#[link(name = "servo",
       vers = "0.1",
       uuid = "637ffc98-9058-471d-9de7-abfc49ef0549",
       url = "http://servo.org/")];

#[comment = "The Servo Parallel Browser Project"];
#[license = "MPL"];
#[crate_type = "lib"];

extern mod azure;
extern mod cairo;
extern mod geom;
extern mod gfx (name = "servo_gfx");
extern mod glut;
extern mod http_client;
extern mod hubbub;
extern mod js;
extern mod layers;
extern mod opengles;
extern mod newcss (name = "css");
extern mod sharegl;
extern mod stb_image;
extern mod std;

pub mod content {
    #[path = "content/content_task.rs"]
    pub mod content_task;
}

pub mod css {
    #[path = "css/select_handler.rs"]
    priv mod select_handler;
    #[path = "css/node_util.rs"]
    priv mod node_util;
    #[path = "css/node_void_ptr.rs"]
    priv mod node_void_ptr;

    #[path = "css/select.rs"]
    pub mod select;
    #[path = "css/matching.rs"]
    pub mod matching;
    #[path = "css/node_style.rs"]
    pub mod node_style;
}

pub mod dom {
    pub mod bindings {
        #[path = "dom/bindings/document.rs"]
        pub mod document;
        #[path = "dom/bindings/element.rs"]
        pub mod element;
        #[path = "dom/bindings/node.rs"]
        pub mod node;
        #[path = "dom/bindings/utils.rs"]
        pub mod utils;
        #[path = "dom/bindings/window.rs"]
        pub mod window;
    }
    #[path = "dom/cow.rs"]
    pub mod cow;
    #[path = "dom/document.rs"]
    pub mod document;
    #[path = "dom/element.rs"]
    pub mod element;
    #[path = "dom/event.rs"]
    pub mod event;
    #[path = "dom/node.rs"]
    pub mod node;
    #[path = "dom/window.rs"]
    pub mod window;
}

pub mod engine;

pub mod layout {
    #[path = "layout/block.rs"]
    pub mod block;
    #[path = "layout/box.rs"]
    pub mod box;
    #[path = "layout/box_builder.rs"]
    pub mod box_builder;
    #[path = "layout/context.rs"]
    pub mod context;
    #[path = "layout/debug.rs"]
    pub mod debug;
    #[path = "layout/display_list_builder.rs"]
    pub mod display_list_builder;
    #[path = "layout/flow.rs"]
    pub mod flow;
    #[path = "layout/layout_task.rs"]
    pub mod layout_task;
    #[path = "layout/inline.rs"]
    pub mod inline;
    #[path = "layout/root.rs"]
    pub mod root;
    #[path = "layout/text.rs"]
    pub mod text;
    #[path = "layout/traverse.rs"]
    pub mod traverse;
    #[path = "layout/aux.rs"]
    mod aux;
}

pub mod html {
    #[path = "html/cssparse.rs"]
    pub mod cssparse;
    #[path = "html/hubbub_html_parser.rs"]
    pub mod hubbub_html_parser;
}

pub mod platform {
    #[path = "platform/base.rs"]
    pub mod base;
    #[path = "platform/osmain.rs"]
    pub mod osmain;
    #[path = "platform/resize_rate_limiter.rs"]
    priv mod resize_rate_limiter;
}

#[path = "util/mod.rs"]
pub mod util;

use servo_util = util;

#[cfg(target_os="macos")]
extern mod core_graphics;
#[cfg(target_os="macos")]
extern mod core_text;

use engine::{Engine, ExitMsg, LoadURLMsg};  // FIXME: "ExitMsg" is pollution.
use platform::osmain::{AddKeyHandler, OSMain};

use core::comm::*;  // FIXME: Bad!
use core::option::swap_unwrap;
use core::pipes::{Port, Chan};

pub use gfx::opts::{Opts, Png, Screen};  // FIXME: Do we really want "Screen" and "Png" visible?
pub use gfx::resource;
pub use gfx::resource::image_cache_task::ImageCacheTask;
pub use gfx::resource::resource_task::ResourceTask;
pub use gfx::text;
pub use gfx::util::url::make_url;

fn main() {
    let args = os::args();
    run(&gfx::opts::from_cmdline_args(args))
}

#[allow(non_implicitly_copyable_typarams)]
fn run(opts: &Opts) {
    match &opts.render_mode {
      &Screen => run_pipeline_screen(opts),
      &Png(ref outfile) => {
        assert opts.urls.is_not_empty();
        if opts.urls.len() > 1u {
            fail ~"servo asks that you stick to a single URL in PNG output mode"
        }
        run_pipeline_png(opts, *outfile)
      }
    }
}

fn run_pipeline_screen(opts: &Opts) {
    let (dom_event_port, dom_event_chan) = pipes::stream();
    let dom_event_chan = pipes::SharedChan(move dom_event_chan);

    // The platform event handler thread
    let osmain = OSMain(dom_event_chan.clone(), copy *opts);

    // Send each file to render then wait for keypress
    let (keypress_from_osmain, keypress_to_engine) = pipes::stream();
    osmain.chan.send(AddKeyHandler(move keypress_to_engine));

    // Create a servo instance
    let resource_task = ResourceTask();
    let image_cache_task = ImageCacheTask(copy resource_task);
    let engine_task = Engine(osmain, opts, move dom_event_port, move dom_event_chan,
                             move resource_task, move image_cache_task);

    for opts.urls.each |filename| {
        let url = make_url(copy *filename, None);
        debug!("master: Sending url `%s`", url.to_str());
        engine_task.send(LoadURLMsg(move url));
        debug!("master: Waiting for keypress");

        match keypress_from_osmain.try_recv() {
          Some(*) => { }
          None => { error!("keypress stream closed unexpectedly") }
        };
    }

    // Shut everything down
    debug!("master: Shut down");
    let (exit_response_from_engine, exit_chan) = pipes::stream();
    engine_task.send(engine::ExitMsg(move exit_chan));
    exit_response_from_engine.recv();

    osmain.chan.send(platform::osmain::Exit);
}

fn run_pipeline_png(_opts: &Opts, _outfile: &str) {
    fail ~"PNG compositor is broken";
}

#[cfg(broken)]
fn run_pipeline_png(url: ~str, outfile: &str) {
    // Use a PNG encoder as the graphics compositor
    use gfx::png_compositor;
    use png_compositor::PngCompositor;
    use io::{Writer, buffered_file_writer};
    use resource::resource_task::ResourceTask;
    use resource::image_cache_task::SyncImageCacheTask;

    listen(|pngdata_from_compositor| {
        let (dom_event_port, dom_event_chan) = pipes::stream();
        let dom_event_chan = pipes::SharedChan(move dom_event_chan);

        let compositor = PngCompositor(pngdata_from_compositor);
        let resource_task = ResourceTask();
        // For the PNG pipeline we are using a synchronous image task so that all images will be
        // fulfilled before the first paint.
        let image_cache_task = SyncImageCacheTask(resource_task);
        let engine_task = Engine(copy compositor, move dom_event_port, move dom_event_chan,
                                 move resource_task, move image_cache_task);
        engine_task.send(LoadURLMsg(make_url(copy url, None)));

        match buffered_file_writer(&Path(outfile)) {
          Ok(writer) => writer.write(pngdata_from_compositor.recv()),
          Err(e) => fail e
        }

        let (exit_chan, exit_response_from_engine) = pipes::stream();
        engine_task.send(engine::ExitMsg(move exit_chan));
        exit_response_from_engine.recv();
        compositor.send(png_compositor::Exit);
    })
}
