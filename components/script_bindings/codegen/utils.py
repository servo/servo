import functools
import re
import textwrap

from components.script_bindings.codegen.codegen import lineStartDetector, compile_fill_template, camel_to_upper_snake

AUTOGENERATED_WARNING_COMMENT = "/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */\n\n"
ALLOWED_WARNING_LIST = ['non_camel_case_types', 'non_upper_case_globals', 'unused_imports',
                        'unused_variables', 'unused_assignments', 'unused_mut',
                        'clippy::approx_constant', 'clippy::enum_variant_names', 'clippy::let_unit_value',
                        'clippy::needless_return', 'clippy::too_many_arguments', 'clippy::unnecessary_cast',
                        'clippy::upper_case_acronyms']


def toStringBool(arg):
    return str(not not arg).lower()


def stripTrailingWhitespace(text):
    tail = '\n' if text.endswith('\n') else ''
    lines = text.splitlines()
    for i in range(len(lines)):
        lines[i] = lines[i].rstrip()
    joined_lines = '\n'.join(lines)
    return f"{joined_lines}{tail}"


def indent(s, indentLevel=2):
    """
    Indent C++ code.

    Weird secret feature: this doesn't indent lines that start with # (such as
    #include lines or #ifdef/#endif).
    """
    if s == "":
        return s
    return re.sub(lineStartDetector, indentLevel * " ", s)


@functools.cache
def dedent(s):
    """
    Remove all leading whitespace from s, and remove a blank line
    at the beginning.
    """
    if s.startswith('\n'):
        s = s[1:]
    return textwrap.dedent(s)


def fill(template, **args):
    """
    Convenience function for filling in a multiline template.

    `fill(template, name1=v1, name2=v2)` is a lot like
    `string.Template(template).substitute({"name1": v1, "name2": v2})`.

    However, it's shorter, and has a few nice features:

      * If `template` is indented, fill() automatically dedents it!
        This makes code using fill() with Python's multiline strings
        much nicer to look at.

      * If `template` starts with a blank line, fill() strips it off.
        (Again, convenient with multiline strings.)

      * fill() recognizes a special kind of substitution
        of the form `$*{name}`.

        Use this to paste in, and automatically indent, multiple lines.
        (Mnemonic: The `*` is for "multiple lines").

        A `$*` substitution must appear by itself on a line, with optional
        preceding indentation (spaces only). The whole line is replaced by the
        corresponding keyword argument, indented appropriately.  If the
        argument is an empty string, no output is generated, not even a blank
        line.
    """

    t, argModList = compile_fill_template(template)
    # Now apply argModList to args
    for (name, modified_name, depth) in argModList:
        if not (args[name] == "" or args[name].endswith("\n")):
            raise ValueError(f"Argument {name} with value {args[name]} is missing a newline")
        args[modified_name] = indent(args[name], depth)

    return t.substitute(args)


def firstCap(string):
    return f"{string[0].upper()}{string[1:]}"


def MemberCondition(pref, func, exposed, secure):
    """
    A string representing the condition for a member to actually be exposed.
    Any of the arguments can be None. If not None, they should have the
    following types:

    pref: The name of the preference.
    func: The name of the function.
    exposed: One or more names of an exposed global.
    secure: Requires secure context.
    """
    assert pref is None or isinstance(pref, str)
    assert func is None or isinstance(func, str)
    assert exposed is None or isinstance(exposed, set)
    assert func is None or pref is None or exposed is None or secure is None
    conditions = []
    if secure:
        conditions.append('Condition::SecureContext()')
    if pref:
        conditions.append(f'Condition::Pref("{pref}")')
    if func:
        conditions.append(f'Condition::Func(D::{func})')
    if exposed:
        conditions.extend([
            f"Condition::Exposed(Globals::{camel_to_upper_snake(i)})" for i in exposed
        ])
    if len(conditions) == 0:
        conditions.append("Condition::Satisfied")
    return conditions
