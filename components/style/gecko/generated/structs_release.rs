/* automatically generated by rust-bindgen */

pub use self::root::*;
pub use self::root::mozilla::*;
pub use self::root::mozilla::css::*;
pub use self::root::mozilla::dom::*;
use atomic_refcell::AtomicRefCell;
use data::ElementData;
pub type ServoUnsafeCell<T> = ::std::cell::UnsafeCell<T>;
pub type ServoCell<T> = ::std::cell::Cell<T>;
pub type ServoNodeData = AtomicRefCell<ElementData>;

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
    impl <T> __BindgenUnionField<T> {
        #[inline]
        pub fn new() -> Self {
            __BindgenUnionField(::std::marker::PhantomData)
        }
        #[inline]
        pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
        #[inline]
        pub unsafe fn as_mut(&mut self) -> &mut T {
            ::std::mem::transmute(self)
        }
    }
    impl <T> ::std::default::Default for __BindgenUnionField<T> {
        #[inline]
        fn default() -> Self { Self::new() }
    }
    impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
        #[inline]
        fn clone(&self) -> Self { Self::new() }
    }
    impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
    impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            fmt.write_str("__BindgenUnionField")
        }
    }
    #[allow(unused_imports)]
    use self::super::root;
    pub const NS_FONT_STYLE_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_STYLE_ITALIC: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_STYLE_OBLIQUE: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_WEIGHT_NORMAL: ::std::os::raw::c_uint = 400;
    pub const NS_FONT_WEIGHT_BOLD: ::std::os::raw::c_uint = 700;
    pub const NS_FONT_WEIGHT_THIN: ::std::os::raw::c_uint = 100;
    pub const NS_FONT_STRETCH_ULTRA_CONDENSED: ::std::os::raw::c_int = -4;
    pub const NS_FONT_STRETCH_EXTRA_CONDENSED: ::std::os::raw::c_int = -3;
    pub const NS_FONT_STRETCH_CONDENSED: ::std::os::raw::c_int = -2;
    pub const NS_FONT_STRETCH_SEMI_CONDENSED: ::std::os::raw::c_int = -1;
    pub const NS_FONT_STRETCH_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_STRETCH_SEMI_EXPANDED: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_STRETCH_EXPANDED: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_STRETCH_EXTRA_EXPANDED: ::std::os::raw::c_uint = 3;
    pub const NS_FONT_STRETCH_ULTRA_EXPANDED: ::std::os::raw::c_uint = 4;
    pub const NS_FONT_SMOOTHING_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_SMOOTHING_GRAYSCALE: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_KERNING_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_KERNING_NONE: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_KERNING_NORMAL: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_SYNTHESIS_WEIGHT: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_SYNTHESIS_STYLE: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_DISPLAY_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_DISPLAY_BLOCK: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_DISPLAY_SWAP: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_DISPLAY_FALLBACK: ::std::os::raw::c_uint = 3;
    pub const NS_FONT_DISPLAY_OPTIONAL: ::std::os::raw::c_uint = 4;
    pub const NS_FONT_VARIANT_ALTERNATES_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_ALTERNATES_HISTORICAL: ::std::os::raw::c_uint =
        1;
    pub const NS_FONT_VARIANT_ALTERNATES_STYLISTIC: ::std::os::raw::c_uint =
        2;
    pub const NS_FONT_VARIANT_ALTERNATES_STYLESET: ::std::os::raw::c_uint = 4;
    pub const NS_FONT_VARIANT_ALTERNATES_CHARACTER_VARIANT:
              ::std::os::raw::c_uint =
        8;
    pub const NS_FONT_VARIANT_ALTERNATES_SWASH: ::std::os::raw::c_uint = 16;
    pub const NS_FONT_VARIANT_ALTERNATES_ORNAMENTS: ::std::os::raw::c_uint =
        32;
    pub const NS_FONT_VARIANT_ALTERNATES_ANNOTATION: ::std::os::raw::c_uint =
        64;
    pub const NS_FONT_VARIANT_ALTERNATES_COUNT: ::std::os::raw::c_uint = 7;
    pub const NS_FONT_VARIANT_ALTERNATES_ENUMERATED_MASK:
              ::std::os::raw::c_uint =
        1;
    pub const NS_FONT_VARIANT_ALTERNATES_FUNCTIONAL_MASK:
              ::std::os::raw::c_uint =
        126;
    pub const NS_FONT_VARIANT_CAPS_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_CAPS_SMALLCAPS: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_VARIANT_CAPS_ALLSMALL: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_VARIANT_CAPS_PETITECAPS: ::std::os::raw::c_uint = 3;
    pub const NS_FONT_VARIANT_CAPS_ALLPETITE: ::std::os::raw::c_uint = 4;
    pub const NS_FONT_VARIANT_CAPS_TITLING: ::std::os::raw::c_uint = 5;
    pub const NS_FONT_VARIANT_CAPS_UNICASE: ::std::os::raw::c_uint = 6;
    pub const NS_FONT_VARIANT_EAST_ASIAN_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_EAST_ASIAN_JIS78: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_VARIANT_EAST_ASIAN_JIS83: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_VARIANT_EAST_ASIAN_JIS90: ::std::os::raw::c_uint = 4;
    pub const NS_FONT_VARIANT_EAST_ASIAN_JIS04: ::std::os::raw::c_uint = 8;
    pub const NS_FONT_VARIANT_EAST_ASIAN_SIMPLIFIED: ::std::os::raw::c_uint =
        16;
    pub const NS_FONT_VARIANT_EAST_ASIAN_TRADITIONAL: ::std::os::raw::c_uint =
        32;
    pub const NS_FONT_VARIANT_EAST_ASIAN_FULL_WIDTH: ::std::os::raw::c_uint =
        64;
    pub const NS_FONT_VARIANT_EAST_ASIAN_PROP_WIDTH: ::std::os::raw::c_uint =
        128;
    pub const NS_FONT_VARIANT_EAST_ASIAN_RUBY: ::std::os::raw::c_uint = 256;
    pub const NS_FONT_VARIANT_EAST_ASIAN_COUNT: ::std::os::raw::c_uint = 9;
    pub const NS_FONT_VARIANT_EAST_ASIAN_VARIANT_MASK: ::std::os::raw::c_uint
              =
        63;
    pub const NS_FONT_VARIANT_EAST_ASIAN_WIDTH_MASK: ::std::os::raw::c_uint =
        192;
    pub const NS_FONT_VARIANT_LIGATURES_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_LIGATURES_NONE: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_VARIANT_LIGATURES_COMMON: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_VARIANT_LIGATURES_NO_COMMON: ::std::os::raw::c_uint = 4;
    pub const NS_FONT_VARIANT_LIGATURES_DISCRETIONARY: ::std::os::raw::c_uint
              =
        8;
    pub const NS_FONT_VARIANT_LIGATURES_NO_DISCRETIONARY:
              ::std::os::raw::c_uint =
        16;
    pub const NS_FONT_VARIANT_LIGATURES_HISTORICAL: ::std::os::raw::c_uint =
        32;
    pub const NS_FONT_VARIANT_LIGATURES_NO_HISTORICAL: ::std::os::raw::c_uint
              =
        64;
    pub const NS_FONT_VARIANT_LIGATURES_CONTEXTUAL: ::std::os::raw::c_uint =
        128;
    pub const NS_FONT_VARIANT_LIGATURES_NO_CONTEXTUAL: ::std::os::raw::c_uint
              =
        256;
    pub const NS_FONT_VARIANT_LIGATURES_COUNT: ::std::os::raw::c_uint = 9;
    pub const NS_FONT_VARIANT_LIGATURES_COMMON_MASK: ::std::os::raw::c_uint =
        6;
    pub const NS_FONT_VARIANT_LIGATURES_DISCRETIONARY_MASK:
              ::std::os::raw::c_uint =
        24;
    pub const NS_FONT_VARIANT_LIGATURES_HISTORICAL_MASK:
              ::std::os::raw::c_uint =
        96;
    pub const NS_FONT_VARIANT_LIGATURES_CONTEXTUAL_MASK:
              ::std::os::raw::c_uint =
        384;
    pub const NS_FONT_VARIANT_NUMERIC_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_NUMERIC_LINING: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_VARIANT_NUMERIC_OLDSTYLE: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_VARIANT_NUMERIC_PROPORTIONAL: ::std::os::raw::c_uint =
        4;
    pub const NS_FONT_VARIANT_NUMERIC_TABULAR: ::std::os::raw::c_uint = 8;
    pub const NS_FONT_VARIANT_NUMERIC_DIAGONAL_FRACTIONS:
              ::std::os::raw::c_uint =
        16;
    pub const NS_FONT_VARIANT_NUMERIC_STACKED_FRACTIONS:
              ::std::os::raw::c_uint =
        32;
    pub const NS_FONT_VARIANT_NUMERIC_SLASHZERO: ::std::os::raw::c_uint = 64;
    pub const NS_FONT_VARIANT_NUMERIC_ORDINAL: ::std::os::raw::c_uint = 128;
    pub const NS_FONT_VARIANT_NUMERIC_COUNT: ::std::os::raw::c_uint = 8;
    pub const NS_FONT_VARIANT_NUMERIC_FIGURE_MASK: ::std::os::raw::c_uint = 3;
    pub const NS_FONT_VARIANT_NUMERIC_SPACING_MASK: ::std::os::raw::c_uint =
        12;
    pub const NS_FONT_VARIANT_NUMERIC_FRACTION_MASK: ::std::os::raw::c_uint =
        48;
    pub const NS_FONT_VARIANT_POSITION_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_POSITION_SUPER: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_VARIANT_POSITION_SUB: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_VARIANT_WIDTH_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_WIDTH_FULL: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_VARIANT_WIDTH_HALF: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_VARIANT_WIDTH_THIRD: ::std::os::raw::c_uint = 3;
    pub const NS_FONT_VARIANT_WIDTH_QUARTER: ::std::os::raw::c_uint = 4;
    pub const NS_FONT_SUBSCRIPT_OFFSET_RATIO: f64 = 0.2;
    pub const NS_FONT_SUPERSCRIPT_OFFSET_RATIO: f64 = 0.34;
    pub const NS_FONT_SUB_SUPER_SIZE_RATIO_SMALL: f64 = 0.82;
    pub const NS_FONT_SUB_SUPER_SIZE_RATIO_LARGE: f64 = 0.667;
    pub const NS_FONT_SUB_SUPER_SMALL_SIZE: f64 = 20.;
    pub const NS_FONT_SUB_SUPER_LARGE_SIZE: f64 = 45.;
    pub const NS_FONT_VARIANT_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_SMALL_CAPS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_AZIMUTH_LEFT_SIDE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_AZIMUTH_FAR_LEFT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_AZIMUTH_LEFT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_AZIMUTH_CENTER_LEFT: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_AZIMUTH_CENTER: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_AZIMUTH_CENTER_RIGHT: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_AZIMUTH_RIGHT: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_AZIMUTH_FAR_RIGHT: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_AZIMUTH_RIGHT_SIDE: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_AZIMUTH_BEHIND: ::std::os::raw::c_uint = 128;
    pub const NS_STYLE_AZIMUTH_LEFTWARDS: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_AZIMUTH_RIGHTWARDS: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_ELEVATION_BELOW: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_ELEVATION_LEVEL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_ELEVATION_ABOVE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_ELEVATION_HIGHER: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_ELEVATION_LOWER: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_PITCH_X_LOW: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PITCH_LOW: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_PITCH_MEDIUM: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_PITCH_HIGH: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_PITCH_X_HIGH: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_SPEAK_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SPEAK_NORMAL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SPEAK_SPELL_OUT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_SPEAK_HEADER_ONCE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SPEAK_HEADER_ALWAYS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SPEAK_NUMERAL_DIGITS: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SPEAK_NUMERAL_CONTINUOUS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SPEAK_PUNCTUATION_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SPEAK_PUNCTUATION_CODE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SPEECH_RATE_X_SLOW: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SPEECH_RATE_SLOW: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SPEECH_RATE_MEDIUM: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_SPEECH_RATE_FAST: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_SPEECH_RATE_X_FAST: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_SPEECH_RATE_FASTER: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_SPEECH_RATE_SLOWER: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_VOLUME_SILENT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_VOLUME_X_SOFT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_VOLUME_SOFT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_VOLUME_MEDIUM: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_VOLUME_LOUD: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_VOLUME_X_LOUD: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_COLOR_INHERIT_FROM_BODY: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_WILL_CHANGE_STACKING_CONTEXT: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_WILL_CHANGE_TRANSFORM: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_WILL_CHANGE_SCROLL: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_WILL_CHANGE_OPACITY: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_WILL_CHANGE_FIXPOS_CB: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_WILL_CHANGE_ABSPOS_CB: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_ANIMATION_ITERATION_COUNT_INFINITE:
              ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_ANIMATION_PLAY_STATE_RUNNING: ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_ANIMATION_PLAY_STATE_PAUSED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_IMAGELAYER_ATTACHMENT_SCROLL: ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_IMAGELAYER_ATTACHMENT_FIXED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_IMAGELAYER_ATTACHMENT_LOCAL: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_IMAGELAYER_CLIP_MOZ_ALMOST_PADDING:
              ::std::os::raw::c_uint =
        127;
    pub const NS_STYLE_IMAGELAYER_POSITION_CENTER: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_IMAGELAYER_POSITION_TOP: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_IMAGELAYER_POSITION_BOTTOM: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_IMAGELAYER_POSITION_LEFT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_IMAGELAYER_POSITION_RIGHT: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_IMAGELAYER_SIZE_CONTAIN: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_IMAGELAYER_SIZE_COVER: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_MASK_MODE_ALPHA: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_MASK_MODE_LUMINANCE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_MASK_MODE_MATCH_SOURCE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_BG_INLINE_POLICY_EACH_BOX: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BG_INLINE_POLICY_CONTINUOUS: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_BG_INLINE_POLICY_BOUNDING_BOX: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_BORDER_COLLAPSE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BORDER_SEPARATE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BORDER_WIDTH_THIN: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BORDER_WIDTH_MEDIUM: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BORDER_WIDTH_THICK: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_BORDER_STYLE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BORDER_STYLE_GROOVE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BORDER_STYLE_RIDGE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_BORDER_STYLE_DOTTED: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_BORDER_STYLE_DASHED: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_BORDER_STYLE_SOLID: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_BORDER_STYLE_DOUBLE: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_BORDER_STYLE_INSET: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_BORDER_STYLE_OUTSET: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_BORDER_STYLE_HIDDEN: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_BORDER_STYLE_AUTO: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_BORDER_IMAGE_REPEAT_STRETCH: ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_BORDER_IMAGE_REPEAT_REPEAT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BORDER_IMAGE_REPEAT_ROUND: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_BORDER_IMAGE_REPEAT_SPACE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_BORDER_IMAGE_SLICE_NOFILL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BORDER_IMAGE_SLICE_FILL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CONTENT_OPEN_QUOTE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CONTENT_CLOSE_QUOTE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CONTENT_NO_OPEN_QUOTE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_CONTENT_NO_CLOSE_QUOTE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_CONTENT_ALT_CONTENT: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_CURSOR_AUTO: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CURSOR_CROSSHAIR: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_CURSOR_DEFAULT: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_CURSOR_POINTER: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_CURSOR_MOVE: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_CURSOR_E_RESIZE: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_CURSOR_NE_RESIZE: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_CURSOR_NW_RESIZE: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_CURSOR_N_RESIZE: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_CURSOR_SE_RESIZE: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_CURSOR_SW_RESIZE: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_CURSOR_S_RESIZE: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_CURSOR_W_RESIZE: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_CURSOR_TEXT: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_CURSOR_WAIT: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_CURSOR_HELP: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_CURSOR_COPY: ::std::os::raw::c_uint = 17;
    pub const NS_STYLE_CURSOR_ALIAS: ::std::os::raw::c_uint = 18;
    pub const NS_STYLE_CURSOR_CONTEXT_MENU: ::std::os::raw::c_uint = 19;
    pub const NS_STYLE_CURSOR_CELL: ::std::os::raw::c_uint = 20;
    pub const NS_STYLE_CURSOR_GRAB: ::std::os::raw::c_uint = 21;
    pub const NS_STYLE_CURSOR_GRABBING: ::std::os::raw::c_uint = 22;
    pub const NS_STYLE_CURSOR_SPINNING: ::std::os::raw::c_uint = 23;
    pub const NS_STYLE_CURSOR_ZOOM_IN: ::std::os::raw::c_uint = 24;
    pub const NS_STYLE_CURSOR_ZOOM_OUT: ::std::os::raw::c_uint = 25;
    pub const NS_STYLE_CURSOR_NOT_ALLOWED: ::std::os::raw::c_uint = 26;
    pub const NS_STYLE_CURSOR_COL_RESIZE: ::std::os::raw::c_uint = 27;
    pub const NS_STYLE_CURSOR_ROW_RESIZE: ::std::os::raw::c_uint = 28;
    pub const NS_STYLE_CURSOR_NO_DROP: ::std::os::raw::c_uint = 29;
    pub const NS_STYLE_CURSOR_VERTICAL_TEXT: ::std::os::raw::c_uint = 30;
    pub const NS_STYLE_CURSOR_ALL_SCROLL: ::std::os::raw::c_uint = 31;
    pub const NS_STYLE_CURSOR_NESW_RESIZE: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_CURSOR_NWSE_RESIZE: ::std::os::raw::c_uint = 33;
    pub const NS_STYLE_CURSOR_NS_RESIZE: ::std::os::raw::c_uint = 34;
    pub const NS_STYLE_CURSOR_EW_RESIZE: ::std::os::raw::c_uint = 35;
    pub const NS_STYLE_CURSOR_NONE: ::std::os::raw::c_uint = 36;
    pub const NS_STYLE_DIRECTION_LTR: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_DIRECTION_RTL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WRITING_MODE_HORIZONTAL_TB: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_WRITING_MODE_VERTICAL_RL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WRITING_MODE_VERTICAL_LR: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_WRITING_MODE_SIDEWAYS_MASK: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_WRITING_MODE_SIDEWAYS_RL: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_WRITING_MODE_SIDEWAYS_LR: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_CONTAIN_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CONTAIN_STRICT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CONTAIN_LAYOUT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_CONTAIN_STYLE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_CONTAIN_PAINT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_CONTAIN_ALL_BITS: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_ALIGN_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_ALIGN_NORMAL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_ALIGN_START: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_ALIGN_END: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_ALIGN_FLEX_START: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_ALIGN_FLEX_END: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_ALIGN_CENTER: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_ALIGN_LEFT: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_ALIGN_RIGHT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_ALIGN_BASELINE: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_ALIGN_LAST_BASELINE: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_ALIGN_STRETCH: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_ALIGN_SELF_START: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_ALIGN_SELF_END: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_ALIGN_SPACE_BETWEEN: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_ALIGN_SPACE_AROUND: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_ALIGN_SPACE_EVENLY: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_ALIGN_LEGACY: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_ALIGN_SAFE: ::std::os::raw::c_uint = 64;
    pub const NS_STYLE_ALIGN_UNSAFE: ::std::os::raw::c_uint = 128;
    pub const NS_STYLE_ALIGN_FLAG_BITS: ::std::os::raw::c_uint = 224;
    pub const NS_STYLE_ALIGN_ALL_BITS: ::std::os::raw::c_uint = 255;
    pub const NS_STYLE_ALIGN_ALL_SHIFT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_JUSTIFY_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_JUSTIFY_NORMAL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_JUSTIFY_START: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_JUSTIFY_END: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_JUSTIFY_FLEX_START: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_JUSTIFY_FLEX_END: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_JUSTIFY_CENTER: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_JUSTIFY_LEFT: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_JUSTIFY_RIGHT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_JUSTIFY_BASELINE: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_JUSTIFY_LAST_BASELINE: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_JUSTIFY_STRETCH: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_JUSTIFY_SELF_START: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_JUSTIFY_SELF_END: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_JUSTIFY_SPACE_BETWEEN: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_JUSTIFY_SPACE_AROUND: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_JUSTIFY_SPACE_EVENLY: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_JUSTIFY_LEGACY: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_JUSTIFY_SAFE: ::std::os::raw::c_uint = 64;
    pub const NS_STYLE_JUSTIFY_UNSAFE: ::std::os::raw::c_uint = 128;
    pub const NS_STYLE_JUSTIFY_FLAG_BITS: ::std::os::raw::c_uint = 224;
    pub const NS_STYLE_JUSTIFY_ALL_BITS: ::std::os::raw::c_uint = 255;
    pub const NS_STYLE_JUSTIFY_ALL_SHIFT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_FLEX_DIRECTION_ROW: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FLEX_DIRECTION_ROW_REVERSE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FLEX_DIRECTION_COLUMN: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FLEX_DIRECTION_COLUMN_REVERSE: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_FLEX_WRAP_NOWRAP: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FLEX_WRAP_WRAP: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FLEX_WRAP_WRAP_REVERSE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_ORDER_INITIAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_JUSTIFY_CONTENT_FLEX_START: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_JUSTIFY_CONTENT_FLEX_END: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_JUSTIFY_CONTENT_CENTER: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_JUSTIFY_CONTENT_SPACE_BETWEEN: ::std::os::raw::c_uint =
        14;
    pub const NS_STYLE_JUSTIFY_CONTENT_SPACE_AROUND: ::std::os::raw::c_uint =
        15;
    pub const NS_STYLE_FILTER_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FILTER_URL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FILTER_BLUR: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FILTER_BRIGHTNESS: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_FILTER_CONTRAST: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_FILTER_GRAYSCALE: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_FILTER_INVERT: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_FILTER_OPACITY: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_FILTER_SATURATE: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_FILTER_SEPIA: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_FILTER_HUE_ROTATE: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_FILTER_DROP_SHADOW: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_FONT_STYLE_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FONT_STYLE_ITALIC: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FONT_STYLE_OBLIQUE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FONT_WEIGHT_NORMAL: ::std::os::raw::c_uint = 400;
    pub const NS_STYLE_FONT_WEIGHT_BOLD: ::std::os::raw::c_uint = 700;
    pub const NS_STYLE_FONT_WEIGHT_BOLDER: ::std::os::raw::c_int = -1;
    pub const NS_STYLE_FONT_WEIGHT_LIGHTER: ::std::os::raw::c_int = -2;
    pub const NS_STYLE_FONT_SIZE_XXSMALL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FONT_SIZE_XSMALL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FONT_SIZE_SMALL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FONT_SIZE_MEDIUM: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_FONT_SIZE_LARGE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_FONT_SIZE_XLARGE: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_FONT_SIZE_XXLARGE: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_FONT_SIZE_XXXLARGE: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_FONT_SIZE_LARGER: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_FONT_SIZE_SMALLER: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_FONT_STRETCH_ULTRA_CONDENSED: ::std::os::raw::c_int =
        -4;
    pub const NS_STYLE_FONT_STRETCH_EXTRA_CONDENSED: ::std::os::raw::c_int =
        -3;
    pub const NS_STYLE_FONT_STRETCH_CONDENSED: ::std::os::raw::c_int = -2;
    pub const NS_STYLE_FONT_STRETCH_SEMI_CONDENSED: ::std::os::raw::c_int =
        -1;
    pub const NS_STYLE_FONT_STRETCH_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FONT_STRETCH_SEMI_EXPANDED: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FONT_STRETCH_EXPANDED: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FONT_STRETCH_EXTRA_EXPANDED: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_FONT_STRETCH_ULTRA_EXPANDED: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_FONT_CAPTION: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FONT_ICON: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FONT_MENU: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_FONT_MESSAGE_BOX: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_FONT_SMALL_CAPTION: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_FONT_STATUS_BAR: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_FONT_WINDOW: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_FONT_DOCUMENT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_FONT_WORKSPACE: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_FONT_DESKTOP: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_FONT_INFO: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_FONT_DIALOG: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_FONT_BUTTON: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_FONT_PULL_DOWN_MENU: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_FONT_LIST: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_FONT_FIELD: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_GRID_AUTO_FLOW_ROW: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_GRID_AUTO_FLOW_COLUMN: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_GRID_AUTO_FLOW_DENSE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_GRID_TEMPLATE_SUBGRID: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_GRID_REPEAT_AUTO_FILL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_GRID_REPEAT_AUTO_FIT: ::std::os::raw::c_uint = 1;
    pub const NS_MATHML_DEFAULT_SCRIPT_SIZE_MULTIPLIER: f64 = 0.71;
    pub const NS_MATHML_DEFAULT_SCRIPT_MIN_SIZE_PT: ::std::os::raw::c_uint =
        8;
    pub const NS_MATHML_MATHVARIANT_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_MATHML_MATHVARIANT_NORMAL: ::std::os::raw::c_uint = 1;
    pub const NS_MATHML_MATHVARIANT_BOLD: ::std::os::raw::c_uint = 2;
    pub const NS_MATHML_MATHVARIANT_ITALIC: ::std::os::raw::c_uint = 3;
    pub const NS_MATHML_MATHVARIANT_BOLD_ITALIC: ::std::os::raw::c_uint = 4;
    pub const NS_MATHML_MATHVARIANT_SCRIPT: ::std::os::raw::c_uint = 5;
    pub const NS_MATHML_MATHVARIANT_BOLD_SCRIPT: ::std::os::raw::c_uint = 6;
    pub const NS_MATHML_MATHVARIANT_FRAKTUR: ::std::os::raw::c_uint = 7;
    pub const NS_MATHML_MATHVARIANT_DOUBLE_STRUCK: ::std::os::raw::c_uint = 8;
    pub const NS_MATHML_MATHVARIANT_BOLD_FRAKTUR: ::std::os::raw::c_uint = 9;
    pub const NS_MATHML_MATHVARIANT_SANS_SERIF: ::std::os::raw::c_uint = 10;
    pub const NS_MATHML_MATHVARIANT_BOLD_SANS_SERIF: ::std::os::raw::c_uint =
        11;
    pub const NS_MATHML_MATHVARIANT_SANS_SERIF_ITALIC: ::std::os::raw::c_uint
              =
        12;
    pub const NS_MATHML_MATHVARIANT_SANS_SERIF_BOLD_ITALIC:
              ::std::os::raw::c_uint =
        13;
    pub const NS_MATHML_MATHVARIANT_MONOSPACE: ::std::os::raw::c_uint = 14;
    pub const NS_MATHML_MATHVARIANT_INITIAL: ::std::os::raw::c_uint = 15;
    pub const NS_MATHML_MATHVARIANT_TAILED: ::std::os::raw::c_uint = 16;
    pub const NS_MATHML_MATHVARIANT_LOOPED: ::std::os::raw::c_uint = 17;
    pub const NS_MATHML_MATHVARIANT_STRETCHED: ::std::os::raw::c_uint = 18;
    pub const NS_MATHML_DISPLAYSTYLE_INLINE: ::std::os::raw::c_uint = 0;
    pub const NS_MATHML_DISPLAYSTYLE_BLOCK: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WIDTH_MAX_CONTENT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_WIDTH_MIN_CONTENT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WIDTH_FIT_CONTENT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_WIDTH_AVAILABLE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_POSITION_STATIC: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_POSITION_RELATIVE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_POSITION_ABSOLUTE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_POSITION_FIXED: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_POSITION_STICKY: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_CLIP_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CLIP_RECT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CLIP_TYPE_MASK: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_CLIP_LEFT_AUTO: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_CLIP_TOP_AUTO: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_CLIP_RIGHT_AUTO: ::std::os::raw::c_uint = 64;
    pub const NS_STYLE_CLIP_BOTTOM_AUTO: ::std::os::raw::c_uint = 128;
    pub const NS_STYLE_FRAME_YES: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FRAME_NO: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FRAME_0: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FRAME_1: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_FRAME_ON: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_FRAME_OFF: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_FRAME_AUTO: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_FRAME_SCROLL: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_FRAME_NOSCROLL: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_OVERFLOW_VISIBLE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_OVERFLOW_HIDDEN: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_OVERFLOW_SCROLL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_OVERFLOW_AUTO: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_OVERFLOW_CLIP: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_OVERFLOW_SCROLLBARS_HORIZONTAL: ::std::os::raw::c_uint
              =
        5;
    pub const NS_STYLE_OVERFLOW_SCROLLBARS_VERTICAL: ::std::os::raw::c_uint =
        6;
    pub const NS_STYLE_OVERFLOW_CLIP_BOX_PADDING_BOX: ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_OVERFLOW_CLIP_BOX_CONTENT_BOX: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_LIST_STYLE_CUSTOM: ::std::os::raw::c_int = -1;
    pub const NS_STYLE_LIST_STYLE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_LIST_STYLE_DISC: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_LIST_STYLE_CIRCLE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_LIST_STYLE_SQUARE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_LIST_STYLE_DECIMAL: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_LIST_STYLE_HEBREW: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_LIST_STYLE_JAPANESE_INFORMAL: ::std::os::raw::c_uint =
        6;
    pub const NS_STYLE_LIST_STYLE_JAPANESE_FORMAL: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_LIST_STYLE_KOREAN_HANGUL_FORMAL: ::std::os::raw::c_uint
              =
        8;
    pub const NS_STYLE_LIST_STYLE_KOREAN_HANJA_INFORMAL:
              ::std::os::raw::c_uint =
        9;
    pub const NS_STYLE_LIST_STYLE_KOREAN_HANJA_FORMAL: ::std::os::raw::c_uint
              =
        10;
    pub const NS_STYLE_LIST_STYLE_SIMP_CHINESE_INFORMAL:
              ::std::os::raw::c_uint =
        11;
    pub const NS_STYLE_LIST_STYLE_SIMP_CHINESE_FORMAL: ::std::os::raw::c_uint
              =
        12;
    pub const NS_STYLE_LIST_STYLE_TRAD_CHINESE_INFORMAL:
              ::std::os::raw::c_uint =
        13;
    pub const NS_STYLE_LIST_STYLE_TRAD_CHINESE_FORMAL: ::std::os::raw::c_uint
              =
        14;
    pub const NS_STYLE_LIST_STYLE_ETHIOPIC_NUMERIC: ::std::os::raw::c_uint =
        15;
    pub const NS_STYLE_LIST_STYLE_DISCLOSURE_CLOSED: ::std::os::raw::c_uint =
        16;
    pub const NS_STYLE_LIST_STYLE_DISCLOSURE_OPEN: ::std::os::raw::c_uint =
        17;
    pub const NS_STYLE_LIST_STYLE__MAX: ::std::os::raw::c_uint = 18;
    pub const NS_STYLE_LIST_STYLE_LOWER_ROMAN: ::std::os::raw::c_uint = 100;
    pub const NS_STYLE_LIST_STYLE_UPPER_ROMAN: ::std::os::raw::c_uint = 101;
    pub const NS_STYLE_LIST_STYLE_LOWER_ALPHA: ::std::os::raw::c_uint = 102;
    pub const NS_STYLE_LIST_STYLE_UPPER_ALPHA: ::std::os::raw::c_uint = 103;
    pub const NS_STYLE_LIST_STYLE_POSITION_INSIDE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_LIST_STYLE_POSITION_OUTSIDE: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_MARGIN_SIZE_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_POINTER_EVENTS_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_POINTER_EVENTS_VISIBLEPAINTED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_POINTER_EVENTS_VISIBLEFILL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_POINTER_EVENTS_VISIBLESTROKE: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_POINTER_EVENTS_VISIBLE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_POINTER_EVENTS_PAINTED: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_POINTER_EVENTS_FILL: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_POINTER_EVENTS_STROKE: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_POINTER_EVENTS_ALL: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_POINTER_EVENTS_AUTO: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_IMAGE_ORIENTATION_FLIP: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_IMAGE_ORIENTATION_FROM_IMAGE: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_ISOLATION_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_ISOLATION_ISOLATE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_OBJECT_FIT_FILL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_OBJECT_FIT_CONTAIN: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_OBJECT_FIT_COVER: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_OBJECT_FIT_NONE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_OBJECT_FIT_SCALE_DOWN: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_RESIZE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_RESIZE_BOTH: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_RESIZE_HORIZONTAL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_RESIZE_VERTICAL: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_TEXT_ALIGN_START: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_ALIGN_LEFT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_ALIGN_RIGHT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_ALIGN_CENTER: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_TEXT_ALIGN_JUSTIFY: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_TEXT_ALIGN_CHAR: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_TEXT_ALIGN_END: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_TEXT_ALIGN_AUTO: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_TEXT_ALIGN_MOZ_CENTER: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_TEXT_ALIGN_MOZ_RIGHT: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_TEXT_ALIGN_MOZ_LEFT: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_TEXT_ALIGN_MOZ_CENTER_OR_INHERIT:
              ::std::os::raw::c_uint =
        11;
    pub const NS_STYLE_TEXT_ALIGN_UNSAFE: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_TEXT_ALIGN_MATCH_PARENT: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_TEXT_DECORATION_LINE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE: ::std::os::raw::c_uint
              =
        1;
    pub const NS_STYLE_TEXT_DECORATION_LINE_OVERLINE: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH:
              ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_TEXT_DECORATION_LINE_BLINK: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_TEXT_DECORATION_LINE_OVERRIDE_ALL:
              ::std::os::raw::c_uint =
        16;
    pub const NS_STYLE_TEXT_DECORATION_LINE_LINES_MASK: ::std::os::raw::c_uint
              =
        7;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_DOTTED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_DASHED: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_SOLID: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_DOUBLE: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_WAVY: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_MAX: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_TEXT_OVERFLOW_CLIP: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_OVERFLOW_ELLIPSIS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_OVERFLOW_STRING: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_TRANSFORM_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_TRANSFORM_CAPITALIZE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_TRANSFORM_LOWERCASE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_TRANSFORM_UPPERCASE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_TEXT_TRANSFORM_FULL_WIDTH: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_TOUCH_ACTION_NONE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TOUCH_ACTION_AUTO: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TOUCH_ACTION_PAN_X: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_TOUCH_ACTION_PAN_Y: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_TOUCH_ACTION_MANIPULATION: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_TOP_LAYER_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TOP_LAYER_TOP: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE: ::std::os::raw::c_uint
              =
        0;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_LINEAR:
              ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN:
              ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_OUT:
              ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN_OUT:
              ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_STEP_START:
              ::std::os::raw::c_uint =
        5;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_STEP_END:
              ::std::os::raw::c_uint =
        6;
    pub const NS_STYLE_VERTICAL_ALIGN_BASELINE: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_VERTICAL_ALIGN_SUB: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_VERTICAL_ALIGN_SUPER: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_VERTICAL_ALIGN_TOP: ::std::os::raw::c_uint = 17;
    pub const NS_STYLE_VERTICAL_ALIGN_TEXT_TOP: ::std::os::raw::c_uint = 18;
    pub const NS_STYLE_VERTICAL_ALIGN_MIDDLE: ::std::os::raw::c_uint = 19;
    pub const NS_STYLE_VERTICAL_ALIGN_TEXT_BOTTOM: ::std::os::raw::c_uint =
        20;
    pub const NS_STYLE_VERTICAL_ALIGN_BOTTOM: ::std::os::raw::c_uint = 21;
    pub const NS_STYLE_VERTICAL_ALIGN_MIDDLE_WITH_BASELINE:
              ::std::os::raw::c_uint =
        22;
    pub const NS_STYLE_VISIBILITY_HIDDEN: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_VISIBILITY_VISIBLE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_VISIBILITY_COLLAPSE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TABSIZE_INITIAL: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_WORDBREAK_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_WORDBREAK_BREAK_ALL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WORDBREAK_KEEP_ALL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_OVERFLOWWRAP_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_OVERFLOWWRAP_BREAK_WORD: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_RUBY_ALIGN_START: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_RUBY_ALIGN_CENTER: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_RUBY_ALIGN_SPACE_BETWEEN: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_RUBY_ALIGN_SPACE_AROUND: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_RUBY_POSITION_OVER: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_RUBY_POSITION_UNDER: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_RUBY_POSITION_INTER_CHARACTER: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_SIZE_ADJUST_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_SIZE_ADJUST_AUTO: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_ORIENTATION_MIXED: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_ORIENTATION_UPRIGHT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_ORIENTATION_SIDEWAYS: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_ALL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_DIGITS_2: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_DIGITS_3: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_DIGITS_4: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_LINE_HEIGHT_BLOCK_HEIGHT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_UNICODE_BIDI_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_UNICODE_BIDI_EMBED: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_UNICODE_BIDI_ISOLATE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_UNICODE_BIDI_BIDI_OVERRIDE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_UNICODE_BIDI_ISOLATE_OVERRIDE: ::std::os::raw::c_uint =
        6;
    pub const NS_STYLE_UNICODE_BIDI_PLAINTEXT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_TABLE_LAYOUT_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TABLE_LAYOUT_FIXED: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TABLE_EMPTY_CELLS_HIDE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TABLE_EMPTY_CELLS_SHOW: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CAPTION_SIDE_TOP: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CAPTION_SIDE_RIGHT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CAPTION_SIDE_BOTTOM: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_CAPTION_SIDE_LEFT: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE: ::std::os::raw::c_uint =
        5;
    pub const NS_STYLE_CELL_SCOPE_ROW: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CELL_SCOPE_COL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CELL_SCOPE_ROWGROUP: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_CELL_SCOPE_COLGROUP: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_PAGE_MARKS_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_PAGE_MARKS_CROP: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PAGE_MARKS_REGISTER: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_PAGE_SIZE_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_PAGE_SIZE_PORTRAIT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PAGE_SIZE_LANDSCAPE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_PAGE_BREAK_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_PAGE_BREAK_ALWAYS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PAGE_BREAK_AVOID: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_PAGE_BREAK_LEFT: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_PAGE_BREAK_RIGHT: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_COLUMN_COUNT_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COLUMN_COUNT_UNLIMITED: ::std::os::raw::c_int = -1;
    pub const NS_STYLE_COLUMN_FILL_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COLUMN_FILL_BALANCE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_COLUMN_SPAN_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COLUMN_SPAN_ALL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_IME_MODE_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_IME_MODE_NORMAL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_IME_MODE_ACTIVE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_IME_MODE_DISABLED: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_IME_MODE_INACTIVE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_GRADIENT_SHAPE_LINEAR: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_GRADIENT_SHAPE_ELLIPTICAL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_GRADIENT_SHAPE_CIRCULAR: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_GRADIENT_SIZE_CLOSEST_SIDE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_GRADIENT_SIZE_CLOSEST_CORNER: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_GRADIENT_SIZE_FARTHEST_SIDE: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_GRADIENT_SIZE_FARTHEST_CORNER: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_GRADIENT_SIZE_EXPLICIT_SIZE: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_CONTEXT_PROPERTY_FILL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CONTEXT_PROPERTY_STROKE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_CONTEXT_PROPERTY_FILL_OPACITY: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_CONTEXT_PROPERTY_STROKE_OPACITY: ::std::os::raw::c_uint
              =
        8;
    pub const NS_STYLE_WINDOW_SHADOW_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_WINDOW_SHADOW_DEFAULT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WINDOW_SHADOW_MENU: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_WINDOW_SHADOW_TOOLTIP: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_WINDOW_SHADOW_SHEET: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_DOMINANT_BASELINE_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_DOMINANT_BASELINE_USE_SCRIPT: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_DOMINANT_BASELINE_NO_CHANGE: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_DOMINANT_BASELINE_RESET_SIZE: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_DOMINANT_BASELINE_IDEOGRAPHIC: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_DOMINANT_BASELINE_ALPHABETIC: ::std::os::raw::c_uint =
        5;
    pub const NS_STYLE_DOMINANT_BASELINE_HANGING: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_DOMINANT_BASELINE_MATHEMATICAL: ::std::os::raw::c_uint
              =
        7;
    pub const NS_STYLE_DOMINANT_BASELINE_CENTRAL: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_DOMINANT_BASELINE_MIDDLE: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_DOMINANT_BASELINE_TEXT_AFTER_EDGE:
              ::std::os::raw::c_uint =
        10;
    pub const NS_STYLE_DOMINANT_BASELINE_TEXT_BEFORE_EDGE:
              ::std::os::raw::c_uint =
        11;
    pub const NS_STYLE_IMAGE_RENDERING_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_IMAGE_RENDERING_OPTIMIZESPEED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_IMAGE_RENDERING_OPTIMIZEQUALITY: ::std::os::raw::c_uint
              =
        2;
    pub const NS_STYLE_IMAGE_RENDERING_CRISPEDGES: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_MASK_TYPE_LUMINANCE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_MASK_TYPE_ALPHA: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PAINT_ORDER_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_PAINT_ORDER_FILL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PAINT_ORDER_STROKE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_PAINT_ORDER_MARKERS: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_PAINT_ORDER_LAST_VALUE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_PAINT_ORDER_BITWIDTH: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_SHAPE_RENDERING_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SHAPE_RENDERING_OPTIMIZESPEED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_SHAPE_RENDERING_CRISPEDGES: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_SHAPE_RENDERING_GEOMETRICPRECISION:
              ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_STROKE_LINECAP_BUTT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_STROKE_LINECAP_ROUND: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_STROKE_LINECAP_SQUARE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_STROKE_LINEJOIN_MITER: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_STROKE_LINEJOIN_ROUND: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_STROKE_LINEJOIN_BEVEL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_STROKE_PROP_CONTEXT_VALUE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_ANCHOR_START: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_ANCHOR_MIDDLE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_ANCHOR_END: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_OVER: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_UNDER: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_LEFT: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_RIGHT: ::std::os::raw::c_uint =
        8;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_DEFAULT: ::std::os::raw::c_uint
              =
        9;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_DEFAULT_ZH:
              ::std::os::raw::c_uint =
        10;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_FILL_MASK: ::std::os::raw::c_uint =
        8;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_FILLED: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_OPEN: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_SHAPE_MASK: ::std::os::raw::c_uint
              =
        7;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_DOT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_CIRCLE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_DOUBLE_CIRCLE:
              ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_TRIANGLE: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_SESAME: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_STRING: ::std::os::raw::c_uint =
        255;
    pub const NS_STYLE_TEXT_RENDERING_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_RENDERING_OPTIMIZESPEED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_TEXT_RENDERING_OPTIMIZELEGIBILITY:
              ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_RENDERING_GEOMETRICPRECISION:
              ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_COLOR_ADJUST_ECONOMY: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COLOR_ADJUST_EXACT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_COLOR_INTERPOLATION_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COLOR_INTERPOLATION_SRGB: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_COLOR_INTERPOLATION_LINEARRGB: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_VECTOR_EFFECT_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_VECTOR_EFFECT_NON_SCALING_STROKE:
              ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_BACKFACE_VISIBILITY_VISIBLE: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_BACKFACE_VISIBILITY_HIDDEN: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TRANSFORM_STYLE_FLAT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TRANSFORM_STYLE_PRESERVE_3D: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_CONTEXT_FILL_OPACITY: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CONTEXT_STROKE_OPACITY: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BLEND_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BLEND_MULTIPLY: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BLEND_SCREEN: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_BLEND_OVERLAY: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_BLEND_DARKEN: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_BLEND_LIGHTEN: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_BLEND_COLOR_DODGE: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_BLEND_COLOR_BURN: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_BLEND_HARD_LIGHT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_BLEND_SOFT_LIGHT: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_BLEND_DIFFERENCE: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_BLEND_EXCLUSION: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_BLEND_HUE: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_BLEND_SATURATION: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_BLEND_COLOR: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_BLEND_LUMINOSITY: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_MASK_COMPOSITE_ADD: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_MASK_COMPOSITE_SUBTRACT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_MASK_COMPOSITE_INTERSECT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_MASK_COMPOSITE_EXCLUDE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_CONTROL_CHARACTER_VISIBILITY_HIDDEN:
              ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_CONTROL_CHARACTER_VISIBILITY_VISIBLE:
              ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_COUNTER_SYSTEM_CYCLIC: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COUNTER_SYSTEM_NUMERIC: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_COUNTER_SYSTEM_ALPHABETIC: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_COUNTER_SYSTEM_SYMBOLIC: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_COUNTER_SYSTEM_ADDITIVE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_COUNTER_SYSTEM_FIXED: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_COUNTER_SYSTEM_EXTENDS: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_COUNTER_RANGE_INFINITE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COUNTER_SPEAKAS_BULLETS: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COUNTER_SPEAKAS_NUMBERS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_COUNTER_SPEAKAS_WORDS: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_COUNTER_SPEAKAS_SPELL_OUT: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_COUNTER_SPEAKAS_OTHER: ::std::os::raw::c_uint = 255;
    pub const NS_STYLE_SCROLL_BEHAVIOR_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SCROLL_BEHAVIOR_SMOOTH: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SCROLL_SNAP_TYPE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SCROLL_SNAP_TYPE_MANDATORY: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SCROLL_SNAP_TYPE_PROXIMITY: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_ORIENTATION_PORTRAIT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_ORIENTATION_LANDSCAPE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SCAN_PROGRESSIVE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SCAN_INTERLACE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_DISPLAY_MODE_BROWSER: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_DISPLAY_MODE_MINIMAL_UI: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_DISPLAY_MODE_STANDALONE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_DISPLAY_MODE_FULLSCREEN: ::std::os::raw::c_uint = 3;
    pub const CSS_PSEUDO_ELEMENT_IS_CSS2: ::std::os::raw::c_uint = 1;
    pub const CSS_PSEUDO_ELEMENT_CONTAINS_ELEMENTS: ::std::os::raw::c_uint =
        2;
    pub const CSS_PSEUDO_ELEMENT_SUPPORTS_STYLE_ATTRIBUTE:
              ::std::os::raw::c_uint =
        4;
    pub const CSS_PSEUDO_ELEMENT_SUPPORTS_USER_ACTION_STATE:
              ::std::os::raw::c_uint =
        8;
    pub const CSS_PSEUDO_ELEMENT_UA_SHEET_ONLY: ::std::os::raw::c_uint = 16;
    pub const CSS_PSEUDO_ELEMENT_IS_JS_CREATED_NAC: ::std::os::raw::c_uint =
        32;
    pub const kNameSpaceID_Unknown: ::std::os::raw::c_int = -1;
    pub const kNameSpaceID_XMLNS: ::std::os::raw::c_uint = 1;
    pub const kNameSpaceID_XML: ::std::os::raw::c_uint = 2;
    pub const kNameSpaceID_XHTML: ::std::os::raw::c_uint = 3;
    pub const kNameSpaceID_XLink: ::std::os::raw::c_uint = 4;
    pub const kNameSpaceID_XSLT: ::std::os::raw::c_uint = 5;
    pub const kNameSpaceID_XBL: ::std::os::raw::c_uint = 6;
    pub const kNameSpaceID_MathML: ::std::os::raw::c_uint = 7;
    pub const kNameSpaceID_RDF: ::std::os::raw::c_uint = 8;
    pub const kNameSpaceID_XUL: ::std::os::raw::c_uint = 9;
    pub const kNameSpaceID_SVG: ::std::os::raw::c_uint = 10;
    pub const kNameSpaceID_disabled_MathML: ::std::os::raw::c_uint = 11;
    pub const kNameSpaceID_disabled_SVG: ::std::os::raw::c_uint = 12;
    pub const kNameSpaceID_LastBuiltin: ::std::os::raw::c_uint = 12;
    pub const kNameSpaceID_Wildcard: ::std::os::raw::c_int = -2147483648;
    pub const NS_AUTHOR_SPECIFIED_BACKGROUND: ::std::os::raw::c_uint = 1;
    pub const NS_AUTHOR_SPECIFIED_BORDER: ::std::os::raw::c_uint = 2;
    pub const NS_AUTHOR_SPECIFIED_PADDING: ::std::os::raw::c_uint = 4;
    pub const NS_AUTHOR_SPECIFIED_TEXT_SHADOW: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_INHERIT_MASK: ::std::os::raw::c_uint = 16777215;
    pub const NS_STYLE_HAS_TEXT_DECORATION_LINES: ::std::os::raw::c_uint =
        16777216;
    pub const NS_STYLE_HAS_PSEUDO_ELEMENT_DATA: ::std::os::raw::c_uint =
        33554432;
    pub const NS_STYLE_RELEVANT_LINK_VISITED: ::std::os::raw::c_uint =
        67108864;
    pub const NS_STYLE_IS_STYLE_IF_VISITED: ::std::os::raw::c_uint =
        134217728;
    pub const NS_STYLE_CHILD_USES_GRANDANCESTOR_STYLE: ::std::os::raw::c_uint
              =
        268435456;
    pub const NS_STYLE_IS_SHARED: ::std::os::raw::c_uint = 536870912;
    pub const NS_STYLE_IS_GOING_AWAY: ::std::os::raw::c_uint = 1073741824;
    pub const NS_STYLE_SUPPRESS_LINEBREAK: ::std::os::raw::c_uint =
        2147483648;
    pub const NS_STYLE_IN_DISPLAY_NONE_SUBTREE: ::std::os::raw::c_ulonglong =
        4294967296;
    pub const NS_STYLE_INELIGIBLE_FOR_SHARING: ::std::os::raw::c_ulonglong =
        8589934592;
    pub const NS_STYLE_HAS_CHILD_THAT_USES_RESET_STYLE:
              ::std::os::raw::c_ulonglong =
        17179869184;
    pub const NS_STYLE_IS_TEXT_COMBINED: ::std::os::raw::c_ulonglong =
        34359738368;
    pub const NS_STYLE_CONTEXT_IS_GECKO: ::std::os::raw::c_ulonglong =
        68719476736;
    pub const NS_STYLE_CONTEXT_TYPE_SHIFT: ::std::os::raw::c_uint = 37;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pair<_T1, _T2> {
            pub first: _T1,
            pub second: _T2,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T1>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T2>>,
        }
        pub type pair_first_type<_T1> = _T1;
        pub type pair_second_type<_T2> = _T2;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct input_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_input_iterator_tag() {
            assert_eq!(::std::mem::size_of::<input_iterator_tag>() , 1usize ,
                       concat ! (
                       "Size of: " , stringify ! ( input_iterator_tag ) ));
            assert_eq! (::std::mem::align_of::<input_iterator_tag>() , 1usize
                        , concat ! (
                        "Alignment of " , stringify ! ( input_iterator_tag )
                        ));
        }
        impl Clone for input_iterator_tag {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_iterator_category<_Category> = _Category;
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        #[repr(C)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        pub struct reverse_iterator<_Iterator> {
            pub current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type reverse_iterator___traits_type = root::std::iterator_traits;
        pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
        pub type reverse_iterator_difference_type =
            root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_pointer =
            root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_reference =
            root::std::reverse_iterator___traits_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct atomic {
        }
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub mod mozilla {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct fallible_t {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_fallible_t() {
            assert_eq!(::std::mem::size_of::<fallible_t>() , 1usize , concat !
                       ( "Size of: " , stringify ! ( fallible_t ) ));
            assert_eq! (::std::mem::align_of::<fallible_t>() , 1usize , concat
                        ! ( "Alignment of " , stringify ! ( fallible_t ) ));
        }
        impl Clone for fallible_t {
            fn clone(&self) -> Self { *self }
        }
        /** Convenient aliases. */
        pub type TrueType = u8;
        pub type FalseType = u8;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct nsStringRepr {
                pub mData: *mut root::mozilla::detail::nsStringRepr_char_type,
                pub mLength: root::mozilla::detail::nsStringRepr_size_type,
                pub mFlags: u32,
            }
            pub type nsStringRepr_fallible_t = root::mozilla::fallible_t;
            pub type nsStringRepr_char_type = u16;
            pub type nsStringRepr_self_type =
                root::mozilla::detail::nsStringRepr;
            pub type nsStringRepr_base_string_type =
                root::mozilla::detail::nsStringRepr_self_type;
            pub type nsStringRepr_substring_type = root::nsAString;
            pub type nsStringRepr_substring_tuple_type =
                root::nsSubstringTuple;
            pub type nsStringRepr_string_type = ::nsstring::nsStringRepr;
            pub type nsStringRepr_const_iterator =
                root::nsReadingIterator<u16>;
            pub type nsStringRepr_iterator = root::nsWritingIterator<u16>;
            pub type nsStringRepr_comparator_type = root::nsStringComparator;
            pub type nsStringRepr_char_iterator =
                *mut root::mozilla::detail::nsStringRepr_char_type;
            pub type nsStringRepr_const_char_iterator =
                *const root::mozilla::detail::nsStringRepr_char_type;
            pub type nsStringRepr_index_type = u32;
            pub type nsStringRepr_size_type = u32;
            pub const nsStringRepr_F_NONE:
                      root::mozilla::detail::nsStringRepr__bindgen_ty_1 =
                nsStringRepr__bindgen_ty_1::F_NONE;
            pub const nsStringRepr_F_TERMINATED:
                      root::mozilla::detail::nsStringRepr__bindgen_ty_1 =
                nsStringRepr__bindgen_ty_1::F_TERMINATED;
            pub const nsStringRepr_F_VOIDED:
                      root::mozilla::detail::nsStringRepr__bindgen_ty_1 =
                nsStringRepr__bindgen_ty_1::F_VOIDED;
            pub const nsStringRepr_F_SHARED:
                      root::mozilla::detail::nsStringRepr__bindgen_ty_1 =
                nsStringRepr__bindgen_ty_1::F_SHARED;
            pub const nsStringRepr_F_OWNED:
                      root::mozilla::detail::nsStringRepr__bindgen_ty_1 =
                nsStringRepr__bindgen_ty_1::F_OWNED;
            pub const nsStringRepr_F_FIXED:
                      root::mozilla::detail::nsStringRepr__bindgen_ty_1 =
                nsStringRepr__bindgen_ty_1::F_FIXED;
            pub const nsStringRepr_F_LITERAL:
                      root::mozilla::detail::nsStringRepr__bindgen_ty_1 =
                nsStringRepr__bindgen_ty_1::F_LITERAL;
            pub const nsStringRepr_F_CLASS_FIXED:
                      root::mozilla::detail::nsStringRepr__bindgen_ty_1 =
                nsStringRepr__bindgen_ty_1::F_CLASS_FIXED;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum nsStringRepr__bindgen_ty_1 {
                F_NONE = 0,
                F_TERMINATED = 1,
                F_VOIDED = 2,
                F_SHARED = 4,
                F_OWNED = 8,
                F_FIXED = 16,
                F_LITERAL = 32,
                F_CLASS_FIXED = 65536,
            }
            #[test]
            fn bindgen_test_layout_nsStringRepr() {
                assert_eq!(::std::mem::size_of::<nsStringRepr>() , 16usize ,
                           concat ! (
                           "Size of: " , stringify ! ( nsStringRepr ) ));
                assert_eq! (::std::mem::align_of::<nsStringRepr>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( nsStringRepr ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const nsStringRepr ) ) . mData as *
                            const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            nsStringRepr ) , "::" , stringify ! ( mData ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const nsStringRepr ) ) . mLength as
                            * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            nsStringRepr ) , "::" , stringify ! ( mLength )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const nsStringRepr ) ) . mFlags as
                            * const _ as usize } , 12usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            nsStringRepr ) , "::" , stringify ! ( mFlags ) ));
            }
            impl Clone for nsStringRepr {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct nsCStringRepr {
                pub mData: *mut root::mozilla::detail::nsCStringRepr_char_type,
                pub mLength: root::mozilla::detail::nsCStringRepr_size_type,
                pub mFlags: u32,
            }
            pub type nsCStringRepr_fallible_t = root::mozilla::fallible_t;
            pub type nsCStringRepr_char_type = ::std::os::raw::c_char;
            pub type nsCStringRepr_self_type =
                root::mozilla::detail::nsCStringRepr;
            pub type nsCStringRepr_base_string_type =
                root::mozilla::detail::nsCStringRepr_self_type;
            pub type nsCStringRepr_substring_type = root::nsACString;
            pub type nsCStringRepr_substring_tuple_type =
                root::nsCSubstringTuple;
            pub type nsCStringRepr_string_type = root::nsCString;
            pub type nsCStringRepr_const_iterator =
                root::nsReadingIterator<::std::os::raw::c_char>;
            pub type nsCStringRepr_iterator =
                root::nsWritingIterator<::std::os::raw::c_char>;
            pub type nsCStringRepr_comparator_type =
                root::nsCStringComparator;
            pub type nsCStringRepr_char_iterator =
                *mut root::mozilla::detail::nsCStringRepr_char_type;
            pub type nsCStringRepr_const_char_iterator =
                *const root::mozilla::detail::nsCStringRepr_char_type;
            pub type nsCStringRepr_index_type = u32;
            pub type nsCStringRepr_size_type = u32;
            pub const nsCStringRepr_F_NONE:
                      root::mozilla::detail::nsCStringRepr__bindgen_ty_1 =
                nsCStringRepr__bindgen_ty_1::F_NONE;
            pub const nsCStringRepr_F_TERMINATED:
                      root::mozilla::detail::nsCStringRepr__bindgen_ty_1 =
                nsCStringRepr__bindgen_ty_1::F_TERMINATED;
            pub const nsCStringRepr_F_VOIDED:
                      root::mozilla::detail::nsCStringRepr__bindgen_ty_1 =
                nsCStringRepr__bindgen_ty_1::F_VOIDED;
            pub const nsCStringRepr_F_SHARED:
                      root::mozilla::detail::nsCStringRepr__bindgen_ty_1 =
                nsCStringRepr__bindgen_ty_1::F_SHARED;
            pub const nsCStringRepr_F_OWNED:
                      root::mozilla::detail::nsCStringRepr__bindgen_ty_1 =
                nsCStringRepr__bindgen_ty_1::F_OWNED;
            pub const nsCStringRepr_F_FIXED:
                      root::mozilla::detail::nsCStringRepr__bindgen_ty_1 =
                nsCStringRepr__bindgen_ty_1::F_FIXED;
            pub const nsCStringRepr_F_LITERAL:
                      root::mozilla::detail::nsCStringRepr__bindgen_ty_1 =
                nsCStringRepr__bindgen_ty_1::F_LITERAL;
            pub const nsCStringRepr_F_CLASS_FIXED:
                      root::mozilla::detail::nsCStringRepr__bindgen_ty_1 =
                nsCStringRepr__bindgen_ty_1::F_CLASS_FIXED;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum nsCStringRepr__bindgen_ty_1 {
                F_NONE = 0,
                F_TERMINATED = 1,
                F_VOIDED = 2,
                F_SHARED = 4,
                F_OWNED = 8,
                F_FIXED = 16,
                F_LITERAL = 32,
                F_CLASS_FIXED = 65536,
            }
            #[test]
            fn bindgen_test_layout_nsCStringRepr() {
                assert_eq!(::std::mem::size_of::<nsCStringRepr>() , 16usize ,
                           concat ! (
                           "Size of: " , stringify ! ( nsCStringRepr ) ));
                assert_eq! (::std::mem::align_of::<nsCStringRepr>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( nsCStringRepr )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const nsCStringRepr ) ) . mData as
                            * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            nsCStringRepr ) , "::" , stringify ! ( mData ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const nsCStringRepr ) ) . mLength
                            as * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            nsCStringRepr ) , "::" , stringify ! ( mLength )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const nsCStringRepr ) ) . mFlags as
                            * const _ as usize } , 12usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            nsCStringRepr ) , "::" , stringify ! ( mFlags )
                            ));
            }
            impl Clone for nsCStringRepr {
                fn clone(&self) -> Self { *self }
            }
            /**
 * LinkedList supports refcounted elements using this adapter class. Clients
 * using LinkedList<RefPtr<T>> will get a data structure that holds a strong
 * reference to T as long as T is in the list.
 */
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct LinkedListElementTraits {
                pub _address: u8,
            }
            pub type LinkedListElementTraits_RawType<T> = *mut T;
            pub type LinkedListElementTraits_ConstRawType<T> = *mut T;
            pub type LinkedListElementTraits_ClientType<T> = *mut T;
            pub type LinkedListElementTraits_ConstClientType<T> = *mut T;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct WeakReference {
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct MutexImpl {
                pub platformData_: [*mut ::std::os::raw::c_void; 5usize],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct MutexImpl_PlatformData {
                _unused: [u8; 0],
            }
            #[test]
            fn bindgen_test_layout_MutexImpl() {
                assert_eq!(::std::mem::size_of::<MutexImpl>() , 40usize ,
                           concat ! ( "Size of: " , stringify ! ( MutexImpl )
                           ));
                assert_eq! (::std::mem::align_of::<MutexImpl>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( MutexImpl ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const MutexImpl ) ) . platformData_
                            as * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! ( MutexImpl )
                            , "::" , stringify ! ( platformData_ ) ));
            }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ArenaObjectID {
            eArenaObjectID_DummyBeforeFirstObjectID = 173,
            eArenaObjectID_nsLineBox = 174,
            eArenaObjectID_nsRuleNode = 175,
            eArenaObjectID_GeckoStyleContext = 176,
            eArenaObjectID_DisplayItemData = 177,
            eArenaObjectID_nsInheritedStyleData = 178,
            eArenaObjectID_nsResetStyleData = 179,
            eArenaObjectID_nsConditionalResetStyleData = 180,
            eArenaObjectID_nsConditionalResetStyleDataEntry = 181,
            eArenaObjectID_nsFrameList = 182,
            eArenaObjectID_CustomCounterStyle = 183,
            eArenaObjectID_DependentBuiltinCounterStyle = 184,
            eArenaObjectID_nsCallbackEventRequest = 185,
            eArenaObjectID_nsIntervalSet_Interval = 186,
            eArenaObjectID_CellData = 187,
            eArenaObjectID_BCCellData = 188,
            eArenaObjectID_nsStyleFont = 189,
            eArenaObjectID_nsStyleColor = 190,
            eArenaObjectID_nsStyleList = 191,
            eArenaObjectID_nsStyleText = 192,
            eArenaObjectID_nsStyleVisibility = 193,
            eArenaObjectID_nsStyleUserInterface = 194,
            eArenaObjectID_nsStyleTableBorder = 195,
            eArenaObjectID_nsStyleSVG = 196,
            eArenaObjectID_nsStyleVariables = 197,
            eArenaObjectID_nsStyleBackground = 198,
            eArenaObjectID_nsStylePosition = 199,
            eArenaObjectID_nsStyleTextReset = 200,
            eArenaObjectID_nsStyleDisplay = 201,
            eArenaObjectID_nsStyleContent = 202,
            eArenaObjectID_nsStyleUIReset = 203,
            eArenaObjectID_nsStyleTable = 204,
            eArenaObjectID_nsStyleMargin = 205,
            eArenaObjectID_nsStylePadding = 206,
            eArenaObjectID_nsStyleBorder = 207,
            eArenaObjectID_nsStyleOutline = 208,
            eArenaObjectID_nsStyleXUL = 209,
            eArenaObjectID_nsStyleSVGReset = 210,
            eArenaObjectID_nsStyleColumn = 211,
            eArenaObjectID_nsStyleEffects = 212,
            eArenaObjectID_COUNT = 213,
        }
        /**
 * A default deletion policy using plain old operator delete.
 *
 * Note that this type can be specialized, but authors should beware of the risk
 * that the specialization may at some point cease to match (either because it
 * gets moved to a different compilation unit or the signature changes). If the
 * non-specialized (|delete|-based) version compiles for that type but does the
 * wrong thing, bad things could happen.
 *
 * This is a non-issue for types which are always incomplete (i.e. opaque handle
 * types), since |delete|-ing such a type will always trigger a compilation
 * error.
 */
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DefaultDelete {
            pub _address: u8,
        }
        pub type MallocSizeOf =
            ::std::option::Option<unsafe extern "C" fn(p:
                                                           *const ::std::os::raw::c_void)
                                      -> usize>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ReverseIterator<IteratorT> {
            pub mCurrent: IteratorT,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<IteratorT>>,
        }
        pub mod css {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(u32)]
            /**
 * Enum defining the mode in which a sheet is to be parsed.  This is
 * usually, but not always, the same as the cascade level at which the
 * sheet will apply (see nsStyleSet.h).  Most of the Loader APIs only
 * support loading of author sheets.
 *
 * Author sheets are the normal case: styles embedded in or linked
 * from HTML pages.  They are also the most restricted.
 *
 * User sheets can do anything author sheets can do, and also get
 * access to a few CSS extensions that are not yet suitable for
 * exposure on the public Web, but are very useful for expressing
 * user style overrides, such as @-moz-document rules.
 *
 * XXX: eUserSheetFeatures was added in bug 1035091, but some patches in
 * that bug never landed to use this enum value. Currently, all the features
 * in user sheet are also available in author sheet.
 *
 * Agent sheets have access to all author- and user-sheet features
 * plus more extensions that are necessary for internal use but,
 * again, not yet suitable for exposure on the public Web.  Some of
 * these are outright unsafe to expose; in particular, incorrect
 * styling of anonymous box pseudo-elements can violate layout
 * invariants.
 *
 * Agent sheets that do not use any unsafe rules could use
 * eSafeAgentSheetFeatures when creating the sheet. This enum value allows
 * Servo backend to recognize the sheets as the agent level, but Gecko
 * backend will parse it under _author_ level.
 */
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum SheetParsingMode {
                eAuthorSheetFeatures = 0,
                eUserSheetFeatures = 1,
                eAgentSheetFeatures = 2,
                eSafeAgentSheetFeatures = 3,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct GroupRule {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct Rule {
                pub _base: root::nsIDOMCSSRule,
                pub _base_1: root::nsWrapperCache,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mSheet: *mut root::mozilla::StyleSheet,
                pub mParentRule: *mut root::mozilla::css::GroupRule,
                pub mLineNumber: u32,
                pub mColumnNumber: u32,
            }
            pub type Rule_HasThreadSafeRefCnt = root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Rule_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_Rule_cycleCollection() {
                assert_eq!(::std::mem::size_of::<Rule_cycleCollection>() ,
                           16usize , concat ! (
                           "Size of: " , stringify ! ( Rule_cycleCollection )
                           ));
                assert_eq! (::std::mem::align_of::<Rule_cycleCollection>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            Rule_cycleCollection ) ));
            }
            impl Clone for Rule_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            pub const Rule_UNKNOWN_RULE:
                      root::mozilla::css::Rule__bindgen_ty_1 =
                Rule__bindgen_ty_1::UNKNOWN_RULE;
            pub const Rule_CHARSET_RULE:
                      root::mozilla::css::Rule__bindgen_ty_1 =
                Rule__bindgen_ty_1::CHARSET_RULE;
            pub const Rule_IMPORT_RULE: root::mozilla::css::Rule__bindgen_ty_1
                      =
                Rule__bindgen_ty_1::IMPORT_RULE;
            pub const Rule_NAMESPACE_RULE:
                      root::mozilla::css::Rule__bindgen_ty_1 =
                Rule__bindgen_ty_1::NAMESPACE_RULE;
            pub const Rule_STYLE_RULE: root::mozilla::css::Rule__bindgen_ty_1
                      =
                Rule__bindgen_ty_1::STYLE_RULE;
            pub const Rule_MEDIA_RULE: root::mozilla::css::Rule__bindgen_ty_1
                      =
                Rule__bindgen_ty_1::MEDIA_RULE;
            pub const Rule_FONT_FACE_RULE:
                      root::mozilla::css::Rule__bindgen_ty_1 =
                Rule__bindgen_ty_1::FONT_FACE_RULE;
            pub const Rule_PAGE_RULE: root::mozilla::css::Rule__bindgen_ty_1 =
                Rule__bindgen_ty_1::PAGE_RULE;
            pub const Rule_KEYFRAME_RULE:
                      root::mozilla::css::Rule__bindgen_ty_1 =
                Rule__bindgen_ty_1::KEYFRAME_RULE;
            pub const Rule_KEYFRAMES_RULE:
                      root::mozilla::css::Rule__bindgen_ty_1 =
                Rule__bindgen_ty_1::KEYFRAMES_RULE;
            pub const Rule_DOCUMENT_RULE:
                      root::mozilla::css::Rule__bindgen_ty_1 =
                Rule__bindgen_ty_1::DOCUMENT_RULE;
            pub const Rule_SUPPORTS_RULE:
                      root::mozilla::css::Rule__bindgen_ty_1 =
                Rule__bindgen_ty_1::SUPPORTS_RULE;
            pub const Rule_FONT_FEATURE_VALUES_RULE:
                      root::mozilla::css::Rule__bindgen_ty_1 =
                Rule__bindgen_ty_1::FONT_FEATURE_VALUES_RULE;
            pub const Rule_COUNTER_STYLE_RULE:
                      root::mozilla::css::Rule__bindgen_ty_1 =
                Rule__bindgen_ty_1::COUNTER_STYLE_RULE;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum Rule__bindgen_ty_1 {
                UNKNOWN_RULE = 0,
                CHARSET_RULE = 1,
                IMPORT_RULE = 2,
                NAMESPACE_RULE = 3,
                STYLE_RULE = 4,
                MEDIA_RULE = 5,
                FONT_FACE_RULE = 6,
                PAGE_RULE = 7,
                KEYFRAME_RULE = 8,
                KEYFRAMES_RULE = 9,
                DOCUMENT_RULE = 10,
                SUPPORTS_RULE = 11,
                FONT_FEATURE_VALUES_RULE = 12,
                COUNTER_STYLE_RULE = 13,
            }
            extern "C" {
                #[link_name = "_ZN7mozilla3css4Rule21_cycleCollectorGlobalE"]
                pub static mut Rule__cycleCollectorGlobal:
                           root::mozilla::css::Rule_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_Rule() {
                assert_eq!(::std::mem::size_of::<Rule>() , 64usize , concat !
                           ( "Size of: " , stringify ! ( Rule ) ));
                assert_eq! (::std::mem::align_of::<Rule>() , 8usize , concat !
                            ( "Alignment of " , stringify ! ( Rule ) ));
            }
            #[repr(C)]
            pub struct Loader {
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mSheets: root::nsAutoPtr<root::mozilla::css::Loader_Sheets>,
                pub mParsingDatas: [u64; 10usize],
                pub mPostedEvents: root::mozilla::css::Loader_LoadDataArray,
                pub mObservers: [u64; 2usize],
                pub mDocument: *mut root::nsIDocument,
                pub mDocGroup: root::RefPtr<root::mozilla::dom::DocGroup>,
                pub mDatasToNotifyOn: u32,
                pub mCompatMode: root::nsCompatibility,
                pub mPreferredSheet: ::nsstring::nsStringRepr,
                pub mStyleBackendType: [u8; 2usize],
                pub mEnabled: bool,
                pub mReporter: root::nsCOMPtr,
            }
            pub use self::super::super::super::root::mozilla::net::ReferrerPolicy
                    as Loader_ReferrerPolicy;
            pub type Loader_HasThreadSafeRefCnt = root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Loader_cycleCollection {
                pub _base: root::nsCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_Loader_cycleCollection() {
                assert_eq!(::std::mem::size_of::<Loader_cycleCollection>() ,
                           16usize , concat ! (
                           "Size of: " , stringify ! ( Loader_cycleCollection
                           ) ));
                assert_eq! (::std::mem::align_of::<Loader_cycleCollection>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            Loader_cycleCollection ) ));
            }
            impl Clone for Loader_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            pub type Loader_LoadDataArray =
                root::nsTArray<root::RefPtr<root::mozilla::css::SheetLoadData>>;
            #[repr(C)]
            #[derive(Debug)]
            pub struct Loader_Sheets {
                pub mCompleteSheets: [u64; 5usize],
                pub mLoadingDatas: [u64; 5usize],
                pub mPendingDatas: [u64; 5usize],
            }
            #[test]
            fn bindgen_test_layout_Loader_Sheets() {
                assert_eq!(::std::mem::size_of::<Loader_Sheets>() , 120usize ,
                           concat ! (
                           "Size of: " , stringify ! ( Loader_Sheets ) ));
                assert_eq! (::std::mem::align_of::<Loader_Sheets>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( Loader_Sheets )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader_Sheets ) ) .
                            mCompleteSheets as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            Loader_Sheets ) , "::" , stringify ! (
                            mCompleteSheets ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader_Sheets ) ) .
                            mLoadingDatas as * const _ as usize } , 40usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            Loader_Sheets ) , "::" , stringify ! (
                            mLoadingDatas ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader_Sheets ) ) .
                            mPendingDatas as * const _ as usize } , 80usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            Loader_Sheets ) , "::" , stringify ! (
                            mPendingDatas ) ));
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3css6Loader21_cycleCollectorGlobalE"]
                pub static mut Loader__cycleCollectorGlobal:
                           root::mozilla::css::Loader_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_Loader() {
                assert_eq!(::std::mem::size_of::<Loader>() , 176usize , concat
                           ! ( "Size of: " , stringify ! ( Loader ) ));
                assert_eq! (::std::mem::align_of::<Loader>() , 8usize , concat
                            ! ( "Alignment of " , stringify ! ( Loader ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mRefCnt as *
                            const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mRefCnt ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mSheets as *
                            const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mSheets ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mParsingDatas as
                            * const _ as usize } , 16usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mParsingDatas ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mPostedEvents as
                            * const _ as usize } , 96usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mPostedEvents ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mObservers as *
                            const _ as usize } , 104usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mObservers ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mDocument as *
                            const _ as usize } , 120usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mDocument ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mDocGroup as *
                            const _ as usize } , 128usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mDocGroup ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mDatasToNotifyOn
                            as * const _ as usize } , 136usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mDatasToNotifyOn ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mCompatMode as *
                            const _ as usize } , 140usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mCompatMode ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mPreferredSheet
                            as * const _ as usize } , 144usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mPreferredSheet ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) .
                            mStyleBackendType as * const _ as usize } ,
                            160usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mStyleBackendType ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mEnabled as *
                            const _ as usize } , 162usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mEnabled ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mReporter as *
                            const _ as usize } , 168usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mReporter ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ImageLoader {
                _unused: [u8; 0],
            }
            #[repr(C)]
            pub struct URLValueData__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct URLValueData {
                pub vtable_: *const URLValueData__bindgen_vtable,
                pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
                pub mURI: root::nsMainThreadPtrHandle<root::nsIURI>,
                pub mString: ::nsstring::nsStringRepr,
                pub mExtraData: root::RefPtr<root::mozilla::URLExtraData>,
                pub mURIResolved: bool,
                pub mIsLocalRef: [u8; 2usize],
                pub mMightHaveRef: [u8; 2usize],
            }
            pub type URLValueData_HasThreadSafeRefCnt =
                root::mozilla::TrueType;
            #[test]
            fn bindgen_test_layout_URLValueData() {
                assert_eq!(::std::mem::size_of::<URLValueData>() , 56usize ,
                           concat ! (
                           "Size of: " , stringify ! ( URLValueData ) ));
                assert_eq! (::std::mem::align_of::<URLValueData>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( URLValueData ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLValueData ) ) . mRefCnt as
                            * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            URLValueData ) , "::" , stringify ! ( mRefCnt )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLValueData ) ) . mURI as *
                            const _ as usize } , 16usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            URLValueData ) , "::" , stringify ! ( mURI ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLValueData ) ) . mString as
                            * const _ as usize } , 24usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            URLValueData ) , "::" , stringify ! ( mString )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLValueData ) ) . mExtraData
                            as * const _ as usize } , 40usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            URLValueData ) , "::" , stringify ! ( mExtraData )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLValueData ) ) .
                            mURIResolved as * const _ as usize } , 48usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            URLValueData ) , "::" , stringify ! ( mURIResolved
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLValueData ) ) .
                            mIsLocalRef as * const _ as usize } , 49usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            URLValueData ) , "::" , stringify ! ( mIsLocalRef
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLValueData ) ) .
                            mMightHaveRef as * const _ as usize } , 51usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            URLValueData ) , "::" , stringify ! (
                            mMightHaveRef ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct URLValue {
                pub _base: root::mozilla::css::URLValueData,
            }
            #[test]
            fn bindgen_test_layout_URLValue() {
                assert_eq!(::std::mem::size_of::<URLValue>() , 56usize ,
                           concat ! ( "Size of: " , stringify ! ( URLValue )
                           ));
                assert_eq! (::std::mem::align_of::<URLValue>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( URLValue ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ImageValue {
                pub _base: root::mozilla::css::URLValueData,
                pub mRequests: [u64; 5usize],
                pub mLoadedImage: bool,
            }
            #[test]
            fn bindgen_test_layout_ImageValue() {
                assert_eq!(::std::mem::size_of::<ImageValue>() , 104usize ,
                           concat ! ( "Size of: " , stringify ! ( ImageValue )
                           ));
                assert_eq! (::std::mem::align_of::<ImageValue>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( ImageValue ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ImageValue ) ) . mRequests as
                            * const _ as usize } , 56usize , concat ! (
                            "Alignment of field: " , stringify ! ( ImageValue
                            ) , "::" , stringify ! ( mRequests ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ImageValue ) ) . mLoadedImage
                            as * const _ as usize } , 96usize , concat ! (
                            "Alignment of field: " , stringify ! ( ImageValue
                            ) , "::" , stringify ! ( mLoadedImage ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct GridNamedArea {
                pub mName: ::nsstring::nsStringRepr,
                pub mColumnStart: u32,
                pub mColumnEnd: u32,
                pub mRowStart: u32,
                pub mRowEnd: u32,
            }
            #[test]
            fn bindgen_test_layout_GridNamedArea() {
                assert_eq!(::std::mem::size_of::<GridNamedArea>() , 32usize ,
                           concat ! (
                           "Size of: " , stringify ! ( GridNamedArea ) ));
                assert_eq! (::std::mem::align_of::<GridNamedArea>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( GridNamedArea )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridNamedArea ) ) . mName as
                            * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            GridNamedArea ) , "::" , stringify ! ( mName ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridNamedArea ) ) .
                            mColumnStart as * const _ as usize } , 16usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GridNamedArea ) , "::" , stringify ! (
                            mColumnStart ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridNamedArea ) ) .
                            mColumnEnd as * const _ as usize } , 20usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GridNamedArea ) , "::" , stringify ! ( mColumnEnd
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridNamedArea ) ) . mRowStart
                            as * const _ as usize } , 24usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            GridNamedArea ) , "::" , stringify ! ( mRowStart )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridNamedArea ) ) . mRowEnd
                            as * const _ as usize } , 28usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            GridNamedArea ) , "::" , stringify ! ( mRowEnd )
                            ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct GridTemplateAreasValue {
                pub mNamedAreas: root::nsTArray<root::mozilla::css::GridNamedArea>,
                pub mTemplates: root::nsTArray<::nsstring::nsStringRepr>,
                pub mNColumns: u32,
                pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
            }
            pub type GridTemplateAreasValue_HasThreadSafeRefCnt =
                root::mozilla::TrueType;
            #[test]
            fn bindgen_test_layout_GridTemplateAreasValue() {
                assert_eq!(::std::mem::size_of::<GridTemplateAreasValue>() ,
                           32usize , concat ! (
                           "Size of: " , stringify ! ( GridTemplateAreasValue
                           ) ));
                assert_eq! (::std::mem::align_of::<GridTemplateAreasValue>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            GridTemplateAreasValue ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridTemplateAreasValue ) ) .
                            mNamedAreas as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GridTemplateAreasValue ) , "::" , stringify ! (
                            mNamedAreas ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridTemplateAreasValue ) ) .
                            mTemplates as * const _ as usize } , 8usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GridTemplateAreasValue ) , "::" , stringify ! (
                            mTemplates ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridTemplateAreasValue ) ) .
                            mNColumns as * const _ as usize } , 16usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GridTemplateAreasValue ) , "::" , stringify ! (
                            mNColumns ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridTemplateAreasValue ) ) .
                            mRefCnt as * const _ as usize } , 24usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            GridTemplateAreasValue ) , "::" , stringify ! (
                            mRefCnt ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct FontFamilyListRefCnt {
                pub _base: root::mozilla::FontFamilyList,
                pub mRefCnt: root::nsAutoRefCnt,
            }
            pub type FontFamilyListRefCnt_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[test]
            fn bindgen_test_layout_FontFamilyListRefCnt() {
                assert_eq!(::std::mem::size_of::<FontFamilyListRefCnt>() ,
                           24usize , concat ! (
                           "Size of: " , stringify ! ( FontFamilyListRefCnt )
                           ));
                assert_eq! (::std::mem::align_of::<FontFamilyListRefCnt>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            FontFamilyListRefCnt ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FontFamilyListRefCnt ) ) .
                            mRefCnt as * const _ as usize } , 16usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            FontFamilyListRefCnt ) , "::" , stringify ! (
                            mRefCnt ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct RGBAColorData {
                pub mR: f32,
                pub mG: f32,
                pub mB: f32,
                pub mA: f32,
            }
            #[test]
            fn bindgen_test_layout_RGBAColorData() {
                assert_eq!(::std::mem::size_of::<RGBAColorData>() , 16usize ,
                           concat ! (
                           "Size of: " , stringify ! ( RGBAColorData ) ));
                assert_eq! (::std::mem::align_of::<RGBAColorData>() , 4usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( RGBAColorData )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const RGBAColorData ) ) . mR as *
                            const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            RGBAColorData ) , "::" , stringify ! ( mR ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const RGBAColorData ) ) . mG as *
                            const _ as usize } , 4usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            RGBAColorData ) , "::" , stringify ! ( mG ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const RGBAColorData ) ) . mB as *
                            const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            RGBAColorData ) , "::" , stringify ! ( mB ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const RGBAColorData ) ) . mA as *
                            const _ as usize } , 12usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            RGBAColorData ) , "::" , stringify ! ( mA ) ));
            }
            impl Clone for RGBAColorData {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct ComplexColorData {
                pub mColor: root::mozilla::css::RGBAColorData,
                pub mForegroundRatio: f32,
            }
            #[test]
            fn bindgen_test_layout_ComplexColorData() {
                assert_eq!(::std::mem::size_of::<ComplexColorData>() , 20usize
                           , concat ! (
                           "Size of: " , stringify ! ( ComplexColorData ) ));
                assert_eq! (::std::mem::align_of::<ComplexColorData>() ,
                            4usize , concat ! (
                            "Alignment of " , stringify ! ( ComplexColorData )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ComplexColorData ) ) . mColor
                            as * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ComplexColorData ) , "::" , stringify ! ( mColor )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ComplexColorData ) ) .
                            mForegroundRatio as * const _ as usize } , 16usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            ComplexColorData ) , "::" , stringify ! (
                            mForegroundRatio ) ));
            }
            impl Clone for ComplexColorData {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ComplexColorValue {
                pub _base: root::mozilla::css::ComplexColorData,
                pub mRefCnt: root::nsAutoRefCnt,
            }
            pub type ComplexColorValue_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[test]
            fn bindgen_test_layout_ComplexColorValue() {
                assert_eq!(::std::mem::size_of::<ComplexColorValue>() ,
                           32usize , concat ! (
                           "Size of: " , stringify ! ( ComplexColorValue ) ));
                assert_eq! (::std::mem::align_of::<ComplexColorValue>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! ( ComplexColorValue
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ComplexColorValue ) ) .
                            mRefCnt as * const _ as usize } , 24usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            ComplexColorValue ) , "::" , stringify ! ( mRefCnt
                            ) ));
            }
            /*********************
 * Style sheet reuse *
 *********************/
            #[repr(C)]
            #[derive(Debug)]
            pub struct LoaderReusableStyleSheets {
                pub mReusableSheets: root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>,
            }
            #[test]
            fn bindgen_test_layout_LoaderReusableStyleSheets() {
                assert_eq!(::std::mem::size_of::<LoaderReusableStyleSheets>()
                           , 8usize , concat ! (
                           "Size of: " , stringify ! (
                           LoaderReusableStyleSheets ) ));
                assert_eq! (::std::mem::align_of::<LoaderReusableStyleSheets>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            LoaderReusableStyleSheets ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const LoaderReusableStyleSheets ) )
                            . mReusableSheets as * const _ as usize } , 0usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            LoaderReusableStyleSheets ) , "::" , stringify ! (
                            mReusableSheets ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct SheetLoadData {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ImportRule {
                _unused: [u8; 0],
            }
            #[repr(i32)]
            /**
 * Enum defining the type of URL matching function for a @-moz-document rule
 * condition.
 */
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum URLMatchingFunction {
                eURL = 0,
                eURLPrefix = 1,
                eDomain = 2,
                eRegExp = 3,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DocumentRule {
                _unused: [u8; 0],
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ThreadSafeAutoRefCnt {
            pub mValue: u64,
        }
        pub const ThreadSafeAutoRefCnt_isThreadSafe: bool = true;
        #[test]
        fn bindgen_test_layout_ThreadSafeAutoRefCnt() {
            assert_eq!(::std::mem::size_of::<ThreadSafeAutoRefCnt>() , 8usize
                       , concat ! (
                       "Size of: " , stringify ! ( ThreadSafeAutoRefCnt ) ));
            assert_eq! (::std::mem::align_of::<ThreadSafeAutoRefCnt>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! ( ThreadSafeAutoRefCnt )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ThreadSafeAutoRefCnt ) ) . mValue
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ThreadSafeAutoRefCnt ) , "::" , stringify ! ( mValue )
                        ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct OwningNonNull<T> {
            pub mPtr: root::RefPtr<T>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StaticRefPtr<T> {
            pub mRawPtr: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct LinkedListElement {
            pub mNext: *mut root::mozilla::LinkedListElement,
            pub mPrev: *mut root::mozilla::LinkedListElement,
            pub mIsSentinel: bool,
        }
        pub type LinkedListElement_Traits =
            root::mozilla::detail::LinkedListElementTraits;
        pub type LinkedListElement_RawType =
            root::mozilla::LinkedListElement_Traits;
        pub type LinkedListElement_ConstRawType =
            root::mozilla::LinkedListElement_Traits;
        pub type LinkedListElement_ClientType =
            root::mozilla::LinkedListElement_Traits;
        pub type LinkedListElement_ConstClientType =
            root::mozilla::LinkedListElement_Traits;
        pub const LinkedListElement_NodeKind_Sentinel:
                  root::mozilla::LinkedListElement_NodeKind =
            LinkedListElement_NodeKind::Normal;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LinkedListElement_NodeKind { Normal = 0, }
        #[repr(C)]
        #[derive(Debug)]
        pub struct LinkedList {
            pub sentinel: root::mozilla::LinkedListElement,
        }
        pub type LinkedList_Traits =
            root::mozilla::detail::LinkedListElementTraits;
        pub type LinkedList_RawType = root::mozilla::LinkedList_Traits;
        pub type LinkedList_ConstRawType = root::mozilla::LinkedList_Traits;
        pub type LinkedList_ClientType = root::mozilla::LinkedList_Traits;
        pub type LinkedList_ConstClientType =
            root::mozilla::LinkedList_Traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct LinkedList_Iterator {
            pub mCurrent: root::mozilla::LinkedList_RawType,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AlignedStorage2 {
            pub u: root::mozilla::AlignedStorage2_U,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AlignedStorage2_U {
            pub mBytes: root::__BindgenUnionField<*mut ::std::os::raw::c_char>,
            pub mDummy: root::__BindgenUnionField<u64>,
            pub bindgen_union_field: u64,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Maybe {
        }
        pub type Maybe_ValueType<T> = T;
        pub mod gfx {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type IntRegion = [u64; 3usize];
            pub type Float = f32;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Color {
                pub _bindgen_opaque_blob: [u32; 4usize],
            }
            #[test]
            fn bindgen_test_layout_Color() {
                assert_eq!(::std::mem::size_of::<Color>() , 16usize , concat !
                           ( "Size of: " , stringify ! ( Color ) ));
                assert_eq! (::std::mem::align_of::<Color>() , 4usize , concat
                            ! ( "Alignment of " , stringify ! ( Color ) ));
            }
            impl Clone for Color {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct PointTyped {
            }
            pub type PointTyped_Coord = u8;
            pub type PointTyped_Super = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct SizeTyped {
            }
            pub type SizeTyped_Super = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IntPointTyped {
            }
            pub type IntPointTyped_ToInt = u32;
            pub type IntPointTyped_Coord = u8;
            pub type IntPointTyped_Super = u8;
            pub type IntPoint = [u32; 2usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IntSizeTyped {
            }
            pub type IntSizeTyped_ToInt = u32;
            pub type IntSizeTyped_Super = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct RectTyped {
            }
            pub type RectTyped_Super = u8;
            pub type IntMargin = [u32; 4usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct MarginTyped {
            }
            pub type MarginTyped_Super = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IntRectTyped {
            }
            pub type IntRectTyped_Super = u8;
            pub type IntRectTyped_Self = u8;
            pub type IntRectTyped_ToInt = u32;
            pub type IntRect = [u32; 4usize];
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct FontVariation {
                pub mTag: u32,
                pub mValue: f32,
            }
            #[test]
            fn bindgen_test_layout_FontVariation() {
                assert_eq!(::std::mem::size_of::<FontVariation>() , 8usize ,
                           concat ! (
                           "Size of: " , stringify ! ( FontVariation ) ));
                assert_eq! (::std::mem::align_of::<FontVariation>() , 4usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( FontVariation )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FontVariation ) ) . mTag as *
                            const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FontVariation ) , "::" , stringify ! ( mTag ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FontVariation ) ) . mValue as
                            * const _ as usize } , 4usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FontVariation ) , "::" , stringify ! ( mValue )
                            ));
            }
            impl Clone for FontVariation {
                fn clone(&self) -> Self { *self }
            }
            pub type Matrix4x4 = [u32; 16usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ScaleFactor {
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ScaleFactors2D {
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct SourceSurface {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DrawTarget {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Path {
                _unused: [u8; 0],
            }
        }
        pub mod layers {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            /**
 * The viewport and displayport metrics for the painted frame at the
 * time of a layer-tree transaction.  These metrics are especially
 * useful for shadow layers, because the metrics values are updated
 * atomically with new pixels.
 */
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct FrameMetrics {
                pub mScrollId: root::mozilla::layers::FrameMetrics_ViewID,
                pub mPresShellResolution: f32,
                pub mCompositionBounds: root::mozilla::ParentLayerRect,
                pub mDisplayPort: root::mozilla::CSSRect,
                pub mCriticalDisplayPort: root::mozilla::CSSRect,
                pub mScrollableRect: root::mozilla::CSSRect,
                pub mCumulativeResolution: root::mozilla::LayoutDeviceToLayerScale2D,
                pub mDevPixelsPerCSSPixel: root::mozilla::CSSToLayoutDeviceScale,
                pub mScrollOffset: root::mozilla::CSSPoint,
                pub mZoom: root::mozilla::CSSToParentLayerScale2D,
                pub mScrollGeneration: u32,
                pub mSmoothScrollOffset: root::mozilla::CSSPoint,
                pub mRootCompositionSize: root::mozilla::CSSSize,
                pub mDisplayPortMargins: root::mozilla::ScreenMargin,
                pub mPresShellId: u32,
                pub mViewport: root::mozilla::CSSRect,
                pub mExtraResolution: root::mozilla::ScreenToLayerScale2D,
                pub mPaintRequestTime: root::mozilla::TimeStamp,
                pub mScrollUpdateType: root::mozilla::layers::FrameMetrics_ScrollOffsetUpdateType,
                pub _bitfield_1: u8,
                pub __bindgen_padding_0: [u16; 3usize],
            }
            pub type FrameMetrics_ViewID = u64;
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum FrameMetrics_ScrollOffsetUpdateType {
                eNone = 0,
                eMainThread = 1,
                ePending = 2,
                eUserAction = 3,
                eRestore = 4,
                eSentinel = 5,
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla6layers12FrameMetrics14NULL_SCROLL_IDE"]
                pub static FrameMetrics_NULL_SCROLL_ID:
                           root::mozilla::layers::FrameMetrics_ViewID;
            }
            pub const FrameMetrics_START_SCROLL_ID:
                      root::mozilla::layers::FrameMetrics_ViewID =
                2;
            #[test]
            fn bindgen_test_layout_FrameMetrics() {
                assert_eq!(::std::mem::size_of::<FrameMetrics>() , 184usize ,
                           concat ! (
                           "Size of: " , stringify ! ( FrameMetrics ) ));
                assert_eq! (::std::mem::align_of::<FrameMetrics>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( FrameMetrics ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) . mScrollId
                            as * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! ( mScrollId )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mPresShellResolution as * const _ as usize } ,
                            8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mPresShellResolution ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mCompositionBounds as * const _ as usize } ,
                            12usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mCompositionBounds ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mDisplayPort as * const _ as usize } , 28usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! ( mDisplayPort
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mCriticalDisplayPort as * const _ as usize } ,
                            44usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mCriticalDisplayPort ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mScrollableRect as * const _ as usize } , 60usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mScrollableRect ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mCumulativeResolution as * const _ as usize } ,
                            76usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mCumulativeResolution ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mDevPixelsPerCSSPixel as * const _ as usize } ,
                            84usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mDevPixelsPerCSSPixel ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mScrollOffset as * const _ as usize } , 88usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mScrollOffset ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) . mZoom as *
                            const _ as usize } , 96usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! ( mZoom ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mScrollGeneration as * const _ as usize } ,
                            104usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mScrollGeneration ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mSmoothScrollOffset as * const _ as usize } ,
                            108usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mSmoothScrollOffset ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mRootCompositionSize as * const _ as usize } ,
                            116usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mRootCompositionSize ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mDisplayPortMargins as * const _ as usize } ,
                            124usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mDisplayPortMargins ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mPresShellId as * const _ as usize } , 140usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! ( mPresShellId
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) . mViewport
                            as * const _ as usize } , 144usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! ( mViewport )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mExtraResolution as * const _ as usize } ,
                            160usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mExtraResolution ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mPaintRequestTime as * const _ as usize } ,
                            168usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mPaintRequestTime ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mScrollUpdateType as * const _ as usize } ,
                            176usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mScrollUpdateType ) ));
            }
            impl Clone for FrameMetrics {
                fn clone(&self) -> Self { *self }
            }
            impl FrameMetrics {
                #[inline]
                pub fn mIsRootContent(&self) -> bool {
                    let mut unit_field_val: u8 =
                        unsafe { ::std::mem::uninitialized() };
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                            *const _ as
                                                            *const u8,
                                                        &mut unit_field_val as
                                                            *mut u8 as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>())
                    };
                    let mask = 1u64 as u8;
                    let val = (unit_field_val & mask) >> 0usize;
                    unsafe { ::std::mem::transmute(val as u8) }
                }
                #[inline]
                pub fn set_mIsRootContent(&mut self, val: bool) {
                    let mask = 1u64 as u8;
                    let val = val as u8 as u8;
                    let mut unit_field_val: u8 =
                        unsafe { ::std::mem::uninitialized() };
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                            *const _ as
                                                            *const u8,
                                                        &mut unit_field_val as
                                                            *mut u8 as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>())
                    };
                    unit_field_val &= !mask;
                    unit_field_val |= (val << 0usize) & mask;
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                            *const _ as
                                                            *const u8,
                                                        &mut self._bitfield_1
                                                            as *mut _ as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>());
                    }
                }
                #[inline]
                pub fn mDoSmoothScroll(&self) -> bool {
                    let mut unit_field_val: u8 =
                        unsafe { ::std::mem::uninitialized() };
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                            *const _ as
                                                            *const u8,
                                                        &mut unit_field_val as
                                                            *mut u8 as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>())
                    };
                    let mask = 2u64 as u8;
                    let val = (unit_field_val & mask) >> 1usize;
                    unsafe { ::std::mem::transmute(val as u8) }
                }
                #[inline]
                pub fn set_mDoSmoothScroll(&mut self, val: bool) {
                    let mask = 2u64 as u8;
                    let val = val as u8 as u8;
                    let mut unit_field_val: u8 =
                        unsafe { ::std::mem::uninitialized() };
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                            *const _ as
                                                            *const u8,
                                                        &mut unit_field_val as
                                                            *mut u8 as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>())
                    };
                    unit_field_val &= !mask;
                    unit_field_val |= (val << 1usize) & mask;
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                            *const _ as
                                                            *const u8,
                                                        &mut self._bitfield_1
                                                            as *mut _ as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>());
                    }
                }
                #[inline]
                pub fn mUseDisplayPortMargins(&self) -> bool {
                    let mut unit_field_val: u8 =
                        unsafe { ::std::mem::uninitialized() };
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                            *const _ as
                                                            *const u8,
                                                        &mut unit_field_val as
                                                            *mut u8 as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>())
                    };
                    let mask = 4u64 as u8;
                    let val = (unit_field_val & mask) >> 2usize;
                    unsafe { ::std::mem::transmute(val as u8) }
                }
                #[inline]
                pub fn set_mUseDisplayPortMargins(&mut self, val: bool) {
                    let mask = 4u64 as u8;
                    let val = val as u8 as u8;
                    let mut unit_field_val: u8 =
                        unsafe { ::std::mem::uninitialized() };
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                            *const _ as
                                                            *const u8,
                                                        &mut unit_field_val as
                                                            *mut u8 as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>())
                    };
                    unit_field_val &= !mask;
                    unit_field_val |= (val << 2usize) & mask;
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                            *const _ as
                                                            *const u8,
                                                        &mut self._bitfield_1
                                                            as *mut _ as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>());
                    }
                }
                #[inline]
                pub fn mIsScrollInfoLayer(&self) -> bool {
                    let mut unit_field_val: u8 =
                        unsafe { ::std::mem::uninitialized() };
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                            *const _ as
                                                            *const u8,
                                                        &mut unit_field_val as
                                                            *mut u8 as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>())
                    };
                    let mask = 8u64 as u8;
                    let val = (unit_field_val & mask) >> 3usize;
                    unsafe { ::std::mem::transmute(val as u8) }
                }
                #[inline]
                pub fn set_mIsScrollInfoLayer(&mut self, val: bool) {
                    let mask = 8u64 as u8;
                    let val = val as u8 as u8;
                    let mut unit_field_val: u8 =
                        unsafe { ::std::mem::uninitialized() };
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                            *const _ as
                                                            *const u8,
                                                        &mut unit_field_val as
                                                            *mut u8 as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>())
                    };
                    unit_field_val &= !mask;
                    unit_field_val |= (val << 3usize) & mask;
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                            *const _ as
                                                            *const u8,
                                                        &mut self._bitfield_1
                                                            as *mut _ as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>());
                    }
                }
                #[inline]
                pub fn new_bitfield_1(mIsRootContent: bool,
                                      mDoSmoothScroll: bool,
                                      mUseDisplayPortMargins: bool,
                                      mIsScrollInfoLayer: bool) -> u8 {
                    ({
                         ({
                              ({
                                   ({ 0 } |
                                        ((mIsRootContent as u8 as u8) <<
                                             0usize) & (1u64 as u8))
                               } |
                                   ((mDoSmoothScroll as u8 as u8) << 1usize) &
                                       (2u64 as u8))
                          } |
                              ((mUseDisplayPortMargins as u8 as u8) << 2usize)
                                  & (4u64 as u8))
                     } |
                         ((mIsScrollInfoLayer as u8 as u8) << 3usize) &
                             (8u64 as u8))
                }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ScrollSnapInfo {
                pub mScrollSnapTypeX: u8,
                pub mScrollSnapTypeY: u8,
                pub mScrollSnapIntervalX: [u32; 2usize],
                pub mScrollSnapIntervalY: [u32; 2usize],
                pub mScrollSnapDestination: root::nsPoint,
                pub mScrollSnapCoordinates: root::nsTArray<root::nsPoint>,
            }
            #[test]
            fn bindgen_test_layout_ScrollSnapInfo() {
                assert_eq!(::std::mem::size_of::<ScrollSnapInfo>() , 40usize ,
                           concat ! (
                           "Size of: " , stringify ! ( ScrollSnapInfo ) ));
                assert_eq! (::std::mem::align_of::<ScrollSnapInfo>() , 8usize
                            , concat ! (
                            "Alignment of " , stringify ! ( ScrollSnapInfo )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollSnapInfo ) ) .
                            mScrollSnapTypeX as * const _ as usize } , 0usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollSnapInfo ) , "::" , stringify ! (
                            mScrollSnapTypeX ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollSnapInfo ) ) .
                            mScrollSnapTypeY as * const _ as usize } , 1usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollSnapInfo ) , "::" , stringify ! (
                            mScrollSnapTypeY ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollSnapInfo ) ) .
                            mScrollSnapIntervalX as * const _ as usize } ,
                            4usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollSnapInfo ) , "::" , stringify ! (
                            mScrollSnapIntervalX ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollSnapInfo ) ) .
                            mScrollSnapIntervalY as * const _ as usize } ,
                            12usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollSnapInfo ) , "::" , stringify ! (
                            mScrollSnapIntervalY ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollSnapInfo ) ) .
                            mScrollSnapDestination as * const _ as usize } ,
                            20usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollSnapInfo ) , "::" , stringify ! (
                            mScrollSnapDestination ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollSnapInfo ) ) .
                            mScrollSnapCoordinates as * const _ as usize } ,
                            32usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollSnapInfo ) , "::" , stringify ! (
                            mScrollSnapCoordinates ) ));
            }
            /**
 * A clip that applies to a layer, that may be scrolled by some of the
 * scroll frames associated with the layer.
 */
            #[repr(C)]
            #[derive(Debug)]
            pub struct LayerClip {
                pub mClipRect: root::mozilla::ParentLayerIntRect,
                pub mMaskLayerIndex: [u64; 2usize],
            }
            #[test]
            fn bindgen_test_layout_LayerClip() {
                assert_eq!(::std::mem::size_of::<LayerClip>() , 32usize ,
                           concat ! ( "Size of: " , stringify ! ( LayerClip )
                           ));
                assert_eq! (::std::mem::align_of::<LayerClip>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( LayerClip ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const LayerClip ) ) . mClipRect as
                            * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! ( LayerClip )
                            , "::" , stringify ! ( mClipRect ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const LayerClip ) ) .
                            mMaskLayerIndex as * const _ as usize } , 16usize
                            , concat ! (
                            "Alignment of field: " , stringify ! ( LayerClip )
                            , "::" , stringify ! ( mMaskLayerIndex ) ));
            }
            /**
 * Metadata about a scroll frame that's stored in the layer tree for use by
 * the compositor (including APZ). This includes the scroll frame's FrameMetrics,
 * as well as other metadata. We don't put the other metadata into FrameMetrics
 * to avoid FrameMetrics becoming too bloated (as a FrameMetrics is e.g. sent
 * over IPC for every repaint request for every active scroll frame).
 */
            #[repr(C)]
            #[derive(Debug)]
            pub struct ScrollMetadata {
                pub mMetrics: root::mozilla::layers::FrameMetrics,
                pub mSnapInfo: root::mozilla::layers::ScrollSnapInfo,
                pub mScrollParentId: root::mozilla::layers::ScrollMetadata_ViewID,
                pub mBackgroundColor: root::mozilla::gfx::Color,
                pub mContentDescription: root::nsCString,
                pub mLineScrollAmount: root::mozilla::LayoutDeviceIntSize,
                pub mPageScrollAmount: root::mozilla::LayoutDeviceIntSize,
                pub mScrollClip: [u64; 5usize],
                pub _bitfield_1: u8,
                pub __bindgen_padding_0: [u8; 7usize],
            }
            pub type ScrollMetadata_ViewID =
                root::mozilla::layers::FrameMetrics_ViewID;
            extern "C" {
                #[link_name =
                      "_ZN7mozilla6layers14ScrollMetadata13sNullMetadataE"]
                pub static mut ScrollMetadata_sNullMetadata:
                           root::mozilla::StaticAutoPtr<root::mozilla::layers::ScrollMetadata>;
            }
            #[test]
            fn bindgen_test_layout_ScrollMetadata() {
                assert_eq!(::std::mem::size_of::<ScrollMetadata>() , 328usize
                           , concat ! (
                           "Size of: " , stringify ! ( ScrollMetadata ) ));
                assert_eq! (::std::mem::align_of::<ScrollMetadata>() , 8usize
                            , concat ! (
                            "Alignment of " , stringify ! ( ScrollMetadata )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollMetadata ) ) . mMetrics
                            as * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollMetadata ) , "::" , stringify ! ( mMetrics )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollMetadata ) ) .
                            mSnapInfo as * const _ as usize } , 184usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollMetadata ) , "::" , stringify ! ( mSnapInfo
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollMetadata ) ) .
                            mScrollParentId as * const _ as usize } , 224usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollMetadata ) , "::" , stringify ! (
                            mScrollParentId ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollMetadata ) ) .
                            mBackgroundColor as * const _ as usize } ,
                            232usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollMetadata ) , "::" , stringify ! (
                            mBackgroundColor ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollMetadata ) ) .
                            mContentDescription as * const _ as usize } ,
                            248usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollMetadata ) , "::" , stringify ! (
                            mContentDescription ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollMetadata ) ) .
                            mLineScrollAmount as * const _ as usize } ,
                            264usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollMetadata ) , "::" , stringify ! (
                            mLineScrollAmount ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollMetadata ) ) .
                            mPageScrollAmount as * const _ as usize } ,
                            272usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollMetadata ) , "::" , stringify ! (
                            mPageScrollAmount ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollMetadata ) ) .
                            mScrollClip as * const _ as usize } , 280usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollMetadata ) , "::" , stringify ! (
                            mScrollClip ) ));
            }
            impl ScrollMetadata {
                #[inline]
                pub fn mHasScrollgrab(&self) -> bool {
                    let mut unit_field_val: u8 =
                        unsafe { ::std::mem::uninitialized() };
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                            *const _ as
                                                            *const u8,
                                                        &mut unit_field_val as
                                                            *mut u8 as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>())
                    };
                    let mask = 1u64 as u8;
                    let val = (unit_field_val & mask) >> 0usize;
                    unsafe { ::std::mem::transmute(val as u8) }
                }
                #[inline]
                pub fn set_mHasScrollgrab(&mut self, val: bool) {
                    let mask = 1u64 as u8;
                    let val = val as u8 as u8;
                    let mut unit_field_val: u8 =
                        unsafe { ::std::mem::uninitialized() };
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                            *const _ as
                                                            *const u8,
                                                        &mut unit_field_val as
                                                            *mut u8 as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>())
                    };
                    unit_field_val &= !mask;
                    unit_field_val |= (val << 0usize) & mask;
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                            *const _ as
                                                            *const u8,
                                                        &mut self._bitfield_1
                                                            as *mut _ as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>());
                    }
                }
                #[inline]
                pub fn mAllowVerticalScrollWithWheel(&self) -> bool {
                    let mut unit_field_val: u8 =
                        unsafe { ::std::mem::uninitialized() };
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                            *const _ as
                                                            *const u8,
                                                        &mut unit_field_val as
                                                            *mut u8 as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>())
                    };
                    let mask = 2u64 as u8;
                    let val = (unit_field_val & mask) >> 1usize;
                    unsafe { ::std::mem::transmute(val as u8) }
                }
                #[inline]
                pub fn set_mAllowVerticalScrollWithWheel(&mut self,
                                                         val: bool) {
                    let mask = 2u64 as u8;
                    let val = val as u8 as u8;
                    let mut unit_field_val: u8 =
                        unsafe { ::std::mem::uninitialized() };
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                            *const _ as
                                                            *const u8,
                                                        &mut unit_field_val as
                                                            *mut u8 as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>())
                    };
                    unit_field_val &= !mask;
                    unit_field_val |= (val << 1usize) & mask;
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                            *const _ as
                                                            *const u8,
                                                        &mut self._bitfield_1
                                                            as *mut _ as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>());
                    }
                }
                #[inline]
                pub fn mIsLayersIdRoot(&self) -> bool {
                    let mut unit_field_val: u8 =
                        unsafe { ::std::mem::uninitialized() };
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                            *const _ as
                                                            *const u8,
                                                        &mut unit_field_val as
                                                            *mut u8 as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>())
                    };
                    let mask = 4u64 as u8;
                    let val = (unit_field_val & mask) >> 2usize;
                    unsafe { ::std::mem::transmute(val as u8) }
                }
                #[inline]
                pub fn set_mIsLayersIdRoot(&mut self, val: bool) {
                    let mask = 4u64 as u8;
                    let val = val as u8 as u8;
                    let mut unit_field_val: u8 =
                        unsafe { ::std::mem::uninitialized() };
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                            *const _ as
                                                            *const u8,
                                                        &mut unit_field_val as
                                                            *mut u8 as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>())
                    };
                    unit_field_val &= !mask;
                    unit_field_val |= (val << 2usize) & mask;
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                            *const _ as
                                                            *const u8,
                                                        &mut self._bitfield_1
                                                            as *mut _ as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>());
                    }
                }
                #[inline]
                pub fn mUsesContainerScrolling(&self) -> bool {
                    let mut unit_field_val: u8 =
                        unsafe { ::std::mem::uninitialized() };
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                            *const _ as
                                                            *const u8,
                                                        &mut unit_field_val as
                                                            *mut u8 as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>())
                    };
                    let mask = 8u64 as u8;
                    let val = (unit_field_val & mask) >> 3usize;
                    unsafe { ::std::mem::transmute(val as u8) }
                }
                #[inline]
                pub fn set_mUsesContainerScrolling(&mut self, val: bool) {
                    let mask = 8u64 as u8;
                    let val = val as u8 as u8;
                    let mut unit_field_val: u8 =
                        unsafe { ::std::mem::uninitialized() };
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                            *const _ as
                                                            *const u8,
                                                        &mut unit_field_val as
                                                            *mut u8 as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>())
                    };
                    unit_field_val &= !mask;
                    unit_field_val |= (val << 3usize) & mask;
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                            *const _ as
                                                            *const u8,
                                                        &mut self._bitfield_1
                                                            as *mut _ as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>());
                    }
                }
                #[inline]
                pub fn mForceDisableApz(&self) -> bool {
                    let mut unit_field_val: u8 =
                        unsafe { ::std::mem::uninitialized() };
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                            *const _ as
                                                            *const u8,
                                                        &mut unit_field_val as
                                                            *mut u8 as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>())
                    };
                    let mask = 16u64 as u8;
                    let val = (unit_field_val & mask) >> 4usize;
                    unsafe { ::std::mem::transmute(val as u8) }
                }
                #[inline]
                pub fn set_mForceDisableApz(&mut self, val: bool) {
                    let mask = 16u64 as u8;
                    let val = val as u8 as u8;
                    let mut unit_field_val: u8 =
                        unsafe { ::std::mem::uninitialized() };
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                            *const _ as
                                                            *const u8,
                                                        &mut unit_field_val as
                                                            *mut u8 as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>())
                    };
                    unit_field_val &= !mask;
                    unit_field_val |= (val << 4usize) & mask;
                    unsafe {
                        ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                            *const _ as
                                                            *const u8,
                                                        &mut self._bitfield_1
                                                            as *mut _ as
                                                            *mut u8,
                                                        ::std::mem::size_of::<u8>());
                    }
                }
                #[inline]
                pub fn new_bitfield_1(mHasScrollgrab: bool,
                                      mAllowVerticalScrollWithWheel: bool,
                                      mIsLayersIdRoot: bool,
                                      mUsesContainerScrolling: bool,
                                      mForceDisableApz: bool) -> u8 {
                    ({
                         ({
                              ({
                                   ({
                                        ({ 0 } |
                                             ((mHasScrollgrab as u8 as u8) <<
                                                  0usize) & (1u64 as u8))
                                    } |
                                        ((mAllowVerticalScrollWithWheel as u8
                                              as u8) << 1usize) &
                                            (2u64 as u8))
                               } |
                                   ((mIsLayersIdRoot as u8 as u8) << 2usize) &
                                       (4u64 as u8))
                          } |
                              ((mUsesContainerScrolling as u8 as u8) <<
                                   3usize) & (8u64 as u8))
                     } |
                         ((mForceDisableApz as u8 as u8) << 4usize) &
                             (16u64 as u8))
                }
            }
            /**
 * This class is used for communicating information about the currently focused
 * element of a document and the scrollable frames to use when keyboard scrolling
 * it. It is created on the main thread at paint-time, but is then passed over
 * IPC to the compositor/APZ code.
 */
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct FocusTarget {
                pub mSequenceNumber: u64,
                pub mFocusHasKeyEventListeners: bool,
                pub mType: root::mozilla::layers::FocusTarget_FocusTargetType,
                pub mData: root::mozilla::layers::FocusTarget_FocusTargetData,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct FocusTarget_ScrollTargets {
                pub mHorizontal: root::mozilla::layers::FrameMetrics_ViewID,
                pub mVertical: root::mozilla::layers::FrameMetrics_ViewID,
            }
            #[test]
            fn bindgen_test_layout_FocusTarget_ScrollTargets() {
                assert_eq!(::std::mem::size_of::<FocusTarget_ScrollTargets>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           FocusTarget_ScrollTargets ) ));
                assert_eq! (::std::mem::align_of::<FocusTarget_ScrollTargets>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            FocusTarget_ScrollTargets ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FocusTarget_ScrollTargets ) )
                            . mHorizontal as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FocusTarget_ScrollTargets ) , "::" , stringify ! (
                            mHorizontal ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FocusTarget_ScrollTargets ) )
                            . mVertical as * const _ as usize } , 8usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FocusTarget_ScrollTargets ) , "::" , stringify ! (
                            mVertical ) ));
            }
            impl Clone for FocusTarget_ScrollTargets {
                fn clone(&self) -> Self { *self }
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum FocusTarget_FocusTargetType {
                eNone = 0,
                eRefLayer = 1,
                eScrollLayer = 2,
                eSentinel = 3,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct FocusTarget_FocusTargetData {
                pub mRefLayerId: root::__BindgenUnionField<u64>,
                pub mScrollTargets: root::__BindgenUnionField<root::mozilla::layers::FocusTarget_ScrollTargets>,
                pub bindgen_union_field: [u64; 2usize],
            }
            #[test]
            fn bindgen_test_layout_FocusTarget_FocusTargetData() {
                assert_eq!(::std::mem::size_of::<FocusTarget_FocusTargetData>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           FocusTarget_FocusTargetData ) ));
                assert_eq! (::std::mem::align_of::<FocusTarget_FocusTargetData>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            FocusTarget_FocusTargetData ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FocusTarget_FocusTargetData )
                            ) . mRefLayerId as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FocusTarget_FocusTargetData ) , "::" , stringify !
                            ( mRefLayerId ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FocusTarget_FocusTargetData )
                            ) . mScrollTargets as * const _ as usize } ,
                            0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FocusTarget_FocusTargetData ) , "::" , stringify !
                            ( mScrollTargets ) ));
            }
            impl Clone for FocusTarget_FocusTargetData {
                fn clone(&self) -> Self { *self }
            }
            #[test]
            fn bindgen_test_layout_FocusTarget() {
                assert_eq!(::std::mem::size_of::<FocusTarget>() , 32usize ,
                           concat ! (
                           "Size of: " , stringify ! ( FocusTarget ) ));
                assert_eq! (::std::mem::align_of::<FocusTarget>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( FocusTarget ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FocusTarget ) ) .
                            mSequenceNumber as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! ( FocusTarget
                            ) , "::" , stringify ! ( mSequenceNumber ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FocusTarget ) ) .
                            mFocusHasKeyEventListeners as * const _ as usize }
                            , 8usize , concat ! (
                            "Alignment of field: " , stringify ! ( FocusTarget
                            ) , "::" , stringify ! (
                            mFocusHasKeyEventListeners ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FocusTarget ) ) . mType as *
                            const _ as usize } , 12usize , concat ! (
                            "Alignment of field: " , stringify ! ( FocusTarget
                            ) , "::" , stringify ! ( mType ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FocusTarget ) ) . mData as *
                            const _ as usize } , 16usize , concat ! (
                            "Alignment of field: " , stringify ! ( FocusTarget
                            ) , "::" , stringify ! ( mData ) ));
            }
            impl Clone for FocusTarget {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct LayerManager {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ContainerLayer {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Layer {
                _unused: [u8; 0],
            }
        }
        pub mod dom {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum PlaybackDirection {
                Normal = 0,
                Reverse = 1,
                Alternate = 2,
                Alternate_reverse = 3,
                EndGuard_ = 4,
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum FillMode {
                None = 0,
                Forwards = 1,
                Backwards = 2,
                Both = 3,
                Auto = 4,
                EndGuard_ = 5,
            }
            pub mod binding_detail {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[repr(C)]
                #[derive(Debug)]
                pub struct FastErrorResult {
                    pub _base: root::mozilla::binding_danger::TErrorResult,
                }
                #[test]
                fn bindgen_test_layout_FastErrorResult() {
                    assert_eq!(::std::mem::size_of::<FastErrorResult>() ,
                               16usize , concat ! (
                               "Size of: " , stringify ! ( FastErrorResult )
                               ));
                    assert_eq! (::std::mem::align_of::<FastErrorResult>() ,
                                8usize , concat ! (
                                "Alignment of " , stringify ! (
                                FastErrorResult ) ));
                }
                #[repr(C)]
                pub struct FakeString {
                    pub mData: *mut root::mozilla::detail::nsStringRepr_char_type,
                    pub mLength: root::mozilla::detail::nsStringRepr_size_type,
                    pub mFlags: u32,
                    pub mInlineStorage: [root::mozilla::detail::nsStringRepr_char_type; 64usize],
                }
                #[repr(C)]
                #[derive(Debug)]
                pub struct FakeString_StringAsserter {
                    pub _base: ::nsstring::nsStringRepr,
                }
                #[test]
                fn bindgen_test_layout_FakeString_StringAsserter() {
                    assert_eq!(::std::mem::size_of::<FakeString_StringAsserter>()
                               , 16usize , concat ! (
                               "Size of: " , stringify ! (
                               FakeString_StringAsserter ) ));
                    assert_eq! (::std::mem::align_of::<FakeString_StringAsserter>()
                                , 8usize , concat ! (
                                "Alignment of " , stringify ! (
                                FakeString_StringAsserter ) ));
                }
                pub const FakeString_sInlineCapacity: usize = 64;
                #[test]
                fn bindgen_test_layout_FakeString() {
                    assert_eq!(::std::mem::size_of::<FakeString>() , 144usize
                               , concat ! (
                               "Size of: " , stringify ! ( FakeString ) ));
                    assert_eq! (::std::mem::align_of::<FakeString>() , 8usize
                                , concat ! (
                                "Alignment of " , stringify ! ( FakeString )
                                ));
                    assert_eq! (unsafe {
                                & ( * ( 0 as * const FakeString ) ) . mData as
                                * const _ as usize } , 0usize , concat ! (
                                "Alignment of field: " , stringify ! (
                                FakeString ) , "::" , stringify ! ( mData )
                                ));
                    assert_eq! (unsafe {
                                & ( * ( 0 as * const FakeString ) ) . mLength
                                as * const _ as usize } , 8usize , concat ! (
                                "Alignment of field: " , stringify ! (
                                FakeString ) , "::" , stringify ! ( mLength )
                                ));
                    assert_eq! (unsafe {
                                & ( * ( 0 as * const FakeString ) ) . mFlags
                                as * const _ as usize } , 12usize , concat ! (
                                "Alignment of field: " , stringify ! (
                                FakeString ) , "::" , stringify ! ( mFlags )
                                ));
                    assert_eq! (unsafe {
                                & ( * ( 0 as * const FakeString ) ) .
                                mInlineStorage as * const _ as usize } ,
                                16usize , concat ! (
                                "Alignment of field: " , stringify ! (
                                FakeString ) , "::" , stringify ! (
                                mInlineStorage ) ));
                }
                #[repr(C)]
                #[derive(Debug)]
                pub struct FastElementCreationOptions {
                    pub _base: root::mozilla::dom::ElementCreationOptions,
                }
                #[test]
                fn bindgen_test_layout_FastElementCreationOptions() {
                    assert_eq!(::std::mem::size_of::<FastElementCreationOptions>()
                               , 56usize , concat ! (
                               "Size of: " , stringify ! (
                               FastElementCreationOptions ) ));
                    assert_eq! (::std::mem::align_of::<FastElementCreationOptions>()
                                , 8usize , concat ! (
                                "Alignment of " , stringify ! (
                                FastElementCreationOptions ) ));
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct RecordEntry<KeyType, ValueType> {
                    pub mKey: KeyType,
                    pub mValue: ValueType,
                    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<KeyType>>,
                    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<ValueType>>,
                }
            }
            /**
 * A class for representing string return values.  This can be either passed to
 * callees that have an nsString or nsAString out param or passed to a callee
 * that actually knows about this class and can work with it.  Such a callee may
 * call SetStringBuffer or SetEphemeralStringBuffer or SetOwnedString or
 * SetOwnedAtom on this object.  It's only OK to call
 * SetStringBuffer/SetOwnedString/SetOwnedAtom if the caller of the method in
 * question plans to keep holding a strong ref to the stringbuffer involved,
 * whether it's a raw nsStringBuffer, or stored inside the string or atom being
 * passed.  In the string/atom cases that means the caller must own the string
 * or atom, and not mutate it (in the string case) for the lifetime of the
 * DOMString.
 *
 * The proper way to store a value in this class is to either to do nothing
 * (which leaves this as an empty string), to call
 * SetStringBuffer/SetEphemeralStringBuffer with a non-null stringbuffer, to
 * call SetOwnedString, to call SetOwnedAtom, to call SetNull(), or to call
 * AsAString() and set the value in the resulting nsString.  These options are
 * mutually exclusive! Don't do more than one of them.
 *
 * The proper way to extract a value is to check IsNull().  If not null, then
 * check HasStringBuffer().  If that's true, check for a zero length, and if the
 * length is nonzero call StringBuffer().  If the length is zero this is the
 * empty string.  If HasStringBuffer() returns false, call AsAString() and get
 * the value from that.
 */
            #[repr(C)]
            #[derive(Debug)]
            pub struct DOMString {
                pub mString: [u64; 21usize],
                pub mStringBuffer: *mut root::nsStringBuffer,
                pub mLength: u32,
                pub mIsNull: bool,
                pub mStringBufferOwned: bool,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum DOMString_NullHandling {
                eTreatNullAsNull = 0,
                eTreatNullAsEmpty = 1,
                eNullNotExpected = 2,
            }
            #[test]
            fn bindgen_test_layout_DOMString() {
                assert_eq!(::std::mem::size_of::<DOMString>() , 184usize ,
                           concat ! ( "Size of: " , stringify ! ( DOMString )
                           ));
                assert_eq! (::std::mem::align_of::<DOMString>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( DOMString ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const DOMString ) ) . mString as *
                            const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! ( DOMString )
                            , "::" , stringify ! ( mString ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const DOMString ) ) . mStringBuffer
                            as * const _ as usize } , 168usize , concat ! (
                            "Alignment of field: " , stringify ! ( DOMString )
                            , "::" , stringify ! ( mStringBuffer ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const DOMString ) ) . mLength as *
                            const _ as usize } , 176usize , concat ! (
                            "Alignment of field: " , stringify ! ( DOMString )
                            , "::" , stringify ! ( mLength ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const DOMString ) ) . mIsNull as *
                            const _ as usize } , 180usize , concat ! (
                            "Alignment of field: " , stringify ! ( DOMString )
                            , "::" , stringify ! ( mIsNull ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const DOMString ) ) .
                            mStringBufferOwned as * const _ as usize } ,
                            181usize , concat ! (
                            "Alignment of field: " , stringify ! ( DOMString )
                            , "::" , stringify ! ( mStringBufferOwned ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DictionaryBase {
                pub mIsAnyMemberPresent: bool,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DictionaryBase_FastDictionaryInitializer {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_DictionaryBase_FastDictionaryInitializer() {
                assert_eq!(::std::mem::size_of::<DictionaryBase_FastDictionaryInitializer>()
                           , 1usize , concat ! (
                           "Size of: " , stringify ! (
                           DictionaryBase_FastDictionaryInitializer ) ));
                assert_eq! (::std::mem::align_of::<DictionaryBase_FastDictionaryInitializer>()
                            , 1usize , concat ! (
                            "Alignment of " , stringify ! (
                            DictionaryBase_FastDictionaryInitializer ) ));
            }
            impl Clone for DictionaryBase_FastDictionaryInitializer {
                fn clone(&self) -> Self { *self }
            }
            #[test]
            fn bindgen_test_layout_DictionaryBase() {
                assert_eq!(::std::mem::size_of::<DictionaryBase>() , 1usize ,
                           concat ! (
                           "Size of: " , stringify ! ( DictionaryBase ) ));
                assert_eq! (::std::mem::align_of::<DictionaryBase>() , 1usize
                            , concat ! (
                            "Alignment of " , stringify ! ( DictionaryBase )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const DictionaryBase ) ) .
                            mIsAnyMemberPresent as * const _ as usize } ,
                            0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            DictionaryBase ) , "::" , stringify ! (
                            mIsAnyMemberPresent ) ));
            }
            impl Clone for DictionaryBase {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct AllOwningUnionBase {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_AllOwningUnionBase() {
                assert_eq!(::std::mem::size_of::<AllOwningUnionBase>() ,
                           1usize , concat ! (
                           "Size of: " , stringify ! ( AllOwningUnionBase )
                           ));
                assert_eq! (::std::mem::align_of::<AllOwningUnionBase>() ,
                            1usize , concat ! (
                            "Alignment of " , stringify ! ( AllOwningUnionBase
                            ) ));
            }
            impl Clone for AllOwningUnionBase {
                fn clone(&self) -> Self { *self }
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum CallerType { System = 0, NonSystem = 1, }
            #[repr(C)]
            #[derive(Debug)]
            pub struct GlobalObject {
                pub mGlobalJSObject: [u64; 3usize],
                pub mCx: *mut root::JSContext,
                pub mGlobalObject: *mut root::nsISupports,
            }
            #[test]
            fn bindgen_test_layout_GlobalObject() {
                assert_eq!(::std::mem::size_of::<GlobalObject>() , 40usize ,
                           concat ! (
                           "Size of: " , stringify ! ( GlobalObject ) ));
                assert_eq! (::std::mem::align_of::<GlobalObject>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( GlobalObject ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GlobalObject ) ) .
                            mGlobalJSObject as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GlobalObject ) , "::" , stringify ! (
                            mGlobalJSObject ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GlobalObject ) ) . mCx as *
                            const _ as usize } , 24usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            GlobalObject ) , "::" , stringify ! ( mCx ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GlobalObject ) ) .
                            mGlobalObject as * const _ as usize } , 32usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GlobalObject ) , "::" , stringify ! (
                            mGlobalObject ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Optional {
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct NonNull<T> {
                pub ptr: *mut T,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Sequence {
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct ParentObject {
                pub mObject: *const root::nsISupports,
                pub mWrapperCache: *const root::nsWrapperCache,
                pub mUseXBLScope: bool,
            }
            #[test]
            fn bindgen_test_layout_ParentObject() {
                assert_eq!(::std::mem::size_of::<ParentObject>() , 24usize ,
                           concat ! (
                           "Size of: " , stringify ! ( ParentObject ) ));
                assert_eq! (::std::mem::align_of::<ParentObject>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( ParentObject ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ParentObject ) ) . mObject as
                            * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ParentObject ) , "::" , stringify ! ( mObject )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ParentObject ) ) .
                            mWrapperCache as * const _ as usize } , 8usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ParentObject ) , "::" , stringify ! (
                            mWrapperCache ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ParentObject ) ) .
                            mUseXBLScope as * const _ as usize } , 16usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ParentObject ) , "::" , stringify ! ( mUseXBLScope
                            ) ));
            }
            impl Clone for ParentObject {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Nullable {
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum CSSStyleSheetParsingMode {
                Author = 0,
                User = 1,
                Agent = 2,
                EndGuard_ = 3,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct OriginAttributesDictionary {
                pub _base: root::mozilla::dom::DictionaryBase,
                pub mAppId: u32,
                pub mFirstPartyDomain: ::nsstring::nsStringRepr,
                pub mInIsolatedMozBrowser: bool,
                pub mPrivateBrowsingId: u32,
                pub mUserContextId: u32,
            }
            #[test]
            fn bindgen_test_layout_OriginAttributesDictionary() {
                assert_eq!(::std::mem::size_of::<OriginAttributesDictionary>()
                           , 40usize , concat ! (
                           "Size of: " , stringify ! (
                           OriginAttributesDictionary ) ));
                assert_eq! (::std::mem::align_of::<OriginAttributesDictionary>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            OriginAttributesDictionary ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const OriginAttributesDictionary )
                            ) . mAppId as * const _ as usize } , 4usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            OriginAttributesDictionary ) , "::" , stringify !
                            ( mAppId ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const OriginAttributesDictionary )
                            ) . mFirstPartyDomain as * const _ as usize } ,
                            8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            OriginAttributesDictionary ) , "::" , stringify !
                            ( mFirstPartyDomain ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const OriginAttributesDictionary )
                            ) . mInIsolatedMozBrowser as * const _ as usize }
                            , 24usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            OriginAttributesDictionary ) , "::" , stringify !
                            ( mInIsolatedMozBrowser ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const OriginAttributesDictionary )
                            ) . mPrivateBrowsingId as * const _ as usize } ,
                            28usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            OriginAttributesDictionary ) , "::" , stringify !
                            ( mPrivateBrowsingId ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const OriginAttributesDictionary )
                            ) . mUserContextId as * const _ as usize } ,
                            32usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            OriginAttributesDictionary ) , "::" , stringify !
                            ( mUserContextId ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Promise {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CSSImportRule {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CSSRuleList {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct MediaList {
                pub _base: root::nsIDOMMediaList,
                pub _base_1: root::nsWrapperCache,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mStyleSheet: *mut root::mozilla::StyleSheet,
            }
            pub type MediaList_HasThreadSafeRefCnt = root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct MediaList_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_MediaList_cycleCollection() {
                assert_eq!(::std::mem::size_of::<MediaList_cycleCollection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           MediaList_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<MediaList_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            MediaList_cycleCollection ) ));
            }
            impl Clone for MediaList_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom9MediaList21_cycleCollectorGlobalE"]
                pub static mut MediaList__cycleCollectorGlobal:
                           root::mozilla::dom::MediaList_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_MediaList() {
                assert_eq!(::std::mem::size_of::<MediaList>() , 48usize ,
                           concat ! ( "Size of: " , stringify ! ( MediaList )
                           ));
                assert_eq! (::std::mem::align_of::<MediaList>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( MediaList ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct SRIMetadata {
                pub mHashes: root::nsTArray<root::nsCString>,
                pub mIntegrityString: ::nsstring::nsStringRepr,
                pub mAlgorithm: root::nsCString,
                pub mAlgorithmType: i8,
                pub mEmpty: bool,
            }
            pub const SRIMetadata_MAX_ALTERNATE_HASHES: u32 = 256;
            pub const SRIMetadata_UNKNOWN_ALGORITHM: i8 = -1;
            #[test]
            fn bindgen_test_layout_SRIMetadata() {
                assert_eq!(::std::mem::size_of::<SRIMetadata>() , 48usize ,
                           concat ! (
                           "Size of: " , stringify ! ( SRIMetadata ) ));
                assert_eq! (::std::mem::align_of::<SRIMetadata>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( SRIMetadata ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const SRIMetadata ) ) . mHashes as
                            * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! ( SRIMetadata
                            ) , "::" , stringify ! ( mHashes ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const SRIMetadata ) ) .
                            mIntegrityString as * const _ as usize } , 8usize
                            , concat ! (
                            "Alignment of field: " , stringify ! ( SRIMetadata
                            ) , "::" , stringify ! ( mIntegrityString ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const SRIMetadata ) ) . mAlgorithm
                            as * const _ as usize } , 24usize , concat ! (
                            "Alignment of field: " , stringify ! ( SRIMetadata
                            ) , "::" , stringify ! ( mAlgorithm ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const SRIMetadata ) ) .
                            mAlgorithmType as * const _ as usize } , 40usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! ( SRIMetadata
                            ) , "::" , stringify ! ( mAlgorithmType ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const SRIMetadata ) ) . mEmpty as *
                            const _ as usize } , 41usize , concat ! (
                            "Alignment of field: " , stringify ! ( SRIMetadata
                            ) , "::" , stringify ! ( mEmpty ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct Element {
                pub _base: root::mozilla::dom::FragmentOrElement,
                pub mState: root::mozilla::EventStates,
                pub mServoData: ::gecko_bindings::structs::ServoCell<*mut ::gecko_bindings::structs::ServoNodeData>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Element_COMTypeInfo {
                pub _address: u8,
            }
            /**
   * StyleStateLocks is used to specify which event states should be locked,
   * and whether they should be locked to on or off.
   */
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Element_StyleStateLocks {
                pub mLocks: root::mozilla::EventStates,
                pub mValues: root::mozilla::EventStates,
            }
            #[test]
            fn bindgen_test_layout_Element_StyleStateLocks() {
                assert_eq!(::std::mem::size_of::<Element_StyleStateLocks>() ,
                           16usize , concat ! (
                           "Size of: " , stringify ! ( Element_StyleStateLocks
                           ) ));
                assert_eq! (::std::mem::align_of::<Element_StyleStateLocks>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            Element_StyleStateLocks ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Element_StyleStateLocks ) ) .
                            mLocks as * const _ as usize } , 0usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            Element_StyleStateLocks ) , "::" , stringify ! (
                            mLocks ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Element_StyleStateLocks ) ) .
                            mValues as * const _ as usize } , 8usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            Element_StyleStateLocks ) , "::" , stringify ! (
                            mValues ) ));
            }
            impl Clone for Element_StyleStateLocks {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Element_MappedAttributeEntry {
                pub attribute: *mut *mut root::nsIAtom,
            }
            #[test]
            fn bindgen_test_layout_Element_MappedAttributeEntry() {
                assert_eq!(::std::mem::size_of::<Element_MappedAttributeEntry>()
                           , 8usize , concat ! (
                           "Size of: " , stringify ! (
                           Element_MappedAttributeEntry ) ));
                assert_eq! (::std::mem::align_of::<Element_MappedAttributeEntry>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            Element_MappedAttributeEntry ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const Element_MappedAttributeEntry ) )
                            . attribute as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            Element_MappedAttributeEntry ) , "::" , stringify
                            ! ( attribute ) ));
            }
            impl Clone for Element_MappedAttributeEntry {
                fn clone(&self) -> Self { *self }
            }
            pub const Element_kFireMutationEvent: bool = true;
            pub const Element_kDontFireMutationEvent: bool = false;
            pub const Element_kNotifyDocumentObservers: bool = true;
            pub const Element_kDontNotifyDocumentObservers: bool = false;
            pub const Element_kCallAfterSetAttr: bool = true;
            pub const Element_kDontCallAfterSetAttr: bool = false;
            #[test]
            fn bindgen_test_layout_Element() {
                assert_eq!(::std::mem::size_of::<Element>() , 120usize ,
                           concat ! ( "Size of: " , stringify ! ( Element )
                           ));
                assert_eq! (::std::mem::align_of::<Element>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( Element ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Element ) ) . mState as *
                            const _ as usize } , 104usize , concat ! (
                            "Alignment of field: " , stringify ! ( Element ) ,
                            "::" , stringify ! ( mState ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Element ) ) . mServoData as *
                            const _ as usize } , 112usize , concat ! (
                            "Alignment of field: " , stringify ! ( Element ) ,
                            "::" , stringify ! ( mServoData ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ShadowRoot {
                _unused: [u8; 0],
            }
            /**
 * Struct that stores info on an attribute. The name and value must either both
 * be null or both be non-null.
 *
 * Note that, just as the pointers returned by GetAttrNameAt, the pointers that
 * this struct hold are only valid until the element or its attributes are
 * mutated (directly or via script).
 */
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct BorrowedAttrInfo {
                pub mName: *const root::nsAttrName,
                pub mValue: *const root::nsAttrValue,
            }
            #[test]
            fn bindgen_test_layout_BorrowedAttrInfo() {
                assert_eq!(::std::mem::size_of::<BorrowedAttrInfo>() , 16usize
                           , concat ! (
                           "Size of: " , stringify ! ( BorrowedAttrInfo ) ));
                assert_eq! (::std::mem::align_of::<BorrowedAttrInfo>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! ( BorrowedAttrInfo )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const BorrowedAttrInfo ) ) . mName
                            as * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            BorrowedAttrInfo ) , "::" , stringify ! ( mName )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const BorrowedAttrInfo ) ) . mValue
                            as * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            BorrowedAttrInfo ) , "::" , stringify ! ( mValue )
                            ));
            }
            impl Clone for BorrowedAttrInfo {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct NodeInfo {
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mDocument: *mut root::nsIDocument,
                pub mInner: root::mozilla::dom::NodeInfo_NodeInfoInner,
                pub mOwnerManager: root::RefPtr<root::nsNodeInfoManager>,
                pub mQualifiedName: ::nsstring::nsStringRepr,
                pub mNodeName: ::nsstring::nsStringRepr,
                pub mLocalName: ::nsstring::nsStringRepr,
            }
            pub type NodeInfo_HasThreadSafeRefCnt = root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct NodeInfo_cycleCollection {
                pub _base: root::nsCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_NodeInfo_cycleCollection() {
                assert_eq!(::std::mem::size_of::<NodeInfo_cycleCollection>() ,
                           16usize , concat ! (
                           "Size of: " , stringify ! (
                           NodeInfo_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<NodeInfo_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            NodeInfo_cycleCollection ) ));
            }
            impl Clone for NodeInfo_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct NodeInfo_NodeInfoInner {
                pub mName: root::nsCOMPtr,
                pub mPrefix: root::nsCOMPtr,
                pub mNamespaceID: i32,
                pub mNodeType: u16,
                pub mNameString: *const root::nsAString,
                pub mExtraName: root::nsCOMPtr,
            }
            #[test]
            fn bindgen_test_layout_NodeInfo_NodeInfoInner() {
                assert_eq!(::std::mem::size_of::<NodeInfo_NodeInfoInner>() ,
                           40usize , concat ! (
                           "Size of: " , stringify ! ( NodeInfo_NodeInfoInner
                           ) ));
                assert_eq! (::std::mem::align_of::<NodeInfo_NodeInfoInner>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            NodeInfo_NodeInfoInner ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) .
                            mName as * const _ as usize } , 0usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            NodeInfo_NodeInfoInner ) , "::" , stringify ! (
                            mName ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) .
                            mPrefix as * const _ as usize } , 8usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            NodeInfo_NodeInfoInner ) , "::" , stringify ! (
                            mPrefix ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) .
                            mNamespaceID as * const _ as usize } , 16usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            NodeInfo_NodeInfoInner ) , "::" , stringify ! (
                            mNamespaceID ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) .
                            mNodeType as * const _ as usize } , 20usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            NodeInfo_NodeInfoInner ) , "::" , stringify ! (
                            mNodeType ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) .
                            mNameString as * const _ as usize } , 24usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            NodeInfo_NodeInfoInner ) , "::" , stringify ! (
                            mNameString ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) .
                            mExtraName as * const _ as usize } , 32usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            NodeInfo_NodeInfoInner ) , "::" , stringify ! (
                            mExtraName ) ));
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom8NodeInfo21_cycleCollectorGlobalE"]
                pub static mut NodeInfo__cycleCollectorGlobal:
                           root::mozilla::dom::NodeInfo_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_NodeInfo() {
                assert_eq!(::std::mem::size_of::<NodeInfo>() , 112usize ,
                           concat ! ( "Size of: " , stringify ! ( NodeInfo )
                           ));
                assert_eq! (::std::mem::align_of::<NodeInfo>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( NodeInfo ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo ) ) . mRefCnt as *
                            const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! ( NodeInfo )
                            , "::" , stringify ! ( mRefCnt ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo ) ) . mDocument as *
                            const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! ( NodeInfo )
                            , "::" , stringify ! ( mDocument ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo ) ) . mInner as *
                            const _ as usize } , 16usize , concat ! (
                            "Alignment of field: " , stringify ! ( NodeInfo )
                            , "::" , stringify ! ( mInner ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo ) ) . mOwnerManager
                            as * const _ as usize } , 56usize , concat ! (
                            "Alignment of field: " , stringify ! ( NodeInfo )
                            , "::" , stringify ! ( mOwnerManager ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo ) ) . mQualifiedName
                            as * const _ as usize } , 64usize , concat ! (
                            "Alignment of field: " , stringify ! ( NodeInfo )
                            , "::" , stringify ! ( mQualifiedName ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo ) ) . mNodeName as *
                            const _ as usize } , 80usize , concat ! (
                            "Alignment of field: " , stringify ! ( NodeInfo )
                            , "::" , stringify ! ( mNodeName ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo ) ) . mLocalName as
                            * const _ as usize } , 96usize , concat ! (
                            "Alignment of field: " , stringify ! ( NodeInfo )
                            , "::" , stringify ! ( mLocalName ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct EventTarget {
                pub _base: root::nsIDOMEventTarget,
                pub _base_1: root::nsWrapperCache,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EventTarget_COMTypeInfo {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_EventTarget() {
                assert_eq!(::std::mem::size_of::<EventTarget>() , 32usize ,
                           concat ! (
                           "Size of: " , stringify ! ( EventTarget ) ));
                assert_eq! (::std::mem::align_of::<EventTarget>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( EventTarget ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AddEventListenerOptionsOrBoolean {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Event {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EventListener {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EventListenerOptionsOrBoolean {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct EventHandlerNonNull {
                pub _base: root::mozilla::dom::CallbackFunction,
            }
            #[test]
            fn bindgen_test_layout_EventHandlerNonNull() {
                assert_eq!(::std::mem::size_of::<EventHandlerNonNull>() ,
                           48usize , concat ! (
                           "Size of: " , stringify ! ( EventHandlerNonNull )
                           ));
                assert_eq! (::std::mem::align_of::<EventHandlerNonNull>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            EventHandlerNonNull ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AccessibleNode {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct BoxQuadOptions {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ConvertCoordinateOptions {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DOMPoint {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DOMQuad {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct DOMRectReadOnly {
                pub _base: root::nsISupports,
                pub _base_1: root::nsWrapperCache,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mParent: root::nsCOMPtr,
            }
            pub type DOMRectReadOnly_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DOMRectReadOnly_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_DOMRectReadOnly_cycleCollection() {
                assert_eq!(::std::mem::size_of::<DOMRectReadOnly_cycleCollection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           DOMRectReadOnly_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<DOMRectReadOnly_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            DOMRectReadOnly_cycleCollection ) ));
            }
            impl Clone for DOMRectReadOnly_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom15DOMRectReadOnly21_cycleCollectorGlobalE"]
                pub static mut DOMRectReadOnly__cycleCollectorGlobal:
                           root::mozilla::dom::DOMRectReadOnly_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_DOMRectReadOnly() {
                assert_eq!(::std::mem::size_of::<DOMRectReadOnly>() , 48usize
                           , concat ! (
                           "Size of: " , stringify ! ( DOMRectReadOnly ) ));
                assert_eq! (::std::mem::align_of::<DOMRectReadOnly>() , 8usize
                            , concat ! (
                            "Alignment of " , stringify ! ( DOMRectReadOnly )
                            ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct OwningNodeOrString {
                pub mType: root::mozilla::dom::OwningNodeOrString_Type,
                pub mValue: root::mozilla::dom::OwningNodeOrString_Value,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum OwningNodeOrString_Type {
                eUninitialized = 0,
                eNode = 1,
                eString = 2,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct OwningNodeOrString_Value {
                pub mNode: root::__BindgenUnionField<root::mozilla::dom::UnionMember>,
                pub mString: root::__BindgenUnionField<root::mozilla::dom::UnionMember>,
                pub bindgen_union_field: [u64; 2usize],
            }
            #[test]
            fn bindgen_test_layout_OwningNodeOrString_Value() {
                assert_eq!(::std::mem::size_of::<OwningNodeOrString_Value>() ,
                           16usize , concat ! (
                           "Size of: " , stringify ! (
                           OwningNodeOrString_Value ) ));
                assert_eq! (::std::mem::align_of::<OwningNodeOrString_Value>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            OwningNodeOrString_Value ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const OwningNodeOrString_Value ) )
                            . mNode as * const _ as usize } , 0usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            OwningNodeOrString_Value ) , "::" , stringify ! (
                            mNode ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const OwningNodeOrString_Value ) )
                            . mString as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            OwningNodeOrString_Value ) , "::" , stringify ! (
                            mString ) ));
            }
            impl Clone for OwningNodeOrString_Value {
                fn clone(&self) -> Self { *self }
            }
            #[test]
            fn bindgen_test_layout_OwningNodeOrString() {
                assert_eq!(::std::mem::size_of::<OwningNodeOrString>() ,
                           24usize , concat ! (
                           "Size of: " , stringify ! ( OwningNodeOrString )
                           ));
                assert_eq! (::std::mem::align_of::<OwningNodeOrString>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! ( OwningNodeOrString
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const OwningNodeOrString ) ) .
                            mType as * const _ as usize } , 0usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            OwningNodeOrString ) , "::" , stringify ! ( mType
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const OwningNodeOrString ) ) .
                            mValue as * const _ as usize } , 8usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            OwningNodeOrString ) , "::" , stringify ! ( mValue
                            ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Text {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TextOrElementOrDocument {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DOMPointInit {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct GetRootNodeOptions {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Touch {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Selection {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct UnionMember {
                pub mStorage: root::mozilla::AlignedStorage2,
            }
            #[repr(C)]
            pub struct DispatcherTrait__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DispatcherTrait {
                pub vtable_: *const DispatcherTrait__bindgen_vtable,
            }
            #[test]
            fn bindgen_test_layout_DispatcherTrait() {
                assert_eq!(::std::mem::size_of::<DispatcherTrait>() , 8usize ,
                           concat ! (
                           "Size of: " , stringify ! ( DispatcherTrait ) ));
                assert_eq! (::std::mem::align_of::<DispatcherTrait>() , 8usize
                            , concat ! (
                            "Alignment of " , stringify ! ( DispatcherTrait )
                            ));
            }
            impl Clone for DispatcherTrait {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ScriptSettingsStackEntry {
                pub mGlobalObject: root::nsCOMPtr,
                pub mType: root::mozilla::dom::ScriptSettingsStackEntry_Type,
                pub mOlder: *mut root::mozilla::dom::ScriptSettingsStackEntry,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum ScriptSettingsStackEntry_Type {
                eEntryScript = 0,
                eIncumbentScript = 1,
                eJSAPI = 2,
                eNoJSAPI = 3,
            }
            #[test]
            fn bindgen_test_layout_ScriptSettingsStackEntry() {
                assert_eq!(::std::mem::size_of::<ScriptSettingsStackEntry>() ,
                           24usize , concat ! (
                           "Size of: " , stringify ! (
                           ScriptSettingsStackEntry ) ));
                assert_eq! (::std::mem::align_of::<ScriptSettingsStackEntry>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            ScriptSettingsStackEntry ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScriptSettingsStackEntry ) )
                            . mGlobalObject as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ScriptSettingsStackEntry ) , "::" , stringify ! (
                            mGlobalObject ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScriptSettingsStackEntry ) )
                            . mType as * const _ as usize } , 8usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            ScriptSettingsStackEntry ) , "::" , stringify ! (
                            mType ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScriptSettingsStackEntry ) )
                            . mOlder as * const _ as usize } , 16usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ScriptSettingsStackEntry ) , "::" , stringify ! (
                            mOlder ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct AutoJSAPI {
                pub _base: root::mozilla::dom::ScriptSettingsStackEntry,
                pub mAutoRequest: [u64; 2usize],
                pub mAutoNullableCompartment: [u64; 3usize],
                pub mCx: *mut root::JSContext,
                pub mIsMainThread: bool,
                pub mOldWarningReporter: [u64; 2usize],
            }
            #[test]
            fn bindgen_test_layout_AutoJSAPI() {
                assert_eq!(::std::mem::size_of::<AutoJSAPI>() , 96usize ,
                           concat ! ( "Size of: " , stringify ! ( AutoJSAPI )
                           ));
                assert_eq! (::std::mem::align_of::<AutoJSAPI>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( AutoJSAPI ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AutoJSAPI ) ) . mAutoRequest
                            as * const _ as usize } , 24usize , concat ! (
                            "Alignment of field: " , stringify ! ( AutoJSAPI )
                            , "::" , stringify ! ( mAutoRequest ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AutoJSAPI ) ) .
                            mAutoNullableCompartment as * const _ as usize } ,
                            40usize , concat ! (
                            "Alignment of field: " , stringify ! ( AutoJSAPI )
                            , "::" , stringify ! ( mAutoNullableCompartment )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AutoJSAPI ) ) . mCx as *
                            const _ as usize } , 64usize , concat ! (
                            "Alignment of field: " , stringify ! ( AutoJSAPI )
                            , "::" , stringify ! ( mCx ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AutoJSAPI ) ) . mIsMainThread
                            as * const _ as usize } , 72usize , concat ! (
                            "Alignment of field: " , stringify ! ( AutoJSAPI )
                            , "::" , stringify ! ( mIsMainThread ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AutoJSAPI ) ) .
                            mOldWarningReporter as * const _ as usize } ,
                            80usize , concat ! (
                            "Alignment of field: " , stringify ! ( AutoJSAPI )
                            , "::" , stringify ! ( mOldWarningReporter ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct AutoEntryScript {
                pub _base: root::mozilla::dom::AutoJSAPI,
                pub mWebIDLCallerPrincipal: *mut root::nsIPrincipal,
                pub mDocShellEntryMonitor: [u64; 5usize],
                pub mCallerOverride: root::JS::AutoHideScriptedCaller,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct AutoEntryScript_DocshellEntryMonitor {
                pub _base: root::JS::dbg::AutoEntryMonitor,
                pub mReason: *const ::std::os::raw::c_char,
            }
            #[test]
            fn bindgen_test_layout_AutoEntryScript_DocshellEntryMonitor() {
                assert_eq!(::std::mem::size_of::<AutoEntryScript_DocshellEntryMonitor>()
                           , 32usize , concat ! (
                           "Size of: " , stringify ! (
                           AutoEntryScript_DocshellEntryMonitor ) ));
                assert_eq! (::std::mem::align_of::<AutoEntryScript_DocshellEntryMonitor>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            AutoEntryScript_DocshellEntryMonitor ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const AutoEntryScript_DocshellEntryMonitor
                            ) ) . mReason as * const _ as usize } , 24usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            AutoEntryScript_DocshellEntryMonitor ) , "::" ,
                            stringify ! ( mReason ) ));
            }
            #[test]
            fn bindgen_test_layout_AutoEntryScript() {
                assert_eq!(::std::mem::size_of::<AutoEntryScript>() , 152usize
                           , concat ! (
                           "Size of: " , stringify ! ( AutoEntryScript ) ));
                assert_eq! (::std::mem::align_of::<AutoEntryScript>() , 8usize
                            , concat ! (
                            "Alignment of " , stringify ! ( AutoEntryScript )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AutoEntryScript ) ) .
                            mWebIDLCallerPrincipal as * const _ as usize } ,
                            96usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            AutoEntryScript ) , "::" , stringify ! (
                            mWebIDLCallerPrincipal ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AutoEntryScript ) ) .
                            mDocShellEntryMonitor as * const _ as usize } ,
                            104usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            AutoEntryScript ) , "::" , stringify ! (
                            mDocShellEntryMonitor ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AutoEntryScript ) ) .
                            mCallerOverride as * const _ as usize } , 144usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            AutoEntryScript ) , "::" , stringify ! (
                            mCallerOverride ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct AutoIncumbentScript {
                pub _base: root::mozilla::dom::ScriptSettingsStackEntry,
                pub mCallerOverride: root::JS::AutoHideScriptedCaller,
            }
            #[test]
            fn bindgen_test_layout_AutoIncumbentScript() {
                assert_eq!(::std::mem::size_of::<AutoIncumbentScript>() ,
                           32usize , concat ! (
                           "Size of: " , stringify ! ( AutoIncumbentScript )
                           ));
                assert_eq! (::std::mem::align_of::<AutoIncumbentScript>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            AutoIncumbentScript ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AutoIncumbentScript ) ) .
                            mCallerOverride as * const _ as usize } , 24usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            AutoIncumbentScript ) , "::" , stringify ! (
                            mCallerOverride ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AudioContext {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DocGroup {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Performance {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ServiceWorkerRegistration {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TimeoutManager {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CustomElementRegistry {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Location {
                _unused: [u8; 0],
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum LargeAllocStatus {
                NONE = 0,
                SUCCESS = 1,
                NON_GET = 2,
                NON_E10S = 3,
                NOT_ONLY_TOPLEVEL_IN_TABGROUP = 4,
                NON_WIN32 = 5,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct PrefSetting {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallbackObject {
                pub _base: root::nsISupports,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mCallback: root::JS::Heap<*mut root::JSObject>,
                pub mCreationStack: root::JS::Heap<*mut root::JSObject>,
                pub mIncumbentGlobal: root::nsCOMPtr,
                pub mIncumbentJSGlobal: root::JS::TenuredHeap,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CallbackObject_COMTypeInfo {
                pub _address: u8,
            }
            pub type CallbackObject_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct CallbackObject_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_CallbackObject_cycleCollection() {
                assert_eq!(::std::mem::size_of::<CallbackObject_cycleCollection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           CallbackObject_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<CallbackObject_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            CallbackObject_cycleCollection ) ));
            }
            impl Clone for CallbackObject_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum CallbackObject_ExceptionHandling {
                eReportExceptions = 0,
                eRethrowContentExceptions = 1,
                eRethrowExceptions = 2,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallbackObject_JSObjectsDropper {
                pub mHolder: root::RefPtr<root::mozilla::dom::CallbackObject>,
            }
            #[test]
            fn bindgen_test_layout_CallbackObject_JSObjectsDropper() {
                assert_eq!(::std::mem::size_of::<CallbackObject_JSObjectsDropper>()
                           , 8usize , concat ! (
                           "Size of: " , stringify ! (
                           CallbackObject_JSObjectsDropper ) ));
                assert_eq! (::std::mem::align_of::<CallbackObject_JSObjectsDropper>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            CallbackObject_JSObjectsDropper ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const CallbackObject_JSObjectsDropper )
                            ) . mHolder as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_JSObjectsDropper ) , "::" ,
                            stringify ! ( mHolder ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct CallbackObject_FastCallbackConstructor {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_CallbackObject_FastCallbackConstructor() {
                assert_eq!(::std::mem::size_of::<CallbackObject_FastCallbackConstructor>()
                           , 1usize , concat ! (
                           "Size of: " , stringify ! (
                           CallbackObject_FastCallbackConstructor ) ));
                assert_eq! (::std::mem::align_of::<CallbackObject_FastCallbackConstructor>()
                            , 1usize , concat ! (
                            "Alignment of " , stringify ! (
                            CallbackObject_FastCallbackConstructor ) ));
            }
            impl Clone for CallbackObject_FastCallbackConstructor {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallbackObject_CallSetup {
                pub mCx: *mut root::JSContext,
                pub mCompartment: *mut root::JSCompartment,
                pub mAutoEntryScript: [u64; 20usize],
                pub mAutoIncumbentScript: [u64; 5usize],
                pub mRootedCallable: [u64; 4usize],
                pub mAsyncStack: [u64; 4usize],
                pub mAsyncStackSetter: [u64; 7usize],
                pub mAc: [u64; 3usize],
                pub mErrorResult: *mut root::mozilla::ErrorResult,
                pub mExceptionHandling: root::mozilla::dom::CallbackObject_ExceptionHandling,
                pub mIsMainThread: bool,
            }
            #[test]
            fn bindgen_test_layout_CallbackObject_CallSetup() {
                assert_eq!(::std::mem::size_of::<CallbackObject_CallSetup>() ,
                           376usize , concat ! (
                           "Size of: " , stringify ! (
                           CallbackObject_CallSetup ) ));
                assert_eq! (::std::mem::align_of::<CallbackObject_CallSetup>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            CallbackObject_CallSetup ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mCx as * const _ as usize } , 0usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mCx ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mCompartment as * const _ as usize } , 8usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mCompartment ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mAutoEntryScript as * const _ as usize } ,
                            16usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mAutoEntryScript ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mAutoIncumbentScript as * const _ as usize } ,
                            176usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mAutoIncumbentScript ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mRootedCallable as * const _ as usize } ,
                            216usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mRootedCallable ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mAsyncStack as * const _ as usize } , 248usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mAsyncStack ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mAsyncStackSetter as * const _ as usize } ,
                            280usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mAsyncStackSetter ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mAc as * const _ as usize } , 336usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mAc ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mErrorResult as * const _ as usize } , 360usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mErrorResult ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mExceptionHandling as * const _ as usize } ,
                            368usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mExceptionHandling ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mIsMainThread as * const _ as usize } , 372usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mIsMainThread ) ));
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom14CallbackObject21_cycleCollectorGlobalE"]
                pub static mut CallbackObject__cycleCollectorGlobal:
                           root::mozilla::dom::CallbackObject_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_CallbackObject() {
                assert_eq!(::std::mem::size_of::<CallbackObject>() , 48usize ,
                           concat ! (
                           "Size of: " , stringify ! ( CallbackObject ) ));
                assert_eq! (::std::mem::align_of::<CallbackObject>() , 8usize
                            , concat ! (
                            "Alignment of " , stringify ! ( CallbackObject )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject ) ) . mRefCnt
                            as * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject ) , "::" , stringify ! ( mRefCnt )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject ) ) .
                            mCallback as * const _ as usize } , 16usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject ) , "::" , stringify ! ( mCallback
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject ) ) .
                            mCreationStack as * const _ as usize } , 24usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject ) , "::" , stringify ! (
                            mCreationStack ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject ) ) .
                            mIncumbentGlobal as * const _ as usize } , 32usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject ) , "::" , stringify ! (
                            mIncumbentGlobal ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject ) ) .
                            mIncumbentJSGlobal as * const _ as usize } ,
                            40usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject ) , "::" , stringify ! (
                            mIncumbentJSGlobal ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallbackObjectHolder {
                pub mPtrBits: usize,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct CallbackObjectHolderBase {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_CallbackObjectHolderBase() {
                assert_eq!(::std::mem::size_of::<CallbackObjectHolderBase>() ,
                           1usize , concat ! (
                           "Size of: " , stringify ! (
                           CallbackObjectHolderBase ) ));
                assert_eq! (::std::mem::align_of::<CallbackObjectHolderBase>()
                            , 1usize , concat ! (
                            "Alignment of " , stringify ! (
                            CallbackObjectHolderBase ) ));
            }
            impl Clone for CallbackObjectHolderBase {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallbackFunction {
                pub _base: root::mozilla::dom::CallbackObject,
            }
            #[test]
            fn bindgen_test_layout_CallbackFunction() {
                assert_eq!(::std::mem::size_of::<CallbackFunction>() , 48usize
                           , concat ! (
                           "Size of: " , stringify ! ( CallbackFunction ) ));
                assert_eq! (::std::mem::align_of::<CallbackFunction>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! ( CallbackFunction )
                            ));
            }
            pub mod prototypes {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
            pub mod constructors {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
            pub mod namedpropertiesobjects {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum VisibilityState {
                Hidden = 0,
                Visible = 1,
                Prerender = 2,
                EndGuard_ = 3,
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum FlashClassification {
                Unclassified = 0,
                Unknown = 1,
                Allowed = 2,
                Denied = 3,
                EndGuard_ = 4,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ElementCreationOptions {
                pub _base: root::mozilla::dom::DictionaryBase,
                pub mIs: [u64; 3usize],
                pub mPseudo: [u64; 3usize],
            }
            #[test]
            fn bindgen_test_layout_ElementCreationOptions() {
                assert_eq!(::std::mem::size_of::<ElementCreationOptions>() ,
                           56usize , concat ! (
                           "Size of: " , stringify ! ( ElementCreationOptions
                           ) ));
                assert_eq! (::std::mem::align_of::<ElementCreationOptions>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            ElementCreationOptions ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ElementCreationOptions ) ) .
                            mIs as * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ElementCreationOptions ) , "::" , stringify ! (
                            mIs ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ElementCreationOptions ) ) .
                            mPseudo as * const _ as usize } , 32usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            ElementCreationOptions ) , "::" , stringify ! (
                            mPseudo ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ElementCreationOptionsOrString {
                pub mType: root::mozilla::dom::ElementCreationOptionsOrString_Type,
                pub mValue: root::mozilla::dom::ElementCreationOptionsOrString_Value,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum ElementCreationOptionsOrString_Type {
                eUninitialized = 0,
                eElementCreationOptions = 1,
                eString = 2,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct ElementCreationOptionsOrString_Value {
                pub mElementCreationOptions: root::__BindgenUnionField<root::mozilla::dom::UnionMember>,
                pub mString: root::__BindgenUnionField<root::mozilla::dom::UnionMember>,
                pub bindgen_union_field: [u64; 18usize],
            }
            #[test]
            fn bindgen_test_layout_ElementCreationOptionsOrString_Value() {
                assert_eq!(::std::mem::size_of::<ElementCreationOptionsOrString_Value>()
                           , 144usize , concat ! (
                           "Size of: " , stringify ! (
                           ElementCreationOptionsOrString_Value ) ));
                assert_eq! (::std::mem::align_of::<ElementCreationOptionsOrString_Value>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            ElementCreationOptionsOrString_Value ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const ElementCreationOptionsOrString_Value
                            ) ) . mElementCreationOptions as * const _ as
                            usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ElementCreationOptionsOrString_Value ) , "::" ,
                            stringify ! ( mElementCreationOptions ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const ElementCreationOptionsOrString_Value
                            ) ) . mString as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ElementCreationOptionsOrString_Value ) , "::" ,
                            stringify ! ( mString ) ));
            }
            impl Clone for ElementCreationOptionsOrString_Value {
                fn clone(&self) -> Self { *self }
            }
            #[test]
            fn bindgen_test_layout_ElementCreationOptionsOrString() {
                assert_eq!(::std::mem::size_of::<ElementCreationOptionsOrString>()
                           , 152usize , concat ! (
                           "Size of: " , stringify ! (
                           ElementCreationOptionsOrString ) ));
                assert_eq! (::std::mem::align_of::<ElementCreationOptionsOrString>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            ElementCreationOptionsOrString ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const ElementCreationOptionsOrString )
                            ) . mType as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ElementCreationOptionsOrString ) , "::" ,
                            stringify ! ( mType ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const ElementCreationOptionsOrString )
                            ) . mValue as * const _ as usize } , 8usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ElementCreationOptionsOrString ) , "::" ,
                            stringify ! ( mValue ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Animation {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AnonymousContent {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct Attr {
                pub _base: root::nsIAttribute,
                pub _base_1: root::nsIDOMAttr,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mValue: ::nsstring::nsStringRepr,
            }
            pub type Attr_HasThreadSafeRefCnt = root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Attr_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_Attr_cycleCollection() {
                assert_eq!(::std::mem::size_of::<Attr_cycleCollection>() ,
                           16usize , concat ! (
                           "Size of: " , stringify ! ( Attr_cycleCollection )
                           ));
                assert_eq! (::std::mem::align_of::<Attr_cycleCollection>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            Attr_cycleCollection ) ));
            }
            impl Clone for Attr_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            extern "C" {
                #[link_name = "_ZN7mozilla3dom4Attr21_cycleCollectorGlobalE"]
                pub static mut Attr__cycleCollectorGlobal:
                           root::mozilla::dom::Attr_cycleCollection;
            }
            extern "C" {
                #[link_name = "_ZN7mozilla3dom4Attr12sInitializedE"]
                pub static mut Attr_sInitialized: bool;
            }
            #[test]
            fn bindgen_test_layout_Attr() {
                assert_eq!(::std::mem::size_of::<Attr>() , 128usize , concat !
                           ( "Size of: " , stringify ! ( Attr ) ));
                assert_eq! (::std::mem::align_of::<Attr>() , 8usize , concat !
                            ( "Alignment of " , stringify ! ( Attr ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct BoxObject {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CDATASection {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Comment {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DocumentFragment {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DocumentTimeline {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DocumentType {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DOMImplementation {
                _unused: [u8; 0],
            }
            #[repr(C)]
            pub struct DOMIntersectionObserver {
                pub _base: root::nsISupports,
                pub _base_1: root::nsWrapperCache,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mOwner: root::nsCOMPtr,
                pub mDocument: root::RefPtr<root::nsIDocument>,
                pub mCallback: root::RefPtr<root::mozilla::dom::IntersectionCallback>,
                pub mRoot: root::RefPtr<root::mozilla::dom::Element>,
                pub mRootMargin: root::nsCSSRect,
                pub mThresholds: root::nsTArray<f64>,
                pub mObservationTargets: root::nsTArray<*mut root::mozilla::dom::Element>,
                pub mQueuedEntries: root::nsTArray<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>,
                pub mConnected: bool,
            }
            pub type DOMIntersectionObserver_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DOMIntersectionObserver_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_DOMIntersectionObserver_cycleCollection() {
                assert_eq!(::std::mem::size_of::<DOMIntersectionObserver_cycleCollection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           DOMIntersectionObserver_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<DOMIntersectionObserver_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            DOMIntersectionObserver_cycleCollection ) ));
            }
            impl Clone for DOMIntersectionObserver_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DOMIntersectionObserver_COMTypeInfo {
                pub _address: u8,
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom23DOMIntersectionObserver21_cycleCollectorGlobalE"]
                pub static mut DOMIntersectionObserver__cycleCollectorGlobal:
                           root::mozilla::dom::DOMIntersectionObserver_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_DOMIntersectionObserver() {
                assert_eq!(::std::mem::size_of::<DOMIntersectionObserver>() ,
                           168usize , concat ! (
                           "Size of: " , stringify ! ( DOMIntersectionObserver
                           ) ));
                assert_eq! (::std::mem::align_of::<DOMIntersectionObserver>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            DOMIntersectionObserver ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DOMStringList {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ElementRegistrationOptions {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct FontFaceSet {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct FrameRequestCallback {
                pub _base: root::mozilla::dom::CallbackFunction,
            }
            #[test]
            fn bindgen_test_layout_FrameRequestCallback() {
                assert_eq!(::std::mem::size_of::<FrameRequestCallback>() ,
                           48usize , concat ! (
                           "Size of: " , stringify ! ( FrameRequestCallback )
                           ));
                assert_eq! (::std::mem::align_of::<FrameRequestCallback>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            FrameRequestCallback ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct FullscreenRequest {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ImageTracker {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HTMLBodyElement {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Link {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct MediaQueryList {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct NodeFilter {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct NodeIterator {
                _unused: [u8; 0],
            }
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum OrientationType { }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ProcessingInstruction {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ScriptLoader {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct StyleSheetList {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct SVGSVGElement {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TouchList {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TreeWalker {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct XPathEvaluator {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct XPathExpression {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct XPathNSResolver {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct XPathResult {
                _unused: [u8; 0],
            }
            pub type NodeFilterHolder =
                root::mozilla::dom::CallbackObjectHolder;
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum ScrollBehavior {
                Auto = 0,
                Instant = 1,
                Smooth = 2,
                EndGuard_ = 3,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct ScrollOptions {
                pub _base: root::mozilla::dom::DictionaryBase,
                pub mBehavior: root::mozilla::dom::ScrollBehavior,
            }
            #[test]
            fn bindgen_test_layout_ScrollOptions() {
                assert_eq!(::std::mem::size_of::<ScrollOptions>() , 2usize ,
                           concat ! (
                           "Size of: " , stringify ! ( ScrollOptions ) ));
                assert_eq! (::std::mem::align_of::<ScrollOptions>() , 1usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( ScrollOptions )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollOptions ) ) . mBehavior
                            as * const _ as usize } , 1usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollOptions ) , "::" , stringify ! ( mBehavior )
                            ));
            }
            impl Clone for ScrollOptions {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ScrollToOptions {
                pub _base: root::mozilla::dom::ScrollOptions,
                pub mLeft: [u64; 2usize],
                pub mTop: [u64; 2usize],
            }
            #[test]
            fn bindgen_test_layout_ScrollToOptions() {
                assert_eq!(::std::mem::size_of::<ScrollToOptions>() , 40usize
                           , concat ! (
                           "Size of: " , stringify ! ( ScrollToOptions ) ));
                assert_eq! (::std::mem::align_of::<ScrollToOptions>() , 8usize
                            , concat ! (
                            "Alignment of " , stringify ! ( ScrollToOptions )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollToOptions ) ) . mLeft
                            as * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollToOptions ) , "::" , stringify ! ( mLeft )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollToOptions ) ) . mTop as
                            * const _ as usize } , 24usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollToOptions ) , "::" , stringify ! ( mTop )
                            ));
            }
            /**
 * StyleChildrenIterator traverses the children of the element from the
 * perspective of the style system, particularly the children we need to
 * traverse during restyle.
 *
 * At present, this is identical to AllChildrenIterator with
 * (eAllChildren | eSkipDocumentLevelNativeAnonymousContent). We used to have
 * detect and skip any native anonymous children that are used to implement some
 * special magic in here that went away, but we keep the separate class so
 * we can reintroduce special magic back if needed.
 *
 * Note: it assumes that no mutation of the DOM or frame tree takes place during
 * iteration, and will break horribly if that is not true.
 *
 * We require this to be memmovable since Rust code can create and move
 * StyleChildrenIterators.
 */
            #[repr(C)]
            #[derive(Debug)]
            pub struct StyleChildrenIterator {
                pub _base: root::mozilla::dom::AllChildrenIterator,
            }
            #[test]
            fn bindgen_test_layout_StyleChildrenIterator() {
                assert_eq!(::std::mem::size_of::<StyleChildrenIterator>() ,
                           80usize , concat ! (
                           "Size of: " , stringify ! ( StyleChildrenIterator )
                           ));
                assert_eq! (::std::mem::align_of::<StyleChildrenIterator>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            StyleChildrenIterator ) ));
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum CompositeOperation {
                Replace = 0,
                Add = 1,
                Accumulate = 2,
                EndGuard_ = 3,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CSSPseudoElement {
                _unused: [u8; 0],
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum IterationCompositeOperation {
                Replace = 0,
                Accumulate = 1,
                EndGuard_ = 2,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ElementOrCSSPseudoElement {
                pub mType: root::mozilla::dom::ElementOrCSSPseudoElement_Type,
                pub mValue: root::mozilla::dom::ElementOrCSSPseudoElement_Value,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum ElementOrCSSPseudoElement_Type {
                eUninitialized = 0,
                eElement = 1,
                eCSSPseudoElement = 2,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct ElementOrCSSPseudoElement_Value {
                pub mElement: root::__BindgenUnionField<root::mozilla::dom::UnionMember>,
                pub mCSSPseudoElement: root::__BindgenUnionField<root::mozilla::dom::UnionMember>,
                pub bindgen_union_field: u64,
            }
            #[test]
            fn bindgen_test_layout_ElementOrCSSPseudoElement_Value() {
                assert_eq!(::std::mem::size_of::<ElementOrCSSPseudoElement_Value>()
                           , 8usize , concat ! (
                           "Size of: " , stringify ! (
                           ElementOrCSSPseudoElement_Value ) ));
                assert_eq! (::std::mem::align_of::<ElementOrCSSPseudoElement_Value>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            ElementOrCSSPseudoElement_Value ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const ElementOrCSSPseudoElement_Value )
                            ) . mElement as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ElementOrCSSPseudoElement_Value ) , "::" ,
                            stringify ! ( mElement ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const ElementOrCSSPseudoElement_Value )
                            ) . mCSSPseudoElement as * const _ as usize } ,
                            0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ElementOrCSSPseudoElement_Value ) , "::" ,
                            stringify ! ( mCSSPseudoElement ) ));
            }
            impl Clone for ElementOrCSSPseudoElement_Value {
                fn clone(&self) -> Self { *self }
            }
            #[test]
            fn bindgen_test_layout_ElementOrCSSPseudoElement() {
                assert_eq!(::std::mem::size_of::<ElementOrCSSPseudoElement>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           ElementOrCSSPseudoElement ) ));
                assert_eq! (::std::mem::align_of::<ElementOrCSSPseudoElement>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            ElementOrCSSPseudoElement ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ElementOrCSSPseudoElement ) )
                            . mType as * const _ as usize } , 0usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            ElementOrCSSPseudoElement ) , "::" , stringify ! (
                            mType ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ElementOrCSSPseudoElement ) )
                            . mValue as * const _ as usize } , 8usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            ElementOrCSSPseudoElement ) , "::" , stringify ! (
                            mValue ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct XBLChildrenElement {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CustomElementData {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct FragmentOrElement {
                pub _base: root::nsIContent,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                /**
   * Array containing all attributes and children for this element
   */
                pub mAttrsAndChildren: root::nsAttrAndChildArray,
            }
            pub type FragmentOrElement_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct FragmentOrElement_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_FragmentOrElement_cycleCollection() {
                assert_eq!(::std::mem::size_of::<FragmentOrElement_cycleCollection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           FragmentOrElement_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<FragmentOrElement_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            FragmentOrElement_cycleCollection ) ));
            }
            impl Clone for FragmentOrElement_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            /**
   * There are a set of DOM- and scripting-specific instance variables
   * that may only be instantiated when a content object is accessed
   * through the DOM. Rather than burn actual slots in the content
   * objects for each of these instance variables, we put them off
   * in a side structure that's only allocated when the content is
   * accessed through the DOM.
   */
            #[repr(C)]
            #[derive(Debug)]
            pub struct FragmentOrElement_nsDOMSlots {
                pub _base: root::nsINode_nsSlots,
                /**
     * The .style attribute (an interface that forwards to the actual
     * style rules)
     * @see nsGenericHTMLElement::GetStyle
     */
                pub mStyle: root::nsCOMPtr,
                /**
     * The .dataset attribute.
     * @see nsGenericHTMLElement::GetDataset
     */
                pub mDataset: *mut root::nsDOMStringMap,
                /**
     * SMIL Overridde style rules (for SMIL animation of CSS properties)
     * @see Element::GetSMILOverrideStyle
     */
                pub mSMILOverrideStyle: root::nsCOMPtr,
                /**
     * Holds any SMIL override style declaration for this element.
     */
                pub mSMILOverrideStyleDeclaration: root::RefPtr<root::mozilla::DeclarationBlock>,
                /**
     * An object implementing nsIDOMMozNamedAttrMap for this content (attributes)
     * @see FragmentOrElement::GetAttributes
     */
                pub mAttributeMap: root::RefPtr<root::nsDOMAttributeMap>,
                pub __bindgen_anon_1: root::mozilla::dom::FragmentOrElement_nsDOMSlots__bindgen_ty_1,
                /**
     * An object implementing the .children property for this element.
     */
                pub mChildrenList: root::RefPtr<root::nsContentList>,
                /**
     * An object implementing the .classList property for this element.
     */
                pub mClassList: root::RefPtr<root::nsDOMTokenList>,
                pub mLabelsList: root::RefPtr<root::nsLabelsNodeList>,
                /**
     * ShadowRoot bound to the element.
     */
                pub mShadowRoot: root::RefPtr<root::mozilla::dom::ShadowRoot>,
                /**
     * The root ShadowRoot of this element if it is in a shadow tree.
     */
                pub mContainingShadow: root::RefPtr<root::mozilla::dom::ShadowRoot>,
                /**
     * An array of web component insertion points to which this element
     * is distributed.
     */
                pub mDestInsertionPoints: root::nsTArray<*mut root::nsIContent>,
                /**
     * XBL binding installed on the element.
     */
                pub mXBLBinding: root::RefPtr<root::nsXBLBinding>,
                /**
     * XBL binding installed on the lement.
     */
                pub mXBLInsertionParent: root::nsCOMPtr,
                /**
     * Web components custom element data.
     */
                pub mCustomElementData: root::RefPtr<root::mozilla::dom::CustomElementData>,
                /**
     * Registered Intersection Observers on the element.
     */
                pub mRegisteredIntersectionObservers: [u64; 5usize],
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct FragmentOrElement_nsDOMSlots__bindgen_ty_1 {
                /**
      * The nearest enclosing content node with a binding that created us.
      * @see FragmentOrElement::GetBindingParent
      */
                pub mBindingParent: root::__BindgenUnionField<*mut root::nsIContent>,
                /**
      * The controllers of the XUL Element.
      */
                pub mControllers: root::__BindgenUnionField<*mut root::nsIControllers>,
                pub bindgen_union_field: u64,
            }
            #[test]
            fn bindgen_test_layout_FragmentOrElement_nsDOMSlots__bindgen_ty_1() {
                assert_eq!(::std::mem::size_of::<FragmentOrElement_nsDOMSlots__bindgen_ty_1>()
                           , 8usize , concat ! (
                           "Size of: " , stringify ! (
                           FragmentOrElement_nsDOMSlots__bindgen_ty_1 ) ));
                assert_eq! (::std::mem::align_of::<FragmentOrElement_nsDOMSlots__bindgen_ty_1>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            FragmentOrElement_nsDOMSlots__bindgen_ty_1 ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const
                            FragmentOrElement_nsDOMSlots__bindgen_ty_1 ) ) .
                            mBindingParent as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots__bindgen_ty_1 ) ,
                            "::" , stringify ! ( mBindingParent ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const
                            FragmentOrElement_nsDOMSlots__bindgen_ty_1 ) ) .
                            mControllers as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots__bindgen_ty_1 ) ,
                            "::" , stringify ! ( mControllers ) ));
            }
            impl Clone for FragmentOrElement_nsDOMSlots__bindgen_ty_1 {
                fn clone(&self) -> Self { *self }
            }
            #[test]
            fn bindgen_test_layout_FragmentOrElement_nsDOMSlots() {
                assert_eq!(::std::mem::size_of::<FragmentOrElement_nsDOMSlots>()
                           , 208usize , concat ! (
                           "Size of: " , stringify ! (
                           FragmentOrElement_nsDOMSlots ) ));
                assert_eq! (::std::mem::align_of::<FragmentOrElement_nsDOMSlots>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mStyle as * const _ as usize } , 48usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mStyle ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mDataset as * const _ as usize } , 56usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mDataset ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mSMILOverrideStyle as * const _ as usize } ,
                            64usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mSMILOverrideStyle ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mSMILOverrideStyleDeclaration as * const _ as
                            usize } , 72usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mSMILOverrideStyleDeclaration ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mAttributeMap as * const _ as usize } , 80usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mAttributeMap ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mChildrenList as * const _ as usize } , 96usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mChildrenList ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mClassList as * const _ as usize } , 104usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mClassList ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mLabelsList as * const _ as usize } , 112usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mLabelsList ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mShadowRoot as * const _ as usize } , 120usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mShadowRoot ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mContainingShadow as * const _ as usize } ,
                            128usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mContainingShadow ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mDestInsertionPoints as * const _ as usize } ,
                            136usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mDestInsertionPoints ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mXBLBinding as * const _ as usize } , 144usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mXBLBinding ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mXBLInsertionParent as * const _ as usize } ,
                            152usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mXBLInsertionParent ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mCustomElementData as * const _ as usize } ,
                            160usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mCustomElementData ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mRegisteredIntersectionObservers as * const _ as
                            usize } , 168usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mRegisteredIntersectionObservers ) ));
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom17FragmentOrElement21_cycleCollectorGlobalE"]
                pub static mut FragmentOrElement__cycleCollectorGlobal:
                           root::mozilla::dom::FragmentOrElement_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_FragmentOrElement() {
                assert_eq!(::std::mem::size_of::<FragmentOrElement>() ,
                           104usize , concat ! (
                           "Size of: " , stringify ! ( FragmentOrElement ) ));
                assert_eq! (::std::mem::align_of::<FragmentOrElement>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! ( FragmentOrElement
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FragmentOrElement ) ) .
                            mRefCnt as * const _ as usize } , 88usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement ) , "::" , stringify ! ( mRefCnt
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FragmentOrElement ) ) .
                            mAttrsAndChildren as * const _ as usize } ,
                            96usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement ) , "::" , stringify ! (
                            mAttrsAndChildren ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct SVGAnimationElement {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct DOMRect {
                pub _base: root::mozilla::dom::DOMRectReadOnly,
                pub _base_1: root::nsIDOMClientRect,
                pub mX: f64,
                pub mY: f64,
                pub mWidth: f64,
                pub mHeight: f64,
            }
            #[test]
            fn bindgen_test_layout_DOMRect() {
                assert_eq!(::std::mem::size_of::<DOMRect>() , 88usize , concat
                           ! ( "Size of: " , stringify ! ( DOMRect ) ));
                assert_eq! (::std::mem::align_of::<DOMRect>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( DOMRect ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct DOMRectList {
                pub _base: root::nsIDOMClientRectList,
                pub _base_1: root::nsWrapperCache,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mArray: root::nsTArray<root::RefPtr<root::mozilla::dom::DOMRect>>,
                pub mParent: root::nsCOMPtr,
            }
            pub type DOMRectList_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DOMRectList_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_DOMRectList_cycleCollection() {
                assert_eq!(::std::mem::size_of::<DOMRectList_cycleCollection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           DOMRectList_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<DOMRectList_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            DOMRectList_cycleCollection ) ));
            }
            impl Clone for DOMRectList_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom11DOMRectList21_cycleCollectorGlobalE"]
                pub static mut DOMRectList__cycleCollectorGlobal:
                           root::mozilla::dom::DOMRectList_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_DOMRectList() {
                assert_eq!(::std::mem::size_of::<DOMRectList>() , 56usize ,
                           concat ! (
                           "Size of: " , stringify ! ( DOMRectList ) ));
                assert_eq! (::std::mem::align_of::<DOMRectList>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( DOMRectList ) ));
            }
            pub type DOMTokenListSupportedToken =
                *const ::std::os::raw::c_char;
            pub type DOMTokenListSupportedTokenArray =
                *mut root::mozilla::dom::DOMTokenListSupportedToken;
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum ScrollLogicalPosition {
                Start = 0,
                End = 1,
                EndGuard_ = 2,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct ScrollIntoViewOptions {
                pub _base: root::mozilla::dom::ScrollOptions,
                pub mBlock: root::mozilla::dom::ScrollLogicalPosition,
            }
            #[test]
            fn bindgen_test_layout_ScrollIntoViewOptions() {
                assert_eq!(::std::mem::size_of::<ScrollIntoViewOptions>() ,
                           3usize , concat ! (
                           "Size of: " , stringify ! ( ScrollIntoViewOptions )
                           ));
                assert_eq! (::std::mem::align_of::<ScrollIntoViewOptions>() ,
                            1usize , concat ! (
                            "Alignment of " , stringify ! (
                            ScrollIntoViewOptions ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollIntoViewOptions ) ) .
                            mBlock as * const _ as usize } , 2usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            ScrollIntoViewOptions ) , "::" , stringify ! (
                            mBlock ) ));
            }
            impl Clone for ScrollIntoViewOptions {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct DOMIntersectionObserverEntry {
                pub _base: root::nsISupports,
                pub _base_1: root::nsWrapperCache,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mOwner: root::nsCOMPtr,
                pub mTime: root::DOMHighResTimeStamp,
                pub mRootBounds: root::RefPtr<root::mozilla::dom::DOMRect>,
                pub mBoundingClientRect: root::RefPtr<root::mozilla::dom::DOMRect>,
                pub mIntersectionRect: root::RefPtr<root::mozilla::dom::DOMRect>,
                pub mIsIntersecting: bool,
                pub mTarget: root::RefPtr<root::mozilla::dom::Element>,
                pub mIntersectionRatio: f64,
            }
            pub type DOMIntersectionObserverEntry_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DOMIntersectionObserverEntry_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_DOMIntersectionObserverEntry_cycleCollection() {
                assert_eq!(::std::mem::size_of::<DOMIntersectionObserverEntry_cycleCollection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           DOMIntersectionObserverEntry_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<DOMIntersectionObserverEntry_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            DOMIntersectionObserverEntry_cycleCollection ) ));
            }
            impl Clone for DOMIntersectionObserverEntry_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom28DOMIntersectionObserverEntry21_cycleCollectorGlobalE"]
                pub static mut
                           DOMIntersectionObserverEntry__cycleCollectorGlobal:
                           root::mozilla::dom::DOMIntersectionObserverEntry_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_DOMIntersectionObserverEntry() {
                assert_eq!(::std::mem::size_of::<DOMIntersectionObserverEntry>()
                           , 104usize , concat ! (
                           "Size of: " , stringify ! (
                           DOMIntersectionObserverEntry ) ));
                assert_eq! (::std::mem::align_of::<DOMIntersectionObserverEntry>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            DOMIntersectionObserverEntry ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IntersectionCallback {
                pub _base: root::mozilla::dom::CallbackFunction,
            }
            #[test]
            fn bindgen_test_layout_IntersectionCallback() {
                assert_eq!(::std::mem::size_of::<IntersectionCallback>() ,
                           48usize , concat ! (
                           "Size of: " , stringify ! ( IntersectionCallback )
                           ));
                assert_eq! (::std::mem::align_of::<IntersectionCallback>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            IntersectionCallback ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct OwningDoubleOrDoubleSequence {
                pub mType: root::mozilla::dom::OwningDoubleOrDoubleSequence_Type,
                pub mValue: root::mozilla::dom::OwningDoubleOrDoubleSequence_Value,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum OwningDoubleOrDoubleSequence_Type {
                eUninitialized = 0,
                eDouble = 1,
                eDoubleSequence = 2,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct OwningDoubleOrDoubleSequence_Value {
                pub mDouble: root::__BindgenUnionField<root::mozilla::dom::UnionMember>,
                pub mDoubleSequence: root::__BindgenUnionField<root::mozilla::dom::UnionMember>,
                pub bindgen_union_field: u64,
            }
            #[test]
            fn bindgen_test_layout_OwningDoubleOrDoubleSequence_Value() {
                assert_eq!(::std::mem::size_of::<OwningDoubleOrDoubleSequence_Value>()
                           , 8usize , concat ! (
                           "Size of: " , stringify ! (
                           OwningDoubleOrDoubleSequence_Value ) ));
                assert_eq! (::std::mem::align_of::<OwningDoubleOrDoubleSequence_Value>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            OwningDoubleOrDoubleSequence_Value ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const OwningDoubleOrDoubleSequence_Value )
                            ) . mDouble as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            OwningDoubleOrDoubleSequence_Value ) , "::" ,
                            stringify ! ( mDouble ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const OwningDoubleOrDoubleSequence_Value )
                            ) . mDoubleSequence as * const _ as usize } ,
                            0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            OwningDoubleOrDoubleSequence_Value ) , "::" ,
                            stringify ! ( mDoubleSequence ) ));
            }
            impl Clone for OwningDoubleOrDoubleSequence_Value {
                fn clone(&self) -> Self { *self }
            }
            #[test]
            fn bindgen_test_layout_OwningDoubleOrDoubleSequence() {
                assert_eq!(::std::mem::size_of::<OwningDoubleOrDoubleSequence>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           OwningDoubleOrDoubleSequence ) ));
                assert_eq! (::std::mem::align_of::<OwningDoubleOrDoubleSequence>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            OwningDoubleOrDoubleSequence ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const OwningDoubleOrDoubleSequence ) )
                            . mType as * const _ as usize } , 0usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            OwningDoubleOrDoubleSequence ) , "::" , stringify
                            ! ( mType ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const OwningDoubleOrDoubleSequence ) )
                            . mValue as * const _ as usize } , 8usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            OwningDoubleOrDoubleSequence ) , "::" , stringify
                            ! ( mValue ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IntersectionObserverInit {
                pub _base: root::mozilla::dom::DictionaryBase,
                pub mRoot: root::RefPtr<root::mozilla::dom::Element>,
                pub mRootMargin: ::nsstring::nsStringRepr,
                pub mThreshold: root::mozilla::dom::OwningDoubleOrDoubleSequence,
            }
            #[test]
            fn bindgen_test_layout_IntersectionObserverInit() {
                assert_eq!(::std::mem::size_of::<IntersectionObserverInit>() ,
                           48usize , concat ! (
                           "Size of: " , stringify ! (
                           IntersectionObserverInit ) ));
                assert_eq! (::std::mem::align_of::<IntersectionObserverInit>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            IntersectionObserverInit ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const IntersectionObserverInit ) )
                            . mRoot as * const _ as usize } , 8usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            IntersectionObserverInit ) , "::" , stringify ! (
                            mRoot ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const IntersectionObserverInit ) )
                            . mRootMargin as * const _ as usize } , 16usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            IntersectionObserverInit ) , "::" , stringify ! (
                            mRootMargin ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const IntersectionObserverInit ) )
                            . mThreshold as * const _ as usize } , 32usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            IntersectionObserverInit ) , "::" , stringify ! (
                            mThreshold ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AnimationFilter {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DOMMatrixReadOnly {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct UnrestrictedDoubleOrKeyframeAnimationOptions {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct DestinationInsertionPointList {
                pub _base: root::nsINodeList,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mParent: root::RefPtr<root::mozilla::dom::Element>,
                pub mDestinationPoints: root::nsCOMArray,
            }
            pub type DestinationInsertionPointList_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DestinationInsertionPointList_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_DestinationInsertionPointList_cycleCollection() {
                assert_eq!(::std::mem::size_of::<DestinationInsertionPointList_cycleCollection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           DestinationInsertionPointList_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<DestinationInsertionPointList_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            DestinationInsertionPointList_cycleCollection )
                            ));
            }
            impl Clone for DestinationInsertionPointList_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom29DestinationInsertionPointList21_cycleCollectorGlobalE"]
                pub static mut
                           DestinationInsertionPointList__cycleCollectorGlobal:
                           root::mozilla::dom::DestinationInsertionPointList_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_DestinationInsertionPointList() {
                assert_eq!(::std::mem::size_of::<DestinationInsertionPointList>()
                           , 56usize , concat ! (
                           "Size of: " , stringify ! (
                           DestinationInsertionPointList ) ));
                assert_eq! (::std::mem::align_of::<DestinationInsertionPointList>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            DestinationInsertionPointList ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const DestinationInsertionPointList ) )
                            . mRefCnt as * const _ as usize } , 32usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            DestinationInsertionPointList ) , "::" , stringify
                            ! ( mRefCnt ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const DestinationInsertionPointList ) )
                            . mParent as * const _ as usize } , 40usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            DestinationInsertionPointList ) , "::" , stringify
                            ! ( mParent ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const DestinationInsertionPointList ) )
                            . mDestinationPoints as * const _ as usize } ,
                            48usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            DestinationInsertionPointList ) , "::" , stringify
                            ! ( mDestinationPoints ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Grid {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ExplicitChildIterator {
                pub mParent: *const root::nsIContent,
                pub mChild: *mut root::nsIContent,
                pub mDefaultChild: *mut root::nsIContent,
                pub mShadowIterator: root::nsAutoPtr<root::mozilla::dom::ExplicitChildIterator>,
                pub mIsFirst: bool,
                pub mIndexInInserted: u32,
            }
            #[test]
            fn bindgen_test_layout_ExplicitChildIterator() {
                assert_eq!(::std::mem::size_of::<ExplicitChildIterator>() ,
                           40usize , concat ! (
                           "Size of: " , stringify ! ( ExplicitChildIterator )
                           ));
                assert_eq! (::std::mem::align_of::<ExplicitChildIterator>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            ExplicitChildIterator ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ExplicitChildIterator ) ) .
                            mParent as * const _ as usize } , 0usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            ExplicitChildIterator ) , "::" , stringify ! (
                            mParent ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ExplicitChildIterator ) ) .
                            mChild as * const _ as usize } , 8usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            ExplicitChildIterator ) , "::" , stringify ! (
                            mChild ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ExplicitChildIterator ) ) .
                            mDefaultChild as * const _ as usize } , 16usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ExplicitChildIterator ) , "::" , stringify ! (
                            mDefaultChild ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ExplicitChildIterator ) ) .
                            mShadowIterator as * const _ as usize } , 24usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            ExplicitChildIterator ) , "::" , stringify ! (
                            mShadowIterator ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ExplicitChildIterator ) ) .
                            mIsFirst as * const _ as usize } , 32usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ExplicitChildIterator ) , "::" , stringify ! (
                            mIsFirst ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ExplicitChildIterator ) ) .
                            mIndexInInserted as * const _ as usize } , 36usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            ExplicitChildIterator ) , "::" , stringify ! (
                            mIndexInInserted ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct FlattenedChildIterator {
                pub _base: root::mozilla::dom::ExplicitChildIterator,
                pub mXBLInvolved: bool,
            }
            #[test]
            fn bindgen_test_layout_FlattenedChildIterator() {
                assert_eq!(::std::mem::size_of::<FlattenedChildIterator>() ,
                           48usize , concat ! (
                           "Size of: " , stringify ! ( FlattenedChildIterator
                           ) ));
                assert_eq! (::std::mem::align_of::<FlattenedChildIterator>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            FlattenedChildIterator ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FlattenedChildIterator ) ) .
                            mXBLInvolved as * const _ as usize } , 40usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FlattenedChildIterator ) , "::" , stringify ! (
                            mXBLInvolved ) ));
            }
            /**
 * AllChildrenIterator traverses the children of an element including before /
 * after content and optionally XBL children.  The iterator can be initialized
 * to start at the end by providing false for aStartAtBeginning in order to
 * start iterating in reverse from the last child.
 *
 * Note: it assumes that no mutation of the DOM or frame tree takes place during
 * iteration, and will break horribly if that is not true.
 */
            #[repr(C)]
            #[derive(Debug)]
            pub struct AllChildrenIterator {
                pub _base: root::mozilla::dom::FlattenedChildIterator,
                pub mOriginalContent: *const root::nsIContent,
                pub mAnonKids: root::nsTArray<*mut root::nsIContent>,
                pub mAnonKidsIdx: u32,
                pub mFlags: u32,
                pub mPhase: root::mozilla::dom::AllChildrenIterator_IteratorPhase,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum AllChildrenIterator_IteratorPhase {
                eAtBegin = 0,
                eAtBeforeKid = 1,
                eAtExplicitKids = 2,
                eAtAnonKids = 3,
                eAtAfterKid = 4,
                eAtEnd = 5,
            }
            #[test]
            fn bindgen_test_layout_AllChildrenIterator() {
                assert_eq!(::std::mem::size_of::<AllChildrenIterator>() ,
                           80usize , concat ! (
                           "Size of: " , stringify ! ( AllChildrenIterator )
                           ));
                assert_eq! (::std::mem::align_of::<AllChildrenIterator>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            AllChildrenIterator ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AllChildrenIterator ) ) .
                            mOriginalContent as * const _ as usize } , 48usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            AllChildrenIterator ) , "::" , stringify ! (
                            mOriginalContent ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AllChildrenIterator ) ) .
                            mAnonKids as * const _ as usize } , 56usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            AllChildrenIterator ) , "::" , stringify ! (
                            mAnonKids ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AllChildrenIterator ) ) .
                            mAnonKidsIdx as * const _ as usize } , 64usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            AllChildrenIterator ) , "::" , stringify ! (
                            mAnonKidsIdx ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AllChildrenIterator ) ) .
                            mFlags as * const _ as usize } , 68usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            AllChildrenIterator ) , "::" , stringify ! (
                            mFlags ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AllChildrenIterator ) ) .
                            mPhase as * const _ as usize } , 72usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            AllChildrenIterator ) , "::" , stringify ! (
                            mPhase ) ));
            }
            /**
 * CSSValue - a DOM object representing values in DOM computed style.
 */
            #[repr(C)]
            #[derive(Debug)]
            pub struct CSSValue {
                pub _base: root::nsISupports,
                pub _base_1: root::nsWrapperCache,
            }
            #[test]
            fn bindgen_test_layout_CSSValue() {
                assert_eq!(::std::mem::size_of::<CSSValue>() , 32usize ,
                           concat ! ( "Size of: " , stringify ! ( CSSValue )
                           ));
                assert_eq! (::std::mem::align_of::<CSSValue>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( CSSValue ) ));
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CSSVariableResolver {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct CSSVariableValues {
            /**
   * Map of variable names to IDs.  Variable IDs are indexes into
   * mVariables.
   */
            pub mVariableIDs: [u64; 5usize],
            /**
   * Array of variables, indexed by variable ID.
   */
            pub mVariables: root::nsTArray<root::mozilla::CSSVariableValues_Variable>,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct CSSVariableValues_Variable {
            pub mVariableName: ::nsstring::nsStringRepr,
            pub mValue: ::nsstring::nsStringRepr,
            pub mFirstToken: root::nsCSSTokenSerializationType,
            pub mLastToken: root::nsCSSTokenSerializationType,
        }
        #[test]
        fn bindgen_test_layout_CSSVariableValues_Variable() {
            assert_eq!(::std::mem::size_of::<CSSVariableValues_Variable>() ,
                       40usize , concat ! (
                       "Size of: " , stringify ! ( CSSVariableValues_Variable
                       ) ));
            assert_eq! (::std::mem::align_of::<CSSVariableValues_Variable>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! (
                        CSSVariableValues_Variable ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSVariableValues_Variable ) ) .
                        mVariableName as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        CSSVariableValues_Variable ) , "::" , stringify ! (
                        mVariableName ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSVariableValues_Variable ) ) .
                        mValue as * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        CSSVariableValues_Variable ) , "::" , stringify ! (
                        mValue ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSVariableValues_Variable ) ) .
                        mFirstToken as * const _ as usize } , 32usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        CSSVariableValues_Variable ) , "::" , stringify ! (
                        mFirstToken ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSVariableValues_Variable ) ) .
                        mLastToken as * const _ as usize } , 36usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        CSSVariableValues_Variable ) , "::" , stringify ! (
                        mLastToken ) ));
        }
        #[test]
        fn bindgen_test_layout_CSSVariableValues() {
            assert_eq!(::std::mem::size_of::<CSSVariableValues>() , 48usize ,
                       concat ! (
                       "Size of: " , stringify ! ( CSSVariableValues ) ));
            assert_eq! (::std::mem::align_of::<CSSVariableValues>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( CSSVariableValues )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSVariableValues ) ) .
                        mVariableIDs as * const _ as usize } , 0usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        CSSVariableValues ) , "::" , stringify ! (
                        mVariableIDs ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSVariableValues ) ) .
                        mVariables as * const _ as usize } , 40usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        CSSVariableValues ) , "::" , stringify ! ( mVariables
                        ) ));
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum SheetType {
            Agent = 0,
            User = 1,
            PresHint = 2,
            Doc = 3,
            ScopedDoc = 4,
            StyleAttr = 5,
            Override = 6,
            Animation = 7,
            Transition = 8,
            Count = 9,
            Unknown = 255,
        }
        /**
 * StaticAutoPtr and StaticRefPtr are like nsAutoPtr and nsRefPtr, except they
 * are suitable for use as global variables.
 *
 * In particular, a global instance of Static{Auto,Ref}Ptr doesn't cause the
 * compiler to emit  a static initializer (in release builds, anyway).
 *
 * In order to accomplish this, Static{Auto,Ref}Ptr must have a trivial
 * constructor and destructor.  As a consequence, it cannot initialize its raw
 * pointer to 0 on construction, and it cannot delete/release its raw pointer
 * upon destruction.
 *
 * Since the compiler guarantees that all global variables are initialized to
 * 0, these trivial constructors are safe.  Since we rely on this, the clang
 * plugin, run as part of our "static analysis" builds, makes it a compile-time
 * error to use Static{Auto,Ref}Ptr as anything except a global variable.
 *
 * Static{Auto,Ref}Ptr have a limited interface as compared to ns{Auto,Ref}Ptr;
 * this is intentional, since their range of acceptable uses is smaller.
 */
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StaticAutoPtr<T> {
            pub mRawPtr: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        /**
 * This struct represents a combined color from a numeric color and
 * the current foreground color (currentcolor keyword).
 * Conceptually, the formula is "color * (1 - p) + currentcolor * p"
 * where p is mForegroundRatio. See mozilla::LinearBlendColors for
 * the actual algorithm.
 */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleComplexColor {
            pub mColor: root::nscolor,
            pub mForegroundRatio: u8,
            pub mIsAuto: bool,
        }
        #[test]
        fn bindgen_test_layout_StyleComplexColor() {
            assert_eq!(::std::mem::size_of::<StyleComplexColor>() , 8usize ,
                       concat ! (
                       "Size of: " , stringify ! ( StyleComplexColor ) ));
            assert_eq! (::std::mem::align_of::<StyleComplexColor>() , 4usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StyleComplexColor )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleComplexColor ) ) . mColor as
                        * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleComplexColor ) , "::" , stringify ! ( mColor )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleComplexColor ) ) .
                        mForegroundRatio as * const _ as usize } , 4usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleComplexColor ) , "::" , stringify ! (
                        mForegroundRatio ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleComplexColor ) ) . mIsAuto
                        as * const _ as usize } , 5usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleComplexColor ) , "::" , stringify ! ( mIsAuto )
                        ));
        }
        impl Clone for StyleComplexColor {
            fn clone(&self) -> Self { *self }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum Side {
            eSideTop = 0,
            eSideRight = 1,
            eSideBottom = 2,
            eSideLeft = 3,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum HalfCorner {
            eCornerTopLeftX = 0,
            eCornerTopLeftY = 1,
            eCornerTopRightX = 2,
            eCornerTopRightY = 3,
            eCornerBottomRightX = 4,
            eCornerBottomRightY = 5,
            eCornerBottomLeftX = 6,
            eCornerBottomLeftY = 7,
        }
        pub const FontFamilyType_eFamily_generic_first:
                  root::mozilla::FontFamilyType =
            FontFamilyType::eFamily_serif;
        pub const FontFamilyType_eFamily_generic_last:
                  root::mozilla::FontFamilyType =
            FontFamilyType::eFamily_fantasy;
        pub const FontFamilyType_eFamily_generic_count:
                  root::mozilla::FontFamilyType =
            FontFamilyType::eFamily_monospace;
        #[repr(u32)]
        /**
 * type of font family name, either a name (e.g. Helvetica) or a
 * generic (e.g. serif, sans-serif), with the ability to distinguish
 * between unquoted and quoted names for serializaiton
 */
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum FontFamilyType {
            eFamily_none = 0,
            eFamily_named = 1,
            eFamily_named_quoted = 2,
            eFamily_serif = 3,
            eFamily_sans_serif = 4,
            eFamily_monospace = 5,
            eFamily_cursive = 6,
            eFamily_fantasy = 7,
            eFamily_moz_variable = 8,
            eFamily_moz_fixed = 9,
        }
        /**
 * font family name, a string for the name if not a generic and
 * a font type indicated named family or which generic family
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct FontFamilyName {
            pub mType: root::mozilla::FontFamilyType,
            pub mName: ::nsstring::nsStringRepr,
        }
        #[test]
        fn bindgen_test_layout_FontFamilyName() {
            assert_eq!(::std::mem::size_of::<FontFamilyName>() , 24usize ,
                       concat ! ( "Size of: " , stringify ! ( FontFamilyName )
                       ));
            assert_eq! (::std::mem::align_of::<FontFamilyName>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( FontFamilyName ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const FontFamilyName ) ) . mType as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( FontFamilyName
                        ) , "::" , stringify ! ( mType ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const FontFamilyName ) ) . mName as *
                        const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( FontFamilyName
                        ) , "::" , stringify ! ( mName ) ));
        }
        /**
 * font family list, array of font families and a default font type.
 * font family names are either named strings or generics. the default
 * font type is used to preserve the variable font fallback behavior
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct FontFamilyList {
            pub mFontlist: root::nsTArray<root::mozilla::FontFamilyName>,
            pub mDefaultFontType: root::mozilla::FontFamilyType,
        }
        #[test]
        fn bindgen_test_layout_FontFamilyList() {
            assert_eq!(::std::mem::size_of::<FontFamilyList>() , 16usize ,
                       concat ! ( "Size of: " , stringify ! ( FontFamilyList )
                       ));
            assert_eq! (::std::mem::align_of::<FontFamilyList>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( FontFamilyList ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const FontFamilyList ) ) . mFontlist as
                        * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( FontFamilyList
                        ) , "::" , stringify ! ( mFontlist ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const FontFamilyList ) ) .
                        mDefaultFontType as * const _ as usize } , 8usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( FontFamilyList
                        ) , "::" , stringify ! ( mDefaultFontType ) ));
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBasicShapeType {
            Polygon = 0,
            Circle = 1,
            Ellipse = 2,
            Inset = 3,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxAlign {
            Stretch = 0,
            Start = 1,
            Center = 2,
            Baseline = 3,
            End = 4,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxDecorationBreak { Slice = 0, Clone = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxDirection { Normal = 0, Reverse = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxOrient { Horizontal = 0, Vertical = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxPack { Start = 0, Center = 1, End = 2, Justify = 3, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxSizing { Content = 0, Border = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleClear {
            None = 0,
            Left = 1,
            Right = 2,
            InlineStart = 3,
            InlineEnd = 4,
            Both = 5,
            Line = 8,
            Max = 13,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleGeometryBox {
            ContentBox = 0,
            PaddingBox = 1,
            BorderBox = 2,
            MarginBox = 3,
            FillBox = 4,
            StrokeBox = 5,
            ViewBox = 6,
            NoClip = 7,
            Text = 8,
            NoBox = 9,
            MozAlmostPadding = 127,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleFillRule { Nonzero = 0, Evenodd = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleFloat {
            None = 0,
            Left = 1,
            Right = 2,
            InlineStart = 3,
            InlineEnd = 4,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleFloatEdge { ContentBox = 0, MarginBox = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleHyphens { None = 0, Manual = 1, Auto = 2, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleShapeRadius { ClosestSide = 0, FarthestSide = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleShapeSourceType {
            None = 0,
            URL = 1,
            Shape = 2,
            Box = 3,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleStackSizing {
            Ignore = 0,
            StretchToFit = 1,
            IgnoreHorizontal = 2,
            IgnoreVertical = 3,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleTextJustify {
            None = 0,
            Auto = 1,
            InterWord = 2,
            InterCharacter = 3,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleUserFocus {
            None = 0,
            Ignore = 1,
            Normal = 2,
            SelectAll = 3,
            SelectBefore = 4,
            SelectAfter = 5,
            SelectSame = 6,
            SelectMenu = 7,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleUserSelect {
            None = 0,
            Text = 1,
            Element = 2,
            Elements = 3,
            All = 4,
            Toggle = 5,
            TriState = 6,
            Auto = 7,
            MozAll = 8,
            MozText = 9,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleUserInput {
            None = 0,
            Enabled = 1,
            Disabled = 2,
            Auto = 3,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleUserModify {
            ReadOnly = 0,
            ReadWrite = 1,
            WriteOnly = 2,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleWindowDragging { Default = 0, Drag = 1, NoDrag = 2, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleOrient {
            Inline = 0,
            Block = 1,
            Horizontal = 2,
            Vertical = 3,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleImageLayerRepeat {
            NoRepeat = 0,
            RepeatX = 1,
            RepeatY = 2,
            Repeat = 3,
            Space = 4,
            Round = 5,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleDisplay {
            None = 0,
            Block = 1,
            FlowRoot = 2,
            Inline = 3,
            InlineBlock = 4,
            ListItem = 5,
            Table = 6,
            InlineTable = 7,
            TableRowGroup = 8,
            TableColumn = 9,
            TableColumnGroup = 10,
            TableHeaderGroup = 11,
            TableFooterGroup = 12,
            TableRow = 13,
            TableCell = 14,
            TableCaption = 15,
            Flex = 16,
            InlineFlex = 17,
            Grid = 18,
            InlineGrid = 19,
            Ruby = 20,
            RubyBase = 21,
            RubyBaseContainer = 22,
            RubyText = 23,
            RubyTextContainer = 24,
            Contents = 25,
            WebkitBox = 26,
            WebkitInlineBox = 27,
            MozBox = 28,
            MozInlineBox = 29,
            MozGrid = 30,
            MozInlineGrid = 31,
            MozGridGroup = 32,
            MozGridLine = 33,
            MozStack = 34,
            MozInlineStack = 35,
            MozDeck = 36,
            MozGroupbox = 37,
            MozPopup = 38,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleGridTrackBreadth { MaxContent = 1, MinContent = 2, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleWhiteSpace {
            Normal = 0,
            Pre = 1,
            Nowrap = 2,
            PreWrap = 3,
            PreLine = 4,
            PreSpace = 5,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WritingMode {
            _unused: [u8; 0],
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LogicalSide {
            eLogicalSideBStart = 0,
            eLogicalSideBEnd = 1,
            eLogicalSideIStart = 2,
            eLogicalSideIEnd = 3,
        }
        /**
 * Additional data used in conjunction with an nsRestyleHint to control the
 * restyle process.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct RestyleHintData {
            pub mSelectorsForDescendants: root::nsTArray<*mut root::nsCSSSelector>,
        }
        #[test]
        fn bindgen_test_layout_RestyleHintData() {
            assert_eq!(::std::mem::size_of::<RestyleHintData>() , 8usize ,
                       concat ! (
                       "Size of: " , stringify ! ( RestyleHintData ) ));
            assert_eq! (::std::mem::align_of::<RestyleHintData>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( RestyleHintData ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const RestyleHintData ) ) .
                        mSelectorsForDescendants as * const _ as usize } ,
                        0usize , concat ! (
                        "Alignment of field: " , stringify ! ( RestyleHintData
                        ) , "::" , stringify ! ( mSelectorsForDescendants )
                        ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NotNull<T> {
            pub mBasePtr: T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WeakPtr {
        }
        pub type WeakPtr_WeakReference = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SupportsWeakPtr {
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WidgetEvent {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WidgetGUIEvent {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WidgetInputEvent {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WidgetPointerEvent {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EventFlags {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ShortcutKeyCandidate {
            _unused: [u8; 0],
        }
        pub const FlushType_Frames: root::mozilla::FlushType =
            FlushType::Style;
        #[repr(u8)]
        /**
 * This is the enum used by nsIDocument::FlushPendingNotifications to
 * decide what to flush.
 *
 * Please note that if you change these values, you should sync it with the
 * flushTypeNames array inside PresShell::FlushPendingNotifications.
 */
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum FlushType {
            None = 0,
            Content = 1,
            ContentAndNotify = 2,
            Style = 3,
            InterruptibleLayout = 4,
            Layout = 5,
            Display = 6,
            Count = 7,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ChangesToFlush {
            pub mFlushType: root::mozilla::FlushType,
            pub mFlushAnimations: bool,
        }
        #[test]
        fn bindgen_test_layout_ChangesToFlush() {
            assert_eq!(::std::mem::size_of::<ChangesToFlush>() , 2usize ,
                       concat ! ( "Size of: " , stringify ! ( ChangesToFlush )
                       ));
            assert_eq! (::std::mem::align_of::<ChangesToFlush>() , 1usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ChangesToFlush ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ChangesToFlush ) ) . mFlushType
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( ChangesToFlush
                        ) , "::" , stringify ! ( mFlushType ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ChangesToFlush ) ) .
                        mFlushAnimations as * const _ as usize } , 1usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ChangesToFlush
                        ) , "::" , stringify ! ( mFlushAnimations ) ));
        }
        impl Clone for ChangesToFlush {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct CSSPixel {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_CSSPixel() {
            assert_eq!(::std::mem::size_of::<CSSPixel>() , 1usize , concat ! (
                       "Size of: " , stringify ! ( CSSPixel ) ));
            assert_eq! (::std::mem::align_of::<CSSPixel>() , 1usize , concat !
                        ( "Alignment of " , stringify ! ( CSSPixel ) ));
        }
        impl Clone for CSSPixel {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct LayoutDevicePixel {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_LayoutDevicePixel() {
            assert_eq!(::std::mem::size_of::<LayoutDevicePixel>() , 1usize ,
                       concat ! (
                       "Size of: " , stringify ! ( LayoutDevicePixel ) ));
            assert_eq! (::std::mem::align_of::<LayoutDevicePixel>() , 1usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( LayoutDevicePixel )
                        ));
        }
        impl Clone for LayoutDevicePixel {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct LayerPixel {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_LayerPixel() {
            assert_eq!(::std::mem::size_of::<LayerPixel>() , 1usize , concat !
                       ( "Size of: " , stringify ! ( LayerPixel ) ));
            assert_eq! (::std::mem::align_of::<LayerPixel>() , 1usize , concat
                        ! ( "Alignment of " , stringify ! ( LayerPixel ) ));
        }
        impl Clone for LayerPixel {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ScreenPixel {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_ScreenPixel() {
            assert_eq!(::std::mem::size_of::<ScreenPixel>() , 1usize , concat
                       ! ( "Size of: " , stringify ! ( ScreenPixel ) ));
            assert_eq! (::std::mem::align_of::<ScreenPixel>() , 1usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ScreenPixel ) ));
        }
        impl Clone for ScreenPixel {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ParentLayerPixel {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_ParentLayerPixel() {
            assert_eq!(::std::mem::size_of::<ParentLayerPixel>() , 1usize ,
                       concat ! (
                       "Size of: " , stringify ! ( ParentLayerPixel ) ));
            assert_eq! (::std::mem::align_of::<ParentLayerPixel>() , 1usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ParentLayerPixel ) ));
        }
        impl Clone for ParentLayerPixel {
            fn clone(&self) -> Self { *self }
        }
        pub type CSSPoint = [u32; 2usize];
        pub type CSSIntPoint = [u32; 2usize];
        pub type CSSSize = [u32; 2usize];
        pub type CSSRect = [u32; 4usize];
        pub type LayoutDeviceIntPoint = [u32; 2usize];
        pub type LayoutDeviceIntSize = [u32; 2usize];
        pub type LayoutDeviceIntRect = [u32; 4usize];
        pub type ScreenIntSize = u8;
        pub type ScreenMargin = [u32; 4usize];
        pub type ParentLayerRect = [u32; 4usize];
        pub type ParentLayerIntRect = [u32; 4usize];
        pub type CSSToLayoutDeviceScale = u32;
        pub type CSSToParentLayerScale2D = [u32; 2usize];
        pub type LayoutDeviceToLayerScale2D = [u32; 2usize];
        pub type ScreenToLayerScale2D = [u32; 2usize];
        pub type TimeStampValue = u64;
        /**
 * Instances of this class represent moments in time, or a special
 * "null" moment. We do not use the non-monotonic system clock or
 * local time, since they can be reset, causing apparent backward
 * travel in time, which can confuse algorithms. Instead we measure
 * elapsed time according to the system.  This time can never go
 * backwards (i.e. it never wraps around, at least not in less than
 * five million years of system elapsed time). It might not advance
 * while the system is sleeping. If TimeStamp::SetNow() is not called
 * at all for hours or days, we might not notice the passage of some
 * of that time.
 *
 * We deliberately do not expose a way to convert TimeStamps to some
 * particular unit. All you can do is compute a difference between two
 * TimeStamps to get a TimeDuration. You can also add a TimeDuration
 * to a TimeStamp to get a new TimeStamp. You can't do something
 * meaningless like add two TimeStamps.
 *
 * Internally this is implemented as either a wrapper around
 *   - high-resolution, monotonic, system clocks if they exist on this
 *     platform
 *   - PRIntervalTime otherwise.  We detect wraparounds of
 *     PRIntervalTime and work around them.
 *
 * This class is similar to C++11's time_point, however it is
 * explicitly nullable and provides an IsNull() method. time_point
 * is initialized to the clock's epoch and provides a
 * time_since_epoch() method that functions similiarly. i.e.
 * t.IsNull() is equivalent to t.time_since_epoch() == decltype(t)::duration::zero();
 */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct TimeStamp {
            /**
   * When built with PRIntervalTime, a value of 0 means this instance
   * is "null". Otherwise, the low 32 bits represent a PRIntervalTime,
   * and the high 32 bits represent a counter of the number of
   * rollovers of PRIntervalTime that we've seen. This counter starts
   * at 1 to avoid a real time colliding with the "null" value.
   *
   * PR_INTERVAL_MAX is set at 100,000 ticks per second. So the minimum
   * time to wrap around is about 2^64/100000 seconds, i.e. about
   * 5,849,424 years.
   *
   * When using a system clock, a value is system dependent.
   */
            pub mValue: root::mozilla::TimeStampValue,
        }
        #[test]
        fn bindgen_test_layout_TimeStamp() {
            assert_eq!(::std::mem::size_of::<TimeStamp>() , 8usize , concat !
                       ( "Size of: " , stringify ! ( TimeStamp ) ));
            assert_eq! (::std::mem::align_of::<TimeStamp>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( TimeStamp ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const TimeStamp ) ) . mValue as * const
                        _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( TimeStamp ) ,
                        "::" , stringify ! ( mValue ) ));
        }
        impl Clone for TimeStamp {
            fn clone(&self) -> Self { *self }
        }
        /**
 * Instances of this class represent the length of an interval of time.
 * Negative durations are allowed, meaning the end is before the start.
 *
 * Internally the duration is stored as a int64_t in units of
 * PR_TicksPerSecond() when building with NSPR interval timers, or a
 * system-dependent unit when building with system clocks.  The
 * system-dependent unit must be constant, otherwise the semantics of
 * this class would be broken.
 *
 * The ValueCalculator template parameter determines how arithmetic
 * operations are performed on the integer count of ticks (mValue).
 */
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BaseTimeDuration {
            pub mValue: i64,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BaseTimeDuration__SomethingVeryRandomHere {
            pub _address: u8,
        }
        /**
 * Perform arithmetic operations on the value of a BaseTimeDuration without
 * doing strict checks on the range of values.
 */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct TimeDurationValueCalculator {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_TimeDurationValueCalculator() {
            assert_eq!(::std::mem::size_of::<TimeDurationValueCalculator>() ,
                       1usize , concat ! (
                       "Size of: " , stringify ! ( TimeDurationValueCalculator
                       ) ));
            assert_eq! (::std::mem::align_of::<TimeDurationValueCalculator>()
                        , 1usize , concat ! (
                        "Alignment of " , stringify ! (
                        TimeDurationValueCalculator ) ));
        }
        impl Clone for TimeDurationValueCalculator {
            fn clone(&self) -> Self { *self }
        }
        /**
 * Specialization of BaseTimeDuration that uses TimeDurationValueCalculator for
 * arithmetic on the mValue member.
 *
 * Use this class for time durations that are *not* expected to hold values of
 * Forever (or the negative equivalent) or when such time duration are *not*
 * expected to be used in arithmetic operations.
 */
        pub type TimeDuration = root::mozilla::BaseTimeDuration;
        /**
 * EventStates is the class used to represent the event states of nsIContent
 * instances. These states are calculated by IntrinsicState() and
 * ContentStatesChanged() has to be called when one of them changes thus
 * informing the layout/style engine of the change.
 * Event states are associated with pseudo-classes.
 */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct EventStates {
            pub mStates: root::mozilla::EventStates_InternalType,
        }
        pub type EventStates_InternalType = u64;
        pub type EventStates_ServoType = u64;
        #[test]
        fn bindgen_test_layout_EventStates() {
            assert_eq!(::std::mem::size_of::<EventStates>() , 8usize , concat
                       ! ( "Size of: " , stringify ! ( EventStates ) ));
            assert_eq! (::std::mem::align_of::<EventStates>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( EventStates ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const EventStates ) ) . mStates as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( EventStates ) ,
                        "::" , stringify ! ( mStates ) ));
        }
        impl Clone for EventStates {
            fn clone(&self) -> Self { *self }
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum TraversalRootBehavior {
            Normal = 0,
            UnstyledChildrenOnly = 1,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum TraversalRestyleBehavior {
            Normal = 0,
            ForNewlyBoundElement = 1,
            ForReconstruct = 2,
            ForAnimationOnly = 3,
            ForCSSRuleChanges = 4,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleRuleInclusion { All = 0, DefaultOnly = 1, }
        pub const UpdateAnimationsTasks_CSSAnimations:
                  root::mozilla::UpdateAnimationsTasks =
            1;
        pub const UpdateAnimationsTasks_CSSTransitions:
                  root::mozilla::UpdateAnimationsTasks =
            2;
        pub const UpdateAnimationsTasks_EffectProperties:
                  root::mozilla::UpdateAnimationsTasks =
            4;
        pub const UpdateAnimationsTasks_CascadeResults:
                  root::mozilla::UpdateAnimationsTasks =
            8;
        pub type UpdateAnimationsTasks = u8;
        pub const ParsingMode_Default: root::mozilla::ParsingMode = 0;
        pub const ParsingMode_AllowUnitlessLength: root::mozilla::ParsingMode
                  =
            1;
        pub const ParsingMode_AllowAllNumericValues:
                  root::mozilla::ParsingMode =
            2;
        pub type ParsingMode = u8;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum InheritTarget {
            Text = 0,
            FirstLetterContinuation = 1,
            PlaceholderFrame = 2,
        }
        #[repr(u8)]
        /**
 * Enumeration that represents one of the two supported style system backends.
 */
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBackendType { None = 0, Gecko = 1, Servo = 2, }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct MallocAllocPolicy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_MallocAllocPolicy() {
            assert_eq!(::std::mem::size_of::<MallocAllocPolicy>() , 1usize ,
                       concat ! (
                       "Size of: " , stringify ! ( MallocAllocPolicy ) ));
            assert_eq! (::std::mem::align_of::<MallocAllocPolicy>() , 1usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( MallocAllocPolicy )
                        ));
        }
        impl Clone for MallocAllocPolicy {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ErrorResult {
            pub _bindgen_opaque_blob: [u64; 2usize],
        }
        pub type ErrorResult_BaseErrorResult =
            root::mozilla::binding_danger::TErrorResult;
        #[test]
        fn bindgen_test_layout_ErrorResult() {
            assert_eq!(::std::mem::size_of::<ErrorResult>() , 16usize , concat
                       ! ( "Size of: " , stringify ! ( ErrorResult ) ));
            assert_eq! (::std::mem::align_of::<ErrorResult>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ErrorResult ) ));
        }
        impl Clone for ErrorResult {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct OOMReporter {
            pub _base: root::mozilla::dom::binding_detail::FastErrorResult,
        }
        #[test]
        fn bindgen_test_layout_OOMReporter() {
            assert_eq!(::std::mem::size_of::<OOMReporter>() , 16usize , concat
                       ! ( "Size of: " , stringify ! ( OOMReporter ) ));
            assert_eq! (::std::mem::align_of::<OOMReporter>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( OOMReporter ) ));
        }
        pub mod binding_danger {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            /**
 * Templated implementation class for various ErrorResult-like things.  The
 * instantiations differ only in terms of their cleanup policies (used in the
 * destructor), which they can specify via the template argument.  Note that
 * this means it's safe to reinterpret_cast between the instantiations unless
 * you plan to invoke the destructor through such a cast pointer.
 *
 * A cleanup policy consists of two booleans: whether to assert that we've been
 * reported or suppressed, and whether to then go ahead and suppress the
 * exception.
 */
            #[repr(C)]
            #[derive(Debug)]
            pub struct TErrorResult {
                pub mResult: root::nsresult,
                pub __bindgen_anon_1: root::mozilla::binding_danger::TErrorResult__bindgen_ty_1,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TErrorResult_Message {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TErrorResult_DOMExceptionInfo {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TErrorResult__bindgen_ty_1 {
                pub mMessage: root::__BindgenUnionField<*mut root::mozilla::binding_danger::TErrorResult_Message>,
                pub mJSException: root::__BindgenUnionField<root::JS::Value>,
                pub mDOMExceptionInfo: root::__BindgenUnionField<*mut root::mozilla::binding_danger::TErrorResult_DOMExceptionInfo>,
                pub bindgen_union_field: u64,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct JustAssertCleanupPolicy {
                pub _address: u8,
            }
            pub const JustAssertCleanupPolicy_assertHandled: bool = true;
            pub const JustAssertCleanupPolicy_suppress: bool = false;
            #[test]
            fn bindgen_test_layout_JustAssertCleanupPolicy() {
                assert_eq!(::std::mem::size_of::<JustAssertCleanupPolicy>() ,
                           1usize , concat ! (
                           "Size of: " , stringify ! ( JustAssertCleanupPolicy
                           ) ));
                assert_eq! (::std::mem::align_of::<JustAssertCleanupPolicy>()
                            , 1usize , concat ! (
                            "Alignment of " , stringify ! (
                            JustAssertCleanupPolicy ) ));
            }
            impl Clone for JustAssertCleanupPolicy {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct AssertAndSuppressCleanupPolicy {
                pub _address: u8,
            }
            pub const AssertAndSuppressCleanupPolicy_assertHandled: bool =
                true;
            pub const AssertAndSuppressCleanupPolicy_suppress: bool = true;
            #[test]
            fn bindgen_test_layout_AssertAndSuppressCleanupPolicy() {
                assert_eq!(::std::mem::size_of::<AssertAndSuppressCleanupPolicy>()
                           , 1usize , concat ! (
                           "Size of: " , stringify ! (
                           AssertAndSuppressCleanupPolicy ) ));
                assert_eq! (::std::mem::align_of::<AssertAndSuppressCleanupPolicy>()
                            , 1usize , concat ! (
                            "Alignment of " , stringify ! (
                            AssertAndSuppressCleanupPolicy ) ));
            }
            impl Clone for AssertAndSuppressCleanupPolicy {
                fn clone(&self) -> Self { *self }
            }
        }
        /**
 * Superclass for data common to CSSStyleSheet and ServoStyleSheet.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct StyleSheet {
            pub _base: root::nsIDOMCSSStyleSheet,
            pub _base_1: root::nsICSSLoaderObserver,
            pub _base_2: root::nsWrapperCache,
            pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
            pub mParent: *mut root::mozilla::StyleSheet,
            pub mTitle: ::nsstring::nsStringRepr,
            pub mDocument: *mut root::nsIDocument,
            pub mOwningNode: *mut root::nsINode,
            pub mOwnerRule: *mut root::mozilla::dom::CSSImportRule,
            pub mMedia: root::RefPtr<root::mozilla::dom::MediaList>,
            pub mNext: root::RefPtr<root::mozilla::StyleSheet>,
            pub mParsingMode: root::mozilla::css::SheetParsingMode,
            pub mType: root::mozilla::StyleBackendType,
            pub mDisabled: bool,
            pub mDocumentAssociationMode: root::mozilla::StyleSheet_DocumentAssociationMode,
            pub mInner: *mut root::mozilla::StyleSheetInfo,
            pub mDirty: bool,
            pub mStyleSets: root::nsTArray<root::mozilla::StyleSetHandle>,
        }
        pub type StyleSheet_HasThreadSafeRefCnt = root::mozilla::FalseType;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleSheet_cycleCollection {
            pub _base: root::nsXPCOMCycleCollectionParticipant,
        }
        #[test]
        fn bindgen_test_layout_StyleSheet_cycleCollection() {
            assert_eq!(::std::mem::size_of::<StyleSheet_cycleCollection>() ,
                       16usize , concat ! (
                       "Size of: " , stringify ! ( StyleSheet_cycleCollection
                       ) ));
            assert_eq! (::std::mem::align_of::<StyleSheet_cycleCollection>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! (
                        StyleSheet_cycleCollection ) ));
        }
        impl Clone for StyleSheet_cycleCollection {
            fn clone(&self) -> Self { *self }
        }
        #[repr(i32)]
        /**
   * The different changes that a stylesheet may go through.
   *
   * Used by the StyleSets in order to handle more efficiently some kinds of
   * changes.
   */
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleSheet_ChangeType {
            Added = 0,
            Removed = 1,
            ApplicableStateChanged = 2,
            RuleAdded = 3,
            RuleRemoved = 4,
            RuleChanged = 5,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleSheet_DocumentAssociationMode {
            OwnedByDocument = 0,
            NotOwnedByDocument = 1,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleSheet_ChildSheetListBuilder {
            pub sheetSlot: *mut root::RefPtr<root::mozilla::StyleSheet>,
            pub parent: *mut root::mozilla::StyleSheet,
        }
        #[test]
        fn bindgen_test_layout_StyleSheet_ChildSheetListBuilder() {
            assert_eq!(::std::mem::size_of::<StyleSheet_ChildSheetListBuilder>()
                       , 16usize , concat ! (
                       "Size of: " , stringify ! (
                       StyleSheet_ChildSheetListBuilder ) ));
            assert_eq! (::std::mem::align_of::<StyleSheet_ChildSheetListBuilder>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        StyleSheet_ChildSheetListBuilder ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleSheet_ChildSheetListBuilder ) )
                        . sheetSlot as * const _ as usize } , 0usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        StyleSheet_ChildSheetListBuilder ) , "::" , stringify
                        ! ( sheetSlot ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleSheet_ChildSheetListBuilder ) )
                        . parent as * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleSheet_ChildSheetListBuilder ) , "::" , stringify
                        ! ( parent ) ));
        }
        impl Clone for StyleSheet_ChildSheetListBuilder {
            fn clone(&self) -> Self { *self }
        }
        extern "C" {
            #[link_name = "_ZN7mozilla10StyleSheet21_cycleCollectorGlobalE"]
            pub static mut StyleSheet__cycleCollectorGlobal:
                       root::mozilla::StyleSheet_cycleCollection;
        }
        #[test]
        fn bindgen_test_layout_StyleSheet() {
            assert_eq!(::std::mem::size_of::<StyleSheet>() , 152usize , concat
                       ! ( "Size of: " , stringify ! ( StyleSheet ) ));
            assert_eq! (::std::mem::align_of::<StyleSheet>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( StyleSheet ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct OriginAttributes {
            pub _base: root::mozilla::dom::OriginAttributesDictionary,
        }
        pub const OriginAttributes_STRIP_FIRST_PARTY_DOMAIN:
                  root::mozilla::OriginAttributes__bindgen_ty_1 =
            OriginAttributes__bindgen_ty_1::STRIP_FIRST_PARTY_DOMAIN;
        pub const OriginAttributes_STRIP_USER_CONTEXT_ID:
                  root::mozilla::OriginAttributes__bindgen_ty_1 =
            OriginAttributes__bindgen_ty_1::STRIP_USER_CONTEXT_ID;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum OriginAttributes__bindgen_ty_1 {
            STRIP_FIRST_PARTY_DOMAIN = 1,
            STRIP_USER_CONTEXT_ID = 2,
        }
        extern "C" {
            #[link_name =
                  "_ZN7mozilla16OriginAttributes20sFirstPartyIsolationE"]
            pub static mut OriginAttributes_sFirstPartyIsolation: bool;
        }
        extern "C" {
            #[link_name =
                  "_ZN7mozilla16OriginAttributes23sRestrictedOpenerAccessE"]
            pub static mut OriginAttributes_sRestrictedOpenerAccess: bool;
        }
        #[test]
        fn bindgen_test_layout_OriginAttributes() {
            assert_eq!(::std::mem::size_of::<OriginAttributes>() , 40usize ,
                       concat ! (
                       "Size of: " , stringify ! ( OriginAttributes ) ));
            assert_eq! (::std::mem::align_of::<OriginAttributes>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( OriginAttributes ) ));
        }
        pub mod net {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum ReferrerPolicy {
                RP_No_Referrer = 2,
                RP_Origin = 3,
                RP_No_Referrer_When_Downgrade = 1,
                RP_Origin_When_Crossorigin = 4,
                RP_Unsafe_URL = 5,
                RP_Same_Origin = 6,
                RP_Strict_Origin = 7,
                RP_Strict_Origin_When_Cross_Origin = 8,
                RP_Unset = 0,
            }
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum CORSMode {
            CORS_NONE = 0,
            CORS_ANONYMOUS = 1,
            CORS_USE_CREDENTIALS = 2,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ServoStyleSheet {
            pub _base: root::mozilla::StyleSheet,
            pub mRuleList: root::RefPtr<root::mozilla::ServoCSSRuleList>,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ServoStyleSheet_cycleCollection {
            pub _base: root::mozilla::StyleSheet_cycleCollection,
        }
        #[test]
        fn bindgen_test_layout_ServoStyleSheet_cycleCollection() {
            assert_eq!(::std::mem::size_of::<ServoStyleSheet_cycleCollection>()
                       , 16usize , concat ! (
                       "Size of: " , stringify ! (
                       ServoStyleSheet_cycleCollection ) ));
            assert_eq! (::std::mem::align_of::<ServoStyleSheet_cycleCollection>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        ServoStyleSheet_cycleCollection ) ));
        }
        impl Clone for ServoStyleSheet_cycleCollection {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ServoStyleSheet_COMTypeInfo {
            pub _address: u8,
        }
        extern "C" {
            #[link_name =
                  "_ZN7mozilla15ServoStyleSheet21_cycleCollectorGlobalE"]
            pub static mut ServoStyleSheet__cycleCollectorGlobal:
                       root::mozilla::ServoStyleSheet_cycleCollection;
        }
        #[test]
        fn bindgen_test_layout_ServoStyleSheet() {
            assert_eq!(::std::mem::size_of::<ServoStyleSheet>() , 160usize ,
                       concat ! (
                       "Size of: " , stringify ! ( ServoStyleSheet ) ));
            assert_eq! (::std::mem::align_of::<ServoStyleSheet>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ServoStyleSheet ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoStyleSheet ) ) . mRuleList
                        as * const _ as usize } , 152usize , concat ! (
                        "Alignment of field: " , stringify ! ( ServoStyleSheet
                        ) , "::" , stringify ! ( mRuleList ) ));
        }
        /**
 * Smart pointer class that can hold a pointer to either an nsStyleSet
 * or a ServoStyleSet.
 */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleSetHandle {
            pub mPtr: root::mozilla::StyleSetHandle_Ptr,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleSetHandle_Ptr {
            pub mValue: usize,
        }
        #[test]
        fn bindgen_test_layout_StyleSetHandle_Ptr() {
            assert_eq!(::std::mem::size_of::<StyleSetHandle_Ptr>() , 8usize ,
                       concat ! (
                       "Size of: " , stringify ! ( StyleSetHandle_Ptr ) ));
            assert_eq! (::std::mem::align_of::<StyleSetHandle_Ptr>() , 8usize
                        , concat ! (
                        "Alignment of " , stringify ! ( StyleSetHandle_Ptr )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSetHandle_Ptr ) ) . mValue
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleSetHandle_Ptr ) , "::" , stringify ! ( mValue )
                        ));
        }
        impl Clone for StyleSetHandle_Ptr {
            fn clone(&self) -> Self { *self }
        }
        #[test]
        fn bindgen_test_layout_StyleSetHandle() {
            assert_eq!(::std::mem::size_of::<StyleSetHandle>() , 8usize ,
                       concat ! ( "Size of: " , stringify ! ( StyleSetHandle )
                       ));
            assert_eq! (::std::mem::align_of::<StyleSetHandle>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StyleSetHandle ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSetHandle ) ) . mPtr as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleSetHandle
                        ) , "::" , stringify ! ( mPtr ) ));
        }
        impl Clone for StyleSetHandle {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        pub struct StyleSheetInfo__bindgen_vtable(::std::os::raw::c_void);
        /**
 * Struct for data common to CSSStyleSheetInner and ServoStyleSheet.
 */
        #[repr(C)]
        pub struct StyleSheetInfo {
            pub vtable_: *const StyleSheetInfo__bindgen_vtable,
            pub mSheetURI: root::nsCOMPtr,
            pub mOriginalSheetURI: root::nsCOMPtr,
            pub mBaseURI: root::nsCOMPtr,
            pub mPrincipal: root::nsCOMPtr,
            pub mCORSMode: root::mozilla::CORSMode,
            pub mReferrerPolicy: root::mozilla::StyleSheetInfo_ReferrerPolicy,
            pub mIntegrity: root::mozilla::dom::SRIMetadata,
            pub mComplete: bool,
            pub mFirstChild: root::RefPtr<root::mozilla::StyleSheet>,
            pub mSheets: [u64; 10usize],
        }
        pub use self::super::super::root::mozilla::net::ReferrerPolicy as
                StyleSheetInfo_ReferrerPolicy;
        #[test]
        fn bindgen_test_layout_StyleSheetInfo() {
            assert_eq!(::std::mem::size_of::<StyleSheetInfo>() , 192usize ,
                       concat ! ( "Size of: " , stringify ! ( StyleSheetInfo )
                       ));
            assert_eq! (::std::mem::align_of::<StyleSheetInfo>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StyleSheetInfo ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSheetInfo ) ) . mSheetURI as
                        * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleSheetInfo
                        ) , "::" , stringify ! ( mSheetURI ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSheetInfo ) ) .
                        mOriginalSheetURI as * const _ as usize } , 16usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StyleSheetInfo
                        ) , "::" , stringify ! ( mOriginalSheetURI ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSheetInfo ) ) . mBaseURI as
                        * const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleSheetInfo
                        ) , "::" , stringify ! ( mBaseURI ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSheetInfo ) ) . mPrincipal
                        as * const _ as usize } , 32usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleSheetInfo
                        ) , "::" , stringify ! ( mPrincipal ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSheetInfo ) ) . mCORSMode as
                        * const _ as usize } , 40usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleSheetInfo
                        ) , "::" , stringify ! ( mCORSMode ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSheetInfo ) ) .
                        mReferrerPolicy as * const _ as usize } , 44usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StyleSheetInfo
                        ) , "::" , stringify ! ( mReferrerPolicy ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSheetInfo ) ) . mIntegrity
                        as * const _ as usize } , 48usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleSheetInfo
                        ) , "::" , stringify ! ( mIntegrity ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSheetInfo ) ) . mComplete as
                        * const _ as usize } , 96usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleSheetInfo
                        ) , "::" , stringify ! ( mComplete ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSheetInfo ) ) . mFirstChild
                        as * const _ as usize } , 104usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleSheetInfo
                        ) , "::" , stringify ! ( mFirstChild ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSheetInfo ) ) . mSheets as *
                        const _ as usize } , 112usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleSheetInfo
                        ) , "::" , stringify ! ( mSheets ) ));
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum CSSEnabledState {
            eForAllContent = 0,
            eInUASheets = 1,
            eInChrome = 2,
            eIgnoreEnabledState = 255,
        }
        pub type CSSPseudoElementTypeBase = u8;
        pub const CSSPseudoElementType_InheritingAnonBox:
                  root::mozilla::CSSPseudoElementType =
            CSSPseudoElementType::Count;
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum CSSPseudoElementType {
            after = 0,
            before = 1,
            backdrop = 2,
            cue = 3,
            firstLetter = 4,
            firstLine = 5,
            mozSelection = 6,
            mozFocusInner = 7,
            mozFocusOuter = 8,
            mozListBullet = 9,
            mozListNumber = 10,
            mozMathAnonymous = 11,
            mozNumberWrapper = 12,
            mozNumberText = 13,
            mozNumberSpinBox = 14,
            mozNumberSpinUp = 15,
            mozNumberSpinDown = 16,
            mozProgressBar = 17,
            mozRangeTrack = 18,
            mozRangeProgress = 19,
            mozRangeThumb = 20,
            mozMeterBar = 21,
            mozPlaceholder = 22,
            placeholder = 23,
            mozColorSwatch = 24,
            Count = 25,
            NonInheritingAnonBox = 26,
            XULTree = 27,
            NotPseudo = 28,
            MAX = 29,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ServoStyleSet {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EventChainVisitor {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EventChainPostVisitor {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EventChainPreVisitor {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EventListenerManager {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TextEditor {
            _unused: [u8; 0],
        }
        #[test]
        fn __bindgen_test_layout_StaticRefPtr_instantiation_2() {
            assert_eq!(::std::mem::size_of::<root::mozilla::StaticRefPtr<root::mozilla::URLExtraData>>()
                       , 8usize , concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::mozilla::StaticRefPtr<root::mozilla::URLExtraData>
                       ) ));
            assert_eq!(::std::mem::align_of::<root::mozilla::StaticRefPtr<root::mozilla::URLExtraData>>()
                       , 8usize , concat ! (
                       "Alignment of template specialization: " , stringify !
                       (
                       root::mozilla::StaticRefPtr<root::mozilla::URLExtraData>
                       ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct URLExtraData {
            pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
            pub mBaseURI: root::nsCOMPtr,
            pub mReferrer: root::nsCOMPtr,
            pub mPrincipal: root::nsCOMPtr,
        }
        pub type URLExtraData_HasThreadSafeRefCnt = root::mozilla::TrueType;
        extern "C" {
            #[link_name = "_ZN7mozilla12URLExtraData6sDummyE"]
            pub static mut URLExtraData_sDummy:
                       root::mozilla::StaticRefPtr<root::mozilla::URLExtraData>;
        }
        #[test]
        fn bindgen_test_layout_URLExtraData() {
            assert_eq!(::std::mem::size_of::<URLExtraData>() , 32usize ,
                       concat ! ( "Size of: " , stringify ! ( URLExtraData )
                       ));
            assert_eq! (::std::mem::align_of::<URLExtraData>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( URLExtraData ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const URLExtraData ) ) . mRefCnt as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( URLExtraData )
                        , "::" , stringify ! ( mRefCnt ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const URLExtraData ) ) . mBaseURI as *
                        const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( URLExtraData )
                        , "::" , stringify ! ( mBaseURI ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const URLExtraData ) ) . mReferrer as *
                        const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! ( URLExtraData )
                        , "::" , stringify ! ( mReferrer ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const URLExtraData ) ) . mPrincipal as
                        * const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! ( URLExtraData )
                        , "::" , stringify ! ( mPrincipal ) ));
        }
        pub mod widget {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IMEState {
                _unused: [u8; 0],
            }
        }
        pub type RawSelectionType = ::std::os::raw::c_short;
        #[repr(i16)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum SelectionType {
            eInvalid = -1,
            eNone = 0,
            eNormal = 1,
            eSpellCheck = 2,
            eIMERawClause = 4,
            eIMESelectedRawClause = 8,
            eIMEConvertedClause = 16,
            eIMESelectedClause = 32,
            eAccessibility = 64,
            eFind = 128,
            eURLSecondary = 256,
            eURLStrikeout = 512,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AccessibleCaretEventHub {
            _unused: [u8; 0],
        }
        pub mod a11y {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DocAccessible {
                _unused: [u8; 0],
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Encoding {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Runnable {
            pub _base: root::nsIRunnable,
            pub _base_1: root::nsINamed,
            pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
            pub mName: *const ::std::os::raw::c_char,
        }
        pub type Runnable_HasThreadSafeRefCnt = root::mozilla::TrueType;
        #[test]
        fn bindgen_test_layout_Runnable() {
            assert_eq!(::std::mem::size_of::<Runnable>() , 32usize , concat !
                       ( "Size of: " , stringify ! ( Runnable ) ));
            assert_eq! (::std::mem::align_of::<Runnable>() , 8usize , concat !
                        ( "Alignment of " , stringify ! ( Runnable ) ));
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum TaskCategory {
            UI = 0,
            Network = 1,
            Timer = 2,
            Worker = 3,
            IdleCallback = 4,
            RefreshDriver = 5,
            GarbageCollection = 6,
            Other = 7,
            Count = 8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AbstractThread {
            _unused: [u8; 0],
        }
        #[repr(i16)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum UseCounter {
            eUseCounter_UNKNOWN = -1,
            eUseCounter_SVGSVGElement_getElementById = 0,
            eUseCounter_SVGSVGElement_currentScale_getter = 1,
            eUseCounter_SVGSVGElement_currentScale_setter = 2,
            eUseCounter_property_Fill = 3,
            eUseCounter_property_FillOpacity = 4,
            eUseCounter_PushManager_subscribe = 5,
            eUseCounter_PushSubscription_unsubscribe = 6,
            eUseCounter_Window_sidebar_getter = 7,
            eUseCounter_Window_sidebar_setter = 8,
            eUseCounter_External_addSearchEngine = 9,
            eUseCounter_OfflineResourceList_swapCache = 10,
            eUseCounter_OfflineResourceList_update = 11,
            eUseCounter_OfflineResourceList_status_getter = 12,
            eUseCounter_OfflineResourceList_status_setter = 13,
            eUseCounter_OfflineResourceList_onchecking_getter = 14,
            eUseCounter_OfflineResourceList_onchecking_setter = 15,
            eUseCounter_OfflineResourceList_onerror_getter = 16,
            eUseCounter_OfflineResourceList_onerror_setter = 17,
            eUseCounter_OfflineResourceList_onnoupdate_getter = 18,
            eUseCounter_OfflineResourceList_onnoupdate_setter = 19,
            eUseCounter_OfflineResourceList_ondownloading_getter = 20,
            eUseCounter_OfflineResourceList_ondownloading_setter = 21,
            eUseCounter_OfflineResourceList_onprogress_getter = 22,
            eUseCounter_OfflineResourceList_onprogress_setter = 23,
            eUseCounter_OfflineResourceList_onupdateready_getter = 24,
            eUseCounter_OfflineResourceList_onupdateready_setter = 25,
            eUseCounter_OfflineResourceList_oncached_getter = 26,
            eUseCounter_OfflineResourceList_oncached_setter = 27,
            eUseCounter_OfflineResourceList_onobsolete_getter = 28,
            eUseCounter_OfflineResourceList_onobsolete_setter = 29,
            eUseCounter_IDBDatabase_createMutableFile = 30,
            eUseCounter_IDBDatabase_mozCreateFileHandle = 31,
            eUseCounter_IDBMutableFile_open = 32,
            eUseCounter_IDBMutableFile_getFile = 33,
            eUseCounter_DataTransfer_addElement = 34,
            eUseCounter_DataTransfer_mozItemCount_getter = 35,
            eUseCounter_DataTransfer_mozItemCount_setter = 36,
            eUseCounter_DataTransfer_mozCursor_getter = 37,
            eUseCounter_DataTransfer_mozCursor_setter = 38,
            eUseCounter_DataTransfer_mozTypesAt = 39,
            eUseCounter_DataTransfer_mozClearDataAt = 40,
            eUseCounter_DataTransfer_mozSetDataAt = 41,
            eUseCounter_DataTransfer_mozGetDataAt = 42,
            eUseCounter_DataTransfer_mozUserCancelled_getter = 43,
            eUseCounter_DataTransfer_mozUserCancelled_setter = 44,
            eUseCounter_DataTransfer_mozSourceNode_getter = 45,
            eUseCounter_DataTransfer_mozSourceNode_setter = 46,
            eUseCounter_GetAttributeNode = 47,
            eUseCounter_SetAttributeNode = 48,
            eUseCounter_GetAttributeNodeNS = 49,
            eUseCounter_SetAttributeNodeNS = 50,
            eUseCounter_RemoveAttributeNode = 51,
            eUseCounter_CreateAttribute = 52,
            eUseCounter_CreateAttributeNS = 53,
            eUseCounter_NodeValue = 54,
            eUseCounter_TextContent = 55,
            eUseCounter_EnablePrivilege = 56,
            eUseCounter_DOMExceptionCode = 57,
            eUseCounter_NoExposedProps = 58,
            eUseCounter_MutationEvent = 59,
            eUseCounter_Components = 60,
            eUseCounter_PrefixedVisibilityAPI = 61,
            eUseCounter_NodeIteratorDetach = 62,
            eUseCounter_LenientThis = 63,
            eUseCounter_GetPreventDefault = 64,
            eUseCounter_GetSetUserData = 65,
            eUseCounter_MozGetAsFile = 66,
            eUseCounter_UseOfCaptureEvents = 67,
            eUseCounter_UseOfReleaseEvents = 68,
            eUseCounter_UseOfDOM3LoadMethod = 69,
            eUseCounter_ChromeUseOfDOM3LoadMethod = 70,
            eUseCounter_ShowModalDialog = 71,
            eUseCounter_Window_Content = 72,
            eUseCounter_SyncXMLHttpRequest = 73,
            eUseCounter_Window_Controllers = 74,
            eUseCounter_ImportXULIntoContent = 75,
            eUseCounter_PannerNodeDoppler = 76,
            eUseCounter_NavigatorGetUserMedia = 77,
            eUseCounter_WebrtcDeprecatedPrefix = 78,
            eUseCounter_RTCPeerConnectionGetStreams = 79,
            eUseCounter_AppCache = 80,
            eUseCounter_PrefixedImageSmoothingEnabled = 81,
            eUseCounter_PrefixedFullscreenAPI = 82,
            eUseCounter_LenientSetter = 83,
            eUseCounter_FileLastModifiedDate = 84,
            eUseCounter_ImageBitmapRenderingContext_TransferImageBitmap = 85,
            eUseCounter_URLCreateObjectURL_MediaStream = 86,
            eUseCounter_XMLBaseAttribute = 87,
            eUseCounter_XMLBaseAttributeForStyleAttr = 88,
            eUseCounter_Count = 89,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PendingAnimationTracker {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ScrollbarStyles {
            pub mHorizontal: u8,
            pub mVertical: u8,
            pub mScrollBehavior: u8,
            pub mScrollSnapTypeX: u8,
            pub mScrollSnapTypeY: u8,
            pub mScrollSnapPointsX: root::nsStyleCoord,
            pub mScrollSnapPointsY: root::nsStyleCoord,
            pub mScrollSnapDestinationX: root::nsStyleCoord_CalcValue,
            pub mScrollSnapDestinationY: root::nsStyleCoord_CalcValue,
        }
        #[test]
        fn bindgen_test_layout_ScrollbarStyles() {
            assert_eq!(::std::mem::size_of::<ScrollbarStyles>() , 64usize ,
                       concat ! (
                       "Size of: " , stringify ! ( ScrollbarStyles ) ));
            assert_eq! (::std::mem::align_of::<ScrollbarStyles>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ScrollbarStyles ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) . mHorizontal
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mHorizontal ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) . mVertical
                        as * const _ as usize } , 1usize , concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mVertical ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) .
                        mScrollBehavior as * const _ as usize } , 2usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mScrollBehavior ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) .
                        mScrollSnapTypeX as * const _ as usize } , 3usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mScrollSnapTypeX ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) .
                        mScrollSnapTypeY as * const _ as usize } , 4usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mScrollSnapTypeY ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) .
                        mScrollSnapPointsX as * const _ as usize } , 8usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mScrollSnapPointsX ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) .
                        mScrollSnapPointsY as * const _ as usize } , 24usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mScrollSnapPointsY ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) .
                        mScrollSnapDestinationX as * const _ as usize } ,
                        40usize , concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mScrollSnapDestinationX ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) .
                        mScrollSnapDestinationY as * const _ as usize } ,
                        52usize , concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mScrollSnapDestinationY ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct LangGroupFontPrefs {
            pub mLangGroup: root::nsCOMPtr,
            pub mMinimumFontSize: root::nscoord,
            pub mDefaultVariableFont: root::nsFont,
            pub mDefaultFixedFont: root::nsFont,
            pub mDefaultSerifFont: root::nsFont,
            pub mDefaultSansSerifFont: root::nsFont,
            pub mDefaultMonospaceFont: root::nsFont,
            pub mDefaultCursiveFont: root::nsFont,
            pub mDefaultFantasyFont: root::nsFont,
            pub mNext: root::nsAutoPtr<root::mozilla::LangGroupFontPrefs>,
        }
        #[test]
        fn bindgen_test_layout_LangGroupFontPrefs() {
            assert_eq!(::std::mem::size_of::<LangGroupFontPrefs>() , 640usize
                       , concat ! (
                       "Size of: " , stringify ! ( LangGroupFontPrefs ) ));
            assert_eq! (::std::mem::align_of::<LangGroupFontPrefs>() , 8usize
                        , concat ! (
                        "Alignment of " , stringify ! ( LangGroupFontPrefs )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mLangGroup as * const _ as usize } , 0usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! ( mLangGroup
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mMinimumFontSize as * const _ as usize } , 8usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mMinimumFontSize ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mDefaultVariableFont as * const _ as usize } , 16usize
                        , concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mDefaultVariableFont ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mDefaultFixedFont as * const _ as usize } , 104usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mDefaultFixedFont ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mDefaultSerifFont as * const _ as usize } , 192usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mDefaultSerifFont ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mDefaultSansSerifFont as * const _ as usize } ,
                        280usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mDefaultSansSerifFont ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mDefaultMonospaceFont as * const _ as usize } ,
                        368usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mDefaultMonospaceFont ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mDefaultCursiveFont as * const _ as usize } , 456usize
                        , concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mDefaultCursiveFont ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mDefaultFantasyFont as * const _ as usize } , 544usize
                        , concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mDefaultFantasyFont ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) . mNext as
                        * const _ as usize } , 632usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! ( mNext )
                        ));
        }
        /**
 * Some functionality that has historically lived on nsPresContext does not
 * actually need to be per-document. This singleton class serves as a host
 * for that functionality. We delegate to it from nsPresContext where
 * appropriate, and use it standalone in some cases as well.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct StaticPresData {
            pub mLangService: *mut root::nsLanguageAtomService,
            pub mBorderWidthTable: [root::nscoord; 3usize],
            pub mStaticLangGroupFontPrefs: root::mozilla::LangGroupFontPrefs,
        }
        #[test]
        fn bindgen_test_layout_StaticPresData() {
            assert_eq!(::std::mem::size_of::<StaticPresData>() , 664usize ,
                       concat ! ( "Size of: " , stringify ! ( StaticPresData )
                       ));
            assert_eq! (::std::mem::align_of::<StaticPresData>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StaticPresData ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StaticPresData ) ) . mLangService
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( StaticPresData
                        ) , "::" , stringify ! ( mLangService ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StaticPresData ) ) .
                        mBorderWidthTable as * const _ as usize } , 8usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StaticPresData
                        ) , "::" , stringify ! ( mBorderWidthTable ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StaticPresData ) ) .
                        mStaticLangGroupFontPrefs as * const _ as usize } ,
                        24usize , concat ! (
                        "Alignment of field: " , stringify ! ( StaticPresData
                        ) , "::" , stringify ! ( mStaticLangGroupFontPrefs )
                        ));
        }
        #[repr(C)]
        pub struct EffectCompositor {
            pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
            pub mPresContext: *mut root::nsPresContext,
            pub mElementsToRestyle: [u64; 10usize],
            pub mIsInPreTraverse: bool,
            pub mRuleProcessors: [u64; 2usize],
        }
        pub type EffectCompositor_HasThreadSafeRefCnt =
            root::mozilla::FalseType;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct EffectCompositor_cycleCollection {
            pub _base: root::nsCycleCollectionParticipant,
        }
        #[test]
        fn bindgen_test_layout_EffectCompositor_cycleCollection() {
            assert_eq!(::std::mem::size_of::<EffectCompositor_cycleCollection>()
                       , 16usize , concat ! (
                       "Size of: " , stringify ! (
                       EffectCompositor_cycleCollection ) ));
            assert_eq! (::std::mem::align_of::<EffectCompositor_cycleCollection>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        EffectCompositor_cycleCollection ) ));
        }
        impl Clone for EffectCompositor_cycleCollection {
            fn clone(&self) -> Self { *self }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum EffectCompositor_CascadeLevel {
            Animations = 0,
            Transitions = 1,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum EffectCompositor_RestyleType {
            Throttled = 0,
            Standard = 1,
            Layer = 2,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum EffectCompositor_AnimationRestyleType {
            Throttled = 0,
            Full = 1,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct EffectCompositor_AnimationStyleRuleProcessor {
            pub _base: root::nsIStyleRuleProcessor,
            pub mRefCnt: root::nsAutoRefCnt,
            pub mCompositor: *mut root::mozilla::EffectCompositor,
            pub mCascadeLevel: root::mozilla::EffectCompositor_CascadeLevel,
        }
        pub type EffectCompositor_AnimationStyleRuleProcessor_HasThreadSafeRefCnt
            = root::mozilla::FalseType;
        #[test]
        fn bindgen_test_layout_EffectCompositor_AnimationStyleRuleProcessor() {
            assert_eq!(::std::mem::size_of::<EffectCompositor_AnimationStyleRuleProcessor>()
                       , 32usize , concat ! (
                       "Size of: " , stringify ! (
                       EffectCompositor_AnimationStyleRuleProcessor ) ));
            assert_eq! (::std::mem::align_of::<EffectCompositor_AnimationStyleRuleProcessor>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        EffectCompositor_AnimationStyleRuleProcessor ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const
                        EffectCompositor_AnimationStyleRuleProcessor ) ) .
                        mRefCnt as * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor_AnimationStyleRuleProcessor ) , "::"
                        , stringify ! ( mRefCnt ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const
                        EffectCompositor_AnimationStyleRuleProcessor ) ) .
                        mCompositor as * const _ as usize } , 16usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor_AnimationStyleRuleProcessor ) , "::"
                        , stringify ! ( mCompositor ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const
                        EffectCompositor_AnimationStyleRuleProcessor ) ) .
                        mCascadeLevel as * const _ as usize } , 24usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor_AnimationStyleRuleProcessor ) , "::"
                        , stringify ! ( mCascadeLevel ) ));
        }
        extern "C" {
            #[link_name =
                  "_ZN7mozilla16EffectCompositor21_cycleCollectorGlobalE"]
            pub static mut EffectCompositor__cycleCollectorGlobal:
                       root::mozilla::EffectCompositor_cycleCollection;
        }
        pub const EffectCompositor_kCascadeLevelCount: usize = 2;
        #[test]
        fn bindgen_test_layout_EffectCompositor() {
            assert_eq!(::std::mem::size_of::<EffectCompositor>() , 120usize ,
                       concat ! (
                       "Size of: " , stringify ! ( EffectCompositor ) ));
            assert_eq! (::std::mem::align_of::<EffectCompositor>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( EffectCompositor ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const EffectCompositor ) ) . mRefCnt as
                        * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor ) , "::" , stringify ! ( mRefCnt )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const EffectCompositor ) ) .
                        mPresContext as * const _ as usize } , 8usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor ) , "::" , stringify ! ( mPresContext
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const EffectCompositor ) ) .
                        mElementsToRestyle as * const _ as usize } , 16usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor ) , "::" , stringify ! (
                        mElementsToRestyle ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const EffectCompositor ) ) .
                        mIsInPreTraverse as * const _ as usize } , 96usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor ) , "::" , stringify ! (
                        mIsInPreTraverse ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const EffectCompositor ) ) .
                        mRuleProcessors as * const _ as usize } , 104usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor ) , "::" , stringify ! (
                        mRuleProcessors ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EventStateManager {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct CounterStyleManager {
            pub mRefCnt: root::nsAutoRefCnt,
            pub mPresContext: *mut root::nsPresContext,
            pub mStyles: [u64; 5usize],
            pub mRetiredStyles: root::nsTArray<*mut root::mozilla::CounterStyle>,
        }
        pub type CounterStyleManager_HasThreadSafeRefCnt =
            root::mozilla::FalseType;
        #[test]
        fn bindgen_test_layout_CounterStyleManager() {
            assert_eq!(::std::mem::size_of::<CounterStyleManager>() , 64usize
                       , concat ! (
                       "Size of: " , stringify ! ( CounterStyleManager ) ));
            assert_eq! (::std::mem::align_of::<CounterStyleManager>() , 8usize
                        , concat ! (
                        "Alignment of " , stringify ! ( CounterStyleManager )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CounterStyleManager ) ) . mRefCnt
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        CounterStyleManager ) , "::" , stringify ! ( mRefCnt )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CounterStyleManager ) ) .
                        mPresContext as * const _ as usize } , 8usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        CounterStyleManager ) , "::" , stringify ! (
                        mPresContext ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CounterStyleManager ) ) . mStyles
                        as * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        CounterStyleManager ) , "::" , stringify ! ( mStyles )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CounterStyleManager ) ) .
                        mRetiredStyles as * const _ as usize } , 56usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        CounterStyleManager ) , "::" , stringify ! (
                        mRetiredStyles ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RestyleManager {
            _unused: [u8; 0],
        }
        /**
 * BlockingResourceBase
 * Base class of resources that might block clients trying to acquire them.
 * Does debugging and deadlock detection in DEBUG builds.
 **/
        #[repr(C)]
        #[derive(Debug)]
        pub struct BlockingResourceBase {
            pub _address: u8,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum BlockingResourceBase_BlockingResourceType {
            eMutex = 0,
            eReentrantMonitor = 1,
            eCondVar = 2,
        }
        extern "C" {
            #[link_name =
                  "_ZN7mozilla20BlockingResourceBase17kResourceTypeNameE"]
            pub static mut BlockingResourceBase_kResourceTypeName:
                       [*const ::std::os::raw::c_char; 0usize];
        }
        #[test]
        fn bindgen_test_layout_BlockingResourceBase() {
            assert_eq!(::std::mem::size_of::<BlockingResourceBase>() , 1usize
                       , concat ! (
                       "Size of: " , stringify ! ( BlockingResourceBase ) ));
            assert_eq! (::std::mem::align_of::<BlockingResourceBase>() ,
                        1usize , concat ! (
                        "Alignment of " , stringify ! ( BlockingResourceBase )
                        ));
        }
        /**
 * OffTheBooksMutex is identical to Mutex, except that OffTheBooksMutex doesn't
 * include leak checking.  Sometimes you want to intentionally "leak" a mutex
 * until shutdown; in these cases, OffTheBooksMutex is for you.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct OffTheBooksMutex {
            pub _base: root::mozilla::detail::MutexImpl,
        }
        #[test]
        fn bindgen_test_layout_OffTheBooksMutex() {
            assert_eq!(::std::mem::size_of::<OffTheBooksMutex>() , 40usize ,
                       concat ! (
                       "Size of: " , stringify ! ( OffTheBooksMutex ) ));
            assert_eq! (::std::mem::align_of::<OffTheBooksMutex>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( OffTheBooksMutex ) ));
        }
        /**
 * Mutex
 * When possible, use MutexAutoLock/MutexAutoUnlock to lock/unlock this
 * mutex within a scope, instead of calling Lock/Unlock directly.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct Mutex {
            pub _base: root::mozilla::OffTheBooksMutex,
        }
        #[test]
        fn bindgen_test_layout_Mutex() {
            assert_eq!(::std::mem::size_of::<Mutex>() , 40usize , concat ! (
                       "Size of: " , stringify ! ( Mutex ) ));
            assert_eq! (::std::mem::align_of::<Mutex>() , 8usize , concat ! (
                        "Alignment of " , stringify ! ( Mutex ) ));
        }
        pub mod image {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ImageURL {
                _unused: [u8; 0],
            }
            /**
 * An ImageLib cache entry key.
 *
 * We key the cache on the initial URI (before any redirects), with some
 * canonicalization applied. See ComputeHash() for the details.
 * Controlled documents do not share their cache entries with
 * non-controlled documents, or other controlled documents.
 */
            #[repr(C)]
            #[derive(Debug)]
            pub struct ImageCacheKey {
                pub mURI: root::RefPtr<root::mozilla::image::ImageURL>,
                pub mBlobSerial: [u64; 2usize],
                pub mOriginAttributes: root::mozilla::OriginAttributes,
                pub mControlledDocument: *mut ::std::os::raw::c_void,
                pub mHash: u32,
                pub mIsChrome: bool,
            }
            #[test]
            fn bindgen_test_layout_ImageCacheKey() {
                assert_eq!(::std::mem::size_of::<ImageCacheKey>() , 80usize ,
                           concat ! (
                           "Size of: " , stringify ! ( ImageCacheKey ) ));
                assert_eq! (::std::mem::align_of::<ImageCacheKey>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( ImageCacheKey )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ImageCacheKey ) ) . mURI as *
                            const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ImageCacheKey ) , "::" , stringify ! ( mURI ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ImageCacheKey ) ) .
                            mBlobSerial as * const _ as usize } , 8usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ImageCacheKey ) , "::" , stringify ! ( mBlobSerial
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ImageCacheKey ) ) .
                            mOriginAttributes as * const _ as usize } ,
                            24usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ImageCacheKey ) , "::" , stringify ! (
                            mOriginAttributes ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ImageCacheKey ) ) .
                            mControlledDocument as * const _ as usize } ,
                            64usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ImageCacheKey ) , "::" , stringify ! (
                            mControlledDocument ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ImageCacheKey ) ) . mHash as
                            * const _ as usize } , 72usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ImageCacheKey ) , "::" , stringify ! ( mHash ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ImageCacheKey ) ) . mIsChrome
                            as * const _ as usize } , 76usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ImageCacheKey ) , "::" , stringify ! ( mIsChrome )
                            ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Image {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ProgressTracker {
                _unused: [u8; 0],
            }
            #[repr(C)]
            pub struct IProgressObserver__bindgen_vtable(::std::os::raw::c_void);
            /**
 * An interface for observing changes to image state, as reported by
 * ProgressTracker.
 *
 * This is the ImageLib-internal version of imgINotificationObserver,
 * essentially, with implementation details that code outside of ImageLib
 * shouldn't see.
 *
 * XXX(seth): It's preferable to avoid adding anything to this interface if
 * possible.  In the long term, it would be ideal to get to a place where we can
 * just use the imgINotificationObserver interface internally as well.
 */
            #[repr(C)]
            #[derive(Debug)]
            pub struct IProgressObserver {
                pub vtable_: *const IProgressObserver__bindgen_vtable,
                pub _base: u64,
            }
            #[test]
            fn bindgen_test_layout_IProgressObserver() {
                assert_eq!(::std::mem::size_of::<IProgressObserver>() ,
                           16usize , concat ! (
                           "Size of: " , stringify ! ( IProgressObserver ) ));
                assert_eq! (::std::mem::align_of::<IProgressObserver>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! ( IProgressObserver
                            ) ));
            }
        }
        pub type CounterValue = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NegativeType {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PadType {
            _unused: [u8; 0],
        }
        #[repr(C)]
        pub struct CounterStyle__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct CounterStyle {
            pub vtable_: *const CounterStyle__bindgen_vtable,
            pub mStyle: i32,
        }
        #[test]
        fn bindgen_test_layout_CounterStyle() {
            assert_eq!(::std::mem::size_of::<CounterStyle>() , 16usize ,
                       concat ! ( "Size of: " , stringify ! ( CounterStyle )
                       ));
            assert_eq! (::std::mem::align_of::<CounterStyle>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( CounterStyle ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CounterStyle ) ) . mStyle as *
                        const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( CounterStyle )
                        , "::" , stringify ! ( mStyle ) ));
        }
        impl Clone for CounterStyle {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct CounterStylePtr {
            pub mRaw: usize,
        }
        #[repr(u64)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum CounterStylePtr_Type {
            eCounterStyle = 0,
            eAnonymousCounterStyle = 1,
            eUnresolvedAtom = 2,
            eMask = 3,
        }
        #[test]
        fn bindgen_test_layout_CounterStylePtr() {
            assert_eq!(::std::mem::size_of::<CounterStylePtr>() , 8usize ,
                       concat ! (
                       "Size of: " , stringify ! ( CounterStylePtr ) ));
            assert_eq! (::std::mem::align_of::<CounterStylePtr>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( CounterStylePtr ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CounterStylePtr ) ) . mRaw as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( CounterStylePtr
                        ) , "::" , stringify ! ( mRaw ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct Position {
            pub mXPosition: root::mozilla::Position_Coord,
            pub mYPosition: root::mozilla::Position_Coord,
        }
        pub type Position_Coord = root::nsStyleCoord_CalcValue;
        #[test]
        fn bindgen_test_layout_Position() {
            assert_eq!(::std::mem::size_of::<Position>() , 24usize , concat !
                       ( "Size of: " , stringify ! ( Position ) ));
            assert_eq! (::std::mem::align_of::<Position>() , 4usize , concat !
                        ( "Alignment of " , stringify ! ( Position ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Position ) ) . mXPosition as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Position ) ,
                        "::" , stringify ! ( mXPosition ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Position ) ) . mYPosition as *
                        const _ as usize } , 12usize , concat ! (
                        "Alignment of field: " , stringify ! ( Position ) ,
                        "::" , stringify ! ( mYPosition ) ));
        }
        impl Clone for Position {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct StyleTransition {
            pub mTimingFunction: root::nsTimingFunction,
            pub mDuration: f32,
            pub mDelay: f32,
            pub mProperty: root::nsCSSPropertyID,
            pub mUnknownProperty: root::nsCOMPtr,
        }
        #[test]
        fn bindgen_test_layout_StyleTransition() {
            assert_eq!(::std::mem::size_of::<StyleTransition>() , 40usize ,
                       concat ! (
                       "Size of: " , stringify ! ( StyleTransition ) ));
            assert_eq! (::std::mem::align_of::<StyleTransition>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StyleTransition ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleTransition ) ) .
                        mTimingFunction as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StyleTransition
                        ) , "::" , stringify ! ( mTimingFunction ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleTransition ) ) . mDuration
                        as * const _ as usize } , 20usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleTransition
                        ) , "::" , stringify ! ( mDuration ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleTransition ) ) . mDelay as *
                        const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleTransition
                        ) , "::" , stringify ! ( mDelay ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleTransition ) ) . mProperty
                        as * const _ as usize } , 28usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleTransition
                        ) , "::" , stringify ! ( mProperty ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleTransition ) ) .
                        mUnknownProperty as * const _ as usize } , 32usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StyleTransition
                        ) , "::" , stringify ! ( mUnknownProperty ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct StyleAnimation {
            pub mTimingFunction: root::nsTimingFunction,
            pub mDuration: f32,
            pub mDelay: f32,
            pub mName: ::nsstring::nsStringRepr,
            pub mDirection: root::mozilla::dom::PlaybackDirection,
            pub mFillMode: root::mozilla::dom::FillMode,
            pub mPlayState: u8,
            pub mIterationCount: f32,
        }
        #[test]
        fn bindgen_test_layout_StyleAnimation() {
            assert_eq!(::std::mem::size_of::<StyleAnimation>() , 56usize ,
                       concat ! ( "Size of: " , stringify ! ( StyleAnimation )
                       ));
            assert_eq! (::std::mem::align_of::<StyleAnimation>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StyleAnimation ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) .
                        mTimingFunction as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mTimingFunction ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) . mDuration as
                        * const _ as usize } , 20usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mDuration ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) . mDelay as *
                        const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mDelay ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) . mName as *
                        const _ as usize } , 32usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mName ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) . mDirection
                        as * const _ as usize } , 48usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mDirection ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) . mFillMode as
                        * const _ as usize } , 49usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mFillMode ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) . mPlayState
                        as * const _ as usize } , 50usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mPlayState ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) .
                        mIterationCount as * const _ as usize } , 52usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mIterationCount ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct StyleBasicShape {
            pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
            pub mType: root::mozilla::StyleBasicShapeType,
            pub mFillRule: root::mozilla::StyleFillRule,
            pub mCoordinates: root::nsTArray<root::nsStyleCoord>,
            pub mPosition: root::mozilla::Position,
            pub mRadius: root::nsStyleCorners,
        }
        pub type StyleBasicShape_HasThreadSafeRefCnt =
            root::mozilla::TrueType;
        #[test]
        fn bindgen_test_layout_StyleBasicShape() {
            assert_eq!(::std::mem::size_of::<StyleBasicShape>() , 120usize ,
                       concat ! (
                       "Size of: " , stringify ! ( StyleBasicShape ) ));
            assert_eq! (::std::mem::align_of::<StyleBasicShape>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StyleBasicShape ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleBasicShape ) ) . mRefCnt as
                        * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleBasicShape
                        ) , "::" , stringify ! ( mRefCnt ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleBasicShape ) ) . mType as *
                        const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleBasicShape
                        ) , "::" , stringify ! ( mType ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleBasicShape ) ) . mFillRule
                        as * const _ as usize } , 9usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleBasicShape
                        ) , "::" , stringify ! ( mFillRule ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleBasicShape ) ) .
                        mCoordinates as * const _ as usize } , 16usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StyleBasicShape
                        ) , "::" , stringify ! ( mCoordinates ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleBasicShape ) ) . mPosition
                        as * const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleBasicShape
                        ) , "::" , stringify ! ( mPosition ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleBasicShape ) ) . mRadius as
                        * const _ as usize } , 48usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleBasicShape
                        ) , "::" , stringify ! ( mRadius ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct StyleShapeSource {
            pub __bindgen_anon_1: root::mozilla::StyleShapeSource__bindgen_ty_1,
            pub mType: root::mozilla::StyleShapeSourceType,
            pub mReferenceBox: root::mozilla::StyleGeometryBox,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleShapeSource__bindgen_ty_1 {
            pub mBasicShape: root::__BindgenUnionField<*mut root::mozilla::StyleBasicShape>,
            pub mURL: root::__BindgenUnionField<*mut root::mozilla::css::URLValue>,
            pub bindgen_union_field: u64,
        }
        #[test]
        fn bindgen_test_layout_StyleShapeSource__bindgen_ty_1() {
            assert_eq!(::std::mem::size_of::<StyleShapeSource__bindgen_ty_1>()
                       , 8usize , concat ! (
                       "Size of: " , stringify ! (
                       StyleShapeSource__bindgen_ty_1 ) ));
            assert_eq! (::std::mem::align_of::<StyleShapeSource__bindgen_ty_1>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        StyleShapeSource__bindgen_ty_1 ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleShapeSource__bindgen_ty_1 )
                        ) . mBasicShape as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleShapeSource__bindgen_ty_1 ) , "::" , stringify !
                        ( mBasicShape ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleShapeSource__bindgen_ty_1 )
                        ) . mURL as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleShapeSource__bindgen_ty_1 ) , "::" , stringify !
                        ( mURL ) ));
        }
        impl Clone for StyleShapeSource__bindgen_ty_1 {
            fn clone(&self) -> Self { *self }
        }
        #[test]
        fn bindgen_test_layout_StyleShapeSource() {
            assert_eq!(::std::mem::size_of::<StyleShapeSource>() , 16usize ,
                       concat ! (
                       "Size of: " , stringify ! ( StyleShapeSource ) ));
            assert_eq! (::std::mem::align_of::<StyleShapeSource>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StyleShapeSource ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleShapeSource ) ) . mType as *
                        const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleShapeSource ) , "::" , stringify ! ( mType ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleShapeSource ) ) .
                        mReferenceBox as * const _ as usize } , 9usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleShapeSource ) , "::" , stringify ! (
                        mReferenceBox ) ));
        }
        pub const SERVO_PREF_ENABLED_align_content: bool = false;
        pub const SERVO_PREF_ENABLED_align_items: bool = false;
        pub const SERVO_PREF_ENABLED_align_self: bool = false;
        pub const SERVO_PREF_ENABLED_all: bool = true;
        pub const SERVO_PREF_ENABLED_animation: bool = false;
        pub const SERVO_PREF_ENABLED_animation_delay: bool = false;
        pub const SERVO_PREF_ENABLED_animation_direction: bool = false;
        pub const SERVO_PREF_ENABLED_animation_duration: bool = false;
        pub const SERVO_PREF_ENABLED_animation_fill_mode: bool = false;
        pub const SERVO_PREF_ENABLED_animation_iteration_count: bool = false;
        pub const SERVO_PREF_ENABLED_animation_name: bool = false;
        pub const SERVO_PREF_ENABLED_animation_play_state: bool = false;
        pub const SERVO_PREF_ENABLED_animation_timing_function: bool = false;
        pub const SERVO_PREF_ENABLED__moz_appearance: bool = false;
        pub const SERVO_PREF_ENABLED_backface_visibility: bool = false;
        pub const SERVO_PREF_ENABLED_background: bool = false;
        pub const SERVO_PREF_ENABLED_background_attachment: bool = false;
        pub const SERVO_PREF_ENABLED_background_blend_mode: bool = true;
        pub const SERVO_PREF_ENABLED_background_clip: bool = false;
        pub const SERVO_PREF_ENABLED_background_color: bool = false;
        pub const SERVO_PREF_ENABLED_background_image: bool = false;
        pub const SERVO_PREF_ENABLED_background_origin: bool = false;
        pub const SERVO_PREF_ENABLED_background_position: bool = false;
        pub const SERVO_PREF_ENABLED_background_position_x: bool = false;
        pub const SERVO_PREF_ENABLED_background_position_y: bool = false;
        pub const SERVO_PREF_ENABLED_background_repeat: bool = false;
        pub const SERVO_PREF_ENABLED_background_size: bool = false;
        pub const SERVO_PREF_ENABLED__moz_binding: bool = false;
        pub const SERVO_PREF_ENABLED_block_size: bool = false;
        pub const SERVO_PREF_ENABLED_border: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_end: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_end_color: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_end_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_end_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_start: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_start_color: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_start_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_start_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_bottom: bool = false;
        pub const SERVO_PREF_ENABLED_border_bottom_color: bool = false;
        pub const SERVO_PREF_ENABLED__moz_border_bottom_colors: bool = false;
        pub const SERVO_PREF_ENABLED_border_bottom_left_radius: bool = false;
        pub const SERVO_PREF_ENABLED_border_bottom_right_radius: bool = false;
        pub const SERVO_PREF_ENABLED_border_bottom_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_bottom_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_collapse: bool = false;
        pub const SERVO_PREF_ENABLED_border_color: bool = false;
        pub const SERVO_PREF_ENABLED_border_image: bool = false;
        pub const SERVO_PREF_ENABLED_border_image_outset: bool = false;
        pub const SERVO_PREF_ENABLED_border_image_repeat: bool = false;
        pub const SERVO_PREF_ENABLED_border_image_slice: bool = false;
        pub const SERVO_PREF_ENABLED_border_image_source: bool = false;
        pub const SERVO_PREF_ENABLED_border_image_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_end: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_end_color: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_end_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_end_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_start: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_start_color: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_start_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_start_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_left: bool = false;
        pub const SERVO_PREF_ENABLED_border_left_color: bool = false;
        pub const SERVO_PREF_ENABLED__moz_border_left_colors: bool = false;
        pub const SERVO_PREF_ENABLED_border_left_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_left_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_radius: bool = false;
        pub const SERVO_PREF_ENABLED_border_right: bool = false;
        pub const SERVO_PREF_ENABLED_border_right_color: bool = false;
        pub const SERVO_PREF_ENABLED__moz_border_right_colors: bool = false;
        pub const SERVO_PREF_ENABLED_border_right_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_right_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_spacing: bool = false;
        pub const SERVO_PREF_ENABLED_border_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_top: bool = false;
        pub const SERVO_PREF_ENABLED_border_top_color: bool = false;
        pub const SERVO_PREF_ENABLED__moz_border_top_colors: bool = false;
        pub const SERVO_PREF_ENABLED_border_top_left_radius: bool = false;
        pub const SERVO_PREF_ENABLED_border_top_right_radius: bool = false;
        pub const SERVO_PREF_ENABLED_border_top_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_top_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_width: bool = false;
        pub const SERVO_PREF_ENABLED_bottom: bool = false;
        pub const SERVO_PREF_ENABLED__moz_box_align: bool = false;
        pub const SERVO_PREF_ENABLED_box_decoration_break: bool = true;
        pub const SERVO_PREF_ENABLED__moz_box_direction: bool = false;
        pub const SERVO_PREF_ENABLED__moz_box_flex: bool = false;
        pub const SERVO_PREF_ENABLED__moz_box_ordinal_group: bool = false;
        pub const SERVO_PREF_ENABLED__moz_box_orient: bool = false;
        pub const SERVO_PREF_ENABLED__moz_box_pack: bool = false;
        pub const SERVO_PREF_ENABLED_box_shadow: bool = false;
        pub const SERVO_PREF_ENABLED_box_sizing: bool = false;
        pub const SERVO_PREF_ENABLED_caption_side: bool = false;
        pub const SERVO_PREF_ENABLED_caret_color: bool = false;
        pub const SERVO_PREF_ENABLED_clear: bool = false;
        pub const SERVO_PREF_ENABLED_clip: bool = false;
        pub const SERVO_PREF_ENABLED_clip_path: bool = false;
        pub const SERVO_PREF_ENABLED_clip_rule: bool = false;
        pub const SERVO_PREF_ENABLED_color: bool = false;
        pub const SERVO_PREF_ENABLED_color_adjust: bool = true;
        pub const SERVO_PREF_ENABLED_color_interpolation: bool = false;
        pub const SERVO_PREF_ENABLED_color_interpolation_filters: bool =
            false;
        pub const SERVO_PREF_ENABLED_column_count: bool = false;
        pub const SERVO_PREF_ENABLED_column_fill: bool = false;
        pub const SERVO_PREF_ENABLED_column_gap: bool = false;
        pub const SERVO_PREF_ENABLED_column_rule: bool = false;
        pub const SERVO_PREF_ENABLED_column_rule_color: bool = false;
        pub const SERVO_PREF_ENABLED_column_rule_style: bool = false;
        pub const SERVO_PREF_ENABLED_column_rule_width: bool = false;
        pub const SERVO_PREF_ENABLED_column_span: bool = true;
        pub const SERVO_PREF_ENABLED_column_width: bool = false;
        pub const SERVO_PREF_ENABLED_columns: bool = false;
        pub const SERVO_PREF_ENABLED_contain: bool = true;
        pub const SERVO_PREF_ENABLED_content: bool = false;
        pub const SERVO_PREF_ENABLED__moz_context_properties: bool = false;
        pub const SERVO_PREF_ENABLED__moz_control_character_visibility: bool =
            false;
        pub const SERVO_PREF_ENABLED_counter_increment: bool = false;
        pub const SERVO_PREF_ENABLED_counter_reset: bool = false;
        pub const SERVO_PREF_ENABLED_cursor: bool = false;
        pub const SERVO_PREF_ENABLED_direction: bool = false;
        pub const SERVO_PREF_ENABLED_display: bool = false;
        pub const SERVO_PREF_ENABLED_dominant_baseline: bool = false;
        pub const SERVO_PREF_ENABLED_empty_cells: bool = false;
        pub const SERVO_PREF_ENABLED_fill: bool = false;
        pub const SERVO_PREF_ENABLED_fill_opacity: bool = false;
        pub const SERVO_PREF_ENABLED_fill_rule: bool = false;
        pub const SERVO_PREF_ENABLED_filter: bool = false;
        pub const SERVO_PREF_ENABLED_flex: bool = false;
        pub const SERVO_PREF_ENABLED_flex_basis: bool = false;
        pub const SERVO_PREF_ENABLED_flex_direction: bool = false;
        pub const SERVO_PREF_ENABLED_flex_flow: bool = false;
        pub const SERVO_PREF_ENABLED_flex_grow: bool = false;
        pub const SERVO_PREF_ENABLED_flex_shrink: bool = false;
        pub const SERVO_PREF_ENABLED_flex_wrap: bool = false;
        pub const SERVO_PREF_ENABLED_float_: bool = false;
        pub const SERVO_PREF_ENABLED__moz_float_edge: bool = false;
        pub const SERVO_PREF_ENABLED_flood_color: bool = false;
        pub const SERVO_PREF_ENABLED_flood_opacity: bool = false;
        pub const SERVO_PREF_ENABLED_font: bool = false;
        pub const SERVO_PREF_ENABLED_font_family: bool = false;
        pub const SERVO_PREF_ENABLED_font_feature_settings: bool = false;
        pub const SERVO_PREF_ENABLED_font_kerning: bool = false;
        pub const SERVO_PREF_ENABLED_font_language_override: bool = false;
        pub const SERVO_PREF_ENABLED_font_size: bool = false;
        pub const SERVO_PREF_ENABLED_font_size_adjust: bool = false;
        pub const SERVO_PREF_ENABLED_font_stretch: bool = false;
        pub const SERVO_PREF_ENABLED_font_style: bool = false;
        pub const SERVO_PREF_ENABLED_font_synthesis: bool = false;
        pub const SERVO_PREF_ENABLED_font_variant: bool = false;
        pub const SERVO_PREF_ENABLED_font_variant_alternates: bool = false;
        pub const SERVO_PREF_ENABLED_font_variant_caps: bool = false;
        pub const SERVO_PREF_ENABLED_font_variant_east_asian: bool = false;
        pub const SERVO_PREF_ENABLED_font_variant_ligatures: bool = false;
        pub const SERVO_PREF_ENABLED_font_variant_numeric: bool = false;
        pub const SERVO_PREF_ENABLED_font_variant_position: bool = false;
        pub const SERVO_PREF_ENABLED_font_variation_settings: bool = true;
        pub const SERVO_PREF_ENABLED_font_weight: bool = false;
        pub const SERVO_PREF_ENABLED__moz_force_broken_image_icon: bool =
            false;
        pub const SERVO_PREF_ENABLED_grid: bool = true;
        pub const SERVO_PREF_ENABLED_grid_area: bool = true;
        pub const SERVO_PREF_ENABLED_grid_auto_columns: bool = true;
        pub const SERVO_PREF_ENABLED_grid_auto_flow: bool = true;
        pub const SERVO_PREF_ENABLED_grid_auto_rows: bool = true;
        pub const SERVO_PREF_ENABLED_grid_column: bool = true;
        pub const SERVO_PREF_ENABLED_grid_column_end: bool = true;
        pub const SERVO_PREF_ENABLED_grid_column_gap: bool = true;
        pub const SERVO_PREF_ENABLED_grid_column_start: bool = true;
        pub const SERVO_PREF_ENABLED_grid_gap: bool = true;
        pub const SERVO_PREF_ENABLED_grid_row: bool = true;
        pub const SERVO_PREF_ENABLED_grid_row_end: bool = true;
        pub const SERVO_PREF_ENABLED_grid_row_gap: bool = true;
        pub const SERVO_PREF_ENABLED_grid_row_start: bool = true;
        pub const SERVO_PREF_ENABLED_grid_template: bool = true;
        pub const SERVO_PREF_ENABLED_grid_template_areas: bool = true;
        pub const SERVO_PREF_ENABLED_grid_template_columns: bool = true;
        pub const SERVO_PREF_ENABLED_grid_template_rows: bool = true;
        pub const SERVO_PREF_ENABLED_height: bool = false;
        pub const SERVO_PREF_ENABLED_hyphens: bool = false;
        pub const SERVO_PREF_ENABLED_initial_letter: bool = true;
        pub const SERVO_PREF_ENABLED_image_orientation: bool = true;
        pub const SERVO_PREF_ENABLED__moz_image_region: bool = false;
        pub const SERVO_PREF_ENABLED_image_rendering: bool = false;
        pub const SERVO_PREF_ENABLED_ime_mode: bool = false;
        pub const SERVO_PREF_ENABLED_inline_size: bool = false;
        pub const SERVO_PREF_ENABLED_isolation: bool = true;
        pub const SERVO_PREF_ENABLED_justify_content: bool = false;
        pub const SERVO_PREF_ENABLED_justify_items: bool = false;
        pub const SERVO_PREF_ENABLED_justify_self: bool = false;
        pub const SERVO_PREF_ENABLED__x_lang: bool = false;
        pub const SERVO_PREF_ENABLED_left: bool = false;
        pub const SERVO_PREF_ENABLED_letter_spacing: bool = false;
        pub const SERVO_PREF_ENABLED_lighting_color: bool = false;
        pub const SERVO_PREF_ENABLED_line_height: bool = false;
        pub const SERVO_PREF_ENABLED_list_style: bool = false;
        pub const SERVO_PREF_ENABLED_list_style_image: bool = false;
        pub const SERVO_PREF_ENABLED_list_style_position: bool = false;
        pub const SERVO_PREF_ENABLED_list_style_type: bool = false;
        pub const SERVO_PREF_ENABLED_margin: bool = false;
        pub const SERVO_PREF_ENABLED_margin_block_end: bool = false;
        pub const SERVO_PREF_ENABLED_margin_block_start: bool = false;
        pub const SERVO_PREF_ENABLED_margin_bottom: bool = false;
        pub const SERVO_PREF_ENABLED_margin_inline_end: bool = false;
        pub const SERVO_PREF_ENABLED_margin_inline_start: bool = false;
        pub const SERVO_PREF_ENABLED_margin_left: bool = false;
        pub const SERVO_PREF_ENABLED_margin_right: bool = false;
        pub const SERVO_PREF_ENABLED_margin_top: bool = false;
        pub const SERVO_PREF_ENABLED_marker: bool = false;
        pub const SERVO_PREF_ENABLED_marker_end: bool = false;
        pub const SERVO_PREF_ENABLED_marker_mid: bool = false;
        pub const SERVO_PREF_ENABLED_marker_start: bool = false;
        pub const SERVO_PREF_ENABLED_mask: bool = false;
        pub const SERVO_PREF_ENABLED_mask_clip: bool = false;
        pub const SERVO_PREF_ENABLED_mask_composite: bool = false;
        pub const SERVO_PREF_ENABLED_mask_image: bool = false;
        pub const SERVO_PREF_ENABLED_mask_mode: bool = false;
        pub const SERVO_PREF_ENABLED_mask_origin: bool = false;
        pub const SERVO_PREF_ENABLED_mask_position: bool = false;
        pub const SERVO_PREF_ENABLED_mask_position_x: bool = false;
        pub const SERVO_PREF_ENABLED_mask_position_y: bool = false;
        pub const SERVO_PREF_ENABLED_mask_repeat: bool = false;
        pub const SERVO_PREF_ENABLED_mask_size: bool = false;
        pub const SERVO_PREF_ENABLED_mask_type: bool = false;
        pub const SERVO_PREF_ENABLED__moz_math_display: bool = false;
        pub const SERVO_PREF_ENABLED__moz_math_variant: bool = false;
        pub const SERVO_PREF_ENABLED_max_block_size: bool = false;
        pub const SERVO_PREF_ENABLED_max_height: bool = false;
        pub const SERVO_PREF_ENABLED_max_inline_size: bool = false;
        pub const SERVO_PREF_ENABLED_max_width: bool = false;
        pub const SERVO_PREF_ENABLED_min_block_size: bool = false;
        pub const SERVO_PREF_ENABLED__moz_min_font_size_ratio: bool = false;
        pub const SERVO_PREF_ENABLED_min_height: bool = false;
        pub const SERVO_PREF_ENABLED_min_inline_size: bool = false;
        pub const SERVO_PREF_ENABLED_min_width: bool = false;
        pub const SERVO_PREF_ENABLED_mix_blend_mode: bool = true;
        pub const SERVO_PREF_ENABLED_object_fit: bool = false;
        pub const SERVO_PREF_ENABLED_object_position: bool = false;
        pub const SERVO_PREF_ENABLED_offset_block_end: bool = false;
        pub const SERVO_PREF_ENABLED_offset_block_start: bool = false;
        pub const SERVO_PREF_ENABLED_offset_inline_end: bool = false;
        pub const SERVO_PREF_ENABLED_offset_inline_start: bool = false;
        pub const SERVO_PREF_ENABLED_opacity: bool = false;
        pub const SERVO_PREF_ENABLED_order: bool = false;
        pub const SERVO_PREF_ENABLED__moz_orient: bool = false;
        pub const SERVO_PREF_ENABLED__moz_osx_font_smoothing: bool = true;
        pub const SERVO_PREF_ENABLED_outline: bool = false;
        pub const SERVO_PREF_ENABLED_outline_color: bool = false;
        pub const SERVO_PREF_ENABLED_outline_offset: bool = false;
        pub const SERVO_PREF_ENABLED__moz_outline_radius: bool = false;
        pub const SERVO_PREF_ENABLED__moz_outline_radius_bottomleft: bool =
            false;
        pub const SERVO_PREF_ENABLED__moz_outline_radius_bottomright: bool =
            false;
        pub const SERVO_PREF_ENABLED__moz_outline_radius_topleft: bool =
            false;
        pub const SERVO_PREF_ENABLED__moz_outline_radius_topright: bool =
            false;
        pub const SERVO_PREF_ENABLED_outline_style: bool = false;
        pub const SERVO_PREF_ENABLED_outline_width: bool = false;
        pub const SERVO_PREF_ENABLED_overflow: bool = false;
        pub const SERVO_PREF_ENABLED_overflow_clip_box: bool = true;
        pub const SERVO_PREF_ENABLED_overflow_x: bool = false;
        pub const SERVO_PREF_ENABLED_overflow_y: bool = false;
        pub const SERVO_PREF_ENABLED_padding: bool = false;
        pub const SERVO_PREF_ENABLED_padding_block_end: bool = false;
        pub const SERVO_PREF_ENABLED_padding_block_start: bool = false;
        pub const SERVO_PREF_ENABLED_padding_bottom: bool = false;
        pub const SERVO_PREF_ENABLED_padding_inline_end: bool = false;
        pub const SERVO_PREF_ENABLED_padding_inline_start: bool = false;
        pub const SERVO_PREF_ENABLED_padding_left: bool = false;
        pub const SERVO_PREF_ENABLED_padding_right: bool = false;
        pub const SERVO_PREF_ENABLED_padding_top: bool = false;
        pub const SERVO_PREF_ENABLED_page_break_after: bool = false;
        pub const SERVO_PREF_ENABLED_page_break_before: bool = false;
        pub const SERVO_PREF_ENABLED_page_break_inside: bool = false;
        pub const SERVO_PREF_ENABLED_paint_order: bool = true;
        pub const SERVO_PREF_ENABLED_perspective: bool = false;
        pub const SERVO_PREF_ENABLED_perspective_origin: bool = false;
        pub const SERVO_PREF_ENABLED_place_content: bool = false;
        pub const SERVO_PREF_ENABLED_place_items: bool = false;
        pub const SERVO_PREF_ENABLED_place_self: bool = false;
        pub const SERVO_PREF_ENABLED_pointer_events: bool = false;
        pub const SERVO_PREF_ENABLED_position: bool = false;
        pub const SERVO_PREF_ENABLED_quotes: bool = false;
        pub const SERVO_PREF_ENABLED_resize: bool = false;
        pub const SERVO_PREF_ENABLED_right: bool = false;
        pub const SERVO_PREF_ENABLED_ruby_align: bool = false;
        pub const SERVO_PREF_ENABLED_ruby_position: bool = false;
        pub const SERVO_PREF_ENABLED__moz_script_level: bool = false;
        pub const SERVO_PREF_ENABLED__moz_script_min_size: bool = false;
        pub const SERVO_PREF_ENABLED__moz_script_size_multiplier: bool =
            false;
        pub const SERVO_PREF_ENABLED_scroll_behavior: bool = true;
        pub const SERVO_PREF_ENABLED_scroll_snap_coordinate: bool = true;
        pub const SERVO_PREF_ENABLED_scroll_snap_destination: bool = true;
        pub const SERVO_PREF_ENABLED_scroll_snap_points_x: bool = true;
        pub const SERVO_PREF_ENABLED_scroll_snap_points_y: bool = true;
        pub const SERVO_PREF_ENABLED_scroll_snap_type: bool = true;
        pub const SERVO_PREF_ENABLED_scroll_snap_type_x: bool = true;
        pub const SERVO_PREF_ENABLED_scroll_snap_type_y: bool = true;
        pub const SERVO_PREF_ENABLED_shape_outside: bool = true;
        pub const SERVO_PREF_ENABLED_shape_rendering: bool = false;
        pub const SERVO_PREF_ENABLED__x_span: bool = false;
        pub const SERVO_PREF_ENABLED__moz_stack_sizing: bool = false;
        pub const SERVO_PREF_ENABLED_stop_color: bool = false;
        pub const SERVO_PREF_ENABLED_stop_opacity: bool = false;
        pub const SERVO_PREF_ENABLED_stroke: bool = false;
        pub const SERVO_PREF_ENABLED_stroke_dasharray: bool = false;
        pub const SERVO_PREF_ENABLED_stroke_dashoffset: bool = false;
        pub const SERVO_PREF_ENABLED_stroke_linecap: bool = false;
        pub const SERVO_PREF_ENABLED_stroke_linejoin: bool = false;
        pub const SERVO_PREF_ENABLED_stroke_miterlimit: bool = false;
        pub const SERVO_PREF_ENABLED_stroke_opacity: bool = false;
        pub const SERVO_PREF_ENABLED_stroke_width: bool = false;
        pub const SERVO_PREF_ENABLED__x_system_font: bool = false;
        pub const SERVO_PREF_ENABLED__moz_tab_size: bool = false;
        pub const SERVO_PREF_ENABLED_table_layout: bool = false;
        pub const SERVO_PREF_ENABLED_text_align: bool = false;
        pub const SERVO_PREF_ENABLED_text_align_last: bool = false;
        pub const SERVO_PREF_ENABLED_text_anchor: bool = false;
        pub const SERVO_PREF_ENABLED_text_combine_upright: bool = true;
        pub const SERVO_PREF_ENABLED_text_decoration: bool = false;
        pub const SERVO_PREF_ENABLED_text_decoration_color: bool = false;
        pub const SERVO_PREF_ENABLED_text_decoration_line: bool = false;
        pub const SERVO_PREF_ENABLED_text_decoration_style: bool = false;
        pub const SERVO_PREF_ENABLED_text_emphasis: bool = false;
        pub const SERVO_PREF_ENABLED_text_emphasis_color: bool = false;
        pub const SERVO_PREF_ENABLED_text_emphasis_position: bool = false;
        pub const SERVO_PREF_ENABLED_text_emphasis_style: bool = false;
        pub const SERVO_PREF_ENABLED__webkit_text_fill_color: bool = true;
        pub const SERVO_PREF_ENABLED_text_indent: bool = false;
        pub const SERVO_PREF_ENABLED_text_justify: bool = true;
        pub const SERVO_PREF_ENABLED_text_orientation: bool = false;
        pub const SERVO_PREF_ENABLED_text_overflow: bool = false;
        pub const SERVO_PREF_ENABLED_text_rendering: bool = false;
        pub const SERVO_PREF_ENABLED_text_shadow: bool = false;
        pub const SERVO_PREF_ENABLED__moz_text_size_adjust: bool = false;
        pub const SERVO_PREF_ENABLED__webkit_text_stroke: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_text_stroke_color: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_text_stroke_width: bool = true;
        pub const SERVO_PREF_ENABLED_text_transform: bool = false;
        pub const SERVO_PREF_ENABLED__x_text_zoom: bool = false;
        pub const SERVO_PREF_ENABLED_top: bool = false;
        pub const SERVO_PREF_ENABLED__moz_top_layer: bool = false;
        pub const SERVO_PREF_ENABLED_touch_action: bool = true;
        pub const SERVO_PREF_ENABLED_transform: bool = false;
        pub const SERVO_PREF_ENABLED__moz_transform: bool = true;
        pub const SERVO_PREF_ENABLED_transform_box: bool = true;
        pub const SERVO_PREF_ENABLED_transform_origin: bool = false;
        pub const SERVO_PREF_ENABLED_transform_style: bool = false;
        pub const SERVO_PREF_ENABLED_transition: bool = false;
        pub const SERVO_PREF_ENABLED_transition_delay: bool = false;
        pub const SERVO_PREF_ENABLED_transition_duration: bool = false;
        pub const SERVO_PREF_ENABLED_transition_property: bool = false;
        pub const SERVO_PREF_ENABLED_transition_timing_function: bool = false;
        pub const SERVO_PREF_ENABLED_unicode_bidi: bool = false;
        pub const SERVO_PREF_ENABLED__moz_user_focus: bool = false;
        pub const SERVO_PREF_ENABLED__moz_user_input: bool = false;
        pub const SERVO_PREF_ENABLED__moz_user_modify: bool = false;
        pub const SERVO_PREF_ENABLED__moz_user_select: bool = false;
        pub const SERVO_PREF_ENABLED_vector_effect: bool = false;
        pub const SERVO_PREF_ENABLED_vertical_align: bool = false;
        pub const SERVO_PREF_ENABLED_visibility: bool = false;
        pub const SERVO_PREF_ENABLED_white_space: bool = false;
        pub const SERVO_PREF_ENABLED_width: bool = false;
        pub const SERVO_PREF_ENABLED_will_change: bool = false;
        pub const SERVO_PREF_ENABLED__moz_window_dragging: bool = false;
        pub const SERVO_PREF_ENABLED__moz_window_shadow: bool = false;
        pub const SERVO_PREF_ENABLED__moz_window_opacity: bool = false;
        pub const SERVO_PREF_ENABLED__moz_window_transform: bool = false;
        pub const SERVO_PREF_ENABLED__moz_window_transform_origin: bool =
            false;
        pub const SERVO_PREF_ENABLED_word_break: bool = false;
        pub const SERVO_PREF_ENABLED_word_spacing: bool = false;
        pub const SERVO_PREF_ENABLED_overflow_wrap: bool = false;
        pub const SERVO_PREF_ENABLED_writing_mode: bool = false;
        pub const SERVO_PREF_ENABLED_z_index: bool = false;
        /**
 * This class holds all non-tree-structural state of an element that might be
 * used for selector matching eventually.
 *
 * This means the attributes, and the element state, such as :hover, :active,
 * etc...
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct ServoElementSnapshot {
            pub mAttrs: root::nsTArray<root::mozilla::ServoAttrSnapshot>,
            pub mState: root::mozilla::ServoElementSnapshot_ServoStateType,
            pub mContains: root::mozilla::ServoElementSnapshot_Flags,
            pub _bitfield_1: u8,
            pub __bindgen_padding_0: [u16; 3usize],
        }
        pub type ServoElementSnapshot_BorrowedAttrInfo =
            root::mozilla::dom::BorrowedAttrInfo;
        pub type ServoElementSnapshot_Element = root::mozilla::dom::Element;
        pub type ServoElementSnapshot_ServoStateType =
            root::mozilla::EventStates_ServoType;
        pub use self::super::super::root::mozilla::ServoElementSnapshotFlags
                as ServoElementSnapshot_Flags;
        #[test]
        fn bindgen_test_layout_ServoElementSnapshot() {
            assert_eq!(::std::mem::size_of::<ServoElementSnapshot>() , 24usize
                       , concat ! (
                       "Size of: " , stringify ! ( ServoElementSnapshot ) ));
            assert_eq! (::std::mem::align_of::<ServoElementSnapshot>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! ( ServoElementSnapshot )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoElementSnapshot ) ) . mAttrs
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoElementSnapshot ) , "::" , stringify ! ( mAttrs )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoElementSnapshot ) ) . mState
                        as * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoElementSnapshot ) , "::" , stringify ! ( mState )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoElementSnapshot ) ) .
                        mContains as * const _ as usize } , 16usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        ServoElementSnapshot ) , "::" , stringify ! (
                        mContains ) ));
        }
        impl ServoElementSnapshot {
            #[inline]
            pub fn mIsHTMLElementInHTMLDocument(&self) -> bool {
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                let mask = 1u64 as u8;
                let val = (unit_field_val & mask) >> 0usize;
                unsafe { ::std::mem::transmute(val as u8) }
            }
            #[inline]
            pub fn set_mIsHTMLElementInHTMLDocument(&mut self, val: bool) {
                let mask = 1u64 as u8;
                let val = val as u8 as u8;
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                unit_field_val &= !mask;
                unit_field_val |= (val << 0usize) & mask;
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                        *const _ as *const u8,
                                                    &mut self._bitfield_1 as
                                                        *mut _ as *mut u8,
                                                    ::std::mem::size_of::<u8>());
                }
            }
            #[inline]
            pub fn mIsInChromeDocument(&self) -> bool {
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                let mask = 2u64 as u8;
                let val = (unit_field_val & mask) >> 1usize;
                unsafe { ::std::mem::transmute(val as u8) }
            }
            #[inline]
            pub fn set_mIsInChromeDocument(&mut self, val: bool) {
                let mask = 2u64 as u8;
                let val = val as u8 as u8;
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                unit_field_val &= !mask;
                unit_field_val |= (val << 1usize) & mask;
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                        *const _ as *const u8,
                                                    &mut self._bitfield_1 as
                                                        *mut _ as *mut u8,
                                                    ::std::mem::size_of::<u8>());
                }
            }
            #[inline]
            pub fn mSupportsLangAttr(&self) -> bool {
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                let mask = 4u64 as u8;
                let val = (unit_field_val & mask) >> 2usize;
                unsafe { ::std::mem::transmute(val as u8) }
            }
            #[inline]
            pub fn set_mSupportsLangAttr(&mut self, val: bool) {
                let mask = 4u64 as u8;
                let val = val as u8 as u8;
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                unit_field_val &= !mask;
                unit_field_val |= (val << 2usize) & mask;
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                        *const _ as *const u8,
                                                    &mut self._bitfield_1 as
                                                        *mut _ as *mut u8,
                                                    ::std::mem::size_of::<u8>());
                }
            }
            #[inline]
            pub fn mIsTableBorderNonzero(&self) -> bool {
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                let mask = 8u64 as u8;
                let val = (unit_field_val & mask) >> 3usize;
                unsafe { ::std::mem::transmute(val as u8) }
            }
            #[inline]
            pub fn set_mIsTableBorderNonzero(&mut self, val: bool) {
                let mask = 8u64 as u8;
                let val = val as u8 as u8;
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                unit_field_val &= !mask;
                unit_field_val |= (val << 3usize) & mask;
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                        *const _ as *const u8,
                                                    &mut self._bitfield_1 as
                                                        *mut _ as *mut u8,
                                                    ::std::mem::size_of::<u8>());
                }
            }
            #[inline]
            pub fn mIsMozBrowserFrame(&self) -> bool {
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                let mask = 16u64 as u8;
                let val = (unit_field_val & mask) >> 4usize;
                unsafe { ::std::mem::transmute(val as u8) }
            }
            #[inline]
            pub fn set_mIsMozBrowserFrame(&mut self, val: bool) {
                let mask = 16u64 as u8;
                let val = val as u8 as u8;
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                unit_field_val &= !mask;
                unit_field_val |= (val << 4usize) & mask;
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                        *const _ as *const u8,
                                                    &mut self._bitfield_1 as
                                                        *mut _ as *mut u8,
                                                    ::std::mem::size_of::<u8>());
                }
            }
            #[inline]
            pub fn mClassAttributeChanged(&self) -> bool {
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                let mask = 32u64 as u8;
                let val = (unit_field_val & mask) >> 5usize;
                unsafe { ::std::mem::transmute(val as u8) }
            }
            #[inline]
            pub fn set_mClassAttributeChanged(&mut self, val: bool) {
                let mask = 32u64 as u8;
                let val = val as u8 as u8;
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                unit_field_val &= !mask;
                unit_field_val |= (val << 5usize) & mask;
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                        *const _ as *const u8,
                                                    &mut self._bitfield_1 as
                                                        *mut _ as *mut u8,
                                                    ::std::mem::size_of::<u8>());
                }
            }
            #[inline]
            pub fn mIdAttributeChanged(&self) -> bool {
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                let mask = 64u64 as u8;
                let val = (unit_field_val & mask) >> 6usize;
                unsafe { ::std::mem::transmute(val as u8) }
            }
            #[inline]
            pub fn set_mIdAttributeChanged(&mut self, val: bool) {
                let mask = 64u64 as u8;
                let val = val as u8 as u8;
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                unit_field_val &= !mask;
                unit_field_val |= (val << 6usize) & mask;
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                        *const _ as *const u8,
                                                    &mut self._bitfield_1 as
                                                        *mut _ as *mut u8,
                                                    ::std::mem::size_of::<u8>());
                }
            }
            #[inline]
            pub fn mOtherAttributeChanged(&self) -> bool {
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                let mask = 128u64 as u8;
                let val = (unit_field_val & mask) >> 7usize;
                unsafe { ::std::mem::transmute(val as u8) }
            }
            #[inline]
            pub fn set_mOtherAttributeChanged(&mut self, val: bool) {
                let mask = 128u64 as u8;
                let val = val as u8 as u8;
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                unit_field_val &= !mask;
                unit_field_val |= (val << 7usize) & mask;
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                        *const _ as *const u8,
                                                    &mut self._bitfield_1 as
                                                        *mut _ as *mut u8,
                                                    ::std::mem::size_of::<u8>());
                }
            }
            #[inline]
            pub fn new_bitfield_1(mIsHTMLElementInHTMLDocument: bool,
                                  mIsInChromeDocument: bool,
                                  mSupportsLangAttr: bool,
                                  mIsTableBorderNonzero: bool,
                                  mIsMozBrowserFrame: bool,
                                  mClassAttributeChanged: bool,
                                  mIdAttributeChanged: bool,
                                  mOtherAttributeChanged: bool) -> u8 {
                ({
                     ({
                          ({
                               ({
                                    ({
                                         ({
                                              ({
                                                   ({ 0 } |
                                                        ((mIsHTMLElementInHTMLDocument
                                                              as u8 as u8) <<
                                                             0usize) &
                                                            (1u64 as u8))
                                               } |
                                                   ((mIsInChromeDocument as u8
                                                         as u8) << 1usize) &
                                                       (2u64 as u8))
                                          } |
                                              ((mSupportsLangAttr as u8 as u8)
                                                   << 2usize) & (4u64 as u8))
                                     } |
                                         ((mIsTableBorderNonzero as u8 as u8)
                                              << 3usize) & (8u64 as u8))
                                } |
                                    ((mIsMozBrowserFrame as u8 as u8) <<
                                         4usize) & (16u64 as u8))
                           } |
                               ((mClassAttributeChanged as u8 as u8) <<
                                    5usize) & (32u64 as u8))
                      } |
                          ((mIdAttributeChanged as u8 as u8) << 6usize) &
                              (64u64 as u8))
                 } |
                     ((mOtherAttributeChanged as u8 as u8) << 7usize) &
                         (128u64 as u8))
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AnimationPropertySegment {
            pub mFromKey: f32,
            pub mToKey: f32,
            pub mFromValue: root::mozilla::AnimationValue,
            pub mToValue: root::mozilla::AnimationValue,
            pub mTimingFunction: [u64; 18usize],
            pub mFromComposite: root::mozilla::dom::CompositeOperation,
            pub mToComposite: root::mozilla::dom::CompositeOperation,
        }
        #[test]
        fn bindgen_test_layout_AnimationPropertySegment() {
            assert_eq!(::std::mem::size_of::<AnimationPropertySegment>() ,
                       208usize , concat ! (
                       "Size of: " , stringify ! ( AnimationPropertySegment )
                       ));
            assert_eq! (::std::mem::align_of::<AnimationPropertySegment>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! (
                        AnimationPropertySegment ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnimationPropertySegment ) ) .
                        mFromKey as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        AnimationPropertySegment ) , "::" , stringify ! (
                        mFromKey ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnimationPropertySegment ) ) .
                        mToKey as * const _ as usize } , 4usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        AnimationPropertySegment ) , "::" , stringify ! (
                        mToKey ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnimationPropertySegment ) ) .
                        mFromValue as * const _ as usize } , 8usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        AnimationPropertySegment ) , "::" , stringify ! (
                        mFromValue ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnimationPropertySegment ) ) .
                        mToValue as * const _ as usize } , 32usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        AnimationPropertySegment ) , "::" , stringify ! (
                        mToValue ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnimationPropertySegment ) ) .
                        mTimingFunction as * const _ as usize } , 56usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        AnimationPropertySegment ) , "::" , stringify ! (
                        mTimingFunction ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnimationPropertySegment ) ) .
                        mFromComposite as * const _ as usize } , 200usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        AnimationPropertySegment ) , "::" , stringify ! (
                        mFromComposite ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnimationPropertySegment ) ) .
                        mToComposite as * const _ as usize } , 201usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        AnimationPropertySegment ) , "::" , stringify ! (
                        mToComposite ) ));
        }
        /**
 * Stores the results of calculating the timing properties of an animation
 * at a given sample time.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct ComputedTiming {
            pub mActiveDuration: root::mozilla::StickyTimeDuration,
            pub mActiveTime: root::mozilla::StickyTimeDuration,
            pub mEndTime: root::mozilla::StickyTimeDuration,
            pub mProgress: [u64; 2usize],
            pub mCurrentIteration: u64,
            pub mIterations: f64,
            pub mIterationStart: f64,
            pub mDuration: root::mozilla::StickyTimeDuration,
            pub mFill: root::mozilla::dom::FillMode,
            pub mPhase: root::mozilla::ComputedTiming_AnimationPhase,
            pub mBeforeFlag: root::mozilla::ComputedTimingFunction_BeforeFlag,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ComputedTiming_AnimationPhase {
            Idle = 0,
            Before = 1,
            Active = 2,
            After = 3,
        }
        #[test]
        fn bindgen_test_layout_ComputedTiming() {
            assert_eq!(::std::mem::size_of::<ComputedTiming>() , 88usize ,
                       concat ! ( "Size of: " , stringify ! ( ComputedTiming )
                       ));
            assert_eq! (::std::mem::align_of::<ComputedTiming>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ComputedTiming ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTiming ) ) .
                        mActiveDuration as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ComputedTiming
                        ) , "::" , stringify ! ( mActiveDuration ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTiming ) ) . mActiveTime
                        as * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( ComputedTiming
                        ) , "::" , stringify ! ( mActiveTime ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTiming ) ) . mEndTime as
                        * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! ( ComputedTiming
                        ) , "::" , stringify ! ( mEndTime ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTiming ) ) . mProgress as
                        * const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! ( ComputedTiming
                        ) , "::" , stringify ! ( mProgress ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTiming ) ) .
                        mCurrentIteration as * const _ as usize } , 40usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ComputedTiming
                        ) , "::" , stringify ! ( mCurrentIteration ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTiming ) ) . mIterations
                        as * const _ as usize } , 48usize , concat ! (
                        "Alignment of field: " , stringify ! ( ComputedTiming
                        ) , "::" , stringify ! ( mIterations ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTiming ) ) .
                        mIterationStart as * const _ as usize } , 56usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ComputedTiming
                        ) , "::" , stringify ! ( mIterationStart ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTiming ) ) . mDuration as
                        * const _ as usize } , 64usize , concat ! (
                        "Alignment of field: " , stringify ! ( ComputedTiming
                        ) , "::" , stringify ! ( mDuration ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTiming ) ) . mFill as *
                        const _ as usize } , 72usize , concat ! (
                        "Alignment of field: " , stringify ! ( ComputedTiming
                        ) , "::" , stringify ! ( mFill ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTiming ) ) . mPhase as *
                        const _ as usize } , 76usize , concat ! (
                        "Alignment of field: " , stringify ! ( ComputedTiming
                        ) , "::" , stringify ! ( mPhase ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTiming ) ) . mBeforeFlag
                        as * const _ as usize } , 80usize , concat ! (
                        "Alignment of field: " , stringify ! ( ComputedTiming
                        ) , "::" , stringify ! ( mBeforeFlag ) ));
        }
        /**
 * A single keyframe.
 *
 * This is the canonical form in which keyframe effects are stored and
 * corresponds closely to the type of objects returned via the getKeyframes()
 * API.
 *
 * Before computing an output animation value, however, we flatten these frames
 * down to a series of per-property value arrays where we also resolve any
 * overlapping shorthands/longhands, convert specified CSS values to computed
 * values, etc.
 *
 * When the target element or style context changes, however, we rebuild these
 * per-property arrays from the original list of keyframes objects. As a result,
 * these objects represent the master definition of the effect's values.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct Keyframe {
            pub mOffset: [u64; 2usize],
            pub mComputedOffset: f64,
            pub mTimingFunction: [u64; 18usize],
            pub mComposite: [u8; 2usize],
            pub mPropertyValues: root::nsTArray<root::mozilla::PropertyValuePair>,
        }
        pub const Keyframe_kComputedOffsetNotSet: f64 = -1.;
        #[test]
        fn bindgen_test_layout_Keyframe() {
            assert_eq!(::std::mem::size_of::<Keyframe>() , 184usize , concat !
                       ( "Size of: " , stringify ! ( Keyframe ) ));
            assert_eq! (::std::mem::align_of::<Keyframe>() , 8usize , concat !
                        ( "Alignment of " , stringify ! ( Keyframe ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Keyframe ) ) . mOffset as * const
                        _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Keyframe ) ,
                        "::" , stringify ! ( mOffset ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Keyframe ) ) . mComputedOffset as
                        * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! ( Keyframe ) ,
                        "::" , stringify ! ( mComputedOffset ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Keyframe ) ) . mTimingFunction as
                        * const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! ( Keyframe ) ,
                        "::" , stringify ! ( mTimingFunction ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Keyframe ) ) . mComposite as *
                        const _ as usize } , 168usize , concat ! (
                        "Alignment of field: " , stringify ! ( Keyframe ) ,
                        "::" , stringify ! ( mComposite ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Keyframe ) ) . mPropertyValues as
                        * const _ as usize } , 176usize , concat ! (
                        "Alignment of field: " , stringify ! ( Keyframe ) ,
                        "::" , stringify ! ( mPropertyValues ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct PropertyStyleAnimationValuePair {
            pub mProperty: root::nsCSSPropertyID,
            pub mValue: root::mozilla::AnimationValue,
        }
        #[test]
        fn bindgen_test_layout_PropertyStyleAnimationValuePair() {
            assert_eq!(::std::mem::size_of::<PropertyStyleAnimationValuePair>()
                       , 32usize , concat ! (
                       "Size of: " , stringify ! (
                       PropertyStyleAnimationValuePair ) ));
            assert_eq! (::std::mem::align_of::<PropertyStyleAnimationValuePair>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        PropertyStyleAnimationValuePair ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PropertyStyleAnimationValuePair )
                        ) . mProperty as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        PropertyStyleAnimationValuePair ) , "::" , stringify !
                        ( mProperty ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PropertyStyleAnimationValuePair )
                        ) . mValue as * const _ as usize } , 8usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        PropertyStyleAnimationValuePair ) , "::" , stringify !
                        ( mValue ) ));
        }
        #[test]
        fn __bindgen_test_layout_DefaultDelete_instantiation_3() {
            assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                       1usize , concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::mozilla::DefaultDelete ) ));
            assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>()
                       , 1usize , concat ! (
                       "Alignment of template specialization: " , stringify !
                       ( root::mozilla::DefaultDelete ) ));
        }
        /**
 * Utility class to handle animated style values
 */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleAnimationValue {
            pub _bindgen_opaque_blob: [u64; 2usize],
        }
        #[repr(u32)]
        /**
   * The types and values for the values that we extract and animate.
   */
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleAnimationValue_Unit {
            eUnit_Null = 0,
            eUnit_Normal = 1,
            eUnit_Auto = 2,
            eUnit_None = 3,
            eUnit_Enumerated = 4,
            eUnit_Visibility = 5,
            eUnit_Integer = 6,
            eUnit_Coord = 7,
            eUnit_Percent = 8,
            eUnit_Float = 9,
            eUnit_Color = 10,
            eUnit_CurrentColor = 11,
            eUnit_ComplexColor = 12,
            eUnit_Calc = 13,
            eUnit_ObjectPosition = 14,
            eUnit_URL = 15,
            eUnit_DiscreteCSSValue = 16,
            eUnit_CSSValuePair = 17,
            eUnit_CSSValueTriplet = 18,
            eUnit_CSSRect = 19,
            eUnit_Dasharray = 20,
            eUnit_Shadow = 21,
            eUnit_Shape = 22,
            eUnit_Filter = 23,
            eUnit_Transform = 24,
            eUnit_BackgroundPositionCoord = 25,
            eUnit_CSSValuePairList = 26,
            eUnit_UnparsedString = 27,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleAnimationValue__bindgen_ty_1 {
            pub mInt: root::__BindgenUnionField<i32>,
            pub mCoord: root::__BindgenUnionField<root::nscoord>,
            pub mFloat: root::__BindgenUnionField<f32>,
            pub mCSSValue: root::__BindgenUnionField<*mut root::nsCSSValue>,
            pub mCSSValuePair: root::__BindgenUnionField<*mut root::nsCSSValuePair>,
            pub mCSSValueTriplet: root::__BindgenUnionField<*mut root::nsCSSValueTriplet>,
            pub mCSSRect: root::__BindgenUnionField<*mut root::nsCSSRect>,
            pub mCSSValueArray: root::__BindgenUnionField<*mut root::nsCSSValue_Array>,
            pub mCSSValueList: root::__BindgenUnionField<*mut root::nsCSSValueList>,
            pub mCSSValueSharedList: root::__BindgenUnionField<*mut root::nsCSSValueSharedList>,
            pub mCSSValuePairList: root::__BindgenUnionField<*mut root::nsCSSValuePairList>,
            pub mString: root::__BindgenUnionField<*mut root::nsStringBuffer>,
            pub mComplexColor: root::__BindgenUnionField<*mut root::mozilla::css::ComplexColorValue>,
            pub bindgen_union_field: u64,
        }
        #[test]
        fn bindgen_test_layout_StyleAnimationValue__bindgen_ty_1() {
            assert_eq!(::std::mem::size_of::<StyleAnimationValue__bindgen_ty_1>()
                       , 8usize , concat ! (
                       "Size of: " , stringify ! (
                       StyleAnimationValue__bindgen_ty_1 ) ));
            assert_eq! (::std::mem::align_of::<StyleAnimationValue__bindgen_ty_1>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mInt as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mInt ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCoord as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCoord ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mFloat as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mFloat ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSValue as * const _ as usize } , 0usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSValue ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSValuePair as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSValuePair ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSValueTriplet as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSValueTriplet ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSRect as * const _ as usize } , 0usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSRect ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSValueArray as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSValueArray ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSValueList as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSValueList ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSValueSharedList as * const _ as usize } , 0usize
                        , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSValueSharedList ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSValuePairList as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSValuePairList ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mString as * const _ as usize } , 0usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mString ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mComplexColor as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mComplexColor ) ));
        }
        impl Clone for StyleAnimationValue__bindgen_ty_1 {
            fn clone(&self) -> Self { *self }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleAnimationValue_IntegerConstructorType {
            IntegerConstructor = 0,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleAnimationValue_CoordConstructorType {
            CoordConstructor = 0,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleAnimationValue_PercentConstructorType {
            PercentConstructor = 0,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleAnimationValue_FloatConstructorType {
            FloatConstructor = 0,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleAnimationValue_ColorConstructorType {
            ColorConstructor = 0,
        }
        #[test]
        fn bindgen_test_layout_StyleAnimationValue() {
            assert_eq!(::std::mem::size_of::<StyleAnimationValue>() , 16usize
                       , concat ! (
                       "Size of: " , stringify ! ( StyleAnimationValue ) ));
            assert_eq! (::std::mem::align_of::<StyleAnimationValue>() , 8usize
                        , concat ! (
                        "Alignment of " , stringify ! ( StyleAnimationValue )
                        ));
        }
        impl Clone for StyleAnimationValue {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AnimationValue {
            pub mGecko: root::mozilla::StyleAnimationValue,
            pub mServo: root::RefPtr<root::RawServoAnimationValue>,
        }
        #[test]
        fn bindgen_test_layout_AnimationValue() {
            assert_eq!(::std::mem::size_of::<AnimationValue>() , 24usize ,
                       concat ! ( "Size of: " , stringify ! ( AnimationValue )
                       ));
            assert_eq! (::std::mem::align_of::<AnimationValue>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( AnimationValue ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnimationValue ) ) . mGecko as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( AnimationValue
                        ) , "::" , stringify ! ( mGecko ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnimationValue ) ) . mServo as *
                        const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! ( AnimationValue
                        ) , "::" , stringify ! ( mServo ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ServoCSSRuleList {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct URIPrincipalReferrerPolicyAndCORSModeHashKey {
            pub _base: root::nsURIHashKey,
            pub mPrincipal: root::nsCOMPtr,
            pub mCORSMode: root::mozilla::CORSMode,
            pub mReferrerPolicy: root::mozilla::URIPrincipalReferrerPolicyAndCORSModeHashKey_ReferrerPolicy,
        }
        pub type URIPrincipalReferrerPolicyAndCORSModeHashKey_KeyType =
            *mut root::mozilla::URIPrincipalReferrerPolicyAndCORSModeHashKey;
        pub type URIPrincipalReferrerPolicyAndCORSModeHashKey_KeyTypePointer =
            *const root::mozilla::URIPrincipalReferrerPolicyAndCORSModeHashKey;
        pub use self::super::super::root::mozilla::net::ReferrerPolicy as
                URIPrincipalReferrerPolicyAndCORSModeHashKey_ReferrerPolicy;
        pub const URIPrincipalReferrerPolicyAndCORSModeHashKey_ALLOW_MEMMOVE:
                  root::mozilla::URIPrincipalReferrerPolicyAndCORSModeHashKey__bindgen_ty_1
                  =
            URIPrincipalReferrerPolicyAndCORSModeHashKey__bindgen_ty_1::ALLOW_MEMMOVE;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum URIPrincipalReferrerPolicyAndCORSModeHashKey__bindgen_ty_1 {
            ALLOW_MEMMOVE = 1,
        }
        #[test]
        fn bindgen_test_layout_URIPrincipalReferrerPolicyAndCORSModeHashKey() {
            assert_eq!(::std::mem::size_of::<URIPrincipalReferrerPolicyAndCORSModeHashKey>()
                       , 32usize , concat ! (
                       "Size of: " , stringify ! (
                       URIPrincipalReferrerPolicyAndCORSModeHashKey ) ));
            assert_eq! (::std::mem::align_of::<URIPrincipalReferrerPolicyAndCORSModeHashKey>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        URIPrincipalReferrerPolicyAndCORSModeHashKey ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const
                        URIPrincipalReferrerPolicyAndCORSModeHashKey ) ) .
                        mPrincipal as * const _ as usize } , 16usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        URIPrincipalReferrerPolicyAndCORSModeHashKey ) , "::"
                        , stringify ! ( mPrincipal ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const
                        URIPrincipalReferrerPolicyAndCORSModeHashKey ) ) .
                        mCORSMode as * const _ as usize } , 24usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        URIPrincipalReferrerPolicyAndCORSModeHashKey ) , "::"
                        , stringify ! ( mCORSMode ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const
                        URIPrincipalReferrerPolicyAndCORSModeHashKey ) ) .
                        mReferrerPolicy as * const _ as usize } , 28usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        URIPrincipalReferrerPolicyAndCORSModeHashKey ) , "::"
                        , stringify ! ( mReferrerPolicy ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ComputedTimingFunction {
            pub mType: root::nsTimingFunction_Type,
            pub mTimingFunction: root::nsSMILKeySpline,
            pub mStepsOrFrames: u32,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ComputedTimingFunction_BeforeFlag { Unset = 0, Set = 1, }
        #[test]
        fn bindgen_test_layout_ComputedTimingFunction() {
            assert_eq!(::std::mem::size_of::<ComputedTimingFunction>() ,
                       136usize , concat ! (
                       "Size of: " , stringify ! ( ComputedTimingFunction )
                       ));
            assert_eq! (::std::mem::align_of::<ComputedTimingFunction>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! ( ComputedTimingFunction
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTimingFunction ) ) .
                        mType as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ComputedTimingFunction ) , "::" , stringify ! ( mType
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTimingFunction ) ) .
                        mTimingFunction as * const _ as usize } , 8usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        ComputedTimingFunction ) , "::" , stringify ! (
                        mTimingFunction ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTimingFunction ) ) .
                        mStepsOrFrames as * const _ as usize } , 128usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        ComputedTimingFunction ) , "::" , stringify ! (
                        mStepsOrFrames ) ));
        }
        impl Clone for ComputedTimingFunction {
            fn clone(&self) -> Self { *self }
        }
        /**
 * A ValueCalculator class that performs additional checks before performing
 * arithmetic operations such that if either operand is Forever (or the
 * negative equivalent) the result remains Forever (or the negative equivalent
 * as appropriate).
 *
 * Currently this only checks if either argument to each operation is
 * Forever/-Forever. However, it is possible that, for example,
 * aA + aB > INT64_MAX (or < INT64_MIN).
 *
 * We currently don't check for that case since we don't expect that to
 * happen often except under test conditions in which case the wrapping
 * behavior is probably acceptable.
 */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StickyTimeDurationValueCalculator {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_StickyTimeDurationValueCalculator() {
            assert_eq!(::std::mem::size_of::<StickyTimeDurationValueCalculator>()
                       , 1usize , concat ! (
                       "Size of: " , stringify ! (
                       StickyTimeDurationValueCalculator ) ));
            assert_eq! (::std::mem::align_of::<StickyTimeDurationValueCalculator>()
                        , 1usize , concat ! (
                        "Alignment of " , stringify ! (
                        StickyTimeDurationValueCalculator ) ));
        }
        impl Clone for StickyTimeDurationValueCalculator {
            fn clone(&self) -> Self { *self }
        }
        /**
 * Specialization of BaseTimeDuration that uses
 * StickyTimeDurationValueCalculator for arithmetic on the mValue member.
 *
 * Use this class when you need a time duration that is expected to hold values
 * of Forever (or the negative equivalent) *and* when you expect that
 * time duration to be used in arithmetic operations (and not just value
 * comparisons).
 */
        pub type StickyTimeDuration = root::mozilla::BaseTimeDuration;
        /**
 * A property-value pair specified on a keyframe.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct PropertyValuePair {
            pub mProperty: root::nsCSSPropertyID,
            pub mValue: root::nsCSSValue,
            pub mServoDeclarationBlock: root::RefPtr<root::RawServoDeclarationBlock>,
        }
        #[test]
        fn bindgen_test_layout_PropertyValuePair() {
            assert_eq!(::std::mem::size_of::<PropertyValuePair>() , 32usize ,
                       concat ! (
                       "Size of: " , stringify ! ( PropertyValuePair ) ));
            assert_eq! (::std::mem::align_of::<PropertyValuePair>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( PropertyValuePair )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PropertyValuePair ) ) . mProperty
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        PropertyValuePair ) , "::" , stringify ! ( mProperty )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PropertyValuePair ) ) . mValue as
                        * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        PropertyValuePair ) , "::" , stringify ! ( mValue )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PropertyValuePair ) ) .
                        mServoDeclarationBlock as * const _ as usize } ,
                        24usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        PropertyValuePair ) , "::" , stringify ! (
                        mServoDeclarationBlock ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SVGLengthList {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SVGNumberList {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SVGPathData {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SVGPointList {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SVGAnimatedPreserveAspectRatio {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SVGStringList {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SVGTransformList {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DeclarationBlock {
            _unused: [u8; 0],
        }
        /**
 * A structure representing a single attribute name and value.
 *
 * This is pretty similar to the private nsAttrAndChildArray::InternalAttr.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct ServoAttrSnapshot {
            pub mName: root::nsAttrName,
            pub mValue: root::nsAttrValue,
        }
        #[test]
        fn bindgen_test_layout_ServoAttrSnapshot() {
            assert_eq!(::std::mem::size_of::<ServoAttrSnapshot>() , 16usize ,
                       concat ! (
                       "Size of: " , stringify ! ( ServoAttrSnapshot ) ));
            assert_eq! (::std::mem::align_of::<ServoAttrSnapshot>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ServoAttrSnapshot )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoAttrSnapshot ) ) . mName as
                        * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoAttrSnapshot ) , "::" , stringify ! ( mName ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoAttrSnapshot ) ) . mValue as
                        * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoAttrSnapshot ) , "::" , stringify ! ( mValue )
                        ));
        }
        #[repr(u8)]
        /**
 * A bitflags enum class used to determine what data does a ServoElementSnapshot
 * contains.
 */
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ServoElementSnapshotFlags {
            State = 1,
            Attributes = 2,
            Id = 4,
            MaybeClass = 8,
            OtherPseudoClassState = 16,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct NonOwningAnimationTarget {
            pub mElement: *mut root::mozilla::dom::Element,
            pub mPseudoType: root::mozilla::CSSPseudoElementType,
        }
        #[test]
        fn bindgen_test_layout_NonOwningAnimationTarget() {
            assert_eq!(::std::mem::size_of::<NonOwningAnimationTarget>() ,
                       16usize , concat ! (
                       "Size of: " , stringify ! ( NonOwningAnimationTarget )
                       ));
            assert_eq! (::std::mem::align_of::<NonOwningAnimationTarget>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! (
                        NonOwningAnimationTarget ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const NonOwningAnimationTarget ) ) .
                        mElement as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        NonOwningAnimationTarget ) , "::" , stringify ! (
                        mElement ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const NonOwningAnimationTarget ) ) .
                        mPseudoType as * const _ as usize } , 8usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        NonOwningAnimationTarget ) , "::" , stringify ! (
                        mPseudoType ) ));
        }
        impl Clone for NonOwningAnimationTarget {
            fn clone(&self) -> Self { *self }
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum Directionality {
            eDir_NotSet = 0,
            eDir_RTL = 1,
            eDir_LTR = 2,
            eDir_Auto = 3,
        }
        /**
 * An DisplayItemClip represents the intersection of an optional rectangle
 * with a list of rounded rectangles (which is often empty), all in appunits.
 * It can represent everything CSS clipping can do to an element (except for
 * SVG clip-path), including no clipping at all.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct DisplayItemClip {
            pub mClipRect: root::nsRect,
            pub mRoundedClipRects: root::nsTArray<root::mozilla::DisplayItemClip_RoundedRect>,
            pub mHaveClipRect: bool,
        }
        pub type DisplayItemClip_Color = root::mozilla::gfx::Color;
        pub type DisplayItemClip_DrawTarget = root::mozilla::gfx::DrawTarget;
        pub type DisplayItemClip_Path = root::mozilla::gfx::Path;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct DisplayItemClip_RoundedRect {
            pub mRect: root::nsRect,
            pub mRadii: [root::nscoord; 8usize],
        }
        #[test]
        fn bindgen_test_layout_DisplayItemClip_RoundedRect() {
            assert_eq!(::std::mem::size_of::<DisplayItemClip_RoundedRect>() ,
                       48usize , concat ! (
                       "Size of: " , stringify ! ( DisplayItemClip_RoundedRect
                       ) ));
            assert_eq! (::std::mem::align_of::<DisplayItemClip_RoundedRect>()
                        , 4usize , concat ! (
                        "Alignment of " , stringify ! (
                        DisplayItemClip_RoundedRect ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const DisplayItemClip_RoundedRect ) ) .
                        mRect as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        DisplayItemClip_RoundedRect ) , "::" , stringify ! (
                        mRect ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const DisplayItemClip_RoundedRect ) ) .
                        mRadii as * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        DisplayItemClip_RoundedRect ) , "::" , stringify ! (
                        mRadii ) ));
        }
        impl Clone for DisplayItemClip_RoundedRect {
            fn clone(&self) -> Self { *self }
        }
        #[test]
        fn bindgen_test_layout_DisplayItemClip() {
            assert_eq!(::std::mem::size_of::<DisplayItemClip>() , 32usize ,
                       concat ! (
                       "Size of: " , stringify ! ( DisplayItemClip ) ));
            assert_eq! (::std::mem::align_of::<DisplayItemClip>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( DisplayItemClip ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const DisplayItemClip ) ) . mClipRect
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( DisplayItemClip
                        ) , "::" , stringify ! ( mClipRect ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const DisplayItemClip ) ) .
                        mRoundedClipRects as * const _ as usize } , 16usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( DisplayItemClip
                        ) , "::" , stringify ! ( mRoundedClipRects ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const DisplayItemClip ) ) .
                        mHaveClipRect as * const _ as usize } , 24usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( DisplayItemClip
                        ) , "::" , stringify ! ( mHaveClipRect ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ContainerLayerParameters {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ServoElementSnapshotTable {
            pub _base: [u64; 5usize],
        }
        #[test]
        fn bindgen_test_layout_ServoElementSnapshotTable() {
            assert_eq!(::std::mem::size_of::<ServoElementSnapshotTable>() ,
                       40usize , concat ! (
                       "Size of: " , stringify ! ( ServoElementSnapshotTable )
                       ));
            assert_eq! (::std::mem::align_of::<ServoElementSnapshotTable>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! (
                        ServoElementSnapshotTable ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct LookAndFeel {
            pub _address: u8,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LookAndFeel_ColorID {
            eColorID_WindowBackground = 0,
            eColorID_WindowForeground = 1,
            eColorID_WidgetBackground = 2,
            eColorID_WidgetForeground = 3,
            eColorID_WidgetSelectBackground = 4,
            eColorID_WidgetSelectForeground = 5,
            eColorID_Widget3DHighlight = 6,
            eColorID_Widget3DShadow = 7,
            eColorID_TextBackground = 8,
            eColorID_TextForeground = 9,
            eColorID_TextSelectBackground = 10,
            eColorID_TextSelectForeground = 11,
            eColorID_TextSelectForegroundCustom = 12,
            eColorID_TextSelectBackgroundDisabled = 13,
            eColorID_TextSelectBackgroundAttention = 14,
            eColorID_TextHighlightBackground = 15,
            eColorID_TextHighlightForeground = 16,
            eColorID_IMERawInputBackground = 17,
            eColorID_IMERawInputForeground = 18,
            eColorID_IMERawInputUnderline = 19,
            eColorID_IMESelectedRawTextBackground = 20,
            eColorID_IMESelectedRawTextForeground = 21,
            eColorID_IMESelectedRawTextUnderline = 22,
            eColorID_IMEConvertedTextBackground = 23,
            eColorID_IMEConvertedTextForeground = 24,
            eColorID_IMEConvertedTextUnderline = 25,
            eColorID_IMESelectedConvertedTextBackground = 26,
            eColorID_IMESelectedConvertedTextForeground = 27,
            eColorID_IMESelectedConvertedTextUnderline = 28,
            eColorID_SpellCheckerUnderline = 29,
            eColorID_activeborder = 30,
            eColorID_activecaption = 31,
            eColorID_appworkspace = 32,
            eColorID_background = 33,
            eColorID_buttonface = 34,
            eColorID_buttonhighlight = 35,
            eColorID_buttonshadow = 36,
            eColorID_buttontext = 37,
            eColorID_captiontext = 38,
            eColorID_graytext = 39,
            eColorID_highlight = 40,
            eColorID_highlighttext = 41,
            eColorID_inactiveborder = 42,
            eColorID_inactivecaption = 43,
            eColorID_inactivecaptiontext = 44,
            eColorID_infobackground = 45,
            eColorID_infotext = 46,
            eColorID_menu = 47,
            eColorID_menutext = 48,
            eColorID_scrollbar = 49,
            eColorID_threeddarkshadow = 50,
            eColorID_threedface = 51,
            eColorID_threedhighlight = 52,
            eColorID_threedlightshadow = 53,
            eColorID_threedshadow = 54,
            eColorID_window = 55,
            eColorID_windowframe = 56,
            eColorID_windowtext = 57,
            eColorID__moz_buttondefault = 58,
            eColorID__moz_field = 59,
            eColorID__moz_fieldtext = 60,
            eColorID__moz_dialog = 61,
            eColorID__moz_dialogtext = 62,
            eColorID__moz_dragtargetzone = 63,
            eColorID__moz_cellhighlight = 64,
            eColorID__moz_cellhighlighttext = 65,
            eColorID__moz_html_cellhighlight = 66,
            eColorID__moz_html_cellhighlighttext = 67,
            eColorID__moz_buttonhoverface = 68,
            eColorID__moz_buttonhovertext = 69,
            eColorID__moz_menuhover = 70,
            eColorID__moz_menuhovertext = 71,
            eColorID__moz_menubartext = 72,
            eColorID__moz_menubarhovertext = 73,
            eColorID__moz_eventreerow = 74,
            eColorID__moz_oddtreerow = 75,
            eColorID__moz_mac_buttonactivetext = 76,
            eColorID__moz_mac_chrome_active = 77,
            eColorID__moz_mac_chrome_inactive = 78,
            eColorID__moz_mac_defaultbuttontext = 79,
            eColorID__moz_mac_focusring = 80,
            eColorID__moz_mac_menuselect = 81,
            eColorID__moz_mac_menushadow = 82,
            eColorID__moz_mac_menutextdisable = 83,
            eColorID__moz_mac_menutextselect = 84,
            eColorID__moz_mac_disabledtoolbartext = 85,
            eColorID__moz_mac_secondaryhighlight = 86,
            eColorID__moz_win_accentcolor = 87,
            eColorID__moz_win_accentcolortext = 88,
            eColorID__moz_win_mediatext = 89,
            eColorID__moz_win_communicationstext = 90,
            eColorID__moz_nativehyperlinktext = 91,
            eColorID__moz_comboboxtext = 92,
            eColorID__moz_combobox = 93,
            eColorID__moz_gtk_info_bar_text = 94,
            eColorID_LAST_COLOR = 95,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LookAndFeel_IntID {
            eIntID_CaretBlinkTime = 0,
            eIntID_CaretWidth = 1,
            eIntID_ShowCaretDuringSelection = 2,
            eIntID_SelectTextfieldsOnKeyFocus = 3,
            eIntID_SubmenuDelay = 4,
            eIntID_MenusCanOverlapOSBar = 5,
            eIntID_UseOverlayScrollbars = 6,
            eIntID_AllowOverlayScrollbarsOverlap = 7,
            eIntID_ShowHideScrollbars = 8,
            eIntID_SkipNavigatingDisabledMenuItem = 9,
            eIntID_DragThresholdX = 10,
            eIntID_DragThresholdY = 11,
            eIntID_UseAccessibilityTheme = 12,
            eIntID_ScrollArrowStyle = 13,
            eIntID_ScrollSliderStyle = 14,
            eIntID_ScrollButtonLeftMouseButtonAction = 15,
            eIntID_ScrollButtonMiddleMouseButtonAction = 16,
            eIntID_ScrollButtonRightMouseButtonAction = 17,
            eIntID_TreeOpenDelay = 18,
            eIntID_TreeCloseDelay = 19,
            eIntID_TreeLazyScrollDelay = 20,
            eIntID_TreeScrollDelay = 21,
            eIntID_TreeScrollLinesMax = 22,
            eIntID_TabFocusModel = 23,
            eIntID_ChosenMenuItemsShouldBlink = 24,
            eIntID_WindowsAccentColorApplies = 25,
            eIntID_WindowsDefaultTheme = 26,
            eIntID_DWMCompositor = 27,
            eIntID_WindowsClassic = 28,
            eIntID_WindowsGlass = 29,
            eIntID_TouchEnabled = 30,
            eIntID_MacGraphiteTheme = 31,
            eIntID_MacYosemiteTheme = 32,
            eIntID_AlertNotificationOrigin = 33,
            eIntID_ScrollToClick = 34,
            eIntID_IMERawInputUnderlineStyle = 35,
            eIntID_IMESelectedRawTextUnderlineStyle = 36,
            eIntID_IMEConvertedTextUnderlineStyle = 37,
            eIntID_IMESelectedConvertedTextUnderline = 38,
            eIntID_SpellCheckerUnderlineStyle = 39,
            eIntID_MenuBarDrag = 40,
            eIntID_WindowsThemeIdentifier = 41,
            eIntID_OperatingSystemVersionIdentifier = 42,
            eIntID_ScrollbarButtonAutoRepeatBehavior = 43,
            eIntID_TooltipDelay = 44,
            eIntID_SwipeAnimationEnabled = 45,
            eIntID_ColorPickerAvailable = 46,
            eIntID_PhysicalHomeButton = 47,
            eIntID_ScrollbarDisplayOnMouseMove = 48,
            eIntID_ScrollbarFadeBeginDelay = 49,
            eIntID_ScrollbarFadeDuration = 50,
            eIntID_ContextMenuOffsetVertical = 51,
            eIntID_ContextMenuOffsetHorizontal = 52,
        }
        #[repr(u32)]
        /**
   * Windows themes we currently detect.
   */
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LookAndFeel_WindowsTheme {
            eWindowsTheme_Generic = 0,
            eWindowsTheme_Classic = 1,
            eWindowsTheme_Aero = 2,
            eWindowsTheme_LunaBlue = 3,
            eWindowsTheme_LunaOlive = 4,
            eWindowsTheme_LunaSilver = 5,
            eWindowsTheme_Royale = 6,
            eWindowsTheme_Zune = 7,
            eWindowsTheme_AeroLite = 8,
        }
        #[repr(u32)]
        /**
   * Operating system versions.
   */
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LookAndFeel_OperatingSystemVersion {
            eOperatingSystemVersion_Windows7 = 2,
            eOperatingSystemVersion_Windows8 = 3,
            eOperatingSystemVersion_Windows10 = 4,
            eOperatingSystemVersion_Unknown = 5,
        }
        pub const LookAndFeel_eScrollArrow_None:
                  root::mozilla::LookAndFeel__bindgen_ty_1 =
            LookAndFeel__bindgen_ty_1::eScrollArrow_None;
        pub const LookAndFeel_eScrollArrow_StartBackward:
                  root::mozilla::LookAndFeel__bindgen_ty_1 =
            LookAndFeel__bindgen_ty_1::eScrollArrow_StartBackward;
        pub const LookAndFeel_eScrollArrow_StartForward:
                  root::mozilla::LookAndFeel__bindgen_ty_1 =
            LookAndFeel__bindgen_ty_1::eScrollArrow_StartForward;
        pub const LookAndFeel_eScrollArrow_EndBackward:
                  root::mozilla::LookAndFeel__bindgen_ty_1 =
            LookAndFeel__bindgen_ty_1::eScrollArrow_EndBackward;
        pub const LookAndFeel_eScrollArrow_EndForward:
                  root::mozilla::LookAndFeel__bindgen_ty_1 =
            LookAndFeel__bindgen_ty_1::eScrollArrow_EndForward;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LookAndFeel__bindgen_ty_1 {
            eScrollArrow_None = 0,
            eScrollArrow_StartBackward = 4096,
            eScrollArrow_StartForward = 256,
            eScrollArrow_EndBackward = 16,
            eScrollArrow_EndForward = 1,
        }
        pub const LookAndFeel_eScrollArrowStyle_Single:
                  root::mozilla::LookAndFeel__bindgen_ty_2 =
            LookAndFeel__bindgen_ty_2::eScrollArrowStyle_Single;
        pub const LookAndFeel_eScrollArrowStyle_BothAtBottom:
                  root::mozilla::LookAndFeel__bindgen_ty_2 =
            LookAndFeel__bindgen_ty_2::eScrollArrowStyle_BothAtBottom;
        pub const LookAndFeel_eScrollArrowStyle_BothAtEachEnd:
                  root::mozilla::LookAndFeel__bindgen_ty_2 =
            LookAndFeel__bindgen_ty_2::eScrollArrowStyle_BothAtEachEnd;
        pub const LookAndFeel_eScrollArrowStyle_BothAtTop:
                  root::mozilla::LookAndFeel__bindgen_ty_2 =
            LookAndFeel__bindgen_ty_2::eScrollArrowStyle_BothAtTop;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LookAndFeel__bindgen_ty_2 {
            eScrollArrowStyle_Single = 4097,
            eScrollArrowStyle_BothAtBottom = 17,
            eScrollArrowStyle_BothAtEachEnd = 4369,
            eScrollArrowStyle_BothAtTop = 4352,
        }
        pub const LookAndFeel_eScrollThumbStyle_Normal:
                  root::mozilla::LookAndFeel__bindgen_ty_3 =
            LookAndFeel__bindgen_ty_3::eScrollThumbStyle_Normal;
        pub const LookAndFeel_eScrollThumbStyle_Proportional:
                  root::mozilla::LookAndFeel__bindgen_ty_3 =
            LookAndFeel__bindgen_ty_3::eScrollThumbStyle_Proportional;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LookAndFeel__bindgen_ty_3 {
            eScrollThumbStyle_Normal = 0,
            eScrollThumbStyle_Proportional = 1,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LookAndFeel_FloatID {
            eFloatID_IMEUnderlineRelativeSize = 0,
            eFloatID_SpellCheckerUnderlineRelativeSize = 1,
            eFloatID_CaretAspectRatio = 2,
        }
        pub const LookAndFeel_FontID_FontID_MINIMUM:
                  root::mozilla::LookAndFeel_FontID =
            LookAndFeel_FontID::eFont_Caption;
        pub const LookAndFeel_FontID_FontID_MAXIMUM:
                  root::mozilla::LookAndFeel_FontID =
            LookAndFeel_FontID::eFont_Widget;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LookAndFeel_FontID {
            eFont_Caption = 1,
            eFont_Icon = 2,
            eFont_Menu = 3,
            eFont_MessageBox = 4,
            eFont_SmallCaption = 5,
            eFont_StatusBar = 6,
            eFont_Window = 7,
            eFont_Document = 8,
            eFont_Workspace = 9,
            eFont_Desktop = 10,
            eFont_Info = 11,
            eFont_Dialog = 12,
            eFont_Button = 13,
            eFont_PullDownMenu = 14,
            eFont_List = 15,
            eFont_Field = 16,
            eFont_Tooltips = 17,
            eFont_Widget = 18,
        }
        #[test]
        fn bindgen_test_layout_LookAndFeel() {
            assert_eq!(::std::mem::size_of::<LookAndFeel>() , 1usize , concat
                       ! ( "Size of: " , stringify ! ( LookAndFeel ) ));
            assert_eq! (::std::mem::align_of::<LookAndFeel>() , 1usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( LookAndFeel ) ));
        }
        impl Clone for LookAndFeel {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct PseudoElementHashEntry {
            pub _base: root::PLDHashEntryHdr,
            pub mElement: root::RefPtr<root::mozilla::dom::Element>,
            pub mPseudoType: root::mozilla::CSSPseudoElementType,
        }
        pub type PseudoElementHashEntry_KeyType =
            root::mozilla::NonOwningAnimationTarget;
        pub type PseudoElementHashEntry_KeyTypePointer =
            *const root::mozilla::NonOwningAnimationTarget;
        pub const PseudoElementHashEntry_ALLOW_MEMMOVE:
                  root::mozilla::PseudoElementHashEntry__bindgen_ty_1 =
            PseudoElementHashEntry__bindgen_ty_1::ALLOW_MEMMOVE;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum PseudoElementHashEntry__bindgen_ty_1 { ALLOW_MEMMOVE = 1, }
        #[test]
        fn bindgen_test_layout_PseudoElementHashEntry() {
            assert_eq!(::std::mem::size_of::<PseudoElementHashEntry>() ,
                       24usize , concat ! (
                       "Size of: " , stringify ! ( PseudoElementHashEntry )
                       ));
            assert_eq! (::std::mem::align_of::<PseudoElementHashEntry>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! ( PseudoElementHashEntry
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PseudoElementHashEntry ) ) .
                        mElement as * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        PseudoElementHashEntry ) , "::" , stringify ! (
                        mElement ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PseudoElementHashEntry ) ) .
                        mPseudoType as * const _ as usize } , 16usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        PseudoElementHashEntry ) , "::" , stringify ! (
                        mPseudoType ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RestyleTracker {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AnimationPerformanceWarning {
            _unused: [u8; 0],
        }
        pub type CSSPseudoClassTypeBase = u8;
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum CSSPseudoClassType {
            empty = 0,
            mozOnlyWhitespace = 1,
            mozEmptyExceptChildrenWithLocalname = 2,
            lang = 3,
            root = 4,
            any = 5,
            firstChild = 6,
            firstNode = 7,
            lastChild = 8,
            lastNode = 9,
            onlyChild = 10,
            firstOfType = 11,
            lastOfType = 12,
            onlyOfType = 13,
            nthChild = 14,
            nthLastChild = 15,
            nthOfType = 16,
            nthLastOfType = 17,
            mozIsHTML = 18,
            unresolved = 19,
            mozNativeAnonymous = 20,
            mozUseShadowTreeRoot = 21,
            mozSystemMetric = 22,
            mozLocaleDir = 23,
            mozLWTheme = 24,
            mozLWThemeBrightText = 25,
            mozLWThemeDarkText = 26,
            mozWindowInactive = 27,
            mozTableBorderNonzero = 28,
            mozBrowserFrame = 29,
            scope = 30,
            negation = 31,
            dir = 32,
            link = 33,
            mozAnyLink = 34,
            anyLink = 35,
            visited = 36,
            active = 37,
            checked = 38,
            disabled = 39,
            enabled = 40,
            focus = 41,
            focusWithin = 42,
            hover = 43,
            mozDragOver = 44,
            target = 45,
            indeterminate = 46,
            mozDevtoolsHighlighted = 47,
            mozStyleeditorTransitioning = 48,
            fullscreen = 49,
            mozFullScreen = 50,
            mozFocusRing = 51,
            mozBroken = 52,
            mozLoading = 53,
            mozUserDisabled = 54,
            mozSuppressed = 55,
            mozHandlerClickToPlay = 56,
            mozHandlerVulnerableUpdatable = 57,
            mozHandlerVulnerableNoUpdate = 58,
            mozHandlerDisabled = 59,
            mozHandlerBlocked = 60,
            mozHandlerCrashed = 61,
            mozMathIncrementScriptLevel = 62,
            mozHasDirAttr = 63,
            mozDirAttrLTR = 64,
            mozDirAttrRTL = 65,
            mozDirAttrLikeAuto = 66,
            mozAutofill = 67,
            mozAutofillPreview = 68,
            required = 69,
            optional = 70,
            valid = 71,
            invalid = 72,
            inRange = 73,
            outOfRange = 74,
            defaultPseudo = 75,
            placeholderShown = 76,
            mozReadOnly = 77,
            mozReadWrite = 78,
            mozSubmitInvalid = 79,
            mozUIInvalid = 80,
            mozUIValid = 81,
            mozMeterOptimum = 82,
            mozMeterSubOptimum = 83,
            mozMeterSubSubOptimum = 84,
            mozPlaceholder = 85,
            Count = 86,
            NotPseudo = 87,
            MAX = 88,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct CSSFontFaceDescriptors {
            pub mFamily: root::nsCSSValue,
            pub mStyle: root::nsCSSValue,
            pub mWeight: root::nsCSSValue,
            pub mStretch: root::nsCSSValue,
            pub mSrc: root::nsCSSValue,
            pub mUnicodeRange: root::nsCSSValue,
            pub mFontFeatureSettings: root::nsCSSValue,
            pub mFontLanguageOverride: root::nsCSSValue,
            pub mDisplay: root::nsCSSValue,
        }
        extern "C" {
            #[link_name = "_ZN7mozilla22CSSFontFaceDescriptors6FieldsE"]
            pub static mut CSSFontFaceDescriptors_Fields:
                       [*const root::nsCSSValue; 0usize];
        }
        #[test]
        fn bindgen_test_layout_CSSFontFaceDescriptors() {
            assert_eq!(::std::mem::size_of::<CSSFontFaceDescriptors>() ,
                       144usize , concat ! (
                       "Size of: " , stringify ! ( CSSFontFaceDescriptors )
                       ));
            assert_eq! (::std::mem::align_of::<CSSFontFaceDescriptors>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! ( CSSFontFaceDescriptors
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSFontFaceDescriptors ) ) .
                        mFamily as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        CSSFontFaceDescriptors ) , "::" , stringify ! (
                        mFamily ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSFontFaceDescriptors ) ) .
                        mStyle as * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        CSSFontFaceDescriptors ) , "::" , stringify ! ( mStyle
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSFontFaceDescriptors ) ) .
                        mWeight as * const _ as usize } , 32usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        CSSFontFaceDescriptors ) , "::" , stringify ! (
                        mWeight ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSFontFaceDescriptors ) ) .
                        mStretch as * const _ as usize } , 48usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        CSSFontFaceDescriptors ) , "::" , stringify ! (
                        mStretch ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSFontFaceDescriptors ) ) . mSrc
                        as * const _ as usize } , 64usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        CSSFontFaceDescriptors ) , "::" , stringify ! ( mSrc )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSFontFaceDescriptors ) ) .
                        mUnicodeRange as * const _ as usize } , 80usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        CSSFontFaceDescriptors ) , "::" , stringify ! (
                        mUnicodeRange ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSFontFaceDescriptors ) ) .
                        mFontFeatureSettings as * const _ as usize } , 96usize
                        , concat ! (
                        "Alignment of field: " , stringify ! (
                        CSSFontFaceDescriptors ) , "::" , stringify ! (
                        mFontFeatureSettings ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSFontFaceDescriptors ) ) .
                        mFontLanguageOverride as * const _ as usize } ,
                        112usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        CSSFontFaceDescriptors ) , "::" , stringify ! (
                        mFontLanguageOverride ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSFontFaceDescriptors ) ) .
                        mDisplay as * const _ as usize } , 128usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        CSSFontFaceDescriptors ) , "::" , stringify ! (
                        mDisplay ) ));
        }
        /**
 * <div rustbindgen="true" replaces="mozilla::UniquePtr">
 *
 * TODO(Emilio): This is a workaround and we should be able to get rid of this
 * one.
 */
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct UniquePtr<T> {
            pub mPtr: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
    }
    pub type va_list = root::__builtin_va_list;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct InfallibleAllocPolicy {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_InfallibleAllocPolicy() {
        assert_eq!(::std::mem::size_of::<InfallibleAllocPolicy>() , 1usize ,
                   concat ! (
                   "Size of: " , stringify ! ( InfallibleAllocPolicy ) ));
        assert_eq! (::std::mem::align_of::<InfallibleAllocPolicy>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( InfallibleAllocPolicy )
                    ));
    }
    impl Clone for InfallibleAllocPolicy {
        fn clone(&self) -> Self { *self }
    }
    /**
 * MozRefCountType is Mozilla's reference count type.
 *
 * We use the same type to represent the refcount of RefCounted objects
 * as well, in order to be able to use the leak detection facilities
 * that are implemented by XPCOM.
 *
 * Note that this type is not in the mozilla namespace so that it is
 * usable for both C and C++ code.
 */
    pub type MozRefCountType = usize;
    pub type MozExternalRefCountType = u32;
    pub const nsresult_NS_ERROR_NO_INTERFACE: root::nsresult =
        nsresult::NS_NOINTERFACE;
    pub const nsresult_NS_ERROR_INVALID_ARG: root::nsresult =
        nsresult::NS_ERROR_ILLEGAL_VALUE;
    pub const nsresult_NS_ERROR_INVALID_POINTER: root::nsresult =
        nsresult::NS_ERROR_ILLEGAL_VALUE;
    pub const nsresult_NS_ERROR_NULL_POINTER: root::nsresult =
        nsresult::NS_ERROR_ILLEGAL_VALUE;
    pub const nsresult_NS_BINDING_SUCCEEDED: root::nsresult = nsresult::NS_OK;
    pub const nsresult_NS_NET_STATUS_RESOLVING_HOST: root::nsresult =
        nsresult::NS_BINDING_REDIRECTED;
    pub const nsresult_NS_NET_STATUS_RESOLVED_HOST: root::nsresult =
        nsresult::NS_ERROR_ALREADY_CONNECTED;
    pub const nsresult_NS_NET_STATUS_CONNECTED_TO: root::nsresult =
        nsresult::NS_BINDING_RETARGETED;
    pub const nsresult_NS_NET_STATUS_TLS_HANDSHAKE_STARTING: root::nsresult =
        nsresult::NS_ERROR_NOT_CONNECTED;
    pub const nsresult_NS_NET_STATUS_TLS_HANDSHAKE_ENDED: root::nsresult =
        nsresult::NS_ERROR_CONNECTION_REFUSED;
    pub const nsresult_NS_NET_STATUS_WAITING_FOR: root::nsresult =
        nsresult::NS_ERROR_MALFORMED_URI;
    pub const nsresult_NS_STATE_PROPERTY_EXISTS: root::nsresult =
        nsresult::NS_OK;
    pub const nsresult_NS_ERROR_HTMLPARSER_CONTINUE: root::nsresult =
        nsresult::NS_OK;
    pub const nsresult_NS_RDF_ASSERTION_ACCEPTED: root::nsresult =
        nsresult::NS_OK;
    pub const nsresult_NS_EXACT_LENGTH: root::nsresult =
        nsresult::NS_OK_UDEC_EXACTLENGTH;
    pub const nsresult_NS_PARTIAL_MORE_INPUT: root::nsresult =
        nsresult::NS_OK_UDEC_MOREINPUT;
    pub const nsresult_NS_PARTIAL_MORE_OUTPUT: root::nsresult =
        nsresult::NS_OK_UDEC_MOREOUTPUT;
    pub const nsresult_NS_ERROR_ILLEGAL_INPUT: root::nsresult =
        nsresult::NS_ERROR_UDEC_ILLEGALINPUT;
    pub const nsresult_NS_ERROR_XPATH_INVALID_ARG: root::nsresult =
        nsresult::NS_ERROR_ILLEGAL_VALUE;
    pub const nsresult_NS_SUCCESS_RESTART_APP: root::nsresult =
        nsresult::NS_SUCCESS_DONT_FIXUP;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsresult {
        NS_OK = 0,
        NS_ERROR_BASE = 3253927936,
        NS_ERROR_NOT_INITIALIZED = 3253927937,
        NS_ERROR_ALREADY_INITIALIZED = 3253927938,
        NS_ERROR_NOT_IMPLEMENTED = 2147500033,
        NS_NOINTERFACE = 2147500034,
        NS_ERROR_ABORT = 2147500036,
        NS_ERROR_FAILURE = 2147500037,
        NS_ERROR_UNEXPECTED = 2147549183,
        NS_ERROR_OUT_OF_MEMORY = 2147942414,
        NS_ERROR_ILLEGAL_VALUE = 2147942487,
        NS_ERROR_NO_AGGREGATION = 2147746064,
        NS_ERROR_NOT_AVAILABLE = 2147746065,
        NS_ERROR_FACTORY_NOT_REGISTERED = 2147746132,
        NS_ERROR_FACTORY_REGISTER_AGAIN = 2147746133,
        NS_ERROR_FACTORY_NOT_LOADED = 2147746296,
        NS_ERROR_FACTORY_NO_SIGNATURE_SUPPORT = 3253928193,
        NS_ERROR_FACTORY_EXISTS = 3253928192,
        NS_ERROR_CANNOT_CONVERT_DATA = 2152071169,
        NS_ERROR_OBJECT_IS_IMMUTABLE = 2152071170,
        NS_ERROR_LOSS_OF_SIGNIFICANT_DATA = 2152071171,
        NS_ERROR_NOT_SAME_THREAD = 2152071172,
        NS_ERROR_ILLEGAL_DURING_SHUTDOWN = 2152071198,
        NS_ERROR_SERVICE_NOT_AVAILABLE = 2152071190,
        NS_SUCCESS_LOSS_OF_INSIGNIFICANT_DATA = 4587521,
        NS_SUCCESS_INTERRUPTED_TRAVERSE = 4587522,
        NS_ERROR_SERVICE_NOT_FOUND = 4587542,
        NS_ERROR_SERVICE_IN_USE = 4587543,
        NS_BASE_STREAM_CLOSED = 2152136706,
        NS_BASE_STREAM_OSERROR = 2152136707,
        NS_BASE_STREAM_ILLEGAL_ARGS = 2152136708,
        NS_BASE_STREAM_NO_CONVERTER = 2152136709,
        NS_BASE_STREAM_BAD_CONVERSION = 2152136710,
        NS_BASE_STREAM_WOULD_BLOCK = 2152136711,
        NS_ERROR_GFX_PRINTER_NO_PRINTER_AVAILABLE = 2152202241,
        NS_ERROR_GFX_PRINTER_NAME_NOT_FOUND = 2152202242,
        NS_ERROR_GFX_PRINTER_COULD_NOT_OPEN_FILE = 2152202243,
        NS_ERROR_GFX_PRINTER_STARTDOC = 2152202244,
        NS_ERROR_GFX_PRINTER_ENDDOC = 2152202245,
        NS_ERROR_GFX_PRINTER_STARTPAGE = 2152202246,
        NS_ERROR_GFX_PRINTER_DOC_IS_BUSY = 2152202247,
        NS_ERROR_GFX_CMAP_MALFORMED = 2152202291,
        NS_SUCCESS_EVENT_CONSUMED = 4784129,
        NS_SUCCESS_EVENT_HANDLED_ASYNCHRONOUSLY = 4784130,
        NS_BINDING_FAILED = 2152398849,
        NS_BINDING_ABORTED = 2152398850,
        NS_BINDING_REDIRECTED = 2152398851,
        NS_BINDING_RETARGETED = 2152398852,
        NS_ERROR_MALFORMED_URI = 2152398858,
        NS_ERROR_IN_PROGRESS = 2152398863,
        NS_ERROR_NO_CONTENT = 2152398865,
        NS_ERROR_UNKNOWN_PROTOCOL = 2152398866,
        NS_ERROR_INVALID_CONTENT_ENCODING = 2152398875,
        NS_ERROR_CORRUPTED_CONTENT = 2152398877,
        NS_ERROR_INVALID_SIGNATURE = 2152398906,
        NS_ERROR_FIRST_HEADER_FIELD_COMPONENT_EMPTY = 2152398882,
        NS_ERROR_ALREADY_OPENED = 2152398921,
        NS_ERROR_ALREADY_CONNECTED = 2152398859,
        NS_ERROR_NOT_CONNECTED = 2152398860,
        NS_ERROR_CONNECTION_REFUSED = 2152398861,
        NS_ERROR_NET_TIMEOUT = 2152398862,
        NS_ERROR_OFFLINE = 2152398864,
        NS_ERROR_PORT_ACCESS_NOT_ALLOWED = 2152398867,
        NS_ERROR_NET_RESET = 2152398868,
        NS_ERROR_NET_INTERRUPT = 2152398919,
        NS_ERROR_PROXY_CONNECTION_REFUSED = 2152398920,
        NS_ERROR_NET_PARTIAL_TRANSFER = 2152398924,
        NS_ERROR_NET_INADEQUATE_SECURITY = 2152398930,
        NS_ERROR_NOT_RESUMABLE = 2152398873,
        NS_ERROR_REDIRECT_LOOP = 2152398879,
        NS_ERROR_ENTITY_CHANGED = 2152398880,
        NS_ERROR_UNSAFE_CONTENT_TYPE = 2152398922,
        NS_ERROR_REMOTE_XUL = 2152398923,
        NS_ERROR_LOAD_SHOWED_ERRORPAGE = 2152398925,
        NS_ERROR_DOCSHELL_DYING = 2152398926,
        NS_ERROR_FTP_LOGIN = 2152398869,
        NS_ERROR_FTP_CWD = 2152398870,
        NS_ERROR_FTP_PASV = 2152398871,
        NS_ERROR_FTP_PWD = 2152398872,
        NS_ERROR_FTP_LIST = 2152398876,
        NS_ERROR_UNKNOWN_HOST = 2152398878,
        NS_ERROR_DNS_LOOKUP_QUEUE_FULL = 2152398881,
        NS_ERROR_UNKNOWN_PROXY_HOST = 2152398890,
        NS_ERROR_UNKNOWN_SOCKET_TYPE = 2152398899,
        NS_ERROR_SOCKET_CREATE_FAILED = 2152398900,
        NS_ERROR_SOCKET_ADDRESS_NOT_SUPPORTED = 2152398901,
        NS_ERROR_SOCKET_ADDRESS_IN_USE = 2152398902,
        NS_ERROR_CACHE_KEY_NOT_FOUND = 2152398909,
        NS_ERROR_CACHE_DATA_IS_STREAM = 2152398910,
        NS_ERROR_CACHE_DATA_IS_NOT_STREAM = 2152398911,
        NS_ERROR_CACHE_WAIT_FOR_VALIDATION = 2152398912,
        NS_ERROR_CACHE_ENTRY_DOOMED = 2152398913,
        NS_ERROR_CACHE_READ_ACCESS_DENIED = 2152398914,
        NS_ERROR_CACHE_WRITE_ACCESS_DENIED = 2152398915,
        NS_ERROR_CACHE_IN_USE = 2152398916,
        NS_ERROR_DOCUMENT_NOT_CACHED = 2152398918,
        NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS = 2152398928,
        NS_ERROR_HOST_IS_IP_ADDRESS = 2152398929,
        NS_SUCCESS_ADOPTED_DATA = 4915290,
        NS_NET_STATUS_BEGIN_FTP_TRANSACTION = 4915227,
        NS_NET_STATUS_END_FTP_TRANSACTION = 4915228,
        NS_SUCCESS_AUTH_FINISHED = 4915240,
        NS_NET_STATUS_READING = 2152398856,
        NS_NET_STATUS_WRITING = 2152398857,
        NS_NET_STATUS_CONNECTING_TO = 2152398855,
        NS_NET_STATUS_SENDING_TO = 2152398853,
        NS_NET_STATUS_RECEIVING_FROM = 2152398854,
        NS_ERROR_INTERCEPTION_FAILED = 2152398948,
        NS_ERROR_HSTS_PRIMING_TIMEOUT = 2152398958,
        NS_ERROR_PLUGINS_PLUGINSNOTCHANGED = 2152465384,
        NS_ERROR_PLUGIN_DISABLED = 2152465385,
        NS_ERROR_PLUGIN_BLOCKLISTED = 2152465386,
        NS_ERROR_PLUGIN_TIME_RANGE_NOT_SUPPORTED = 2152465387,
        NS_ERROR_PLUGIN_CLICKTOPLAY = 2152465388,
        NS_PLUGIN_INIT_PENDING = 4981741,
        NS_TABLELAYOUT_CELL_NOT_FOUND = 5046272,
        NS_POSITION_BEFORE_TABLE = 5046275,
        NS_STATE_PROPERTY_NOT_THERE = 5046277,
        NS_ERROR_HTMLPARSER_EOF = 2152596456,
        NS_ERROR_HTMLPARSER_UNKNOWN = 2152596457,
        NS_ERROR_HTMLPARSER_CANTPROPAGATE = 2152596458,
        NS_ERROR_HTMLPARSER_CONTEXTMISMATCH = 2152596459,
        NS_ERROR_HTMLPARSER_BADFILENAME = 2152596460,
        NS_ERROR_HTMLPARSER_BADURL = 2152596461,
        NS_ERROR_HTMLPARSER_INVALIDPARSERCONTEXT = 2152596462,
        NS_ERROR_HTMLPARSER_INTERRUPTED = 2152596463,
        NS_ERROR_HTMLPARSER_BLOCK = 2152596464,
        NS_ERROR_HTMLPARSER_BADTOKENIZER = 2152596465,
        NS_ERROR_HTMLPARSER_BADATTRIBUTE = 2152596466,
        NS_ERROR_HTMLPARSER_UNRESOLVEDDTD = 2152596467,
        NS_ERROR_HTMLPARSER_MISPLACEDTABLECONTENT = 2152596468,
        NS_ERROR_HTMLPARSER_BADDTD = 2152596469,
        NS_ERROR_HTMLPARSER_BADCONTEXT = 2152596470,
        NS_ERROR_HTMLPARSER_STOPPARSING = 2152596471,
        NS_ERROR_HTMLPARSER_UNTERMINATEDSTRINGLITERAL = 2152596472,
        NS_ERROR_HTMLPARSER_HIERARCHYTOODEEP = 2152596473,
        NS_ERROR_HTMLPARSER_FAKE_ENDTAG = 2152596474,
        NS_ERROR_HTMLPARSER_INVALID_COMMENT = 2152596475,
        NS_HTMLTOKENS_NOT_AN_ENTITY = 5113808,
        NS_HTMLPARSER_VALID_META_CHARSET = 5114808,
        NS_RDF_CURSOR_EMPTY = 5177345,
        NS_RDF_NO_VALUE = 5177346,
        NS_RDF_ASSERTION_REJECTED = 5177347,
        NS_RDF_STOP_VISIT = 5177348,
        NS_ERROR_UCONV_NOCONV = 2152726529,
        NS_ERROR_UDEC_ILLEGALINPUT = 2152726542,
        NS_OK_HAD_REPLACEMENTS = 5242883,
        NS_SUCCESS_USING_FALLBACK_LOCALE = 5242882,
        NS_OK_UDEC_EXACTLENGTH = 5242891,
        NS_OK_UDEC_MOREINPUT = 5242892,
        NS_OK_UDEC_MOREOUTPUT = 5242893,
        NS_OK_UDEC_NOBOMFOUND = 5242894,
        NS_OK_UENC_EXACTLENGTH = 5242913,
        NS_OK_UENC_MOREOUTPUT = 5242914,
        NS_ERROR_UENC_NOMAPPING = 5242915,
        NS_OK_UENC_MOREINPUT = 5242916,
        NS_ERROR_FILE_UNRECOGNIZED_PATH = 2152857601,
        NS_ERROR_FILE_UNRESOLVABLE_SYMLINK = 2152857602,
        NS_ERROR_FILE_EXECUTION_FAILED = 2152857603,
        NS_ERROR_FILE_UNKNOWN_TYPE = 2152857604,
        NS_ERROR_FILE_DESTINATION_NOT_DIR = 2152857605,
        NS_ERROR_FILE_TARGET_DOES_NOT_EXIST = 2152857606,
        NS_ERROR_FILE_COPY_OR_MOVE_FAILED = 2152857607,
        NS_ERROR_FILE_ALREADY_EXISTS = 2152857608,
        NS_ERROR_FILE_INVALID_PATH = 2152857609,
        NS_ERROR_FILE_DISK_FULL = 2152857610,
        NS_ERROR_FILE_CORRUPTED = 2152857611,
        NS_ERROR_FILE_NOT_DIRECTORY = 2152857612,
        NS_ERROR_FILE_IS_DIRECTORY = 2152857613,
        NS_ERROR_FILE_IS_LOCKED = 2152857614,
        NS_ERROR_FILE_TOO_BIG = 2152857615,
        NS_ERROR_FILE_NO_DEVICE_SPACE = 2152857616,
        NS_ERROR_FILE_NAME_TOO_LONG = 2152857617,
        NS_ERROR_FILE_NOT_FOUND = 2152857618,
        NS_ERROR_FILE_READ_ONLY = 2152857619,
        NS_ERROR_FILE_DIR_NOT_EMPTY = 2152857620,
        NS_ERROR_FILE_ACCESS_DENIED = 2152857621,
        NS_SUCCESS_FILE_DIRECTORY_EMPTY = 5373953,
        NS_SUCCESS_AGGREGATE_RESULT = 5373954,
        NS_ERROR_DOM_INDEX_SIZE_ERR = 2152923137,
        NS_ERROR_DOM_HIERARCHY_REQUEST_ERR = 2152923139,
        NS_ERROR_DOM_WRONG_DOCUMENT_ERR = 2152923140,
        NS_ERROR_DOM_INVALID_CHARACTER_ERR = 2152923141,
        NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR = 2152923143,
        NS_ERROR_DOM_NOT_FOUND_ERR = 2152923144,
        NS_ERROR_DOM_NOT_SUPPORTED_ERR = 2152923145,
        NS_ERROR_DOM_INUSE_ATTRIBUTE_ERR = 2152923146,
        NS_ERROR_DOM_INVALID_STATE_ERR = 2152923147,
        NS_ERROR_DOM_SYNTAX_ERR = 2152923148,
        NS_ERROR_DOM_INVALID_MODIFICATION_ERR = 2152923149,
        NS_ERROR_DOM_NAMESPACE_ERR = 2152923150,
        NS_ERROR_DOM_INVALID_ACCESS_ERR = 2152923151,
        NS_ERROR_DOM_TYPE_MISMATCH_ERR = 2152923153,
        NS_ERROR_DOM_SECURITY_ERR = 2152923154,
        NS_ERROR_DOM_NETWORK_ERR = 2152923155,
        NS_ERROR_DOM_ABORT_ERR = 2152923156,
        NS_ERROR_DOM_URL_MISMATCH_ERR = 2152923157,
        NS_ERROR_DOM_QUOTA_EXCEEDED_ERR = 2152923158,
        NS_ERROR_DOM_TIMEOUT_ERR = 2152923159,
        NS_ERROR_DOM_INVALID_NODE_TYPE_ERR = 2152923160,
        NS_ERROR_DOM_DATA_CLONE_ERR = 2152923161,
        NS_ERROR_TYPE_ERR = 2152923162,
        NS_ERROR_RANGE_ERR = 2152923163,
        NS_ERROR_DOM_ENCODING_NOT_SUPPORTED_ERR = 2152923164,
        NS_ERROR_DOM_INVALID_POINTER_ERR = 2152923165,
        NS_ERROR_DOM_UNKNOWN_ERR = 2152923166,
        NS_ERROR_DOM_DATA_ERR = 2152923167,
        NS_ERROR_DOM_OPERATION_ERR = 2152923168,
        NS_ERROR_DOM_NOT_ALLOWED_ERR = 2152923169,
        NS_ERROR_DOM_SECMAN_ERR = 2152924137,
        NS_ERROR_DOM_WRONG_TYPE_ERR = 2152924138,
        NS_ERROR_DOM_NOT_OBJECT_ERR = 2152924139,
        NS_ERROR_DOM_NOT_XPC_OBJECT_ERR = 2152924140,
        NS_ERROR_DOM_NOT_NUMBER_ERR = 2152924141,
        NS_ERROR_DOM_NOT_BOOLEAN_ERR = 2152924142,
        NS_ERROR_DOM_NOT_FUNCTION_ERR = 2152924143,
        NS_ERROR_DOM_TOO_FEW_PARAMETERS_ERR = 2152924144,
        NS_ERROR_DOM_BAD_DOCUMENT_DOMAIN = 2152924145,
        NS_ERROR_DOM_PROP_ACCESS_DENIED = 2152924146,
        NS_ERROR_DOM_XPCONNECT_ACCESS_DENIED = 2152924147,
        NS_ERROR_DOM_BAD_URI = 2152924148,
        NS_ERROR_DOM_RETVAL_UNDEFINED = 2152924149,
        NS_ERROR_DOM_QUOTA_REACHED = 2152924150,
        NS_ERROR_UNCATCHABLE_EXCEPTION = 2152924151,
        NS_ERROR_DOM_MALFORMED_URI = 2152924152,
        NS_ERROR_DOM_INVALID_HEADER_NAME = 2152924153,
        NS_ERROR_DOM_INVALID_STATE_XHR_HAS_INVALID_CONTEXT = 2152924154,
        NS_ERROR_DOM_INVALID_STATE_XHR_MUST_BE_OPENED = 2152924155,
        NS_ERROR_DOM_INVALID_STATE_XHR_MUST_NOT_BE_SENDING = 2152924156,
        NS_ERROR_DOM_INVALID_STATE_XHR_MUST_NOT_BE_LOADING_OR_DONE =
            2152924157,
        NS_ERROR_DOM_INVALID_STATE_XHR_HAS_WRONG_RESPONSETYPE_FOR_RESPONSEXML
            = 2152924158,
        NS_ERROR_DOM_INVALID_STATE_XHR_HAS_WRONG_RESPONSETYPE_FOR_RESPONSETEXT
            = 2152924159,
        NS_ERROR_DOM_INVALID_STATE_XHR_CHUNKED_RESPONSETYPES_UNSUPPORTED_FOR_SYNC
            = 2152924160,
        NS_ERROR_DOM_INVALID_ACCESS_XHR_TIMEOUT_AND_RESPONSETYPE_UNSUPPORTED_FOR_SYNC
            = 2152924161,
        NS_ERROR_DOM_JS_DECODING_ERROR = 2152924162,
        NS_SUCCESS_DOM_NO_OPERATION = 5439489,
        NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW = 5439490,
        NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW_UNCATCHABLE = 5439491,
        NS_IMAGELIB_SUCCESS_LOAD_FINISHED = 5505024,
        NS_IMAGELIB_CHANGING_OWNER = 5505025,
        NS_IMAGELIB_ERROR_FAILURE = 2152988677,
        NS_IMAGELIB_ERROR_NO_DECODER = 2152988678,
        NS_IMAGELIB_ERROR_NOT_FINISHED = 2152988679,
        NS_IMAGELIB_ERROR_NO_ENCODER = 2152988681,
        NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND = 5636097,
        NS_SUCCESS_EDITOR_FOUND_TARGET = 5636098,
        NS_ERROR_XPC_NOT_ENOUGH_ARGS = 2153185281,
        NS_ERROR_XPC_NEED_OUT_OBJECT = 2153185282,
        NS_ERROR_XPC_CANT_SET_OUT_VAL = 2153185283,
        NS_ERROR_XPC_NATIVE_RETURNED_FAILURE = 2153185284,
        NS_ERROR_XPC_CANT_GET_INTERFACE_INFO = 2153185285,
        NS_ERROR_XPC_CANT_GET_PARAM_IFACE_INFO = 2153185286,
        NS_ERROR_XPC_CANT_GET_METHOD_INFO = 2153185287,
        NS_ERROR_XPC_UNEXPECTED = 2153185288,
        NS_ERROR_XPC_BAD_CONVERT_JS = 2153185289,
        NS_ERROR_XPC_BAD_CONVERT_NATIVE = 2153185290,
        NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF = 2153185291,
        NS_ERROR_XPC_BAD_OP_ON_WN_PROTO = 2153185292,
        NS_ERROR_XPC_CANT_CONVERT_WN_TO_FUN = 2153185293,
        NS_ERROR_XPC_CANT_DEFINE_PROP_ON_WN = 2153185294,
        NS_ERROR_XPC_CANT_WATCH_WN_STATIC = 2153185295,
        NS_ERROR_XPC_CANT_EXPORT_WN_STATIC = 2153185296,
        NS_ERROR_XPC_SCRIPTABLE_CALL_FAILED = 2153185297,
        NS_ERROR_XPC_SCRIPTABLE_CTOR_FAILED = 2153185298,
        NS_ERROR_XPC_CANT_CALL_WO_SCRIPTABLE = 2153185299,
        NS_ERROR_XPC_CANT_CTOR_WO_SCRIPTABLE = 2153185300,
        NS_ERROR_XPC_CI_RETURNED_FAILURE = 2153185301,
        NS_ERROR_XPC_GS_RETURNED_FAILURE = 2153185302,
        NS_ERROR_XPC_BAD_CID = 2153185303,
        NS_ERROR_XPC_BAD_IID = 2153185304,
        NS_ERROR_XPC_CANT_CREATE_WN = 2153185305,
        NS_ERROR_XPC_JS_THREW_EXCEPTION = 2153185306,
        NS_ERROR_XPC_JS_THREW_NATIVE_OBJECT = 2153185307,
        NS_ERROR_XPC_JS_THREW_JS_OBJECT = 2153185308,
        NS_ERROR_XPC_JS_THREW_NULL = 2153185309,
        NS_ERROR_XPC_JS_THREW_STRING = 2153185310,
        NS_ERROR_XPC_JS_THREW_NUMBER = 2153185311,
        NS_ERROR_XPC_JAVASCRIPT_ERROR = 2153185312,
        NS_ERROR_XPC_JAVASCRIPT_ERROR_WITH_DETAILS = 2153185313,
        NS_ERROR_XPC_CANT_CONVERT_PRIMITIVE_TO_ARRAY = 2153185314,
        NS_ERROR_XPC_CANT_CONVERT_OBJECT_TO_ARRAY = 2153185315,
        NS_ERROR_XPC_NOT_ENOUGH_ELEMENTS_IN_ARRAY = 2153185316,
        NS_ERROR_XPC_CANT_GET_ARRAY_INFO = 2153185317,
        NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING = 2153185318,
        NS_ERROR_XPC_SECURITY_MANAGER_VETO = 2153185319,
        NS_ERROR_XPC_INTERFACE_NOT_SCRIPTABLE = 2153185320,
        NS_ERROR_XPC_INTERFACE_NOT_FROM_NSISUPPORTS = 2153185321,
        NS_ERROR_XPC_CANT_GET_JSOBJECT_OF_DOM_OBJECT = 2153185322,
        NS_ERROR_XPC_CANT_SET_READ_ONLY_CONSTANT = 2153185323,
        NS_ERROR_XPC_CANT_SET_READ_ONLY_ATTRIBUTE = 2153185324,
        NS_ERROR_XPC_CANT_SET_READ_ONLY_METHOD = 2153185325,
        NS_ERROR_XPC_CANT_ADD_PROP_TO_WRAPPED_NATIVE = 2153185326,
        NS_ERROR_XPC_CALL_TO_SCRIPTABLE_FAILED = 2153185327,
        NS_ERROR_XPC_JSOBJECT_HAS_NO_FUNCTION_NAMED = 2153185328,
        NS_ERROR_XPC_BAD_ID_STRING = 2153185329,
        NS_ERROR_XPC_BAD_INITIALIZER_NAME = 2153185330,
        NS_ERROR_XPC_HAS_BEEN_SHUTDOWN = 2153185331,
        NS_ERROR_XPC_CANT_MODIFY_PROP_ON_WN = 2153185332,
        NS_ERROR_XPC_BAD_CONVERT_JS_ZERO_ISNOT_NULL = 2153185333,
        NS_ERROR_XPC_CANT_PASS_CPOW_TO_NATIVE = 2153185334,
        NS_ERROR_LAUNCHED_CHILD_PROCESS = 2153251016,
        NS_ERROR_CSP_FORM_ACTION_VIOLATION = 2153381986,
        NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION = 2153381987,
        NS_ERROR_SRI_CORRUPT = 2153382088,
        NS_ERROR_SRI_DISABLED = 2153382089,
        NS_ERROR_SRI_NOT_ELIGIBLE = 2153382090,
        NS_ERROR_SRI_UNEXPECTED_HASH_TYPE = 2153382091,
        NS_ERROR_SRI_IMPORT = 2153382092,
        NS_ERROR_CMS_VERIFY_NOT_SIGNED = 2153382912,
        NS_ERROR_CMS_VERIFY_NO_CONTENT_INFO = 2153382913,
        NS_ERROR_CMS_VERIFY_BAD_DIGEST = 2153382914,
        NS_ERROR_CMS_VERIFY_NOCERT = 2153382916,
        NS_ERROR_CMS_VERIFY_UNTRUSTED = 2153382917,
        NS_ERROR_CMS_VERIFY_ERROR_UNVERIFIED = 2153382919,
        NS_ERROR_CMS_VERIFY_ERROR_PROCESSING = 2153382920,
        NS_ERROR_CMS_VERIFY_BAD_SIGNATURE = 2153382921,
        NS_ERROR_CMS_VERIFY_DIGEST_MISMATCH = 2153382922,
        NS_ERROR_CMS_VERIFY_UNKNOWN_ALGO = 2153382923,
        NS_ERROR_CMS_VERIFY_UNSUPPORTED_ALGO = 2153382924,
        NS_ERROR_CMS_VERIFY_MALFORMED_SIGNATURE = 2153382925,
        NS_ERROR_CMS_VERIFY_HEADER_MISMATCH = 2153382926,
        NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED = 2153382927,
        NS_ERROR_CMS_VERIFY_CERT_WITHOUT_ADDRESS = 2153382928,
        NS_ERROR_CMS_ENCRYPT_NO_BULK_ALG = 2153382944,
        NS_ERROR_CMS_ENCRYPT_INCOMPLETE = 2153382945,
        NS_ERROR_DOM_INVALID_EXPRESSION_ERR = 2153447475,
        NS_ERROR_DOM_TYPE_ERR = 2153447476,
        NS_ERROR_WONT_HANDLE_CONTENT = 2153578497,
        NS_ERROR_MALWARE_URI = 2153578526,
        NS_ERROR_PHISHING_URI = 2153578527,
        NS_ERROR_TRACKING_URI = 2153578530,
        NS_ERROR_UNWANTED_URI = 2153578531,
        NS_ERROR_BLOCKED_URI = 2153578533,
        NS_ERROR_SAVE_LINK_AS_TIMEOUT = 2153578528,
        NS_ERROR_PARSED_DATA_CACHED = 2153578529,
        NS_REFRESHURI_HEADER_FOUND = 6094850,
        NS_ERROR_IMAGE_SRC_CHANGED = 2153644036,
        NS_ERROR_IMAGE_BLOCKED = 2153644037,
        NS_ERROR_CONTENT_BLOCKED = 2153644038,
        NS_ERROR_CONTENT_BLOCKED_SHOW_ALT = 2153644039,
        NS_PROPTABLE_PROP_NOT_THERE = 2153644042,
        NS_ERROR_XBL_BLOCKED = 2153644047,
        NS_ERROR_CONTENT_CRASHED = 2153644048,
        NS_HTML_STYLE_PROPERTY_NOT_THERE = 6160386,
        NS_CONTENT_BLOCKED = 6160392,
        NS_CONTENT_BLOCKED_SHOW_ALT = 6160393,
        NS_PROPTABLE_PROP_OVERWRITTEN = 6160395,
        NS_FINDBROADCASTER_NOT_FOUND = 6160396,
        NS_FINDBROADCASTER_FOUND = 6160397,
        NS_FINDBROADCASTER_AWAIT_OVERLAYS = 6160398,
        NS_ERROR_XSLT_PARSE_FAILURE = 2153775105,
        NS_ERROR_XPATH_PARSE_FAILURE = 2153775106,
        NS_ERROR_XSLT_ALREADY_SET = 2153775107,
        NS_ERROR_XSLT_EXECUTION_FAILURE = 2153775108,
        NS_ERROR_XPATH_UNKNOWN_FUNCTION = 2153775109,
        NS_ERROR_XSLT_BAD_RECURSION = 2153775110,
        NS_ERROR_XSLT_BAD_VALUE = 2153775111,
        NS_ERROR_XSLT_NODESET_EXPECTED = 2153775112,
        NS_ERROR_XSLT_ABORTED = 2153775113,
        NS_ERROR_XSLT_NETWORK_ERROR = 2153775114,
        NS_ERROR_XSLT_WRONG_MIME_TYPE = 2153775115,
        NS_ERROR_XSLT_LOAD_RECURSION = 2153775116,
        NS_ERROR_XPATH_BAD_ARGUMENT_COUNT = 2153775117,
        NS_ERROR_XPATH_BAD_EXTENSION_FUNCTION = 2153775118,
        NS_ERROR_XPATH_PAREN_EXPECTED = 2153775119,
        NS_ERROR_XPATH_INVALID_AXIS = 2153775120,
        NS_ERROR_XPATH_NO_NODE_TYPE_TEST = 2153775121,
        NS_ERROR_XPATH_BRACKET_EXPECTED = 2153775122,
        NS_ERROR_XPATH_INVALID_VAR_NAME = 2153775123,
        NS_ERROR_XPATH_UNEXPECTED_END = 2153775124,
        NS_ERROR_XPATH_OPERATOR_EXPECTED = 2153775125,
        NS_ERROR_XPATH_UNCLOSED_LITERAL = 2153775126,
        NS_ERROR_XPATH_BAD_COLON = 2153775127,
        NS_ERROR_XPATH_BAD_BANG = 2153775128,
        NS_ERROR_XPATH_ILLEGAL_CHAR = 2153775129,
        NS_ERROR_XPATH_BINARY_EXPECTED = 2153775130,
        NS_ERROR_XSLT_LOAD_BLOCKED_ERROR = 2153775131,
        NS_ERROR_XPATH_INVALID_EXPRESSION_EVALUATED = 2153775132,
        NS_ERROR_XPATH_UNBALANCED_CURLY_BRACE = 2153775133,
        NS_ERROR_XSLT_BAD_NODE_NAME = 2153775134,
        NS_ERROR_XSLT_VAR_ALREADY_SET = 2153775135,
        NS_ERROR_XSLT_CALL_TO_KEY_NOT_ALLOWED = 2153775136,
        NS_XSLT_GET_NEW_HANDLER = 6291457,
        NS_ERROR_TRANSPORT_INIT = 2153840641,
        NS_ERROR_DUPLICATE_HANDLE = 2153840642,
        NS_ERROR_BRIDGE_OPEN_PARENT = 2153840643,
        NS_ERROR_BRIDGE_OPEN_CHILD = 2153840644,
        NS_ERROR_DOM_SVG_WRONG_TYPE_ERR = 2153906176,
        NS_ERROR_DOM_SVG_MATRIX_NOT_INVERTABLE = 2153906178,
        NS_ERROR_STORAGE_BUSY = 2153971713,
        NS_ERROR_STORAGE_IOERR = 2153971714,
        NS_ERROR_STORAGE_CONSTRAINT = 2153971715,
        NS_ERROR_DOM_FILE_NOT_FOUND_ERR = 2154102784,
        NS_ERROR_DOM_FILE_NOT_READABLE_ERR = 2154102785,
        NS_ERROR_DOM_FILE_ABORT_ERR = 2154102786,
        NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR = 2154168321,
        NS_ERROR_DOM_INDEXEDDB_NOT_FOUND_ERR = 2154168323,
        NS_ERROR_DOM_INDEXEDDB_CONSTRAINT_ERR = 2154168324,
        NS_ERROR_DOM_INDEXEDDB_DATA_ERR = 2154168325,
        NS_ERROR_DOM_INDEXEDDB_NOT_ALLOWED_ERR = 2154168326,
        NS_ERROR_DOM_INDEXEDDB_TRANSACTION_INACTIVE_ERR = 2154168327,
        NS_ERROR_DOM_INDEXEDDB_ABORT_ERR = 2154168328,
        NS_ERROR_DOM_INDEXEDDB_READ_ONLY_ERR = 2154168329,
        NS_ERROR_DOM_INDEXEDDB_TIMEOUT_ERR = 2154168330,
        NS_ERROR_DOM_INDEXEDDB_QUOTA_ERR = 2154168331,
        NS_ERROR_DOM_INDEXEDDB_VERSION_ERR = 2154168332,
        NS_ERROR_DOM_INDEXEDDB_RECOVERABLE_ERR = 2154169321,
        NS_ERROR_DOM_FILEHANDLE_UNKNOWN_ERR = 2154233857,
        NS_ERROR_DOM_FILEHANDLE_NOT_ALLOWED_ERR = 2154233858,
        NS_ERROR_DOM_FILEHANDLE_INACTIVE_ERR = 2154233859,
        NS_ERROR_DOM_FILEHANDLE_ABORT_ERR = 2154233860,
        NS_ERROR_DOM_FILEHANDLE_READ_ONLY_ERR = 2154233861,
        NS_ERROR_DOM_FILEHANDLE_QUOTA_ERR = 2154233862,
        NS_ERROR_SIGNED_JAR_NOT_SIGNED = 2154299393,
        NS_ERROR_SIGNED_JAR_MODIFIED_ENTRY = 2154299394,
        NS_ERROR_SIGNED_JAR_UNSIGNED_ENTRY = 2154299395,
        NS_ERROR_SIGNED_JAR_ENTRY_MISSING = 2154299396,
        NS_ERROR_SIGNED_JAR_WRONG_SIGNATURE = 2154299397,
        NS_ERROR_SIGNED_JAR_ENTRY_TOO_LARGE = 2154299398,
        NS_ERROR_SIGNED_JAR_ENTRY_INVALID = 2154299399,
        NS_ERROR_SIGNED_JAR_MANIFEST_INVALID = 2154299400,
        NS_ERROR_DOM_FILESYSTEM_INVALID_PATH_ERR = 2154364929,
        NS_ERROR_DOM_FILESYSTEM_INVALID_MODIFICATION_ERR = 2154364930,
        NS_ERROR_DOM_FILESYSTEM_NO_MODIFICATION_ALLOWED_ERR = 2154364931,
        NS_ERROR_DOM_FILESYSTEM_PATH_EXISTS_ERR = 2154364932,
        NS_ERROR_DOM_FILESYSTEM_TYPE_MISMATCH_ERR = 2154364933,
        NS_ERROR_DOM_FILESYSTEM_UNKNOWN_ERR = 2154364934,
        NS_ERROR_SIGNED_APP_MANIFEST_INVALID = 2154496001,
        NS_ERROR_DOM_ANIM_MISSING_PROPS_ERR = 2154561537,
        NS_ERROR_DOM_PUSH_INVALID_REGISTRATION_ERR = 2154627073,
        NS_ERROR_DOM_PUSH_DENIED_ERR = 2154627074,
        NS_ERROR_DOM_PUSH_ABORT_ERR = 2154627075,
        NS_ERROR_DOM_PUSH_SERVICE_UNREACHABLE = 2154627076,
        NS_ERROR_DOM_PUSH_INVALID_KEY_ERR = 2154627077,
        NS_ERROR_DOM_PUSH_MISMATCHED_KEY_ERR = 2154627078,
        NS_ERROR_DOM_PUSH_GCM_DISABLED = 2154627079,
        NS_ERROR_DOM_MEDIA_ABORT_ERR = 2154692609,
        NS_ERROR_DOM_MEDIA_NOT_ALLOWED_ERR = 2154692610,
        NS_ERROR_DOM_MEDIA_NOT_SUPPORTED_ERR = 2154692611,
        NS_ERROR_DOM_MEDIA_DECODE_ERR = 2154692612,
        NS_ERROR_DOM_MEDIA_FATAL_ERR = 2154692613,
        NS_ERROR_DOM_MEDIA_METADATA_ERR = 2154692614,
        NS_ERROR_DOM_MEDIA_OVERFLOW_ERR = 2154692615,
        NS_ERROR_DOM_MEDIA_END_OF_STREAM = 2154692616,
        NS_ERROR_DOM_MEDIA_WAITING_FOR_DATA = 2154692617,
        NS_ERROR_DOM_MEDIA_CANCELED = 2154692618,
        NS_ERROR_DOM_MEDIA_MEDIASINK_ERR = 2154692619,
        NS_ERROR_DOM_MEDIA_DEMUXER_ERR = 2154692620,
        NS_ERROR_DOM_MEDIA_CDM_ERR = 2154692621,
        NS_ERROR_DOM_MEDIA_NEED_NEW_DECODER = 2154692622,
        NS_ERROR_DOM_MEDIA_INITIALIZING_DECODER = 2154692623,
        NS_ERROR_DOM_MEDIA_CUBEB_INITIALIZATION_ERR = 2154692709,
        NS_ERROR_UC_UPDATE_UNKNOWN = 2154758145,
        NS_ERROR_UC_UPDATE_DUPLICATE_PREFIX = 2154758146,
        NS_ERROR_UC_UPDATE_INFINITE_LOOP = 2154758147,
        NS_ERROR_UC_UPDATE_WRONG_REMOVAL_INDICES = 2154758148,
        NS_ERROR_UC_UPDATE_CHECKSUM_MISMATCH = 2154758149,
        NS_ERROR_UC_UPDATE_MISSING_CHECKSUM = 2154758150,
        NS_ERROR_UC_UPDATE_SHUTDOWNING = 2154758151,
        NS_ERROR_UC_UPDATE_TABLE_NOT_FOUND = 2154758152,
        NS_ERROR_UC_UPDATE_BUILD_PREFIX_FAILURE = 2154758153,
        NS_ERROR_UC_UPDATE_FAIL_TO_WRITE_DISK = 2154758154,
        NS_ERROR_UC_UPDATE_PROTOCOL_PARSER_ERROR = 2154758155,
        NS_ERROR_INTERNAL_ERRORRESULT_JS_EXCEPTION = 2154823681,
        NS_ERROR_INTERNAL_ERRORRESULT_DOMEXCEPTION = 2154823682,
        NS_ERROR_INTERNAL_ERRORRESULT_EXCEPTION_ON_JSCONTEXT = 2154823683,
        NS_ERROR_INTERNAL_ERRORRESULT_TYPEERROR = 2154823684,
        NS_ERROR_INTERNAL_ERRORRESULT_RANGEERROR = 2154823685,
        NS_ERROR_DOWNLOAD_COMPLETE = 2155347969,
        NS_ERROR_DOWNLOAD_NOT_PARTIAL = 2155347970,
        NS_ERROR_UNORM_MOREOUTPUT = 2155348001,
        NS_ERROR_DOCSHELL_REQUEST_REJECTED = 2155348969,
        NS_ERROR_DOCUMENT_IS_PRINTMODE = 2155349969,
        NS_SUCCESS_DONT_FIXUP = 7864321,
        NS_SUCCESS_RESTART_APP_NOT_SAME_PROFILE = 7864323,
        NS_SUCCESS_UNORM_NOTFOUND = 7864337,
        NS_ERROR_NOT_IN_TREE = 2155348006,
        NS_OK_NO_NAME_CLAUSE_HANDLED = 7864354,
    }
    pub type nsrefcnt = root::MozRefCountType;
    #[repr(C)]
    pub struct nsQueryFrame__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsQueryFrame {
        pub vtable_: *const nsQueryFrame__bindgen_vtable,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsQueryFrame_FrameIID {
        BRFrame_id = 0,
        DetailsFrame_id = 1,
        nsAutoRepeatBoxFrame_id = 2,
        nsBCTableCellFrame_id = 3,
        nsBackdropFrame_id = 4,
        nsBlockFrame_id = 5,
        nsBox_id = 6,
        nsBoxFrame_id = 7,
        nsBulletFrame_id = 8,
        nsButtonBoxFrame_id = 9,
        nsCanvasFrame_id = 10,
        nsColorControlFrame_id = 11,
        nsColumnSetFrame_id = 12,
        nsComboboxControlFrame_id = 13,
        nsComboboxDisplayFrame_id = 14,
        nsContinuingTextFrame_id = 15,
        nsDateTimeControlFrame_id = 16,
        nsDeckFrame_id = 17,
        nsDocElementBoxFrame_id = 18,
        nsFieldSetFrame_id = 19,
        nsFileControlFrame_id = 20,
        nsFirstLetterFrame_id = 21,
        nsFirstLineFrame_id = 22,
        nsFlexContainerFrame_id = 23,
        nsFrame_id = 24,
        nsGfxButtonControlFrame_id = 25,
        nsGfxCheckboxControlFrame_id = 26,
        nsGfxRadioControlFrame_id = 27,
        nsGridContainerFrame_id = 28,
        nsGridRowGroupFrame_id = 29,
        nsGridRowLeafFrame_id = 30,
        nsGroupBoxFrame_id = 31,
        nsHTMLButtonControlFrame_id = 32,
        nsHTMLCanvasFrame_id = 33,
        nsHTMLFramesetBlankFrame_id = 34,
        nsHTMLFramesetBorderFrame_id = 35,
        nsHTMLFramesetFrame_id = 36,
        nsHTMLScrollFrame_id = 37,
        nsImageBoxFrame_id = 38,
        nsImageControlFrame_id = 39,
        nsImageFrame_id = 40,
        nsInlineFrame_id = 41,
        nsLeafBoxFrame_id = 42,
        nsLegendFrame_id = 43,
        nsListBoxBodyFrame_id = 44,
        nsListControlFrame_id = 45,
        nsListItemFrame_id = 46,
        nsMathMLFrame_id = 47,
        nsMathMLmactionFrame_id = 48,
        nsMathMLmathBlockFrame_id = 49,
        nsMathMLmathInlineFrame_id = 50,
        nsMathMLmencloseFrame_id = 51,
        nsMathMLmfencedFrame_id = 52,
        nsMathMLmfracFrame_id = 53,
        nsMathMLmmultiscriptsFrame_id = 54,
        nsMathMLmoFrame_id = 55,
        nsMathMLmpaddedFrame_id = 56,
        nsMathMLmrootFrame_id = 57,
        nsMathMLmrowFrame_id = 58,
        nsMathMLmspaceFrame_id = 59,
        nsMathMLmsqrtFrame_id = 60,
        nsMathMLmtableFrame_id = 61,
        nsMathMLmtableWrapperFrame_id = 62,
        nsMathMLmtdFrame_id = 63,
        nsMathMLmtdInnerFrame_id = 64,
        nsMathMLmtrFrame_id = 65,
        nsMathMLmunderoverFrame_id = 66,
        nsMathMLsemanticsFrame_id = 67,
        nsMathMLTokenFrame_id = 68,
        nsMenuBarFrame_id = 69,
        nsMenuFrame_id = 70,
        nsMenuPopupFrame_id = 71,
        nsMeterFrame_id = 72,
        nsNumberControlFrame_id = 73,
        nsPluginFrame_id = 74,
        nsPageBreakFrame_id = 75,
        nsPageContentFrame_id = 76,
        nsPageFrame_id = 77,
        nsPlaceholderFrame_id = 78,
        nsPopupSetFrame_id = 79,
        nsProgressFrame_id = 80,
        nsProgressMeterFrame_id = 81,
        nsRangeFrame_id = 82,
        nsResizerFrame_id = 83,
        nsRootBoxFrame_id = 84,
        nsRubyBaseContainerFrame_id = 85,
        nsRubyBaseFrame_id = 86,
        nsRubyFrame_id = 87,
        nsRubyTextContainerFrame_id = 88,
        nsRubyTextFrame_id = 89,
        nsScrollbarButtonFrame_id = 90,
        nsScrollbarFrame_id = 91,
        nsSelectsAreaFrame_id = 92,
        nsSimplePageSequenceFrame_id = 93,
        nsSliderFrame_id = 94,
        nsSplitterFrame_id = 95,
        nsStackFrame_id = 96,
        nsSubDocumentFrame_id = 97,
        nsSVGAFrame_id = 98,
        nsSVGClipPathFrame_id = 99,
        nsSVGContainerFrame_id = 100,
        SVGFEContainerFrame_id = 101,
        SVGFEImageFrame_id = 102,
        SVGFELeafFrame_id = 103,
        SVGFEUnstyledLeafFrame_id = 104,
        nsSVGFilterFrame_id = 105,
        nsSVGForeignObjectFrame_id = 106,
        nsSVGGenericContainerFrame_id = 107,
        nsSVGGFrame_id = 108,
        nsSVGImageFrame_id = 109,
        nsSVGInnerSVGFrame_id = 110,
        nsSVGLinearGradientFrame_id = 111,
        nsSVGMarkerFrame_id = 112,
        nsSVGMarkerAnonChildFrame_id = 113,
        nsSVGMaskFrame_id = 114,
        nsSVGOuterSVGFrame_id = 115,
        nsSVGOuterSVGAnonChildFrame_id = 116,
        SVGGeometryFrame_id = 117,
        nsSVGPatternFrame_id = 118,
        nsSVGRadialGradientFrame_id = 119,
        nsSVGStopFrame_id = 120,
        nsSVGSwitchFrame_id = 121,
        nsSVGSymbolFrame_id = 122,
        SVGTextFrame_id = 123,
        nsSVGUseFrame_id = 124,
        SVGViewFrame_id = 125,
        nsTableCellFrame_id = 126,
        nsTableColFrame_id = 127,
        nsTableColGroupFrame_id = 128,
        nsTableFrame_id = 129,
        nsTableWrapperFrame_id = 130,
        nsTableRowFrame_id = 131,
        nsTableRowGroupFrame_id = 132,
        nsTextBoxFrame_id = 133,
        nsTextControlFrame_id = 134,
        nsTextFrame_id = 135,
        nsTitleBarFrame_id = 136,
        nsTreeBodyFrame_id = 137,
        nsTreeColFrame_id = 138,
        nsVideoFrame_id = 139,
        nsXULLabelFrame_id = 140,
        nsXULScrollFrame_id = 141,
        ViewportFrame_id = 142,
        nsContainerFrame_id = 143,
        nsFormControlFrame_id = 144,
        nsIFrame_id = 145,
        nsLeafFrame_id = 146,
        nsMathMLContainerFrame_id = 147,
        nsRubyContentFrame_id = 148,
        nsSplittableFrame_id = 149,
        nsSVGDisplayContainerFrame_id = 150,
        nsSVGGradientFrame_id = 151,
        nsSVGPaintServerFrame_id = 152,
        nsIAnonymousContentCreator_id = 153,
        nsIComboboxControlFrame_id = 154,
        nsIFormControlFrame_id = 155,
        nsIFrameFrame_id = 156,
        nsIListControlFrame_id = 157,
        nsIMathMLFrame_id = 158,
        nsIMenuFrame_id = 159,
        nsIObjectFrame_id = 160,
        nsIPageSequenceFrame_id = 161,
        nsIPercentBSizeObserver_id = 162,
        nsIRootBox_id = 163,
        nsIScrollableFrame_id = 164,
        nsIScrollbarMediator_id = 165,
        nsISelectControlFrame_id = 166,
        nsISVGSVGFrame_id = 167,
        nsIStatefulFrame_id = 168,
        nsITableCellLayout_id = 169,
        nsITableLayout_id = 170,
        nsITextControlFrame_id = 171,
        nsITreeBoxObject_id = 172,
        nsSVGDisplayableFrame_id = 173,
        NON_FRAME_MARKER = 174,
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsQueryFrame_ClassID {
        BRFrame_id = 0,
        DetailsFrame_id = 1,
        nsAutoRepeatBoxFrame_id = 2,
        nsBCTableCellFrame_id = 3,
        nsBackdropFrame_id = 4,
        nsBlockFrame_id = 5,
        nsBox_id = 6,
        nsBoxFrame_id = 7,
        nsBulletFrame_id = 8,
        nsButtonBoxFrame_id = 9,
        nsCanvasFrame_id = 10,
        nsColorControlFrame_id = 11,
        nsColumnSetFrame_id = 12,
        nsComboboxControlFrame_id = 13,
        nsComboboxDisplayFrame_id = 14,
        nsContinuingTextFrame_id = 15,
        nsDateTimeControlFrame_id = 16,
        nsDeckFrame_id = 17,
        nsDocElementBoxFrame_id = 18,
        nsFieldSetFrame_id = 19,
        nsFileControlFrame_id = 20,
        nsFirstLetterFrame_id = 21,
        nsFirstLineFrame_id = 22,
        nsFlexContainerFrame_id = 23,
        nsFrame_id = 24,
        nsGfxButtonControlFrame_id = 25,
        nsGfxCheckboxControlFrame_id = 26,
        nsGfxRadioControlFrame_id = 27,
        nsGridContainerFrame_id = 28,
        nsGridRowGroupFrame_id = 29,
        nsGridRowLeafFrame_id = 30,
        nsGroupBoxFrame_id = 31,
        nsHTMLButtonControlFrame_id = 32,
        nsHTMLCanvasFrame_id = 33,
        nsHTMLFramesetBlankFrame_id = 34,
        nsHTMLFramesetBorderFrame_id = 35,
        nsHTMLFramesetFrame_id = 36,
        nsHTMLScrollFrame_id = 37,
        nsImageBoxFrame_id = 38,
        nsImageControlFrame_id = 39,
        nsImageFrame_id = 40,
        nsInlineFrame_id = 41,
        nsLeafBoxFrame_id = 42,
        nsLegendFrame_id = 43,
        nsListBoxBodyFrame_id = 44,
        nsListControlFrame_id = 45,
        nsListItemFrame_id = 46,
        nsMathMLFrame_id = 47,
        nsMathMLmactionFrame_id = 48,
        nsMathMLmathBlockFrame_id = 49,
        nsMathMLmathInlineFrame_id = 50,
        nsMathMLmencloseFrame_id = 51,
        nsMathMLmfencedFrame_id = 52,
        nsMathMLmfracFrame_id = 53,
        nsMathMLmmultiscriptsFrame_id = 54,
        nsMathMLmoFrame_id = 55,
        nsMathMLmpaddedFrame_id = 56,
        nsMathMLmrootFrame_id = 57,
        nsMathMLmrowFrame_id = 58,
        nsMathMLmspaceFrame_id = 59,
        nsMathMLmsqrtFrame_id = 60,
        nsMathMLmtableFrame_id = 61,
        nsMathMLmtableWrapperFrame_id = 62,
        nsMathMLmtdFrame_id = 63,
        nsMathMLmtdInnerFrame_id = 64,
        nsMathMLmtrFrame_id = 65,
        nsMathMLmunderoverFrame_id = 66,
        nsMathMLsemanticsFrame_id = 67,
        nsMathMLTokenFrame_id = 68,
        nsMenuBarFrame_id = 69,
        nsMenuFrame_id = 70,
        nsMenuPopupFrame_id = 71,
        nsMeterFrame_id = 72,
        nsNumberControlFrame_id = 73,
        nsPluginFrame_id = 74,
        nsPageBreakFrame_id = 75,
        nsPageContentFrame_id = 76,
        nsPageFrame_id = 77,
        nsPlaceholderFrame_id = 78,
        nsPopupSetFrame_id = 79,
        nsProgressFrame_id = 80,
        nsProgressMeterFrame_id = 81,
        nsRangeFrame_id = 82,
        nsResizerFrame_id = 83,
        nsRootBoxFrame_id = 84,
        nsRubyBaseContainerFrame_id = 85,
        nsRubyBaseFrame_id = 86,
        nsRubyFrame_id = 87,
        nsRubyTextContainerFrame_id = 88,
        nsRubyTextFrame_id = 89,
        nsScrollbarButtonFrame_id = 90,
        nsScrollbarFrame_id = 91,
        nsSelectsAreaFrame_id = 92,
        nsSimplePageSequenceFrame_id = 93,
        nsSliderFrame_id = 94,
        nsSplitterFrame_id = 95,
        nsStackFrame_id = 96,
        nsSubDocumentFrame_id = 97,
        nsSVGAFrame_id = 98,
        nsSVGClipPathFrame_id = 99,
        nsSVGContainerFrame_id = 100,
        SVGFEContainerFrame_id = 101,
        SVGFEImageFrame_id = 102,
        SVGFELeafFrame_id = 103,
        SVGFEUnstyledLeafFrame_id = 104,
        nsSVGFilterFrame_id = 105,
        nsSVGForeignObjectFrame_id = 106,
        nsSVGGenericContainerFrame_id = 107,
        nsSVGGFrame_id = 108,
        nsSVGImageFrame_id = 109,
        nsSVGInnerSVGFrame_id = 110,
        nsSVGLinearGradientFrame_id = 111,
        nsSVGMarkerFrame_id = 112,
        nsSVGMarkerAnonChildFrame_id = 113,
        nsSVGMaskFrame_id = 114,
        nsSVGOuterSVGFrame_id = 115,
        nsSVGOuterSVGAnonChildFrame_id = 116,
        SVGGeometryFrame_id = 117,
        nsSVGPatternFrame_id = 118,
        nsSVGRadialGradientFrame_id = 119,
        nsSVGStopFrame_id = 120,
        nsSVGSwitchFrame_id = 121,
        nsSVGSymbolFrame_id = 122,
        SVGTextFrame_id = 123,
        nsSVGUseFrame_id = 124,
        SVGViewFrame_id = 125,
        nsTableCellFrame_id = 126,
        nsTableColFrame_id = 127,
        nsTableColGroupFrame_id = 128,
        nsTableFrame_id = 129,
        nsTableWrapperFrame_id = 130,
        nsTableRowFrame_id = 131,
        nsTableRowGroupFrame_id = 132,
        nsTextBoxFrame_id = 133,
        nsTextControlFrame_id = 134,
        nsTextFrame_id = 135,
        nsTitleBarFrame_id = 136,
        nsTreeBodyFrame_id = 137,
        nsTreeColFrame_id = 138,
        nsVideoFrame_id = 139,
        nsXULLabelFrame_id = 140,
        nsXULScrollFrame_id = 141,
        ViewportFrame_id = 142,
    }
    #[test]
    fn bindgen_test_layout_nsQueryFrame() {
        assert_eq!(::std::mem::size_of::<nsQueryFrame>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsQueryFrame ) ));
        assert_eq! (::std::mem::align_of::<nsQueryFrame>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsQueryFrame ) ));
    }
    impl Clone for nsQueryFrame {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAString {
        pub _base: root::mozilla::detail::nsStringRepr,
    }
    pub type nsAString_self_type = root::nsAString;
    extern "C" {
        #[link_name = "_ZN9nsAString12kMaxCapacityE"]
        pub static nsAString_kMaxCapacity:
                   root::mozilla::detail::nsStringRepr_size_type;
    }
    #[test]
    fn bindgen_test_layout_nsAString() {
        assert_eq!(::std::mem::size_of::<nsAString>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsAString ) ));
        assert_eq! (::std::mem::align_of::<nsAString>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsAString ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsSubstringTuple {
        pub mHead: *const root::nsSubstringTuple_self_type,
        pub mFragA: *const root::nsSubstringTuple_base_string_type,
        pub mFragB: *const root::nsSubstringTuple_base_string_type,
    }
    pub type nsSubstringTuple_char_type = u16;
    pub type nsSubstringTuple_self_type = root::nsSubstringTuple;
    pub type nsSubstringTuple_base_string_type =
        root::mozilla::detail::nsStringRepr;
    pub type nsSubstringTuple_size_type = u32;
    #[test]
    fn bindgen_test_layout_nsSubstringTuple() {
        assert_eq!(::std::mem::size_of::<nsSubstringTuple>() , 24usize ,
                   concat ! ( "Size of: " , stringify ! ( nsSubstringTuple )
                   ));
        assert_eq! (::std::mem::align_of::<nsSubstringTuple>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsSubstringTuple ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSubstringTuple ) ) . mHead as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSubstringTuple )
                    , "::" , stringify ! ( mHead ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSubstringTuple ) ) . mFragA as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSubstringTuple )
                    , "::" , stringify ! ( mFragA ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSubstringTuple ) ) . mFragB as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSubstringTuple )
                    , "::" , stringify ! ( mFragB ) ));
    }
    impl Clone for nsSubstringTuple {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    pub struct nsAutoString {
        pub _base: root::nsFixedString,
        pub mStorage: [root::mozilla::detail::nsStringRepr_char_type; 64usize],
    }
    pub type nsAutoString_self_type = root::nsAutoString;
    pub const nsAutoString_kDefaultStorageSize:
              root::nsAutoString__bindgen_ty_1 =
        nsAutoString__bindgen_ty_1::kDefaultStorageSize;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsAutoString__bindgen_ty_1 { kDefaultStorageSize = 64, }
    #[test]
    fn bindgen_test_layout_nsAutoString() {
        assert_eq!(::std::mem::size_of::<nsAutoString>() , 160usize , concat !
                   ( "Size of: " , stringify ! ( nsAutoString ) ));
        assert_eq! (::std::mem::align_of::<nsAutoString>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsAutoString ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAutoString ) ) . mStorage as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAutoString ) ,
                    "::" , stringify ! ( mStorage ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsDependentSubstring {
        pub _base: root::nsAString,
    }
    pub type nsDependentSubstring_self_type = root::nsDependentSubstring;
    #[test]
    fn bindgen_test_layout_nsDependentSubstring() {
        assert_eq!(::std::mem::size_of::<nsDependentSubstring>() , 16usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsDependentSubstring ) ));
        assert_eq! (::std::mem::align_of::<nsDependentSubstring>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsDependentSubstring ) ));
    }
    #[repr(C)]
    pub struct nsStringComparator__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStringComparator {
        pub vtable_: *const nsStringComparator__bindgen_vtable,
    }
    pub type nsStringComparator_char_type = u16;
    #[test]
    fn bindgen_test_layout_nsStringComparator() {
        assert_eq!(::std::mem::size_of::<nsStringComparator>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStringComparator )
                   ));
        assert_eq! (::std::mem::align_of::<nsStringComparator>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStringComparator ) ));
    }
    impl Clone for nsStringComparator {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsACString {
        pub _base: root::mozilla::detail::nsCStringRepr,
    }
    pub type nsACString_self_type = root::nsACString;
    extern "C" {
        #[link_name = "_ZN10nsACString12kMaxCapacityE"]
        pub static nsACString_kMaxCapacity:
                   root::mozilla::detail::nsCStringRepr_size_type;
    }
    #[test]
    fn bindgen_test_layout_nsACString() {
        assert_eq!(::std::mem::size_of::<nsACString>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsACString ) ));
        assert_eq! (::std::mem::align_of::<nsACString>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsACString ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCSubstringTuple {
        pub mHead: *const root::nsCSubstringTuple_self_type,
        pub mFragA: *const root::nsCSubstringTuple_base_string_type,
        pub mFragB: *const root::nsCSubstringTuple_base_string_type,
    }
    pub type nsCSubstringTuple_char_type = ::std::os::raw::c_char;
    pub type nsCSubstringTuple_self_type = root::nsCSubstringTuple;
    pub type nsCSubstringTuple_base_string_type =
        root::mozilla::detail::nsCStringRepr;
    pub type nsCSubstringTuple_size_type = u32;
    #[test]
    fn bindgen_test_layout_nsCSubstringTuple() {
        assert_eq!(::std::mem::size_of::<nsCSubstringTuple>() , 24usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCSubstringTuple )
                   ));
        assert_eq! (::std::mem::align_of::<nsCSubstringTuple>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSubstringTuple ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSubstringTuple ) ) . mHead as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSubstringTuple )
                    , "::" , stringify ! ( mHead ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSubstringTuple ) ) . mFragA as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSubstringTuple )
                    , "::" , stringify ! ( mFragA ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSubstringTuple ) ) . mFragB as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSubstringTuple )
                    , "::" , stringify ! ( mFragB ) ));
    }
    impl Clone for nsCSubstringTuple {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCString {
        pub _base: root::nsACString,
    }
    pub type nsCString_self_type = root::nsCString;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCString_Segment {
        pub mBegin: u32,
        pub mLength: u32,
    }
    #[test]
    fn bindgen_test_layout_nsCString_Segment() {
        assert_eq!(::std::mem::size_of::<nsCString_Segment>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCString_Segment )
                   ));
        assert_eq! (::std::mem::align_of::<nsCString_Segment>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCString_Segment ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCString_Segment ) ) . mBegin as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCString_Segment )
                    , "::" , stringify ! ( mBegin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCString_Segment ) ) . mLength as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCString_Segment )
                    , "::" , stringify ! ( mLength ) ));
    }
    impl Clone for nsCString_Segment {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsCString() {
        assert_eq!(::std::mem::size_of::<nsCString>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsCString ) ));
        assert_eq! (::std::mem::align_of::<nsCString>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsCString ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsDependentCSubstring {
        pub _base: root::nsACString,
    }
    pub type nsDependentCSubstring_self_type = root::nsDependentCSubstring;
    #[test]
    fn bindgen_test_layout_nsDependentCSubstring() {
        assert_eq!(::std::mem::size_of::<nsDependentCSubstring>() , 16usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsDependentCSubstring ) ));
        assert_eq! (::std::mem::align_of::<nsDependentCSubstring>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsDependentCSubstring )
                    ));
    }
    #[repr(C)]
    pub struct nsCStringComparator__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCStringComparator {
        pub vtable_: *const nsCStringComparator__bindgen_vtable,
    }
    pub type nsCStringComparator_char_type = ::std::os::raw::c_char;
    #[test]
    fn bindgen_test_layout_nsCStringComparator() {
        assert_eq!(::std::mem::size_of::<nsCStringComparator>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCStringComparator ) ));
        assert_eq! (::std::mem::align_of::<nsCStringComparator>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCStringComparator ) ));
    }
    impl Clone for nsCStringComparator {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    pub struct nsISupports__bindgen_vtable(::std::os::raw::c_void);
    /**
 * Basic component object model interface. Objects which implement
 * this interface support runtime interface discovery (QueryInterface)
 * and a reference counted memory model (AddRef/Release). This is
 * modelled after the win32 IUnknown API.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsISupports {
        pub vtable_: *const nsISupports__bindgen_vtable,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISupports_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsISupports() {
        assert_eq!(::std::mem::size_of::<nsISupports>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsISupports ) ));
        assert_eq! (::std::mem::align_of::<nsISupports>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsISupports ) ));
    }
    impl Clone for nsISupports {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    pub struct nsCycleCollectionParticipant__bindgen_vtable(::std::os::raw::c_void);
    /**
 * Participant implementation classes
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCycleCollectionParticipant {
        pub vtable_: *const nsCycleCollectionParticipant__bindgen_vtable,
        pub mMightSkip: bool,
        pub mTraverseShouldTrace: bool,
    }
    #[test]
    fn bindgen_test_layout_nsCycleCollectionParticipant() {
        assert_eq!(::std::mem::size_of::<nsCycleCollectionParticipant>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( nsCycleCollectionParticipant )
                   ));
        assert_eq! (::std::mem::align_of::<nsCycleCollectionParticipant>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsCycleCollectionParticipant ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCycleCollectionParticipant ) ) .
                    mMightSkip as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCycleCollectionParticipant ) , "::" , stringify ! (
                    mMightSkip ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCycleCollectionParticipant ) ) .
                    mTraverseShouldTrace as * const _ as usize } , 9usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCycleCollectionParticipant ) , "::" , stringify ! (
                    mTraverseShouldTrace ) ));
    }
    impl Clone for nsCycleCollectionParticipant {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCycleCollectingAutoRefCnt {
        pub mRefCntAndFlags: usize,
    }
    #[test]
    fn bindgen_test_layout_nsCycleCollectingAutoRefCnt() {
        assert_eq!(::std::mem::size_of::<nsCycleCollectingAutoRefCnt>() ,
                   8usize , concat ! (
                   "Size of: " , stringify ! ( nsCycleCollectingAutoRefCnt )
                   ));
        assert_eq! (::std::mem::align_of::<nsCycleCollectingAutoRefCnt>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsCycleCollectingAutoRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCycleCollectingAutoRefCnt ) ) .
                    mRefCntAndFlags as * const _ as usize } , 0usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsCycleCollectingAutoRefCnt ) , "::" , stringify ! (
                    mRefCntAndFlags ) ));
    }
    impl Clone for nsCycleCollectingAutoRefCnt {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsCharTraits {
        pub _address: u8,
    }
    /**
 * @see nsTAString
 */
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsReadingIterator<CharT> {
        pub mStart: *mut CharT,
        pub mEnd: *mut CharT,
        pub mPosition: *mut CharT,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<CharT>>,
    }
    pub type nsReadingIterator_self_type<CharT> =
        root::nsReadingIterator<CharT>;
    pub type nsReadingIterator_difference_type = isize;
    pub type nsReadingIterator_size_type = usize;
    pub type nsReadingIterator_value_type<CharT> = CharT;
    pub type nsReadingIterator_pointer<CharT> = *mut CharT;
    pub type nsReadingIterator_reference = u8;
    /**
 * @see nsTAString
 */
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsWritingIterator<CharT> {
        pub mStart: *mut CharT,
        pub mEnd: *mut CharT,
        pub mPosition: *mut CharT,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<CharT>>,
    }
    pub type nsWritingIterator_self_type<CharT> =
        root::nsWritingIterator<CharT>;
    pub type nsWritingIterator_difference_type = isize;
    pub type nsWritingIterator_size_type = usize;
    pub type nsWritingIterator_value_type<CharT> = CharT;
    pub type nsWritingIterator_pointer<CharT> = *mut CharT;
    pub type nsWritingIterator_reference = u8;
    #[repr(C)]
    pub struct nsSubstringSplitter {
        pub mStr: *const root::nsAString,
        pub mArray: u64,
        pub mArraySize: root::nsSubstringSplitter_size_type,
        pub mDelim: root::nsSubstringSplitter_char_type,
    }
    pub type nsSubstringSplitter_size_type =
        root::mozilla::detail::nsStringRepr_size_type;
    pub type nsSubstringSplitter_char_type =
        root::mozilla::detail::nsStringRepr_char_type;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsSubstringSplitter_nsTSubstringSplit_Iter {
        pub mObj: *const root::nsSubstringSplitter,
        pub mPos: root::nsSubstringSplitter_size_type,
    }
    #[test]
    fn bindgen_test_layout_nsSubstringSplitter_nsTSubstringSplit_Iter() {
        assert_eq!(::std::mem::size_of::<nsSubstringSplitter_nsTSubstringSplit_Iter>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsSubstringSplitter_nsTSubstringSplit_Iter ) ));
        assert_eq! (::std::mem::align_of::<nsSubstringSplitter_nsTSubstringSplit_Iter>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsSubstringSplitter_nsTSubstringSplit_Iter ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsSubstringSplitter_nsTSubstringSplit_Iter )
                    ) . mObj as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsSubstringSplitter_nsTSubstringSplit_Iter ) , "::" ,
                    stringify ! ( mObj ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsSubstringSplitter_nsTSubstringSplit_Iter )
                    ) . mPos as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsSubstringSplitter_nsTSubstringSplit_Iter ) , "::" ,
                    stringify ! ( mPos ) ));
    }
    impl Clone for nsSubstringSplitter_nsTSubstringSplit_Iter {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsSubstringSplitter() {
        assert_eq!(::std::mem::size_of::<nsSubstringSplitter>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsSubstringSplitter ) ));
        assert_eq! (::std::mem::align_of::<nsSubstringSplitter>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsSubstringSplitter ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSubstringSplitter ) ) . mStr as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSubstringSplitter
                    ) , "::" , stringify ! ( mStr ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSubstringSplitter ) ) . mArray as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSubstringSplitter
                    ) , "::" , stringify ! ( mArray ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSubstringSplitter ) ) . mArraySize
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSubstringSplitter
                    ) , "::" , stringify ! ( mArraySize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSubstringSplitter ) ) . mDelim as *
                    const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSubstringSplitter
                    ) , "::" , stringify ! ( mDelim ) ));
    }
    #[repr(C)]
    pub struct nsCSubstringSplitter {
        pub mStr: *const root::nsACString,
        pub mArray: u64,
        pub mArraySize: root::nsCSubstringSplitter_size_type,
        pub mDelim: root::nsCSubstringSplitter_char_type,
    }
    pub type nsCSubstringSplitter_size_type =
        root::mozilla::detail::nsCStringRepr_size_type;
    pub type nsCSubstringSplitter_char_type =
        root::mozilla::detail::nsCStringRepr_char_type;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCSubstringSplitter_nsTSubstringSplit_Iter {
        pub mObj: *const root::nsCSubstringSplitter,
        pub mPos: root::nsCSubstringSplitter_size_type,
    }
    #[test]
    fn bindgen_test_layout_nsCSubstringSplitter_nsTSubstringSplit_Iter() {
        assert_eq!(::std::mem::size_of::<nsCSubstringSplitter_nsTSubstringSplit_Iter>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsCSubstringSplitter_nsTSubstringSplit_Iter ) ));
        assert_eq! (::std::mem::align_of::<nsCSubstringSplitter_nsTSubstringSplit_Iter>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsCSubstringSplitter_nsTSubstringSplit_Iter ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsCSubstringSplitter_nsTSubstringSplit_Iter )
                    ) . mObj as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSubstringSplitter_nsTSubstringSplit_Iter ) , "::" ,
                    stringify ! ( mObj ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsCSubstringSplitter_nsTSubstringSplit_Iter )
                    ) . mPos as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSubstringSplitter_nsTSubstringSplit_Iter ) , "::" ,
                    stringify ! ( mPos ) ));
    }
    impl Clone for nsCSubstringSplitter_nsTSubstringSplit_Iter {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsCSubstringSplitter() {
        assert_eq!(::std::mem::size_of::<nsCSubstringSplitter>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSubstringSplitter ) ));
        assert_eq! (::std::mem::align_of::<nsCSubstringSplitter>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSubstringSplitter ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSubstringSplitter ) ) . mStr as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSubstringSplitter ) , "::" , stringify ! ( mStr ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSubstringSplitter ) ) . mArray as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSubstringSplitter ) , "::" , stringify ! ( mArray ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSubstringSplitter ) ) . mArraySize
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSubstringSplitter ) , "::" , stringify ! ( mArraySize )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSubstringSplitter ) ) . mDelim as
                    * const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSubstringSplitter ) , "::" , stringify ! ( mDelim ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsFixedString {
        pub _base: ::nsstring::nsStringRepr,
        pub mFixedCapacity: root::mozilla::detail::nsStringRepr_size_type,
        pub mFixedBuf: *mut root::mozilla::detail::nsStringRepr_char_type,
    }
    pub type nsFixedString_self_type = root::nsFixedString;
    pub type nsFixedString_fixed_string_type = root::nsFixedString;
    #[test]
    fn bindgen_test_layout_nsFixedString() {
        assert_eq!(::std::mem::size_of::<nsFixedString>() , 32usize , concat !
                   ( "Size of: " , stringify ! ( nsFixedString ) ));
        assert_eq! (::std::mem::align_of::<nsFixedString>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsFixedString ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFixedString ) ) . mFixedCapacity as
                    * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFixedString ) ,
                    "::" , stringify ! ( mFixedCapacity ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFixedString ) ) . mFixedBuf as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFixedString ) ,
                    "::" , stringify ! ( mFixedBuf ) ));
    }
    pub type PRUint32 = ::std::os::raw::c_uint;
    pub type PRIntn = ::std::os::raw::c_int;
    pub type PRUintn = ::std::os::raw::c_uint;
    /************************************************************************
** TYPES:       PRSize
** DESCRIPTION:
**  A type for representing the size of objects.
************************************************************************/
    pub type PRSize = usize;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLHashEntry {
        pub next: *mut root::PLHashEntry,
        pub keyHash: root::PLHashNumber,
        pub key: *const ::std::os::raw::c_void,
        pub value: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_PLHashEntry() {
        assert_eq!(::std::mem::size_of::<PLHashEntry>() , 32usize , concat ! (
                   "Size of: " , stringify ! ( PLHashEntry ) ));
        assert_eq! (::std::mem::align_of::<PLHashEntry>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( PLHashEntry ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashEntry ) ) . next as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashEntry ) ,
                    "::" , stringify ! ( next ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashEntry ) ) . keyHash as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashEntry ) ,
                    "::" , stringify ! ( keyHash ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashEntry ) ) . key as * const _ as
                    usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashEntry ) ,
                    "::" , stringify ! ( key ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashEntry ) ) . value as * const _
                    as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashEntry ) ,
                    "::" , stringify ! ( value ) ));
    }
    impl Clone for PLHashEntry {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLHashTable {
        pub buckets: *mut *mut root::PLHashEntry,
        pub nentries: root::PRUint32,
        pub shift: root::PRUint32,
        pub keyHash: root::PLHashFunction,
        pub keyCompare: root::PLHashComparator,
        pub valueCompare: root::PLHashComparator,
        pub allocOps: *const root::PLHashAllocOps,
        pub allocPriv: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_PLHashTable() {
        assert_eq!(::std::mem::size_of::<PLHashTable>() , 56usize , concat ! (
                   "Size of: " , stringify ! ( PLHashTable ) ));
        assert_eq! (::std::mem::align_of::<PLHashTable>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( PLHashTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . buckets as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( buckets ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . nentries as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( nentries ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . shift as * const _
                    as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( shift ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . keyHash as * const
                    _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( keyHash ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . keyCompare as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( keyCompare ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . valueCompare as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( valueCompare ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . allocOps as * const
                    _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( allocOps ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . allocPriv as *
                    const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( allocPriv ) ));
    }
    impl Clone for PLHashTable {
        fn clone(&self) -> Self { *self }
    }
    pub type PLHashNumber = root::PRUint32;
    pub type PLHashFunction =
        ::std::option::Option<unsafe extern "C" fn(key:
                                                       *const ::std::os::raw::c_void)
                                  -> root::PLHashNumber>;
    pub type PLHashComparator =
        ::std::option::Option<unsafe extern "C" fn(v1:
                                                       *const ::std::os::raw::c_void,
                                                   v2:
                                                       *const ::std::os::raw::c_void)
                                  -> root::PRIntn>;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLHashAllocOps {
        pub allocTable: ::std::option::Option<unsafe extern "C" fn(pool:
                                                                       *mut ::std::os::raw::c_void,
                                                                   size:
                                                                       root::PRSize)
                                                  ->
                                                      *mut ::std::os::raw::c_void>,
        pub freeTable: ::std::option::Option<unsafe extern "C" fn(pool:
                                                                      *mut ::std::os::raw::c_void,
                                                                  item:
                                                                      *mut ::std::os::raw::c_void)>,
        pub allocEntry: ::std::option::Option<unsafe extern "C" fn(pool:
                                                                       *mut ::std::os::raw::c_void,
                                                                   key:
                                                                       *const ::std::os::raw::c_void)
                                                  -> *mut root::PLHashEntry>,
        pub freeEntry: ::std::option::Option<unsafe extern "C" fn(pool:
                                                                      *mut ::std::os::raw::c_void,
                                                                  he:
                                                                      *mut root::PLHashEntry,
                                                                  flag:
                                                                      root::PRUintn)>,
    }
    #[test]
    fn bindgen_test_layout_PLHashAllocOps() {
        assert_eq!(::std::mem::size_of::<PLHashAllocOps>() , 32usize , concat
                   ! ( "Size of: " , stringify ! ( PLHashAllocOps ) ));
        assert_eq! (::std::mem::align_of::<PLHashAllocOps>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( PLHashAllocOps ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashAllocOps ) ) . allocTable as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashAllocOps ) ,
                    "::" , stringify ! ( allocTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashAllocOps ) ) . freeTable as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashAllocOps ) ,
                    "::" , stringify ! ( freeTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashAllocOps ) ) . allocEntry as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashAllocOps ) ,
                    "::" , stringify ! ( allocEntry ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashAllocOps ) ) . freeEntry as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashAllocOps ) ,
                    "::" , stringify ! ( freeEntry ) ));
    }
    impl Clone for PLHashAllocOps {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSTokenSerializationType {
        eCSSTokenSerialization_Nothing = 0,
        eCSSTokenSerialization_Whitespace = 1,
        eCSSTokenSerialization_AtKeyword_or_Hash = 2,
        eCSSTokenSerialization_Number = 3,
        eCSSTokenSerialization_Dimension = 4,
        eCSSTokenSerialization_Percentage = 5,
        eCSSTokenSerialization_URange = 6,
        eCSSTokenSerialization_URL_or_BadURL = 7,
        eCSSTokenSerialization_Function = 8,
        eCSSTokenSerialization_Ident = 9,
        eCSSTokenSerialization_CDC = 10,
        eCSSTokenSerialization_DashMatch = 11,
        eCSSTokenSerialization_ContainsMatch = 12,
        eCSSTokenSerialization_Symbol_Hash = 13,
        eCSSTokenSerialization_Symbol_At = 14,
        eCSSTokenSerialization_Symbol_Dot_or_Plus = 15,
        eCSSTokenSerialization_Symbol_Minus = 16,
        eCSSTokenSerialization_Symbol_OpenParen = 17,
        eCSSTokenSerialization_Symbol_Question = 18,
        eCSSTokenSerialization_Symbol_Assorted = 19,
        eCSSTokenSerialization_Symbol_Equals = 20,
        eCSSTokenSerialization_Symbol_Bar = 21,
        eCSSTokenSerialization_Symbol_Slash = 22,
        eCSSTokenSerialization_Symbol_Asterisk = 23,
        eCSSTokenSerialization_Other = 24,
    }
    /**
 * A "unique identifier". This is modeled after OSF DCE UUIDs.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsID {
        pub m0: u32,
        pub m1: u16,
        pub m2: u16,
        pub m3: [u8; 8usize],
    }
    #[test]
    fn bindgen_test_layout_nsID() {
        assert_eq!(::std::mem::size_of::<nsID>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsID ) ));
        assert_eq! (::std::mem::align_of::<nsID>() , 4usize , concat ! (
                    "Alignment of " , stringify ! ( nsID ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsID ) ) . m0 as * const _ as usize }
                    , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsID ) , "::" ,
                    stringify ! ( m0 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsID ) ) . m1 as * const _ as usize }
                    , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsID ) , "::" ,
                    stringify ! ( m1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsID ) ) . m2 as * const _ as usize }
                    , 6usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsID ) , "::" ,
                    stringify ! ( m2 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsID ) ) . m3 as * const _ as usize }
                    , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsID ) , "::" ,
                    stringify ! ( m3 ) ));
    }
    impl Clone for nsID {
        fn clone(&self) -> Self { *self }
    }
    pub type nsCID = root::nsID;
    /**
 * An "interface id" which can be used to uniquely identify a given
 * interface.
 */
    pub type nsIID = root::nsID;
    pub type PRTime = i64;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct PRThread {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsAutoRefCnt {
        pub mValue: root::nsrefcnt,
    }
    pub const nsAutoRefCnt_isThreadSafe: bool = false;
    #[test]
    fn bindgen_test_layout_nsAutoRefCnt() {
        assert_eq!(::std::mem::size_of::<nsAutoRefCnt>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsAutoRefCnt ) ));
        assert_eq! (::std::mem::align_of::<nsAutoRefCnt>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsAutoRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAutoRefCnt ) ) . mValue as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAutoRefCnt ) ,
                    "::" , stringify ! ( mValue ) ));
    }
    impl Clone for nsAutoRefCnt {
        fn clone(&self) -> Self { *self }
    }
    /**
 * already_AddRefed cooperates with reference counting smart pointers to enable
 * you to assign in a pointer _without_ |AddRef|ing it.  You might want to use
 * this as a return type from a function that returns an already |AddRef|ed
 * pointer.
 *
 * TODO Move already_AddRefed to namespace mozilla.  This has not yet been done
 * because of the sheer number of usages of already_AddRefed.
 *
 * When should you use already_AddRefed<>?
 * * Ensure a consumer takes ownership of a reference
 * * Pass ownership without calling AddRef/Release (sometimes required in
 *   off-main-thread code)
 * * The ref pointer type you're using doesn't support move construction
 *
 * Otherwise, use Move(RefPtr/nsCOMPtr/etc).
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct already_AddRefed<T> {
        pub mRawPtr: *mut T,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    #[repr(C)]
    pub struct nsCOMPtr_helper__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCOMPtr_helper {
        pub vtable_: *const nsCOMPtr_helper__bindgen_vtable,
    }
    #[test]
    fn bindgen_test_layout_nsCOMPtr_helper() {
        assert_eq!(::std::mem::size_of::<nsCOMPtr_helper>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsCOMPtr_helper ) ));
        assert_eq! (::std::mem::align_of::<nsCOMPtr_helper>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCOMPtr_helper ) ));
    }
    impl Clone for nsCOMPtr_helper {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct RefPtr<T> {
        pub mRawPtr: *mut T,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    pub type RefPtr_element_type<T> = T;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RefPtr_Proxy {
    }
    pub type RefPtr_Proxy_member_function = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RefPtr_ConstRemovingRefPtrTraits {
        pub _address: u8,
    }
    #[repr(C)]
    pub struct nsCycleCollectionTraversalCallback__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCycleCollectionTraversalCallback {
        pub vtable_: *const nsCycleCollectionTraversalCallback__bindgen_vtable,
        pub mFlags: u32,
    }
    pub const nsCycleCollectionTraversalCallback_WANT_DEBUG_INFO:
              root::nsCycleCollectionTraversalCallback__bindgen_ty_1 =
        nsCycleCollectionTraversalCallback__bindgen_ty_1::WANT_DEBUG_INFO;
    pub const nsCycleCollectionTraversalCallback_WANT_ALL_TRACES:
              root::nsCycleCollectionTraversalCallback__bindgen_ty_1 =
        nsCycleCollectionTraversalCallback__bindgen_ty_1::WANT_ALL_TRACES;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCycleCollectionTraversalCallback__bindgen_ty_1 {
        WANT_DEBUG_INFO = 1,
        WANT_ALL_TRACES = 2,
    }
    #[test]
    fn bindgen_test_layout_nsCycleCollectionTraversalCallback() {
        assert_eq!(::std::mem::size_of::<nsCycleCollectionTraversalCallback>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsCycleCollectionTraversalCallback ) ));
        assert_eq! (::std::mem::align_of::<nsCycleCollectionTraversalCallback>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsCycleCollectionTraversalCallback ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCycleCollectionTraversalCallback )
                    ) . mFlags as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCycleCollectionTraversalCallback ) , "::" , stringify !
                    ( mFlags ) ));
    }
    impl Clone for nsCycleCollectionTraversalCallback {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSContext {
        _unused: [u8; 0],
    }
    pub mod JS {
        #[allow(unused_imports)]
        use self::super::super::root;
        /**
 * JS::Value is the interface for a single JavaScript Engine value.  A few
 * general notes on JS::Value:
 *
 * - JS::Value has setX() and isX() members for X in
 *
 *     { Int32, Double, String, Symbol, Boolean, Undefined, Null, Object, Magic }
 *
 *   JS::Value also contains toX() for each of the non-singleton types.
 *
 * - Magic is a singleton type whose payload contains either a JSWhyMagic "reason" for
 *   the magic value or a uint32_t value. By providing JSWhyMagic values when
 *   creating and checking for magic values, it is possible to assert, at
 *   runtime, that only magic values with the expected reason flow through a
 *   particular value. For example, if cx->exception has a magic value, the
 *   reason must be JS_GENERATOR_CLOSING.
 *
 * - The JS::Value operations are preferred.  The JSVAL_* operations remain for
 *   compatibility; they may be removed at some point.  These operations mostly
 *   provide similar functionality.  But there are a few key differences.  One
 *   is that JS::Value gives null a separate type.
 *   Also, to help prevent mistakenly boxing a nullable JSObject* as an object,
 *   Value::setObject takes a JSObject&. (Conversely, Value::toObject returns a
 *   JSObject&.)  A convenience member Value::setObjectOrNull is provided.
 *
 * - JSVAL_VOID is the same as the singleton value of the Undefined type.
 *
 * - Note that JS::Value is 8 bytes on 32 and 64-bit architectures. Thus, on
 *   32-bit user code should avoid copying jsval/JS::Value as much as possible,
 *   preferring to pass by const Value&.
 */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct Value {
            pub data: root::JS::Value_layout,
        }
        pub type Value_PayloadType = u64;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct Value_layout {
            pub asBits: root::__BindgenUnionField<u64>,
            pub debugView: root::__BindgenUnionField<root::JS::Value_layout__bindgen_ty_1>,
            pub s: root::__BindgenUnionField<root::JS::Value_layout__bindgen_ty_2>,
            pub asDouble: root::__BindgenUnionField<f64>,
            pub asPtr: root::__BindgenUnionField<*mut ::std::os::raw::c_void>,
            pub asWord: root::__BindgenUnionField<usize>,
            pub asUIntPtr: root::__BindgenUnionField<usize>,
            pub bindgen_union_field: u64,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct Value_layout__bindgen_ty_1 {
            pub _bitfield_1: u64,
            pub __bindgen_align: [u64; 0usize],
        }
        #[test]
        fn bindgen_test_layout_Value_layout__bindgen_ty_1() {
            assert_eq!(::std::mem::size_of::<Value_layout__bindgen_ty_1>() ,
                       8usize , concat ! (
                       "Size of: " , stringify ! ( Value_layout__bindgen_ty_1
                       ) ));
            assert_eq! (::std::mem::align_of::<Value_layout__bindgen_ty_1>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! (
                        Value_layout__bindgen_ty_1 ) ));
        }
        impl Clone for Value_layout__bindgen_ty_1 {
            fn clone(&self) -> Self { *self }
        }
        impl Value_layout__bindgen_ty_1 {
            #[inline]
            pub fn payload47(&self) -> u64 {
                let mut unit_field_val: u64 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u64 as *mut u8,
                                                    ::std::mem::size_of::<u64>())
                };
                let mask = 140737488355327u64 as u64;
                let val = (unit_field_val & mask) >> 0usize;
                unsafe { ::std::mem::transmute(val as u64) }
            }
            #[inline]
            pub fn set_payload47(&mut self, val: u64) {
                let mask = 140737488355327u64 as u64;
                let val = val as u64 as u64;
                let mut unit_field_val: u64 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u64 as *mut u8,
                                                    ::std::mem::size_of::<u64>())
                };
                unit_field_val &= !mask;
                unit_field_val |= (val << 0usize) & mask;
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                        *const _ as *const u8,
                                                    &mut self._bitfield_1 as
                                                        *mut _ as *mut u8,
                                                    ::std::mem::size_of::<u64>());
                }
            }
            #[inline]
            pub fn tag(&self) -> root::JSValueTag {
                let mut unit_field_val: u64 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u64 as *mut u8,
                                                    ::std::mem::size_of::<u64>())
                };
                let mask = 18446603336221196288u64 as u64;
                let val = (unit_field_val & mask) >> 47usize;
                unsafe { ::std::mem::transmute(val as u32) }
            }
            #[inline]
            pub fn set_tag(&mut self, val: root::JSValueTag) {
                let mask = 18446603336221196288u64 as u64;
                let val = val as u32 as u64;
                let mut unit_field_val: u64 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u64 as *mut u8,
                                                    ::std::mem::size_of::<u64>())
                };
                unit_field_val &= !mask;
                unit_field_val |= (val << 47usize) & mask;
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                        *const _ as *const u8,
                                                    &mut self._bitfield_1 as
                                                        *mut _ as *mut u8,
                                                    ::std::mem::size_of::<u64>());
                }
            }
            #[inline]
            pub fn new_bitfield_1(payload47: u64, tag: root::JSValueTag)
             -> u64 {
                ({
                     ({ 0 } |
                          ((payload47 as u64 as u64) << 0usize) &
                              (140737488355327u64 as u64))
                 } |
                     ((tag as u32 as u64) << 47usize) &
                         (18446603336221196288u64 as u64))
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct Value_layout__bindgen_ty_2 {
            pub payload: root::JS::Value_layout__bindgen_ty_2__bindgen_ty_1,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct Value_layout__bindgen_ty_2__bindgen_ty_1 {
            pub i32: root::__BindgenUnionField<i32>,
            pub u32: root::__BindgenUnionField<u32>,
            pub why: root::__BindgenUnionField<root::JSWhyMagic>,
            pub bindgen_union_field: u32,
        }
        #[test]
        fn bindgen_test_layout_Value_layout__bindgen_ty_2__bindgen_ty_1() {
            assert_eq!(::std::mem::size_of::<Value_layout__bindgen_ty_2__bindgen_ty_1>()
                       , 4usize , concat ! (
                       "Size of: " , stringify ! (
                       Value_layout__bindgen_ty_2__bindgen_ty_1 ) ));
            assert_eq! (::std::mem::align_of::<Value_layout__bindgen_ty_2__bindgen_ty_1>()
                        , 4usize , concat ! (
                        "Alignment of " , stringify ! (
                        Value_layout__bindgen_ty_2__bindgen_ty_1 ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const Value_layout__bindgen_ty_2__bindgen_ty_1
                        ) ) . i32 as * const _ as usize } , 0usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        Value_layout__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                        stringify ! ( i32 ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const Value_layout__bindgen_ty_2__bindgen_ty_1
                        ) ) . u32 as * const _ as usize } , 0usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        Value_layout__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                        stringify ! ( u32 ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const Value_layout__bindgen_ty_2__bindgen_ty_1
                        ) ) . why as * const _ as usize } , 0usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        Value_layout__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                        stringify ! ( why ) ));
        }
        impl Clone for Value_layout__bindgen_ty_2__bindgen_ty_1 {
            fn clone(&self) -> Self { *self }
        }
        #[test]
        fn bindgen_test_layout_Value_layout__bindgen_ty_2() {
            assert_eq!(::std::mem::size_of::<Value_layout__bindgen_ty_2>() ,
                       4usize , concat ! (
                       "Size of: " , stringify ! ( Value_layout__bindgen_ty_2
                       ) ));
            assert_eq! (::std::mem::align_of::<Value_layout__bindgen_ty_2>() ,
                        4usize , concat ! (
                        "Alignment of " , stringify ! (
                        Value_layout__bindgen_ty_2 ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout__bindgen_ty_2 ) ) .
                        payload as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        Value_layout__bindgen_ty_2 ) , "::" , stringify ! (
                        payload ) ));
        }
        impl Clone for Value_layout__bindgen_ty_2 {
            fn clone(&self) -> Self { *self }
        }
        #[test]
        fn bindgen_test_layout_Value_layout() {
            assert_eq!(::std::mem::size_of::<Value_layout>() , 8usize , concat
                       ! ( "Size of: " , stringify ! ( Value_layout ) ));
            assert_eq! (::std::mem::align_of::<Value_layout>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( Value_layout ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout ) ) . asBits as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value_layout )
                        , "::" , stringify ! ( asBits ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout ) ) . debugView as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value_layout )
                        , "::" , stringify ! ( debugView ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout ) ) . s as * const _
                        as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value_layout )
                        , "::" , stringify ! ( s ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout ) ) . asDouble as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value_layout )
                        , "::" , stringify ! ( asDouble ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout ) ) . asPtr as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value_layout )
                        , "::" , stringify ! ( asPtr ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout ) ) . asWord as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value_layout )
                        , "::" , stringify ! ( asWord ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout ) ) . asUIntPtr as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value_layout )
                        , "::" , stringify ! ( asUIntPtr ) ));
        }
        impl Clone for Value_layout {
            fn clone(&self) -> Self { *self }
        }
        #[test]
        fn bindgen_test_layout_Value() {
            assert_eq!(::std::mem::size_of::<Value>() , 8usize , concat ! (
                       "Size of: " , stringify ! ( Value ) ));
            assert_eq! (::std::mem::align_of::<Value>() , 8usize , concat ! (
                        "Alignment of " , stringify ! ( Value ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value ) ) . data as * const _ as
                        usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value ) , "::"
                        , stringify ! ( data ) ));
        }
        impl Clone for Value {
            fn clone(&self) -> Self { *self }
        }
        /**
 * Reference to a T that has been rooted elsewhere. This is most useful
 * as a parameter type, which guarantees that the T lvalue is properly
 * rooted. See "Move GC Stack Rooting" above.
 *
 * If you want to add additional methods to Handle for a specific
 * specialization, define a HandleBase<T> specialization containing them.
 */
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Handle<T> {
            pub ptr: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type Handle_ElementType<T> = T;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum Handle_Disambiguator {
            DeliberatelyChoosingThisOverload = 0,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum Handle_CallerIdentity {
            ImUsingThisOnlyInFromFromMarkedLocation = 0,
        }
        /**
 * Similar to a handle, but the underlying storage can be changed. This is
 * useful for outparams.
 *
 * If you want to add additional methods to MutableHandle for a specific
 * specialization, define a MutableHandleBase<T> specialization containing
 * them.
 */
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MutableHandle<T> {
            pub ptr: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type MutableHandle_ElementType<T> = T;
        /**
 * Local variable of type T whose value is always rooted. This is typically
 * used for local variables, or for non-rooted values being passed to a
 * function that requires a handle, e.g. Foo(Root<T>(cx, x)).
 *
 * If you want to add additional methods to Rooted for a specific
 * specialization, define a RootedBase<T> specialization containing them.
 */
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Rooted {
        }
        pub type Rooted_ElementType<T> = T;
        pub type HandleId = root::JS::Handle<root::jsid>;
        pub type HandleObject = root::JS::Handle<*mut root::JSObject>;
        pub type HandleValue = root::JS::Handle<root::JS::Value>;
        pub type MutableHandleValue =
            root::JS::MutableHandle<root::JS::Value>;
        pub type RootedObject = [u64; 3usize];
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct PropertyDescriptor {
            pub obj: *mut root::JSObject,
            pub attrs: ::std::os::raw::c_uint,
            pub getter: root::JSGetterOp,
            pub setter: root::JSSetterOp,
            pub value: root::JS::Value,
        }
        #[test]
        fn bindgen_test_layout_PropertyDescriptor() {
            assert_eq!(::std::mem::size_of::<PropertyDescriptor>() , 40usize ,
                       concat ! (
                       "Size of: " , stringify ! ( PropertyDescriptor ) ));
            assert_eq! (::std::mem::align_of::<PropertyDescriptor>() , 8usize
                        , concat ! (
                        "Alignment of " , stringify ! ( PropertyDescriptor )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PropertyDescriptor ) ) . obj as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        PropertyDescriptor ) , "::" , stringify ! ( obj ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PropertyDescriptor ) ) . attrs as
                        * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        PropertyDescriptor ) , "::" , stringify ! ( attrs )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PropertyDescriptor ) ) . getter
                        as * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        PropertyDescriptor ) , "::" , stringify ! ( getter )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PropertyDescriptor ) ) . setter
                        as * const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        PropertyDescriptor ) , "::" , stringify ! ( setter )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PropertyDescriptor ) ) . value as
                        * const _ as usize } , 32usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        PropertyDescriptor ) , "::" , stringify ! ( value )
                        ));
        }
        impl Clone for PropertyDescriptor {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DeletePolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct FreePolicy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_FreePolicy() {
            assert_eq!(::std::mem::size_of::<FreePolicy>() , 1usize , concat !
                       ( "Size of: " , stringify ! ( FreePolicy ) ));
            assert_eq! (::std::mem::align_of::<FreePolicy>() , 1usize , concat
                        ! ( "Alignment of " , stringify ! ( FreePolicy ) ));
        }
        impl Clone for FreePolicy {
            fn clone(&self) -> Self { *self }
        }
        /**
 * A GC pointer, tagged with the trace kind.
 *
 * In general, a GC pointer should be stored with an exact type. This class
 * is for use when that is not possible because a single pointer must point
 * to several kinds of GC thing.
 */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct GCCellPtr {
            pub ptr: usize,
        }
        #[test]
        fn bindgen_test_layout_GCCellPtr() {
            assert_eq!(::std::mem::size_of::<GCCellPtr>() , 8usize , concat !
                       ( "Size of: " , stringify ! ( GCCellPtr ) ));
            assert_eq! (::std::mem::align_of::<GCCellPtr>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( GCCellPtr ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GCCellPtr ) ) . ptr as * const _
                        as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GCCellPtr ) ,
                        "::" , stringify ! ( ptr ) ));
        }
        impl Clone for GCCellPtr {
            fn clone(&self) -> Self { *self }
        }
        /**
 * The Heap<T> class is a heap-stored reference to a JS GC thing. All members of
 * heap classes that refer to GC things should use Heap<T> (or possibly
 * TenuredHeap<T>, described below).
 *
 * Heap<T> is an abstraction that hides some of the complexity required to
 * maintain GC invariants for the contained reference. It uses operator
 * overloading to provide a normal pointer interface, but notifies the GC every
 * time the value it contains is updated. This is necessary for generational GC,
 * which keeps track of all pointers into the nursery.
 *
 * Heap<T> instances must be traced when their containing object is traced to
 * keep the pointed-to GC thing alive.
 *
 * Heap<T> objects should only be used on the heap. GC references stored on the
 * C/C++ stack must use Rooted/Handle/MutableHandle instead.
 *
 * Type T must be a public GC pointer type.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct Heap<T> {
            pub ptr: T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type Heap_ElementType<T> = T;
        pub mod dbg {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            pub struct GarbageCollectionEvent {
                pub majorGCNumber_: u64,
                pub reason: *const ::std::os::raw::c_char,
                pub nonincrementalReason: *const ::std::os::raw::c_char,
                pub collections: [u64; 3usize],
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct GarbageCollectionEvent_Collection {
                pub startTimestamp: root::mozilla::TimeStamp,
                pub endTimestamp: root::mozilla::TimeStamp,
            }
            #[test]
            fn bindgen_test_layout_GarbageCollectionEvent_Collection() {
                assert_eq!(::std::mem::size_of::<GarbageCollectionEvent_Collection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           GarbageCollectionEvent_Collection ) ));
                assert_eq! (::std::mem::align_of::<GarbageCollectionEvent_Collection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            GarbageCollectionEvent_Collection ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const GarbageCollectionEvent_Collection
                            ) ) . startTimestamp as * const _ as usize } ,
                            0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            GarbageCollectionEvent_Collection ) , "::" ,
                            stringify ! ( startTimestamp ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const GarbageCollectionEvent_Collection
                            ) ) . endTimestamp as * const _ as usize } ,
                            8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            GarbageCollectionEvent_Collection ) , "::" ,
                            stringify ! ( endTimestamp ) ));
            }
            impl Clone for GarbageCollectionEvent_Collection {
                fn clone(&self) -> Self { *self }
            }
            pub type GarbageCollectionEvent_Ptr =
                root::mozilla::UniquePtr<root::JS::dbg::GarbageCollectionEvent>;
            #[test]
            fn bindgen_test_layout_GarbageCollectionEvent() {
                assert_eq!(::std::mem::size_of::<GarbageCollectionEvent>() ,
                           48usize , concat ! (
                           "Size of: " , stringify ! ( GarbageCollectionEvent
                           ) ));
                assert_eq! (::std::mem::align_of::<GarbageCollectionEvent>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            GarbageCollectionEvent ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GarbageCollectionEvent ) ) .
                            majorGCNumber_ as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GarbageCollectionEvent ) , "::" , stringify ! (
                            majorGCNumber_ ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GarbageCollectionEvent ) ) .
                            reason as * const _ as usize } , 8usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            GarbageCollectionEvent ) , "::" , stringify ! (
                            reason ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GarbageCollectionEvent ) ) .
                            nonincrementalReason as * const _ as usize } ,
                            16usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            GarbageCollectionEvent ) , "::" , stringify ! (
                            nonincrementalReason ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GarbageCollectionEvent ) ) .
                            collections as * const _ as usize } , 24usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GarbageCollectionEvent ) , "::" , stringify ! (
                            collections ) ));
            }
            #[repr(C)]
            pub struct AutoEntryMonitor__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct AutoEntryMonitor {
                pub vtable_: *const AutoEntryMonitor__bindgen_vtable,
                pub cx_: *mut root::JSContext,
                pub savedMonitor_: *mut root::JS::dbg::AutoEntryMonitor,
            }
            #[test]
            fn bindgen_test_layout_AutoEntryMonitor() {
                assert_eq!(::std::mem::size_of::<AutoEntryMonitor>() , 24usize
                           , concat ! (
                           "Size of: " , stringify ! ( AutoEntryMonitor ) ));
                assert_eq! (::std::mem::align_of::<AutoEntryMonitor>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! ( AutoEntryMonitor )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AutoEntryMonitor ) ) . cx_ as
                            * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            AutoEntryMonitor ) , "::" , stringify ! ( cx_ )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AutoEntryMonitor ) ) .
                            savedMonitor_ as * const _ as usize } , 16usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            AutoEntryMonitor ) , "::" , stringify ! (
                            savedMonitor_ ) ));
            }
        }
        /**
 * The TenuredHeap<T> class is similar to the Heap<T> class above in that it
 * encapsulates the GC concerns of an on-heap reference to a JS object. However,
 * it has two important differences:
 *
 *  1) Pointers which are statically known to only reference "tenured" objects
 *     can avoid the extra overhead of SpiderMonkey's write barriers.
 *
 *  2) Objects in the "tenured" heap have stronger alignment restrictions than
 *     those in the "nursery", so it is possible to store flags in the lower
 *     bits of pointers known to be tenured. TenuredHeap wraps a normal tagged
 *     pointer with a nice API for accessing the flag bits and adds various
 *     assertions to ensure that it is not mis-used.
 *
 * GC things are said to be "tenured" when they are located in the long-lived
 * heap: e.g. they have gained tenure as an object by surviving past at least
 * one GC. For performance, SpiderMonkey allocates some things which are known
 * to normally be long lived directly into the tenured generation; for example,
 * global objects. Additionally, SpiderMonkey does not visit individual objects
 * when deleting non-tenured objects, so object with finalizers are also always
 * tenured; for instance, this includes most DOM objects.
 *
 * The considerations to keep in mind when using a TenuredHeap<T> vs a normal
 * Heap<T> are:
 *
 *  - It is invalid for a TenuredHeap<T> to refer to a non-tenured thing.
 *  - It is however valid for a Heap<T> to refer to a tenured thing.
 *  - It is not possible to store flag bits in a Heap<T>.
 */
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TenuredHeap {
            pub bits: usize,
        }
        pub type TenuredHeap_ElementType<T> = T;
        pub const TenuredHeap_maskBits: root::JS::TenuredHeap__bindgen_ty_1 =
            TenuredHeap__bindgen_ty_1::maskBits;
        pub const TenuredHeap_flagsMask: root::JS::TenuredHeap__bindgen_ty_1 =
            TenuredHeap__bindgen_ty_1::maskBits;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum TenuredHeap__bindgen_ty_1 { maskBits = 0, }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ConstUTF8CharsZ {
            pub data_: *const ::std::os::raw::c_char,
        }
        pub type ConstUTF8CharsZ_CharT = ::std::os::raw::c_uchar;
        #[test]
        fn bindgen_test_layout_ConstUTF8CharsZ() {
            assert_eq!(::std::mem::size_of::<ConstUTF8CharsZ>() , 8usize ,
                       concat ! (
                       "Size of: " , stringify ! ( ConstUTF8CharsZ ) ));
            assert_eq! (::std::mem::align_of::<ConstUTF8CharsZ>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ConstUTF8CharsZ ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ConstUTF8CharsZ ) ) . data_ as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( ConstUTF8CharsZ
                        ) , "::" , stringify ! ( data_ ) ));
        }
        impl Clone for ConstUTF8CharsZ {
            fn clone(&self) -> Self { *self }
        }
        /**
 * Per ES6, the [[DefineOwnProperty]] internal method has three different
 * possible outcomes:
 *
 * -   It can throw an exception (which we indicate by returning false).
 *
 * -   It can return true, indicating unvarnished success.
 *
 * -   It can return false, indicating "strict failure". The property could
 *     not be defined. It's an error, but no exception was thrown.
 *
 * It's not just [[DefineOwnProperty]]: all the mutating internal methods have
 * the same three outcomes. (The other affected internal methods are [[Set]],
 * [[Delete]], [[SetPrototypeOf]], and [[PreventExtensions]].)
 *
 * If you think this design is awful, you're not alone.  But as it's the
 * standard, we must represent these boolean "success" values somehow.
 * ObjectOpSuccess is the class for this. It's like a bool, but when it's false
 * it also stores an error code.
 *
 * Typical usage:
 *
 *     ObjectOpResult result;
 *     if (!DefineProperty(cx, obj, id, ..., result))
 *         return false;
 *     if (!result)
 *         return result.reportError(cx, obj, id);
 *
 * Users don't have to call `result.report()`; another possible ending is:
 *
 *     argv.rval().setBoolean(bool(result));
 *     return true;
 */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ObjectOpResult {
            /**
     * code_ is either one of the special codes OkCode or Uninitialized, or
     * an error code. For now the error codes are private to the JS engine;
     * they're defined in js/src/js.msg.
     *
     * code_ is uintptr_t (rather than uint32_t) for the convenience of the
     * JITs, which would otherwise have to deal with either padding or stack
     * alignment on 64-bit platforms.
     */
            pub code_: usize,
        }
        #[repr(u64)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ObjectOpResult_SpecialCodes {
            OkCode = 0,
            Uninitialized = 18446744073709551615,
        }
        #[test]
        fn bindgen_test_layout_ObjectOpResult() {
            assert_eq!(::std::mem::size_of::<ObjectOpResult>() , 8usize ,
                       concat ! ( "Size of: " , stringify ! ( ObjectOpResult )
                       ));
            assert_eq! (::std::mem::align_of::<ObjectOpResult>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ObjectOpResult ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ObjectOpResult ) ) . code_ as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( ObjectOpResult
                        ) , "::" , stringify ! ( code_ ) ));
        }
        impl Clone for ObjectOpResult {
            fn clone(&self) -> Self { *self }
        }
        /**
 * This class can be used to store a pointer to the youngest frame of a saved
 * stack in the specified JSContext. This reference will be picked up by any new
 * calls performed until the class is destroyed, with the specified asyncCause,
 * that must not be empty.
 *
 * Any stack capture initiated during these new calls will go through the async
 * stack instead of the current stack.
 *
 * Capturing the stack before a new call is performed will not be affected.
 *
 * The provided chain of SavedFrame objects can live in any compartment,
 * although it will be copied to the compartment where the stack is captured.
 *
 * See also `js/src/doc/SavedFrame/SavedFrame.md` for documentation on async
 * stack frames.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoSetAsyncStackForNewCalls {
            pub cx: *mut root::JSContext,
            pub oldAsyncStack: root::JS::RootedObject,
            pub oldAsyncCause: *const ::std::os::raw::c_char,
            pub oldAsyncCallIsExplicit: bool,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum AutoSetAsyncStackForNewCalls_AsyncCallKind {
            IMPLICIT = 0,
            EXPLICIT = 1,
        }
        #[test]
        fn bindgen_test_layout_AutoSetAsyncStackForNewCalls() {
            assert_eq!(::std::mem::size_of::<AutoSetAsyncStackForNewCalls>() ,
                       48usize , concat ! (
                       "Size of: " , stringify ! (
                       AutoSetAsyncStackForNewCalls ) ));
            assert_eq! (::std::mem::align_of::<AutoSetAsyncStackForNewCalls>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        AutoSetAsyncStackForNewCalls ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AutoSetAsyncStackForNewCalls ) )
                        . cx as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        AutoSetAsyncStackForNewCalls ) , "::" , stringify ! (
                        cx ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AutoSetAsyncStackForNewCalls ) )
                        . oldAsyncStack as * const _ as usize } , 8usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        AutoSetAsyncStackForNewCalls ) , "::" , stringify ! (
                        oldAsyncStack ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AutoSetAsyncStackForNewCalls ) )
                        . oldAsyncCause as * const _ as usize } , 32usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        AutoSetAsyncStackForNewCalls ) , "::" , stringify ! (
                        oldAsyncCause ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AutoSetAsyncStackForNewCalls ) )
                        . oldAsyncCallIsExplicit as * const _ as usize } ,
                        40usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        AutoSetAsyncStackForNewCalls ) , "::" , stringify ! (
                        oldAsyncCallIsExplicit ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoHideScriptedCaller {
            pub mContext: *mut root::JSContext,
        }
        #[test]
        fn bindgen_test_layout_AutoHideScriptedCaller() {
            assert_eq!(::std::mem::size_of::<AutoHideScriptedCaller>() ,
                       8usize , concat ! (
                       "Size of: " , stringify ! ( AutoHideScriptedCaller )
                       ));
            assert_eq! (::std::mem::align_of::<AutoHideScriptedCaller>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! ( AutoHideScriptedCaller
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AutoHideScriptedCaller ) ) .
                        mContext as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        AutoHideScriptedCaller ) , "::" , stringify ! (
                        mContext ) ));
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSFunction {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSObject {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSScript {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSString {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct jsid {
        pub asBits: usize,
    }
    #[test]
    fn bindgen_test_layout_jsid() {
        assert_eq!(::std::mem::size_of::<jsid>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( jsid ) ));
        assert_eq! (::std::mem::align_of::<jsid>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( jsid ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const jsid ) ) . asBits as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( jsid ) , "::" ,
                    stringify ! ( asBits ) ));
    }
    impl Clone for jsid {
        fn clone(&self) -> Self { *self }
    }
    pub mod js {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod gc {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod gcstats {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Statistics {
                _unused: [u8; 0],
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct SystemAllocPolicy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_SystemAllocPolicy() {
            assert_eq!(::std::mem::size_of::<SystemAllocPolicy>() , 1usize ,
                       concat ! (
                       "Size of: " , stringify ! ( SystemAllocPolicy ) ));
            assert_eq! (::std::mem::align_of::<SystemAllocPolicy>() , 1usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( SystemAllocPolicy )
                        ));
        }
        impl Clone for SystemAllocPolicy {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WrappedPtrOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MutableWrappedPtrOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HandleBase {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MutableHandleBase {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HeapBase {
            pub _address: u8,
        }
        #[repr(C)]
        pub struct SourceHook__bindgen_vtable(::std::os::raw::c_void);
        /**
 * A class of objects that return source code on demand.
 *
 * When code is compiled with setSourceIsLazy(true), SpiderMonkey doesn't
 * retain the source code (and doesn't do lazy bytecode generation). If we ever
 * need the source code, say, in response to a call to Function.prototype.
 * toSource or Debugger.Source.prototype.text, then we call the 'load' member
 * function of the instance of this class that has hopefully been registered
 * with the runtime, passing the code's URL, and hope that it will be able to
 * find the source.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct SourceHook {
            pub vtable_: *const SourceHook__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_SourceHook() {
            assert_eq!(::std::mem::size_of::<SourceHook>() , 8usize , concat !
                       ( "Size of: " , stringify ! ( SourceHook ) ));
            assert_eq! (::std::mem::align_of::<SourceHook>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( SourceHook ) ));
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSCompartment {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSRuntime {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct JSTracer {
        pub runtime_: *mut root::JSRuntime,
        pub weakMapAction_: root::WeakMapTraceKind,
        pub tag_: root::JSTracer_TracerKindTag,
        pub traceWeakEdges_: bool,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSTracer_TracerKindTag {
        Marking = 0,
        WeakMarking = 1,
        Tenuring = 2,
        Callback = 3,
    }
    #[test]
    fn bindgen_test_layout_JSTracer() {
        assert_eq!(::std::mem::size_of::<JSTracer>() , 24usize , concat ! (
                   "Size of: " , stringify ! ( JSTracer ) ));
        assert_eq! (::std::mem::align_of::<JSTracer>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( JSTracer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSTracer ) ) . runtime_ as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSTracer ) , "::" ,
                    stringify ! ( runtime_ ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSTracer ) ) . weakMapAction_ as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSTracer ) , "::" ,
                    stringify ! ( weakMapAction_ ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSTracer ) ) . tag_ as * const _ as
                    usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSTracer ) , "::" ,
                    stringify ! ( tag_ ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSTracer ) ) . traceWeakEdges_ as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSTracer ) , "::" ,
                    stringify ! ( traceWeakEdges_ ) ));
    }
    impl Clone for JSTracer {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsQueryInterface {
        pub mRawPtr: *mut root::nsISupports,
    }
    #[test]
    fn bindgen_test_layout_nsQueryInterface() {
        assert_eq!(::std::mem::size_of::<nsQueryInterface>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsQueryInterface ) ));
        assert_eq! (::std::mem::align_of::<nsQueryInterface>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsQueryInterface ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsQueryInterface ) ) . mRawPtr as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsQueryInterface )
                    , "::" , stringify ! ( mRawPtr ) ));
    }
    impl Clone for nsQueryInterface {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsQueryInterfaceWithError {
        pub mRawPtr: *mut root::nsISupports,
        pub mErrorPtr: *mut root::nsresult,
    }
    #[test]
    fn bindgen_test_layout_nsQueryInterfaceWithError() {
        assert_eq!(::std::mem::size_of::<nsQueryInterfaceWithError>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( nsQueryInterfaceWithError ) ));
        assert_eq! (::std::mem::align_of::<nsQueryInterfaceWithError>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsQueryInterfaceWithError
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsQueryInterfaceWithError ) ) .
                    mRawPtr as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsQueryInterfaceWithError ) , "::" , stringify ! ( mRawPtr
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsQueryInterfaceWithError ) ) .
                    mErrorPtr as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsQueryInterfaceWithError ) , "::" , stringify ! (
                    mErrorPtr ) ));
    }
    impl Clone for nsQueryInterfaceWithError {
        fn clone(&self) -> Self { *self }
    }
    ////////////////////////////////////////////////////////////////////////////
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsGetServiceByCID {
        pub mCID: *const root::nsCID,
        pub __bindgen_align: [u64; 0usize],
    }
    #[test]
    fn bindgen_test_layout_nsGetServiceByCID() {
        assert_eq!(::std::mem::size_of::<nsGetServiceByCID>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsGetServiceByCID )
                   ));
        assert_eq! (::std::mem::align_of::<nsGetServiceByCID>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsGetServiceByCID ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsGetServiceByCID ) ) . mCID as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsGetServiceByCID )
                    , "::" , stringify ! ( mCID ) ));
    }
    impl Clone for nsGetServiceByCID {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsGetServiceByCIDWithError {
        pub mCID: *const root::nsCID,
        pub mErrorPtr: *mut root::nsresult,
    }
    #[test]
    fn bindgen_test_layout_nsGetServiceByCIDWithError() {
        assert_eq!(::std::mem::size_of::<nsGetServiceByCIDWithError>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( nsGetServiceByCIDWithError )
                   ));
        assert_eq! (::std::mem::align_of::<nsGetServiceByCIDWithError>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsGetServiceByCIDWithError
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsGetServiceByCIDWithError ) ) . mCID
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsGetServiceByCIDWithError ) , "::" , stringify ! ( mCID )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsGetServiceByCIDWithError ) ) .
                    mErrorPtr as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsGetServiceByCIDWithError ) , "::" , stringify ! (
                    mErrorPtr ) ));
    }
    impl Clone for nsGetServiceByCIDWithError {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsGetServiceByContractID {
        pub mContractID: *const ::std::os::raw::c_char,
    }
    #[test]
    fn bindgen_test_layout_nsGetServiceByContractID() {
        assert_eq!(::std::mem::size_of::<nsGetServiceByContractID>() , 8usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsGetServiceByContractID ) ));
        assert_eq! (::std::mem::align_of::<nsGetServiceByContractID>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsGetServiceByContractID )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsGetServiceByContractID ) ) .
                    mContractID as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsGetServiceByContractID ) , "::" , stringify ! (
                    mContractID ) ));
    }
    impl Clone for nsGetServiceByContractID {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsGetServiceByContractIDWithError {
        pub mContractID: *const ::std::os::raw::c_char,
        pub mErrorPtr: *mut root::nsresult,
    }
    #[test]
    fn bindgen_test_layout_nsGetServiceByContractIDWithError() {
        assert_eq!(::std::mem::size_of::<nsGetServiceByContractIDWithError>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsGetServiceByContractIDWithError ) ));
        assert_eq! (::std::mem::align_of::<nsGetServiceByContractIDWithError>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsGetServiceByContractIDWithError ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsGetServiceByContractIDWithError ) )
                    . mContractID as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsGetServiceByContractIDWithError ) , "::" , stringify ! (
                    mContractID ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsGetServiceByContractIDWithError ) )
                    . mErrorPtr as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsGetServiceByContractIDWithError ) , "::" , stringify ! (
                    mErrorPtr ) ));
    }
    impl Clone for nsGetServiceByContractIDWithError {
        fn clone(&self) -> Self { *self }
    }
    /**
 * Factors implementation for all template versions of nsCOMPtr.
 *
 * Here's the way people normally do things like this:
 *
 *   template<class T> class Foo { ... };
 *   template<> class Foo<void*> { ... };
 *   template<class T> class Foo<T*> : private Foo<void*> { ... };
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCOMPtr_base {
        pub mRawPtr: *mut root::nsISupports,
    }
    #[test]
    fn bindgen_test_layout_nsCOMPtr_base() {
        assert_eq!(::std::mem::size_of::<nsCOMPtr_base>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( nsCOMPtr_base ) ));
        assert_eq! (::std::mem::align_of::<nsCOMPtr_base>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsCOMPtr_base ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCOMPtr_base ) ) . mRawPtr as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCOMPtr_base ) ,
                    "::" , stringify ! ( mRawPtr ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCOMPtr {
        pub _base: root::nsCOMPtr_base,
    }
    pub type nsCOMPtr_element_type<T> = T;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAutoPtr<T> {
        pub mRawPtr: *mut T,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsAutoPtr_Ptr<T> {
        pub mPtr: *mut T,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    pub type nsAutoPtr_element_type<T> = T;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsAutoPtr_Proxy {
    }
    pub type nsAutoPtr_Proxy_member_function = u8;
    pub type PLDHashNumber = u32;
    #[repr(C)]
    #[derive(Debug)]
    pub struct PLDHashTable {
        pub mOps: *const root::PLDHashTableOps,
        pub mHashShift: i16,
        pub mEntrySize: u32,
        pub mEntryCount: u32,
        pub mRemovedCount: u32,
        pub mEntryStore: root::PLDHashTable_EntryStore,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct PLDHashTable_EntryStore {
        pub mEntryStore: *mut ::std::os::raw::c_char,
        pub mGeneration: u32,
    }
    #[test]
    fn bindgen_test_layout_PLDHashTable_EntryStore() {
        assert_eq!(::std::mem::size_of::<PLDHashTable_EntryStore>() , 16usize
                   , concat ! (
                   "Size of: " , stringify ! ( PLDHashTable_EntryStore ) ));
        assert_eq! (::std::mem::align_of::<PLDHashTable_EntryStore>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( PLDHashTable_EntryStore )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_EntryStore ) ) .
                    mEntryStore as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_EntryStore ) , "::" , stringify ! (
                    mEntryStore ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_EntryStore ) ) .
                    mGeneration as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_EntryStore ) , "::" , stringify ! (
                    mGeneration ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct PLDHashTable_Iterator {
        pub mTable: *mut root::PLDHashTable,
        pub mStart: *mut ::std::os::raw::c_char,
        pub mLimit: *mut ::std::os::raw::c_char,
        pub mCurrent: *mut ::std::os::raw::c_char,
        pub mNexts: u32,
        pub mNextsLimit: u32,
        pub mHaveRemoved: bool,
    }
    #[test]
    fn bindgen_test_layout_PLDHashTable_Iterator() {
        assert_eq!(::std::mem::size_of::<PLDHashTable_Iterator>() , 48usize ,
                   concat ! (
                   "Size of: " , stringify ! ( PLDHashTable_Iterator ) ));
        assert_eq! (::std::mem::align_of::<PLDHashTable_Iterator>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( PLDHashTable_Iterator )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_Iterator ) ) . mTable as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_Iterator ) , "::" , stringify ! ( mTable )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_Iterator ) ) . mStart as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_Iterator ) , "::" , stringify ! ( mStart )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_Iterator ) ) . mLimit as
                    * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_Iterator ) , "::" , stringify ! ( mLimit )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_Iterator ) ) . mCurrent
                    as * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_Iterator ) , "::" , stringify ! ( mCurrent )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_Iterator ) ) . mNexts as
                    * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_Iterator ) , "::" , stringify ! ( mNexts )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_Iterator ) ) .
                    mNextsLimit as * const _ as usize } , 36usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_Iterator ) , "::" , stringify ! ( mNextsLimit
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_Iterator ) ) .
                    mHaveRemoved as * const _ as usize } , 40usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_Iterator ) , "::" , stringify ! (
                    mHaveRemoved ) ));
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum PLDHashTable_SearchReason { ForSearchOrRemove = 0, ForAdd = 1, }
    pub const PLDHashTable_kMaxCapacity: u32 = 67108864;
    pub const PLDHashTable_kMinCapacity: u32 = 8;
    pub const PLDHashTable_kMaxInitialLength: u32 = 33554432;
    pub const PLDHashTable_kDefaultInitialLength: u32 = 4;
    pub const PLDHashTable_kHashBits: u32 = 32;
    pub const PLDHashTable_kGoldenRatio: u32 = 2654435769;
    pub const PLDHashTable_kCollisionFlag: root::PLDHashNumber = 1;
    #[test]
    fn bindgen_test_layout_PLDHashTable() {
        assert_eq!(::std::mem::size_of::<PLDHashTable>() , 40usize , concat !
                   ( "Size of: " , stringify ! ( PLDHashTable ) ));
        assert_eq! (::std::mem::align_of::<PLDHashTable>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( PLDHashTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable ) ) . mOps as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTable ) ,
                    "::" , stringify ! ( mOps ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable ) ) . mHashShift as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTable ) ,
                    "::" , stringify ! ( mHashShift ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable ) ) . mEntrySize as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTable ) ,
                    "::" , stringify ! ( mEntrySize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable ) ) . mEntryCount as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTable ) ,
                    "::" , stringify ! ( mEntryCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable ) ) . mRemovedCount as *
                    const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTable ) ,
                    "::" , stringify ! ( mRemovedCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable ) ) . mEntryStore as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTable ) ,
                    "::" , stringify ! ( mEntryStore ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLDHashTableOps {
        pub hashKey: root::PLDHashHashKey,
        pub matchEntry: root::PLDHashMatchEntry,
        pub moveEntry: root::PLDHashMoveEntry,
        pub clearEntry: root::PLDHashClearEntry,
        pub initEntry: root::PLDHashInitEntry,
    }
    #[test]
    fn bindgen_test_layout_PLDHashTableOps() {
        assert_eq!(::std::mem::size_of::<PLDHashTableOps>() , 40usize , concat
                   ! ( "Size of: " , stringify ! ( PLDHashTableOps ) ));
        assert_eq! (::std::mem::align_of::<PLDHashTableOps>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( PLDHashTableOps ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTableOps ) ) . hashKey as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTableOps ) ,
                    "::" , stringify ! ( hashKey ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTableOps ) ) . matchEntry as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTableOps ) ,
                    "::" , stringify ! ( matchEntry ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTableOps ) ) . moveEntry as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTableOps ) ,
                    "::" , stringify ! ( moveEntry ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTableOps ) ) . clearEntry as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTableOps ) ,
                    "::" , stringify ! ( clearEntry ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTableOps ) ) . initEntry as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTableOps ) ,
                    "::" , stringify ! ( initEntry ) ));
    }
    impl Clone for PLDHashTableOps {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLDHashEntryHdr {
        pub mKeyHash: root::PLDHashNumber,
    }
    #[test]
    fn bindgen_test_layout_PLDHashEntryHdr() {
        assert_eq!(::std::mem::size_of::<PLDHashEntryHdr>() , 4usize , concat
                   ! ( "Size of: " , stringify ! ( PLDHashEntryHdr ) ));
        assert_eq! (::std::mem::align_of::<PLDHashEntryHdr>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( PLDHashEntryHdr ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashEntryHdr ) ) . mKeyHash as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashEntryHdr ) ,
                    "::" , stringify ! ( mKeyHash ) ));
    }
    impl Clone for PLDHashEntryHdr {
        fn clone(&self) -> Self { *self }
    }
    pub type PLDHashHashKey =
        ::std::option::Option<unsafe extern "C" fn(aKey:
                                                       *const ::std::os::raw::c_void)
                                  -> root::PLDHashNumber>;
    pub type PLDHashMatchEntry =
        ::std::option::Option<unsafe extern "C" fn(aEntry:
                                                       *const root::PLDHashEntryHdr,
                                                   aKey:
                                                       *const ::std::os::raw::c_void)
                                  -> bool>;
    pub type PLDHashMoveEntry =
        ::std::option::Option<unsafe extern "C" fn(aTable:
                                                       *mut root::PLDHashTable,
                                                   aFrom:
                                                       *const root::PLDHashEntryHdr,
                                                   aTo:
                                                       *mut root::PLDHashEntryHdr)>;
    pub type PLDHashClearEntry =
        ::std::option::Option<unsafe extern "C" fn(aTable:
                                                       *mut root::PLDHashTable,
                                                   aEntry:
                                                       *mut root::PLDHashEntryHdr)>;
    pub type PLDHashInitEntry =
        ::std::option::Option<unsafe extern "C" fn(aEntry:
                                                       *mut root::PLDHashEntryHdr,
                                                   aKey:
                                                       *const ::std::os::raw::c_void)>;
    /**
 * hashkey wrapper using T* KeyType
 *
 * @see nsTHashtable::EntryType for specification
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPtrHashKey<T> {
        pub _base: root::PLDHashEntryHdr,
        pub mKey: *mut T,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    pub type nsPtrHashKey_KeyType<T> = *mut T;
    pub type nsPtrHashKey_KeyTypePointer<T> = *mut T;
    pub const nsPtrHashKey_ALLOW_MEMMOVE: root::nsPtrHashKey__bindgen_ty_1 =
        nsPtrHashKey__bindgen_ty_1::ALLOW_MEMMOVE;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsPtrHashKey__bindgen_ty_1 { ALLOW_MEMMOVE = 0, }
    /**
 * hashkey wrapper using nsAString KeyType
 *
 * @see nsTHashtable::EntryType for specification
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStringHashKey {
        pub _base: root::PLDHashEntryHdr,
        pub mStr: ::nsstring::nsStringRepr,
    }
    pub type nsStringHashKey_KeyType = *const root::nsAString;
    pub type nsStringHashKey_KeyTypePointer = *const root::nsAString;
    pub const nsStringHashKey_ALLOW_MEMMOVE:
              root::nsStringHashKey__bindgen_ty_1 =
        nsStringHashKey__bindgen_ty_1::ALLOW_MEMMOVE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStringHashKey__bindgen_ty_1 { ALLOW_MEMMOVE = 1, }
    #[test]
    fn bindgen_test_layout_nsStringHashKey() {
        assert_eq!(::std::mem::size_of::<nsStringHashKey>() , 24usize , concat
                   ! ( "Size of: " , stringify ! ( nsStringHashKey ) ));
        assert_eq! (::std::mem::align_of::<nsStringHashKey>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStringHashKey ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStringHashKey ) ) . mStr as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStringHashKey ) ,
                    "::" , stringify ! ( mStr ) ));
    }
    /**
 * hashkey wrapper using nsACString KeyType
 *
 * @see nsTHashtable::EntryType for specification
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCStringHashKey {
        pub _base: root::PLDHashEntryHdr,
        pub mStr: root::nsCString,
    }
    pub type nsCStringHashKey_KeyType = *const root::nsACString;
    pub type nsCStringHashKey_KeyTypePointer = *const root::nsACString;
    pub const nsCStringHashKey_ALLOW_MEMMOVE:
              root::nsCStringHashKey__bindgen_ty_1 =
        nsCStringHashKey__bindgen_ty_1::ALLOW_MEMMOVE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCStringHashKey__bindgen_ty_1 { ALLOW_MEMMOVE = 1, }
    #[test]
    fn bindgen_test_layout_nsCStringHashKey() {
        assert_eq!(::std::mem::size_of::<nsCStringHashKey>() , 24usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCStringHashKey )
                   ));
        assert_eq! (::std::mem::align_of::<nsCStringHashKey>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCStringHashKey ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCStringHashKey ) ) . mStr as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCStringHashKey )
                    , "::" , stringify ! ( mStr ) ));
    }
    /**
 * hashkey wrapper using nsISupports* KeyType
 *
 * @see nsTHashtable::EntryType for specification
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsISupportsHashKey {
        pub _base: root::PLDHashEntryHdr,
        pub mSupports: root::nsCOMPtr,
    }
    pub type nsISupportsHashKey_KeyType = *mut root::nsISupports;
    pub type nsISupportsHashKey_KeyTypePointer = *const root::nsISupports;
    pub const nsISupportsHashKey_ALLOW_MEMMOVE:
              root::nsISupportsHashKey__bindgen_ty_1 =
        nsISupportsHashKey__bindgen_ty_1::ALLOW_MEMMOVE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsISupportsHashKey__bindgen_ty_1 { ALLOW_MEMMOVE = 1, }
    #[test]
    fn bindgen_test_layout_nsISupportsHashKey() {
        assert_eq!(::std::mem::size_of::<nsISupportsHashKey>() , 16usize ,
                   concat ! ( "Size of: " , stringify ! ( nsISupportsHashKey )
                   ));
        assert_eq! (::std::mem::align_of::<nsISupportsHashKey>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsISupportsHashKey ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsISupportsHashKey ) ) . mSupports as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsISupportsHashKey
                    ) , "::" , stringify ! ( mSupports ) ));
    }
    /**
 * hashkey wrapper using refcounted * KeyType
 *
 * @see nsTHashtable::EntryType for specification
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsRefPtrHashKey<T> {
        pub _base: root::PLDHashEntryHdr,
        pub mKey: root::RefPtr<T>,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    pub type nsRefPtrHashKey_KeyType<T> = *mut T;
    pub type nsRefPtrHashKey_KeyTypePointer<T> = *mut T;
    pub const nsRefPtrHashKey_ALLOW_MEMMOVE:
              root::nsRefPtrHashKey__bindgen_ty_1 =
        nsRefPtrHashKey__bindgen_ty_1::ALLOW_MEMMOVE;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsRefPtrHashKey__bindgen_ty_1 { ALLOW_MEMMOVE = 0, }
    /**
 * a base class for templated hashtables.
 *
 * Clients will rarely need to use this class directly. Check the derived
 * classes first, to see if they will meet your needs.
 *
 * @param EntryType  the templated entry-type class that is managed by the
 *   hashtable. <code>EntryType</code> must extend the following declaration,
 *   and <strong>must not declare any virtual functions or derive from classes
 *   with virtual functions.</strong>  Any vtable pointer would break the
 *   PLDHashTable code.
 *<pre>   class EntryType : public PLDHashEntryHdr
 *   {
 *   public: or friend nsTHashtable<EntryType>;
 *     // KeyType is what we use when Get()ing or Put()ing this entry
 *     // this should either be a simple datatype (uint32_t, nsISupports*) or
 *     // a const reference (const nsAString&)
 *     typedef something KeyType;
 *     // KeyTypePointer is the pointer-version of KeyType, because
 *     // PLDHashTable.h requires keys to cast to <code>const void*</code>
 *     typedef const something* KeyTypePointer;
 *
 *     EntryType(KeyTypePointer aKey);
 *
 *     // A copy or C++11 Move constructor must be defined, even if
 *     // AllowMemMove() == true, otherwise you will cause link errors.
 *     EntryType(const EntryType& aEnt);  // Either this...
 *     EntryType(EntryType&& aEnt);       // ...or this
 *
 *     // the destructor must be defined... or you will cause link errors!
 *     ~EntryType();
 *
 *     // KeyEquals(): does this entry match this key?
 *     bool KeyEquals(KeyTypePointer aKey) const;
 *
 *     // KeyToPointer(): Convert KeyType to KeyTypePointer
 *     static KeyTypePointer KeyToPointer(KeyType aKey);
 *
 *     // HashKey(): calculate the hash number
 *     static PLDHashNumber HashKey(KeyTypePointer aKey);
 *
 *     // ALLOW_MEMMOVE can we move this class with memmove(), or do we have
 *     // to use the copy constructor?
 *     enum { ALLOW_MEMMOVE = true/false };
 *   }</pre>
 *
 * @see nsInterfaceHashtable
 * @see nsDataHashtable
 * @see nsClassHashtable
 * @author "Benjamin Smedberg <bsmedberg@covad.net>"
 */
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsTHashtable {
    }
    pub type nsTHashtable_fallible_t = root::mozilla::fallible_t;
    /**
   * KeyType is typedef'ed for ease of use.
   */
    pub type nsTHashtable_KeyType = [u8; 0usize];
    /**
   * KeyTypePointer is typedef'ed for ease of use.
   */
    pub type nsTHashtable_KeyTypePointer = [u8; 0usize];
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsTHashtable_Iterator {
        pub _base: root::PLDHashTable_Iterator,
    }
    pub type nsTHashtable_Iterator_Base = root::PLDHashTable_Iterator;
    /**
 * templated hashtable for simple data types
 * This class manages simple data types that do not need construction or
 * destruction.
 *
 * @param KeyClass a wrapper-class for the hashtable key, see nsHashKeys.h
 *   for a complete specification.
 * @param DataType the datatype stored in the hashtable,
 *   for example, uint32_t or nsCOMPtr.  If UserDataType is not the same,
 *   DataType must implicitly cast to UserDataType
 * @param UserDataType the user sees, for example uint32_t or nsISupports*
 */
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsBaseHashtable {
    }
    pub type nsBaseHashtable_fallible_t = root::mozilla::fallible_t;
    pub type nsBaseHashtable_KeyType = [u8; 0usize];
    pub type nsBaseHashtable_EntryType<KeyClass, DataType> =
        root::nsBaseHashtableET<KeyClass, DataType>;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsBaseHashtable_LookupResult<KeyClass, DataType> {
        pub mEntry: *mut root::nsBaseHashtable_EntryType<KeyClass, DataType>,
        pub mTable: *mut u8,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<KeyClass>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<DataType>>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsBaseHashtable_EntryPtr<KeyClass, DataType> {
        pub mEntry: *mut root::nsBaseHashtable_EntryType<KeyClass, DataType>,
        pub mExistingEntry: bool,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<KeyClass>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<DataType>>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsBaseHashtable_Iterator {
        pub _base: root::PLDHashTable_Iterator,
    }
    pub type nsBaseHashtable_Iterator_Base = root::PLDHashTable_Iterator;
    /**
 * the private nsTHashtable::EntryType class used by nsBaseHashtable
 * @see nsTHashtable for the specification of this class
 * @see nsBaseHashtable for template parameters
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsBaseHashtableET<KeyClass, DataType> {
        pub _base: KeyClass,
        pub mData: DataType,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<KeyClass>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<DataType>>,
    }
    pub type nsBaseHashtableET_KeyType = [u8; 0usize];
    pub type nsBaseHashtableET_KeyTypePointer = [u8; 0usize];
    /**
 * templated hashtable class maps keys to simple datatypes.
 * See nsBaseHashtable for complete declaration
 * @param KeyClass a wrapper-class for the hashtable key, see nsHashKeys.h
 *   for a complete specification.
 * @param DataType the simple datatype being wrapped
 * @see nsInterfaceHashtable, nsClassHashtable
 */
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDataHashtable {
    }
    pub type nsDataHashtable_BaseClass = u8;
    pub type nsIntRegion = root::mozilla::gfx::IntRegion;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsRegion {
        pub mImpl: root::pixman_region32_t,
    }
    pub type nsRegion_RectType = root::nsRect;
    pub type nsRegion_PointType = root::nsPoint;
    pub type nsRegion_MarginType = root::nsMargin;
    /**
   * VisitEdges is a weird kind of function that we use for padding
   * out surfaces to prevent texture filtering artifacts.
   * It calls the visitFn callback for each of the exterior edges of
   * the regions. The top and bottom edges will be expanded 1 pixel
   * to the left and right if there's an outside corner. The order
   * the edges are visited is not guaranteed.
   *
   * visitFn has a side parameter that can be TOP,BOTTOM,LEFT,RIGHT
   * and specifies which kind of edge is being visited. x1, y1, x2, y2
   * are the coordinates of the line. (x1 == x2) || (y1 == y2)
   */
    pub type nsRegion_visitFn =
        ::std::option::Option<unsafe extern "C" fn(closure:
                                                       *mut ::std::os::raw::c_void,
                                                   side: root::VisitSide,
                                                   x1: ::std::os::raw::c_int,
                                                   y1: ::std::os::raw::c_int,
                                                   x2: ::std::os::raw::c_int,
                                                   y2:
                                                       ::std::os::raw::c_int)>;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsRegion_RectIterator {
        pub mCurrent: ::std::os::raw::c_int,
        pub mLimit: ::std::os::raw::c_int,
        pub mTmp: root::nsRect,
        pub mBoxes: *mut root::pixman_box32_t,
    }
    #[test]
    fn bindgen_test_layout_nsRegion_RectIterator() {
        assert_eq!(::std::mem::size_of::<nsRegion_RectIterator>() , 32usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsRegion_RectIterator ) ));
        assert_eq! (::std::mem::align_of::<nsRegion_RectIterator>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsRegion_RectIterator )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRegion_RectIterator ) ) . mCurrent
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsRegion_RectIterator ) , "::" , stringify ! ( mCurrent )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRegion_RectIterator ) ) . mLimit as
                    * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsRegion_RectIterator ) , "::" , stringify ! ( mLimit )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRegion_RectIterator ) ) . mTmp as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsRegion_RectIterator ) , "::" , stringify ! ( mTmp ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRegion_RectIterator ) ) . mBoxes as
                    * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsRegion_RectIterator ) , "::" , stringify ! ( mBoxes )
                    ));
    }
    impl Clone for nsRegion_RectIterator {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsRegion() {
        assert_eq!(::std::mem::size_of::<nsRegion>() , 24usize , concat ! (
                   "Size of: " , stringify ! ( nsRegion ) ));
        assert_eq! (::std::mem::align_of::<nsRegion>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsRegion ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRegion ) ) . mImpl as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsRegion ) , "::" ,
                    stringify ! ( mImpl ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTArrayHeader {
        pub mLength: u32,
        pub _bitfield_1: u32,
    }
    extern "C" {
        #[link_name = "_ZN14nsTArrayHeader9sEmptyHdrE"]
        pub static mut nsTArrayHeader_sEmptyHdr: root::nsTArrayHeader;
    }
    #[test]
    fn bindgen_test_layout_nsTArrayHeader() {
        assert_eq!(::std::mem::size_of::<nsTArrayHeader>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( nsTArrayHeader ) ));
        assert_eq! (::std::mem::align_of::<nsTArrayHeader>() , 4usize , concat
                    ! ( "Alignment of " , stringify ! ( nsTArrayHeader ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsTArrayHeader ) ) . mLength as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsTArrayHeader ) ,
                    "::" , stringify ! ( mLength ) ));
    }
    impl Clone for nsTArrayHeader {
        fn clone(&self) -> Self { *self }
    }
    impl nsTArrayHeader {
        #[inline]
        pub fn mCapacity(&self) -> u32 {
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            let mask = 2147483647u64 as u32;
            let val = (unit_field_val & mask) >> 0usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mCapacity(&mut self, val: u32) {
            let mask = 2147483647u64 as u32;
            let val = val as u32 as u32;
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 0usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u32>());
            }
        }
        #[inline]
        pub fn mIsAutoArray(&self) -> u32 {
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            let mask = 2147483648u64 as u32;
            let val = (unit_field_val & mask) >> 31usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mIsAutoArray(&mut self, val: u32) {
            let mask = 2147483648u64 as u32;
            let val = val as u32 as u32;
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 31usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u32>());
            }
        }
        #[inline]
        pub fn new_bitfield_1(mCapacity: u32, mIsAutoArray: u32) -> u32 {
            ({
                 ({ 0 } |
                      ((mCapacity as u32 as u32) << 0usize) &
                          (2147483647u64 as u32))
             } |
                 ((mIsAutoArray as u32 as u32) << 31usize) &
                     (2147483648u64 as u32))
        }
    }
    pub type nscoord = i32;
    pub type nscolor = u32;
    pub type nsIntPoint = root::mozilla::gfx::IntPoint;
    pub type nsIntMargin = root::mozilla::gfx::IntMargin;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct gfxFontFeature {
        pub mTag: u32,
        pub mValue: u32,
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeature() {
        assert_eq!(::std::mem::size_of::<gfxFontFeature>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( gfxFontFeature ) ));
        assert_eq! (::std::mem::align_of::<gfxFontFeature>() , 4usize , concat
                    ! ( "Alignment of " , stringify ! ( gfxFontFeature ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxFontFeature ) ) . mTag as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( gfxFontFeature ) ,
                    "::" , stringify ! ( mTag ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxFontFeature ) ) . mValue as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( gfxFontFeature ) ,
                    "::" , stringify ! ( mValue ) ));
    }
    impl Clone for gfxFontFeature {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxAlternateValue {
        pub alternate: u32,
        pub value: ::nsstring::nsStringRepr,
    }
    #[test]
    fn bindgen_test_layout_gfxAlternateValue() {
        assert_eq!(::std::mem::size_of::<gfxAlternateValue>() , 24usize ,
                   concat ! ( "Size of: " , stringify ! ( gfxAlternateValue )
                   ));
        assert_eq! (::std::mem::align_of::<gfxAlternateValue>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( gfxAlternateValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxAlternateValue ) ) . alternate as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( gfxAlternateValue )
                    , "::" , stringify ! ( alternate ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxAlternateValue ) ) . value as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( gfxAlternateValue )
                    , "::" , stringify ! ( value ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxFontFeatureValueSet {
        pub mRefCnt: root::nsAutoRefCnt,
        pub mFontFeatureValues: [u64; 5usize],
    }
    pub type gfxFontFeatureValueSet_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxFontFeatureValueSet_ValueList {
        pub name: ::nsstring::nsStringRepr,
        pub featureSelectors: root::nsTArray<::std::os::raw::c_uint>,
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeatureValueSet_ValueList() {
        assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet_ValueList>() ,
                   24usize , concat ! (
                   "Size of: " , stringify ! (
                   gfxFontFeatureValueSet_ValueList ) ));
        assert_eq! (::std::mem::align_of::<gfxFontFeatureValueSet_ValueList>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    gfxFontFeatureValueSet_ValueList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxFontFeatureValueSet_ValueList ) )
                    . name as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_ValueList ) , "::" , stringify ! (
                    name ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxFontFeatureValueSet_ValueList ) )
                    . featureSelectors as * const _ as usize } , 16usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_ValueList ) , "::" , stringify ! (
                    featureSelectors ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxFontFeatureValueSet_FeatureValues {
        pub alternate: u32,
        pub valuelist: root::nsTArray<root::gfxFontFeatureValueSet_ValueList>,
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeatureValueSet_FeatureValues() {
        assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet_FeatureValues>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   gfxFontFeatureValueSet_FeatureValues ) ));
        assert_eq! (::std::mem::align_of::<gfxFontFeatureValueSet_FeatureValues>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValues ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const gfxFontFeatureValueSet_FeatureValues ) )
                    . alternate as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValues ) , "::" , stringify
                    ! ( alternate ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const gfxFontFeatureValueSet_FeatureValues ) )
                    . valuelist as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValues ) , "::" , stringify
                    ! ( valuelist ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxFontFeatureValueSet_FeatureValueHashKey {
        pub mFamily: ::nsstring::nsStringRepr,
        pub mPropVal: u32,
        pub mName: ::nsstring::nsStringRepr,
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeatureValueSet_FeatureValueHashKey() {
        assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet_FeatureValueHashKey>()
                   , 40usize , concat ! (
                   "Size of: " , stringify ! (
                   gfxFontFeatureValueSet_FeatureValueHashKey ) ));
        assert_eq! (::std::mem::align_of::<gfxFontFeatureValueSet_FeatureValueHashKey>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValueHashKey ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const gfxFontFeatureValueSet_FeatureValueHashKey )
                    ) . mFamily as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValueHashKey ) , "::" ,
                    stringify ! ( mFamily ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const gfxFontFeatureValueSet_FeatureValueHashKey )
                    ) . mPropVal as * const _ as usize } , 16usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValueHashKey ) , "::" ,
                    stringify ! ( mPropVal ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const gfxFontFeatureValueSet_FeatureValueHashKey )
                    ) . mName as * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValueHashKey ) , "::" ,
                    stringify ! ( mName ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxFontFeatureValueSet_FeatureValueHashEntry {
        pub _base: root::PLDHashEntryHdr,
        pub mKey: root::gfxFontFeatureValueSet_FeatureValueHashKey,
        pub mValues: root::nsTArray<::std::os::raw::c_uint>,
    }
    pub type gfxFontFeatureValueSet_FeatureValueHashEntry_KeyType =
        *const root::gfxFontFeatureValueSet_FeatureValueHashKey;
    pub type gfxFontFeatureValueSet_FeatureValueHashEntry_KeyTypePointer =
        *const root::gfxFontFeatureValueSet_FeatureValueHashKey;
    pub const gfxFontFeatureValueSet_FeatureValueHashEntry_ALLOW_MEMMOVE:
              root::gfxFontFeatureValueSet_FeatureValueHashEntry__bindgen_ty_1
              =
        gfxFontFeatureValueSet_FeatureValueHashEntry__bindgen_ty_1::ALLOW_MEMMOVE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum gfxFontFeatureValueSet_FeatureValueHashEntry__bindgen_ty_1 {
        ALLOW_MEMMOVE = 1,
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeatureValueSet_FeatureValueHashEntry() {
        assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet_FeatureValueHashEntry>()
                   , 56usize , concat ! (
                   "Size of: " , stringify ! (
                   gfxFontFeatureValueSet_FeatureValueHashEntry ) ));
        assert_eq! (::std::mem::align_of::<gfxFontFeatureValueSet_FeatureValueHashEntry>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValueHashEntry ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const gfxFontFeatureValueSet_FeatureValueHashEntry
                    ) ) . mKey as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValueHashEntry ) , "::" ,
                    stringify ! ( mKey ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const gfxFontFeatureValueSet_FeatureValueHashEntry
                    ) ) . mValues as * const _ as usize } , 48usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValueHashEntry ) , "::" ,
                    stringify ! ( mValues ) ));
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeatureValueSet() {
        assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet>() , 48usize ,
                   concat ! (
                   "Size of: " , stringify ! ( gfxFontFeatureValueSet ) ));
        assert_eq! (::std::mem::align_of::<gfxFontFeatureValueSet>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( gfxFontFeatureValueSet )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxFontFeatureValueSet ) ) . mRefCnt
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet ) , "::" , stringify ! ( mRefCnt )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxFontFeatureValueSet ) ) .
                    mFontFeatureValues as * const _ as usize } , 8usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet ) , "::" , stringify ! (
                    mFontFeatureValues ) ));
    }
    pub type gfxFontVariation = root::mozilla::gfx::FontVariation;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct gfxFontStyle {
        _unused: [u8; 0],
    }
    pub const kGenericFont_NONE: u8 = 0;
    pub const kGenericFont_moz_variable: u8 = 0;
    pub const kGenericFont_moz_fixed: u8 = 1;
    pub const kGenericFont_serif: u8 = 2;
    pub const kGenericFont_sans_serif: u8 = 4;
    pub const kGenericFont_monospace: u8 = 8;
    pub const kGenericFont_cursive: u8 = 16;
    pub const kGenericFont_fantasy: u8 = 32;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsFont {
        pub fontlist: root::mozilla::FontFamilyList,
        pub style: u8,
        pub systemFont: bool,
        pub variantCaps: u8,
        pub variantNumeric: u8,
        pub variantPosition: u8,
        pub variantWidth: u8,
        pub variantLigatures: u16,
        pub variantEastAsian: u16,
        pub variantAlternates: u16,
        pub smoothing: u8,
        pub weight: u16,
        pub stretch: i16,
        pub kerning: u8,
        pub synthesis: u8,
        pub size: root::nscoord,
        pub sizeAdjust: f32,
        pub alternateValues: root::nsTArray<root::gfxAlternateValue>,
        pub featureValueLookup: root::RefPtr<root::gfxFontFeatureValueSet>,
        pub fontFeatureSettings: root::nsTArray<root::gfxFontFeature>,
        pub fontVariationSettings: root::nsTArray<root::mozilla::gfx::FontVariation>,
        pub languageOverride: u32,
    }
    #[test]
    fn bindgen_test_layout_nsFont() {
        assert_eq!(::std::mem::size_of::<nsFont>() , 88usize , concat ! (
                   "Size of: " , stringify ! ( nsFont ) ));
        assert_eq! (::std::mem::align_of::<nsFont>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsFont ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . fontlist as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( fontlist ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . style as * const _ as
                    usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( style ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . systemFont as * const _
                    as usize } , 17usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( systemFont ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . variantCaps as * const _
                    as usize } , 18usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( variantCaps ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . variantNumeric as *
                    const _ as usize } , 19usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( variantNumeric ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . variantPosition as *
                    const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( variantPosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . variantWidth as * const
                    _ as usize } , 21usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( variantWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . variantLigatures as *
                    const _ as usize } , 22usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( variantLigatures ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . variantEastAsian as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( variantEastAsian ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . variantAlternates as *
                    const _ as usize } , 26usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( variantAlternates ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . smoothing as * const _
                    as usize } , 28usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( smoothing ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . weight as * const _ as
                    usize } , 30usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( weight ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . stretch as * const _ as
                    usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( stretch ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . kerning as * const _ as
                    usize } , 34usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( kerning ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . synthesis as * const _
                    as usize } , 35usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( synthesis ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . size as * const _ as
                    usize } , 36usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( size ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . sizeAdjust as * const _
                    as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( sizeAdjust ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . alternateValues as *
                    const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( alternateValues ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . featureValueLookup as *
                    const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( featureValueLookup ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . fontFeatureSettings as *
                    const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( fontFeatureSettings ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . fontVariationSettings as
                    * const _ as usize } , 72usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( fontVariationSettings ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . languageOverride as *
                    const _ as usize } , 80usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( languageOverride ) ));
    }
    /**
 * An array of objects, similar to AutoTArray<T,1> but which is memmovable. It
 * always has length >= 1.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleAutoArray<T> {
        pub mFirstElement: T,
        pub mOtherElements: root::nsTArray<T>,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleAutoArray_WithSingleInitialElement {
        WITH_SINGLE_INITIAL_ELEMENT = 0,
    }
    /**
 * Currently needs to be 'double' for Cairo compatibility. Could
 * become 'float', perhaps, in some configurations.
 */
    pub type gfxFloat = f64;
    pub type gfxSize = [u64; 2usize];
    pub type nsIntRect = root::mozilla::gfx::IntRect;
    pub const nsStyleUnit_eStyleUnit_MAX: root::nsStyleUnit =
        nsStyleUnit::eStyleUnit_Calc;
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleUnit {
        eStyleUnit_Null = 0,
        eStyleUnit_Normal = 1,
        eStyleUnit_Auto = 2,
        eStyleUnit_None = 3,
        eStyleUnit_Percent = 10,
        eStyleUnit_Factor = 11,
        eStyleUnit_Degree = 12,
        eStyleUnit_Grad = 13,
        eStyleUnit_Radian = 14,
        eStyleUnit_Turn = 15,
        eStyleUnit_FlexFraction = 16,
        eStyleUnit_Coord = 20,
        eStyleUnit_Integer = 30,
        eStyleUnit_Enumerated = 32,
        eStyleUnit_Calc = 40,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleUnion {
        pub mInt: root::__BindgenUnionField<i32>,
        pub mFloat: root::__BindgenUnionField<f32>,
        pub mPointer: root::__BindgenUnionField<*mut ::std::os::raw::c_void>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsStyleUnion() {
        assert_eq!(::std::mem::size_of::<nsStyleUnion>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleUnion ) ));
        assert_eq! (::std::mem::align_of::<nsStyleUnion>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleUnion ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUnion ) ) . mInt as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUnion ) ,
                    "::" , stringify ! ( mInt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUnion ) ) . mFloat as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUnion ) ,
                    "::" , stringify ! ( mFloat ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUnion ) ) . mPointer as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUnion ) ,
                    "::" , stringify ! ( mPointer ) ));
    }
    impl Clone for nsStyleUnion {
        fn clone(&self) -> Self { *self }
    }
    /**
 * Class that hold a single size specification used by the style
 * system.  The size specification consists of two parts -- a number
 * and a unit.  The number is an integer, a floating point value, an
 * nscoord, or undefined, and the unit is an nsStyleUnit.  Checking
 * the unit is a must before asking for the value in any particular
 * form.
 */
 /** <div rustbindgen private accessor="unsafe"></div> */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleCoord {
        mUnit: root::nsStyleUnit,
        mValue: root::nsStyleUnion,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleCoord_CalcValue {
        pub mLength: root::nscoord,
        pub mPercent: f32,
        pub mHasPercent: bool,
    }
    #[test]
    fn bindgen_test_layout_nsStyleCoord_CalcValue() {
        assert_eq!(::std::mem::size_of::<nsStyleCoord_CalcValue>() , 12usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsStyleCoord_CalcValue ) ));
        assert_eq! (::std::mem::align_of::<nsStyleCoord_CalcValue>() , 4usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsStyleCoord_CalcValue )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCoord_CalcValue ) ) . mLength
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleCoord_CalcValue ) , "::" , stringify ! ( mLength )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCoord_CalcValue ) ) . mPercent
                    as * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleCoord_CalcValue ) , "::" , stringify ! ( mPercent )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCoord_CalcValue ) ) .
                    mHasPercent as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleCoord_CalcValue ) , "::" , stringify ! (
                    mHasPercent ) ));
    }
    impl Clone for nsStyleCoord_CalcValue {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleCoord_Calc {
        pub _base: root::nsStyleCoord_CalcValue,
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
    }
    pub type nsStyleCoord_Calc_HasThreadSafeRefCnt = root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsStyleCoord_Calc() {
        assert_eq!(::std::mem::size_of::<nsStyleCoord_Calc>() , 24usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleCoord_Calc )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleCoord_Calc>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleCoord_Calc ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCoord_Calc ) ) . mRefCnt as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleCoord_Calc )
                    , "::" , stringify ! ( mRefCnt ) ));
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleCoord_CoordConstructorType { CoordConstructor = 0, }
    #[test]
    fn bindgen_test_layout_nsStyleCoord() {
        assert_eq!(::std::mem::size_of::<nsStyleCoord>() , 16usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleCoord ) ));
        assert_eq! (::std::mem::align_of::<nsStyleCoord>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleCoord ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCoord ) ) . mUnit as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleCoord ) ,
                    "::" , stringify ! ( mUnit ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCoord ) ) . mValue as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleCoord ) ,
                    "::" , stringify ! ( mValue ) ));
    }
    impl nsStyleCoord {
        #[inline]
        pub unsafe fn get_mUnit(&self) -> &root::nsStyleUnit { &self.mUnit }
        #[inline]
        pub unsafe fn get_mUnit_mut(&mut self) -> &mut root::nsStyleUnit {
            &mut self.mUnit
        }
        #[inline]
        pub unsafe fn get_mValue(&self) -> &root::nsStyleUnion {
            &self.mValue
        }
        #[inline]
        pub unsafe fn get_mValue_mut(&mut self) -> &mut root::nsStyleUnion {
            &mut self.mValue
        }
    }
    /**
 * Class that represents a set of top/right/bottom/left nsStyleCoords.
 * This is commonly used to hold the widths of the borders, margins,
 * or paddings of a box.
 */
 /** <div rustbindgen private accessor="unsafe"></div> */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleSides {
        mUnits: [root::nsStyleUnit; 4usize],
        mValues: [root::nsStyleUnion; 4usize],
    }
    #[test]
    fn bindgen_test_layout_nsStyleSides() {
        assert_eq!(::std::mem::size_of::<nsStyleSides>() , 40usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleSides ) ));
        assert_eq! (::std::mem::align_of::<nsStyleSides>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleSides ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSides ) ) . mUnits as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSides ) ,
                    "::" , stringify ! ( mUnits ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSides ) ) . mValues as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSides ) ,
                    "::" , stringify ! ( mValues ) ));
    }
    impl nsStyleSides {
        #[inline]
        pub unsafe fn get_mUnits(&self) -> &[root::nsStyleUnit; 4usize] {
            &self.mUnits
        }
        #[inline]
        pub unsafe fn get_mUnits_mut(&mut self)
         -> &mut [root::nsStyleUnit; 4usize] {
            &mut self.mUnits
        }
        #[inline]
        pub unsafe fn get_mValues(&self) -> &[root::nsStyleUnion; 4usize] {
            &self.mValues
        }
        #[inline]
        pub unsafe fn get_mValues_mut(&mut self)
         -> &mut [root::nsStyleUnion; 4usize] {
            &mut self.mValues
        }
    }
    /**
 * Class that represents a set of top-left/top-right/bottom-right/bottom-left
 * nsStyleCoord pairs.  This is used to hold the dimensions of the
 * corners of a box (for, e.g., border-radius and outline-radius).
 */
 /** <div rustbindgen private accessor="unsafe"></div> */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleCorners {
        mUnits: [root::nsStyleUnit; 8usize],
        mValues: [root::nsStyleUnion; 8usize],
    }
    #[test]
    fn bindgen_test_layout_nsStyleCorners() {
        assert_eq!(::std::mem::size_of::<nsStyleCorners>() , 72usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleCorners ) ));
        assert_eq! (::std::mem::align_of::<nsStyleCorners>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleCorners ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCorners ) ) . mUnits as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleCorners ) ,
                    "::" , stringify ! ( mUnits ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCorners ) ) . mValues as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleCorners ) ,
                    "::" , stringify ! ( mValues ) ));
    }
    impl nsStyleCorners {
        #[inline]
        pub unsafe fn get_mUnits(&self) -> &[root::nsStyleUnit; 8usize] {
            &self.mUnits
        }
        #[inline]
        pub unsafe fn get_mUnits_mut(&mut self)
         -> &mut [root::nsStyleUnit; 8usize] {
            &mut self.mUnits
        }
        #[inline]
        pub unsafe fn get_mValues(&self) -> &[root::nsStyleUnion; 8usize] {
            &self.mValues
        }
        #[inline]
        pub unsafe fn get_mValues_mut(&mut self)
         -> &mut [root::nsStyleUnion; 8usize] {
            &mut self.mValues
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsCSSSelector {
        _unused: [u8; 0],
    }
    pub const nsChangeHint_nsChangeHint_Empty: root::nsChangeHint =
        nsChangeHint(0);
    pub const nsChangeHint_nsChangeHint_RepaintFrame: root::nsChangeHint =
        nsChangeHint(1);
    pub const nsChangeHint_nsChangeHint_NeedReflow: root::nsChangeHint =
        nsChangeHint(2);
    pub const nsChangeHint_nsChangeHint_ClearAncestorIntrinsics:
              root::nsChangeHint =
        nsChangeHint(4);
    pub const nsChangeHint_nsChangeHint_ClearDescendantIntrinsics:
              root::nsChangeHint =
        nsChangeHint(8);
    pub const nsChangeHint_nsChangeHint_NeedDirtyReflow: root::nsChangeHint =
        nsChangeHint(16);
    pub const nsChangeHint_nsChangeHint_SyncFrameView: root::nsChangeHint =
        nsChangeHint(32);
    pub const nsChangeHint_nsChangeHint_UpdateCursor: root::nsChangeHint =
        nsChangeHint(64);
    pub const nsChangeHint_nsChangeHint_UpdateEffects: root::nsChangeHint =
        nsChangeHint(128);
    pub const nsChangeHint_nsChangeHint_UpdateOpacityLayer: root::nsChangeHint
              =
        nsChangeHint(256);
    pub const nsChangeHint_nsChangeHint_UpdateTransformLayer:
              root::nsChangeHint =
        nsChangeHint(512);
    pub const nsChangeHint_nsChangeHint_ReconstructFrame: root::nsChangeHint =
        nsChangeHint(1024);
    pub const nsChangeHint_nsChangeHint_UpdateOverflow: root::nsChangeHint =
        nsChangeHint(2048);
    pub const nsChangeHint_nsChangeHint_UpdateSubtreeOverflow:
              root::nsChangeHint =
        nsChangeHint(4096);
    pub const nsChangeHint_nsChangeHint_UpdatePostTransformOverflow:
              root::nsChangeHint =
        nsChangeHint(8192);
    pub const nsChangeHint_nsChangeHint_UpdateParentOverflow:
              root::nsChangeHint =
        nsChangeHint(16384);
    pub const nsChangeHint_nsChangeHint_ChildrenOnlyTransform:
              root::nsChangeHint =
        nsChangeHint(32768);
    pub const nsChangeHint_nsChangeHint_RecomputePosition: root::nsChangeHint
              =
        nsChangeHint(65536);
    pub const nsChangeHint_nsChangeHint_UpdateContainingBlock:
              root::nsChangeHint =
        nsChangeHint(131072);
    pub const nsChangeHint_nsChangeHint_BorderStyleNoneChange:
              root::nsChangeHint =
        nsChangeHint(262144);
    pub const nsChangeHint_nsChangeHint_UpdateTextPath: root::nsChangeHint =
        nsChangeHint(524288);
    pub const nsChangeHint_nsChangeHint_SchedulePaint: root::nsChangeHint =
        nsChangeHint(1048576);
    pub const nsChangeHint_nsChangeHint_NeutralChange: root::nsChangeHint =
        nsChangeHint(2097152);
    pub const nsChangeHint_nsChangeHint_InvalidateRenderingObservers:
              root::nsChangeHint =
        nsChangeHint(4194304);
    pub const nsChangeHint_nsChangeHint_ReflowChangesSizeOrPosition:
              root::nsChangeHint =
        nsChangeHint(8388608);
    pub const nsChangeHint_nsChangeHint_UpdateComputedBSize:
              root::nsChangeHint =
        nsChangeHint(16777216);
    pub const nsChangeHint_nsChangeHint_UpdateUsesOpacity: root::nsChangeHint
              =
        nsChangeHint(33554432);
    pub const nsChangeHint_nsChangeHint_UpdateBackgroundPosition:
              root::nsChangeHint =
        nsChangeHint(67108864);
    pub const nsChangeHint_nsChangeHint_AddOrRemoveTransform:
              root::nsChangeHint =
        nsChangeHint(134217728);
    pub const nsChangeHint_nsChangeHint_CSSOverflowChange: root::nsChangeHint
              =
        nsChangeHint(268435456);
    pub const nsChangeHint_nsChangeHint_UpdateWidgetProperties:
              root::nsChangeHint =
        nsChangeHint(536870912);
    pub const nsChangeHint_nsChangeHint_AllHints: root::nsChangeHint =
        nsChangeHint(1073741823);
    impl ::std::ops::BitOr<root::nsChangeHint> for root::nsChangeHint {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self { nsChangeHint(self.0 | other.0) }
    }
    impl ::std::ops::BitOrAssign for root::nsChangeHint {
        #[inline]
        fn bitor_assign(&mut self, rhs: root::nsChangeHint) {
            self.0 |= rhs.0;
        }
    }
    impl ::std::ops::BitAnd<root::nsChangeHint> for root::nsChangeHint {
        type
        Output
        =
        Self;
        #[inline]
        fn bitand(self, other: Self) -> Self {
            nsChangeHint(self.0 & other.0)
        }
    }
    impl ::std::ops::BitAndAssign for root::nsChangeHint {
        #[inline]
        fn bitand_assign(&mut self, rhs: root::nsChangeHint) {
            self.0 &= rhs.0;
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct nsChangeHint(pub u32);
    pub const nsRestyleHint_eRestyle_Self: root::nsRestyleHint =
        nsRestyleHint(1);
    pub const nsRestyleHint_eRestyle_SomeDescendants: root::nsRestyleHint =
        nsRestyleHint(2);
    pub const nsRestyleHint_eRestyle_Subtree: root::nsRestyleHint =
        nsRestyleHint(4);
    pub const nsRestyleHint_eRestyle_LaterSiblings: root::nsRestyleHint =
        nsRestyleHint(8);
    pub const nsRestyleHint_eRestyle_CSSTransitions: root::nsRestyleHint =
        nsRestyleHint(16);
    pub const nsRestyleHint_eRestyle_CSSAnimations: root::nsRestyleHint =
        nsRestyleHint(32);
    pub const nsRestyleHint_eRestyle_StyleAttribute: root::nsRestyleHint =
        nsRestyleHint(64);
    pub const nsRestyleHint_eRestyle_StyleAttribute_Animations:
              root::nsRestyleHint =
        nsRestyleHint(128);
    pub const nsRestyleHint_eRestyle_Force: root::nsRestyleHint =
        nsRestyleHint(256);
    pub const nsRestyleHint_eRestyle_ForceDescendants: root::nsRestyleHint =
        nsRestyleHint(512);
    pub const nsRestyleHint_eRestyle_AllHintsWithAnimations:
              root::nsRestyleHint =
        nsRestyleHint(176);
    impl ::std::ops::BitOr<root::nsRestyleHint> for root::nsRestyleHint {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            nsRestyleHint(self.0 | other.0)
        }
    }
    impl ::std::ops::BitOrAssign for root::nsRestyleHint {
        #[inline]
        fn bitor_assign(&mut self, rhs: root::nsRestyleHint) {
            self.0 |= rhs.0;
        }
    }
    impl ::std::ops::BitAnd<root::nsRestyleHint> for root::nsRestyleHint {
        type
        Output
        =
        Self;
        #[inline]
        fn bitand(self, other: Self) -> Self {
            nsRestyleHint(self.0 & other.0)
        }
    }
    impl ::std::ops::BitAndAssign for root::nsRestyleHint {
        #[inline]
        fn bitand_assign(&mut self, rhs: root::nsRestyleHint) {
            self.0 &= rhs.0;
        }
    }
    #[repr(C)]
    /**
 * |nsRestyleHint| is a bitfield for the result of
 * |HasStateDependentStyle| and |HasAttributeDependentStyle|.  When no
 * restyling is necessary, use |nsRestyleHint(0)|.
 *
 * Without eRestyle_Force or eRestyle_ForceDescendants, the restyling process
 * can stop processing at a frame when it detects no style changes and it is
 * known that the styles of the subtree beneath it will not change, leaving
 * the old style context on the frame.  eRestyle_Force can be used to skip this
 * optimization on a frame, and to force its new style context to be used.
 *
 * Similarly, eRestyle_ForceDescendants will cause the frame and all of its
 * descendants to be traversed and for the new style contexts that are created
 * to be set on the frames.
 *
 * NOTE: When adding new restyle hints, please also add them to
 * RestyleManager::RestyleHintToString.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct nsRestyleHint(pub u32);
    #[repr(u32)]
    /**
 * Return status for event processors.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsEventStatus {
        nsEventStatus_eIgnore = 0,
        nsEventStatus_eConsumeNoDefault = 1,
        nsEventStatus_eConsumeDoDefault = 2,
        nsEventStatus_eSentinel = 3,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct pixman_region32_data {
        pub size: ::std::os::raw::c_long,
        pub numRects: ::std::os::raw::c_long,
    }
    #[test]
    fn bindgen_test_layout_pixman_region32_data() {
        assert_eq!(::std::mem::size_of::<pixman_region32_data>() , 16usize ,
                   concat ! (
                   "Size of: " , stringify ! ( pixman_region32_data ) ));
        assert_eq! (::std::mem::align_of::<pixman_region32_data>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( pixman_region32_data ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const pixman_region32_data ) ) . size as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    pixman_region32_data ) , "::" , stringify ! ( size ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const pixman_region32_data ) ) . numRects
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    pixman_region32_data ) , "::" , stringify ! ( numRects )
                    ));
    }
    impl Clone for pixman_region32_data {
        fn clone(&self) -> Self { *self }
    }
    pub type pixman_region32_data_t = root::pixman_region32_data;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct pixman_box32 {
        pub x1: i32,
        pub y1: i32,
        pub x2: i32,
        pub y2: i32,
    }
    #[test]
    fn bindgen_test_layout_pixman_box32() {
        assert_eq!(::std::mem::size_of::<pixman_box32>() , 16usize , concat !
                   ( "Size of: " , stringify ! ( pixman_box32 ) ));
        assert_eq! (::std::mem::align_of::<pixman_box32>() , 4usize , concat !
                    ( "Alignment of " , stringify ! ( pixman_box32 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const pixman_box32 ) ) . x1 as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( pixman_box32 ) ,
                    "::" , stringify ! ( x1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const pixman_box32 ) ) . y1 as * const _ as
                    usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( pixman_box32 ) ,
                    "::" , stringify ! ( y1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const pixman_box32 ) ) . x2 as * const _ as
                    usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( pixman_box32 ) ,
                    "::" , stringify ! ( x2 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const pixman_box32 ) ) . y2 as * const _ as
                    usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( pixman_box32 ) ,
                    "::" , stringify ! ( y2 ) ));
    }
    impl Clone for pixman_box32 {
        fn clone(&self) -> Self { *self }
    }
    pub type pixman_box32_t = root::pixman_box32;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct pixman_region32 {
        pub extents: root::pixman_box32_t,
        pub data: *mut root::pixman_region32_data_t,
    }
    #[test]
    fn bindgen_test_layout_pixman_region32() {
        assert_eq!(::std::mem::size_of::<pixman_region32>() , 24usize , concat
                   ! ( "Size of: " , stringify ! ( pixman_region32 ) ));
        assert_eq! (::std::mem::align_of::<pixman_region32>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( pixman_region32 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const pixman_region32 ) ) . extents as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( pixman_region32 ) ,
                    "::" , stringify ! ( extents ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const pixman_region32 ) ) . data as * const
                    _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( pixman_region32 ) ,
                    "::" , stringify ! ( data ) ));
    }
    impl Clone for pixman_region32 {
        fn clone(&self) -> Self { *self }
    }
    pub type pixman_region32_t = root::pixman_region32;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum VisitSide { TOP = 0, BOTTOM = 1, LEFT = 2, RIGHT = 3, }
    /**
 * Presentation shell interface. Presentation shells are the
 * controlling point for managing the presentation of a document. The
 * presentation shell holds a live reference to the document, the
 * presentation context, the style manager, the style set and the root
 * frame. <p>
 *
 * When this object is Release'd, it will release the document, the
 * presentation context, the style manager, the style set and the root
 * frame.
 */
    #[repr(C)]
    pub struct nsIPresShell {
        pub _base: root::nsISupports,
        pub mDocument: root::nsCOMPtr,
        pub mPresContext: root::RefPtr<root::nsPresContext>,
        pub mStyleSet: root::mozilla::StyleSetHandle,
        pub mFrameConstructor: *mut root::nsCSSFrameConstructor,
        pub mViewManager: *mut root::nsViewManager,
        pub mFrameArena: root::nsPresArena,
        pub mSelection: root::RefPtr<root::nsFrameSelection>,
        pub mFrameManager: *mut root::nsFrameManagerBase,
        pub mForwardingContainer: u64,
        pub mDocAccessible: *mut root::mozilla::a11y::DocAccessible,
        pub mReflowContinueTimer: root::nsCOMPtr,
        pub mPaintCount: u64,
        pub mScrollPositionClampingScrollPortSize: root::nsSize,
        pub mAutoWeakFrames: *mut root::AutoWeakFrame,
        pub mWeakFrames: [u64; 5usize],
        pub mCanvasBackgroundColor: root::nscolor,
        pub mResolution: [u32; 2usize],
        pub mSelectionFlags: i16,
        pub mRenderFlags: root::nsIPresShell_RenderFlags,
        pub _bitfield_1: [u8; 2usize],
        pub mPresShellId: u32,
        pub mFontSizeInflationEmPerLine: u32,
        pub mFontSizeInflationMinTwips: u32,
        pub mFontSizeInflationLineThreshold: u32,
        pub mFontSizeInflationForceEnabled: bool,
        pub mFontSizeInflationDisabledInMasterProcess: bool,
        pub mFontSizeInflationEnabled: bool,
        pub mFontSizeInflationEnabledIsDirty: bool,
        pub mPaintingIsFrozen: bool,
        pub mIsNeverPainting: bool,
        pub mInFlush: bool,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIPresShell_COMTypeInfo {
        pub _address: u8,
    }
    pub type nsIPresShell_FocusTarget = root::mozilla::layers::FocusTarget;
    pub type nsIPresShell_LayerManager = root::mozilla::layers::LayerManager;
    pub type nsIPresShell_SourceSurface = root::mozilla::gfx::SourceSurface;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_eRenderFlag {
        STATE_IGNORING_VIEWPORT_SCROLLING = 1,
        STATE_DRAWWINDOW_NOT_FLUSHING = 2,
    }
    pub type nsIPresShell_RenderFlags = u8;
    #[repr(u32)]
    /**
   * Gets nearest scrollable frame from the specified content node. The frame
   * is scrollable with overflow:scroll or overflow:auto in some direction when
   * aDirection is eEither.  Otherwise, this returns a nearest frame that is
   * scrollable in the specified direction.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_ScrollDirection {
        eHorizontal = 0,
        eVertical = 1,
        eEither = 2,
    }
    #[repr(u32)]
    /**
   * Tell the pres shell that a frame needs to be marked dirty and needs
   * Reflow.  It's OK if this is an ancestor of the frame needing reflow as
   * long as the ancestor chain between them doesn't cross a reflow root.
   *
   * The bit to add should be NS_FRAME_IS_DIRTY, NS_FRAME_HAS_DIRTY_CHILDREN
   * or nsFrameState(0); passing 0 means that dirty bits won't be set on the
   * frame or its ancestors/descendants, but that intrinsic widths will still
   * be marked dirty.  Passing aIntrinsicDirty = eResize and aBitToAdd = 0
   * would result in no work being done, so don't do that.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_IntrinsicDirty {
        eResize = 0,
        eTreeChange = 1,
        eStyleChange = 2,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_ReflowRootHandling {
        ePositionOrSizeChange = 0,
        eNoPositionOrSizeChange = 1,
        eInferFromBitToAdd = 2,
    }
    pub const nsIPresShell_SCROLL_TOP: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_TOP;
    pub const nsIPresShell_SCROLL_BOTTOM: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_BOTTOM;
    pub const nsIPresShell_SCROLL_LEFT: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_TOP;
    pub const nsIPresShell_SCROLL_RIGHT: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_BOTTOM;
    pub const nsIPresShell_SCROLL_CENTER: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_CENTER;
    pub const nsIPresShell_SCROLL_MINIMUM: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_MINIMUM;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell__bindgen_ty_1 {
        SCROLL_TOP = 0,
        SCROLL_BOTTOM = 100,
        SCROLL_CENTER = 50,
        SCROLL_MINIMUM = -1,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_WhenToScroll {
        SCROLL_ALWAYS = 0,
        SCROLL_IF_NOT_VISIBLE = 1,
        SCROLL_IF_NOT_FULLY_VISIBLE = 2,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIPresShell_ScrollAxis {
        pub _bindgen_opaque_blob: u32,
    }
    #[test]
    fn bindgen_test_layout_nsIPresShell_ScrollAxis() {
        assert_eq!(::std::mem::size_of::<nsIPresShell_ScrollAxis>() , 4usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIPresShell_ScrollAxis ) ));
        assert_eq! (::std::mem::align_of::<nsIPresShell_ScrollAxis>() , 4usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsIPresShell_ScrollAxis )
                    ));
    }
    impl Clone for nsIPresShell_ScrollAxis {
        fn clone(&self) -> Self { *self }
    }
    pub const nsIPresShell_SCROLL_FIRST_ANCESTOR_ONLY:
              root::nsIPresShell__bindgen_ty_2 =
        nsIPresShell__bindgen_ty_2::SCROLL_FIRST_ANCESTOR_ONLY;
    pub const nsIPresShell_SCROLL_OVERFLOW_HIDDEN:
              root::nsIPresShell__bindgen_ty_2 =
        nsIPresShell__bindgen_ty_2::SCROLL_OVERFLOW_HIDDEN;
    pub const nsIPresShell_SCROLL_NO_PARENT_FRAMES:
              root::nsIPresShell__bindgen_ty_2 =
        nsIPresShell__bindgen_ty_2::SCROLL_NO_PARENT_FRAMES;
    pub const nsIPresShell_SCROLL_SMOOTH: root::nsIPresShell__bindgen_ty_2 =
        nsIPresShell__bindgen_ty_2::SCROLL_SMOOTH;
    pub const nsIPresShell_SCROLL_SMOOTH_AUTO:
              root::nsIPresShell__bindgen_ty_2 =
        nsIPresShell__bindgen_ty_2::SCROLL_SMOOTH_AUTO;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell__bindgen_ty_2 {
        SCROLL_FIRST_ANCESTOR_ONLY = 1,
        SCROLL_OVERFLOW_HIDDEN = 2,
        SCROLL_NO_PARENT_FRAMES = 4,
        SCROLL_SMOOTH = 8,
        SCROLL_SMOOTH_AUTO = 16,
    }
    pub const nsIPresShell_RENDER_IS_UNTRUSTED:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_IS_UNTRUSTED;
    pub const nsIPresShell_RENDER_IGNORE_VIEWPORT_SCROLLING:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_IGNORE_VIEWPORT_SCROLLING;
    pub const nsIPresShell_RENDER_CARET: root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_CARET;
    pub const nsIPresShell_RENDER_USE_WIDGET_LAYERS:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_USE_WIDGET_LAYERS;
    pub const nsIPresShell_RENDER_ASYNC_DECODE_IMAGES:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_ASYNC_DECODE_IMAGES;
    pub const nsIPresShell_RENDER_DOCUMENT_RELATIVE:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_DOCUMENT_RELATIVE;
    pub const nsIPresShell_RENDER_DRAWWINDOW_NOT_FLUSHING:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_DRAWWINDOW_NOT_FLUSHING;
    #[repr(u32)]
    /**
   * Render the document into an arbitrary gfxContext
   * Designed for getting a picture of a document or a piece of a document
   * Note that callers will generally want to call FlushPendingNotifications
   * to get an up-to-date view of the document
   * @param aRect is the region to capture into the offscreen buffer, in the
   * root frame's coordinate system (if aIgnoreViewportScrolling is false)
   * or in the root scrolled frame's coordinate system
   * (if aIgnoreViewportScrolling is true). The coordinates are in appunits.
   * @param aFlags see below;
   *   set RENDER_IS_UNTRUSTED if the contents may be passed to malicious
   * agents. E.g. we might choose not to paint the contents of sensitive widgets
   * such as the file name in a file upload widget, and we might choose not
   * to paint themes.
   *   set RENDER_IGNORE_VIEWPORT_SCROLLING to ignore
   * clipping and scrollbar painting due to scrolling in the viewport
   *   set RENDER_CARET to draw the caret if one would be visible
   * (by default the caret is never drawn)
   *   set RENDER_USE_LAYER_MANAGER to force rendering to go through
   * the layer manager for the window. This may be unexpectedly slow
   * (if the layer manager must read back data from the GPU) or low-quality
   * (if the layer manager reads back pixel data and scales it
   * instead of rendering using the appropriate scaling). It may also
   * slow everything down if the area rendered does not correspond to the
   * normal visible area of the window.
   *   set RENDER_ASYNC_DECODE_IMAGES to avoid having images synchronously
   * decoded during rendering.
   * (by default images decode synchronously with RenderDocument)
   *   set RENDER_DOCUMENT_RELATIVE to render the document as if there has been
   * no scrolling and interpret |aRect| relative to the document instead of the
   * CSS viewport. Only considered if RENDER_IGNORE_VIEWPORT_SCROLLING is set
   * or the document is in ignore viewport scrolling mode
   * (nsIPresShell::SetIgnoreViewportScrolling/IgnoringViewportScrolling).
   * @param aBackgroundColor a background color to render onto
   * @param aRenderedContext the gfxContext to render to. We render so that
   * one CSS pixel in the source document is rendered to one unit in the current
   * transform.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell__bindgen_ty_3 {
        RENDER_IS_UNTRUSTED = 1,
        RENDER_IGNORE_VIEWPORT_SCROLLING = 2,
        RENDER_CARET = 4,
        RENDER_USE_WIDGET_LAYERS = 8,
        RENDER_ASYNC_DECODE_IMAGES = 16,
        RENDER_DOCUMENT_RELATIVE = 32,
        RENDER_DRAWWINDOW_NOT_FLUSHING = 64,
    }
    pub const nsIPresShell_RENDER_IS_IMAGE: root::nsIPresShell__bindgen_ty_4 =
        nsIPresShell__bindgen_ty_4::RENDER_IS_IMAGE;
    pub const nsIPresShell_RENDER_AUTO_SCALE: root::nsIPresShell__bindgen_ty_4
              =
        nsIPresShell__bindgen_ty_4::RENDER_AUTO_SCALE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell__bindgen_ty_4 {
        RENDER_IS_IMAGE = 256,
        RENDER_AUTO_SCALE = 128,
    }
    pub const nsIPresShell_FORCE_DRAW: root::nsIPresShell__bindgen_ty_5 =
        nsIPresShell__bindgen_ty_5::FORCE_DRAW;
    pub const nsIPresShell_ADD_FOR_SUBDOC: root::nsIPresShell__bindgen_ty_5 =
        nsIPresShell__bindgen_ty_5::ADD_FOR_SUBDOC;
    pub const nsIPresShell_APPEND_UNSCROLLED_ONLY:
              root::nsIPresShell__bindgen_ty_5 =
        nsIPresShell__bindgen_ty_5::APPEND_UNSCROLLED_ONLY;
    #[repr(u32)]
    /**
   * Add a solid color item to the bottom of aList with frame aFrame and bounds
   * aBounds. Checks first if this needs to be done by checking if aFrame is a
   * canvas frame (if the FORCE_DRAW flag is passed then this check is skipped).
   * aBackstopColor is composed behind the background color of the canvas, it is
   * transparent by default.
   * We attempt to make the background color part of the scrolled canvas (to reduce
   * transparent layers), and if async scrolling is enabled (and the background
   * is opaque) then we add a second, unscrolled item to handle the checkerboarding
   * case.
   * ADD_FOR_SUBDOC shoud be specified when calling this for a subdocument, and
   * LayoutUseContainersForRootFrame might cause the whole list to be scrolled. In
   * that case the second unscrolled item will be elided.
   * APPEND_UNSCROLLED_ONLY only attempts to add the unscrolled item, so that we
   * can add it manually after LayoutUseContainersForRootFrame has built the
   * scrolling ContainerLayer.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell__bindgen_ty_5 {
        FORCE_DRAW = 1,
        ADD_FOR_SUBDOC = 2,
        APPEND_UNSCROLLED_ONLY = 4,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIPresShell_PointerCaptureInfo {
        pub mPendingContent: root::nsCOMPtr,
        pub mOverrideContent: root::nsCOMPtr,
    }
    #[test]
    fn bindgen_test_layout_nsIPresShell_PointerCaptureInfo() {
        assert_eq!(::std::mem::size_of::<nsIPresShell_PointerCaptureInfo>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( nsIPresShell_PointerCaptureInfo
                   ) ));
        assert_eq! (::std::mem::align_of::<nsIPresShell_PointerCaptureInfo>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsIPresShell_PointerCaptureInfo ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell_PointerCaptureInfo ) ) .
                    mPendingContent as * const _ as usize } , 0usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsIPresShell_PointerCaptureInfo ) , "::" , stringify ! (
                    mPendingContent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell_PointerCaptureInfo ) ) .
                    mOverrideContent as * const _ as usize } , 8usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsIPresShell_PointerCaptureInfo ) , "::" , stringify ! (
                    mOverrideContent ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIPresShell_PointerInfo {
        pub mPointerType: u16,
        pub mActiveState: bool,
        pub mPrimaryState: bool,
        pub mPreventMouseEventByContent: bool,
    }
    #[test]
    fn bindgen_test_layout_nsIPresShell_PointerInfo() {
        assert_eq!(::std::mem::size_of::<nsIPresShell_PointerInfo>() , 6usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsIPresShell_PointerInfo ) ));
        assert_eq! (::std::mem::align_of::<nsIPresShell_PointerInfo>() ,
                    2usize , concat ! (
                    "Alignment of " , stringify ! ( nsIPresShell_PointerInfo )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell_PointerInfo ) ) .
                    mPointerType as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsIPresShell_PointerInfo ) , "::" , stringify ! (
                    mPointerType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell_PointerInfo ) ) .
                    mActiveState as * const _ as usize } , 2usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsIPresShell_PointerInfo ) , "::" , stringify ! (
                    mActiveState ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell_PointerInfo ) ) .
                    mPrimaryState as * const _ as usize } , 3usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsIPresShell_PointerInfo ) , "::" , stringify ! (
                    mPrimaryState ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell_PointerInfo ) ) .
                    mPreventMouseEventByContent as * const _ as usize } ,
                    4usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsIPresShell_PointerInfo ) , "::" , stringify ! (
                    mPreventMouseEventByContent ) ));
    }
    impl Clone for nsIPresShell_PointerInfo {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_PaintFlags {
        PAINT_LAYERS = 1,
        PAINT_COMPOSITE = 2,
        PAINT_SYNC_DECODE_IMAGES = 4,
    }
    #[repr(u32)]
    /**
   * Ensures that the refresh driver is running, and schedules a view
   * manager flush on the next tick.
   *
   * @param aType PAINT_DELAYED_COMPRESS : Schedule a paint to be executed after a delay, and
   * put FrameLayerBuilder in 'compressed' mode that avoids short cut optimizations.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_PaintType {
        PAINT_DEFAULT = 0,
        PAINT_DELAYED_COMPRESS = 1,
    }
    extern "C" {
        #[link_name = "_ZN12nsIPresShell12gCaptureInfoE"]
        pub static mut nsIPresShell_gCaptureInfo: root::CapturingContentInfo;
    }
    extern "C" {
        #[link_name = "_ZN12nsIPresShell14gKeyDownTargetE"]
        pub static mut nsIPresShell_gKeyDownTarget: *mut root::nsIContent;
    }
    #[test]
    fn bindgen_test_layout_nsIPresShell() {
        assert_eq!(::std::mem::size_of::<nsIPresShell>() , 5384usize , concat
                   ! ( "Size of: " , stringify ! ( nsIPresShell ) ));
        assert_eq! (::std::mem::align_of::<nsIPresShell>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsIPresShell ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mDocument as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mDocument ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mPresContext as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mPresContext ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mStyleSet as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mStyleSet ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mFrameConstructor
                    as * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFrameConstructor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mViewManager as *
                    const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mViewManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mFrameArena as *
                    const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFrameArena ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mSelection as *
                    const _ as usize } , 5232usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mSelection ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mFrameManager as *
                    const _ as usize } , 5240usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFrameManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mForwardingContainer as * const _ as usize } , 5248usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mForwardingContainer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mDocAccessible as
                    * const _ as usize } , 5256usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mDocAccessible ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mReflowContinueTimer as * const _ as usize } , 5264usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mReflowContinueTimer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mPaintCount as *
                    const _ as usize } , 5272usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mPaintCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mScrollPositionClampingScrollPortSize as * const _ as
                    usize } , 5280usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mScrollPositionClampingScrollPortSize
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mAutoWeakFrames as
                    * const _ as usize } , 5288usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mAutoWeakFrames ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mWeakFrames as *
                    const _ as usize } , 5296usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mWeakFrames ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mCanvasBackgroundColor as * const _ as usize } , 5336usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mCanvasBackgroundColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mResolution as *
                    const _ as usize } , 5340usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mResolution ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mSelectionFlags as
                    * const _ as usize } , 5348usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mSelectionFlags ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mRenderFlags as *
                    const _ as usize } , 5350usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mRenderFlags ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mPresShellId as *
                    const _ as usize } , 5356usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mPresShellId ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mFontSizeInflationEmPerLine as * const _ as usize } ,
                    5360usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFontSizeInflationEmPerLine ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mFontSizeInflationMinTwips as * const _ as usize } ,
                    5364usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFontSizeInflationMinTwips ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mFontSizeInflationLineThreshold as * const _ as usize } ,
                    5368usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFontSizeInflationLineThreshold ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mFontSizeInflationForceEnabled as * const _ as usize } ,
                    5372usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFontSizeInflationForceEnabled ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mFontSizeInflationDisabledInMasterProcess as * const _ as
                    usize } , 5373usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! (
                    mFontSizeInflationDisabledInMasterProcess ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mFontSizeInflationEnabled as * const _ as usize } ,
                    5374usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFontSizeInflationEnabled ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mFontSizeInflationEnabledIsDirty as * const _ as usize } ,
                    5375usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFontSizeInflationEnabledIsDirty )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mPaintingIsFrozen
                    as * const _ as usize } , 5376usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mPaintingIsFrozen ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mIsNeverPainting
                    as * const _ as usize } , 5377usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mIsNeverPainting ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mInFlush as *
                    const _ as usize } , 5378usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mInFlush ) ));
    }
    impl nsIPresShell {
        #[inline]
        pub fn mDidInitialize(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 1u64 as u16;
            let val = (unit_field_val & mask) >> 0usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mDidInitialize(&mut self, val: bool) {
            let mask = 1u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 0usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mIsDestroying(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 2u64 as u16;
            let val = (unit_field_val & mask) >> 1usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsDestroying(&mut self, val: bool) {
            let mask = 2u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 1usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mIsReflowing(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 4u64 as u16;
            let val = (unit_field_val & mask) >> 2usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsReflowing(&mut self, val: bool) {
            let mask = 4u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 2usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mPaintingSuppressed(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 8u64 as u16;
            let val = (unit_field_val & mask) >> 3usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mPaintingSuppressed(&mut self, val: bool) {
            let mask = 8u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 3usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mIsActive(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 16u64 as u16;
            let val = (unit_field_val & mask) >> 4usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsActive(&mut self, val: bool) {
            let mask = 16u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 4usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mFrozen(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 32u64 as u16;
            let val = (unit_field_val & mask) >> 5usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mFrozen(&mut self, val: bool) {
            let mask = 32u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 5usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mIsFirstPaint(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 64u64 as u16;
            let val = (unit_field_val & mask) >> 6usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsFirstPaint(&mut self, val: bool) {
            let mask = 64u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 6usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mObservesMutationsForPrint(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 128u64 as u16;
            let val = (unit_field_val & mask) >> 7usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mObservesMutationsForPrint(&mut self, val: bool) {
            let mask = 128u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 7usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mSuppressInterruptibleReflows(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 256u64 as u16;
            let val = (unit_field_val & mask) >> 8usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mSuppressInterruptibleReflows(&mut self, val: bool) {
            let mask = 256u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 8usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mScrollPositionClampingScrollPortSizeSet(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 512u64 as u16;
            let val = (unit_field_val & mask) >> 9usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mScrollPositionClampingScrollPortSizeSet(&mut self,
                                                            val: bool) {
            let mask = 512u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 9usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mNeedLayoutFlush(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 1024u64 as u16;
            let val = (unit_field_val & mask) >> 10usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mNeedLayoutFlush(&mut self, val: bool) {
            let mask = 1024u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 10usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mNeedStyleFlush(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 2048u64 as u16;
            let val = (unit_field_val & mask) >> 11usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mNeedStyleFlush(&mut self, val: bool) {
            let mask = 2048u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 11usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mObservingStyleFlushes(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 4096u64 as u16;
            let val = (unit_field_val & mask) >> 12usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mObservingStyleFlushes(&mut self, val: bool) {
            let mask = 4096u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 12usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mObservingLayoutFlushes(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 8192u64 as u16;
            let val = (unit_field_val & mask) >> 13usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mObservingLayoutFlushes(&mut self, val: bool) {
            let mask = 8192u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 13usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mNeedThrottledAnimationFlush(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 16384u64 as u16;
            let val = (unit_field_val & mask) >> 14usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mNeedThrottledAnimationFlush(&mut self, val: bool) {
            let mask = 16384u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 14usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn new_bitfield_1(mDidInitialize: bool, mIsDestroying: bool,
                              mIsReflowing: bool, mPaintingSuppressed: bool,
                              mIsActive: bool, mFrozen: bool,
                              mIsFirstPaint: bool,
                              mObservesMutationsForPrint: bool,
                              mSuppressInterruptibleReflows: bool,
                              mScrollPositionClampingScrollPortSizeSet: bool,
                              mNeedLayoutFlush: bool, mNeedStyleFlush: bool,
                              mObservingStyleFlushes: bool,
                              mObservingLayoutFlushes: bool,
                              mNeedThrottledAnimationFlush: bool) -> u16 {
            ({
                 ({
                      ({
                           ({
                                ({
                                     ({
                                          ({
                                               ({
                                                    ({
                                                         ({
                                                              ({
                                                                   ({
                                                                        ({
                                                                             ({
                                                                                  ({
                                                                                       0
                                                                                   }
                                                                                       |
                                                                                       ((mDidInitialize
                                                                                             as
                                                                                             u8
                                                                                             as
                                                                                             u16)
                                                                                            <<
                                                                                            0usize)
                                                                                           &
                                                                                           (1u64
                                                                                                as
                                                                                                u16))
                                                                              }
                                                                                  |
                                                                                  ((mIsDestroying
                                                                                        as
                                                                                        u8
                                                                                        as
                                                                                        u16)
                                                                                       <<
                                                                                       1usize)
                                                                                      &
                                                                                      (2u64
                                                                                           as
                                                                                           u16))
                                                                         } |
                                                                             ((mIsReflowing
                                                                                   as
                                                                                   u8
                                                                                   as
                                                                                   u16)
                                                                                  <<
                                                                                  2usize)
                                                                                 &
                                                                                 (4u64
                                                                                      as
                                                                                      u16))
                                                                    } |
                                                                        ((mPaintingSuppressed
                                                                              as
                                                                              u8
                                                                              as
                                                                              u16)
                                                                             <<
                                                                             3usize)
                                                                            &
                                                                            (8u64
                                                                                 as
                                                                                 u16))
                                                               } |
                                                                   ((mIsActive
                                                                         as u8
                                                                         as
                                                                         u16)
                                                                        <<
                                                                        4usize)
                                                                       &
                                                                       (16u64
                                                                            as
                                                                            u16))
                                                          } |
                                                              ((mFrozen as u8
                                                                    as u16) <<
                                                                   5usize) &
                                                                  (32u64 as
                                                                       u16))
                                                     } |
                                                         ((mIsFirstPaint as u8
                                                               as u16) <<
                                                              6usize) &
                                                             (64u64 as u16))
                                                } |
                                                    ((mObservesMutationsForPrint
                                                          as u8 as u16) <<
                                                         7usize) &
                                                        (128u64 as u16))
                                           } |
                                               ((mSuppressInterruptibleReflows
                                                     as u8 as u16) << 8usize)
                                                   & (256u64 as u16))
                                      } |
                                          ((mScrollPositionClampingScrollPortSizeSet
                                                as u8 as u16) << 9usize) &
                                              (512u64 as u16))
                                 } |
                                     ((mNeedLayoutFlush as u8 as u16) <<
                                          10usize) & (1024u64 as u16))
                            } |
                                ((mNeedStyleFlush as u8 as u16) << 11usize) &
                                    (2048u64 as u16))
                       } |
                           ((mObservingStyleFlushes as u8 as u16) << 12usize)
                               & (4096u64 as u16))
                  } |
                      ((mObservingLayoutFlushes as u8 as u16) << 13usize) &
                          (8192u64 as u16))
             } |
                 ((mNeedThrottledAnimationFlush as u8 as u16) << 14usize) &
                     (16384u64 as u16))
        }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum WeakMapTraceKind {
        DoNotTraceWeakMaps = 0,
        ExpandWeakMaps = 1,
        TraceWeakMapValues = 2,
        TraceWeakMapKeysValues = 3,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSValueTag {
        JSVAL_TAG_MAX_DOUBLE = 131056,
        JSVAL_TAG_INT32 = 131057,
        JSVAL_TAG_UNDEFINED = 131058,
        JSVAL_TAG_NULL = 131059,
        JSVAL_TAG_BOOLEAN = 131060,
        JSVAL_TAG_MAGIC = 131061,
        JSVAL_TAG_STRING = 131062,
        JSVAL_TAG_SYMBOL = 131063,
        JSVAL_TAG_PRIVATE_GCTHING = 131064,
        JSVAL_TAG_OBJECT = 131068,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSWhyMagic {
        JS_ELEMENTS_HOLE = 0,
        JS_NO_ITER_VALUE = 1,
        JS_GENERATOR_CLOSING = 2,
        JS_NO_CONSTANT = 3,
        JS_THIS_POISON = 4,
        JS_ARG_POISON = 5,
        JS_SERIALIZE_NO_NODE = 6,
        JS_LAZY_ARGUMENTS = 7,
        JS_OPTIMIZED_ARGUMENTS = 8,
        JS_IS_CONSTRUCTING = 9,
        JS_BLOCK_NEEDS_CLONE = 10,
        JS_HASH_KEY_EMPTY = 11,
        JS_ION_ERROR = 12,
        JS_ION_BAILOUT = 13,
        JS_OPTIMIZED_OUT = 14,
        JS_UNINITIALIZED_LEXICAL = 15,
        JS_GENERIC_MAGIC = 16,
        JS_WHY_MAGIC_COUNT = 17,
    }
    /**
 * This structure precedes the string buffers "we" allocate.  It may be the
 * case that nsTAString::mData does not point to one of these special
 * buffers.  The mFlags member variable distinguishes the buffer type.
 *
 * When this header is in use, it enables reference counting, and capacity
 * tracking.  NOTE: A string buffer can be modified only if its reference
 * count is 1.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStringBuffer {
        pub mRefCount: u32,
        pub mStorageSize: u32,
    }
    #[test]
    fn bindgen_test_layout_nsStringBuffer() {
        assert_eq!(::std::mem::size_of::<nsStringBuffer>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( nsStringBuffer ) ));
        assert_eq! (::std::mem::align_of::<nsStringBuffer>() , 4usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStringBuffer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStringBuffer ) ) . mRefCount as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStringBuffer ) ,
                    "::" , stringify ! ( mRefCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStringBuffer ) ) . mStorageSize as
                    * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStringBuffer ) ,
                    "::" , stringify ! ( mStorageSize ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIAtom {
        pub _base: root::nsISupports,
        pub _bitfield_1: u32,
        pub mHash: u32,
        /**
   * WARNING! There is an invisible constraint on |mString|: the chars it
   * points to must belong to an nsStringBuffer. This is so that the
   * nsStringBuffer::FromData() calls above are valid.
   */
        pub mString: *mut u16,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIAtom_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIAtom() {
        assert_eq!(::std::mem::size_of::<nsIAtom>() , 24usize , concat ! (
                   "Size of: " , stringify ! ( nsIAtom ) ));
        assert_eq! (::std::mem::align_of::<nsIAtom>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIAtom ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIAtom ) ) . mHash as * const _ as
                    usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIAtom ) , "::" ,
                    stringify ! ( mHash ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIAtom ) ) . mString as * const _ as
                    usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIAtom ) , "::" ,
                    stringify ! ( mString ) ));
    }
    impl Clone for nsIAtom {
        fn clone(&self) -> Self { *self }
    }
    impl nsIAtom {
        #[inline]
        pub fn mLength(&self) -> u32 {
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            let mask = 2147483647u64 as u32;
            let val = (unit_field_val & mask) >> 0usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mLength(&mut self, val: u32) {
            let mask = 2147483647u64 as u32;
            let val = val as u32 as u32;
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 0usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u32>());
            }
        }
        #[inline]
        pub fn mIsStatic(&self) -> u32 {
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            let mask = 2147483648u64 as u32;
            let val = (unit_field_val & mask) >> 31usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mIsStatic(&mut self, val: u32) {
            let mask = 2147483648u64 as u32;
            let val = val as u32 as u32;
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 31usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u32>());
            }
        }
        #[inline]
        pub fn new_bitfield_1(mLength: u32, mIsStatic: u32) -> u32 {
            ({
                 ({ 0 } |
                      ((mLength as u32 as u32) << 0usize) &
                          (2147483647u64 as u32))
             } |
                 ((mIsStatic as u32 as u32) << 31usize) &
                     (2147483648u64 as u32))
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIPrincipal {
        pub _base: root::nsISerializable,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIPrincipal_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIPrincipal() {
        assert_eq!(::std::mem::size_of::<nsIPrincipal>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIPrincipal ) ));
        assert_eq! (::std::mem::align_of::<nsIPrincipal>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsIPrincipal ) ));
    }
    impl Clone for nsIPrincipal {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    pub struct nsWrapperCache__bindgen_vtable(::std::os::raw::c_void);
    /**
 * Class to store the wrapper for an object. This can only be used with objects
 * that only have one non-security wrapper at a time (for an XPCWrappedNative
 * this is usually ensured by setting an explicit parent in the PreCreate hook
 * for the class).
 *
 * An instance of nsWrapperCache can be gotten from an object that implements
 * a wrapper cache by calling QueryInterface on it. Note that this breaks XPCOM
 * rules a bit (this object doesn't derive from nsISupports).
 *
 * The cache can store objects other than wrappers. We allow wrappers to use a
 * separate JSObject to store their state (mostly expandos). If the wrapper is
 * collected and we want to preserve this state we actually store the state
 * object in the cache.
 *
 * The cache can store 2 types of objects:
 *
 *  If WRAPPER_IS_NOT_DOM_BINDING is set (IsDOMBinding() returns false):
 *    - the JSObject of an XPCWrappedNative wrapper
 *
 *  If WRAPPER_IS_NOT_DOM_BINDING is not set (IsDOMBinding() returns true):
 *    - a DOM binding object (regular JS object or proxy)
 *
 * The finalizer for the wrapper clears the cache.
 *
 * A compacting GC can move the wrapper object. Pointers to moved objects are
 * usually found and updated by tracing the heap, however non-preserved wrappers
 * are weak references and are not traced, so another approach is
 * necessary. Instead a class hook (objectMovedOp) is provided that is called
 * when an object is moved and is responsible for ensuring pointers are
 * updated. It does this by calling UpdateWrapper() on the wrapper
 * cache. SetWrapper() asserts that the hook is implemented for any wrapper set.
 *
 * A number of the methods are implemented in nsWrapperCacheInlines.h because we
 * have to include some JS headers that don't play nicely with the rest of the
 * codebase. Include nsWrapperCacheInlines.h if you need to call those methods.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsWrapperCache {
        pub vtable_: *const nsWrapperCache__bindgen_vtable,
        pub mWrapper: *mut root::JSObject,
        pub mFlags: root::nsWrapperCache_FlagsType,
        pub mBoolFlags: u32,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsWrapperCache_COMTypeInfo {
        pub _address: u8,
    }
    pub type nsWrapperCache_FlagsType = u32;
    pub const nsWrapperCache_WRAPPER_BIT_PRESERVED:
              root::nsWrapperCache__bindgen_ty_1 =
        nsWrapperCache__bindgen_ty_1::WRAPPER_BIT_PRESERVED;
    #[repr(u32)]
    /**
   * If this bit is set then we're preserving the wrapper, which in effect ties
   * the lifetime of the JS object stored in the cache to the lifetime of the
   * native object. We rely on the cycle collector to break the cycle that this
   * causes between the native object and the JS object, so it is important that
   * any native object that supports preserving of its wrapper
   * traces/traverses/unlinks the cached JS object (see
   * NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER and
   * NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER).
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsWrapperCache__bindgen_ty_1 { WRAPPER_BIT_PRESERVED = 1, }
    pub const nsWrapperCache_WRAPPER_IS_NOT_DOM_BINDING:
              root::nsWrapperCache__bindgen_ty_2 =
        nsWrapperCache__bindgen_ty_2::WRAPPER_IS_NOT_DOM_BINDING;
    #[repr(u32)]
    /**
   * If this bit is set then the wrapper for the native object is not a DOM
   * binding.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsWrapperCache__bindgen_ty_2 { WRAPPER_IS_NOT_DOM_BINDING = 2, }
    pub const nsWrapperCache_kWrapperFlagsMask:
              root::nsWrapperCache__bindgen_ty_3 =
        nsWrapperCache__bindgen_ty_3::kWrapperFlagsMask;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsWrapperCache__bindgen_ty_3 { kWrapperFlagsMask = 3, }
    #[test]
    fn bindgen_test_layout_nsWrapperCache() {
        assert_eq!(::std::mem::size_of::<nsWrapperCache>() , 24usize , concat
                   ! ( "Size of: " , stringify ! ( nsWrapperCache ) ));
        assert_eq! (::std::mem::align_of::<nsWrapperCache>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsWrapperCache ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsWrapperCache ) ) . mWrapper as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsWrapperCache ) ,
                    "::" , stringify ! ( mWrapper ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsWrapperCache ) ) . mFlags as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsWrapperCache ) ,
                    "::" , stringify ! ( mFlags ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsWrapperCache ) ) . mBoolFlags as *
                    const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsWrapperCache ) ,
                    "::" , stringify ! ( mBoolFlags ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsILoadGroup {
        pub _base: root::nsIRequest,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsILoadGroup_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsILoadGroup() {
        assert_eq!(::std::mem::size_of::<nsILoadGroup>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsILoadGroup ) ));
        assert_eq! (::std::mem::align_of::<nsILoadGroup>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsILoadGroup ) ));
    }
    impl Clone for nsILoadGroup {
        fn clone(&self) -> Self { *self }
    }
    pub type nsLoadFlags = u32;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIRequest {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIRequest_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsIRequest_LOAD_REQUESTMASK: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_REQUESTMASK;
    pub const nsIRequest_LOAD_NORMAL: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_NORMAL;
    pub const nsIRequest_LOAD_BACKGROUND: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_BACKGROUND;
    pub const nsIRequest_LOAD_HTML_OBJECT_DATA: root::nsIRequest__bindgen_ty_1
              =
        nsIRequest__bindgen_ty_1::LOAD_HTML_OBJECT_DATA;
    pub const nsIRequest_INHIBIT_CACHING: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::INHIBIT_CACHING;
    pub const nsIRequest_INHIBIT_PERSISTENT_CACHING:
              root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::INHIBIT_PERSISTENT_CACHING;
    pub const nsIRequest_LOAD_BYPASS_CACHE: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_BYPASS_CACHE;
    pub const nsIRequest_LOAD_FROM_CACHE: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_FROM_CACHE;
    pub const nsIRequest_VALIDATE_ALWAYS: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::VALIDATE_ALWAYS;
    pub const nsIRequest_VALIDATE_NEVER: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::VALIDATE_NEVER;
    pub const nsIRequest_VALIDATE_ONCE_PER_SESSION:
              root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::VALIDATE_ONCE_PER_SESSION;
    pub const nsIRequest_LOAD_ANONYMOUS: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_ANONYMOUS;
    pub const nsIRequest_LOAD_FRESH_CONNECTION: root::nsIRequest__bindgen_ty_1
              =
        nsIRequest__bindgen_ty_1::LOAD_FRESH_CONNECTION;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIRequest__bindgen_ty_1 {
        LOAD_REQUESTMASK = 65535,
        LOAD_NORMAL = 0,
        LOAD_BACKGROUND = 1,
        LOAD_HTML_OBJECT_DATA = 2,
        INHIBIT_CACHING = 128,
        INHIBIT_PERSISTENT_CACHING = 256,
        LOAD_BYPASS_CACHE = 512,
        LOAD_FROM_CACHE = 1024,
        VALIDATE_ALWAYS = 2048,
        VALIDATE_NEVER = 4096,
        VALIDATE_ONCE_PER_SESSION = 8192,
        LOAD_ANONYMOUS = 16384,
        LOAD_FRESH_CONNECTION = 32768,
    }
    #[test]
    fn bindgen_test_layout_nsIRequest() {
        assert_eq!(::std::mem::size_of::<nsIRequest>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIRequest ) ));
        assert_eq! (::std::mem::align_of::<nsIRequest>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIRequest ) ));
    }
    impl Clone for nsIRequest {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIURI {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIURI_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIURI() {
        assert_eq!(::std::mem::size_of::<nsIURI>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIURI ) ));
        assert_eq! (::std::mem::align_of::<nsIURI>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIURI ) ));
    }
    impl Clone for nsIURI {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMNode {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMNode_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsIDOMNode_ELEMENT_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::ELEMENT_NODE;
    pub const nsIDOMNode_ATTRIBUTE_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::ATTRIBUTE_NODE;
    pub const nsIDOMNode_TEXT_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::TEXT_NODE;
    pub const nsIDOMNode_CDATA_SECTION_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::CDATA_SECTION_NODE;
    pub const nsIDOMNode_ENTITY_REFERENCE_NODE: root::nsIDOMNode__bindgen_ty_1
              =
        nsIDOMNode__bindgen_ty_1::ENTITY_REFERENCE_NODE;
    pub const nsIDOMNode_ENTITY_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::ENTITY_NODE;
    pub const nsIDOMNode_PROCESSING_INSTRUCTION_NODE:
              root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::PROCESSING_INSTRUCTION_NODE;
    pub const nsIDOMNode_COMMENT_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::COMMENT_NODE;
    pub const nsIDOMNode_DOCUMENT_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::DOCUMENT_NODE;
    pub const nsIDOMNode_DOCUMENT_TYPE_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::DOCUMENT_TYPE_NODE;
    pub const nsIDOMNode_DOCUMENT_FRAGMENT_NODE:
              root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::DOCUMENT_FRAGMENT_NODE;
    pub const nsIDOMNode_NOTATION_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::NOTATION_NODE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDOMNode__bindgen_ty_1 {
        ELEMENT_NODE = 1,
        ATTRIBUTE_NODE = 2,
        TEXT_NODE = 3,
        CDATA_SECTION_NODE = 4,
        ENTITY_REFERENCE_NODE = 5,
        ENTITY_NODE = 6,
        PROCESSING_INSTRUCTION_NODE = 7,
        COMMENT_NODE = 8,
        DOCUMENT_NODE = 9,
        DOCUMENT_TYPE_NODE = 10,
        DOCUMENT_FRAGMENT_NODE = 11,
        NOTATION_NODE = 12,
    }
    pub const nsIDOMNode_DOCUMENT_POSITION_DISCONNECTED:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_DISCONNECTED;
    pub const nsIDOMNode_DOCUMENT_POSITION_PRECEDING:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_PRECEDING;
    pub const nsIDOMNode_DOCUMENT_POSITION_FOLLOWING:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_FOLLOWING;
    pub const nsIDOMNode_DOCUMENT_POSITION_CONTAINS:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_CONTAINS;
    pub const nsIDOMNode_DOCUMENT_POSITION_CONTAINED_BY:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_CONTAINED_BY;
    pub const nsIDOMNode_DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDOMNode__bindgen_ty_2 {
        DOCUMENT_POSITION_DISCONNECTED = 1,
        DOCUMENT_POSITION_PRECEDING = 2,
        DOCUMENT_POSITION_FOLLOWING = 4,
        DOCUMENT_POSITION_CONTAINS = 8,
        DOCUMENT_POSITION_CONTAINED_BY = 16,
        DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMNode() {
        assert_eq!(::std::mem::size_of::<nsIDOMNode>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIDOMNode ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMNode>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIDOMNode ) ));
    }
    impl Clone for nsIDOMNode {
        fn clone(&self) -> Self { *self }
    }
    pub type nsContentPolicyType = u32;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMDocument {
        _unused: [u8; 0],
    }
    /**
 * An internal interface that abstracts some DOMNode-related parts that both
 * nsIContent and nsIDocument share.  An instance of this interface has a list
 * of nsIContent children and provides access to them.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsINode {
        pub _base: root::mozilla::dom::EventTarget,
        pub mNodeInfo: root::RefPtr<root::mozilla::dom::NodeInfo>,
        pub mParent: *mut root::nsINode,
        pub mNextSibling: *mut root::nsIContent,
        pub mPreviousSibling: *mut root::nsIContent,
        pub mFirstChild: *mut root::nsIContent,
        pub __bindgen_anon_1: root::nsINode__bindgen_ty_1,
        pub mSlots: *mut root::nsINode_nsSlots,
    }
    pub type nsINode_BoxQuadOptions = root::mozilla::dom::BoxQuadOptions;
    pub type nsINode_ConvertCoordinateOptions =
        root::mozilla::dom::ConvertCoordinateOptions;
    pub type nsINode_DOMPoint = root::mozilla::dom::DOMPoint;
    pub type nsINode_DOMPointInit = root::mozilla::dom::DOMPointInit;
    pub type nsINode_DOMQuad = root::mozilla::dom::DOMQuad;
    pub type nsINode_DOMRectReadOnly = root::mozilla::dom::DOMRectReadOnly;
    pub type nsINode_OwningNodeOrString =
        root::mozilla::dom::OwningNodeOrString;
    pub type nsINode_TextOrElementOrDocument =
        root::mozilla::dom::TextOrElementOrDocument;
    pub use self::super::root::mozilla::dom::CallerType as nsINode_CallerType;
    pub type nsINode_ErrorResult = root::mozilla::ErrorResult;
    pub type nsINode_Sequence = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsINode_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsINode_eCONTENT: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eCONTENT;
    pub const nsINode_eDOCUMENT: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eDOCUMENT;
    pub const nsINode_eATTRIBUTE: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eATTRIBUTE;
    pub const nsINode_eTEXT: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eTEXT;
    pub const nsINode_ePROCESSING_INSTRUCTION: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::ePROCESSING_INSTRUCTION;
    pub const nsINode_eCOMMENT: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eCOMMENT;
    pub const nsINode_eHTML_FORM_CONTROL: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eHTML_FORM_CONTROL;
    pub const nsINode_eDOCUMENT_FRAGMENT: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eDOCUMENT_FRAGMENT;
    pub const nsINode_eDATA_NODE: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eDATA_NODE;
    pub const nsINode_eMEDIA: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eMEDIA;
    pub const nsINode_eANIMATION: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eANIMATION;
    pub const nsINode_eFILTER: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eFILTER;
    #[repr(u32)]
    /**
   * Bit-flags to pass (or'ed together) to IsNodeOfType()
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsINode__bindgen_ty_2 {
        eCONTENT = 1,
        eDOCUMENT = 2,
        eATTRIBUTE = 4,
        eTEXT = 8,
        ePROCESSING_INSTRUCTION = 16,
        eCOMMENT = 32,
        eHTML_FORM_CONTROL = 64,
        eDOCUMENT_FRAGMENT = 128,
        eDATA_NODE = 256,
        eMEDIA = 512,
        eANIMATION = 1024,
        eFILTER = 2048,
    }
    #[repr(C)]
    pub struct nsINode_nsSlots__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsINode_nsSlots {
        pub vtable_: *const nsINode_nsSlots__bindgen_vtable,
        /**
     * A list of mutation observers
     */
        pub mMutationObservers: [u64; 2usize],
        /**
     * An object implementing nsIDOMNodeList for this content (childNodes)
     * @see nsIDOMNodeList
     * @see nsGenericHTMLElement::GetChildNodes
     */
        pub mChildNodes: root::RefPtr<root::nsChildContentList>,
        /**
     * Weak reference to this node.  This is cleared by the destructor of
     * nsNodeWeakReference.
     */
        pub mWeakReference: *mut root::nsNodeWeakReference,
        /**
     * Number of descendant nodes in the uncomposed document that have been
     * explicitly set as editable.
     */
        pub mEditableDescendantCount: u32,
    }
    #[test]
    fn bindgen_test_layout_nsINode_nsSlots() {
        assert_eq!(::std::mem::size_of::<nsINode_nsSlots>() , 48usize , concat
                   ! ( "Size of: " , stringify ! ( nsINode_nsSlots ) ));
        assert_eq! (::std::mem::align_of::<nsINode_nsSlots>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsINode_nsSlots ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode_nsSlots ) ) .
                    mMutationObservers as * const _ as usize } , 8usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsINode_nsSlots ) ,
                    "::" , stringify ! ( mMutationObservers ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode_nsSlots ) ) . mChildNodes as
                    * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode_nsSlots ) ,
                    "::" , stringify ! ( mChildNodes ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode_nsSlots ) ) . mWeakReference
                    as * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode_nsSlots ) ,
                    "::" , stringify ! ( mWeakReference ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode_nsSlots ) ) .
                    mEditableDescendantCount as * const _ as usize } , 40usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode_nsSlots ) ,
                    "::" , stringify ! ( mEditableDescendantCount ) ));
    }
    #[repr(u32)]
    /**
   * Boolean flags
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsINode_BooleanFlag {
        NodeHasRenderingObservers = 0,
        IsInDocument = 1,
        ParentIsContent = 2,
        NodeIsElement = 3,
        ElementHasID = 4,
        ElementMayHaveClass = 5,
        ElementMayHaveStyle = 6,
        ElementHasName = 7,
        ElementMayHaveContentEditableAttr = 8,
        NodeIsCommonAncestorForRangeInSelection = 9,
        NodeIsDescendantOfCommonAncestorForRangeInSelection = 10,
        NodeIsCCMarkedRoot = 11,
        NodeIsCCBlackTree = 12,
        NodeIsPurpleRoot = 13,
        ElementHasLockedStyleStates = 14,
        ElementHasPointerLock = 15,
        NodeMayHaveDOMMutationObserver = 16,
        NodeIsContent = 17,
        ElementHasAnimations = 18,
        NodeHasValidDirAttribute = 19,
        NodeHasDirAutoSet = 20,
        NodeHasTextNodeDirectionalityMap = 21,
        NodeAncestorHasDirAuto = 22,
        ElementIsInStyleScope = 23,
        ElementIsScopedStyleRoot = 24,
        NodeHandlingClick = 25,
        NodeHasRelevantHoverRules = 26,
        ElementHasWeirdParserInsertionMode = 27,
        ParserHasNotified = 28,
        MayBeApzAware = 29,
        ElementMayHaveAnonymousChildren = 30,
        BooleanFlagCount = 31,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsINode__bindgen_ty_1 {
        pub mPrimaryFrame: root::__BindgenUnionField<*mut root::nsIFrame>,
        pub mSubtreeRoot: root::__BindgenUnionField<*mut root::nsINode>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsINode__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsINode__bindgen_ty_1>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsINode__bindgen_ty_1 ) ));
        assert_eq! (::std::mem::align_of::<nsINode__bindgen_ty_1>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsINode__bindgen_ty_1 )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode__bindgen_ty_1 ) ) .
                    mPrimaryFrame as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsINode__bindgen_ty_1 ) , "::" , stringify ! (
                    mPrimaryFrame ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode__bindgen_ty_1 ) ) .
                    mSubtreeRoot as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsINode__bindgen_ty_1 ) , "::" , stringify ! (
                    mSubtreeRoot ) ));
    }
    impl Clone for nsINode__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsINode() {
        assert_eq!(::std::mem::size_of::<nsINode>() , 88usize , concat ! (
                   "Size of: " , stringify ! ( nsINode ) ));
        assert_eq! (::std::mem::align_of::<nsINode>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsINode ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode ) ) . mNodeInfo as * const _
                    as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode ) , "::" ,
                    stringify ! ( mNodeInfo ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode ) ) . mParent as * const _ as
                    usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode ) , "::" ,
                    stringify ! ( mParent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode ) ) . mNextSibling as * const
                    _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode ) , "::" ,
                    stringify ! ( mNextSibling ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode ) ) . mPreviousSibling as *
                    const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode ) , "::" ,
                    stringify ! ( mPreviousSibling ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode ) ) . mFirstChild as * const
                    _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode ) , "::" ,
                    stringify ! ( mFirstChild ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode ) ) . mSlots as * const _ as
                    usize } , 80usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode ) , "::" ,
                    stringify ! ( mSlots ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIRedirectHistoryEntry {
        _unused: [u8; 0],
    }
    /**
 * Get a property named by id in obj.  Note the jsid id type -- id may
 * be a string (Unicode property identifier) or an int (element index).  The
 * *vp out parameter, on success, is the new property value after the action.
 */
    pub type JSGetterOp =
        ::std::option::Option<unsafe extern "C" fn(cx: *mut root::JSContext,
                                                   obj:
                                                       root::JS::HandleObject,
                                                   id: root::JS::HandleId,
                                                   vp:
                                                       root::JS::MutableHandleValue)
                                  -> bool>;
    /**
 * Set a property named by id in obj, treating the assignment as strict
 * mode code if strict is true. Note the jsid id type -- id may be a string
 * (Unicode property identifier) or an int (element index). The *vp out
 * parameter, on success, is the new property value after the
 * set.
 */
    pub type JSSetterOp =
        ::std::option::Option<unsafe extern "C" fn(cx: *mut root::JSContext,
                                                   obj:
                                                       root::JS::HandleObject,
                                                   id: root::JS::HandleId,
                                                   vp:
                                                       root::JS::MutableHandleValue,
                                                   result:
                                                       *mut root::JS::ObjectOpResult)
                                  -> bool>;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct JSErrorFormatString {
        /** The error message name in ASCII. */
        pub name: *const ::std::os::raw::c_char,
        /** The error format string in ASCII. */
        pub format: *const ::std::os::raw::c_char,
        /** The number of arguments to expand in the formatted error message. */
        pub argCount: u16,
        /** One of the JSExnType constants above. */
        pub exnType: i16,
    }
    #[test]
    fn bindgen_test_layout_JSErrorFormatString() {
        assert_eq!(::std::mem::size_of::<JSErrorFormatString>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( JSErrorFormatString ) ));
        assert_eq! (::std::mem::align_of::<JSErrorFormatString>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( JSErrorFormatString ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorFormatString ) ) . name as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorFormatString
                    ) , "::" , stringify ! ( name ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorFormatString ) ) . format as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorFormatString
                    ) , "::" , stringify ! ( format ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorFormatString ) ) . argCount as
                    * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorFormatString
                    ) , "::" , stringify ! ( argCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorFormatString ) ) . exnType as
                    * const _ as usize } , 18usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorFormatString
                    ) , "::" , stringify ! ( exnType ) ));
    }
    impl Clone for JSErrorFormatString {
        fn clone(&self) -> Self { *self }
    }
    pub type JSErrorCallback =
        ::std::option::Option<unsafe extern "C" fn(userRef:
                                                       *mut ::std::os::raw::c_void,
                                                   errorNumber:
                                                       ::std::os::raw::c_uint)
                                  -> *const root::JSErrorFormatString>;
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSAutoRequest {
        pub mContext: *mut root::JSContext,
    }
    #[test]
    fn bindgen_test_layout_JSAutoRequest() {
        assert_eq!(::std::mem::size_of::<JSAutoRequest>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( JSAutoRequest ) ));
        assert_eq! (::std::mem::align_of::<JSAutoRequest>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( JSAutoRequest ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSAutoRequest ) ) . mContext as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSAutoRequest ) ,
                    "::" , stringify ! ( mContext ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSAutoCompartment {
        pub cx_: *mut root::JSContext,
        pub oldCompartment_: *mut root::JSCompartment,
    }
    #[test]
    fn bindgen_test_layout_JSAutoCompartment() {
        assert_eq!(::std::mem::size_of::<JSAutoCompartment>() , 16usize ,
                   concat ! ( "Size of: " , stringify ! ( JSAutoCompartment )
                   ));
        assert_eq! (::std::mem::align_of::<JSAutoCompartment>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( JSAutoCompartment ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSAutoCompartment ) ) . cx_ as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSAutoCompartment )
                    , "::" , stringify ! ( cx_ ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSAutoCompartment ) ) .
                    oldCompartment_ as * const _ as usize } , 8usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( JSAutoCompartment )
                    , "::" , stringify ! ( oldCompartment_ ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSAutoNullableCompartment {
        pub cx_: *mut root::JSContext,
        pub oldCompartment_: *mut root::JSCompartment,
    }
    #[test]
    fn bindgen_test_layout_JSAutoNullableCompartment() {
        assert_eq!(::std::mem::size_of::<JSAutoNullableCompartment>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( JSAutoNullableCompartment ) ));
        assert_eq! (::std::mem::align_of::<JSAutoNullableCompartment>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( JSAutoNullableCompartment
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSAutoNullableCompartment ) ) . cx_
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    JSAutoNullableCompartment ) , "::" , stringify ! ( cx_ )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSAutoNullableCompartment ) ) .
                    oldCompartment_ as * const _ as usize } , 8usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    JSAutoNullableCompartment ) , "::" , stringify ! (
                    oldCompartment_ ) ));
    }
    /**
 * Base class that implements parts shared by JSErrorReport and
 * JSErrorNotes::Note.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSErrorBase {
        pub message_: root::JS::ConstUTF8CharsZ,
        pub filename: *const ::std::os::raw::c_char,
        pub lineno: ::std::os::raw::c_uint,
        pub column: ::std::os::raw::c_uint,
        pub errorNumber: ::std::os::raw::c_uint,
        pub _bitfield_1: u8,
        pub __bindgen_padding_0: [u8; 3usize],
    }
    #[test]
    fn bindgen_test_layout_JSErrorBase() {
        assert_eq!(::std::mem::size_of::<JSErrorBase>() , 32usize , concat ! (
                   "Size of: " , stringify ! ( JSErrorBase ) ));
        assert_eq! (::std::mem::align_of::<JSErrorBase>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( JSErrorBase ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorBase ) ) . message_ as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorBase ) ,
                    "::" , stringify ! ( message_ ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorBase ) ) . filename as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorBase ) ,
                    "::" , stringify ! ( filename ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorBase ) ) . lineno as * const _
                    as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorBase ) ,
                    "::" , stringify ! ( lineno ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorBase ) ) . column as * const _
                    as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorBase ) ,
                    "::" , stringify ! ( column ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorBase ) ) . errorNumber as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorBase ) ,
                    "::" , stringify ! ( errorNumber ) ));
    }
    impl JSErrorBase {
        #[inline]
        pub fn ownsMessage_(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 1u64 as u8;
            let val = (unit_field_val & mask) >> 0usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_ownsMessage_(&mut self, val: bool) {
            let mask = 1u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 0usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn new_bitfield_1(ownsMessage_: bool) -> u8 {
            ({ 0 } | ((ownsMessage_ as u8 as u8) << 0usize) & (1u64 as u8))
        }
    }
    /**
 * Notes associated with JSErrorReport.
 */
    #[repr(C)]
    pub struct JSErrorNotes {
        pub notes_: [u64; 4usize],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSErrorNotes_Note {
        pub _base: root::JSErrorBase,
    }
    #[test]
    fn bindgen_test_layout_JSErrorNotes_Note() {
        assert_eq!(::std::mem::size_of::<JSErrorNotes_Note>() , 32usize ,
                   concat ! ( "Size of: " , stringify ! ( JSErrorNotes_Note )
                   ));
        assert_eq! (::std::mem::align_of::<JSErrorNotes_Note>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( JSErrorNotes_Note ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSErrorNotes_iterator {
        pub note_: *mut root::mozilla::UniquePtr<root::JSErrorNotes_Note>,
    }
    #[test]
    fn bindgen_test_layout_JSErrorNotes_iterator() {
        assert_eq!(::std::mem::size_of::<JSErrorNotes_iterator>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( JSErrorNotes_iterator ) ));
        assert_eq! (::std::mem::align_of::<JSErrorNotes_iterator>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( JSErrorNotes_iterator )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorNotes_iterator ) ) . note_ as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    JSErrorNotes_iterator ) , "::" , stringify ! ( note_ ) ));
    }
    #[test]
    fn bindgen_test_layout_JSErrorNotes() {
        assert_eq!(::std::mem::size_of::<JSErrorNotes>() , 32usize , concat !
                   ( "Size of: " , stringify ! ( JSErrorNotes ) ));
        assert_eq! (::std::mem::align_of::<JSErrorNotes>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( JSErrorNotes ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorNotes ) ) . notes_ as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorNotes ) ,
                    "::" , stringify ! ( notes_ ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIObjectInputStream {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIObjectOutputStream {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsISerializable {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISerializable_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsISerializable() {
        assert_eq!(::std::mem::size_of::<nsISerializable>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsISerializable ) ));
        assert_eq! (::std::mem::align_of::<nsISerializable>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsISerializable ) ));
    }
    impl Clone for nsISerializable {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIContentSecurityPolicy {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIChannel {
        pub _base: root::nsIRequest,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIChannel_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsIChannel_LOAD_DOCUMENT_URI: root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_DOCUMENT_URI;
    pub const nsIChannel_LOAD_RETARGETED_DOCUMENT_URI:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_RETARGETED_DOCUMENT_URI;
    pub const nsIChannel_LOAD_REPLACE: root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_REPLACE;
    pub const nsIChannel_LOAD_INITIAL_DOCUMENT_URI:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_INITIAL_DOCUMENT_URI;
    pub const nsIChannel_LOAD_TARGETED: root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_TARGETED;
    pub const nsIChannel_LOAD_CALL_CONTENT_SNIFFERS:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_CALL_CONTENT_SNIFFERS;
    pub const nsIChannel_LOAD_CLASSIFY_URI: root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_CLASSIFY_URI;
    pub const nsIChannel_LOAD_MEDIA_SNIFFER_OVERRIDES_CONTENT_TYPE:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_MEDIA_SNIFFER_OVERRIDES_CONTENT_TYPE;
    pub const nsIChannel_LOAD_EXPLICIT_CREDENTIALS:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_EXPLICIT_CREDENTIALS;
    pub const nsIChannel_LOAD_BYPASS_SERVICE_WORKER:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_BYPASS_SERVICE_WORKER;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIChannel__bindgen_ty_1 {
        LOAD_DOCUMENT_URI = 65536,
        LOAD_RETARGETED_DOCUMENT_URI = 131072,
        LOAD_REPLACE = 262144,
        LOAD_INITIAL_DOCUMENT_URI = 524288,
        LOAD_TARGETED = 1048576,
        LOAD_CALL_CONTENT_SNIFFERS = 2097152,
        LOAD_CLASSIFY_URI = 4194304,
        LOAD_MEDIA_SNIFFER_OVERRIDES_CONTENT_TYPE = 8388608,
        LOAD_EXPLICIT_CREDENTIALS = 16777216,
        LOAD_BYPASS_SERVICE_WORKER = 33554432,
    }
    pub const nsIChannel_DISPOSITION_INLINE: root::nsIChannel__bindgen_ty_2 =
        nsIChannel__bindgen_ty_2::DISPOSITION_INLINE;
    pub const nsIChannel_DISPOSITION_ATTACHMENT:
              root::nsIChannel__bindgen_ty_2 =
        nsIChannel__bindgen_ty_2::DISPOSITION_ATTACHMENT;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIChannel__bindgen_ty_2 {
        DISPOSITION_INLINE = 0,
        DISPOSITION_ATTACHMENT = 1,
    }
    #[test]
    fn bindgen_test_layout_nsIChannel() {
        assert_eq!(::std::mem::size_of::<nsIChannel>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIChannel ) ));
        assert_eq! (::std::mem::align_of::<nsIChannel>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIChannel ) ));
    }
    impl Clone for nsIChannel {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDocShell {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsILoadContext {
        _unused: [u8; 0],
    }
    pub type nsSecurityFlags = u32;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsILoadInfo {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsILoadInfo_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsILoadInfo_SEC_NORMAL: root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_NORMAL;
    pub const nsILoadInfo_SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS:
              root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS;
    pub const nsILoadInfo_SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED:
              root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED;
    pub const nsILoadInfo_SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS:
              root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS;
    pub const nsILoadInfo_SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL:
              root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL;
    pub const nsILoadInfo_SEC_REQUIRE_CORS_DATA_INHERITS:
              root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_REQUIRE_CORS_DATA_INHERITS;
    pub const nsILoadInfo_SEC_COOKIES_DEFAULT: root::nsILoadInfo__bindgen_ty_1
              =
        nsILoadInfo__bindgen_ty_1::SEC_NORMAL;
    pub const nsILoadInfo_SEC_COOKIES_INCLUDE: root::nsILoadInfo__bindgen_ty_1
              =
        nsILoadInfo__bindgen_ty_1::SEC_COOKIES_INCLUDE;
    pub const nsILoadInfo_SEC_COOKIES_SAME_ORIGIN:
              root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_COOKIES_SAME_ORIGIN;
    pub const nsILoadInfo_SEC_COOKIES_OMIT: root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_COOKIES_OMIT;
    pub const nsILoadInfo_SEC_FORCE_INHERIT_PRINCIPAL:
              root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_FORCE_INHERIT_PRINCIPAL;
    pub const nsILoadInfo_SEC_SANDBOXED: root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_SANDBOXED;
    pub const nsILoadInfo_SEC_ABOUT_BLANK_INHERITS:
              root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_ABOUT_BLANK_INHERITS;
    pub const nsILoadInfo_SEC_ALLOW_CHROME: root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_ALLOW_CHROME;
    pub const nsILoadInfo_SEC_DISALLOW_SCRIPT: root::nsILoadInfo__bindgen_ty_1
              =
        nsILoadInfo__bindgen_ty_1::SEC_DISALLOW_SCRIPT;
    pub const nsILoadInfo_SEC_DONT_FOLLOW_REDIRECTS:
              root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_DONT_FOLLOW_REDIRECTS;
    pub const nsILoadInfo_SEC_LOAD_ERROR_PAGE: root::nsILoadInfo__bindgen_ty_1
              =
        nsILoadInfo__bindgen_ty_1::SEC_LOAD_ERROR_PAGE;
    pub const nsILoadInfo_SEC_FORCE_INHERIT_PRINCIPAL_OVERRULE_OWNER:
              root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_FORCE_INHERIT_PRINCIPAL_OVERRULE_OWNER;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsILoadInfo__bindgen_ty_1 {
        SEC_NORMAL = 0,
        SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS = 1,
        SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED = 2,
        SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS = 4,
        SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL = 8,
        SEC_REQUIRE_CORS_DATA_INHERITS = 16,
        SEC_COOKIES_INCLUDE = 32,
        SEC_COOKIES_SAME_ORIGIN = 64,
        SEC_COOKIES_OMIT = 96,
        SEC_FORCE_INHERIT_PRINCIPAL = 128,
        SEC_SANDBOXED = 256,
        SEC_ABOUT_BLANK_INHERITS = 512,
        SEC_ALLOW_CHROME = 1024,
        SEC_DISALLOW_SCRIPT = 2048,
        SEC_DONT_FOLLOW_REDIRECTS = 4096,
        SEC_LOAD_ERROR_PAGE = 8192,
        SEC_FORCE_INHERIT_PRINCIPAL_OVERRULE_OWNER = 16384,
    }
    pub const nsILoadInfo_TAINTING_BASIC: root::nsILoadInfo__bindgen_ty_2 =
        nsILoadInfo__bindgen_ty_2::TAINTING_BASIC;
    pub const nsILoadInfo_TAINTING_CORS: root::nsILoadInfo__bindgen_ty_2 =
        nsILoadInfo__bindgen_ty_2::TAINTING_CORS;
    pub const nsILoadInfo_TAINTING_OPAQUE: root::nsILoadInfo__bindgen_ty_2 =
        nsILoadInfo__bindgen_ty_2::TAINTING_OPAQUE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsILoadInfo__bindgen_ty_2 {
        TAINTING_BASIC = 0,
        TAINTING_CORS = 1,
        TAINTING_OPAQUE = 2,
    }
    #[test]
    fn bindgen_test_layout_nsILoadInfo() {
        assert_eq!(::std::mem::size_of::<nsILoadInfo>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsILoadInfo ) ));
        assert_eq! (::std::mem::align_of::<nsILoadInfo>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsILoadInfo ) ));
    }
    impl Clone for nsILoadInfo {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIInterfaceRequestor {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIInterfaceRequestor_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIInterfaceRequestor() {
        assert_eq!(::std::mem::size_of::<nsIInterfaceRequestor>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIInterfaceRequestor ) ));
        assert_eq! (::std::mem::align_of::<nsIInterfaceRequestor>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIInterfaceRequestor )
                    ));
    }
    impl Clone for nsIInterfaceRequestor {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIInputStream {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIStreamListener {
        pub _base: root::nsIRequestObserver,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIStreamListener_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIStreamListener() {
        assert_eq!(::std::mem::size_of::<nsIStreamListener>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsIStreamListener )
                   ));
        assert_eq! (::std::mem::align_of::<nsIStreamListener>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIStreamListener ) ));
    }
    impl Clone for nsIStreamListener {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsICSSLoaderObserver {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsICSSLoaderObserver_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsICSSLoaderObserver() {
        assert_eq!(::std::mem::size_of::<nsICSSLoaderObserver>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsICSSLoaderObserver ) ));
        assert_eq! (::std::mem::align_of::<nsICSSLoaderObserver>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsICSSLoaderObserver ) ));
    }
    impl Clone for nsICSSLoaderObserver {
        fn clone(&self) -> Self { *self }
    }
    pub type DOMHighResTimeStamp = f64;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMAttr {
        pub _base: root::nsIDOMNode,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMAttr_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMAttr() {
        assert_eq!(::std::mem::size_of::<nsIDOMAttr>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIDOMAttr ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMAttr>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIDOMAttr ) ));
    }
    impl Clone for nsIDOMAttr {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMElement {
        pub _base: root::nsIDOMNode,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMElement_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMElement() {
        assert_eq!(::std::mem::size_of::<nsIDOMElement>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( nsIDOMElement ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMElement>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsIDOMElement ) ));
    }
    impl Clone for nsIDOMElement {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMNodeList {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMNodeList_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMNodeList() {
        assert_eq!(::std::mem::size_of::<nsIDOMNodeList>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( nsIDOMNodeList ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMNodeList>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsIDOMNodeList ) ));
    }
    impl Clone for nsIDOMNodeList {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMClientRect {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMClientRect_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMClientRect() {
        assert_eq!(::std::mem::size_of::<nsIDOMClientRect>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsIDOMClientRect ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMClientRect>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMClientRect ) ));
    }
    impl Clone for nsIDOMClientRect {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMClientRectList {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMClientRectList_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMClientRectList() {
        assert_eq!(::std::mem::size_of::<nsIDOMClientRectList>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIDOMClientRectList ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMClientRectList>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMClientRectList ) ));
    }
    impl Clone for nsIDOMClientRectList {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMStyleSheet {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMStyleSheet_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMStyleSheet() {
        assert_eq!(::std::mem::size_of::<nsIDOMStyleSheet>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsIDOMStyleSheet ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMStyleSheet>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMStyleSheet ) ));
    }
    impl Clone for nsIDOMStyleSheet {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMMediaList {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMMediaList_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMMediaList() {
        assert_eq!(::std::mem::size_of::<nsIDOMMediaList>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsIDOMMediaList ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMMediaList>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMMediaList ) ));
    }
    impl Clone for nsIDOMMediaList {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMEvent {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMEventTarget {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMEventTarget_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMEventTarget() {
        assert_eq!(::std::mem::size_of::<nsIDOMEventTarget>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsIDOMEventTarget )
                   ));
        assert_eq! (::std::mem::align_of::<nsIDOMEventTarget>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMEventTarget ) ));
    }
    impl Clone for nsIDOMEventTarget {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMEventListener {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMHTMLCollection {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMHTMLCollection_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMHTMLCollection() {
        assert_eq!(::std::mem::size_of::<nsIDOMHTMLCollection>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIDOMHTMLCollection ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMHTMLCollection>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMHTMLCollection ) ));
    }
    impl Clone for nsIDOMHTMLCollection {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMCSSValue {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMCSSValue_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsIDOMCSSValue_CSS_INHERIT: root::nsIDOMCSSValue__bindgen_ty_1 =
        nsIDOMCSSValue__bindgen_ty_1::CSS_INHERIT;
    pub const nsIDOMCSSValue_CSS_PRIMITIVE_VALUE:
              root::nsIDOMCSSValue__bindgen_ty_1 =
        nsIDOMCSSValue__bindgen_ty_1::CSS_PRIMITIVE_VALUE;
    pub const nsIDOMCSSValue_CSS_VALUE_LIST:
              root::nsIDOMCSSValue__bindgen_ty_1 =
        nsIDOMCSSValue__bindgen_ty_1::CSS_VALUE_LIST;
    pub const nsIDOMCSSValue_CSS_CUSTOM: root::nsIDOMCSSValue__bindgen_ty_1 =
        nsIDOMCSSValue__bindgen_ty_1::CSS_CUSTOM;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDOMCSSValue__bindgen_ty_1 {
        CSS_INHERIT = 0,
        CSS_PRIMITIVE_VALUE = 1,
        CSS_VALUE_LIST = 2,
        CSS_CUSTOM = 3,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMCSSValue() {
        assert_eq!(::std::mem::size_of::<nsIDOMCSSValue>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( nsIDOMCSSValue ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMCSSValue>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsIDOMCSSValue ) ));
    }
    impl Clone for nsIDOMCSSValue {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMCSSRule {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMCSSRule_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsIDOMCSSRule_UNKNOWN_RULE: root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::UNKNOWN_RULE;
    pub const nsIDOMCSSRule_STYLE_RULE: root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::STYLE_RULE;
    pub const nsIDOMCSSRule_CHARSET_RULE: root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::CHARSET_RULE;
    pub const nsIDOMCSSRule_IMPORT_RULE: root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::IMPORT_RULE;
    pub const nsIDOMCSSRule_MEDIA_RULE: root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::MEDIA_RULE;
    pub const nsIDOMCSSRule_FONT_FACE_RULE: root::nsIDOMCSSRule__bindgen_ty_1
              =
        nsIDOMCSSRule__bindgen_ty_1::FONT_FACE_RULE;
    pub const nsIDOMCSSRule_PAGE_RULE: root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::PAGE_RULE;
    pub const nsIDOMCSSRule_KEYFRAMES_RULE: root::nsIDOMCSSRule__bindgen_ty_1
              =
        nsIDOMCSSRule__bindgen_ty_1::KEYFRAMES_RULE;
    pub const nsIDOMCSSRule_KEYFRAME_RULE: root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::KEYFRAME_RULE;
    pub const nsIDOMCSSRule_MOZ_KEYFRAMES_RULE:
              root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::KEYFRAMES_RULE;
    pub const nsIDOMCSSRule_MOZ_KEYFRAME_RULE:
              root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::KEYFRAME_RULE;
    pub const nsIDOMCSSRule_NAMESPACE_RULE: root::nsIDOMCSSRule__bindgen_ty_1
              =
        nsIDOMCSSRule__bindgen_ty_1::NAMESPACE_RULE;
    pub const nsIDOMCSSRule_COUNTER_STYLE_RULE:
              root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::COUNTER_STYLE_RULE;
    pub const nsIDOMCSSRule_SUPPORTS_RULE: root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::SUPPORTS_RULE;
    pub const nsIDOMCSSRule_DOCUMENT_RULE: root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::DOCUMENT_RULE;
    pub const nsIDOMCSSRule_FONT_FEATURE_VALUES_RULE:
              root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::FONT_FEATURE_VALUES_RULE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDOMCSSRule__bindgen_ty_1 {
        UNKNOWN_RULE = 0,
        STYLE_RULE = 1,
        CHARSET_RULE = 2,
        IMPORT_RULE = 3,
        MEDIA_RULE = 4,
        FONT_FACE_RULE = 5,
        PAGE_RULE = 6,
        KEYFRAMES_RULE = 7,
        KEYFRAME_RULE = 8,
        NAMESPACE_RULE = 10,
        COUNTER_STYLE_RULE = 11,
        SUPPORTS_RULE = 12,
        DOCUMENT_RULE = 13,
        FONT_FEATURE_VALUES_RULE = 14,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMCSSRule() {
        assert_eq!(::std::mem::size_of::<nsIDOMCSSRule>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( nsIDOMCSSRule ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMCSSRule>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsIDOMCSSRule ) ));
    }
    impl Clone for nsIDOMCSSRule {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMCSSRuleList {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMCSSStyleSheet {
        pub _base: root::nsIDOMStyleSheet,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMCSSStyleSheet_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMCSSStyleSheet() {
        assert_eq!(::std::mem::size_of::<nsIDOMCSSStyleSheet>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIDOMCSSStyleSheet ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMCSSStyleSheet>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMCSSStyleSheet ) ));
    }
    impl Clone for nsIDOMCSSStyleSheet {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMCSSStyleDeclaration {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMCSSStyleDeclaration_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMCSSStyleDeclaration() {
        assert_eq!(::std::mem::size_of::<nsIDOMCSSStyleDeclaration>() , 8usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsIDOMCSSStyleDeclaration ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMCSSStyleDeclaration>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIDOMCSSStyleDeclaration
                    ) ));
    }
    impl Clone for nsIDOMCSSStyleDeclaration {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    pub struct TraceCallbacks__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct TraceCallbacks {
        pub vtable_: *const TraceCallbacks__bindgen_vtable,
    }
    #[test]
    fn bindgen_test_layout_TraceCallbacks() {
        assert_eq!(::std::mem::size_of::<TraceCallbacks>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( TraceCallbacks ) ));
        assert_eq! (::std::mem::align_of::<TraceCallbacks>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( TraceCallbacks ) ));
    }
    impl Clone for TraceCallbacks {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsScriptObjectTracer {
        pub _base: root::nsCycleCollectionParticipant,
    }
    #[test]
    fn bindgen_test_layout_nsScriptObjectTracer() {
        assert_eq!(::std::mem::size_of::<nsScriptObjectTracer>() , 16usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsScriptObjectTracer ) ));
        assert_eq! (::std::mem::align_of::<nsScriptObjectTracer>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsScriptObjectTracer ) ));
    }
    impl Clone for nsScriptObjectTracer {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsXPCOMCycleCollectionParticipant {
        pub _base: root::nsScriptObjectTracer,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsXPCOMCycleCollectionParticipant_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsXPCOMCycleCollectionParticipant() {
        assert_eq!(::std::mem::size_of::<nsXPCOMCycleCollectionParticipant>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsXPCOMCycleCollectionParticipant ) ));
        assert_eq! (::std::mem::align_of::<nsXPCOMCycleCollectionParticipant>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsXPCOMCycleCollectionParticipant ) ));
    }
    impl Clone for nsXPCOMCycleCollectionParticipant {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    pub struct nsIDocument {
        pub _base: root::nsINode,
        pub _base_1: root::mozilla::dom::DispatcherTrait,
        pub mDeprecationWarnedAbout: u64,
        pub mDocWarningWarnedAbout: u64,
        pub mSelectorCache: root::nsAutoPtr<root::nsIDocument_SelectorCache>,
        pub mReferrer: root::nsCString,
        pub mLastModified: ::nsstring::nsStringRepr,
        pub mDocumentURI: root::nsCOMPtr,
        pub mOriginalURI: root::nsCOMPtr,
        pub mChromeXHRDocURI: root::nsCOMPtr,
        pub mDocumentBaseURI: root::nsCOMPtr,
        pub mChromeXHRDocBaseURI: root::nsCOMPtr,
        pub mCachedURLData: root::RefPtr<root::mozilla::URLExtraData>,
        pub mDocumentLoadGroup: root::nsWeakPtr,
        pub mReferrerPolicySet: bool,
        pub mReferrerPolicy: root::nsIDocument_ReferrerPolicyEnum,
        pub mBlockAllMixedContent: bool,
        pub mBlockAllMixedContentPreloads: bool,
        pub mUpgradeInsecureRequests: bool,
        pub mUpgradeInsecurePreloads: bool,
        pub mHSTSPrimingURIList: [u64; 5usize],
        pub mDocumentContainer: u64,
        pub mCharacterSet: root::mozilla::NotNull<*const root::mozilla::Encoding>,
        pub mCharacterSetSource: i32,
        pub mParentDocument: *mut root::nsIDocument,
        pub mCachedRootElement: *mut root::mozilla::dom::Element,
        pub mNodeInfoManager: *mut root::nsNodeInfoManager,
        pub mCSSLoader: root::RefPtr<root::mozilla::css::Loader>,
        pub mStyleImageLoader: root::RefPtr<root::mozilla::css::ImageLoader>,
        pub mAttrStyleSheet: root::RefPtr<root::nsHTMLStyleSheet>,
        pub mStyleAttrStyleSheet: root::RefPtr<root::nsHTMLCSSStyleSheet>,
        pub mImageTracker: root::RefPtr<root::mozilla::dom::ImageTracker>,
        pub mActivityObservers: u64,
        pub mLinksToUpdate: [u64; 3usize],
        pub mAnimationController: root::RefPtr<root::nsSMILAnimationController>,
        pub mPropertyTable: root::nsPropertyTable,
        pub mExtraPropertyTables: root::nsTArray<root::nsAutoPtr<root::nsPropertyTable>>,
        pub mChildrenCollection: root::nsCOMPtr,
        pub mFontFaceSet: root::RefPtr<root::mozilla::dom::FontFaceSet>,
        pub mLastFocusTime: root::mozilla::TimeStamp,
        pub _bitfield_1: [u8; 7usize],
        pub mCompatMode: root::nsCompatibility,
        pub mReadyState: root::nsIDocument_ReadyState,
        pub mStyleBackendType: root::mozilla::StyleBackendType,
        pub mVisibilityState: root::mozilla::dom::VisibilityState,
        pub mType: root::nsIDocument_Type,
        pub mDefaultElementType: u8,
        pub mAllowXULXBL: root::nsIDocument_Tri,
        pub mScriptGlobalObject: root::nsCOMPtr,
        pub mOriginalDocument: root::nsCOMPtr,
        pub mBidiOptions: u32,
        pub mSandboxFlags: u32,
        pub mContentLanguage: root::nsCString,
        pub mChannel: root::nsCOMPtr,
        pub mContentType: root::nsCString,
        pub mId: ::nsstring::nsStringRepr,
        pub mSecurityInfo: root::nsCOMPtr,
        pub mFailedChannel: root::nsCOMPtr,
        pub mPartID: u32,
        pub mMarkedCCGeneration: u32,
        pub mPresShell: *mut root::nsIPresShell,
        pub mSubtreeModifiedTargets: root::nsCOMArray,
        pub mSubtreeModifiedDepth: u32,
        pub mDisplayDocument: root::nsCOMPtr,
        pub mEventsSuppressed: u32,
        /**
   * The number number of external scripts (ones with the src attribute) that
   * have this document as their owner and that are being evaluated right now.
   */
        pub mExternalScriptsBeingEvaluated: u32,
        /**
   * The current frame request callback handle
   */
        pub mFrameRequestCallbackCounter: i32,
        pub mStaticCloneCount: u32,
        pub mBlockedTrackingNodes: root::nsTArray<root::nsCOMPtr>,
        pub mWindow: *mut root::nsPIDOMWindowInner,
        pub mCachedEncoder: root::nsCOMPtr,
        pub mFrameRequestCallbacks: root::nsTArray<root::nsIDocument_FrameRequest>,
        pub mBFCacheEntry: *mut root::nsIBFCacheEntry,
        pub mBaseTarget: ::nsstring::nsStringRepr,
        pub mStateObjectContainer: root::nsCOMPtr,
        pub mStateObjectCached: root::nsCOMPtr,
        pub mInSyncOperationCount: u32,
        pub mXPathEvaluator: root::RefPtr<root::mozilla::dom::XPathEvaluator>,
        pub mAnonymousContents: root::nsTArray<root::RefPtr<root::mozilla::dom::AnonymousContent>>,
        pub mBlockDOMContentLoaded: u32,
        pub mDOMMediaQueryLists: root::mozilla::LinkedList,
        pub mUseCounters: [u64; 2usize],
        pub mChildDocumentUseCounters: [u64; 2usize],
        pub mNotifiedPageForUseCounter: [u64; 2usize],
        pub mIncCounters: u16,
        pub mUserHasInteracted: bool,
        pub mPageUnloadingEventTimeStamp: root::mozilla::TimeStamp,
        pub mDocGroup: root::RefPtr<root::mozilla::dom::DocGroup>,
        pub mTrackingScripts: [u64; 5usize],
    }
    pub type nsIDocument_GlobalObject = root::mozilla::dom::GlobalObject;
    pub type nsIDocument_Encoding = root::mozilla::Encoding;
    pub type nsIDocument_NotNull<T> = root::mozilla::NotNull<T>;
    pub use self::super::root::mozilla::net::ReferrerPolicy as
            nsIDocument_ReferrerPolicyEnum;
    pub type nsIDocument_Element = root::mozilla::dom::Element;
    pub type nsIDocument_FullscreenRequest =
        root::mozilla::dom::FullscreenRequest;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDocument_COMTypeInfo {
        pub _address: u8,
    }
    #[repr(C)]
    pub struct nsIDocument_PageUnloadingEventTimeStamp {
        pub mDocument: root::nsCOMPtr,
        pub mSet: bool,
    }
    #[test]
    fn bindgen_test_layout_nsIDocument_PageUnloadingEventTimeStamp() {
        assert_eq!(::std::mem::size_of::<nsIDocument_PageUnloadingEventTimeStamp>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsIDocument_PageUnloadingEventTimeStamp ) ));
        assert_eq! (::std::mem::align_of::<nsIDocument_PageUnloadingEventTimeStamp>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsIDocument_PageUnloadingEventTimeStamp ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsIDocument_PageUnloadingEventTimeStamp )
                    ) . mDocument as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsIDocument_PageUnloadingEventTimeStamp ) , "::" ,
                    stringify ! ( mDocument ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsIDocument_PageUnloadingEventTimeStamp )
                    ) . mSet as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsIDocument_PageUnloadingEventTimeStamp ) , "::" ,
                    stringify ! ( mSet ) ));
    }
    /**
   * This gets fired when the element that an id refers to changes.
   * This fires at difficult times. It is generally not safe to do anything
   * which could modify the DOM in any way. Use
   * nsContentUtils::AddScriptRunner.
   * @return true to keep the callback in the callback set, false
   * to remove it.
   */
    pub type nsIDocument_IDTargetObserver =
        ::std::option::Option<unsafe extern "C" fn(aOldElement:
                                                       *mut root::nsIDocument_Element,
                                                   aNewelement:
                                                       *mut root::nsIDocument_Element,
                                                   aData:
                                                       *mut ::std::os::raw::c_void)
                                  -> bool>;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIDocument_SelectorCacheKey {
        pub mKey: ::nsstring::nsStringRepr,
        pub mState: root::nsExpirationState,
    }
    #[test]
    fn bindgen_test_layout_nsIDocument_SelectorCacheKey() {
        assert_eq!(::std::mem::size_of::<nsIDocument_SelectorCacheKey>() ,
                   24usize , concat ! (
                   "Size of: " , stringify ! ( nsIDocument_SelectorCacheKey )
                   ));
        assert_eq! (::std::mem::align_of::<nsIDocument_SelectorCacheKey>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsIDocument_SelectorCacheKey ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIDocument_SelectorCacheKey ) ) .
                    mKey as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsIDocument_SelectorCacheKey ) , "::" , stringify ! ( mKey
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIDocument_SelectorCacheKey ) ) .
                    mState as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsIDocument_SelectorCacheKey ) , "::" , stringify ! (
                    mState ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDocument_SelectorCacheKeyDeleter {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDocument_SelectorCache {
        pub _bindgen_opaque_blob: [u64; 17usize],
    }
    #[test]
    fn bindgen_test_layout_nsIDocument_SelectorCache() {
        assert_eq!(::std::mem::size_of::<nsIDocument_SelectorCache>() ,
                   136usize , concat ! (
                   "Size of: " , stringify ! ( nsIDocument_SelectorCache ) ));
        assert_eq! (::std::mem::align_of::<nsIDocument_SelectorCache>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIDocument_SelectorCache
                    ) ));
    }
    impl Clone for nsIDocument_SelectorCache {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_additionalSheetType {
        eAgentSheet = 0,
        eUserSheet = 1,
        eAuthorSheet = 2,
        AdditionalSheetTypeCount = 3,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_ReadyState {
        READYSTATE_UNINITIALIZED = 0,
        READYSTATE_LOADING = 1,
        READYSTATE_INTERACTIVE = 3,
        READYSTATE_COMPLETE = 4,
    }
    /**
   * Enumerate all subdocuments.
   * The enumerator callback should return true to continue enumerating, or
   * false to stop.  This will never get passed a null aDocument.
   */
    pub type nsIDocument_nsSubDocEnumFunc =
        ::std::option::Option<unsafe extern "C" fn(aDocument:
                                                       *mut root::nsIDocument,
                                                   aData:
                                                       *mut ::std::os::raw::c_void)
                                  -> bool>;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_ElementsFromPointFlags {
        IGNORE_ROOT_SCROLL_FRAME = 1,
        FLUSH_LAYOUT = 2,
        IS_ELEMENT_FROM_POINT = 4,
    }
    /**
   * A class that represents an external resource load that has begun but
   * doesn't have a document yet.  Observers can be registered on this object,
   * and will be notified after the document is created.  Observers registered
   * after the document has been created will NOT be notified.  When observers
   * are notified, the subject will be the newly-created document, the topic
   * will be "external-resource-document-created", and the data will be null.
   * If document creation fails for some reason, observers will still be
   * notified, with a null document pointer.
   */
    #[repr(C)]
    pub struct nsIDocument_ExternalResourceLoad {
        pub _base: root::nsISupports,
        pub mObservers: [u64; 10usize],
    }
    #[test]
    fn bindgen_test_layout_nsIDocument_ExternalResourceLoad() {
        assert_eq!(::std::mem::size_of::<nsIDocument_ExternalResourceLoad>() ,
                   88usize , concat ! (
                   "Size of: " , stringify ! (
                   nsIDocument_ExternalResourceLoad ) ));
        assert_eq! (::std::mem::align_of::<nsIDocument_ExternalResourceLoad>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsIDocument_ExternalResourceLoad ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIDocument_ExternalResourceLoad ) )
                    . mObservers as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsIDocument_ExternalResourceLoad ) , "::" , stringify ! (
                    mObservers ) ));
    }
    pub type nsIDocument_ActivityObserverEnumerator =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::nsISupports,
                                                   arg2:
                                                       *mut ::std::os::raw::c_void)>;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_DocumentTheme {
        Doc_Theme_Uninitialized = 0,
        Doc_Theme_None = 1,
        Doc_Theme_Neutral = 2,
        Doc_Theme_Dark = 3,
        Doc_Theme_Bright = 4,
    }
    pub type nsIDocument_FrameRequestCallbackList =
        root::nsTArray<root::RefPtr<root::mozilla::dom::FrameRequestCallback>>;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_DeprecatedOperations {
        eGetAttributeNode = 0,
        eSetAttributeNode = 1,
        eGetAttributeNodeNS = 2,
        eSetAttributeNodeNS = 3,
        eRemoveAttributeNode = 4,
        eCreateAttribute = 5,
        eCreateAttributeNS = 6,
        eNodeValue = 7,
        eTextContent = 8,
        eEnablePrivilege = 9,
        eDOMExceptionCode = 10,
        eNoExposedProps = 11,
        eMutationEvent = 12,
        eComponents = 13,
        ePrefixedVisibilityAPI = 14,
        eNodeIteratorDetach = 15,
        eLenientThis = 16,
        eGetPreventDefault = 17,
        eGetSetUserData = 18,
        eMozGetAsFile = 19,
        eUseOfCaptureEvents = 20,
        eUseOfReleaseEvents = 21,
        eUseOfDOM3LoadMethod = 22,
        eChromeUseOfDOM3LoadMethod = 23,
        eShowModalDialog = 24,
        eWindow_Content = 25,
        eSyncXMLHttpRequest = 26,
        eWindow_Controllers = 27,
        eImportXULIntoContent = 28,
        ePannerNodeDoppler = 29,
        eNavigatorGetUserMedia = 30,
        eWebrtcDeprecatedPrefix = 31,
        eRTCPeerConnectionGetStreams = 32,
        eAppCache = 33,
        ePrefixedImageSmoothingEnabled = 34,
        ePrefixedFullscreenAPI = 35,
        eLenientSetter = 36,
        eFileLastModifiedDate = 37,
        eImageBitmapRenderingContext_TransferImageBitmap = 38,
        eURLCreateObjectURL_MediaStream = 39,
        eXMLBaseAttribute = 40,
        eXMLBaseAttributeForStyleAttr = 41,
        eDeprecatedOperationCount = 42,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_DocumentWarnings {
        eIgnoringWillChangeOverBudget = 0,
        ePreventDefaultFromPassiveListener = 1,
        eSVGReferenceLoop = 2,
        eSVGReferenceChainLengthExceeded = 3,
        eDocumentWarningCount = 4,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_ElementCallbackType {
        eCreated = 0,
        eAttached = 1,
        eDetached = 2,
        eAttributeChanged = 3,
    }
    pub const nsIDocument_eScopedStyle_Unknown:
              root::nsIDocument__bindgen_ty_1 =
        nsIDocument__bindgen_ty_1::eScopedStyle_Unknown;
    pub const nsIDocument_eScopedStyle_Disabled:
              root::nsIDocument__bindgen_ty_1 =
        nsIDocument__bindgen_ty_1::eScopedStyle_Disabled;
    pub const nsIDocument_eScopedStyle_Enabled:
              root::nsIDocument__bindgen_ty_1 =
        nsIDocument__bindgen_ty_1::eScopedStyle_Enabled;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument__bindgen_ty_1 {
        eScopedStyle_Unknown = 0,
        eScopedStyle_Disabled = 1,
        eScopedStyle_Enabled = 2,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_Type {
        eUnknown = 0,
        eHTML = 1,
        eXHTML = 2,
        eGenericXML = 3,
        eSVG = 4,
        eXUL = 5,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_Tri { eTriUnset = 0, eTriFalse = 1, eTriTrue = 2, }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDocument_FrameRequest {
        _unused: [u8; 0],
    }
    pub const nsIDocument_kSegmentSize: usize = 128;
    #[test]
    fn bindgen_test_layout_nsIDocument() {
        assert_eq!(::std::mem::size_of::<nsIDocument>() , 856usize , concat !
                   ( "Size of: " , stringify ! ( nsIDocument ) ));
        assert_eq! (::std::mem::align_of::<nsIDocument>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsIDocument ) ));
    }
    impl nsIDocument {
        #[inline]
        pub fn mBidiEnabled(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 1u64 as u64;
            let val = (unit_field_val & mask) >> 0usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mBidiEnabled(&mut self, val: bool) {
            let mask = 1u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 0usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mMathMLEnabled(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 2u64 as u64;
            let val = (unit_field_val & mask) >> 1usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mMathMLEnabled(&mut self, val: bool) {
            let mask = 2u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 1usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsInitialDocumentInWindow(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 4u64 as u64;
            let val = (unit_field_val & mask) >> 2usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsInitialDocumentInWindow(&mut self, val: bool) {
            let mask = 4u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 2usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIgnoreDocGroupMismatches(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 8u64 as u64;
            let val = (unit_field_val & mask) >> 3usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIgnoreDocGroupMismatches(&mut self, val: bool) {
            let mask = 8u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 3usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mLoadedAsData(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 16u64 as u64;
            let val = (unit_field_val & mask) >> 4usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mLoadedAsData(&mut self, val: bool) {
            let mask = 16u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 4usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mLoadedAsInteractiveData(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 32u64 as u64;
            let val = (unit_field_val & mask) >> 5usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mLoadedAsInteractiveData(&mut self, val: bool) {
            let mask = 32u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 5usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mMayStartLayout(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 64u64 as u64;
            let val = (unit_field_val & mask) >> 6usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mMayStartLayout(&mut self, val: bool) {
            let mask = 64u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 6usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHaveFiredTitleChange(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 128u64 as u64;
            let val = (unit_field_val & mask) >> 7usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHaveFiredTitleChange(&mut self, val: bool) {
            let mask = 128u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 7usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsShowing(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 256u64 as u64;
            let val = (unit_field_val & mask) >> 8usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsShowing(&mut self, val: bool) {
            let mask = 256u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 8usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mVisible(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 512u64 as u64;
            let val = (unit_field_val & mask) >> 9usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mVisible(&mut self, val: bool) {
            let mask = 512u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 9usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasReferrerPolicyCSP(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 1024u64 as u64;
            let val = (unit_field_val & mask) >> 10usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasReferrerPolicyCSP(&mut self, val: bool) {
            let mask = 1024u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 10usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mRemovedFromDocShell(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 2048u64 as u64;
            let val = (unit_field_val & mask) >> 11usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mRemovedFromDocShell(&mut self, val: bool) {
            let mask = 2048u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 11usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mAllowDNSPrefetch(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 4096u64 as u64;
            let val = (unit_field_val & mask) >> 12usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mAllowDNSPrefetch(&mut self, val: bool) {
            let mask = 4096u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 12usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsStaticDocument(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 8192u64 as u64;
            let val = (unit_field_val & mask) >> 13usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsStaticDocument(&mut self, val: bool) {
            let mask = 8192u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 13usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mCreatingStaticClone(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 16384u64 as u64;
            let val = (unit_field_val & mask) >> 14usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mCreatingStaticClone(&mut self, val: bool) {
            let mask = 16384u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 14usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mInUnlinkOrDeletion(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 32768u64 as u64;
            let val = (unit_field_val & mask) >> 15usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mInUnlinkOrDeletion(&mut self, val: bool) {
            let mask = 32768u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 15usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasHadScriptHandlingObject(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 65536u64 as u64;
            let val = (unit_field_val & mask) >> 16usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasHadScriptHandlingObject(&mut self, val: bool) {
            let mask = 65536u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 16usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsBeingUsedAsImage(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 131072u64 as u64;
            let val = (unit_field_val & mask) >> 17usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsBeingUsedAsImage(&mut self, val: bool) {
            let mask = 131072u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 17usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsSyntheticDocument(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 262144u64 as u64;
            let val = (unit_field_val & mask) >> 18usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsSyntheticDocument(&mut self, val: bool) {
            let mask = 262144u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 18usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasLinksToUpdate(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 524288u64 as u64;
            let val = (unit_field_val & mask) >> 19usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasLinksToUpdate(&mut self, val: bool) {
            let mask = 524288u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 19usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasLinksToUpdateRunnable(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 1048576u64 as u64;
            let val = (unit_field_val & mask) >> 20usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasLinksToUpdateRunnable(&mut self, val: bool) {
            let mask = 1048576u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 20usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mMayHaveDOMMutationObservers(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 2097152u64 as u64;
            let val = (unit_field_val & mask) >> 21usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mMayHaveDOMMutationObservers(&mut self, val: bool) {
            let mask = 2097152u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 21usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mMayHaveAnimationObservers(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 4194304u64 as u64;
            let val = (unit_field_val & mask) >> 22usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mMayHaveAnimationObservers(&mut self, val: bool) {
            let mask = 4194304u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 22usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasMixedActiveContentLoaded(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 8388608u64 as u64;
            let val = (unit_field_val & mask) >> 23usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasMixedActiveContentLoaded(&mut self, val: bool) {
            let mask = 8388608u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 23usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasMixedActiveContentBlocked(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 16777216u64 as u64;
            let val = (unit_field_val & mask) >> 24usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasMixedActiveContentBlocked(&mut self, val: bool) {
            let mask = 16777216u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 24usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasMixedDisplayContentLoaded(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 33554432u64 as u64;
            let val = (unit_field_val & mask) >> 25usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasMixedDisplayContentLoaded(&mut self, val: bool) {
            let mask = 33554432u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 25usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasMixedDisplayContentBlocked(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 67108864u64 as u64;
            let val = (unit_field_val & mask) >> 26usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasMixedDisplayContentBlocked(&mut self, val: bool) {
            let mask = 67108864u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 26usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasMixedContentObjectSubrequest(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 134217728u64 as u64;
            let val = (unit_field_val & mask) >> 27usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasMixedContentObjectSubrequest(&mut self, val: bool) {
            let mask = 134217728u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 27usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasCSP(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 268435456u64 as u64;
            let val = (unit_field_val & mask) >> 28usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasCSP(&mut self, val: bool) {
            let mask = 268435456u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 28usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasUnsafeEvalCSP(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 536870912u64 as u64;
            let val = (unit_field_val & mask) >> 29usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasUnsafeEvalCSP(&mut self, val: bool) {
            let mask = 536870912u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 29usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasUnsafeInlineCSP(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 1073741824u64 as u64;
            let val = (unit_field_val & mask) >> 30usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasUnsafeInlineCSP(&mut self, val: bool) {
            let mask = 1073741824u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 30usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasTrackingContentBlocked(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 2147483648u64 as u64;
            let val = (unit_field_val & mask) >> 31usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasTrackingContentBlocked(&mut self, val: bool) {
            let mask = 2147483648u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 31usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasTrackingContentLoaded(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 4294967296u64 as u64;
            let val = (unit_field_val & mask) >> 32usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasTrackingContentLoaded(&mut self, val: bool) {
            let mask = 4294967296u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 32usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mBFCacheDisallowed(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 8589934592u64 as u64;
            let val = (unit_field_val & mask) >> 33usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mBFCacheDisallowed(&mut self, val: bool) {
            let mask = 8589934592u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 33usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasHadDefaultView(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 17179869184u64 as u64;
            let val = (unit_field_val & mask) >> 34usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasHadDefaultView(&mut self, val: bool) {
            let mask = 17179869184u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 34usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mStyleSheetChangeEventsEnabled(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 34359738368u64 as u64;
            let val = (unit_field_val & mask) >> 35usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mStyleSheetChangeEventsEnabled(&mut self, val: bool) {
            let mask = 34359738368u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 35usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsSrcdocDocument(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 68719476736u64 as u64;
            let val = (unit_field_val & mask) >> 36usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsSrcdocDocument(&mut self, val: bool) {
            let mask = 68719476736u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 36usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mDidDocumentOpen(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 137438953472u64 as u64;
            let val = (unit_field_val & mask) >> 37usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mDidDocumentOpen(&mut self, val: bool) {
            let mask = 137438953472u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 37usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasDisplayDocument(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 274877906944u64 as u64;
            let val = (unit_field_val & mask) >> 38usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasDisplayDocument(&mut self, val: bool) {
            let mask = 274877906944u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 38usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mFontFaceSetDirty(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 549755813888u64 as u64;
            let val = (unit_field_val & mask) >> 39usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mFontFaceSetDirty(&mut self, val: bool) {
            let mask = 549755813888u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 39usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mGetUserFontSetCalled(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 1099511627776u64 as u64;
            let val = (unit_field_val & mask) >> 40usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mGetUserFontSetCalled(&mut self, val: bool) {
            let mask = 1099511627776u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 40usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPostedFlushUserFontSet(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 2199023255552u64 as u64;
            let val = (unit_field_val & mask) >> 41usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mPostedFlushUserFontSet(&mut self, val: bool) {
            let mask = 2199023255552u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 41usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mDidFireDOMContentLoaded(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 4398046511104u64 as u64;
            let val = (unit_field_val & mask) >> 42usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mDidFireDOMContentLoaded(&mut self, val: bool) {
            let mask = 4398046511104u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 42usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasScrollLinkedEffect(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 8796093022208u64 as u64;
            let val = (unit_field_val & mask) >> 43usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasScrollLinkedEffect(&mut self, val: bool) {
            let mask = 8796093022208u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 43usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mFrameRequestCallbacksScheduled(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 17592186044416u64 as u64;
            let val = (unit_field_val & mask) >> 44usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mFrameRequestCallbacksScheduled(&mut self, val: bool) {
            let mask = 17592186044416u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 44usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsTopLevelContentDocument(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 35184372088832u64 as u64;
            let val = (unit_field_val & mask) >> 45usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsTopLevelContentDocument(&mut self, val: bool) {
            let mask = 35184372088832u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 45usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsContentDocument(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 70368744177664u64 as u64;
            let val = (unit_field_val & mask) >> 46usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsContentDocument(&mut self, val: bool) {
            let mask = 70368744177664u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 46usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsScopedStyleEnabled(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 422212465065984u64 as u64;
            let val = (unit_field_val & mask) >> 47usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mIsScopedStyleEnabled(&mut self,
                                         val: ::std::os::raw::c_uint) {
            let mask = 422212465065984u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 47usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn new_bitfield_1(mBidiEnabled: bool, mMathMLEnabled: bool,
                              mIsInitialDocumentInWindow: bool,
                              mIgnoreDocGroupMismatches: bool,
                              mLoadedAsData: bool,
                              mLoadedAsInteractiveData: bool,
                              mMayStartLayout: bool,
                              mHaveFiredTitleChange: bool, mIsShowing: bool,
                              mVisible: bool, mHasReferrerPolicyCSP: bool,
                              mRemovedFromDocShell: bool,
                              mAllowDNSPrefetch: bool,
                              mIsStaticDocument: bool,
                              mCreatingStaticClone: bool,
                              mInUnlinkOrDeletion: bool,
                              mHasHadScriptHandlingObject: bool,
                              mIsBeingUsedAsImage: bool,
                              mIsSyntheticDocument: bool,
                              mHasLinksToUpdate: bool,
                              mHasLinksToUpdateRunnable: bool,
                              mMayHaveDOMMutationObservers: bool,
                              mMayHaveAnimationObservers: bool,
                              mHasMixedActiveContentLoaded: bool,
                              mHasMixedActiveContentBlocked: bool,
                              mHasMixedDisplayContentLoaded: bool,
                              mHasMixedDisplayContentBlocked: bool,
                              mHasMixedContentObjectSubrequest: bool,
                              mHasCSP: bool, mHasUnsafeEvalCSP: bool,
                              mHasUnsafeInlineCSP: bool,
                              mHasTrackingContentBlocked: bool,
                              mHasTrackingContentLoaded: bool,
                              mBFCacheDisallowed: bool,
                              mHasHadDefaultView: bool,
                              mStyleSheetChangeEventsEnabled: bool,
                              mIsSrcdocDocument: bool, mDidDocumentOpen: bool,
                              mHasDisplayDocument: bool,
                              mFontFaceSetDirty: bool,
                              mGetUserFontSetCalled: bool,
                              mPostedFlushUserFontSet: bool,
                              mDidFireDOMContentLoaded: bool,
                              mHasScrollLinkedEffect: bool,
                              mFrameRequestCallbacksScheduled: bool,
                              mIsTopLevelContentDocument: bool,
                              mIsContentDocument: bool,
                              mIsScopedStyleEnabled: ::std::os::raw::c_uint)
         -> u64 {
            ({
                 ({
                      ({
                           ({
                                ({
                                     ({
                                          ({
                                               ({
                                                    ({
                                                         ({
                                                              ({
                                                                   ({
                                                                        ({
                                                                             ({
                                                                                  ({
                                                                                       ({
                                                                                            ({
                                                                                                 ({
                                                                                                      ({
                                                                                                           ({
                                                                                                                ({
                                                                                                                     ({
                                                                                                                          ({
                                                                                                                               ({
                                                                                                                                    ({
                                                                                                                                         ({
                                                                                                                                              ({
                                                                                                                                                   ({
                                                                                                                                                        ({
                                                                                                                                                             ({
                                                                                                                                                                  ({
                                                                                                                                                                       ({
                                                                                                                                                                            ({
                                                                                                                                                                                 ({
                                                                                                                                                                                      ({
                                                                                                                                                                                           ({
                                                                                                                                                                                                ({
                                                                                                                                                                                                     ({
                                                                                                                                                                                                          ({
                                                                                                                                                                                                               ({
                                                                                                                                                                                                                    ({
                                                                                                                                                                                                                         ({
                                                                                                                                                                                                                              ({
                                                                                                                                                                                                                                   ({
                                                                                                                                                                                                                                        ({
                                                                                                                                                                                                                                             ({
                                                                                                                                                                                                                                                  ({
                                                                                                                                                                                                                                                       ({
                                                                                                                                                                                                                                                            0
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                            |
                                                                                                                                                                                                                                                            ((mBidiEnabled
                                                                                                                                                                                                                                                                  as
                                                                                                                                                                                                                                                                  u8
                                                                                                                                                                                                                                                                  as
                                                                                                                                                                                                                                                                  u64)
                                                                                                                                                                                                                                                                 <<
                                                                                                                                                                                                                                                                 0usize)
                                                                                                                                                                                                                                                                &
                                                                                                                                                                                                                                                                (1u64
                                                                                                                                                                                                                                                                     as
                                                                                                                                                                                                                                                                     u64))
                                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                                                       |
                                                                                                                                                                                                                                                       ((mMathMLEnabled
                                                                                                                                                                                                                                                             as
                                                                                                                                                                                                                                                             u8
                                                                                                                                                                                                                                                             as
                                                                                                                                                                                                                                                             u64)
                                                                                                                                                                                                                                                            <<
                                                                                                                                                                                                                                                            1usize)
                                                                                                                                                                                                                                                           &
                                                                                                                                                                                                                                                           (2u64
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                u64))
                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                                  |
                                                                                                                                                                                                                                                  ((mIsInitialDocumentInWindow
                                                                                                                                                                                                                                                        as
                                                                                                                                                                                                                                                        u8
                                                                                                                                                                                                                                                        as
                                                                                                                                                                                                                                                        u64)
                                                                                                                                                                                                                                                       <<
                                                                                                                                                                                                                                                       2usize)
                                                                                                                                                                                                                                                      &
                                                                                                                                                                                                                                                      (4u64
                                                                                                                                                                                                                                                           as
                                                                                                                                                                                                                                                           u64))
                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                             |
                                                                                                                                                                                                                                             ((mIgnoreDocGroupMismatches
                                                                                                                                                                                                                                                   as
                                                                                                                                                                                                                                                   u8
                                                                                                                                                                                                                                                   as
                                                                                                                                                                                                                                                   u64)
                                                                                                                                                                                                                                                  <<
                                                                                                                                                                                                                                                  3usize)
                                                                                                                                                                                                                                                 &
                                                                                                                                                                                                                                                 (8u64
                                                                                                                                                                                                                                                      as
                                                                                                                                                                                                                                                      u64))
                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                        |
                                                                                                                                                                                                                                        ((mLoadedAsData
                                                                                                                                                                                                                                              as
                                                                                                                                                                                                                                              u8
                                                                                                                                                                                                                                              as
                                                                                                                                                                                                                                              u64)
                                                                                                                                                                                                                                             <<
                                                                                                                                                                                                                                             4usize)
                                                                                                                                                                                                                                            &
                                                                                                                                                                                                                                            (16u64
                                                                                                                                                                                                                                                 as
                                                                                                                                                                                                                                                 u64))
                                                                                                                                                                                                                               }
                                                                                                                                                                                                                                   |
                                                                                                                                                                                                                                   ((mLoadedAsInteractiveData
                                                                                                                                                                                                                                         as
                                                                                                                                                                                                                                         u8
                                                                                                                                                                                                                                         as
                                                                                                                                                                                                                                         u64)
                                                                                                                                                                                                                                        <<
                                                                                                                                                                                                                                        5usize)
                                                                                                                                                                                                                                       &
                                                                                                                                                                                                                                       (32u64
                                                                                                                                                                                                                                            as
                                                                                                                                                                                                                                            u64))
                                                                                                                                                                                                                          }
                                                                                                                                                                                                                              |
                                                                                                                                                                                                                              ((mMayStartLayout
                                                                                                                                                                                                                                    as
                                                                                                                                                                                                                                    u8
                                                                                                                                                                                                                                    as
                                                                                                                                                                                                                                    u64)
                                                                                                                                                                                                                                   <<
                                                                                                                                                                                                                                   6usize)
                                                                                                                                                                                                                                  &
                                                                                                                                                                                                                                  (64u64
                                                                                                                                                                                                                                       as
                                                                                                                                                                                                                                       u64))
                                                                                                                                                                                                                     }
                                                                                                                                                                                                                         |
                                                                                                                                                                                                                         ((mHaveFiredTitleChange
                                                                                                                                                                                                                               as
                                                                                                                                                                                                                               u8
                                                                                                                                                                                                                               as
                                                                                                                                                                                                                               u64)
                                                                                                                                                                                                                              <<
                                                                                                                                                                                                                              7usize)
                                                                                                                                                                                                                             &
                                                                                                                                                                                                                             (128u64
                                                                                                                                                                                                                                  as
                                                                                                                                                                                                                                  u64))
                                                                                                                                                                                                                }
                                                                                                                                                                                                                    |
                                                                                                                                                                                                                    ((mIsShowing
                                                                                                                                                                                                                          as
                                                                                                                                                                                                                          u8
                                                                                                                                                                                                                          as
                                                                                                                                                                                                                          u64)
                                                                                                                                                                                                                         <<
                                                                                                                                                                                                                         8usize)
                                                                                                                                                                                                                        &
                                                                                                                                                                                                                        (256u64
                                                                                                                                                                                                                             as
                                                                                                                                                                                                                             u64))
                                                                                                                                                                                                           }
                                                                                                                                                                                                               |
                                                                                                                                                                                                               ((mVisible
                                                                                                                                                                                                                     as
                                                                                                                                                                                                                     u8
                                                                                                                                                                                                                     as
                                                                                                                                                                                                                     u64)
                                                                                                                                                                                                                    <<
                                                                                                                                                                                                                    9usize)
                                                                                                                                                                                                                   &
                                                                                                                                                                                                                   (512u64
                                                                                                                                                                                                                        as
                                                                                                                                                                                                                        u64))
                                                                                                                                                                                                      }
                                                                                                                                                                                                          |
                                                                                                                                                                                                          ((mHasReferrerPolicyCSP
                                                                                                                                                                                                                as
                                                                                                                                                                                                                u8
                                                                                                                                                                                                                as
                                                                                                                                                                                                                u64)
                                                                                                                                                                                                               <<
                                                                                                                                                                                                               10usize)
                                                                                                                                                                                                              &
                                                                                                                                                                                                              (1024u64
                                                                                                                                                                                                                   as
                                                                                                                                                                                                                   u64))
                                                                                                                                                                                                 }
                                                                                                                                                                                                     |
                                                                                                                                                                                                     ((mRemovedFromDocShell
                                                                                                                                                                                                           as
                                                                                                                                                                                                           u8
                                                                                                                                                                                                           as
                                                                                                                                                                                                           u64)
                                                                                                                                                                                                          <<
                                                                                                                                                                                                          11usize)
                                                                                                                                                                                                         &
                                                                                                                                                                                                         (2048u64
                                                                                                                                                                                                              as
                                                                                                                                                                                                              u64))
                                                                                                                                                                                            }
                                                                                                                                                                                                |
                                                                                                                                                                                                ((mAllowDNSPrefetch
                                                                                                                                                                                                      as
                                                                                                                                                                                                      u8
                                                                                                                                                                                                      as
                                                                                                                                                                                                      u64)
                                                                                                                                                                                                     <<
                                                                                                                                                                                                     12usize)
                                                                                                                                                                                                    &
                                                                                                                                                                                                    (4096u64
                                                                                                                                                                                                         as
                                                                                                                                                                                                         u64))
                                                                                                                                                                                       }
                                                                                                                                                                                           |
                                                                                                                                                                                           ((mIsStaticDocument
                                                                                                                                                                                                 as
                                                                                                                                                                                                 u8
                                                                                                                                                                                                 as
                                                                                                                                                                                                 u64)
                                                                                                                                                                                                <<
                                                                                                                                                                                                13usize)
                                                                                                                                                                                               &
                                                                                                                                                                                               (8192u64
                                                                                                                                                                                                    as
                                                                                                                                                                                                    u64))
                                                                                                                                                                                  }
                                                                                                                                                                                      |
                                                                                                                                                                                      ((mCreatingStaticClone
                                                                                                                                                                                            as
                                                                                                                                                                                            u8
                                                                                                                                                                                            as
                                                                                                                                                                                            u64)
                                                                                                                                                                                           <<
                                                                                                                                                                                           14usize)
                                                                                                                                                                                          &
                                                                                                                                                                                          (16384u64
                                                                                                                                                                                               as
                                                                                                                                                                                               u64))
                                                                                                                                                                             }
                                                                                                                                                                                 |
                                                                                                                                                                                 ((mInUnlinkOrDeletion
                                                                                                                                                                                       as
                                                                                                                                                                                       u8
                                                                                                                                                                                       as
                                                                                                                                                                                       u64)
                                                                                                                                                                                      <<
                                                                                                                                                                                      15usize)
                                                                                                                                                                                     &
                                                                                                                                                                                     (32768u64
                                                                                                                                                                                          as
                                                                                                                                                                                          u64))
                                                                                                                                                                        }
                                                                                                                                                                            |
                                                                                                                                                                            ((mHasHadScriptHandlingObject
                                                                                                                                                                                  as
                                                                                                                                                                                  u8
                                                                                                                                                                                  as
                                                                                                                                                                                  u64)
                                                                                                                                                                                 <<
                                                                                                                                                                                 16usize)
                                                                                                                                                                                &
                                                                                                                                                                                (65536u64
                                                                                                                                                                                     as
                                                                                                                                                                                     u64))
                                                                                                                                                                   }
                                                                                                                                                                       |
                                                                                                                                                                       ((mIsBeingUsedAsImage
                                                                                                                                                                             as
                                                                                                                                                                             u8
                                                                                                                                                                             as
                                                                                                                                                                             u64)
                                                                                                                                                                            <<
                                                                                                                                                                            17usize)
                                                                                                                                                                           &
                                                                                                                                                                           (131072u64
                                                                                                                                                                                as
                                                                                                                                                                                u64))
                                                                                                                                                              }
                                                                                                                                                                  |
                                                                                                                                                                  ((mIsSyntheticDocument
                                                                                                                                                                        as
                                                                                                                                                                        u8
                                                                                                                                                                        as
                                                                                                                                                                        u64)
                                                                                                                                                                       <<
                                                                                                                                                                       18usize)
                                                                                                                                                                      &
                                                                                                                                                                      (262144u64
                                                                                                                                                                           as
                                                                                                                                                                           u64))
                                                                                                                                                         }
                                                                                                                                                             |
                                                                                                                                                             ((mHasLinksToUpdate
                                                                                                                                                                   as
                                                                                                                                                                   u8
                                                                                                                                                                   as
                                                                                                                                                                   u64)
                                                                                                                                                                  <<
                                                                                                                                                                  19usize)
                                                                                                                                                                 &
                                                                                                                                                                 (524288u64
                                                                                                                                                                      as
                                                                                                                                                                      u64))
                                                                                                                                                    }
                                                                                                                                                        |
                                                                                                                                                        ((mHasLinksToUpdateRunnable
                                                                                                                                                              as
                                                                                                                                                              u8
                                                                                                                                                              as
                                                                                                                                                              u64)
                                                                                                                                                             <<
                                                                                                                                                             20usize)
                                                                                                                                                            &
                                                                                                                                                            (1048576u64
                                                                                                                                                                 as
                                                                                                                                                                 u64))
                                                                                                                                               }
                                                                                                                                                   |
                                                                                                                                                   ((mMayHaveDOMMutationObservers
                                                                                                                                                         as
                                                                                                                                                         u8
                                                                                                                                                         as
                                                                                                                                                         u64)
                                                                                                                                                        <<
                                                                                                                                                        21usize)
                                                                                                                                                       &
                                                                                                                                                       (2097152u64
                                                                                                                                                            as
                                                                                                                                                            u64))
                                                                                                                                          }
                                                                                                                                              |
                                                                                                                                              ((mMayHaveAnimationObservers
                                                                                                                                                    as
                                                                                                                                                    u8
                                                                                                                                                    as
                                                                                                                                                    u64)
                                                                                                                                                   <<
                                                                                                                                                   22usize)
                                                                                                                                                  &
                                                                                                                                                  (4194304u64
                                                                                                                                                       as
                                                                                                                                                       u64))
                                                                                                                                     }
                                                                                                                                         |
                                                                                                                                         ((mHasMixedActiveContentLoaded
                                                                                                                                               as
                                                                                                                                               u8
                                                                                                                                               as
                                                                                                                                               u64)
                                                                                                                                              <<
                                                                                                                                              23usize)
                                                                                                                                             &
                                                                                                                                             (8388608u64
                                                                                                                                                  as
                                                                                                                                                  u64))
                                                                                                                                }
                                                                                                                                    |
                                                                                                                                    ((mHasMixedActiveContentBlocked
                                                                                                                                          as
                                                                                                                                          u8
                                                                                                                                          as
                                                                                                                                          u64)
                                                                                                                                         <<
                                                                                                                                         24usize)
                                                                                                                                        &
                                                                                                                                        (16777216u64
                                                                                                                                             as
                                                                                                                                             u64))
                                                                                                                           }
                                                                                                                               |
                                                                                                                               ((mHasMixedDisplayContentLoaded
                                                                                                                                     as
                                                                                                                                     u8
                                                                                                                                     as
                                                                                                                                     u64)
                                                                                                                                    <<
                                                                                                                                    25usize)
                                                                                                                                   &
                                                                                                                                   (33554432u64
                                                                                                                                        as
                                                                                                                                        u64))
                                                                                                                      }
                                                                                                                          |
                                                                                                                          ((mHasMixedDisplayContentBlocked
                                                                                                                                as
                                                                                                                                u8
                                                                                                                                as
                                                                                                                                u64)
                                                                                                                               <<
                                                                                                                               26usize)
                                                                                                                              &
                                                                                                                              (67108864u64
                                                                                                                                   as
                                                                                                                                   u64))
                                                                                                                 }
                                                                                                                     |
                                                                                                                     ((mHasMixedContentObjectSubrequest
                                                                                                                           as
                                                                                                                           u8
                                                                                                                           as
                                                                                                                           u64)
                                                                                                                          <<
                                                                                                                          27usize)
                                                                                                                         &
                                                                                                                         (134217728u64
                                                                                                                              as
                                                                                                                              u64))
                                                                                                            }
                                                                                                                |
                                                                                                                ((mHasCSP
                                                                                                                      as
                                                                                                                      u8
                                                                                                                      as
                                                                                                                      u64)
                                                                                                                     <<
                                                                                                                     28usize)
                                                                                                                    &
                                                                                                                    (268435456u64
                                                                                                                         as
                                                                                                                         u64))
                                                                                                       }
                                                                                                           |
                                                                                                           ((mHasUnsafeEvalCSP
                                                                                                                 as
                                                                                                                 u8
                                                                                                                 as
                                                                                                                 u64)
                                                                                                                <<
                                                                                                                29usize)
                                                                                                               &
                                                                                                               (536870912u64
                                                                                                                    as
                                                                                                                    u64))
                                                                                                  }
                                                                                                      |
                                                                                                      ((mHasUnsafeInlineCSP
                                                                                                            as
                                                                                                            u8
                                                                                                            as
                                                                                                            u64)
                                                                                                           <<
                                                                                                           30usize)
                                                                                                          &
                                                                                                          (1073741824u64
                                                                                                               as
                                                                                                               u64))
                                                                                             }
                                                                                                 |
                                                                                                 ((mHasTrackingContentBlocked
                                                                                                       as
                                                                                                       u8
                                                                                                       as
                                                                                                       u64)
                                                                                                      <<
                                                                                                      31usize)
                                                                                                     &
                                                                                                     (2147483648u64
                                                                                                          as
                                                                                                          u64))
                                                                                        }
                                                                                            |
                                                                                            ((mHasTrackingContentLoaded
                                                                                                  as
                                                                                                  u8
                                                                                                  as
                                                                                                  u64)
                                                                                                 <<
                                                                                                 32usize)
                                                                                                &
                                                                                                (4294967296u64
                                                                                                     as
                                                                                                     u64))
                                                                                   }
                                                                                       |
                                                                                       ((mBFCacheDisallowed
                                                                                             as
                                                                                             u8
                                                                                             as
                                                                                             u64)
                                                                                            <<
                                                                                            33usize)
                                                                                           &
                                                                                           (8589934592u64
                                                                                                as
                                                                                                u64))
                                                                              }
                                                                                  |
                                                                                  ((mHasHadDefaultView
                                                                                        as
                                                                                        u8
                                                                                        as
                                                                                        u64)
                                                                                       <<
                                                                                       34usize)
                                                                                      &
                                                                                      (17179869184u64
                                                                                           as
                                                                                           u64))
                                                                         } |
                                                                             ((mStyleSheetChangeEventsEnabled
                                                                                   as
                                                                                   u8
                                                                                   as
                                                                                   u64)
                                                                                  <<
                                                                                  35usize)
                                                                                 &
                                                                                 (34359738368u64
                                                                                      as
                                                                                      u64))
                                                                    } |
                                                                        ((mIsSrcdocDocument
                                                                              as
                                                                              u8
                                                                              as
                                                                              u64)
                                                                             <<
                                                                             36usize)
                                                                            &
                                                                            (68719476736u64
                                                                                 as
                                                                                 u64))
                                                               } |
                                                                   ((mDidDocumentOpen
                                                                         as u8
                                                                         as
                                                                         u64)
                                                                        <<
                                                                        37usize)
                                                                       &
                                                                       (137438953472u64
                                                                            as
                                                                            u64))
                                                          } |
                                                              ((mHasDisplayDocument
                                                                    as u8 as
                                                                    u64) <<
                                                                   38usize) &
                                                                  (274877906944u64
                                                                       as
                                                                       u64))
                                                     } |
                                                         ((mFontFaceSetDirty
                                                               as u8 as u64)
                                                              << 39usize) &
                                                             (549755813888u64
                                                                  as u64))
                                                } |
                                                    ((mGetUserFontSetCalled as
                                                          u8 as u64) <<
                                                         40usize) &
                                                        (1099511627776u64 as
                                                             u64))
                                           } |
                                               ((mPostedFlushUserFontSet as u8
                                                     as u64) << 41usize) &
                                                   (2199023255552u64 as u64))
                                      } |
                                          ((mDidFireDOMContentLoaded as u8 as
                                                u64) << 42usize) &
                                              (4398046511104u64 as u64))
                                 } |
                                     ((mHasScrollLinkedEffect as u8 as u64) <<
                                          43usize) &
                                         (8796093022208u64 as u64))
                            } |
                                ((mFrameRequestCallbacksScheduled as u8 as
                                      u64) << 44usize) &
                                    (17592186044416u64 as u64))
                       } |
                           ((mIsTopLevelContentDocument as u8 as u64) <<
                                45usize) & (35184372088832u64 as u64))
                  } |
                      ((mIsContentDocument as u8 as u64) << 46usize) &
                          (70368744177664u64 as u64))
             } |
                 ((mIsScopedStyleEnabled as u32 as u64) << 47usize) &
                     (422212465065984u64 as u64))
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSCounterStyleRule {
        pub _base: root::mozilla::css::Rule,
        pub _base_1: root::nsIDOMCSSCounterStyleRule,
        pub mName: root::nsCOMPtr,
        pub mValues: [root::nsCSSValue; 10usize],
        pub mGeneration: u32,
    }
    pub type nsCSSCounterStyleRule_Getter =
        ::std::option::Option<unsafe extern "C" fn() -> root::nsresult>;
    extern "C" {
        #[link_name = "_ZN21nsCSSCounterStyleRule8kGettersE"]
        pub static mut nsCSSCounterStyleRule_kGetters:
                   [root::nsCSSCounterStyleRule_Getter; 0usize];
    }
    #[test]
    fn bindgen_test_layout_nsCSSCounterStyleRule() {
        assert_eq!(::std::mem::size_of::<nsCSSCounterStyleRule>() , 248usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSCounterStyleRule ) ));
        assert_eq! (::std::mem::align_of::<nsCSSCounterStyleRule>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSCounterStyleRule )
                    ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsFontFaceRuleContainer {
        pub mRule: root::RefPtr<root::nsCSSFontFaceRule>,
        pub mSheetType: root::mozilla::SheetType,
    }
    #[test]
    fn bindgen_test_layout_nsFontFaceRuleContainer() {
        assert_eq!(::std::mem::size_of::<nsFontFaceRuleContainer>() , 16usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsFontFaceRuleContainer ) ));
        assert_eq! (::std::mem::align_of::<nsFontFaceRuleContainer>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsFontFaceRuleContainer )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFontFaceRuleContainer ) ) . mRule
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsFontFaceRuleContainer ) , "::" , stringify ! ( mRule )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFontFaceRuleContainer ) ) .
                    mSheetType as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsFontFaceRuleContainer ) , "::" , stringify ! (
                    mSheetType ) ));
    }
    /**
 * A node of content in a document's content model. This interface
 * is supported by all content objects.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIContent {
        pub _base: root::nsINode,
    }
    pub type nsIContent_IMEState = root::mozilla::widget::IMEState;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIContent_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsIContent_eAllChildren: root::nsIContent__bindgen_ty_1 =
        nsIContent__bindgen_ty_1::eAllChildren;
    pub const nsIContent_eAllButXBL: root::nsIContent__bindgen_ty_1 =
        nsIContent__bindgen_ty_1::eAllButXBL;
    pub const nsIContent_eSkipPlaceholderContent:
              root::nsIContent__bindgen_ty_1 =
        nsIContent__bindgen_ty_1::eSkipPlaceholderContent;
    pub const nsIContent_eSkipDocumentLevelNativeAnonymousContent:
              root::nsIContent__bindgen_ty_1 =
        nsIContent__bindgen_ty_1::eSkipDocumentLevelNativeAnonymousContent;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIContent__bindgen_ty_1 {
        eAllChildren = 0,
        eAllButXBL = 1,
        eSkipPlaceholderContent = 2,
        eSkipDocumentLevelNativeAnonymousContent = 4,
    }
    pub const nsIContent_ATTR_MISSING: root::nsIContent__bindgen_ty_2 =
        nsIContent__bindgen_ty_2::ATTR_MISSING;
    pub const nsIContent_ATTR_VALUE_NO_MATCH: root::nsIContent__bindgen_ty_2 =
        nsIContent__bindgen_ty_2::ATTR_VALUE_NO_MATCH;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIContent__bindgen_ty_2 {
        ATTR_MISSING = -1,
        ATTR_VALUE_NO_MATCH = -2,
    }
    /**
   * Check whether this content node's given attribute has one of a given
   * list of values. If there is a match, we return the index in the list
   * of the first matching value. If there was no attribute at all, then
   * we return ATTR_MISSING. If there was an attribute but it didn't
   * match, we return ATTR_VALUE_NO_MATCH. A non-negative result always
   * indicates a match.
   *
   * @param aNameSpaceID The namespace ID of the attribute.  Must not
   *                     be kNameSpaceID_Unknown.
   * @param aName The name atom of the attribute.  Must not be null.
   * @param aValues a nullptr-terminated array of pointers to atom values to test
   *                against.
   * @param aCaseSensitive Whether to do a case-sensitive compare on the values.
   * @return ATTR_MISSING, ATTR_VALUE_NO_MATCH or the non-negative index
   * indicating the first value of aValues that matched
   */
    pub type nsIContent_AttrValuesArray = *const *const root::nsIAtom;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIContent_FlattenedParentType {
        eNotForStyle = 0,
        eForStyle = 1,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIContent_ETabFocusType {
        eTabFocus_textControlsMask = 1,
        eTabFocus_formElementsMask = 2,
        eTabFocus_linksMask = 4,
        eTabFocus_any = 7,
    }
    extern "C" {
        #[link_name = "_ZN10nsIContent14sTabFocusModelE"]
        pub static mut nsIContent_sTabFocusModel: i32;
    }
    extern "C" {
        #[link_name = "_ZN10nsIContent26sTabFocusModelAppliesToXULE"]
        pub static mut nsIContent_sTabFocusModelAppliesToXUL: bool;
    }
    #[test]
    fn bindgen_test_layout_nsIContent() {
        assert_eq!(::std::mem::size_of::<nsIContent>() , 88usize , concat ! (
                   "Size of: " , stringify ! ( nsIContent ) ));
        assert_eq! (::std::mem::align_of::<nsIContent>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIContent ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsStyleContext {
        _unused: [u8; 0],
    }
    #[repr(C)]
    pub struct nsPresContext {
        pub _base: root::nsIObserver,
        pub _base_1: u64,
        pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
        pub mType: root::nsPresContext_nsPresContextType,
        pub mShell: *mut root::nsIPresShell,
        pub mDocument: root::nsCOMPtr,
        pub mDeviceContext: root::RefPtr<root::nsDeviceContext>,
        pub mEventManager: root::RefPtr<root::mozilla::EventStateManager>,
        pub mRefreshDriver: root::RefPtr<root::nsRefreshDriver>,
        pub mEffectCompositor: root::RefPtr<root::mozilla::EffectCompositor>,
        pub mTransitionManager: root::RefPtr<root::nsTransitionManager>,
        pub mAnimationManager: root::RefPtr<root::nsAnimationManager>,
        pub mRestyleManager: root::RefPtr<root::mozilla::RestyleManager>,
        pub mCounterStyleManager: root::RefPtr<root::mozilla::CounterStyleManager>,
        pub mMedium: *mut root::nsIAtom,
        pub mMediaEmulated: root::nsCOMPtr,
        pub mLinkHandler: *mut root::nsILinkHandler,
        pub mLanguage: root::nsCOMPtr,
        pub mInflationDisabledForShrinkWrap: bool,
        pub mContainer: u64,
        pub mBaseMinFontSize: i32,
        pub mSystemFontScale: f32,
        pub mTextZoom: f32,
        pub mEffectiveTextZoom: f32,
        pub mFullZoom: f32,
        pub mOverrideDPPX: f32,
        pub mLastFontInflationScreenSize: root::gfxSize,
        pub mCurAppUnitsPerDevPixel: i32,
        pub mAutoQualityMinFontSizePixelsPref: i32,
        pub mTheme: root::nsCOMPtr,
        pub mLangService: *mut root::nsLanguageAtomService,
        pub mPrintSettings: root::nsCOMPtr,
        pub mPrefChangedTimer: root::nsCOMPtr,
        pub mBidiEngine: root::mozilla::UniquePtr<root::nsBidi>,
        pub mTransactions: [u64; 10usize],
        pub mTextPerf: root::nsAutoPtr<root::gfxTextPerfMetrics>,
        pub mMissingFonts: root::nsAutoPtr<root::gfxMissingFontRecorder>,
        pub mVisibleArea: root::nsRect,
        pub mPageSize: root::nsSize,
        pub mPageScale: f32,
        pub mPPScale: f32,
        pub mDefaultColor: root::nscolor,
        pub mBackgroundColor: root::nscolor,
        pub mLinkColor: root::nscolor,
        pub mActiveLinkColor: root::nscolor,
        pub mVisitedLinkColor: root::nscolor,
        pub mFocusBackgroundColor: root::nscolor,
        pub mFocusTextColor: root::nscolor,
        pub mBodyTextColor: root::nscolor,
        pub mViewportScrollbarOverrideNode: *mut root::nsIContent,
        pub mViewportStyleScrollbar: root::nsPresContext_ScrollbarStyles,
        pub mFocusRingWidth: u8,
        pub mExistThrottledUpdates: bool,
        pub mImageAnimationMode: u16,
        pub mImageAnimationModePref: u16,
        pub mLangGroupFontPrefs: root::nsPresContext_LangGroupFontPrefs,
        pub mFontGroupCacheDirty: bool,
        pub mLanguagesUsed: [u64; 5usize],
        pub mBorderWidthTable: [root::nscoord; 3usize],
        pub mInterruptChecksToSkip: u32,
        pub mElementsRestyled: u64,
        pub mFramesConstructed: u64,
        pub mFramesReflowed: u64,
        pub mReflowStartTime: root::mozilla::TimeStamp,
        pub mFirstNonBlankPaintTime: root::mozilla::TimeStamp,
        pub mFirstClickTime: root::mozilla::TimeStamp,
        pub mFirstKeyTime: root::mozilla::TimeStamp,
        pub mFirstMouseMoveTime: root::mozilla::TimeStamp,
        pub mFirstScrollTime: root::mozilla::TimeStamp,
        pub mInteractionTimeEnabled: bool,
        pub mLastStyleUpdateForAllAnimations: root::mozilla::TimeStamp,
        pub mTelemetryScrollLastY: root::nscoord,
        pub mTelemetryScrollMaxY: root::nscoord,
        pub mTelemetryScrollTotalY: root::nscoord,
        pub _bitfield_1: [u8; 6usize],
        pub __bindgen_padding_0: [u16; 3usize],
    }
    pub type nsPresContext_Encoding = root::mozilla::Encoding;
    pub type nsPresContext_NotNull<T> = root::mozilla::NotNull<T>;
    pub type nsPresContext_LangGroupFontPrefs =
        root::mozilla::LangGroupFontPrefs;
    pub type nsPresContext_ScrollbarStyles = root::mozilla::ScrollbarStyles;
    pub type nsPresContext_StaticPresData = root::mozilla::StaticPresData;
    pub type nsPresContext_HasThreadSafeRefCnt = root::mozilla::FalseType;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsPresContext_cycleCollection {
        pub _base: root::nsXPCOMCycleCollectionParticipant,
    }
    #[test]
    fn bindgen_test_layout_nsPresContext_cycleCollection() {
        assert_eq!(::std::mem::size_of::<nsPresContext_cycleCollection>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( nsPresContext_cycleCollection )
                   ));
        assert_eq! (::std::mem::align_of::<nsPresContext_cycleCollection>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsPresContext_cycleCollection ) ));
    }
    impl Clone for nsPresContext_cycleCollection {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsPresContext_nsPresContextType {
        eContext_Galley = 0,
        eContext_PrintPreview = 1,
        eContext_Print = 2,
        eContext_PageLayout = 3,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsPresContext_InteractionType {
        eClickInteraction = 0,
        eKeyInteraction = 1,
        eMouseMoveInteraction = 2,
        eScrollInteraction = 3,
    }
    /**
   * A class that can be used to temporarily disable reflow interruption.
   */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPresContext_InterruptPreventer {
        pub mCtx: *mut root::nsPresContext,
        pub mInterruptsEnabled: bool,
        pub mHasPendingInterrupt: bool,
    }
    #[test]
    fn bindgen_test_layout_nsPresContext_InterruptPreventer() {
        assert_eq!(::std::mem::size_of::<nsPresContext_InterruptPreventer>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsPresContext_InterruptPreventer ) ));
        assert_eq! (::std::mem::align_of::<nsPresContext_InterruptPreventer>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsPresContext_InterruptPreventer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext_InterruptPreventer ) )
                    . mCtx as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresContext_InterruptPreventer ) , "::" , stringify ! (
                    mCtx ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext_InterruptPreventer ) )
                    . mInterruptsEnabled as * const _ as usize } , 8usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresContext_InterruptPreventer ) , "::" , stringify ! (
                    mInterruptsEnabled ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext_InterruptPreventer ) )
                    . mHasPendingInterrupt as * const _ as usize } , 9usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresContext_InterruptPreventer ) , "::" , stringify ! (
                    mHasPendingInterrupt ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPresContext_TransactionInvalidations {
        pub mTransactionId: u64,
        pub mInvalidations: root::nsTArray<root::nsRect>,
    }
    #[test]
    fn bindgen_test_layout_nsPresContext_TransactionInvalidations() {
        assert_eq!(::std::mem::size_of::<nsPresContext_TransactionInvalidations>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsPresContext_TransactionInvalidations ) ));
        assert_eq! (::std::mem::align_of::<nsPresContext_TransactionInvalidations>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsPresContext_TransactionInvalidations ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsPresContext_TransactionInvalidations )
                    ) . mTransactionId as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresContext_TransactionInvalidations ) , "::" ,
                    stringify ! ( mTransactionId ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsPresContext_TransactionInvalidations )
                    ) . mInvalidations as * const _ as usize } , 8usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresContext_TransactionInvalidations ) , "::" ,
                    stringify ! ( mInvalidations ) ));
    }
    extern "C" {
        #[link_name = "_ZN13nsPresContext21_cycleCollectorGlobalE"]
        pub static mut nsPresContext__cycleCollectorGlobal:
                   root::nsPresContext_cycleCollection;
    }
    #[test]
    fn bindgen_test_layout_nsPresContext() {
        assert_eq!(::std::mem::size_of::<nsPresContext>() , 1304usize , concat
                   ! ( "Size of: " , stringify ! ( nsPresContext ) ));
        assert_eq! (::std::mem::align_of::<nsPresContext>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsPresContext ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mRefCnt as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mType as * const
                    _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mShell as * const
                    _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mShell ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mDocument as *
                    const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mDocument ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mDeviceContext as
                    * const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mDeviceContext ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mEventManager as
                    * const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mEventManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mRefreshDriver as
                    * const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mRefreshDriver ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mEffectCompositor
                    as * const _ as usize } , 72usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mEffectCompositor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mTransitionManager as * const _ as usize } , 80usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mTransitionManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mAnimationManager
                    as * const _ as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mAnimationManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mRestyleManager
                    as * const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mRestyleManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mCounterStyleManager as * const _ as usize } , 104usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mCounterStyleManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mMedium as *
                    const _ as usize } , 112usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mMedium ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mMediaEmulated as
                    * const _ as usize } , 120usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mMediaEmulated ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mLinkHandler as *
                    const _ as usize } , 128usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLinkHandler ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mLanguage as *
                    const _ as usize } , 136usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLanguage ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mInflationDisabledForShrinkWrap as * const _ as usize } ,
                    144usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mInflationDisabledForShrinkWrap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mContainer as *
                    const _ as usize } , 152usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mContainer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mBaseMinFontSize
                    as * const _ as usize } , 160usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mBaseMinFontSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mSystemFontScale
                    as * const _ as usize } , 164usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mSystemFontScale ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mTextZoom as *
                    const _ as usize } , 168usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mTextZoom ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mEffectiveTextZoom as * const _ as usize } , 172usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mEffectiveTextZoom ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mFullZoom as *
                    const _ as usize } , 176usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFullZoom ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mOverrideDPPX as
                    * const _ as usize } , 180usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mOverrideDPPX ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mLastFontInflationScreenSize as * const _ as usize } ,
                    184usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLastFontInflationScreenSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mCurAppUnitsPerDevPixel as * const _ as usize } , 200usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mCurAppUnitsPerDevPixel ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mAutoQualityMinFontSizePixelsPref as * const _ as usize }
                    , 204usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mAutoQualityMinFontSizePixelsPref )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mTheme as * const
                    _ as usize } , 208usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mTheme ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mLangService as *
                    const _ as usize } , 216usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLangService ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mPrintSettings as
                    * const _ as usize } , 224usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mPrintSettings ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mPrefChangedTimer
                    as * const _ as usize } , 232usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mPrefChangedTimer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mBidiEngine as *
                    const _ as usize } , 240usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mBidiEngine ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mTransactions as
                    * const _ as usize } , 248usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mTransactions ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mTextPerf as *
                    const _ as usize } , 328usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mTextPerf ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mMissingFonts as
                    * const _ as usize } , 336usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mMissingFonts ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mVisibleArea as *
                    const _ as usize } , 344usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mVisibleArea ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mPageSize as *
                    const _ as usize } , 360usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mPageSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mPageScale as *
                    const _ as usize } , 368usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mPageScale ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mPPScale as *
                    const _ as usize } , 372usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mPPScale ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mDefaultColor as
                    * const _ as usize } , 376usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mDefaultColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mBackgroundColor
                    as * const _ as usize } , 380usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mBackgroundColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mLinkColor as *
                    const _ as usize } , 384usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLinkColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mActiveLinkColor
                    as * const _ as usize } , 388usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mActiveLinkColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mVisitedLinkColor
                    as * const _ as usize } , 392usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mVisitedLinkColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mFocusBackgroundColor as * const _ as usize } , 396usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFocusBackgroundColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mFocusTextColor
                    as * const _ as usize } , 400usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFocusTextColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mBodyTextColor as
                    * const _ as usize } , 404usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mBodyTextColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mViewportScrollbarOverrideNode as * const _ as usize } ,
                    408usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mViewportScrollbarOverrideNode ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mViewportStyleScrollbar as * const _ as usize } , 416usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mViewportStyleScrollbar ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mFocusRingWidth
                    as * const _ as usize } , 480usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFocusRingWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mExistThrottledUpdates as * const _ as usize } , 481usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mExistThrottledUpdates ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mImageAnimationMode as * const _ as usize } , 482usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mImageAnimationMode ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mImageAnimationModePref as * const _ as usize } , 484usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mImageAnimationModePref ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mLangGroupFontPrefs as * const _ as usize } , 488usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLangGroupFontPrefs ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mFontGroupCacheDirty as * const _ as usize } , 1128usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFontGroupCacheDirty ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mLanguagesUsed as
                    * const _ as usize } , 1136usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLanguagesUsed ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mBorderWidthTable
                    as * const _ as usize } , 1176usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mBorderWidthTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mInterruptChecksToSkip as * const _ as usize } , 1188usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mInterruptChecksToSkip ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mElementsRestyled
                    as * const _ as usize } , 1192usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mElementsRestyled ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mFramesConstructed as * const _ as usize } , 1200usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFramesConstructed ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mFramesReflowed
                    as * const _ as usize } , 1208usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFramesReflowed ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mReflowStartTime
                    as * const _ as usize } , 1216usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mReflowStartTime ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mFirstNonBlankPaintTime as * const _ as usize } ,
                    1224usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFirstNonBlankPaintTime ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mFirstClickTime
                    as * const _ as usize } , 1232usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFirstClickTime ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mFirstKeyTime as
                    * const _ as usize } , 1240usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFirstKeyTime ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mFirstMouseMoveTime as * const _ as usize } , 1248usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFirstMouseMoveTime ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mFirstScrollTime
                    as * const _ as usize } , 1256usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFirstScrollTime ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mInteractionTimeEnabled as * const _ as usize } ,
                    1264usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mInteractionTimeEnabled ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mLastStyleUpdateForAllAnimations as * const _ as usize } ,
                    1272usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLastStyleUpdateForAllAnimations )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mTelemetryScrollLastY as * const _ as usize } , 1280usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mTelemetryScrollLastY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mTelemetryScrollMaxY as * const _ as usize } , 1284usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mTelemetryScrollMaxY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mTelemetryScrollTotalY as * const _ as usize } , 1288usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mTelemetryScrollTotalY ) ));
    }
    impl nsPresContext {
        #[inline]
        pub fn mHasPendingInterrupt(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 1u64 as u64;
            let val = (unit_field_val & mask) >> 0usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mHasPendingInterrupt(&mut self,
                                        val: ::std::os::raw::c_uint) {
            let mask = 1u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 0usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPendingInterruptFromTest(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 2u64 as u64;
            let val = (unit_field_val & mask) >> 1usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPendingInterruptFromTest(&mut self,
                                             val: ::std::os::raw::c_uint) {
            let mask = 2u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 1usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mInterruptsEnabled(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 4u64 as u64;
            let val = (unit_field_val & mask) >> 2usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mInterruptsEnabled(&mut self,
                                      val: ::std::os::raw::c_uint) {
            let mask = 4u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 2usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mUseDocumentFonts(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 8u64 as u64;
            let val = (unit_field_val & mask) >> 3usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mUseDocumentFonts(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 8u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 3usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mUseDocumentColors(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 16u64 as u64;
            let val = (unit_field_val & mask) >> 4usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mUseDocumentColors(&mut self,
                                      val: ::std::os::raw::c_uint) {
            let mask = 16u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 4usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mUnderlineLinks(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 32u64 as u64;
            let val = (unit_field_val & mask) >> 5usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mUnderlineLinks(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 32u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 5usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mSendAfterPaintToContent(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 64u64 as u64;
            let val = (unit_field_val & mask) >> 6usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mSendAfterPaintToContent(&mut self,
                                            val: ::std::os::raw::c_uint) {
            let mask = 64u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 6usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mUseFocusColors(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 128u64 as u64;
            let val = (unit_field_val & mask) >> 7usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mUseFocusColors(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 128u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 7usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mFocusRingOnAnything(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 256u64 as u64;
            let val = (unit_field_val & mask) >> 8usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mFocusRingOnAnything(&mut self,
                                        val: ::std::os::raw::c_uint) {
            let mask = 256u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 8usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mFocusRingStyle(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 512u64 as u64;
            let val = (unit_field_val & mask) >> 9usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mFocusRingStyle(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 512u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 9usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mDrawImageBackground(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 1024u64 as u64;
            let val = (unit_field_val & mask) >> 10usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mDrawImageBackground(&mut self,
                                        val: ::std::os::raw::c_uint) {
            let mask = 1024u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 10usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mDrawColorBackground(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 2048u64 as u64;
            let val = (unit_field_val & mask) >> 11usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mDrawColorBackground(&mut self,
                                        val: ::std::os::raw::c_uint) {
            let mask = 2048u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 11usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mNeverAnimate(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 4096u64 as u64;
            let val = (unit_field_val & mask) >> 12usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mNeverAnimate(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 4096u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 12usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsRenderingOnlySelection(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 8192u64 as u64;
            let val = (unit_field_val & mask) >> 13usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mIsRenderingOnlySelection(&mut self,
                                             val: ::std::os::raw::c_uint) {
            let mask = 8192u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 13usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPaginated(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 16384u64 as u64;
            let val = (unit_field_val & mask) >> 14usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPaginated(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 16384u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 14usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mCanPaginatedScroll(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 32768u64 as u64;
            let val = (unit_field_val & mask) >> 15usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mCanPaginatedScroll(&mut self,
                                       val: ::std::os::raw::c_uint) {
            let mask = 32768u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 15usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mDoScaledTwips(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 65536u64 as u64;
            let val = (unit_field_val & mask) >> 16usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mDoScaledTwips(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 65536u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 16usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsRootPaginatedDocument(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 131072u64 as u64;
            let val = (unit_field_val & mask) >> 17usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mIsRootPaginatedDocument(&mut self,
                                            val: ::std::os::raw::c_uint) {
            let mask = 131072u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 17usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPrefBidiDirection(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 262144u64 as u64;
            let val = (unit_field_val & mask) >> 18usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPrefBidiDirection(&mut self,
                                      val: ::std::os::raw::c_uint) {
            let mask = 262144u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 18usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPrefScrollbarSide(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 1572864u64 as u64;
            let val = (unit_field_val & mask) >> 19usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPrefScrollbarSide(&mut self,
                                      val: ::std::os::raw::c_uint) {
            let mask = 1572864u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 19usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPendingSysColorChanged(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 2097152u64 as u64;
            let val = (unit_field_val & mask) >> 21usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPendingSysColorChanged(&mut self,
                                           val: ::std::os::raw::c_uint) {
            let mask = 2097152u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 21usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPendingThemeChanged(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 4194304u64 as u64;
            let val = (unit_field_val & mask) >> 22usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPendingThemeChanged(&mut self,
                                        val: ::std::os::raw::c_uint) {
            let mask = 4194304u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 22usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPendingUIResolutionChanged(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 8388608u64 as u64;
            let val = (unit_field_val & mask) >> 23usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPendingUIResolutionChanged(&mut self,
                                               val: ::std::os::raw::c_uint) {
            let mask = 8388608u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 23usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPendingMediaFeatureValuesChanged(&self)
         -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 16777216u64 as u64;
            let val = (unit_field_val & mask) >> 24usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPendingMediaFeatureValuesChanged(&mut self,
                                                     val:
                                                         ::std::os::raw::c_uint) {
            let mask = 16777216u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 24usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPrefChangePendingNeedsReflow(&self)
         -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 33554432u64 as u64;
            let val = (unit_field_val & mask) >> 25usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPrefChangePendingNeedsReflow(&mut self,
                                                 val:
                                                     ::std::os::raw::c_uint) {
            let mask = 33554432u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 25usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsEmulatingMedia(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 67108864u64 as u64;
            let val = (unit_field_val & mask) >> 26usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mIsEmulatingMedia(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 67108864u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 26usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsGlyph(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 134217728u64 as u64;
            let val = (unit_field_val & mask) >> 27usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mIsGlyph(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 134217728u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 27usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mUsesRootEMUnits(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 268435456u64 as u64;
            let val = (unit_field_val & mask) >> 28usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mUsesRootEMUnits(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 268435456u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 28usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mUsesExChUnits(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 536870912u64 as u64;
            let val = (unit_field_val & mask) >> 29usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mUsesExChUnits(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 536870912u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 29usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mUsesViewportUnits(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 1073741824u64 as u64;
            let val = (unit_field_val & mask) >> 30usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mUsesViewportUnits(&mut self,
                                      val: ::std::os::raw::c_uint) {
            let mask = 1073741824u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 30usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPendingViewportChange(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 2147483648u64 as u64;
            let val = (unit_field_val & mask) >> 31usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPendingViewportChange(&mut self,
                                          val: ::std::os::raw::c_uint) {
            let mask = 2147483648u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 31usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mCounterStylesDirty(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 4294967296u64 as u64;
            let val = (unit_field_val & mask) >> 32usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mCounterStylesDirty(&mut self,
                                       val: ::std::os::raw::c_uint) {
            let mask = 4294967296u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 32usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPostedFlushCounterStyles(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 8589934592u64 as u64;
            let val = (unit_field_val & mask) >> 33usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPostedFlushCounterStyles(&mut self,
                                             val: ::std::os::raw::c_uint) {
            let mask = 8589934592u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 33usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mSuppressResizeReflow(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 17179869184u64 as u64;
            let val = (unit_field_val & mask) >> 34usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mSuppressResizeReflow(&mut self,
                                         val: ::std::os::raw::c_uint) {
            let mask = 17179869184u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 34usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsVisual(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 34359738368u64 as u64;
            let val = (unit_field_val & mask) >> 35usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mIsVisual(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 34359738368u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 35usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mFireAfterPaintEvents(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 68719476736u64 as u64;
            let val = (unit_field_val & mask) >> 36usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mFireAfterPaintEvents(&mut self,
                                         val: ::std::os::raw::c_uint) {
            let mask = 68719476736u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 36usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsChrome(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 137438953472u64 as u64;
            let val = (unit_field_val & mask) >> 37usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mIsChrome(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 137438953472u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 37usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsChromeOriginImage(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 274877906944u64 as u64;
            let val = (unit_field_val & mask) >> 38usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mIsChromeOriginImage(&mut self,
                                        val: ::std::os::raw::c_uint) {
            let mask = 274877906944u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 38usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPaintFlashing(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 549755813888u64 as u64;
            let val = (unit_field_val & mask) >> 39usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPaintFlashing(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 549755813888u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 39usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPaintFlashingInitialized(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 1099511627776u64 as u64;
            let val = (unit_field_val & mask) >> 40usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPaintFlashingInitialized(&mut self,
                                             val: ::std::os::raw::c_uint) {
            let mask = 1099511627776u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 40usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasWarnedAboutPositionedTableParts(&self)
         -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 2199023255552u64 as u64;
            let val = (unit_field_val & mask) >> 41usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mHasWarnedAboutPositionedTableParts(&mut self,
                                                       val:
                                                           ::std::os::raw::c_uint) {
            let mask = 2199023255552u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 41usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasWarnedAboutTooLargeDashedOrDottedRadius(&self)
         -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 4398046511104u64 as u64;
            let val = (unit_field_val & mask) >> 42usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mHasWarnedAboutTooLargeDashedOrDottedRadius(&mut self,
                                                               val:
                                                                   ::std::os::raw::c_uint) {
            let mask = 4398046511104u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 42usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mQuirkSheetAdded(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 8796093022208u64 as u64;
            let val = (unit_field_val & mask) >> 43usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mQuirkSheetAdded(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 8796093022208u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 43usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mNeedsPrefUpdate(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 17592186044416u64 as u64;
            let val = (unit_field_val & mask) >> 44usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mNeedsPrefUpdate(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 17592186044416u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 44usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHadNonBlankPaint(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 35184372088832u64 as u64;
            let val = (unit_field_val & mask) >> 45usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mHadNonBlankPaint(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 35184372088832u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 45usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn new_bitfield_1(mHasPendingInterrupt: ::std::os::raw::c_uint,
                              mPendingInterruptFromTest:
                                  ::std::os::raw::c_uint,
                              mInterruptsEnabled: ::std::os::raw::c_uint,
                              mUseDocumentFonts: ::std::os::raw::c_uint,
                              mUseDocumentColors: ::std::os::raw::c_uint,
                              mUnderlineLinks: ::std::os::raw::c_uint,
                              mSendAfterPaintToContent:
                                  ::std::os::raw::c_uint,
                              mUseFocusColors: ::std::os::raw::c_uint,
                              mFocusRingOnAnything: ::std::os::raw::c_uint,
                              mFocusRingStyle: ::std::os::raw::c_uint,
                              mDrawImageBackground: ::std::os::raw::c_uint,
                              mDrawColorBackground: ::std::os::raw::c_uint,
                              mNeverAnimate: ::std::os::raw::c_uint,
                              mIsRenderingOnlySelection:
                                  ::std::os::raw::c_uint,
                              mPaginated: ::std::os::raw::c_uint,
                              mCanPaginatedScroll: ::std::os::raw::c_uint,
                              mDoScaledTwips: ::std::os::raw::c_uint,
                              mIsRootPaginatedDocument:
                                  ::std::os::raw::c_uint,
                              mPrefBidiDirection: ::std::os::raw::c_uint,
                              mPrefScrollbarSide: ::std::os::raw::c_uint,
                              mPendingSysColorChanged: ::std::os::raw::c_uint,
                              mPendingThemeChanged: ::std::os::raw::c_uint,
                              mPendingUIResolutionChanged:
                                  ::std::os::raw::c_uint,
                              mPendingMediaFeatureValuesChanged:
                                  ::std::os::raw::c_uint,
                              mPrefChangePendingNeedsReflow:
                                  ::std::os::raw::c_uint,
                              mIsEmulatingMedia: ::std::os::raw::c_uint,
                              mIsGlyph: ::std::os::raw::c_uint,
                              mUsesRootEMUnits: ::std::os::raw::c_uint,
                              mUsesExChUnits: ::std::os::raw::c_uint,
                              mUsesViewportUnits: ::std::os::raw::c_uint,
                              mPendingViewportChange: ::std::os::raw::c_uint,
                              mCounterStylesDirty: ::std::os::raw::c_uint,
                              mPostedFlushCounterStyles:
                                  ::std::os::raw::c_uint,
                              mSuppressResizeReflow: ::std::os::raw::c_uint,
                              mIsVisual: ::std::os::raw::c_uint,
                              mFireAfterPaintEvents: ::std::os::raw::c_uint,
                              mIsChrome: ::std::os::raw::c_uint,
                              mIsChromeOriginImage: ::std::os::raw::c_uint,
                              mPaintFlashing: ::std::os::raw::c_uint,
                              mPaintFlashingInitialized:
                                  ::std::os::raw::c_uint,
                              mHasWarnedAboutPositionedTableParts:
                                  ::std::os::raw::c_uint,
                              mHasWarnedAboutTooLargeDashedOrDottedRadius:
                                  ::std::os::raw::c_uint,
                              mQuirkSheetAdded: ::std::os::raw::c_uint,
                              mNeedsPrefUpdate: ::std::os::raw::c_uint,
                              mHadNonBlankPaint: ::std::os::raw::c_uint)
         -> u64 {
            ({
                 ({
                      ({
                           ({
                                ({
                                     ({
                                          ({
                                               ({
                                                    ({
                                                         ({
                                                              ({
                                                                   ({
                                                                        ({
                                                                             ({
                                                                                  ({
                                                                                       ({
                                                                                            ({
                                                                                                 ({
                                                                                                      ({
                                                                                                           ({
                                                                                                                ({
                                                                                                                     ({
                                                                                                                          ({
                                                                                                                               ({
                                                                                                                                    ({
                                                                                                                                         ({
                                                                                                                                              ({
                                                                                                                                                   ({
                                                                                                                                                        ({
                                                                                                                                                             ({
                                                                                                                                                                  ({
                                                                                                                                                                       ({
                                                                                                                                                                            ({
                                                                                                                                                                                 ({
                                                                                                                                                                                      ({
                                                                                                                                                                                           ({
                                                                                                                                                                                                ({
                                                                                                                                                                                                     ({
                                                                                                                                                                                                          ({
                                                                                                                                                                                                               ({
                                                                                                                                                                                                                    ({
                                                                                                                                                                                                                         ({
                                                                                                                                                                                                                              ({
                                                                                                                                                                                                                                   ({
                                                                                                                                                                                                                                        ({
                                                                                                                                                                                                                                             0
                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                             |
                                                                                                                                                                                                                                             ((mHasPendingInterrupt
                                                                                                                                                                                                                                                   as
                                                                                                                                                                                                                                                   u32
                                                                                                                                                                                                                                                   as
                                                                                                                                                                                                                                                   u64)
                                                                                                                                                                                                                                                  <<
                                                                                                                                                                                                                                                  0usize)
                                                                                                                                                                                                                                                 &
                                                                                                                                                                                                                                                 (1u64
                                                                                                                                                                                                                                                      as
                                                                                                                                                                                                                                                      u64))
                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                        |
                                                                                                                                                                                                                                        ((mPendingInterruptFromTest
                                                                                                                                                                                                                                              as
                                                                                                                                                                                                                                              u32
                                                                                                                                                                                                                                              as
                                                                                                                                                                                                                                              u64)
                                                                                                                                                                                                                                             <<
                                                                                                                                                                                                                                             1usize)
                                                                                                                                                                                                                                            &
                                                                                                                                                                                                                                            (2u64
                                                                                                                                                                                                                                                 as
                                                                                                                                                                                                                                                 u64))
                                                                                                                                                                                                                               }
                                                                                                                                                                                                                                   |
                                                                                                                                                                                                                                   ((mInterruptsEnabled
                                                                                                                                                                                                                                         as
                                                                                                                                                                                                                                         u32
                                                                                                                                                                                                                                         as
                                                                                                                                                                                                                                         u64)
                                                                                                                                                                                                                                        <<
                                                                                                                                                                                                                                        2usize)
                                                                                                                                                                                                                                       &
                                                                                                                                                                                                                                       (4u64
                                                                                                                                                                                                                                            as
                                                                                                                                                                                                                                            u64))
                                                                                                                                                                                                                          }
                                                                                                                                                                                                                              |
                                                                                                                                                                                                                              ((mUseDocumentFonts
                                                                                                                                                                                                                                    as
                                                                                                                                                                                                                                    u32
                                                                                                                                                                                                                                    as
                                                                                                                                                                                                                                    u64)
                                                                                                                                                                                                                                   <<
                                                                                                                                                                                                                                   3usize)
                                                                                                                                                                                                                                  &
                                                                                                                                                                                                                                  (8u64
                                                                                                                                                                                                                                       as
                                                                                                                                                                                                                                       u64))
                                                                                                                                                                                                                     }
                                                                                                                                                                                                                         |
                                                                                                                                                                                                                         ((mUseDocumentColors
                                                                                                                                                                                                                               as
                                                                                                                                                                                                                               u32
                                                                                                                                                                                                                               as
                                                                                                                                                                                                                               u64)
                                                                                                                                                                                                                              <<
                                                                                                                                                                                                                              4usize)
                                                                                                                                                                                                                             &
                                                                                                                                                                                                                             (16u64
                                                                                                                                                                                                                                  as
                                                                                                                                                                                                                                  u64))
                                                                                                                                                                                                                }
                                                                                                                                                                                                                    |
                                                                                                                                                                                                                    ((mUnderlineLinks
                                                                                                                                                                                                                          as
                                                                                                                                                                                                                          u32
                                                                                                                                                                                                                          as
                                                                                                                                                                                                                          u64)
                                                                                                                                                                                                                         <<
                                                                                                                                                                                                                         5usize)
                                                                                                                                                                                                                        &
                                                                                                                                                                                                                        (32u64
                                                                                                                                                                                                                             as
                                                                                                                                                                                                                             u64))
                                                                                                                                                                                                           }
                                                                                                                                                                                                               |
                                                                                                                                                                                                               ((mSendAfterPaintToContent
                                                                                                                                                                                                                     as
                                                                                                                                                                                                                     u32
                                                                                                                                                                                                                     as
                                                                                                                                                                                                                     u64)
                                                                                                                                                                                                                    <<
                                                                                                                                                                                                                    6usize)
                                                                                                                                                                                                                   &
                                                                                                                                                                                                                   (64u64
                                                                                                                                                                                                                        as
                                                                                                                                                                                                                        u64))
                                                                                                                                                                                                      }
                                                                                                                                                                                                          |
                                                                                                                                                                                                          ((mUseFocusColors
                                                                                                                                                                                                                as
                                                                                                                                                                                                                u32
                                                                                                                                                                                                                as
                                                                                                                                                                                                                u64)
                                                                                                                                                                                                               <<
                                                                                                                                                                                                               7usize)
                                                                                                                                                                                                              &
                                                                                                                                                                                                              (128u64
                                                                                                                                                                                                                   as
                                                                                                                                                                                                                   u64))
                                                                                                                                                                                                 }
                                                                                                                                                                                                     |
                                                                                                                                                                                                     ((mFocusRingOnAnything
                                                                                                                                                                                                           as
                                                                                                                                                                                                           u32
                                                                                                                                                                                                           as
                                                                                                                                                                                                           u64)
                                                                                                                                                                                                          <<
                                                                                                                                                                                                          8usize)
                                                                                                                                                                                                         &
                                                                                                                                                                                                         (256u64
                                                                                                                                                                                                              as
                                                                                                                                                                                                              u64))
                                                                                                                                                                                            }
                                                                                                                                                                                                |
                                                                                                                                                                                                ((mFocusRingStyle
                                                                                                                                                                                                      as
                                                                                                                                                                                                      u32
                                                                                                                                                                                                      as
                                                                                                                                                                                                      u64)
                                                                                                                                                                                                     <<
                                                                                                                                                                                                     9usize)
                                                                                                                                                                                                    &
                                                                                                                                                                                                    (512u64
                                                                                                                                                                                                         as
                                                                                                                                                                                                         u64))
                                                                                                                                                                                       }
                                                                                                                                                                                           |
                                                                                                                                                                                           ((mDrawImageBackground
                                                                                                                                                                                                 as
                                                                                                                                                                                                 u32
                                                                                                                                                                                                 as
                                                                                                                                                                                                 u64)
                                                                                                                                                                                                <<
                                                                                                                                                                                                10usize)
                                                                                                                                                                                               &
                                                                                                                                                                                               (1024u64
                                                                                                                                                                                                    as
                                                                                                                                                                                                    u64))
                                                                                                                                                                                  }
                                                                                                                                                                                      |
                                                                                                                                                                                      ((mDrawColorBackground
                                                                                                                                                                                            as
                                                                                                                                                                                            u32
                                                                                                                                                                                            as
                                                                                                                                                                                            u64)
                                                                                                                                                                                           <<
                                                                                                                                                                                           11usize)
                                                                                                                                                                                          &
                                                                                                                                                                                          (2048u64
                                                                                                                                                                                               as
                                                                                                                                                                                               u64))
                                                                                                                                                                             }
                                                                                                                                                                                 |
                                                                                                                                                                                 ((mNeverAnimate
                                                                                                                                                                                       as
                                                                                                                                                                                       u32
                                                                                                                                                                                       as
                                                                                                                                                                                       u64)
                                                                                                                                                                                      <<
                                                                                                                                                                                      12usize)
                                                                                                                                                                                     &
                                                                                                                                                                                     (4096u64
                                                                                                                                                                                          as
                                                                                                                                                                                          u64))
                                                                                                                                                                        }
                                                                                                                                                                            |
                                                                                                                                                                            ((mIsRenderingOnlySelection
                                                                                                                                                                                  as
                                                                                                                                                                                  u32
                                                                                                                                                                                  as
                                                                                                                                                                                  u64)
                                                                                                                                                                                 <<
                                                                                                                                                                                 13usize)
                                                                                                                                                                                &
                                                                                                                                                                                (8192u64
                                                                                                                                                                                     as
                                                                                                                                                                                     u64))
                                                                                                                                                                   }
                                                                                                                                                                       |
                                                                                                                                                                       ((mPaginated
                                                                                                                                                                             as
                                                                                                                                                                             u32
                                                                                                                                                                             as
                                                                                                                                                                             u64)
                                                                                                                                                                            <<
                                                                                                                                                                            14usize)
                                                                                                                                                                           &
                                                                                                                                                                           (16384u64
                                                                                                                                                                                as
                                                                                                                                                                                u64))
                                                                                                                                                              }
                                                                                                                                                                  |
                                                                                                                                                                  ((mCanPaginatedScroll
                                                                                                                                                                        as
                                                                                                                                                                        u32
                                                                                                                                                                        as
                                                                                                                                                                        u64)
                                                                                                                                                                       <<
                                                                                                                                                                       15usize)
                                                                                                                                                                      &
                                                                                                                                                                      (32768u64
                                                                                                                                                                           as
                                                                                                                                                                           u64))
                                                                                                                                                         }
                                                                                                                                                             |
                                                                                                                                                             ((mDoScaledTwips
                                                                                                                                                                   as
                                                                                                                                                                   u32
                                                                                                                                                                   as
                                                                                                                                                                   u64)
                                                                                                                                                                  <<
                                                                                                                                                                  16usize)
                                                                                                                                                                 &
                                                                                                                                                                 (65536u64
                                                                                                                                                                      as
                                                                                                                                                                      u64))
                                                                                                                                                    }
                                                                                                                                                        |
                                                                                                                                                        ((mIsRootPaginatedDocument
                                                                                                                                                              as
                                                                                                                                                              u32
                                                                                                                                                              as
                                                                                                                                                              u64)
                                                                                                                                                             <<
                                                                                                                                                             17usize)
                                                                                                                                                            &
                                                                                                                                                            (131072u64
                                                                                                                                                                 as
                                                                                                                                                                 u64))
                                                                                                                                               }
                                                                                                                                                   |
                                                                                                                                                   ((mPrefBidiDirection
                                                                                                                                                         as
                                                                                                                                                         u32
                                                                                                                                                         as
                                                                                                                                                         u64)
                                                                                                                                                        <<
                                                                                                                                                        18usize)
                                                                                                                                                       &
                                                                                                                                                       (262144u64
                                                                                                                                                            as
                                                                                                                                                            u64))
                                                                                                                                          }
                                                                                                                                              |
                                                                                                                                              ((mPrefScrollbarSide
                                                                                                                                                    as
                                                                                                                                                    u32
                                                                                                                                                    as
                                                                                                                                                    u64)
                                                                                                                                                   <<
                                                                                                                                                   19usize)
                                                                                                                                                  &
                                                                                                                                                  (1572864u64
                                                                                                                                                       as
                                                                                                                                                       u64))
                                                                                                                                     }
                                                                                                                                         |
                                                                                                                                         ((mPendingSysColorChanged
                                                                                                                                               as
                                                                                                                                               u32
                                                                                                                                               as
                                                                                                                                               u64)
                                                                                                                                              <<
                                                                                                                                              21usize)
                                                                                                                                             &
                                                                                                                                             (2097152u64
                                                                                                                                                  as
                                                                                                                                                  u64))
                                                                                                                                }
                                                                                                                                    |
                                                                                                                                    ((mPendingThemeChanged
                                                                                                                                          as
                                                                                                                                          u32
                                                                                                                                          as
                                                                                                                                          u64)
                                                                                                                                         <<
                                                                                                                                         22usize)
                                                                                                                                        &
                                                                                                                                        (4194304u64
                                                                                                                                             as
                                                                                                                                             u64))
                                                                                                                           }
                                                                                                                               |
                                                                                                                               ((mPendingUIResolutionChanged
                                                                                                                                     as
                                                                                                                                     u32
                                                                                                                                     as
                                                                                                                                     u64)
                                                                                                                                    <<
                                                                                                                                    23usize)
                                                                                                                                   &
                                                                                                                                   (8388608u64
                                                                                                                                        as
                                                                                                                                        u64))
                                                                                                                      }
                                                                                                                          |
                                                                                                                          ((mPendingMediaFeatureValuesChanged
                                                                                                                                as
                                                                                                                                u32
                                                                                                                                as
                                                                                                                                u64)
                                                                                                                               <<
                                                                                                                               24usize)
                                                                                                                              &
                                                                                                                              (16777216u64
                                                                                                                                   as
                                                                                                                                   u64))
                                                                                                                 }
                                                                                                                     |
                                                                                                                     ((mPrefChangePendingNeedsReflow
                                                                                                                           as
                                                                                                                           u32
                                                                                                                           as
                                                                                                                           u64)
                                                                                                                          <<
                                                                                                                          25usize)
                                                                                                                         &
                                                                                                                         (33554432u64
                                                                                                                              as
                                                                                                                              u64))
                                                                                                            }
                                                                                                                |
                                                                                                                ((mIsEmulatingMedia
                                                                                                                      as
                                                                                                                      u32
                                                                                                                      as
                                                                                                                      u64)
                                                                                                                     <<
                                                                                                                     26usize)
                                                                                                                    &
                                                                                                                    (67108864u64
                                                                                                                         as
                                                                                                                         u64))
                                                                                                       }
                                                                                                           |
                                                                                                           ((mIsGlyph
                                                                                                                 as
                                                                                                                 u32
                                                                                                                 as
                                                                                                                 u64)
                                                                                                                <<
                                                                                                                27usize)
                                                                                                               &
                                                                                                               (134217728u64
                                                                                                                    as
                                                                                                                    u64))
                                                                                                  }
                                                                                                      |
                                                                                                      ((mUsesRootEMUnits
                                                                                                            as
                                                                                                            u32
                                                                                                            as
                                                                                                            u64)
                                                                                                           <<
                                                                                                           28usize)
                                                                                                          &
                                                                                                          (268435456u64
                                                                                                               as
                                                                                                               u64))
                                                                                             }
                                                                                                 |
                                                                                                 ((mUsesExChUnits
                                                                                                       as
                                                                                                       u32
                                                                                                       as
                                                                                                       u64)
                                                                                                      <<
                                                                                                      29usize)
                                                                                                     &
                                                                                                     (536870912u64
                                                                                                          as
                                                                                                          u64))
                                                                                        }
                                                                                            |
                                                                                            ((mUsesViewportUnits
                                                                                                  as
                                                                                                  u32
                                                                                                  as
                                                                                                  u64)
                                                                                                 <<
                                                                                                 30usize)
                                                                                                &
                                                                                                (1073741824u64
                                                                                                     as
                                                                                                     u64))
                                                                                   }
                                                                                       |
                                                                                       ((mPendingViewportChange
                                                                                             as
                                                                                             u32
                                                                                             as
                                                                                             u64)
                                                                                            <<
                                                                                            31usize)
                                                                                           &
                                                                                           (2147483648u64
                                                                                                as
                                                                                                u64))
                                                                              }
                                                                                  |
                                                                                  ((mCounterStylesDirty
                                                                                        as
                                                                                        u32
                                                                                        as
                                                                                        u64)
                                                                                       <<
                                                                                       32usize)
                                                                                      &
                                                                                      (4294967296u64
                                                                                           as
                                                                                           u64))
                                                                         } |
                                                                             ((mPostedFlushCounterStyles
                                                                                   as
                                                                                   u32
                                                                                   as
                                                                                   u64)
                                                                                  <<
                                                                                  33usize)
                                                                                 &
                                                                                 (8589934592u64
                                                                                      as
                                                                                      u64))
                                                                    } |
                                                                        ((mSuppressResizeReflow
                                                                              as
                                                                              u32
                                                                              as
                                                                              u64)
                                                                             <<
                                                                             34usize)
                                                                            &
                                                                            (17179869184u64
                                                                                 as
                                                                                 u64))
                                                               } |
                                                                   ((mIsVisual
                                                                         as
                                                                         u32
                                                                         as
                                                                         u64)
                                                                        <<
                                                                        35usize)
                                                                       &
                                                                       (34359738368u64
                                                                            as
                                                                            u64))
                                                          } |
                                                              ((mFireAfterPaintEvents
                                                                    as u32 as
                                                                    u64) <<
                                                                   36usize) &
                                                                  (68719476736u64
                                                                       as
                                                                       u64))
                                                     } |
                                                         ((mIsChrome as u32 as
                                                               u64) <<
                                                              37usize) &
                                                             (137438953472u64
                                                                  as u64))
                                                } |
                                                    ((mIsChromeOriginImage as
                                                          u32 as u64) <<
                                                         38usize) &
                                                        (274877906944u64 as
                                                             u64))
                                           } |
                                               ((mPaintFlashing as u32 as u64)
                                                    << 39usize) &
                                                   (549755813888u64 as u64))
                                      } |
                                          ((mPaintFlashingInitialized as u32
                                                as u64) << 40usize) &
                                              (1099511627776u64 as u64))
                                 } |
                                     ((mHasWarnedAboutPositionedTableParts as
                                           u32 as u64) << 41usize) &
                                         (2199023255552u64 as u64))
                            } |
                                ((mHasWarnedAboutTooLargeDashedOrDottedRadius
                                      as u32 as u64) << 42usize) &
                                    (4398046511104u64 as u64))
                       } |
                           ((mQuirkSheetAdded as u32 as u64) << 43usize) &
                               (8796093022208u64 as u64))
                  } |
                      ((mNeedsPrefUpdate as u32 as u64) << 44usize) &
                          (17592186044416u64 as u64))
             } |
                 ((mHadNonBlankPaint as u32 as u64) << 45usize) &
                     (35184372088832u64 as u64))
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAttrName {
        pub mBits: usize,
    }
    #[test]
    fn bindgen_test_layout_nsAttrName() {
        assert_eq!(::std::mem::size_of::<nsAttrName>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsAttrName ) ));
        assert_eq! (::std::mem::align_of::<nsAttrName>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsAttrName ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrName ) ) . mBits as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAttrName ) , "::"
                    , stringify ! ( mBits ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAttrValue {
        pub mBits: usize,
    }
    pub type nsAttrValue_AtomArray = root::nsTArray<root::nsCOMPtr>;
    pub const nsAttrValue_ValueType_eSVGTypesBegin:
              root::nsAttrValue_ValueType =
        nsAttrValue_ValueType::eSVGAngle;
    pub const nsAttrValue_ValueType_eSVGTypesEnd: root::nsAttrValue_ValueType
              =
        nsAttrValue_ValueType::eSVGViewBox;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsAttrValue_ValueType {
        eString = 0,
        eAtom = 2,
        eInteger = 3,
        eColor = 7,
        eEnum = 11,
        ePercent = 15,
        eCSSDeclaration = 16,
        eURL = 17,
        eImage = 18,
        eAtomArray = 19,
        eDoubleValue = 20,
        eIntMarginValue = 21,
        eSVGAngle = 22,
        eSVGIntegerPair = 23,
        eSVGLength = 24,
        eSVGLengthList = 25,
        eSVGNumberList = 26,
        eSVGNumberPair = 27,
        eSVGPathData = 28,
        eSVGPointList = 29,
        eSVGPreserveAspectRatio = 30,
        eSVGStringList = 31,
        eSVGTransformList = 32,
        eSVGViewBox = 33,
    }
    /**
   * Structure for a mapping from int (enum) values to strings.  When you use
   * it you generally create an array of them.
   * Instantiate like this:
   * EnumTable myTable[] = {
   *   { "string1", 1 },
   *   { "string2", 2 },
   *   { nullptr, 0 }
   * }
   */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsAttrValue_EnumTable {
        /** The string the value maps to */
        pub tag: *const ::std::os::raw::c_char,
        /** The enum value that maps to this string */
        pub value: i16,
    }
    #[test]
    fn bindgen_test_layout_nsAttrValue_EnumTable() {
        assert_eq!(::std::mem::size_of::<nsAttrValue_EnumTable>() , 16usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsAttrValue_EnumTable ) ));
        assert_eq! (::std::mem::align_of::<nsAttrValue_EnumTable>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsAttrValue_EnumTable )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrValue_EnumTable ) ) . tag as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrValue_EnumTable ) , "::" , stringify ! ( tag ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrValue_EnumTable ) ) . value as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrValue_EnumTable ) , "::" , stringify ! ( value ) ));
    }
    impl Clone for nsAttrValue_EnumTable {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsAttrValue_ValueBaseType {
        eStringBase = 0,
        eOtherBase = 1,
        eAtomBase = 2,
        eIntegerBase = 3,
    }
    extern "C" {
        #[link_name = "_ZN11nsAttrValue15sEnumTableArrayE"]
        pub static mut nsAttrValue_sEnumTableArray:
                   *mut root::nsTArray<*const root::nsAttrValue_EnumTable>;
    }
    #[test]
    fn bindgen_test_layout_nsAttrValue() {
        assert_eq!(::std::mem::size_of::<nsAttrValue>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsAttrValue ) ));
        assert_eq! (::std::mem::align_of::<nsAttrValue>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsAttrValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrValue ) ) . mBits as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAttrValue ) ,
                    "::" , stringify ! ( mBits ) ));
    }
    #[repr(u32)]
    /**
 * This is the enum used by functions that need to be told whether to
 * do case-sensitive or case-insensitive string comparisons.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCaseTreatment { eCaseMatters = 0, eIgnoreCase = 1, }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIVariant {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIVariant_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIVariant() {
        assert_eq!(::std::mem::size_of::<nsIVariant>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIVariant ) ));
        assert_eq! (::std::mem::align_of::<nsIVariant>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIVariant ) ));
    }
    impl Clone for nsIVariant {
        fn clone(&self) -> Self { *self }
    }
    pub const kNameSpaceID_None: i32 = 0;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsNodeInfoManager {
        pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
        pub mNodeInfoHash: *mut root::PLHashTable,
        pub mDocument: *mut root::nsIDocument,
        pub mNonDocumentNodeInfos: u32,
        pub mPrincipal: root::nsCOMPtr,
        pub mDefaultPrincipal: root::nsCOMPtr,
        pub mTextNodeInfo: *mut root::mozilla::dom::NodeInfo,
        pub mCommentNodeInfo: *mut root::mozilla::dom::NodeInfo,
        pub mDocumentNodeInfo: *mut root::mozilla::dom::NodeInfo,
        pub mBindingManager: root::RefPtr<root::nsBindingManager>,
        pub mRecentlyUsedNodeInfos: [*mut root::mozilla::dom::NodeInfo; 31usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsNodeInfoManager_cycleCollection {
        pub _base: root::nsCycleCollectionParticipant,
    }
    #[test]
    fn bindgen_test_layout_nsNodeInfoManager_cycleCollection() {
        assert_eq!(::std::mem::size_of::<nsNodeInfoManager_cycleCollection>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsNodeInfoManager_cycleCollection ) ));
        assert_eq! (::std::mem::align_of::<nsNodeInfoManager_cycleCollection>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsNodeInfoManager_cycleCollection ) ));
    }
    impl Clone for nsNodeInfoManager_cycleCollection {
        fn clone(&self) -> Self { *self }
    }
    pub type nsNodeInfoManager_HasThreadSafeRefCnt = root::mozilla::FalseType;
    extern "C" {
        #[link_name = "_ZN17nsNodeInfoManager21_cycleCollectorGlobalE"]
        pub static mut nsNodeInfoManager__cycleCollectorGlobal:
                   root::nsNodeInfoManager_cycleCollection;
    }
    #[test]
    fn bindgen_test_layout_nsNodeInfoManager() {
        assert_eq!(::std::mem::size_of::<nsNodeInfoManager>() , 328usize ,
                   concat ! ( "Size of: " , stringify ! ( nsNodeInfoManager )
                   ));
        assert_eq! (::std::mem::align_of::<nsNodeInfoManager>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsNodeInfoManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) . mRefCnt as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) . mNodeInfoHash
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mNodeInfoHash ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) . mDocument as
                    * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mDocument ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) .
                    mNonDocumentNodeInfos as * const _ as usize } , 24usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mNonDocumentNodeInfos ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) . mPrincipal as
                    * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mPrincipal ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) .
                    mDefaultPrincipal as * const _ as usize } , 40usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mDefaultPrincipal ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) . mTextNodeInfo
                    as * const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mTextNodeInfo ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) .
                    mCommentNodeInfo as * const _ as usize } , 56usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mCommentNodeInfo ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) .
                    mDocumentNodeInfo as * const _ as usize } , 64usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mDocumentNodeInfo ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) .
                    mBindingManager as * const _ as usize } , 72usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mBindingManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) .
                    mRecentlyUsedNodeInfos as * const _ as usize } , 80usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mRecentlyUsedNodeInfos ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsBindingManager {
        _unused: [u8; 0],
    }
    pub type NSPropertyFunc =
        ::std::option::Option<unsafe extern "C" fn(aObject:
                                                       *mut ::std::os::raw::c_void,
                                                   aPropertyName:
                                                       *mut root::nsIAtom,
                                                   aPropertyValue:
                                                       *mut ::std::os::raw::c_void,
                                                   aData:
                                                       *mut ::std::os::raw::c_void)>;
    /**
 * Callback type for property destructors.  |aObject| is the object
 * the property is being removed for, |aPropertyName| is the property
 * being removed, |aPropertyValue| is the value of the property, and |aData|
 * is the opaque destructor data that was passed to SetProperty().
 **/
    pub type NSPropertyDtorFunc = root::NSPropertyFunc;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIFrame {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsPropertyOwner {
        pub mObject: *const ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_nsPropertyOwner() {
        assert_eq!(::std::mem::size_of::<nsPropertyOwner>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsPropertyOwner ) ));
        assert_eq! (::std::mem::align_of::<nsPropertyOwner>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsPropertyOwner ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPropertyOwner ) ) . mObject as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPropertyOwner ) ,
                    "::" , stringify ! ( mObject ) ));
    }
    impl Clone for nsPropertyOwner {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPropertyTable {
        pub mPropertyList: *mut root::nsPropertyTable_PropertyList,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsPropertyTable_PropertyList {
        _unused: [u8; 0],
    }
    #[test]
    fn bindgen_test_layout_nsPropertyTable() {
        assert_eq!(::std::mem::size_of::<nsPropertyTable>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsPropertyTable ) ));
        assert_eq! (::std::mem::align_of::<nsPropertyTable>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsPropertyTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPropertyTable ) ) . mPropertyList
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPropertyTable ) ,
                    "::" , stringify ! ( mPropertyList ) ));
    }
    /**
 * An array of observers. Like a normal array, but supports iterators that are
 * stable even if the array is modified during iteration.
 * The template parameter T is the observer type the array will hold;
 * N is the number of built-in storage slots that come with the array.
 * NOTE: You probably want to use nsTObserverArray, unless you specifically
 * want built-in storage. See below.
 * @see nsTObserverArray, nsTArray
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsTObserverArray_base {
        pub mIterators: *mut root::nsTObserverArray_base_Iterator_base,
    }
    pub type nsTObserverArray_base_index_type = usize;
    pub type nsTObserverArray_base_size_type = usize;
    pub type nsTObserverArray_base_diff_type = isize;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTObserverArray_base_Iterator_base {
        pub mPosition: root::nsTObserverArray_base_index_type,
        pub mNext: *mut root::nsTObserverArray_base_Iterator_base,
    }
    #[test]
    fn bindgen_test_layout_nsTObserverArray_base_Iterator_base() {
        assert_eq!(::std::mem::size_of::<nsTObserverArray_base_Iterator_base>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsTObserverArray_base_Iterator_base ) ));
        assert_eq! (::std::mem::align_of::<nsTObserverArray_base_Iterator_base>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsTObserverArray_base_Iterator_base ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsTObserverArray_base_Iterator_base )
                    ) . mPosition as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsTObserverArray_base_Iterator_base ) , "::" , stringify !
                    ( mPosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsTObserverArray_base_Iterator_base )
                    ) . mNext as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTObserverArray_base_Iterator_base ) , "::" , stringify !
                    ( mNext ) ));
    }
    impl Clone for nsTObserverArray_base_Iterator_base {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsTObserverArray_base() {
        assert_eq!(::std::mem::size_of::<nsTObserverArray_base>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsTObserverArray_base ) ));
        assert_eq! (::std::mem::align_of::<nsTObserverArray_base>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsTObserverArray_base )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsTObserverArray_base ) ) .
                    mIterators as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTObserverArray_base ) , "::" , stringify ! ( mIterators
                    ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsTObserverArray {
    }
    pub type nsTObserverArray_base_type = u8;
    pub type nsTObserverArray_size_type =
        root::nsTObserverArray_base_size_type;
    /**
 * It is used by the application to initialize a runtime and run scripts.
 * A script runtime would implement this interface.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIScriptContext {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIScriptContext_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIScriptContext() {
        assert_eq!(::std::mem::size_of::<nsIScriptContext>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsIScriptContext ) ));
        assert_eq! (::std::mem::align_of::<nsIScriptContext>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIScriptContext ) ));
    }
    impl Clone for nsIScriptContext {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPIDOMWindowOuter {
        pub _base: [u64; 30usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsPIDOMWindowOuter_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsPIDOMWindowOuter() {
        assert_eq!(::std::mem::size_of::<nsPIDOMWindowOuter>() , 240usize ,
                   concat ! ( "Size of: " , stringify ! ( nsPIDOMWindowOuter )
                   ));
        assert_eq! (::std::mem::align_of::<nsPIDOMWindowOuter>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsPIDOMWindowOuter ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIGlobalObject {
        pub _base: root::nsISupports,
        pub _base_1: root::mozilla::dom::DispatcherTrait,
        pub mHostObjectURIs: root::nsTArray<root::nsCString>,
        pub mIsDying: bool,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIGlobalObject_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIGlobalObject() {
        assert_eq!(::std::mem::size_of::<nsIGlobalObject>() , 32usize , concat
                   ! ( "Size of: " , stringify ! ( nsIGlobalObject ) ));
        assert_eq! (::std::mem::align_of::<nsIGlobalObject>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIGlobalObject ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAttrAndChildArray {
        pub mImpl: *mut root::nsAttrAndChildArray_Impl,
    }
    pub type nsAttrAndChildArray_BorrowedAttrInfo =
        root::mozilla::dom::BorrowedAttrInfo;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAttrAndChildArray_InternalAttr {
        pub mName: root::nsAttrName,
        pub mValue: root::nsAttrValue,
    }
    #[test]
    fn bindgen_test_layout_nsAttrAndChildArray_InternalAttr() {
        assert_eq!(::std::mem::size_of::<nsAttrAndChildArray_InternalAttr>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsAttrAndChildArray_InternalAttr ) ));
        assert_eq! (::std::mem::align_of::<nsAttrAndChildArray_InternalAttr>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsAttrAndChildArray_InternalAttr ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrAndChildArray_InternalAttr ) )
                    . mName as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrAndChildArray_InternalAttr ) , "::" , stringify ! (
                    mName ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrAndChildArray_InternalAttr ) )
                    . mValue as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrAndChildArray_InternalAttr ) , "::" , stringify ! (
                    mValue ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsAttrAndChildArray_Impl {
        pub mAttrAndChildCount: u32,
        pub mBufferSize: u32,
        pub mMappedAttrs: *mut root::nsMappedAttributes,
        pub mBuffer: [*mut ::std::os::raw::c_void; 1usize],
    }
    #[test]
    fn bindgen_test_layout_nsAttrAndChildArray_Impl() {
        assert_eq!(::std::mem::size_of::<nsAttrAndChildArray_Impl>() , 24usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsAttrAndChildArray_Impl ) ));
        assert_eq! (::std::mem::align_of::<nsAttrAndChildArray_Impl>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsAttrAndChildArray_Impl )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrAndChildArray_Impl ) ) .
                    mAttrAndChildCount as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrAndChildArray_Impl ) , "::" , stringify ! (
                    mAttrAndChildCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrAndChildArray_Impl ) ) .
                    mBufferSize as * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrAndChildArray_Impl ) , "::" , stringify ! (
                    mBufferSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrAndChildArray_Impl ) ) .
                    mMappedAttrs as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrAndChildArray_Impl ) , "::" , stringify ! (
                    mMappedAttrs ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrAndChildArray_Impl ) ) .
                    mBuffer as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrAndChildArray_Impl ) , "::" , stringify ! ( mBuffer
                    ) ));
    }
    impl Clone for nsAttrAndChildArray_Impl {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsAttrAndChildArray() {
        assert_eq!(::std::mem::size_of::<nsAttrAndChildArray>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsAttrAndChildArray ) ));
        assert_eq! (::std::mem::align_of::<nsAttrAndChildArray>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsAttrAndChildArray ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrAndChildArray ) ) . mImpl as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAttrAndChildArray
                    ) , "::" , stringify ! ( mImpl ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsChildContentList {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsCSSSelectorList {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsDOMAttributeMap {
        pub _base: root::nsIDOMMozNamedAttrMap,
        pub _base_1: root::nsWrapperCache,
        pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
        pub mContent: root::nsCOMPtr,
        /**
   * Cache of Attrs.
   */
        pub mAttributeCache: root::nsDOMAttributeMap_AttrCache,
    }
    pub type nsDOMAttributeMap_Attr = root::mozilla::dom::Attr;
    pub type nsDOMAttributeMap_Element = root::mozilla::dom::Element;
    pub type nsDOMAttributeMap_ErrorResult = root::mozilla::ErrorResult;
    pub type nsDOMAttributeMap_HasThreadSafeRefCnt = root::mozilla::FalseType;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsDOMAttributeMap_cycleCollection {
        pub _base: root::nsXPCOMCycleCollectionParticipant,
    }
    #[test]
    fn bindgen_test_layout_nsDOMAttributeMap_cycleCollection() {
        assert_eq!(::std::mem::size_of::<nsDOMAttributeMap_cycleCollection>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsDOMAttributeMap_cycleCollection ) ));
        assert_eq! (::std::mem::align_of::<nsDOMAttributeMap_cycleCollection>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsDOMAttributeMap_cycleCollection ) ));
    }
    impl Clone for nsDOMAttributeMap_cycleCollection {
        fn clone(&self) -> Self { *self }
    }
    pub type nsDOMAttributeMap_AttrCache = [u64; 5usize];
    extern "C" {
        #[link_name = "_ZN17nsDOMAttributeMap21_cycleCollectorGlobalE"]
        pub static mut nsDOMAttributeMap__cycleCollectorGlobal:
                   root::nsDOMAttributeMap_cycleCollection;
    }
    #[test]
    fn bindgen_test_layout_nsDOMAttributeMap() {
        assert_eq!(::std::mem::size_of::<nsDOMAttributeMap>() , 88usize ,
                   concat ! ( "Size of: " , stringify ! ( nsDOMAttributeMap )
                   ));
        assert_eq! (::std::mem::align_of::<nsDOMAttributeMap>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsDOMAttributeMap ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIAnimationObserver {
        _unused: [u8; 0],
    }
    /**
 * Mutation observer interface
 *
 * See nsINode::AddMutationObserver, nsINode::RemoveMutationObserver for how to
 * attach or remove your observers.
 *
 * WARNING: During these notifications, you are not allowed to perform
 * any mutations to the current or any other document, or start a
 * network load.  If you need to perform such operations do that
 * during the _last_ nsIDocumentObserver::EndUpdate notification.  The
 * expection for this is ParentChainChanged, where mutations should be
 * done from an async event, as the notification might not be
 * surrounded by BeginUpdate/EndUpdate calls.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIMutationObserver {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIMutationObserver_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIMutationObserver() {
        assert_eq!(::std::mem::size_of::<nsIMutationObserver>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIMutationObserver ) ));
        assert_eq! (::std::mem::align_of::<nsIMutationObserver>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIMutationObserver ) ));
    }
    impl Clone for nsIMutationObserver {
        fn clone(&self) -> Self { *self }
    }
    /**
 * An internal interface for a reasonably fast indexOf.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsINodeList {
        pub _base: root::nsIDOMNodeList,
        pub _base_1: root::nsWrapperCache,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsINodeList_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsINodeList() {
        assert_eq!(::std::mem::size_of::<nsINodeList>() , 32usize , concat ! (
                   "Size of: " , stringify ! ( nsINodeList ) ));
        assert_eq! (::std::mem::align_of::<nsINodeList>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsINodeList ) ));
    }
    /**
 * A class that implements nsIWeakReference
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsNodeWeakReference {
        pub _base: root::nsIWeakReference,
        pub mRefCnt: root::nsAutoRefCnt,
        pub mNode: *mut root::nsINode,
    }
    pub type nsNodeWeakReference_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsNodeWeakReference() {
        assert_eq!(::std::mem::size_of::<nsNodeWeakReference>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsNodeWeakReference ) ));
        assert_eq! (::std::mem::align_of::<nsNodeWeakReference>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsNodeWeakReference ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeWeakReference ) ) . mRefCnt as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeWeakReference
                    ) , "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeWeakReference ) ) . mNode as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeWeakReference
                    ) , "::" , stringify ! ( mNode ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDOMMutationObserver {
        _unused: [u8; 0],
    }
    pub const NODE_HAS_LISTENERMANAGER: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_HAS_LISTENERMANAGER;
    pub const NODE_HAS_PROPERTIES: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_HAS_PROPERTIES;
    pub const NODE_IS_ANONYMOUS_ROOT: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_IS_ANONYMOUS_ROOT;
    pub const NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE;
    pub const NODE_IS_NATIVE_ANONYMOUS_ROOT: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_IS_NATIVE_ANONYMOUS_ROOT;
    pub const NODE_FORCE_XBL_BINDINGS: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_FORCE_XBL_BINDINGS;
    pub const NODE_MAY_BE_IN_BINDING_MNGR: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_MAY_BE_IN_BINDING_MNGR;
    pub const NODE_IS_EDITABLE: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_IS_EDITABLE;
    pub const NODE_IS_NATIVE_ANONYMOUS: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_IS_NATIVE_ANONYMOUS;
    pub const NODE_IS_IN_SHADOW_TREE: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_IS_IN_SHADOW_TREE;
    pub const NODE_HAS_EMPTY_SELECTOR: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_HAS_EMPTY_SELECTOR;
    pub const NODE_HAS_SLOW_SELECTOR: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_HAS_SLOW_SELECTOR;
    pub const NODE_HAS_EDGE_CHILD_SELECTOR: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_HAS_EDGE_CHILD_SELECTOR;
    pub const NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS;
    pub const NODE_ALL_SELECTOR_FLAGS: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_ALL_SELECTOR_FLAGS;
    pub const NODE_NEEDS_FRAME: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_NEEDS_FRAME;
    pub const NODE_DESCENDANTS_NEED_FRAMES: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_DESCENDANTS_NEED_FRAMES;
    pub const NODE_HAS_ACCESSKEY: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_HAS_ACCESSKEY;
    pub const NODE_HAS_DIRECTION_RTL: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_HAS_DIRECTION_RTL;
    pub const NODE_HAS_DIRECTION_LTR: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_HAS_DIRECTION_LTR;
    pub const NODE_ALL_DIRECTION_FLAGS: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_ALL_DIRECTION_FLAGS;
    pub const NODE_CHROME_ONLY_ACCESS: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_CHROME_ONLY_ACCESS;
    pub const NODE_IS_ROOT_OF_CHROME_ONLY_ACCESS: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_IS_ROOT_OF_CHROME_ONLY_ACCESS;
    pub const NODE_TYPE_SPECIFIC_BITS_OFFSET: root::_bindgen_ty_83 =
        _bindgen_ty_83::NODE_TYPE_SPECIFIC_BITS_OFFSET;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum _bindgen_ty_83 {
        NODE_HAS_LISTENERMANAGER = 4,
        NODE_HAS_PROPERTIES = 8,
        NODE_IS_ANONYMOUS_ROOT = 16,
        NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE = 32,
        NODE_IS_NATIVE_ANONYMOUS_ROOT = 64,
        NODE_FORCE_XBL_BINDINGS = 128,
        NODE_MAY_BE_IN_BINDING_MNGR = 256,
        NODE_IS_EDITABLE = 512,
        NODE_IS_NATIVE_ANONYMOUS = 1024,
        NODE_IS_IN_SHADOW_TREE = 2048,
        NODE_HAS_EMPTY_SELECTOR = 4096,
        NODE_HAS_SLOW_SELECTOR = 8192,
        NODE_HAS_EDGE_CHILD_SELECTOR = 16384,
        NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS = 32768,
        NODE_ALL_SELECTOR_FLAGS = 61440,
        NODE_NEEDS_FRAME = 65536,
        NODE_DESCENDANTS_NEED_FRAMES = 131072,
        NODE_HAS_ACCESSKEY = 262144,
        NODE_HAS_DIRECTION_RTL = 524288,
        NODE_HAS_DIRECTION_LTR = 1048576,
        NODE_ALL_DIRECTION_FLAGS = 1572864,
        NODE_CHROME_ONLY_ACCESS = 2097152,
        NODE_IS_ROOT_OF_CHROME_ONLY_ACCESS = 4194304,
        NODE_TYPE_SPECIFIC_BITS_OFFSET = 21,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsRuleWalker {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsTextFragment {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsXBLBinding {
        pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
        pub mMarkedForDeath: bool,
        pub mUsingContentXBLScope: bool,
        pub mIsShadowRootBinding: bool,
        pub mPrototypeBinding: *mut root::nsXBLPrototypeBinding,
        pub mContent: root::nsCOMPtr,
        pub mNextBinding: root::RefPtr<root::nsXBLBinding>,
        pub mBoundElement: *mut root::nsIContent,
        pub mDefaultInsertionPoint: root::RefPtr<root::mozilla::dom::XBLChildrenElement>,
        pub mInsertionPoints: root::nsTArray<root::RefPtr<root::mozilla::dom::XBLChildrenElement>>,
        pub mAnonymousContentList: root::RefPtr<root::nsAnonymousContentList>,
    }
    pub type nsXBLBinding_HasThreadSafeRefCnt = root::mozilla::FalseType;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsXBLBinding_cycleCollection {
        pub _base: root::nsCycleCollectionParticipant,
    }
    #[test]
    fn bindgen_test_layout_nsXBLBinding_cycleCollection() {
        assert_eq!(::std::mem::size_of::<nsXBLBinding_cycleCollection>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( nsXBLBinding_cycleCollection )
                   ));
        assert_eq! (::std::mem::align_of::<nsXBLBinding_cycleCollection>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsXBLBinding_cycleCollection ) ));
    }
    impl Clone for nsXBLBinding_cycleCollection {
        fn clone(&self) -> Self { *self }
    }
    extern "C" {
        #[link_name = "_ZN12nsXBLBinding21_cycleCollectorGlobalE"]
        pub static mut nsXBLBinding__cycleCollectorGlobal:
                   root::nsXBLBinding_cycleCollection;
    }
    #[test]
    fn bindgen_test_layout_nsXBLBinding() {
        assert_eq!(::std::mem::size_of::<nsXBLBinding>() , 72usize , concat !
                   ( "Size of: " , stringify ! ( nsXBLBinding ) ));
        assert_eq! (::std::mem::align_of::<nsXBLBinding>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsXBLBinding ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) . mRefCnt as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) . mMarkedForDeath as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( mMarkedForDeath ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) .
                    mUsingContentXBLScope as * const _ as usize } , 9usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( mUsingContentXBLScope ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) .
                    mIsShadowRootBinding as * const _ as usize } , 10usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( mIsShadowRootBinding ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) . mPrototypeBinding
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( mPrototypeBinding ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) . mContent as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( mContent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) . mNextBinding as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( mNextBinding ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) . mBoundElement as *
                    const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( mBoundElement ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) .
                    mDefaultInsertionPoint as * const _ as usize } , 48usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( mDefaultInsertionPoint ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) . mInsertionPoints
                    as * const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( mInsertionPoints ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) .
                    mAnonymousContentList as * const _ as usize } , 64usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( mAnonymousContentList ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsISelectionDisplay {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISelectionDisplay_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsISelectionDisplay_DISPLAY_TEXT:
              root::nsISelectionDisplay__bindgen_ty_1 =
        nsISelectionDisplay__bindgen_ty_1::DISPLAY_TEXT;
    pub const nsISelectionDisplay_DISPLAY_IMAGES:
              root::nsISelectionDisplay__bindgen_ty_1 =
        nsISelectionDisplay__bindgen_ty_1::DISPLAY_IMAGES;
    pub const nsISelectionDisplay_DISPLAY_FRAMES:
              root::nsISelectionDisplay__bindgen_ty_1 =
        nsISelectionDisplay__bindgen_ty_1::DISPLAY_FRAMES;
    pub const nsISelectionDisplay_DISPLAY_ALL:
              root::nsISelectionDisplay__bindgen_ty_1 =
        nsISelectionDisplay__bindgen_ty_1::DISPLAY_ALL;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsISelectionDisplay__bindgen_ty_1 {
        DISPLAY_TEXT = 1,
        DISPLAY_IMAGES = 2,
        DISPLAY_FRAMES = 4,
        DISPLAY_ALL = 7,
    }
    #[test]
    fn bindgen_test_layout_nsISelectionDisplay() {
        assert_eq!(::std::mem::size_of::<nsISelectionDisplay>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsISelectionDisplay ) ));
        assert_eq! (::std::mem::align_of::<nsISelectionDisplay>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsISelectionDisplay ) ));
    }
    impl Clone for nsISelectionDisplay {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISelection {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsISelectionController {
        pub _base: root::nsISelectionDisplay,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISelectionController_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsISelectionController_SELECTION_NONE:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_NONE;
    pub const nsISelectionController_SELECTION_NORMAL:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_NORMAL;
    pub const nsISelectionController_SELECTION_SPELLCHECK:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_SPELLCHECK;
    pub const nsISelectionController_SELECTION_IME_RAWINPUT:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_IME_RAWINPUT;
    pub const nsISelectionController_SELECTION_IME_SELECTEDRAWTEXT:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_IME_SELECTEDRAWTEXT;
    pub const nsISelectionController_SELECTION_IME_CONVERTEDTEXT:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_IME_CONVERTEDTEXT;
    pub const nsISelectionController_SELECTION_IME_SELECTEDCONVERTEDTEXT:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_IME_SELECTEDCONVERTEDTEXT;
    pub const nsISelectionController_SELECTION_ACCESSIBILITY:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_ACCESSIBILITY;
    pub const nsISelectionController_SELECTION_FIND:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_FIND;
    pub const nsISelectionController_SELECTION_URLSECONDARY:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_URLSECONDARY;
    pub const nsISelectionController_SELECTION_URLSTRIKEOUT:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_URLSTRIKEOUT;
    pub const nsISelectionController_NUM_SELECTIONTYPES:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::NUM_SELECTIONTYPES;
    pub const nsISelectionController_SELECTION_ANCHOR_REGION:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_NONE;
    pub const nsISelectionController_SELECTION_FOCUS_REGION:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_NORMAL;
    pub const nsISelectionController_SELECTION_WHOLE_SELECTION:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_SPELLCHECK;
    pub const nsISelectionController_NUM_SELECTION_REGIONS:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::NUM_SELECTION_REGIONS;
    pub const nsISelectionController_SELECTION_OFF:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_NONE;
    pub const nsISelectionController_SELECTION_HIDDEN:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_NORMAL;
    pub const nsISelectionController_SELECTION_ON:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_SPELLCHECK;
    pub const nsISelectionController_SELECTION_DISABLED:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::NUM_SELECTION_REGIONS;
    pub const nsISelectionController_SELECTION_ATTENTION:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_IME_RAWINPUT;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsISelectionController__bindgen_ty_1 {
        SELECTION_NONE = 0,
        SELECTION_NORMAL = 1,
        SELECTION_SPELLCHECK = 2,
        SELECTION_IME_RAWINPUT = 4,
        SELECTION_IME_SELECTEDRAWTEXT = 8,
        SELECTION_IME_CONVERTEDTEXT = 16,
        SELECTION_IME_SELECTEDCONVERTEDTEXT = 32,
        SELECTION_ACCESSIBILITY = 64,
        SELECTION_FIND = 128,
        SELECTION_URLSECONDARY = 256,
        SELECTION_URLSTRIKEOUT = 512,
        NUM_SELECTIONTYPES = 11,
        NUM_SELECTION_REGIONS = 3,
    }
    pub const nsISelectionController_SCROLL_SYNCHRONOUS:
              root::nsISelectionController__bindgen_ty_2 =
        nsISelectionController__bindgen_ty_2::SCROLL_SYNCHRONOUS;
    pub const nsISelectionController_SCROLL_FIRST_ANCESTOR_ONLY:
              root::nsISelectionController__bindgen_ty_2 =
        nsISelectionController__bindgen_ty_2::SCROLL_FIRST_ANCESTOR_ONLY;
    pub const nsISelectionController_SCROLL_CENTER_VERTICALLY:
              root::nsISelectionController__bindgen_ty_2 =
        nsISelectionController__bindgen_ty_2::SCROLL_CENTER_VERTICALLY;
    pub const nsISelectionController_SCROLL_OVERFLOW_HIDDEN:
              root::nsISelectionController__bindgen_ty_2 =
        nsISelectionController__bindgen_ty_2::SCROLL_OVERFLOW_HIDDEN;
    pub const nsISelectionController_SCROLL_FOR_CARET_MOVE:
              root::nsISelectionController__bindgen_ty_2 =
        nsISelectionController__bindgen_ty_2::SCROLL_FOR_CARET_MOVE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsISelectionController__bindgen_ty_2 {
        SCROLL_SYNCHRONOUS = 2,
        SCROLL_FIRST_ANCESTOR_ONLY = 4,
        SCROLL_CENTER_VERTICALLY = 16,
        SCROLL_OVERFLOW_HIDDEN = 32,
        SCROLL_FOR_CARET_MOVE = 64,
    }
    pub const nsISelectionController_MOVE_LEFT:
              root::nsISelectionController__bindgen_ty_3 =
        nsISelectionController__bindgen_ty_3::MOVE_LEFT;
    pub const nsISelectionController_MOVE_RIGHT:
              root::nsISelectionController__bindgen_ty_3 =
        nsISelectionController__bindgen_ty_3::MOVE_RIGHT;
    pub const nsISelectionController_MOVE_UP:
              root::nsISelectionController__bindgen_ty_3 =
        nsISelectionController__bindgen_ty_3::MOVE_UP;
    pub const nsISelectionController_MOVE_DOWN:
              root::nsISelectionController__bindgen_ty_3 =
        nsISelectionController__bindgen_ty_3::MOVE_DOWN;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsISelectionController__bindgen_ty_3 {
        MOVE_LEFT = 0,
        MOVE_RIGHT = 1,
        MOVE_UP = 2,
        MOVE_DOWN = 3,
    }
    #[test]
    fn bindgen_test_layout_nsISelectionController() {
        assert_eq!(::std::mem::size_of::<nsISelectionController>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsISelectionController ) ));
        assert_eq! (::std::mem::align_of::<nsISelectionController>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsISelectionController )
                    ));
    }
    impl Clone for nsISelectionController {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsFrameManagerBase {
        pub mPresShell: *mut root::nsIPresShell,
        pub mRootFrame: *mut root::nsIFrame,
        pub mUndisplayedMap: *mut root::nsFrameManagerBase_UndisplayedMap,
        pub mDisplayContentsMap: *mut root::nsFrameManagerBase_UndisplayedMap,
        pub mIsDestroyingFrames: bool,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsFrameManagerBase_UndisplayedMap {
        _unused: [u8; 0],
    }
    #[test]
    fn bindgen_test_layout_nsFrameManagerBase() {
        assert_eq!(::std::mem::size_of::<nsFrameManagerBase>() , 40usize ,
                   concat ! ( "Size of: " , stringify ! ( nsFrameManagerBase )
                   ));
        assert_eq! (::std::mem::align_of::<nsFrameManagerBase>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsFrameManagerBase ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFrameManagerBase ) ) . mPresShell
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFrameManagerBase
                    ) , "::" , stringify ! ( mPresShell ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFrameManagerBase ) ) . mRootFrame
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFrameManagerBase
                    ) , "::" , stringify ! ( mRootFrame ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFrameManagerBase ) ) .
                    mUndisplayedMap as * const _ as usize } , 16usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsFrameManagerBase
                    ) , "::" , stringify ! ( mUndisplayedMap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFrameManagerBase ) ) .
                    mDisplayContentsMap as * const _ as usize } , 24usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsFrameManagerBase
                    ) , "::" , stringify ! ( mDisplayContentsMap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFrameManagerBase ) ) .
                    mIsDestroyingFrames as * const _ as usize } , 32usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsFrameManagerBase
                    ) , "::" , stringify ! ( mIsDestroyingFrames ) ));
    }
    impl Clone for nsFrameManagerBase {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIWeakReference {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIWeakReference_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIWeakReference() {
        assert_eq!(::std::mem::size_of::<nsIWeakReference>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsIWeakReference ) ));
        assert_eq! (::std::mem::align_of::<nsIWeakReference>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIWeakReference ) ));
    }
    impl Clone for nsIWeakReference {
        fn clone(&self) -> Self { *self }
    }
    pub type nsWeakPtr = root::nsCOMPtr;
    /**
 * templated hashtable class maps keys to reference pointers.
 * See nsBaseHashtable for complete declaration.
 * @param KeyClass a wrapper-class for the hashtable key, see nsHashKeys.h
 *   for a complete specification.
 * @param PtrType the reference-type being wrapped
 * @see nsDataHashtable, nsClassHashtable
 */
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsRefPtrHashtable {
    }
    pub type nsRefPtrHashtable_KeyType = [u8; 0usize];
    pub type nsRefPtrHashtable_UserDataType<PtrType> = *mut PtrType;
    pub type nsRefPtrHashtable_base_type = u8;
    /**
 * templated hashtable class maps keys to C++ object pointers.
 * See nsBaseHashtable for complete declaration.
 * @param KeyClass a wrapper-class for the hashtable key, see nsHashKeys.h
 *   for a complete specification.
 * @param Class the class-type being wrapped
 * @see nsInterfaceHashtable, nsClassHashtable
 */
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsClassHashtable {
    }
    pub type nsClassHashtable_KeyType = [u8; 0usize];
    pub type nsClassHashtable_UserDataType<T> = *mut T;
    pub type nsClassHashtable_base_type = u8;
    #[repr(C)]
    pub struct nsPresArena {
        pub mFreeLists: [root::nsPresArena_FreeList; 213usize],
        pub mPool: [u64; 4usize],
        pub mArenaRefPtrs: [u64; 5usize],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPresArena_FreeList {
        pub mEntries: root::nsTArray<*mut ::std::os::raw::c_void>,
        pub mEntrySize: usize,
        pub mEntriesEverAllocated: usize,
    }
    #[test]
    fn bindgen_test_layout_nsPresArena_FreeList() {
        assert_eq!(::std::mem::size_of::<nsPresArena_FreeList>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsPresArena_FreeList ) ));
        assert_eq! (::std::mem::align_of::<nsPresArena_FreeList>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsPresArena_FreeList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresArena_FreeList ) ) . mEntries
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresArena_FreeList ) , "::" , stringify ! ( mEntries )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresArena_FreeList ) ) . mEntrySize
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresArena_FreeList ) , "::" , stringify ! ( mEntrySize )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresArena_FreeList ) ) .
                    mEntriesEverAllocated as * const _ as usize } , 16usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresArena_FreeList ) , "::" , stringify ! (
                    mEntriesEverAllocated ) ));
    }
    #[test]
    fn bindgen_test_layout_nsPresArena() {
        assert_eq!(::std::mem::size_of::<nsPresArena>() , 5184usize , concat !
                   ( "Size of: " , stringify ! ( nsPresArena ) ));
        assert_eq! (::std::mem::align_of::<nsPresArena>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsPresArena ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresArena ) ) . mFreeLists as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresArena ) ,
                    "::" , stringify ! ( mFreeLists ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresArena ) ) . mPool as * const _
                    as usize } , 5112usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresArena ) ,
                    "::" , stringify ! ( mPool ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresArena ) ) . mArenaRefPtrs as *
                    const _ as usize } , 5144usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresArena ) ,
                    "::" , stringify ! ( mArenaRefPtrs ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsArenaMemoryStats {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct imgIRequest {
        pub _base: root::nsIRequest,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct imgIRequest_COMTypeInfo {
        pub _address: u8,
    }
    pub const imgIRequest_STATUS_NONE: root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_NONE;
    pub const imgIRequest_STATUS_SIZE_AVAILABLE:
              root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_SIZE_AVAILABLE;
    pub const imgIRequest_STATUS_LOAD_COMPLETE:
              root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_LOAD_COMPLETE;
    pub const imgIRequest_STATUS_ERROR: root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_ERROR;
    pub const imgIRequest_STATUS_FRAME_COMPLETE:
              root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_FRAME_COMPLETE;
    pub const imgIRequest_STATUS_DECODE_COMPLETE:
              root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_DECODE_COMPLETE;
    pub const imgIRequest_STATUS_IS_ANIMATED: root::imgIRequest__bindgen_ty_1
              =
        imgIRequest__bindgen_ty_1::STATUS_IS_ANIMATED;
    pub const imgIRequest_STATUS_HAS_TRANSPARENCY:
              root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_HAS_TRANSPARENCY;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum imgIRequest__bindgen_ty_1 {
        STATUS_NONE = 0,
        STATUS_SIZE_AVAILABLE = 1,
        STATUS_LOAD_COMPLETE = 2,
        STATUS_ERROR = 4,
        STATUS_FRAME_COMPLETE = 8,
        STATUS_DECODE_COMPLETE = 16,
        STATUS_IS_ANIMATED = 32,
        STATUS_HAS_TRANSPARENCY = 64,
    }
    pub const imgIRequest_CORS_NONE: root::imgIRequest__bindgen_ty_2 =
        imgIRequest__bindgen_ty_2::CORS_NONE;
    pub const imgIRequest_CORS_ANONYMOUS: root::imgIRequest__bindgen_ty_2 =
        imgIRequest__bindgen_ty_2::CORS_ANONYMOUS;
    pub const imgIRequest_CORS_USE_CREDENTIALS:
              root::imgIRequest__bindgen_ty_2 =
        imgIRequest__bindgen_ty_2::CORS_USE_CREDENTIALS;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum imgIRequest__bindgen_ty_2 {
        CORS_NONE = 1,
        CORS_ANONYMOUS = 2,
        CORS_USE_CREDENTIALS = 3,
    }
    pub const imgIRequest_CATEGORY_FRAME_INIT: root::imgIRequest__bindgen_ty_3
              =
        imgIRequest__bindgen_ty_3::CATEGORY_FRAME_INIT;
    pub const imgIRequest_CATEGORY_SIZE_QUERY: root::imgIRequest__bindgen_ty_3
              =
        imgIRequest__bindgen_ty_3::CATEGORY_SIZE_QUERY;
    pub const imgIRequest_CATEGORY_DISPLAY: root::imgIRequest__bindgen_ty_3 =
        imgIRequest__bindgen_ty_3::CATEGORY_DISPLAY;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum imgIRequest__bindgen_ty_3 {
        CATEGORY_FRAME_INIT = 1,
        CATEGORY_SIZE_QUERY = 2,
        CATEGORY_DISPLAY = 4,
    }
    #[test]
    fn bindgen_test_layout_imgIRequest() {
        assert_eq!(::std::mem::size_of::<imgIRequest>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( imgIRequest ) ));
        assert_eq! (::std::mem::align_of::<imgIRequest>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( imgIRequest ) ));
    }
    impl Clone for imgIRequest {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct imgINotificationObserver {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct imgINotificationObserver_COMTypeInfo {
        pub _address: u8,
    }
    pub const imgINotificationObserver_SIZE_AVAILABLE:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::SIZE_AVAILABLE;
    pub const imgINotificationObserver_FRAME_UPDATE:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::FRAME_UPDATE;
    pub const imgINotificationObserver_FRAME_COMPLETE:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::FRAME_COMPLETE;
    pub const imgINotificationObserver_LOAD_COMPLETE:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::LOAD_COMPLETE;
    pub const imgINotificationObserver_DECODE_COMPLETE:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::DECODE_COMPLETE;
    pub const imgINotificationObserver_DISCARD:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::DISCARD;
    pub const imgINotificationObserver_UNLOCKED_DRAW:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::UNLOCKED_DRAW;
    pub const imgINotificationObserver_IS_ANIMATED:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::IS_ANIMATED;
    pub const imgINotificationObserver_HAS_TRANSPARENCY:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::HAS_TRANSPARENCY;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum imgINotificationObserver__bindgen_ty_1 {
        SIZE_AVAILABLE = 1,
        FRAME_UPDATE = 2,
        FRAME_COMPLETE = 3,
        LOAD_COMPLETE = 4,
        DECODE_COMPLETE = 5,
        DISCARD = 6,
        UNLOCKED_DRAW = 7,
        IS_ANIMATED = 8,
        HAS_TRANSPARENCY = 9,
    }
    #[test]
    fn bindgen_test_layout_imgINotificationObserver() {
        assert_eq!(::std::mem::size_of::<imgINotificationObserver>() , 8usize
                   , concat ! (
                   "Size of: " , stringify ! ( imgINotificationObserver ) ));
        assert_eq! (::std::mem::align_of::<imgINotificationObserver>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( imgINotificationObserver )
                    ));
    }
    impl Clone for imgINotificationObserver {
        fn clone(&self) -> Self { *self }
    }
    pub type nsFrameState_size_t = u64;
    pub const nsFrameState_NS_STATE_FLEX_NORMAL_FLOW_CHILDREN_IN_CSS_ORDER:
              root::nsFrameState =
        nsFrameState::NS_STATE_BOX_CHILD_RESERVED;
    pub const nsFrameState_NS_STATE_FLEX_IS_LEGACY_WEBKIT_BOX:
              root::nsFrameState =
        nsFrameState::NS_STATE_STACK_NOT_POSITIONED;
    pub const nsFrameState_NS_STATE_FLEX_SYNTHESIZE_BASELINE:
              root::nsFrameState =
        nsFrameState::NS_STATE_IS_HORIZONTAL;
    pub const nsFrameState_NS_STATE_GRID_NORMAL_FLOW_CHILDREN_IN_CSS_ORDER:
              root::nsFrameState =
        nsFrameState::NS_STATE_BOX_CHILD_RESERVED;
    pub const nsFrameState_NS_STATE_GRID_DID_PUSH_ITEMS: root::nsFrameState =
        nsFrameState::NS_STATE_STACK_NOT_POSITIONED;
    pub const nsFrameState_NS_STATE_GRID_GENERATE_COMPUTED_VALUES:
              root::nsFrameState =
        nsFrameState::NS_STATE_IS_HORIZONTAL;
    pub const nsFrameState_NS_STATE_GRID_SYNTHESIZE_BASELINE:
              root::nsFrameState =
        nsFrameState::NS_STATE_AUTO_STRETCH;
    pub const nsFrameState_NS_STATE_IS_OUTER_SVG: root::nsFrameState =
        nsFrameState::NS_STATE_BOX_CHILD_RESERVED;
    pub const nsFrameState_NS_STATE_SVG_CLIPPATH_CHILD: root::nsFrameState =
        nsFrameState::NS_STATE_STACK_NOT_POSITIONED;
    pub const nsFrameState_NS_STATE_SVG_POSITIONING_DIRTY: root::nsFrameState
              =
        nsFrameState::NS_STATE_IS_HORIZONTAL;
    pub const nsFrameState_NS_STATE_SVG_POSITIONING_MAY_USE_PERCENTAGES:
              root::nsFrameState =
        nsFrameState::NS_STATE_AUTO_STRETCH;
    pub const nsFrameState_NS_STATE_SVG_TEXT_IN_REFLOW: root::nsFrameState =
        nsFrameState::NS_STATE_IS_ROOT;
    pub const nsFrameState_TEXT_FIRST_LETTER: root::nsFrameState =
        nsFrameState::NS_STATE_BOX_CHILD_RESERVED;
    pub const nsFrameState_TEXT_START_OF_LINE: root::nsFrameState =
        nsFrameState::NS_STATE_STACK_NOT_POSITIONED;
    pub const nsFrameState_TEXT_END_OF_LINE: root::nsFrameState =
        nsFrameState::NS_STATE_IS_HORIZONTAL;
    pub const nsFrameState_TEXT_HYPHEN_BREAK: root::nsFrameState =
        nsFrameState::NS_STATE_AUTO_STRETCH;
    pub const nsFrameState_TEXT_TRIMMED_TRAILING_WHITESPACE:
              root::nsFrameState =
        nsFrameState::NS_STATE_IS_ROOT;
    pub const nsFrameState_TEXT_JUSTIFICATION_ENABLED: root::nsFrameState =
        nsFrameState::NS_STATE_CURRENTLY_IN_DEBUG;
    pub const nsFrameState_TEXT_SELECTION_UNDERLINE_OVERFLOWED:
              root::nsFrameState =
        nsFrameState::NS_STATE_SET_TO_DEBUG;
    pub const nsFrameState_TEXT_IS_ONLY_WHITESPACE: root::nsFrameState =
        nsFrameState::NS_STATE_DEBUG_WAS_SET;
    pub const nsFrameState_TEXT_ISNOT_ONLY_WHITESPACE: root::nsFrameState =
        nsFrameState::NS_STATE_MENU_HAS_POPUP_LIST;
    pub const nsFrameState_TEXT_IN_TEXTRUN_USER_DATA: root::nsFrameState =
        nsFrameState::NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK;
    pub const nsFrameState_TEXT_OFFSETS_NEED_FIXING: root::nsFrameState =
        nsFrameState::NS_STATE_EQUAL_SIZE;
    pub const nsFrameState_TEXT_HAS_NONCOLLAPSED_CHARACTERS:
              root::nsFrameState =
        nsFrameState::NS_STATE_IS_DIRECTION_NORMAL;
    pub const nsFrameState_TEXT_IS_IN_TOKEN_MATHML: root::nsFrameState =
        nsFrameState::NS_FRAME_IS_PUSHED_FLOAT;
    pub const nsFrameState_TEXT_IN_UNINFLATED_TEXTRUN_USER_DATA:
              root::nsFrameState =
        nsFrameState::NS_FRAME_MOUSE_THROUGH_ALWAYS;
    pub const nsFrameState_TEXT_HAS_FONT_INFLATION: root::nsFrameState =
        nsFrameState::NS_FRAME_MOUSE_THROUGH_NEVER;
    pub const nsFrameState_NS_BLOCK_NEEDS_BIDI_RESOLUTION: root::nsFrameState
              =
        nsFrameState::NS_STATE_BOX_CHILD_RESERVED;
    pub const nsFrameState_NS_BLOCK_HAS_PUSHED_FLOATS: root::nsFrameState =
        nsFrameState::NS_STATE_STACK_NOT_POSITIONED;
    pub const nsFrameState_NS_BLOCK_MARGIN_ROOT: root::nsFrameState =
        nsFrameState::NS_STATE_IS_HORIZONTAL;
    pub const nsFrameState_NS_BLOCK_FLOAT_MGR: root::nsFrameState =
        nsFrameState::NS_STATE_AUTO_STRETCH;
    pub const nsFrameState_NS_BLOCK_HAS_LINE_CURSOR: root::nsFrameState =
        nsFrameState::NS_STATE_IS_ROOT;
    pub const nsFrameState_NS_BLOCK_HAS_OVERFLOW_LINES: root::nsFrameState =
        nsFrameState::NS_STATE_CURRENTLY_IN_DEBUG;
    pub const nsFrameState_NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS:
              root::nsFrameState =
        nsFrameState::NS_STATE_SET_TO_DEBUG;
    pub const nsFrameState_NS_BLOCK_HAS_CLEAR_CHILDREN: root::nsFrameState =
        nsFrameState::NS_STATE_DEBUG_WAS_SET;
    pub const nsFrameState_NS_BLOCK_CLIP_PAGINATED_OVERFLOW:
              root::nsFrameState =
        nsFrameState::NS_STATE_MENU_HAS_POPUP_LIST;
    pub const nsFrameState_NS_BLOCK_HAS_FIRST_LETTER_STYLE: root::nsFrameState
              =
        nsFrameState::NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK;
    pub const nsFrameState_NS_BLOCK_FRAME_HAS_OUTSIDE_BULLET:
              root::nsFrameState =
        nsFrameState::NS_STATE_EQUAL_SIZE;
    pub const nsFrameState_NS_BLOCK_FRAME_HAS_INSIDE_BULLET:
              root::nsFrameState =
        nsFrameState::NS_STATE_IS_DIRECTION_NORMAL;
    pub const nsFrameState_NS_BLOCK_LOOK_FOR_DIRTY_FRAMES: root::nsFrameState
              =
        nsFrameState::NS_FRAME_MOUSE_THROUGH_NEVER;
    pub const nsFrameState_NS_BLOCK_FRAME_INTRINSICS_INFLATED:
              root::nsFrameState =
        nsFrameState::TEXT_NO_RENDERED_GLYPHS;
    pub const nsFrameState_NS_BLOCK_HAS_FIRST_LETTER_CHILD: root::nsFrameState
              =
        nsFrameState::TEXT_IN_OFFSET_CACHE;
    pub const nsFrameState_BULLET_FRAME_HAS_FONT_INFLATION: root::nsFrameState
              =
        nsFrameState::TEXT_NO_RENDERED_GLYPHS;
    pub const nsFrameState_BULLET_FRAME_IMAGE_LOADING: root::nsFrameState =
        nsFrameState::TEXT_IN_OFFSET_CACHE;
    pub const nsFrameState_NS_SCROLLFRAME_INVALIDATE_CONTENTS_ON_SCROLL:
              root::nsFrameState =
        nsFrameState::NS_STATE_BOX_CHILD_RESERVED;
    pub const nsFrameState_IMAGE_SIZECONSTRAINED: root::nsFrameState =
        nsFrameState::NS_STATE_BOX_CHILD_RESERVED;
    pub const nsFrameState_IMAGE_GOTINITIALREFLOW: root::nsFrameState =
        nsFrameState::NS_STATE_STACK_NOT_POSITIONED;
    pub const nsFrameState_NS_INLINE_FRAME_BIDI_VISUAL_STATE_IS_SET:
              root::nsFrameState =
        nsFrameState::NS_STATE_STACK_NOT_POSITIONED;
    pub const nsFrameState_NS_INLINE_FRAME_BIDI_VISUAL_IS_FIRST:
              root::nsFrameState =
        nsFrameState::NS_STATE_IS_HORIZONTAL;
    pub const nsFrameState_NS_INLINE_FRAME_BIDI_VISUAL_IS_LAST:
              root::nsFrameState =
        nsFrameState::NS_STATE_AUTO_STRETCH;
    pub const nsFrameState_NS_RUBY_TEXT_FRAME_AUTOHIDE: root::nsFrameState =
        nsFrameState::NS_STATE_IS_ROOT;
    pub const nsFrameState_NS_RUBY_TEXT_CONTAINER_IS_SPAN: root::nsFrameState
              =
        nsFrameState::NS_STATE_BOX_CHILD_RESERVED;
    pub const nsFrameState_PLACEHOLDER_FOR_FLOAT: root::nsFrameState =
        nsFrameState::NS_STATE_BOX_CHILD_RESERVED;
    pub const nsFrameState_PLACEHOLDER_FOR_ABSPOS: root::nsFrameState =
        nsFrameState::NS_STATE_STACK_NOT_POSITIONED;
    pub const nsFrameState_PLACEHOLDER_FOR_FIXEDPOS: root::nsFrameState =
        nsFrameState::NS_STATE_IS_HORIZONTAL;
    pub const nsFrameState_PLACEHOLDER_FOR_POPUP: root::nsFrameState =
        nsFrameState::NS_STATE_AUTO_STRETCH;
    pub const nsFrameState_PLACEHOLDER_FOR_TOPLAYER: root::nsFrameState =
        nsFrameState::NS_STATE_IS_ROOT;
    pub const nsFrameState_PLACEHOLDER_STATICPOS_NEEDS_CSSALIGN:
              root::nsFrameState =
        nsFrameState::NS_STATE_CURRENTLY_IN_DEBUG;
    pub const nsFrameState_PLACEHOLDER_LINE_IS_EMPTY_SO_FAR:
              root::nsFrameState =
        nsFrameState::NS_STATE_SET_TO_DEBUG;
    pub const nsFrameState_PLACEHOLDER_HAVE_LINE_IS_EMPTY_SO_FAR:
              root::nsFrameState =
        nsFrameState::NS_STATE_DEBUG_WAS_SET;
    pub const nsFrameState_NS_TABLE_CELL_HAS_PCT_OVER_BSIZE:
              root::nsFrameState =
        nsFrameState::NS_STATE_MENU_HAS_POPUP_LIST;
    pub const nsFrameState_NS_TABLE_CELL_HAD_SPECIAL_REFLOW:
              root::nsFrameState =
        nsFrameState::NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK;
    pub const nsFrameState_NS_TABLE_CELL_CONTENT_EMPTY: root::nsFrameState =
        nsFrameState::NS_STATE_IS_DIRECTION_NORMAL;
    pub const nsFrameState_NS_REPEATED_ROW_OR_ROWGROUP: root::nsFrameState =
        nsFrameState::NS_STATE_MENU_HAS_POPUP_LIST;
    pub const nsFrameState_NS_ROW_HAS_CELL_WITH_STYLE_BSIZE:
              root::nsFrameState =
        nsFrameState::NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK;
    pub const nsFrameState_NS_TABLE_ROW_HAS_UNPAGINATED_BSIZE:
              root::nsFrameState =
        nsFrameState::NS_STATE_EQUAL_SIZE;
    pub const nsFrameState_NS_ROWGROUP_HAS_ROW_CURSOR: root::nsFrameState =
        nsFrameState::NS_STATE_DEBUG_WAS_SET;
    pub const nsFrameState_NS_ROWGROUP_HAS_STYLE_BSIZE: root::nsFrameState =
        nsFrameState::NS_STATE_EQUAL_SIZE;
    pub const nsFrameState_NS_ROWGROUP_REPEATABLE: root::nsFrameState =
        nsFrameState::NS_STATE_IS_DIRECTION_NORMAL;
    pub const nsFrameState_NS_TABLE_PART_HAS_FIXED_BACKGROUND:
              root::nsFrameState =
        nsFrameState::NS_STATE_MENU_HAS_POPUP_LIST;
    #[repr(u64)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsFrameState {
        NS_FRAME_IN_REFLOW = 1,
        NS_FRAME_FIRST_REFLOW = 2,
        NS_FRAME_IS_FLUID_CONTINUATION = 4,
        NS_FRAME_ANONYMOUSCONTENTCREATOR_CONTENT = 8,
        NS_FRAME_EXTERNAL_REFERENCE = 16,
        NS_FRAME_CONTAINS_RELATIVE_BSIZE = 32,
        NS_FRAME_GENERATED_CONTENT = 64,
        NS_FRAME_IS_OVERFLOW_CONTAINER = 128,
        NS_FRAME_OUT_OF_FLOW = 256,
        NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN = 512,
        NS_FRAME_IS_DIRTY = 1024,
        NS_FRAME_TOO_DEEP_IN_FRAME_TREE = 2048,
        NS_FRAME_HAS_DIRTY_CHILDREN = 4096,
        NS_FRAME_HAS_VIEW = 8192,
        NS_FRAME_INDEPENDENT_SELECTION = 16384,
        NS_FRAME_PART_OF_IBSPLIT = 32768,
        NS_FRAME_MAY_BE_TRANSFORMED = 65536,
        NS_FRAME_IS_BIDI = 131072,
        NS_FRAME_HAS_CHILD_WITH_VIEW = 262144,
        NS_FRAME_REFLOW_ROOT = 524288,
        NS_FRAME_IS_PUSHED_FLOAT = 4294967296,
        NS_FRAME_DRAWING_AS_PAINTSERVER = 8589934592,
        NS_FRAME_DESCENDANT_INTRINSIC_ISIZE_DEPENDS_ON_BSIZE = 17179869184,
        NS_FRAME_SIMPLE_EVENT_REGIONS = 34359738368,
        NS_FRAME_UPDATE_LAYER_TREE = 68719476736,
        NS_FRAME_HAS_ABSPOS_CHILDREN = 137438953472,
        NS_FRAME_PAINTED_THEBES = 274877906944,
        NS_FRAME_IN_CONSTRAINED_BSIZE = 549755813888,
        NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO = 1099511627776,
        NS_FRAME_FONT_INFLATION_CONTAINER = 2199023255552,
        NS_FRAME_FONT_INFLATION_FLOW_ROOT = 4398046511104,
        NS_FRAME_SVG_LAYOUT = 8796093022208,
        NS_FRAME_MAY_HAVE_GENERATED_CONTENT = 17592186044416,
        NS_FRAME_NO_COMPONENT_ALPHA = 35184372088832,
        NS_FRAME_VISIBILITY_IS_TRACKED = 70368744177664,
        NS_FRAME_IS_SVG_TEXT = 140737488355328,
        NS_FRAME_NEEDS_PAINT = 281474976710656,
        NS_FRAME_DESCENDANT_NEEDS_PAINT = 562949953421312,
        NS_FRAME_IN_POPUP = 1125899906842624,
        NS_FRAME_ALL_DESCENDANTS_NEED_PAINT = 2251799813685248,
        NS_FRAME_HAS_INVALID_RECT = 4503599627370496,
        NS_FRAME_IS_NONDISPLAY = 9007199254740992,
        NS_FRAME_HAS_LAYER_ACTIVITY_PROPERTY = 18014398509481984,
        NS_FRAME_OWNS_ANON_BOXES = 36028797018963968,
        NS_FRAME_HAS_CSS_COUNTER_STYLE = 72057594037927936,
        NS_FRAME_SIMPLE_DISPLAYLIST = 144115188075855872,
        NS_FRAME_MATHML_SCRIPT_DESCENDANT = 288230376151711744,
        NS_FRAME_IS_IN_SINGLE_CHAR_MI = 576460752303423488,
        NS_STATE_BOX_CHILD_RESERVED = 1048576,
        NS_STATE_STACK_NOT_POSITIONED = 2097152,
        NS_STATE_IS_HORIZONTAL = 4194304,
        NS_STATE_AUTO_STRETCH = 8388608,
        NS_STATE_IS_ROOT = 16777216,
        NS_STATE_CURRENTLY_IN_DEBUG = 33554432,
        NS_STATE_SET_TO_DEBUG = 67108864,
        NS_STATE_DEBUG_WAS_SET = 134217728,
        NS_STATE_MENU_HAS_POPUP_LIST = 268435456,
        NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK = 536870912,
        NS_STATE_EQUAL_SIZE = 1073741824,
        NS_STATE_IS_DIRECTION_NORMAL = 2147483648,
        NS_FRAME_MOUSE_THROUGH_ALWAYS = 1152921504606846976,
        NS_FRAME_MOUSE_THROUGH_NEVER = 2305843009213693952,
        TEXT_NO_RENDERED_GLYPHS = 4611686018427387904,
        TEXT_IN_OFFSET_CACHE = 9223372036854775808,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct gfxContext {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDocShell {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsViewManager {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsView {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIPageSequenceFrame {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsCanvasFrame {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsCaret {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsFrameSelection {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsILayoutHistoryState {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIReflowCallback {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsCSSFrameConstructor {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AutoWeakFrame {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct WeakFrame {
        _unused: [u8; 0],
    }
    /**
 * Interface for frames that are scrollable. This interface exposes
 * APIs for examining scroll state, observing changes to scroll state,
 * and triggering scrolling.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIScrollableFrame {
        pub _base: root::nsIScrollbarMediator,
    }
    pub type nsIScrollableFrame_CSSIntPoint = root::mozilla::CSSIntPoint;
    pub type nsIScrollableFrame_ContainerLayerParameters =
        root::mozilla::ContainerLayerParameters;
    pub type nsIScrollableFrame_FrameMetrics =
        root::mozilla::layers::FrameMetrics;
    pub type nsIScrollableFrame_ScrollSnapInfo =
        root::mozilla::layers::ScrollSnapInfo;
    pub type nsIScrollableFrame_Has_NS_DECL_QUERYFRAME_TARGET =
        root::nsIScrollableFrame;
    pub const nsIScrollableFrame_HORIZONTAL:
              root::nsIScrollableFrame__bindgen_ty_1 =
        nsIScrollableFrame__bindgen_ty_1::HORIZONTAL;
    pub const nsIScrollableFrame_VERTICAL:
              root::nsIScrollableFrame__bindgen_ty_1 =
        nsIScrollableFrame__bindgen_ty_1::VERTICAL;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIScrollableFrame__bindgen_ty_1 {
        HORIZONTAL = 1,
        VERTICAL = 2,
    }
    #[repr(u32)]
    /**
   * When a scroll operation is requested, we ask for instant, smooth,
   * smooth msd, or normal scrolling.
   *
   * SMOOTH scrolls have a symmetrical acceleration and deceleration curve
   * modeled with a set of splines that guarantee that the destination will be 
   * reached over a fixed time interval.  SMOOTH will only be smooth if smooth
   * scrolling is actually enabled.  This behavior is utilized by keyboard and
   * mouse wheel scrolling events.
   *
   * SMOOTH_MSD implements a physically based model that approximates the
   * behavior of a mass-spring-damper system.  SMOOTH_MSD scrolls have a
   * non-symmetrical acceleration and deceleration curve, can potentially
   * overshoot the destination on intermediate frames, and complete over a
   * variable time interval.  SMOOTH_MSD will only be smooth if cssom-view
   * smooth-scrolling is enabled.
   *
   * INSTANT is always synchronous, NORMAL can be asynchronous.
   *
   * If an INSTANT scroll request happens while a SMOOTH or async scroll is
   * already in progress, the async scroll is interrupted and we instantly
   * scroll to the destination.
   *
   * If an INSTANT or SMOOTH scroll request happens while a SMOOTH_MSD scroll
   * is already in progress, the SMOOTH_MSD scroll is interrupted without
   * first scrolling to the destination.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIScrollableFrame_ScrollMode {
        INSTANT = 0,
        SMOOTH = 1,
        SMOOTH_MSD = 2,
        NORMAL = 3,
    }
    #[repr(u32)]
    /**
   * Some platforms (OSX) may generate additional scrolling events even
   * after the user has stopped scrolling, simulating a momentum scrolling
   * effect resulting from fling gestures.
   * SYNTHESIZED_MOMENTUM_EVENT indicates that the scrolling is being requested
   * by such a synthesized event and may be ignored if another scroll has
   * been started since the last actual user input.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIScrollableFrame_ScrollMomentum {
        NOT_MOMENTUM = 0,
        SYNTHESIZED_MOMENTUM_EVENT = 1,
    }
    #[repr(u32)]
    /**
   * When scrolling by a relative amount, we can choose various units.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIScrollableFrame_ScrollUnit {
        DEVICE_PIXELS = 0,
        LINES = 1,
        PAGES = 2,
        WHOLE = 3,
    }
    extern "C" {
        #[link_name = "_ZN18nsIScrollableFrame9kFrameIIDE"]
        pub static nsIScrollableFrame_kFrameIID: root::nsQueryFrame_FrameIID;
    }
    #[test]
    fn bindgen_test_layout_nsIScrollableFrame() {
        assert_eq!(::std::mem::size_of::<nsIScrollableFrame>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsIScrollableFrame )
                   ));
        assert_eq! (::std::mem::align_of::<nsIScrollableFrame>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIScrollableFrame ) ));
    }
    impl Clone for nsIScrollableFrame {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDisplayList {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDisplayListBuilder {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsRefreshDriver {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsARefreshObserver {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsAPostRefreshObserver {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsAccessibilityService {
        _unused: [u8; 0],
    }
    /**
 * The signature of the timer callback function passed to initWithFuncCallback.
 * This is the function that will get called when the timer expires if the
 * timer is initialized via initWithFuncCallback.
 *
 * @param aTimer the timer which has expired
 * @param aClosure opaque parameter passed to initWithFuncCallback
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsITimer {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsITimer_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsITimer_TYPE_ONE_SHOT: root::nsITimer__bindgen_ty_1 =
        nsITimer__bindgen_ty_1::TYPE_ONE_SHOT;
    pub const nsITimer_TYPE_REPEATING_SLACK: root::nsITimer__bindgen_ty_1 =
        nsITimer__bindgen_ty_1::TYPE_REPEATING_SLACK;
    pub const nsITimer_TYPE_REPEATING_PRECISE: root::nsITimer__bindgen_ty_1 =
        nsITimer__bindgen_ty_1::TYPE_REPEATING_PRECISE;
    pub const nsITimer_TYPE_REPEATING_PRECISE_CAN_SKIP:
              root::nsITimer__bindgen_ty_1 =
        nsITimer__bindgen_ty_1::TYPE_REPEATING_PRECISE_CAN_SKIP;
    pub const nsITimer_TYPE_REPEATING_SLACK_LOW_PRIORITY:
              root::nsITimer__bindgen_ty_1 =
        nsITimer__bindgen_ty_1::TYPE_REPEATING_SLACK_LOW_PRIORITY;
    pub const nsITimer_TYPE_ONE_SHOT_LOW_PRIORITY:
              root::nsITimer__bindgen_ty_1 =
        nsITimer__bindgen_ty_1::TYPE_ONE_SHOT_LOW_PRIORITY;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsITimer__bindgen_ty_1 {
        TYPE_ONE_SHOT = 0,
        TYPE_REPEATING_SLACK = 1,
        TYPE_REPEATING_PRECISE = 2,
        TYPE_REPEATING_PRECISE_CAN_SKIP = 3,
        TYPE_REPEATING_SLACK_LOW_PRIORITY = 4,
        TYPE_ONE_SHOT_LOW_PRIORITY = 5,
    }
    #[test]
    fn bindgen_test_layout_nsITimer() {
        assert_eq!(::std::mem::size_of::<nsITimer>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsITimer ) ));
        assert_eq! (::std::mem::align_of::<nsITimer>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsITimer ) ));
    }
    impl Clone for nsITimer {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct CapturingContentInfo {
        pub mAllowed: bool,
        pub mPointerLock: bool,
        pub mRetargetToElement: bool,
        pub mPreventDrag: bool,
        pub mContent: root::mozilla::StaticRefPtr<root::nsIContent>,
    }
    #[test]
    fn bindgen_test_layout_CapturingContentInfo() {
        assert_eq!(::std::mem::size_of::<CapturingContentInfo>() , 16usize ,
                   concat ! (
                   "Size of: " , stringify ! ( CapturingContentInfo ) ));
        assert_eq! (::std::mem::align_of::<CapturingContentInfo>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( CapturingContentInfo ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CapturingContentInfo ) ) . mAllowed
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CapturingContentInfo ) , "::" , stringify ! ( mAllowed )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CapturingContentInfo ) ) .
                    mPointerLock as * const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CapturingContentInfo ) , "::" , stringify ! ( mPointerLock
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CapturingContentInfo ) ) .
                    mRetargetToElement as * const _ as usize } , 2usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    CapturingContentInfo ) , "::" , stringify ! (
                    mRetargetToElement ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CapturingContentInfo ) ) .
                    mPreventDrag as * const _ as usize } , 3usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CapturingContentInfo ) , "::" , stringify ! ( mPreventDrag
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CapturingContentInfo ) ) . mContent
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CapturingContentInfo ) , "::" , stringify ! ( mContent )
                    ));
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsRectVisibility {
        nsRectVisibility_kVisible = 0,
        nsRectVisibility_kAboveViewport = 1,
        nsRectVisibility_kBelowViewport = 2,
        nsRectVisibility_kLeftOfViewport = 3,
        nsRectVisibility_kRightOfViewport = 4,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIObserver {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIObserver_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIObserver() {
        assert_eq!(::std::mem::size_of::<nsIObserver>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIObserver ) ));
        assert_eq! (::std::mem::align_of::<nsIObserver>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsIObserver ) ));
    }
    impl Clone for nsIObserver {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIEventTarget {
        pub _base: root::nsISupports,
        pub mVirtualThread: *mut root::PRThread,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIEventTarget_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsIEventTarget_DISPATCH_NORMAL:
              root::nsIEventTarget__bindgen_ty_1 =
        nsIEventTarget__bindgen_ty_1::DISPATCH_NORMAL;
    pub const nsIEventTarget_DISPATCH_SYNC: root::nsIEventTarget__bindgen_ty_1
              =
        nsIEventTarget__bindgen_ty_1::DISPATCH_SYNC;
    pub const nsIEventTarget_DISPATCH_AT_END:
              root::nsIEventTarget__bindgen_ty_1 =
        nsIEventTarget__bindgen_ty_1::DISPATCH_AT_END;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIEventTarget__bindgen_ty_1 {
        DISPATCH_NORMAL = 0,
        DISPATCH_SYNC = 1,
        DISPATCH_AT_END = 2,
    }
    #[test]
    fn bindgen_test_layout_nsIEventTarget() {
        assert_eq!(::std::mem::size_of::<nsIEventTarget>() , 16usize , concat
                   ! ( "Size of: " , stringify ! ( nsIEventTarget ) ));
        assert_eq! (::std::mem::align_of::<nsIEventTarget>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsIEventTarget ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIEventTarget ) ) . mVirtualThread
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIEventTarget ) ,
                    "::" , stringify ! ( mVirtualThread ) ));
    }
    impl Clone for nsIEventTarget {
        fn clone(&self) -> Self { *self }
    }
    pub type nsTimerCallbackFunc =
        ::std::option::Option<unsafe extern "C" fn(aTimer:
                                                       *mut root::nsITimer,
                                                   aClosure:
                                                       *mut ::std::os::raw::c_void)>;
    /**
 * The signature of the timer name callback function passed to
 * initWithNameableFuncCallback.
 * This is the function that will get called when timer profiling is enabled
 * via the "TimerFirings" log module.
 *
 * @param aTimer the timer which has expired
 * @param aAnonymize whether the name should avoid including privacy sensitive info
 * @param aClosure opaque parameter passed to initWithFuncCallback
 * @param aBuf a buffer in which to put the name
 * @param aLen the length of the buffer
 */
    pub type nsTimerNameCallbackFunc =
        ::std::option::Option<unsafe extern "C" fn(aTimer:
                                                       *mut root::nsITimer,
                                                   aAnonymize: bool,
                                                   aClosure:
                                                       *mut ::std::os::raw::c_void,
                                                   aBuf:
                                                       *mut ::std::os::raw::c_char,
                                                   aLen: usize)>;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsITimerCallback {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsITimerCallback_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsITimerCallback() {
        assert_eq!(::std::mem::size_of::<nsITimerCallback>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsITimerCallback ) ));
        assert_eq! (::std::mem::align_of::<nsITimerCallback>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsITimerCallback ) ));
    }
    impl Clone for nsITimerCallback {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIWidget {
        _unused: [u8; 0],
    }
    #[repr(u32)]
    /**
 * sizemode is an adjunct to widget size
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsSizeMode {
        nsSizeMode_Normal = 0,
        nsSizeMode_Minimized = 1,
        nsSizeMode_Maximized = 2,
        nsSizeMode_Fullscreen = 3,
        nsSizeMode_Invalid = 4,
    }
    /**
 * templated hashtable class maps keys to interface pointers.
 * See nsBaseHashtable for complete declaration.
 * @param KeyClass a wrapper-class for the hashtable key, see nsHashKeys.h
 *   for a complete specification.
 * @param Interface the interface-type being wrapped
 * @see nsDataHashtable, nsClassHashtable
 */
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsInterfaceHashtable {
    }
    pub type nsInterfaceHashtable_KeyType = [u8; 0usize];
    pub type nsInterfaceHashtable_UserDataType<Interface> = *mut Interface;
    pub type nsInterfaceHashtable_base_type = u8;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsLanguageAtomService {
        pub mLangToGroup: [u64; 5usize],
        pub mLocaleLanguage: root::nsCOMPtr,
    }
    pub type nsLanguageAtomService_Encoding = root::mozilla::Encoding;
    pub type nsLanguageAtomService_NotNull<T> = root::mozilla::NotNull<T>;
    #[test]
    fn bindgen_test_layout_nsLanguageAtomService() {
        assert_eq!(::std::mem::size_of::<nsLanguageAtomService>() , 48usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsLanguageAtomService ) ));
        assert_eq! (::std::mem::align_of::<nsLanguageAtomService>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsLanguageAtomService )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsLanguageAtomService ) ) .
                    mLangToGroup as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsLanguageAtomService ) , "::" , stringify ! (
                    mLangToGroup ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsLanguageAtomService ) ) .
                    mLocaleLanguage as * const _ as usize } , 40usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsLanguageAtomService ) , "::" , stringify ! (
                    mLocaleLanguage ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsINamed {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsINamed_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsINamed() {
        assert_eq!(::std::mem::size_of::<nsINamed>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsINamed ) ));
        assert_eq! (::std::mem::align_of::<nsINamed>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsINamed ) ));
    }
    impl Clone for nsINamed {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIRunnable {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIRunnable_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIRunnable() {
        assert_eq!(::std::mem::size_of::<nsIRunnable>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIRunnable ) ));
        assert_eq! (::std::mem::align_of::<nsIRunnable>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsIRunnable ) ));
    }
    impl Clone for nsIRunnable {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsISerialEventTarget {
        pub _base: root::nsIEventTarget,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISerialEventTarget_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsISerialEventTarget() {
        assert_eq!(::std::mem::size_of::<nsISerialEventTarget>() , 16usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsISerialEventTarget ) ));
        assert_eq! (::std::mem::align_of::<nsISerialEventTarget>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsISerialEventTarget ) ));
    }
    impl Clone for nsISerialEventTarget {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsRevocableEventPtr<T> {
        pub mEvent: root::RefPtr<T>,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPIDOMWindowInner {
        pub _base: [u64; 30usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsPIDOMWindowInner_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsPIDOMWindowInner() {
        assert_eq!(::std::mem::size_of::<nsPIDOMWindowInner>() , 240usize ,
                   concat ! ( "Size of: " , stringify ! ( nsPIDOMWindowInner )
                   ));
        assert_eq! (::std::mem::align_of::<nsPIDOMWindowInner>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsPIDOMWindowInner ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsGlobalWindow {
        _unused: [u8; 0],
    }
    /**
 * The global object which keeps a script context for each supported script
 * language. This often used to store per-window global state.
 * This is a heavyweight interface implemented only by DOM globals, and
 * it might go away some time in the future.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIScriptGlobalObject {
        pub _base: root::nsIGlobalObject,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIScriptGlobalObject_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIScriptGlobalObject() {
        assert_eq!(::std::mem::size_of::<nsIScriptGlobalObject>() , 32usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIScriptGlobalObject ) ));
        assert_eq! (::std::mem::align_of::<nsIScriptGlobalObject>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIScriptGlobalObject )
                    ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISimpleEnumerator {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIControllers {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct mozIDOMWindow {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mozIDOMWindow_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_mozIDOMWindow() {
        assert_eq!(::std::mem::size_of::<mozIDOMWindow>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( mozIDOMWindow ) ));
        assert_eq! (::std::mem::align_of::<mozIDOMWindow>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( mozIDOMWindow ) ));
    }
    impl Clone for mozIDOMWindow {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct mozIDOMWindowProxy {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mozIDOMWindowProxy_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_mozIDOMWindowProxy() {
        assert_eq!(::std::mem::size_of::<mozIDOMWindowProxy>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( mozIDOMWindowProxy )
                   ));
        assert_eq! (::std::mem::align_of::<mozIDOMWindowProxy>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( mozIDOMWindowProxy ) ));
    }
    impl Clone for mozIDOMWindowProxy {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsICSSDeclaration {
        pub _base: root::nsIDOMCSSStyleDeclaration,
        pub _base_1: root::nsWrapperCache,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsICSSDeclaration_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsICSSDeclaration() {
        assert_eq!(::std::mem::size_of::<nsICSSDeclaration>() , 32usize ,
                   concat ! ( "Size of: " , stringify ! ( nsICSSDeclaration )
                   ));
        assert_eq! (::std::mem::align_of::<nsICSSDeclaration>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsICSSDeclaration ) ));
    }
    pub type SuspendTypes = u32;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum UIStateChangeType {
        UIStateChangeType_NoChange = 0,
        UIStateChangeType_Set = 1,
        UIStateChangeType_Clear = 2,
        UIStateChangeType_Invalid = 3,
    }
    #[repr(C)]
    pub struct nsPIDOMWindow__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsPIDOMWindow {
    }
    pub type nsPIDOMWindow_ServiceWorkerRegistrationTable = [u64; 5usize];
    pub mod xpc {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug)]
        pub struct ErrorBase {
            pub mErrorMsg: ::nsstring::nsStringRepr,
            pub mFileName: ::nsstring::nsStringRepr,
            pub mLineNumber: u32,
            pub mColumn: u32,
        }
        #[test]
        fn bindgen_test_layout_ErrorBase() {
            assert_eq!(::std::mem::size_of::<ErrorBase>() , 40usize , concat !
                       ( "Size of: " , stringify ! ( ErrorBase ) ));
            assert_eq! (::std::mem::align_of::<ErrorBase>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( ErrorBase ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ErrorBase ) ) . mErrorMsg as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( ErrorBase ) ,
                        "::" , stringify ! ( mErrorMsg ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ErrorBase ) ) . mFileName as *
                        const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! ( ErrorBase ) ,
                        "::" , stringify ! ( mFileName ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ErrorBase ) ) . mLineNumber as *
                        const _ as usize } , 32usize , concat ! (
                        "Alignment of field: " , stringify ! ( ErrorBase ) ,
                        "::" , stringify ! ( mLineNumber ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ErrorBase ) ) . mColumn as *
                        const _ as usize } , 36usize , concat ! (
                        "Alignment of field: " , stringify ! ( ErrorBase ) ,
                        "::" , stringify ! ( mColumn ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ErrorNote {
            pub _base: root::xpc::ErrorBase,
        }
        #[test]
        fn bindgen_test_layout_ErrorNote() {
            assert_eq!(::std::mem::size_of::<ErrorNote>() , 40usize , concat !
                       ( "Size of: " , stringify ! ( ErrorNote ) ));
            assert_eq! (::std::mem::align_of::<ErrorNote>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( ErrorNote ) ));
        }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCompatibility {
        eCompatibility_FullStandards = 1,
        eCompatibility_AlmostStandards = 2,
        eCompatibility_NavQuirks = 3,
    }
    /**
 * Information details about a characterdata change.  Basically, we
 * view all changes as replacements of a length of text at some offset
 * with some other text (of possibly some other length).
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct CharacterDataChangeInfo {
        /**
   * True if this character data change is just an append.
   */
        pub mAppend: bool,
        /**
   * The offset in the text where the change occurred.
   */
        pub mChangeStart: u32,
        /**
   * The offset such that mChangeEnd - mChangeStart is equal to the length of
   * the text we removed. If this was a pure insert or append, this is equal to
   * mChangeStart.
   */
        pub mChangeEnd: u32,
        /**
   * The length of the text that was inserted in place of the removed text.  If
   * this was a pure text removal, this is 0.
   */
        pub mReplaceLength: u32,
        /**
   * Used for splitText() and normalize(), otherwise null.
   */
        pub mDetails: *mut root::CharacterDataChangeInfo_Details,
    }
    /**
   * The net result is that mChangeStart characters at the beginning of the
   * text remained as they were.  The next mChangeEnd - mChangeStart characters
   * were removed, and mReplaceLength characters were inserted in their place.
   * The text that used to begin at mChangeEnd now begins at
   * mChangeStart + mReplaceLength.
   */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct CharacterDataChangeInfo_Details {
        pub mType: root::CharacterDataChangeInfo_Details__bindgen_ty_1,
        /**
     * For eMerge it's the text node that will be removed, for eSplit it's the
     * new text node.
     */
        pub mNextSibling: *mut root::nsIContent,
    }
    pub const CharacterDataChangeInfo_Details_eMerge:
              root::CharacterDataChangeInfo_Details__bindgen_ty_1 =
        CharacterDataChangeInfo_Details__bindgen_ty_1::eMerge;
    pub const CharacterDataChangeInfo_Details_eSplit:
              root::CharacterDataChangeInfo_Details__bindgen_ty_1 =
        CharacterDataChangeInfo_Details__bindgen_ty_1::eSplit;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum CharacterDataChangeInfo_Details__bindgen_ty_1 {
        eMerge = 0,
        eSplit = 1,
    }
    #[test]
    fn bindgen_test_layout_CharacterDataChangeInfo_Details() {
        assert_eq!(::std::mem::size_of::<CharacterDataChangeInfo_Details>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( CharacterDataChangeInfo_Details
                   ) ));
        assert_eq! (::std::mem::align_of::<CharacterDataChangeInfo_Details>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    CharacterDataChangeInfo_Details ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CharacterDataChangeInfo_Details ) ) .
                    mType as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CharacterDataChangeInfo_Details ) , "::" , stringify ! (
                    mType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CharacterDataChangeInfo_Details ) ) .
                    mNextSibling as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CharacterDataChangeInfo_Details ) , "::" , stringify ! (
                    mNextSibling ) ));
    }
    impl Clone for CharacterDataChangeInfo_Details {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_CharacterDataChangeInfo() {
        assert_eq!(::std::mem::size_of::<CharacterDataChangeInfo>() , 24usize
                   , concat ! (
                   "Size of: " , stringify ! ( CharacterDataChangeInfo ) ));
        assert_eq! (::std::mem::align_of::<CharacterDataChangeInfo>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( CharacterDataChangeInfo )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CharacterDataChangeInfo ) ) . mAppend
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CharacterDataChangeInfo ) , "::" , stringify ! ( mAppend )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CharacterDataChangeInfo ) ) .
                    mChangeStart as * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CharacterDataChangeInfo ) , "::" , stringify ! (
                    mChangeStart ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CharacterDataChangeInfo ) ) .
                    mChangeEnd as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CharacterDataChangeInfo ) , "::" , stringify ! (
                    mChangeEnd ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CharacterDataChangeInfo ) ) .
                    mReplaceLength as * const _ as usize } , 12usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    CharacterDataChangeInfo ) , "::" , stringify ! (
                    mReplaceLength ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CharacterDataChangeInfo ) ) .
                    mDetails as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CharacterDataChangeInfo ) , "::" , stringify ! ( mDetails
                    ) ));
    }
    impl Clone for CharacterDataChangeInfo {
        fn clone(&self) -> Self { *self }
    }
    pub type nsUpdateType = u32;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDocumentObserver {
        pub _base: root::nsIMutationObserver,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDocumentObserver_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDocumentObserver() {
        assert_eq!(::std::mem::size_of::<nsIDocumentObserver>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIDocumentObserver ) ));
        assert_eq! (::std::mem::align_of::<nsIDocumentObserver>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDocumentObserver ) ));
    }
    impl Clone for nsIDocumentObserver {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIRequestObserver {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIRequestObserver_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIRequestObserver() {
        assert_eq!(::std::mem::size_of::<nsIRequestObserver>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsIRequestObserver )
                   ));
        assert_eq! (::std::mem::align_of::<nsIRequestObserver>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIRequestObserver ) ));
    }
    impl Clone for nsIRequestObserver {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsScanner {
        _unused: [u8; 0],
    }
    /***************************************************************
  Notes: 
 ***************************************************************/
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsITokenizer {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsITokenizer_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsITokenizer() {
        assert_eq!(::std::mem::size_of::<nsITokenizer>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsITokenizer ) ));
        assert_eq! (::std::mem::align_of::<nsITokenizer>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsITokenizer ) ));
    }
    impl Clone for nsITokenizer {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsDTDMode {
        eDTDMode_unknown = 0,
        eDTDMode_quirks = 1,
        eDTDMode_almost_standards = 2,
        eDTDMode_full_standards = 3,
        eDTDMode_autodetect = 4,
        eDTDMode_fragment = 5,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIContentSink {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct CParserContext {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDTD {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDTD_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDTD() {
        assert_eq!(::std::mem::size_of::<nsIDTD>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIDTD ) ));
        assert_eq! (::std::mem::align_of::<nsIDTD>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIDTD ) ));
    }
    impl Clone for nsIDTD {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsParserBase {
        pub _base: root::nsISupports,
    }
    #[test]
    fn bindgen_test_layout_nsParserBase() {
        assert_eq!(::std::mem::size_of::<nsParserBase>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsParserBase ) ));
        assert_eq! (::std::mem::align_of::<nsParserBase>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsParserBase ) ));
    }
    impl Clone for nsParserBase {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum eParserCommands {
        eViewNormal = 0,
        eViewSource = 1,
        eViewFragment = 2,
        eViewErrors = 3,
    }
    /**
 * This GECKO-INTERNAL interface is on track to being REMOVED (or refactored
 * to the point of being near-unrecognizable).
 *
 * Please DO NOT #include this file in comm-central code, in your XULRunner
 * app or binary extensions.
 *
 * Please DO NOT #include this into new files even inside Gecko. It is more
 * likely than not that #including this header is the wrong thing to do.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIParser {
        pub _base: root::nsParserBase,
    }
    pub type nsIParser_Encoding = root::mozilla::Encoding;
    pub type nsIParser_NotNull<T> = root::mozilla::NotNull<T>;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIParser_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIParser() {
        assert_eq!(::std::mem::size_of::<nsIParser>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIParser ) ));
        assert_eq! (::std::mem::align_of::<nsIParser>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIParser ) ));
    }
    impl Clone for nsIParser {
        fn clone(&self) -> Self { *self }
    }
    /**
 * Hashtable key class to use with nsTHashtable/nsBaseHashtable
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsURIHashKey {
        pub _base: root::PLDHashEntryHdr,
        pub mKey: root::nsCOMPtr,
    }
    pub type nsURIHashKey_KeyType = *mut root::nsIURI;
    pub type nsURIHashKey_KeyTypePointer = *const root::nsIURI;
    pub const nsURIHashKey_ALLOW_MEMMOVE: root::nsURIHashKey__bindgen_ty_1 =
        nsURIHashKey__bindgen_ty_1::ALLOW_MEMMOVE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsURIHashKey__bindgen_ty_1 { ALLOW_MEMMOVE = 1, }
    #[test]
    fn bindgen_test_layout_nsURIHashKey() {
        assert_eq!(::std::mem::size_of::<nsURIHashKey>() , 16usize , concat !
                   ( "Size of: " , stringify ! ( nsURIHashKey ) ));
        assert_eq! (::std::mem::align_of::<nsURIHashKey>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsURIHashKey ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsURIHashKey ) ) . mKey as * const _
                    as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsURIHashKey ) ,
                    "::" , stringify ! ( mKey ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsContentList {
        _unused: [u8; 0],
    }
    /**
 * Data used to track the expiration state of an object. We promise that this
 * is 32 bits so that objects that includes this as a field can pad and align
 * efficiently.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsExpirationState {
        pub _bitfield_1: u32,
        pub __bindgen_align: [u32; 0usize],
    }
    pub const nsExpirationState_NOT_TRACKED:
              root::nsExpirationState__bindgen_ty_1 =
        nsExpirationState__bindgen_ty_1::NOT_TRACKED;
    pub const nsExpirationState_MAX_INDEX_IN_GENERATION:
              root::nsExpirationState__bindgen_ty_1 =
        nsExpirationState__bindgen_ty_1::MAX_INDEX_IN_GENERATION;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsExpirationState__bindgen_ty_1 {
        NOT_TRACKED = 15,
        MAX_INDEX_IN_GENERATION = 268435455,
    }
    #[test]
    fn bindgen_test_layout_nsExpirationState() {
        assert_eq!(::std::mem::size_of::<nsExpirationState>() , 4usize ,
                   concat ! ( "Size of: " , stringify ! ( nsExpirationState )
                   ));
        assert_eq! (::std::mem::align_of::<nsExpirationState>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsExpirationState ) ));
    }
    impl Clone for nsExpirationState {
        fn clone(&self) -> Self { *self }
    }
    impl nsExpirationState {
        #[inline]
        pub fn mGeneration(&self) -> u32 {
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            let mask = 15u64 as u32;
            let val = (unit_field_val & mask) >> 0usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mGeneration(&mut self, val: u32) {
            let mask = 15u64 as u32;
            let val = val as u32 as u32;
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 0usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u32>());
            }
        }
        #[inline]
        pub fn mIndexInGeneration(&self) -> u32 {
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            let mask = 4294967280u64 as u32;
            let val = (unit_field_val & mask) >> 4usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mIndexInGeneration(&mut self, val: u32) {
            let mask = 4294967280u64 as u32;
            let val = val as u32 as u32;
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 4usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u32>());
            }
        }
        #[inline]
        pub fn new_bitfield_1(mGeneration: u32, mIndexInGeneration: u32)
         -> u32 {
            ({
                 ({ 0 } |
                      ((mGeneration as u32 as u32) << 0usize) &
                          (15u64 as u32))
             } |
                 ((mIndexInGeneration as u32 as u32) << 4usize) &
                     (4294967280u64 as u32))
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct gfxUserFontSet {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDOMNavigationTiming {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsFrameLoader {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsHTMLCSSStyleSheet {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsHTMLStyleSheet {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIBFCacheEntry {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDocumentEncoder {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMNodeFilter {
        _unused: [u8; 0],
    }
    /**
 * An internal interface
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIHTMLCollection {
        pub _base: root::nsIDOMHTMLCollection,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIHTMLCollection_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIHTMLCollection() {
        assert_eq!(::std::mem::size_of::<nsIHTMLCollection>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsIHTMLCollection )
                   ));
        assert_eq! (::std::mem::align_of::<nsIHTMLCollection>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIHTMLCollection ) ));
    }
    impl Clone for nsIHTMLCollection {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIObjectLoadingContent {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIStructuredCloneContainer {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsRange {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsSMILAnimationController {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsSVGElement {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsTextNode {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsWindowSizes {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDOMCaretPosition {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsViewportInfo {
        _unused: [u8; 0],
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum HSTSPrimingState {
        eNO_HSTS_PRIMING = 0,
        eHSTS_PRIMING_ALLOW = 1,
        eHSTS_PRIMING_BLOCK = 2,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ProfilerBacktrace {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ProfilerMarkerPayload {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct ProfilerBacktraceDestructor {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_ProfilerBacktraceDestructor() {
        assert_eq!(::std::mem::size_of::<ProfilerBacktraceDestructor>() ,
                   1usize , concat ! (
                   "Size of: " , stringify ! ( ProfilerBacktraceDestructor )
                   ));
        assert_eq! (::std::mem::align_of::<ProfilerBacktraceDestructor>() ,
                    1usize , concat ! (
                    "Alignment of " , stringify ! (
                    ProfilerBacktraceDestructor ) ));
    }
    impl Clone for ProfilerBacktraceDestructor {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleDisplay {
        pub mBinding: root::BindingHolder,
        pub mDisplay: root::mozilla::StyleDisplay,
        pub mOriginalDisplay: root::mozilla::StyleDisplay,
        pub mContain: u8,
        pub mAppearance: u8,
        pub mPosition: u8,
        pub mFloat: root::mozilla::StyleFloat,
        pub mOriginalFloat: root::mozilla::StyleFloat,
        pub mBreakType: root::mozilla::StyleClear,
        pub mBreakInside: u8,
        pub mBreakBefore: bool,
        pub mBreakAfter: bool,
        pub mOverflowX: u8,
        pub mOverflowY: u8,
        pub mOverflowClipBox: u8,
        pub mResize: u8,
        pub mOrient: root::mozilla::StyleOrient,
        pub mIsolation: u8,
        pub mTopLayer: u8,
        pub mWillChangeBitField: u8,
        pub mWillChange: root::nsCOMArray,
        pub mTouchAction: u8,
        pub mScrollBehavior: u8,
        pub mScrollSnapTypeX: u8,
        pub mScrollSnapTypeY: u8,
        pub mScrollSnapPointsX: root::nsStyleCoord,
        pub mScrollSnapPointsY: root::nsStyleCoord,
        pub mScrollSnapDestination: root::mozilla::Position,
        pub mScrollSnapCoordinate: root::nsTArray<root::mozilla::Position>,
        pub mBackfaceVisibility: u8,
        pub mTransformStyle: u8,
        pub mTransformBox: root::nsStyleDisplay_StyleGeometryBox,
        pub mSpecifiedTransform: root::RefPtr<root::nsCSSValueSharedList>,
        pub mTransformOrigin: [root::nsStyleCoord; 3usize],
        pub mChildPerspective: root::nsStyleCoord,
        pub mPerspectiveOrigin: [root::nsStyleCoord; 2usize],
        pub mVerticalAlign: root::nsStyleCoord,
        pub mTransitions: root::nsStyleAutoArray<root::mozilla::StyleTransition>,
        pub mTransitionTimingFunctionCount: u32,
        pub mTransitionDurationCount: u32,
        pub mTransitionDelayCount: u32,
        pub mTransitionPropertyCount: u32,
        pub mAnimations: root::nsStyleAutoArray<root::mozilla::StyleAnimation>,
        pub mAnimationTimingFunctionCount: u32,
        pub mAnimationDurationCount: u32,
        pub mAnimationDelayCount: u32,
        pub mAnimationNameCount: u32,
        pub mAnimationDirectionCount: u32,
        pub mAnimationFillModeCount: u32,
        pub mAnimationPlayStateCount: u32,
        pub mAnimationIterationCountCount: u32,
        pub mShapeOutside: root::mozilla::StyleShapeSource,
    }
    pub use self::super::root::mozilla::StyleGeometryBox as
            nsStyleDisplay_StyleGeometryBox;
    pub const nsStyleDisplay_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleDisplay() {
        assert_eq!(::std::mem::size_of::<nsStyleDisplay>() , 416usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleDisplay ) ));
        assert_eq! (::std::mem::align_of::<nsStyleDisplay>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleDisplay ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mBinding as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mBinding ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mDisplay as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mDisplay ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mOriginalDisplay
                    as * const _ as usize } , 9usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mOriginalDisplay ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mContain as *
                    const _ as usize } , 10usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mContain ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mAppearance as *
                    const _ as usize } , 11usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAppearance ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mPosition as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mPosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mFloat as *
                    const _ as usize } , 13usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mFloat ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mOriginalFloat
                    as * const _ as usize } , 14usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mOriginalFloat ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mBreakType as *
                    const _ as usize } , 15usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mBreakType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mBreakInside as
                    * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mBreakInside ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mBreakBefore as
                    * const _ as usize } , 17usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mBreakBefore ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mBreakAfter as *
                    const _ as usize } , 18usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mBreakAfter ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mOverflowX as *
                    const _ as usize } , 19usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mOverflowX ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mOverflowY as *
                    const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mOverflowY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mOverflowClipBox
                    as * const _ as usize } , 21usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mOverflowClipBox ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mResize as *
                    const _ as usize } , 22usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mResize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mOrient as *
                    const _ as usize } , 23usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mOrient ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mIsolation as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mIsolation ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mTopLayer as *
                    const _ as usize } , 25usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTopLayer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mWillChangeBitField as * const _ as usize } , 26usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mWillChangeBitField ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mWillChange as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mWillChange ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mTouchAction as
                    * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTouchAction ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mScrollBehavior
                    as * const _ as usize } , 41usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mScrollBehavior ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mScrollSnapTypeX
                    as * const _ as usize } , 42usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mScrollSnapTypeX ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mScrollSnapTypeY
                    as * const _ as usize } , 43usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mScrollSnapTypeY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mScrollSnapPointsX as * const _ as usize } , 48usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mScrollSnapPointsX ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mScrollSnapPointsY as * const _ as usize } , 64usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mScrollSnapPointsY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mScrollSnapDestination as * const _ as usize } , 80usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mScrollSnapDestination ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mScrollSnapCoordinate as * const _ as usize } , 104usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mScrollSnapCoordinate ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mBackfaceVisibility as * const _ as usize } , 112usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mBackfaceVisibility ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mTransformStyle
                    as * const _ as usize } , 113usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransformStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mTransformBox as
                    * const _ as usize } , 114usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransformBox ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mSpecifiedTransform as * const _ as usize } , 120usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mSpecifiedTransform ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mTransformOrigin
                    as * const _ as usize } , 128usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransformOrigin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mChildPerspective as * const _ as usize } , 176usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mChildPerspective ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mPerspectiveOrigin as * const _ as usize } , 192usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mPerspectiveOrigin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mVerticalAlign
                    as * const _ as usize } , 224usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mVerticalAlign ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mTransitions as
                    * const _ as usize } , 240usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransitions ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mTransitionTimingFunctionCount as * const _ as usize } ,
                    288usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransitionTimingFunctionCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mTransitionDurationCount as * const _ as usize } ,
                    292usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransitionDurationCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mTransitionDelayCount as * const _ as usize } , 296usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransitionDelayCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mTransitionPropertyCount as * const _ as usize } ,
                    300usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransitionPropertyCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mAnimations as *
                    const _ as usize } , 304usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimations ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationTimingFunctionCount as * const _ as usize } ,
                    368usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationTimingFunctionCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationDurationCount as * const _ as usize } , 372usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationDurationCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationDelayCount as * const _ as usize } , 376usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationDelayCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationNameCount as * const _ as usize } , 380usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationNameCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationDirectionCount as * const _ as usize } ,
                    384usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationDirectionCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationFillModeCount as * const _ as usize } , 388usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationFillModeCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationPlayStateCount as * const _ as usize } ,
                    392usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationPlayStateCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationIterationCountCount as * const _ as usize } ,
                    396usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationIterationCountCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mShapeOutside as
                    * const _ as usize } , 400usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mShapeOutside ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsBidi {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIPrintSettings {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsITheme {
        _unused: [u8; 0],
    }
    /**
 * Interface used for handling clicks on links
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsILinkHandler {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsILinkHandler_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsILinkHandler() {
        assert_eq!(::std::mem::size_of::<nsILinkHandler>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( nsILinkHandler ) ));
        assert_eq! (::std::mem::align_of::<nsILinkHandler>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsILinkHandler ) ));
    }
    impl Clone for nsILinkHandler {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct gfxUserFontEntry {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct gfxTextPerfMetrics {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsTransitionManager {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsAnimationManager {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDeviceContext {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct gfxMissingFontRecorder {
        _unused: [u8; 0],
    }
    pub const kPresContext_DefaultVariableFont_ID: u8 = 0;
    pub const kPresContext_DefaultFixedFont_ID: u8 = 1;
    #[repr(C)]
    pub struct nsRootPresContext {
        pub _base: root::nsPresContext,
        pub mNotifyDidPaintTimers: [u64; 10usize],
        pub mApplyPluginGeometryTimer: root::nsCOMPtr,
        pub mRegisteredPlugins: [u64; 5usize],
        pub mWillPaintObservers: root::nsTArray<root::nsCOMPtr>,
        pub mWillPaintFallbackEvent: root::nsRevocableEventPtr<root::nsRootPresContext_RunWillPaintObservers>,
        pub mDOMGeneration: u32,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsRootPresContext_RunWillPaintObservers {
        pub _base: root::mozilla::Runnable,
        pub mPresContext: *mut root::nsRootPresContext,
    }
    #[test]
    fn bindgen_test_layout_nsRootPresContext_RunWillPaintObservers() {
        assert_eq!(::std::mem::size_of::<nsRootPresContext_RunWillPaintObservers>()
                   , 40usize , concat ! (
                   "Size of: " , stringify ! (
                   nsRootPresContext_RunWillPaintObservers ) ));
        assert_eq! (::std::mem::align_of::<nsRootPresContext_RunWillPaintObservers>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsRootPresContext_RunWillPaintObservers ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsRootPresContext_RunWillPaintObservers )
                    ) . mPresContext as * const _ as usize } , 32usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsRootPresContext_RunWillPaintObservers ) , "::" ,
                    stringify ! ( mPresContext ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsRootPresContext_NotifyDidPaintTimer {
        pub mTransactionId: u64,
        pub mTimer: root::nsCOMPtr,
    }
    #[test]
    fn bindgen_test_layout_nsRootPresContext_NotifyDidPaintTimer() {
        assert_eq!(::std::mem::size_of::<nsRootPresContext_NotifyDidPaintTimer>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsRootPresContext_NotifyDidPaintTimer ) ));
        assert_eq! (::std::mem::align_of::<nsRootPresContext_NotifyDidPaintTimer>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsRootPresContext_NotifyDidPaintTimer ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsRootPresContext_NotifyDidPaintTimer ) )
                    . mTransactionId as * const _ as usize } , 0usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsRootPresContext_NotifyDidPaintTimer ) , "::" , stringify
                    ! ( mTransactionId ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsRootPresContext_NotifyDidPaintTimer ) )
                    . mTimer as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsRootPresContext_NotifyDidPaintTimer ) , "::" , stringify
                    ! ( mTimer ) ));
    }
    #[test]
    fn bindgen_test_layout_nsRootPresContext() {
        assert_eq!(::std::mem::size_of::<nsRootPresContext>() , 1456usize ,
                   concat ! ( "Size of: " , stringify ! ( nsRootPresContext )
                   ));
        assert_eq! (::std::mem::align_of::<nsRootPresContext>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsRootPresContext ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRootPresContext ) ) .
                    mNotifyDidPaintTimers as * const _ as usize } , 1304usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsRootPresContext )
                    , "::" , stringify ! ( mNotifyDidPaintTimers ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRootPresContext ) ) .
                    mApplyPluginGeometryTimer as * const _ as usize } ,
                    1384usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsRootPresContext )
                    , "::" , stringify ! ( mApplyPluginGeometryTimer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRootPresContext ) ) .
                    mRegisteredPlugins as * const _ as usize } , 1392usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsRootPresContext )
                    , "::" , stringify ! ( mRegisteredPlugins ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRootPresContext ) ) .
                    mWillPaintObservers as * const _ as usize } , 1432usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsRootPresContext )
                    , "::" , stringify ! ( mWillPaintObservers ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRootPresContext ) ) .
                    mWillPaintFallbackEvent as * const _ as usize } ,
                    1440usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsRootPresContext )
                    , "::" , stringify ! ( mWillPaintFallbackEvent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRootPresContext ) ) .
                    mDOMGeneration as * const _ as usize } , 1448usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsRootPresContext )
                    , "::" , stringify ! ( mDOMGeneration ) ));
    }
    #[repr(i16)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSKeyword {
        eCSSKeyword_UNKNOWN = -1,
        eCSSKeyword__moz_activehyperlinktext = 0,
        eCSSKeyword__moz_all = 1,
        eCSSKeyword__moz_alt_content = 2,
        eCSSKeyword__moz_available = 3,
        eCSSKeyword__moz_box = 4,
        eCSSKeyword__moz_button = 5,
        eCSSKeyword__moz_buttondefault = 6,
        eCSSKeyword__moz_buttonhoverface = 7,
        eCSSKeyword__moz_buttonhovertext = 8,
        eCSSKeyword__moz_cellhighlight = 9,
        eCSSKeyword__moz_cellhighlighttext = 10,
        eCSSKeyword__moz_center = 11,
        eCSSKeyword__moz_combobox = 12,
        eCSSKeyword__moz_comboboxtext = 13,
        eCSSKeyword__moz_context_properties = 14,
        eCSSKeyword__moz_block_height = 15,
        eCSSKeyword__moz_deck = 16,
        eCSSKeyword__moz_default_background_color = 17,
        eCSSKeyword__moz_default_color = 18,
        eCSSKeyword__moz_desktop = 19,
        eCSSKeyword__moz_dialog = 20,
        eCSSKeyword__moz_dialogtext = 21,
        eCSSKeyword__moz_document = 22,
        eCSSKeyword__moz_dragtargetzone = 23,
        eCSSKeyword__moz_element = 24,
        eCSSKeyword__moz_eventreerow = 25,
        eCSSKeyword__moz_field = 26,
        eCSSKeyword__moz_fieldtext = 27,
        eCSSKeyword__moz_fit_content = 28,
        eCSSKeyword__moz_fixed = 29,
        eCSSKeyword__moz_grabbing = 30,
        eCSSKeyword__moz_grab = 31,
        eCSSKeyword__moz_grid_group = 32,
        eCSSKeyword__moz_grid_line = 33,
        eCSSKeyword__moz_grid = 34,
        eCSSKeyword__moz_groupbox = 35,
        eCSSKeyword__moz_gtk_info_bar = 36,
        eCSSKeyword__moz_gtk_info_bar_text = 37,
        eCSSKeyword__moz_hidden_unscrollable = 38,
        eCSSKeyword__moz_hyperlinktext = 39,
        eCSSKeyword__moz_html_cellhighlight = 40,
        eCSSKeyword__moz_html_cellhighlighttext = 41,
        eCSSKeyword__moz_image_rect = 42,
        eCSSKeyword__moz_info = 43,
        eCSSKeyword__moz_inline_box = 44,
        eCSSKeyword__moz_inline_grid = 45,
        eCSSKeyword__moz_inline_stack = 46,
        eCSSKeyword__moz_left = 47,
        eCSSKeyword__moz_list = 48,
        eCSSKeyword__moz_mac_buttonactivetext = 49,
        eCSSKeyword__moz_mac_chrome_active = 50,
        eCSSKeyword__moz_mac_chrome_inactive = 51,
        eCSSKeyword__moz_mac_defaultbuttontext = 52,
        eCSSKeyword__moz_mac_focusring = 53,
        eCSSKeyword__moz_mac_fullscreen_button = 54,
        eCSSKeyword__moz_mac_menuselect = 55,
        eCSSKeyword__moz_mac_menushadow = 56,
        eCSSKeyword__moz_mac_menutextdisable = 57,
        eCSSKeyword__moz_mac_menutextselect = 58,
        eCSSKeyword__moz_mac_disabledtoolbartext = 59,
        eCSSKeyword__moz_mac_secondaryhighlight = 60,
        eCSSKeyword__moz_max_content = 61,
        eCSSKeyword__moz_menuhover = 62,
        eCSSKeyword__moz_menuhovertext = 63,
        eCSSKeyword__moz_menubartext = 64,
        eCSSKeyword__moz_menubarhovertext = 65,
        eCSSKeyword__moz_middle_with_baseline = 66,
        eCSSKeyword__moz_min_content = 67,
        eCSSKeyword__moz_nativehyperlinktext = 68,
        eCSSKeyword__moz_none = 69,
        eCSSKeyword__moz_oddtreerow = 70,
        eCSSKeyword__moz_popup = 71,
        eCSSKeyword__moz_pre_space = 72,
        eCSSKeyword__moz_pull_down_menu = 73,
        eCSSKeyword__moz_right = 74,
        eCSSKeyword__moz_scrollbars_horizontal = 75,
        eCSSKeyword__moz_scrollbars_none = 76,
        eCSSKeyword__moz_scrollbars_vertical = 77,
        eCSSKeyword__moz_stack = 78,
        eCSSKeyword__moz_text = 79,
        eCSSKeyword__moz_use_system_font = 80,
        eCSSKeyword__moz_visitedhyperlinktext = 81,
        eCSSKeyword__moz_window = 82,
        eCSSKeyword__moz_workspace = 83,
        eCSSKeyword__moz_zoom_in = 84,
        eCSSKeyword__moz_zoom_out = 85,
        eCSSKeyword__webkit_box = 86,
        eCSSKeyword__webkit_flex = 87,
        eCSSKeyword__webkit_inline_box = 88,
        eCSSKeyword__webkit_inline_flex = 89,
        eCSSKeyword_absolute = 90,
        eCSSKeyword_active = 91,
        eCSSKeyword_activeborder = 92,
        eCSSKeyword_activecaption = 93,
        eCSSKeyword_add = 94,
        eCSSKeyword_additive = 95,
        eCSSKeyword_alias = 96,
        eCSSKeyword_all = 97,
        eCSSKeyword_all_petite_caps = 98,
        eCSSKeyword_all_scroll = 99,
        eCSSKeyword_all_small_caps = 100,
        eCSSKeyword_alpha = 101,
        eCSSKeyword_alternate = 102,
        eCSSKeyword_alternate_reverse = 103,
        eCSSKeyword_always = 104,
        eCSSKeyword_annotation = 105,
        eCSSKeyword_appworkspace = 106,
        eCSSKeyword_auto = 107,
        eCSSKeyword_auto_fill = 108,
        eCSSKeyword_auto_fit = 109,
        eCSSKeyword_auto_flow = 110,
        eCSSKeyword_avoid = 111,
        eCSSKeyword_background = 112,
        eCSSKeyword_backwards = 113,
        eCSSKeyword_balance = 114,
        eCSSKeyword_baseline = 115,
        eCSSKeyword_bidi_override = 116,
        eCSSKeyword_blink = 117,
        eCSSKeyword_block = 118,
        eCSSKeyword_block_axis = 119,
        eCSSKeyword_blur = 120,
        eCSSKeyword_bold = 121,
        eCSSKeyword_bold_fraktur = 122,
        eCSSKeyword_bold_italic = 123,
        eCSSKeyword_bold_sans_serif = 124,
        eCSSKeyword_bold_script = 125,
        eCSSKeyword_bolder = 126,
        eCSSKeyword_border_box = 127,
        eCSSKeyword_both = 128,
        eCSSKeyword_bottom = 129,
        eCSSKeyword_bottom_outside = 130,
        eCSSKeyword_break_all = 131,
        eCSSKeyword_break_word = 132,
        eCSSKeyword_brightness = 133,
        eCSSKeyword_browser = 134,
        eCSSKeyword_bullets = 135,
        eCSSKeyword_button = 136,
        eCSSKeyword_buttonface = 137,
        eCSSKeyword_buttonhighlight = 138,
        eCSSKeyword_buttonshadow = 139,
        eCSSKeyword_buttontext = 140,
        eCSSKeyword_capitalize = 141,
        eCSSKeyword_caption = 142,
        eCSSKeyword_captiontext = 143,
        eCSSKeyword_cell = 144,
        eCSSKeyword_center = 145,
        eCSSKeyword_ch = 146,
        eCSSKeyword_character_variant = 147,
        eCSSKeyword_circle = 148,
        eCSSKeyword_cjk_decimal = 149,
        eCSSKeyword_clip = 150,
        eCSSKeyword_clone = 151,
        eCSSKeyword_close_quote = 152,
        eCSSKeyword_closest_corner = 153,
        eCSSKeyword_closest_side = 154,
        eCSSKeyword_cm = 155,
        eCSSKeyword_col_resize = 156,
        eCSSKeyword_collapse = 157,
        eCSSKeyword_color = 158,
        eCSSKeyword_color_burn = 159,
        eCSSKeyword_color_dodge = 160,
        eCSSKeyword_common_ligatures = 161,
        eCSSKeyword_column = 162,
        eCSSKeyword_column_reverse = 163,
        eCSSKeyword_condensed = 164,
        eCSSKeyword_contain = 165,
        eCSSKeyword_content_box = 166,
        eCSSKeyword_contents = 167,
        eCSSKeyword_context_fill = 168,
        eCSSKeyword_context_fill_opacity = 169,
        eCSSKeyword_context_menu = 170,
        eCSSKeyword_context_stroke = 171,
        eCSSKeyword_context_stroke_opacity = 172,
        eCSSKeyword_context_value = 173,
        eCSSKeyword_continuous = 174,
        eCSSKeyword_contrast = 175,
        eCSSKeyword_copy = 176,
        eCSSKeyword_contextual = 177,
        eCSSKeyword_cover = 178,
        eCSSKeyword_crop = 179,
        eCSSKeyword_cross = 180,
        eCSSKeyword_crosshair = 181,
        eCSSKeyword_currentcolor = 182,
        eCSSKeyword_cursive = 183,
        eCSSKeyword_cyclic = 184,
        eCSSKeyword_darken = 185,
        eCSSKeyword_dashed = 186,
        eCSSKeyword_dense = 187,
        eCSSKeyword_decimal = 188,
        eCSSKeyword_default = 189,
        eCSSKeyword_deg = 190,
        eCSSKeyword_diagonal_fractions = 191,
        eCSSKeyword_dialog = 192,
        eCSSKeyword_difference = 193,
        eCSSKeyword_digits = 194,
        eCSSKeyword_disabled = 195,
        eCSSKeyword_disc = 196,
        eCSSKeyword_disclosure_closed = 197,
        eCSSKeyword_disclosure_open = 198,
        eCSSKeyword_discretionary_ligatures = 199,
        eCSSKeyword_distribute = 200,
        eCSSKeyword_dot = 201,
        eCSSKeyword_dotted = 202,
        eCSSKeyword_double = 203,
        eCSSKeyword_double_circle = 204,
        eCSSKeyword_double_struck = 205,
        eCSSKeyword_drag = 206,
        eCSSKeyword_drop_shadow = 207,
        eCSSKeyword_e_resize = 208,
        eCSSKeyword_ease = 209,
        eCSSKeyword_ease_in = 210,
        eCSSKeyword_ease_in_out = 211,
        eCSSKeyword_ease_out = 212,
        eCSSKeyword_economy = 213,
        eCSSKeyword_element = 214,
        eCSSKeyword_elements = 215,
        eCSSKeyword_ellipse = 216,
        eCSSKeyword_ellipsis = 217,
        eCSSKeyword_em = 218,
        eCSSKeyword_embed = 219,
        eCSSKeyword_enabled = 220,
        eCSSKeyword_end = 221,
        eCSSKeyword_ethiopic_numeric = 222,
        eCSSKeyword_ex = 223,
        eCSSKeyword_exact = 224,
        eCSSKeyword_exclude = 225,
        eCSSKeyword_exclusion = 226,
        eCSSKeyword_expanded = 227,
        eCSSKeyword_extends = 228,
        eCSSKeyword_extra_condensed = 229,
        eCSSKeyword_extra_expanded = 230,
        eCSSKeyword_ew_resize = 231,
        eCSSKeyword_fallback = 232,
        eCSSKeyword_fantasy = 233,
        eCSSKeyword_farthest_side = 234,
        eCSSKeyword_farthest_corner = 235,
        eCSSKeyword_fill = 236,
        eCSSKeyword_filled = 237,
        eCSSKeyword_fill_box = 238,
        eCSSKeyword_first = 239,
        eCSSKeyword_fit_content = 240,
        eCSSKeyword_fixed = 241,
        eCSSKeyword_flat = 242,
        eCSSKeyword_flex = 243,
        eCSSKeyword_flex_end = 244,
        eCSSKeyword_flex_start = 245,
        eCSSKeyword_flip = 246,
        eCSSKeyword_flow_root = 247,
        eCSSKeyword_forwards = 248,
        eCSSKeyword_fraktur = 249,
        eCSSKeyword_frames = 250,
        eCSSKeyword_from_image = 251,
        eCSSKeyword_full_width = 252,
        eCSSKeyword_fullscreen = 253,
        eCSSKeyword_grab = 254,
        eCSSKeyword_grabbing = 255,
        eCSSKeyword_grad = 256,
        eCSSKeyword_grayscale = 257,
        eCSSKeyword_graytext = 258,
        eCSSKeyword_grid = 259,
        eCSSKeyword_groove = 260,
        eCSSKeyword_hard_light = 261,
        eCSSKeyword_hebrew = 262,
        eCSSKeyword_help = 263,
        eCSSKeyword_hidden = 264,
        eCSSKeyword_hide = 265,
        eCSSKeyword_highlight = 266,
        eCSSKeyword_highlighttext = 267,
        eCSSKeyword_historical_forms = 268,
        eCSSKeyword_historical_ligatures = 269,
        eCSSKeyword_horizontal = 270,
        eCSSKeyword_horizontal_tb = 271,
        eCSSKeyword_hue = 272,
        eCSSKeyword_hue_rotate = 273,
        eCSSKeyword_hz = 274,
        eCSSKeyword_icon = 275,
        eCSSKeyword_ignore = 276,
        eCSSKeyword_ignore_horizontal = 277,
        eCSSKeyword_ignore_vertical = 278,
        eCSSKeyword_in = 279,
        eCSSKeyword_interlace = 280,
        eCSSKeyword_inactive = 281,
        eCSSKeyword_inactiveborder = 282,
        eCSSKeyword_inactivecaption = 283,
        eCSSKeyword_inactivecaptiontext = 284,
        eCSSKeyword_infinite = 285,
        eCSSKeyword_infobackground = 286,
        eCSSKeyword_infotext = 287,
        eCSSKeyword_inherit = 288,
        eCSSKeyword_initial = 289,
        eCSSKeyword_inline = 290,
        eCSSKeyword_inline_axis = 291,
        eCSSKeyword_inline_block = 292,
        eCSSKeyword_inline_end = 293,
        eCSSKeyword_inline_flex = 294,
        eCSSKeyword_inline_grid = 295,
        eCSSKeyword_inline_start = 296,
        eCSSKeyword_inline_table = 297,
        eCSSKeyword_inset = 298,
        eCSSKeyword_inside = 299,
        eCSSKeyword_inter_character = 300,
        eCSSKeyword_inter_word = 301,
        eCSSKeyword_interpolatematrix = 302,
        eCSSKeyword_accumulatematrix = 303,
        eCSSKeyword_intersect = 304,
        eCSSKeyword_isolate = 305,
        eCSSKeyword_isolate_override = 306,
        eCSSKeyword_invert = 307,
        eCSSKeyword_italic = 308,
        eCSSKeyword_japanese_formal = 309,
        eCSSKeyword_japanese_informal = 310,
        eCSSKeyword_jis78 = 311,
        eCSSKeyword_jis83 = 312,
        eCSSKeyword_jis90 = 313,
        eCSSKeyword_jis04 = 314,
        eCSSKeyword_justify = 315,
        eCSSKeyword_keep_all = 316,
        eCSSKeyword_khz = 317,
        eCSSKeyword_korean_hangul_formal = 318,
        eCSSKeyword_korean_hanja_formal = 319,
        eCSSKeyword_korean_hanja_informal = 320,
        eCSSKeyword_landscape = 321,
        eCSSKeyword_large = 322,
        eCSSKeyword_larger = 323,
        eCSSKeyword_last = 324,
        eCSSKeyword_last_baseline = 325,
        eCSSKeyword_layout = 326,
        eCSSKeyword_left = 327,
        eCSSKeyword_legacy = 328,
        eCSSKeyword_lighten = 329,
        eCSSKeyword_lighter = 330,
        eCSSKeyword_line_through = 331,
        eCSSKeyword_linear = 332,
        eCSSKeyword_lining_nums = 333,
        eCSSKeyword_list_item = 334,
        eCSSKeyword_local = 335,
        eCSSKeyword_logical = 336,
        eCSSKeyword_looped = 337,
        eCSSKeyword_lowercase = 338,
        eCSSKeyword_lr = 339,
        eCSSKeyword_lr_tb = 340,
        eCSSKeyword_ltr = 341,
        eCSSKeyword_luminance = 342,
        eCSSKeyword_luminosity = 343,
        eCSSKeyword_mandatory = 344,
        eCSSKeyword_manipulation = 345,
        eCSSKeyword_manual = 346,
        eCSSKeyword_margin_box = 347,
        eCSSKeyword_markers = 348,
        eCSSKeyword_match_parent = 349,
        eCSSKeyword_match_source = 350,
        eCSSKeyword_matrix = 351,
        eCSSKeyword_matrix3d = 352,
        eCSSKeyword_max_content = 353,
        eCSSKeyword_medium = 354,
        eCSSKeyword_menu = 355,
        eCSSKeyword_menutext = 356,
        eCSSKeyword_message_box = 357,
        eCSSKeyword_middle = 358,
        eCSSKeyword_min_content = 359,
        eCSSKeyword_minmax = 360,
        eCSSKeyword_mix = 361,
        eCSSKeyword_mixed = 362,
        eCSSKeyword_mm = 363,
        eCSSKeyword_monospace = 364,
        eCSSKeyword_move = 365,
        eCSSKeyword_ms = 366,
        eCSSKeyword_multiply = 367,
        eCSSKeyword_n_resize = 368,
        eCSSKeyword_narrower = 369,
        eCSSKeyword_ne_resize = 370,
        eCSSKeyword_nesw_resize = 371,
        eCSSKeyword_no_clip = 372,
        eCSSKeyword_no_close_quote = 373,
        eCSSKeyword_no_common_ligatures = 374,
        eCSSKeyword_no_contextual = 375,
        eCSSKeyword_no_discretionary_ligatures = 376,
        eCSSKeyword_no_drag = 377,
        eCSSKeyword_no_drop = 378,
        eCSSKeyword_no_historical_ligatures = 379,
        eCSSKeyword_no_open_quote = 380,
        eCSSKeyword_no_repeat = 381,
        eCSSKeyword_none = 382,
        eCSSKeyword_normal = 383,
        eCSSKeyword_not_allowed = 384,
        eCSSKeyword_nowrap = 385,
        eCSSKeyword_numeric = 386,
        eCSSKeyword_ns_resize = 387,
        eCSSKeyword_nw_resize = 388,
        eCSSKeyword_nwse_resize = 389,
        eCSSKeyword_oblique = 390,
        eCSSKeyword_oldstyle_nums = 391,
        eCSSKeyword_opacity = 392,
        eCSSKeyword_open = 393,
        eCSSKeyword_open_quote = 394,
        eCSSKeyword_optional = 395,
        eCSSKeyword_ordinal = 396,
        eCSSKeyword_ornaments = 397,
        eCSSKeyword_outset = 398,
        eCSSKeyword_outside = 399,
        eCSSKeyword_over = 400,
        eCSSKeyword_overlay = 401,
        eCSSKeyword_overline = 402,
        eCSSKeyword_paint = 403,
        eCSSKeyword_padding_box = 404,
        eCSSKeyword_painted = 405,
        eCSSKeyword_pan_x = 406,
        eCSSKeyword_pan_y = 407,
        eCSSKeyword_paused = 408,
        eCSSKeyword_pc = 409,
        eCSSKeyword_perspective = 410,
        eCSSKeyword_petite_caps = 411,
        eCSSKeyword_physical = 412,
        eCSSKeyword_plaintext = 413,
        eCSSKeyword_pointer = 414,
        eCSSKeyword_polygon = 415,
        eCSSKeyword_portrait = 416,
        eCSSKeyword_pre = 417,
        eCSSKeyword_pre_wrap = 418,
        eCSSKeyword_pre_line = 419,
        eCSSKeyword_preserve_3d = 420,
        eCSSKeyword_progress = 421,
        eCSSKeyword_progressive = 422,
        eCSSKeyword_proportional_nums = 423,
        eCSSKeyword_proportional_width = 424,
        eCSSKeyword_proximity = 425,
        eCSSKeyword_pt = 426,
        eCSSKeyword_px = 427,
        eCSSKeyword_rad = 428,
        eCSSKeyword_read_only = 429,
        eCSSKeyword_read_write = 430,
        eCSSKeyword_relative = 431,
        eCSSKeyword_repeat = 432,
        eCSSKeyword_repeat_x = 433,
        eCSSKeyword_repeat_y = 434,
        eCSSKeyword_reverse = 435,
        eCSSKeyword_ridge = 436,
        eCSSKeyword_right = 437,
        eCSSKeyword_rl = 438,
        eCSSKeyword_rl_tb = 439,
        eCSSKeyword_rotate = 440,
        eCSSKeyword_rotate3d = 441,
        eCSSKeyword_rotatex = 442,
        eCSSKeyword_rotatey = 443,
        eCSSKeyword_rotatez = 444,
        eCSSKeyword_round = 445,
        eCSSKeyword_row = 446,
        eCSSKeyword_row_resize = 447,
        eCSSKeyword_row_reverse = 448,
        eCSSKeyword_rtl = 449,
        eCSSKeyword_ruby = 450,
        eCSSKeyword_ruby_base = 451,
        eCSSKeyword_ruby_base_container = 452,
        eCSSKeyword_ruby_text = 453,
        eCSSKeyword_ruby_text_container = 454,
        eCSSKeyword_running = 455,
        eCSSKeyword_s = 456,
        eCSSKeyword_s_resize = 457,
        eCSSKeyword_safe = 458,
        eCSSKeyword_saturate = 459,
        eCSSKeyword_saturation = 460,
        eCSSKeyword_scale = 461,
        eCSSKeyword_scale_down = 462,
        eCSSKeyword_scale3d = 463,
        eCSSKeyword_scalex = 464,
        eCSSKeyword_scaley = 465,
        eCSSKeyword_scalez = 466,
        eCSSKeyword_screen = 467,
        eCSSKeyword_script = 468,
        eCSSKeyword_scroll = 469,
        eCSSKeyword_scrollbar = 470,
        eCSSKeyword_scrollbar_small = 471,
        eCSSKeyword_scrollbar_horizontal = 472,
        eCSSKeyword_scrollbar_vertical = 473,
        eCSSKeyword_se_resize = 474,
        eCSSKeyword_select_after = 475,
        eCSSKeyword_select_all = 476,
        eCSSKeyword_select_before = 477,
        eCSSKeyword_select_menu = 478,
        eCSSKeyword_select_same = 479,
        eCSSKeyword_self_end = 480,
        eCSSKeyword_self_start = 481,
        eCSSKeyword_semi_condensed = 482,
        eCSSKeyword_semi_expanded = 483,
        eCSSKeyword_separate = 484,
        eCSSKeyword_sepia = 485,
        eCSSKeyword_serif = 486,
        eCSSKeyword_sesame = 487,
        eCSSKeyword_show = 488,
        eCSSKeyword_sideways = 489,
        eCSSKeyword_sideways_lr = 490,
        eCSSKeyword_sideways_right = 491,
        eCSSKeyword_sideways_rl = 492,
        eCSSKeyword_simp_chinese_formal = 493,
        eCSSKeyword_simp_chinese_informal = 494,
        eCSSKeyword_simplified = 495,
        eCSSKeyword_skew = 496,
        eCSSKeyword_skewx = 497,
        eCSSKeyword_skewy = 498,
        eCSSKeyword_slashed_zero = 499,
        eCSSKeyword_slice = 500,
        eCSSKeyword_small = 501,
        eCSSKeyword_small_caps = 502,
        eCSSKeyword_small_caption = 503,
        eCSSKeyword_smaller = 504,
        eCSSKeyword_smooth = 505,
        eCSSKeyword_soft = 506,
        eCSSKeyword_soft_light = 507,
        eCSSKeyword_solid = 508,
        eCSSKeyword_space_around = 509,
        eCSSKeyword_space_between = 510,
        eCSSKeyword_space_evenly = 511,
        eCSSKeyword_span = 512,
        eCSSKeyword_spell_out = 513,
        eCSSKeyword_square = 514,
        eCSSKeyword_stacked_fractions = 515,
        eCSSKeyword_start = 516,
        eCSSKeyword_static = 517,
        eCSSKeyword_standalone = 518,
        eCSSKeyword_status_bar = 519,
        eCSSKeyword_step_end = 520,
        eCSSKeyword_step_start = 521,
        eCSSKeyword_sticky = 522,
        eCSSKeyword_stretch = 523,
        eCSSKeyword_stretch_to_fit = 524,
        eCSSKeyword_stretched = 525,
        eCSSKeyword_strict = 526,
        eCSSKeyword_stroke = 527,
        eCSSKeyword_stroke_box = 528,
        eCSSKeyword_style = 529,
        eCSSKeyword_styleset = 530,
        eCSSKeyword_stylistic = 531,
        eCSSKeyword_sub = 532,
        eCSSKeyword_subgrid = 533,
        eCSSKeyword_subtract = 534,
        eCSSKeyword_super = 535,
        eCSSKeyword_sw_resize = 536,
        eCSSKeyword_swash = 537,
        eCSSKeyword_swap = 538,
        eCSSKeyword_table = 539,
        eCSSKeyword_table_caption = 540,
        eCSSKeyword_table_cell = 541,
        eCSSKeyword_table_column = 542,
        eCSSKeyword_table_column_group = 543,
        eCSSKeyword_table_footer_group = 544,
        eCSSKeyword_table_header_group = 545,
        eCSSKeyword_table_row = 546,
        eCSSKeyword_table_row_group = 547,
        eCSSKeyword_tabular_nums = 548,
        eCSSKeyword_tailed = 549,
        eCSSKeyword_tb = 550,
        eCSSKeyword_tb_rl = 551,
        eCSSKeyword_text = 552,
        eCSSKeyword_text_bottom = 553,
        eCSSKeyword_text_top = 554,
        eCSSKeyword_thick = 555,
        eCSSKeyword_thin = 556,
        eCSSKeyword_threeddarkshadow = 557,
        eCSSKeyword_threedface = 558,
        eCSSKeyword_threedhighlight = 559,
        eCSSKeyword_threedlightshadow = 560,
        eCSSKeyword_threedshadow = 561,
        eCSSKeyword_titling_caps = 562,
        eCSSKeyword_toggle = 563,
        eCSSKeyword_top = 564,
        eCSSKeyword_top_outside = 565,
        eCSSKeyword_trad_chinese_formal = 566,
        eCSSKeyword_trad_chinese_informal = 567,
        eCSSKeyword_traditional = 568,
        eCSSKeyword_translate = 569,
        eCSSKeyword_translate3d = 570,
        eCSSKeyword_translatex = 571,
        eCSSKeyword_translatey = 572,
        eCSSKeyword_translatez = 573,
        eCSSKeyword_transparent = 574,
        eCSSKeyword_triangle = 575,
        eCSSKeyword_tri_state = 576,
        eCSSKeyword_ultra_condensed = 577,
        eCSSKeyword_ultra_expanded = 578,
        eCSSKeyword_under = 579,
        eCSSKeyword_underline = 580,
        eCSSKeyword_unicase = 581,
        eCSSKeyword_unsafe = 582,
        eCSSKeyword_unset = 583,
        eCSSKeyword_uppercase = 584,
        eCSSKeyword_upright = 585,
        eCSSKeyword_vertical = 586,
        eCSSKeyword_vertical_lr = 587,
        eCSSKeyword_vertical_rl = 588,
        eCSSKeyword_vertical_text = 589,
        eCSSKeyword_view_box = 590,
        eCSSKeyword_visible = 591,
        eCSSKeyword_visiblefill = 592,
        eCSSKeyword_visiblepainted = 593,
        eCSSKeyword_visiblestroke = 594,
        eCSSKeyword_w_resize = 595,
        eCSSKeyword_wait = 596,
        eCSSKeyword_wavy = 597,
        eCSSKeyword_weight = 598,
        eCSSKeyword_wider = 599,
        eCSSKeyword_window = 600,
        eCSSKeyword_windowframe = 601,
        eCSSKeyword_windowtext = 602,
        eCSSKeyword_words = 603,
        eCSSKeyword_wrap = 604,
        eCSSKeyword_wrap_reverse = 605,
        eCSSKeyword_write_only = 606,
        eCSSKeyword_x_large = 607,
        eCSSKeyword_x_small = 608,
        eCSSKeyword_xx_large = 609,
        eCSSKeyword_xx_small = 610,
        eCSSKeyword_zoom_in = 611,
        eCSSKeyword_zoom_out = 612,
        eCSSKeyword_radio = 613,
        eCSSKeyword_checkbox = 614,
        eCSSKeyword_button_bevel = 615,
        eCSSKeyword_toolbox = 616,
        eCSSKeyword_toolbar = 617,
        eCSSKeyword_toolbarbutton = 618,
        eCSSKeyword_toolbargripper = 619,
        eCSSKeyword_dualbutton = 620,
        eCSSKeyword_toolbarbutton_dropdown = 621,
        eCSSKeyword_button_arrow_up = 622,
        eCSSKeyword_button_arrow_down = 623,
        eCSSKeyword_button_arrow_next = 624,
        eCSSKeyword_button_arrow_previous = 625,
        eCSSKeyword_separator = 626,
        eCSSKeyword_splitter = 627,
        eCSSKeyword_statusbar = 628,
        eCSSKeyword_statusbarpanel = 629,
        eCSSKeyword_resizerpanel = 630,
        eCSSKeyword_resizer = 631,
        eCSSKeyword_listbox = 632,
        eCSSKeyword_listitem = 633,
        eCSSKeyword_numbers = 634,
        eCSSKeyword_number_input = 635,
        eCSSKeyword_treeview = 636,
        eCSSKeyword_treeitem = 637,
        eCSSKeyword_treetwisty = 638,
        eCSSKeyword_treetwistyopen = 639,
        eCSSKeyword_treeline = 640,
        eCSSKeyword_treeheader = 641,
        eCSSKeyword_treeheadercell = 642,
        eCSSKeyword_treeheadersortarrow = 643,
        eCSSKeyword_progressbar = 644,
        eCSSKeyword_progressbar_vertical = 645,
        eCSSKeyword_progresschunk = 646,
        eCSSKeyword_progresschunk_vertical = 647,
        eCSSKeyword_tab = 648,
        eCSSKeyword_tabpanels = 649,
        eCSSKeyword_tabpanel = 650,
        eCSSKeyword_tab_scroll_arrow_back = 651,
        eCSSKeyword_tab_scroll_arrow_forward = 652,
        eCSSKeyword_tooltip = 653,
        eCSSKeyword_spinner = 654,
        eCSSKeyword_spinner_upbutton = 655,
        eCSSKeyword_spinner_downbutton = 656,
        eCSSKeyword_spinner_textfield = 657,
        eCSSKeyword_scrollbarbutton_up = 658,
        eCSSKeyword_scrollbarbutton_down = 659,
        eCSSKeyword_scrollbarbutton_left = 660,
        eCSSKeyword_scrollbarbutton_right = 661,
        eCSSKeyword_scrollbartrack_horizontal = 662,
        eCSSKeyword_scrollbartrack_vertical = 663,
        eCSSKeyword_scrollbarthumb_horizontal = 664,
        eCSSKeyword_scrollbarthumb_vertical = 665,
        eCSSKeyword_sheet = 666,
        eCSSKeyword_textfield = 667,
        eCSSKeyword_textfield_multiline = 668,
        eCSSKeyword_caret = 669,
        eCSSKeyword_searchfield = 670,
        eCSSKeyword_menubar = 671,
        eCSSKeyword_menupopup = 672,
        eCSSKeyword_menuitem = 673,
        eCSSKeyword_checkmenuitem = 674,
        eCSSKeyword_radiomenuitem = 675,
        eCSSKeyword_menucheckbox = 676,
        eCSSKeyword_menuradio = 677,
        eCSSKeyword_menuseparator = 678,
        eCSSKeyword_menuarrow = 679,
        eCSSKeyword_menuimage = 680,
        eCSSKeyword_menuitemtext = 681,
        eCSSKeyword_menulist = 682,
        eCSSKeyword_menulist_button = 683,
        eCSSKeyword_menulist_text = 684,
        eCSSKeyword_menulist_textfield = 685,
        eCSSKeyword_meterbar = 686,
        eCSSKeyword_meterchunk = 687,
        eCSSKeyword_minimal_ui = 688,
        eCSSKeyword_range = 689,
        eCSSKeyword_range_thumb = 690,
        eCSSKeyword_sans_serif = 691,
        eCSSKeyword_sans_serif_bold_italic = 692,
        eCSSKeyword_sans_serif_italic = 693,
        eCSSKeyword_scale_horizontal = 694,
        eCSSKeyword_scale_vertical = 695,
        eCSSKeyword_scalethumb_horizontal = 696,
        eCSSKeyword_scalethumb_vertical = 697,
        eCSSKeyword_scalethumbstart = 698,
        eCSSKeyword_scalethumbend = 699,
        eCSSKeyword_scalethumbtick = 700,
        eCSSKeyword_groupbox = 701,
        eCSSKeyword_checkbox_container = 702,
        eCSSKeyword_radio_container = 703,
        eCSSKeyword_checkbox_label = 704,
        eCSSKeyword_radio_label = 705,
        eCSSKeyword_button_focus = 706,
        eCSSKeyword__moz_win_media_toolbox = 707,
        eCSSKeyword__moz_win_communications_toolbox = 708,
        eCSSKeyword__moz_win_browsertabbar_toolbox = 709,
        eCSSKeyword__moz_win_accentcolor = 710,
        eCSSKeyword__moz_win_accentcolortext = 711,
        eCSSKeyword__moz_win_mediatext = 712,
        eCSSKeyword__moz_win_communicationstext = 713,
        eCSSKeyword__moz_win_glass = 714,
        eCSSKeyword__moz_win_borderless_glass = 715,
        eCSSKeyword__moz_window_titlebar = 716,
        eCSSKeyword__moz_window_titlebar_maximized = 717,
        eCSSKeyword__moz_window_frame_left = 718,
        eCSSKeyword__moz_window_frame_right = 719,
        eCSSKeyword__moz_window_frame_bottom = 720,
        eCSSKeyword__moz_window_button_close = 721,
        eCSSKeyword__moz_window_button_minimize = 722,
        eCSSKeyword__moz_window_button_maximize = 723,
        eCSSKeyword__moz_window_button_restore = 724,
        eCSSKeyword__moz_window_button_box = 725,
        eCSSKeyword__moz_window_button_box_maximized = 726,
        eCSSKeyword__moz_mac_help_button = 727,
        eCSSKeyword__moz_win_exclude_glass = 728,
        eCSSKeyword__moz_mac_vibrancy_light = 729,
        eCSSKeyword__moz_mac_vibrancy_dark = 730,
        eCSSKeyword__moz_mac_disclosure_button_closed = 731,
        eCSSKeyword__moz_mac_disclosure_button_open = 732,
        eCSSKeyword__moz_mac_source_list = 733,
        eCSSKeyword__moz_mac_source_list_selection = 734,
        eCSSKeyword__moz_mac_active_source_list_selection = 735,
        eCSSKeyword_alphabetic = 736,
        eCSSKeyword_bevel = 737,
        eCSSKeyword_butt = 738,
        eCSSKeyword_central = 739,
        eCSSKeyword_crispedges = 740,
        eCSSKeyword_evenodd = 741,
        eCSSKeyword_geometricprecision = 742,
        eCSSKeyword_hanging = 743,
        eCSSKeyword_ideographic = 744,
        eCSSKeyword_linearrgb = 745,
        eCSSKeyword_mathematical = 746,
        eCSSKeyword_miter = 747,
        eCSSKeyword_no_change = 748,
        eCSSKeyword_non_scaling_stroke = 749,
        eCSSKeyword_nonzero = 750,
        eCSSKeyword_optimizelegibility = 751,
        eCSSKeyword_optimizequality = 752,
        eCSSKeyword_optimizespeed = 753,
        eCSSKeyword_reset_size = 754,
        eCSSKeyword_srgb = 755,
        eCSSKeyword_symbolic = 756,
        eCSSKeyword_symbols = 757,
        eCSSKeyword_text_after_edge = 758,
        eCSSKeyword_text_before_edge = 759,
        eCSSKeyword_use_script = 760,
        eCSSKeyword__moz_crisp_edges = 761,
        eCSSKeyword_space = 762,
        eCSSKeyword_COUNT = 763,
    }
    pub const nsCSSPropertyID_eCSSProperty_COUNT_no_shorthands:
              root::nsCSSPropertyID =
        nsCSSPropertyID::eCSSProperty_all;
    pub const nsCSSPropertyID_eCSSProperty_COUNT_DUMMY: root::nsCSSPropertyID
              =
        nsCSSPropertyID::eCSSProperty_z_index;
    pub const nsCSSPropertyID_eCSSProperty_COUNT: root::nsCSSPropertyID =
        nsCSSPropertyID::eCSSPropertyAlias_WordWrap;
    pub const nsCSSPropertyID_eCSSProperty_COUNT_DUMMY2: root::nsCSSPropertyID
              =
        nsCSSPropertyID::eCSSProperty_transition;
    pub const nsCSSPropertyID_eCSSProperty_COUNT_with_aliases:
              root::nsCSSPropertyID =
        nsCSSPropertyID::eCSSPropertyExtra_no_properties;
    pub const nsCSSPropertyID_eCSSProperty_COUNT_DUMMY3: root::nsCSSPropertyID
              =
        nsCSSPropertyID::eCSSPropertyAlias_WebkitMaskSize;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSPropertyID {
        eCSSProperty_UNKNOWN = -1,
        eCSSProperty_align_content = 0,
        eCSSProperty_align_items = 1,
        eCSSProperty_align_self = 2,
        eCSSProperty_animation_delay = 3,
        eCSSProperty_animation_direction = 4,
        eCSSProperty_animation_duration = 5,
        eCSSProperty_animation_fill_mode = 6,
        eCSSProperty_animation_iteration_count = 7,
        eCSSProperty_animation_name = 8,
        eCSSProperty_animation_play_state = 9,
        eCSSProperty_animation_timing_function = 10,
        eCSSProperty__moz_appearance = 11,
        eCSSProperty_backface_visibility = 12,
        eCSSProperty_background_attachment = 13,
        eCSSProperty_background_blend_mode = 14,
        eCSSProperty_background_clip = 15,
        eCSSProperty_background_color = 16,
        eCSSProperty_background_image = 17,
        eCSSProperty_background_origin = 18,
        eCSSProperty_background_position_x = 19,
        eCSSProperty_background_position_y = 20,
        eCSSProperty_background_repeat = 21,
        eCSSProperty_background_size = 22,
        eCSSProperty__moz_binding = 23,
        eCSSProperty_block_size = 24,
        eCSSProperty_border_block_end_color = 25,
        eCSSProperty_border_block_end_style = 26,
        eCSSProperty_border_block_end_width = 27,
        eCSSProperty_border_block_start_color = 28,
        eCSSProperty_border_block_start_style = 29,
        eCSSProperty_border_block_start_width = 30,
        eCSSProperty_border_bottom_color = 31,
        eCSSProperty__moz_border_bottom_colors = 32,
        eCSSProperty_border_bottom_left_radius = 33,
        eCSSProperty_border_bottom_right_radius = 34,
        eCSSProperty_border_bottom_style = 35,
        eCSSProperty_border_bottom_width = 36,
        eCSSProperty_border_collapse = 37,
        eCSSProperty_border_image_outset = 38,
        eCSSProperty_border_image_repeat = 39,
        eCSSProperty_border_image_slice = 40,
        eCSSProperty_border_image_source = 41,
        eCSSProperty_border_image_width = 42,
        eCSSProperty_border_inline_end_color = 43,
        eCSSProperty_border_inline_end_style = 44,
        eCSSProperty_border_inline_end_width = 45,
        eCSSProperty_border_inline_start_color = 46,
        eCSSProperty_border_inline_start_style = 47,
        eCSSProperty_border_inline_start_width = 48,
        eCSSProperty_border_left_color = 49,
        eCSSProperty__moz_border_left_colors = 50,
        eCSSProperty_border_left_style = 51,
        eCSSProperty_border_left_width = 52,
        eCSSProperty_border_right_color = 53,
        eCSSProperty__moz_border_right_colors = 54,
        eCSSProperty_border_right_style = 55,
        eCSSProperty_border_right_width = 56,
        eCSSProperty_border_spacing = 57,
        eCSSProperty_border_top_color = 58,
        eCSSProperty__moz_border_top_colors = 59,
        eCSSProperty_border_top_left_radius = 60,
        eCSSProperty_border_top_right_radius = 61,
        eCSSProperty_border_top_style = 62,
        eCSSProperty_border_top_width = 63,
        eCSSProperty_bottom = 64,
        eCSSProperty__moz_box_align = 65,
        eCSSProperty_box_decoration_break = 66,
        eCSSProperty__moz_box_direction = 67,
        eCSSProperty__moz_box_flex = 68,
        eCSSProperty__moz_box_ordinal_group = 69,
        eCSSProperty__moz_box_orient = 70,
        eCSSProperty__moz_box_pack = 71,
        eCSSProperty_box_shadow = 72,
        eCSSProperty_box_sizing = 73,
        eCSSProperty_caption_side = 74,
        eCSSProperty_caret_color = 75,
        eCSSProperty_clear = 76,
        eCSSProperty_clip = 77,
        eCSSProperty_clip_path = 78,
        eCSSProperty_clip_rule = 79,
        eCSSProperty_color = 80,
        eCSSProperty_color_adjust = 81,
        eCSSProperty_color_interpolation = 82,
        eCSSProperty_color_interpolation_filters = 83,
        eCSSProperty_column_count = 84,
        eCSSProperty_column_fill = 85,
        eCSSProperty_column_gap = 86,
        eCSSProperty_column_rule_color = 87,
        eCSSProperty_column_rule_style = 88,
        eCSSProperty_column_rule_width = 89,
        eCSSProperty_column_span = 90,
        eCSSProperty_column_width = 91,
        eCSSProperty_contain = 92,
        eCSSProperty_content = 93,
        eCSSProperty__moz_context_properties = 94,
        eCSSProperty__moz_control_character_visibility = 95,
        eCSSProperty_counter_increment = 96,
        eCSSProperty_counter_reset = 97,
        eCSSProperty_cursor = 98,
        eCSSProperty_direction = 99,
        eCSSProperty_display = 100,
        eCSSProperty_dominant_baseline = 101,
        eCSSProperty_empty_cells = 102,
        eCSSProperty_fill = 103,
        eCSSProperty_fill_opacity = 104,
        eCSSProperty_fill_rule = 105,
        eCSSProperty_filter = 106,
        eCSSProperty_flex_basis = 107,
        eCSSProperty_flex_direction = 108,
        eCSSProperty_flex_grow = 109,
        eCSSProperty_flex_shrink = 110,
        eCSSProperty_flex_wrap = 111,
        eCSSProperty_float_ = 112,
        eCSSProperty__moz_float_edge = 113,
        eCSSProperty_flood_color = 114,
        eCSSProperty_flood_opacity = 115,
        eCSSProperty_font_family = 116,
        eCSSProperty_font_feature_settings = 117,
        eCSSProperty_font_kerning = 118,
        eCSSProperty_font_language_override = 119,
        eCSSProperty_font_size = 120,
        eCSSProperty_font_size_adjust = 121,
        eCSSProperty_font_stretch = 122,
        eCSSProperty_font_style = 123,
        eCSSProperty_font_synthesis = 124,
        eCSSProperty_font_variant_alternates = 125,
        eCSSProperty_font_variant_caps = 126,
        eCSSProperty_font_variant_east_asian = 127,
        eCSSProperty_font_variant_ligatures = 128,
        eCSSProperty_font_variant_numeric = 129,
        eCSSProperty_font_variant_position = 130,
        eCSSProperty_font_variation_settings = 131,
        eCSSProperty_font_weight = 132,
        eCSSProperty__moz_force_broken_image_icon = 133,
        eCSSProperty_grid_auto_columns = 134,
        eCSSProperty_grid_auto_flow = 135,
        eCSSProperty_grid_auto_rows = 136,
        eCSSProperty_grid_column_end = 137,
        eCSSProperty_grid_column_gap = 138,
        eCSSProperty_grid_column_start = 139,
        eCSSProperty_grid_row_end = 140,
        eCSSProperty_grid_row_gap = 141,
        eCSSProperty_grid_row_start = 142,
        eCSSProperty_grid_template_areas = 143,
        eCSSProperty_grid_template_columns = 144,
        eCSSProperty_grid_template_rows = 145,
        eCSSProperty_height = 146,
        eCSSProperty_hyphens = 147,
        eCSSProperty_initial_letter = 148,
        eCSSProperty_image_orientation = 149,
        eCSSProperty__moz_image_region = 150,
        eCSSProperty_image_rendering = 151,
        eCSSProperty_ime_mode = 152,
        eCSSProperty_inline_size = 153,
        eCSSProperty_isolation = 154,
        eCSSProperty_justify_content = 155,
        eCSSProperty_justify_items = 156,
        eCSSProperty_justify_self = 157,
        eCSSProperty__x_lang = 158,
        eCSSProperty_left = 159,
        eCSSProperty_letter_spacing = 160,
        eCSSProperty_lighting_color = 161,
        eCSSProperty_line_height = 162,
        eCSSProperty_list_style_image = 163,
        eCSSProperty_list_style_position = 164,
        eCSSProperty_list_style_type = 165,
        eCSSProperty_margin_block_end = 166,
        eCSSProperty_margin_block_start = 167,
        eCSSProperty_margin_bottom = 168,
        eCSSProperty_margin_inline_end = 169,
        eCSSProperty_margin_inline_start = 170,
        eCSSProperty_margin_left = 171,
        eCSSProperty_margin_right = 172,
        eCSSProperty_margin_top = 173,
        eCSSProperty_marker_end = 174,
        eCSSProperty_marker_mid = 175,
        eCSSProperty_marker_start = 176,
        eCSSProperty_mask_clip = 177,
        eCSSProperty_mask_composite = 178,
        eCSSProperty_mask_image = 179,
        eCSSProperty_mask_mode = 180,
        eCSSProperty_mask_origin = 181,
        eCSSProperty_mask_position_x = 182,
        eCSSProperty_mask_position_y = 183,
        eCSSProperty_mask_repeat = 184,
        eCSSProperty_mask_size = 185,
        eCSSProperty_mask_type = 186,
        eCSSProperty__moz_math_display = 187,
        eCSSProperty__moz_math_variant = 188,
        eCSSProperty_max_block_size = 189,
        eCSSProperty_max_height = 190,
        eCSSProperty_max_inline_size = 191,
        eCSSProperty_max_width = 192,
        eCSSProperty_min_block_size = 193,
        eCSSProperty__moz_min_font_size_ratio = 194,
        eCSSProperty_min_height = 195,
        eCSSProperty_min_inline_size = 196,
        eCSSProperty_min_width = 197,
        eCSSProperty_mix_blend_mode = 198,
        eCSSProperty_object_fit = 199,
        eCSSProperty_object_position = 200,
        eCSSProperty_offset_block_end = 201,
        eCSSProperty_offset_block_start = 202,
        eCSSProperty_offset_inline_end = 203,
        eCSSProperty_offset_inline_start = 204,
        eCSSProperty_opacity = 205,
        eCSSProperty_order = 206,
        eCSSProperty__moz_orient = 207,
        eCSSProperty__moz_osx_font_smoothing = 208,
        eCSSProperty_outline_color = 209,
        eCSSProperty_outline_offset = 210,
        eCSSProperty__moz_outline_radius_bottomleft = 211,
        eCSSProperty__moz_outline_radius_bottomright = 212,
        eCSSProperty__moz_outline_radius_topleft = 213,
        eCSSProperty__moz_outline_radius_topright = 214,
        eCSSProperty_outline_style = 215,
        eCSSProperty_outline_width = 216,
        eCSSProperty_overflow_clip_box = 217,
        eCSSProperty_overflow_x = 218,
        eCSSProperty_overflow_y = 219,
        eCSSProperty_padding_block_end = 220,
        eCSSProperty_padding_block_start = 221,
        eCSSProperty_padding_bottom = 222,
        eCSSProperty_padding_inline_end = 223,
        eCSSProperty_padding_inline_start = 224,
        eCSSProperty_padding_left = 225,
        eCSSProperty_padding_right = 226,
        eCSSProperty_padding_top = 227,
        eCSSProperty_page_break_after = 228,
        eCSSProperty_page_break_before = 229,
        eCSSProperty_page_break_inside = 230,
        eCSSProperty_paint_order = 231,
        eCSSProperty_perspective = 232,
        eCSSProperty_perspective_origin = 233,
        eCSSProperty_pointer_events = 234,
        eCSSProperty_position = 235,
        eCSSProperty_quotes = 236,
        eCSSProperty_resize = 237,
        eCSSProperty_right = 238,
        eCSSProperty_ruby_align = 239,
        eCSSProperty_ruby_position = 240,
        eCSSProperty__moz_script_level = 241,
        eCSSProperty__moz_script_min_size = 242,
        eCSSProperty__moz_script_size_multiplier = 243,
        eCSSProperty_scroll_behavior = 244,
        eCSSProperty_scroll_snap_coordinate = 245,
        eCSSProperty_scroll_snap_destination = 246,
        eCSSProperty_scroll_snap_points_x = 247,
        eCSSProperty_scroll_snap_points_y = 248,
        eCSSProperty_scroll_snap_type_x = 249,
        eCSSProperty_scroll_snap_type_y = 250,
        eCSSProperty_shape_outside = 251,
        eCSSProperty_shape_rendering = 252,
        eCSSProperty__x_span = 253,
        eCSSProperty__moz_stack_sizing = 254,
        eCSSProperty_stop_color = 255,
        eCSSProperty_stop_opacity = 256,
        eCSSProperty_stroke = 257,
        eCSSProperty_stroke_dasharray = 258,
        eCSSProperty_stroke_dashoffset = 259,
        eCSSProperty_stroke_linecap = 260,
        eCSSProperty_stroke_linejoin = 261,
        eCSSProperty_stroke_miterlimit = 262,
        eCSSProperty_stroke_opacity = 263,
        eCSSProperty_stroke_width = 264,
        eCSSProperty__x_system_font = 265,
        eCSSProperty__moz_tab_size = 266,
        eCSSProperty_table_layout = 267,
        eCSSProperty_text_align = 268,
        eCSSProperty_text_align_last = 269,
        eCSSProperty_text_anchor = 270,
        eCSSProperty_text_combine_upright = 271,
        eCSSProperty_text_decoration_color = 272,
        eCSSProperty_text_decoration_line = 273,
        eCSSProperty_text_decoration_style = 274,
        eCSSProperty_text_emphasis_color = 275,
        eCSSProperty_text_emphasis_position = 276,
        eCSSProperty_text_emphasis_style = 277,
        eCSSProperty__webkit_text_fill_color = 278,
        eCSSProperty_text_indent = 279,
        eCSSProperty_text_justify = 280,
        eCSSProperty_text_orientation = 281,
        eCSSProperty_text_overflow = 282,
        eCSSProperty_text_rendering = 283,
        eCSSProperty_text_shadow = 284,
        eCSSProperty__moz_text_size_adjust = 285,
        eCSSProperty__webkit_text_stroke_color = 286,
        eCSSProperty__webkit_text_stroke_width = 287,
        eCSSProperty_text_transform = 288,
        eCSSProperty__x_text_zoom = 289,
        eCSSProperty_top = 290,
        eCSSProperty__moz_top_layer = 291,
        eCSSProperty_touch_action = 292,
        eCSSProperty_transform = 293,
        eCSSProperty_transform_box = 294,
        eCSSProperty_transform_origin = 295,
        eCSSProperty_transform_style = 296,
        eCSSProperty_transition_delay = 297,
        eCSSProperty_transition_duration = 298,
        eCSSProperty_transition_property = 299,
        eCSSProperty_transition_timing_function = 300,
        eCSSProperty_unicode_bidi = 301,
        eCSSProperty__moz_user_focus = 302,
        eCSSProperty__moz_user_input = 303,
        eCSSProperty__moz_user_modify = 304,
        eCSSProperty__moz_user_select = 305,
        eCSSProperty_vector_effect = 306,
        eCSSProperty_vertical_align = 307,
        eCSSProperty_visibility = 308,
        eCSSProperty_white_space = 309,
        eCSSProperty_width = 310,
        eCSSProperty_will_change = 311,
        eCSSProperty__moz_window_dragging = 312,
        eCSSProperty__moz_window_shadow = 313,
        eCSSProperty__moz_window_opacity = 314,
        eCSSProperty__moz_window_transform = 315,
        eCSSProperty__moz_window_transform_origin = 316,
        eCSSProperty_word_break = 317,
        eCSSProperty_word_spacing = 318,
        eCSSProperty_overflow_wrap = 319,
        eCSSProperty_writing_mode = 320,
        eCSSProperty_z_index = 321,
        eCSSProperty_all = 322,
        eCSSProperty_animation = 323,
        eCSSProperty_background = 324,
        eCSSProperty_background_position = 325,
        eCSSProperty_border = 326,
        eCSSProperty_border_block_end = 327,
        eCSSProperty_border_block_start = 328,
        eCSSProperty_border_bottom = 329,
        eCSSProperty_border_color = 330,
        eCSSProperty_border_image = 331,
        eCSSProperty_border_inline_end = 332,
        eCSSProperty_border_inline_start = 333,
        eCSSProperty_border_left = 334,
        eCSSProperty_border_radius = 335,
        eCSSProperty_border_right = 336,
        eCSSProperty_border_style = 337,
        eCSSProperty_border_top = 338,
        eCSSProperty_border_width = 339,
        eCSSProperty_column_rule = 340,
        eCSSProperty_columns = 341,
        eCSSProperty_flex = 342,
        eCSSProperty_flex_flow = 343,
        eCSSProperty_font = 344,
        eCSSProperty_font_variant = 345,
        eCSSProperty_grid = 346,
        eCSSProperty_grid_area = 347,
        eCSSProperty_grid_column = 348,
        eCSSProperty_grid_gap = 349,
        eCSSProperty_grid_row = 350,
        eCSSProperty_grid_template = 351,
        eCSSProperty_list_style = 352,
        eCSSProperty_margin = 353,
        eCSSProperty_marker = 354,
        eCSSProperty_mask = 355,
        eCSSProperty_mask_position = 356,
        eCSSProperty_outline = 357,
        eCSSProperty__moz_outline_radius = 358,
        eCSSProperty_overflow = 359,
        eCSSProperty_padding = 360,
        eCSSProperty_place_content = 361,
        eCSSProperty_place_items = 362,
        eCSSProperty_place_self = 363,
        eCSSProperty_scroll_snap_type = 364,
        eCSSProperty_text_decoration = 365,
        eCSSProperty_text_emphasis = 366,
        eCSSProperty__webkit_text_stroke = 367,
        eCSSProperty__moz_transform = 368,
        eCSSProperty_transition = 369,
        eCSSPropertyAlias_WordWrap = 370,
        eCSSPropertyAlias_MozTransformOrigin = 371,
        eCSSPropertyAlias_MozPerspectiveOrigin = 372,
        eCSSPropertyAlias_MozPerspective = 373,
        eCSSPropertyAlias_MozTransformStyle = 374,
        eCSSPropertyAlias_MozBackfaceVisibility = 375,
        eCSSPropertyAlias_MozBorderImage = 376,
        eCSSPropertyAlias_MozTransition = 377,
        eCSSPropertyAlias_MozTransitionDelay = 378,
        eCSSPropertyAlias_MozTransitionDuration = 379,
        eCSSPropertyAlias_MozTransitionProperty = 380,
        eCSSPropertyAlias_MozTransitionTimingFunction = 381,
        eCSSPropertyAlias_MozAnimation = 382,
        eCSSPropertyAlias_MozAnimationDelay = 383,
        eCSSPropertyAlias_MozAnimationDirection = 384,
        eCSSPropertyAlias_MozAnimationDuration = 385,
        eCSSPropertyAlias_MozAnimationFillMode = 386,
        eCSSPropertyAlias_MozAnimationIterationCount = 387,
        eCSSPropertyAlias_MozAnimationName = 388,
        eCSSPropertyAlias_MozAnimationPlayState = 389,
        eCSSPropertyAlias_MozAnimationTimingFunction = 390,
        eCSSPropertyAlias_MozBoxSizing = 391,
        eCSSPropertyAlias_MozFontFeatureSettings = 392,
        eCSSPropertyAlias_MozFontLanguageOverride = 393,
        eCSSPropertyAlias_MozPaddingEnd = 394,
        eCSSPropertyAlias_MozPaddingStart = 395,
        eCSSPropertyAlias_MozMarginEnd = 396,
        eCSSPropertyAlias_MozMarginStart = 397,
        eCSSPropertyAlias_MozBorderEnd = 398,
        eCSSPropertyAlias_MozBorderEndColor = 399,
        eCSSPropertyAlias_MozBorderEndStyle = 400,
        eCSSPropertyAlias_MozBorderEndWidth = 401,
        eCSSPropertyAlias_MozBorderStart = 402,
        eCSSPropertyAlias_MozBorderStartColor = 403,
        eCSSPropertyAlias_MozBorderStartStyle = 404,
        eCSSPropertyAlias_MozBorderStartWidth = 405,
        eCSSPropertyAlias_MozHyphens = 406,
        eCSSPropertyAlias_MozColumnCount = 407,
        eCSSPropertyAlias_MozColumnFill = 408,
        eCSSPropertyAlias_MozColumnGap = 409,
        eCSSPropertyAlias_MozColumnRule = 410,
        eCSSPropertyAlias_MozColumnRuleColor = 411,
        eCSSPropertyAlias_MozColumnRuleStyle = 412,
        eCSSPropertyAlias_MozColumnRuleWidth = 413,
        eCSSPropertyAlias_MozColumnWidth = 414,
        eCSSPropertyAlias_MozColumns = 415,
        eCSSPropertyAlias_WebkitAnimation = 416,
        eCSSPropertyAlias_WebkitAnimationDelay = 417,
        eCSSPropertyAlias_WebkitAnimationDirection = 418,
        eCSSPropertyAlias_WebkitAnimationDuration = 419,
        eCSSPropertyAlias_WebkitAnimationFillMode = 420,
        eCSSPropertyAlias_WebkitAnimationIterationCount = 421,
        eCSSPropertyAlias_WebkitAnimationName = 422,
        eCSSPropertyAlias_WebkitAnimationPlayState = 423,
        eCSSPropertyAlias_WebkitAnimationTimingFunction = 424,
        eCSSPropertyAlias_WebkitFilter = 425,
        eCSSPropertyAlias_WebkitTextSizeAdjust = 426,
        eCSSPropertyAlias_WebkitTransform = 427,
        eCSSPropertyAlias_WebkitTransformOrigin = 428,
        eCSSPropertyAlias_WebkitTransformStyle = 429,
        eCSSPropertyAlias_WebkitBackfaceVisibility = 430,
        eCSSPropertyAlias_WebkitPerspective = 431,
        eCSSPropertyAlias_WebkitPerspectiveOrigin = 432,
        eCSSPropertyAlias_WebkitTransition = 433,
        eCSSPropertyAlias_WebkitTransitionDelay = 434,
        eCSSPropertyAlias_WebkitTransitionDuration = 435,
        eCSSPropertyAlias_WebkitTransitionProperty = 436,
        eCSSPropertyAlias_WebkitTransitionTimingFunction = 437,
        eCSSPropertyAlias_WebkitBorderRadius = 438,
        eCSSPropertyAlias_WebkitBorderTopLeftRadius = 439,
        eCSSPropertyAlias_WebkitBorderTopRightRadius = 440,
        eCSSPropertyAlias_WebkitBorderBottomLeftRadius = 441,
        eCSSPropertyAlias_WebkitBorderBottomRightRadius = 442,
        eCSSPropertyAlias_WebkitBackgroundClip = 443,
        eCSSPropertyAlias_WebkitBackgroundOrigin = 444,
        eCSSPropertyAlias_WebkitBackgroundSize = 445,
        eCSSPropertyAlias_WebkitBorderImage = 446,
        eCSSPropertyAlias_WebkitBoxShadow = 447,
        eCSSPropertyAlias_WebkitBoxSizing = 448,
        eCSSPropertyAlias_WebkitBoxFlex = 449,
        eCSSPropertyAlias_WebkitBoxOrdinalGroup = 450,
        eCSSPropertyAlias_WebkitBoxOrient = 451,
        eCSSPropertyAlias_WebkitBoxDirection = 452,
        eCSSPropertyAlias_WebkitBoxAlign = 453,
        eCSSPropertyAlias_WebkitBoxPack = 454,
        eCSSPropertyAlias_WebkitFlexDirection = 455,
        eCSSPropertyAlias_WebkitFlexWrap = 456,
        eCSSPropertyAlias_WebkitFlexFlow = 457,
        eCSSPropertyAlias_WebkitOrder = 458,
        eCSSPropertyAlias_WebkitFlex = 459,
        eCSSPropertyAlias_WebkitFlexGrow = 460,
        eCSSPropertyAlias_WebkitFlexShrink = 461,
        eCSSPropertyAlias_WebkitFlexBasis = 462,
        eCSSPropertyAlias_WebkitJustifyContent = 463,
        eCSSPropertyAlias_WebkitAlignItems = 464,
        eCSSPropertyAlias_WebkitAlignSelf = 465,
        eCSSPropertyAlias_WebkitAlignContent = 466,
        eCSSPropertyAlias_WebkitUserSelect = 467,
        eCSSPropertyAlias_WebkitMask = 468,
        eCSSPropertyAlias_WebkitMaskClip = 469,
        eCSSPropertyAlias_WebkitMaskComposite = 470,
        eCSSPropertyAlias_WebkitMaskImage = 471,
        eCSSPropertyAlias_WebkitMaskOrigin = 472,
        eCSSPropertyAlias_WebkitMaskPosition = 473,
        eCSSPropertyAlias_WebkitMaskPositionX = 474,
        eCSSPropertyAlias_WebkitMaskPositionY = 475,
        eCSSPropertyAlias_WebkitMaskRepeat = 476,
        eCSSPropertyAlias_WebkitMaskSize = 477,
        eCSSPropertyExtra_no_properties = 478,
        eCSSPropertyExtra_all_properties = 479,
        eCSSPropertyExtra_x_none_value = 480,
        eCSSPropertyExtra_x_auto_value = 481,
        eCSSPropertyExtra_variable = 482,
        eCSSProperty_DOM = 483,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSFontDesc {
        eCSSFontDesc_UNKNOWN = -1,
        eCSSFontDesc_Family = 0,
        eCSSFontDesc_Style = 1,
        eCSSFontDesc_Weight = 2,
        eCSSFontDesc_Stretch = 3,
        eCSSFontDesc_Src = 4,
        eCSSFontDesc_UnicodeRange = 5,
        eCSSFontDesc_FontFeatureSettings = 6,
        eCSSFontDesc_FontLanguageOverride = 7,
        eCSSFontDesc_Display = 8,
        eCSSFontDesc_COUNT = 9,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSCounterDesc {
        eCSSCounterDesc_UNKNOWN = -1,
        eCSSCounterDesc_System = 0,
        eCSSCounterDesc_Symbols = 1,
        eCSSCounterDesc_AdditiveSymbols = 2,
        eCSSCounterDesc_Negative = 3,
        eCSSCounterDesc_Prefix = 4,
        eCSSCounterDesc_Suffix = 5,
        eCSSCounterDesc_Range = 6,
        eCSSCounterDesc_Pad = 7,
        eCSSCounterDesc_Fallback = 8,
        eCSSCounterDesc_SpeakAs = 9,
        eCSSCounterDesc_COUNT = 10,
    }
    pub const nsStyleStructID_nsStyleStructID_DUMMY1: root::nsStyleStructID =
        nsStyleStructID::nsStyleStructID_None;
    pub const nsStyleStructID_eStyleStruct_Font: root::nsStyleStructID =
        nsStyleStructID::nsStyleStructID_Inherited_Start;
    pub const nsStyleStructID_nsStyleStructID_DUMMY2: root::nsStyleStructID =
        nsStyleStructID::eStyleStruct_Variables;
    pub const nsStyleStructID_eStyleStruct_Background: root::nsStyleStructID =
        nsStyleStructID::nsStyleStructID_Reset_Start;
    pub const nsStyleStructID_nsStyleStructID_Inherited_Count:
              root::nsStyleStructID =
        nsStyleStructID::nsStyleStructID_Reset_Start;
    pub const nsStyleStructID_nsStyleStructID_Reset_Count:
              root::nsStyleStructID =
        nsStyleStructID::eStyleStruct_Table;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleStructID {
        nsStyleStructID_None = -1,
        nsStyleStructID_Inherited_Start = 0,
        eStyleStruct_Color = 1,
        eStyleStruct_List = 2,
        eStyleStruct_Text = 3,
        eStyleStruct_Visibility = 4,
        eStyleStruct_UserInterface = 5,
        eStyleStruct_TableBorder = 6,
        eStyleStruct_SVG = 7,
        eStyleStruct_Variables = 8,
        nsStyleStructID_Reset_Start = 9,
        eStyleStruct_Position = 10,
        eStyleStruct_TextReset = 11,
        eStyleStruct_Display = 12,
        eStyleStruct_Content = 13,
        eStyleStruct_UIReset = 14,
        eStyleStruct_Table = 15,
        eStyleStruct_Margin = 16,
        eStyleStruct_Padding = 17,
        eStyleStruct_Border = 18,
        eStyleStruct_Outline = 19,
        eStyleStruct_XUL = 20,
        eStyleStruct_SVGReset = 21,
        eStyleStruct_Column = 22,
        eStyleStruct_Effects = 23,
        nsStyleStructID_Length = 24,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIProperties {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIProperties_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIProperties() {
        assert_eq!(::std::mem::size_of::<nsIProperties>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( nsIProperties ) ));
        assert_eq! (::std::mem::align_of::<nsIProperties>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsIProperties ) ));
    }
    impl Clone for nsIProperties {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    /**
 * Types of animatable values.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleAnimType {
        eStyleAnimType_Custom = 0,
        eStyleAnimType_Coord = 1,
        eStyleAnimType_Sides_Top = 2,
        eStyleAnimType_Sides_Right = 3,
        eStyleAnimType_Sides_Bottom = 4,
        eStyleAnimType_Sides_Left = 5,
        eStyleAnimType_Corner_TopLeft = 6,
        eStyleAnimType_Corner_TopRight = 7,
        eStyleAnimType_Corner_BottomRight = 8,
        eStyleAnimType_Corner_BottomLeft = 9,
        eStyleAnimType_nscoord = 10,
        eStyleAnimType_float = 11,
        eStyleAnimType_Color = 12,
        eStyleAnimType_ComplexColor = 13,
        eStyleAnimType_PaintServer = 14,
        eStyleAnimType_Shadow = 15,
        eStyleAnimType_Discrete = 16,
        eStyleAnimType_None = 17,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCSSProps {
        pub _address: u8,
    }
    pub use self::super::root::mozilla::CSSEnabledState as
            nsCSSProps_EnabledState;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCSSProps_KTableEntry {
        pub mKeyword: root::nsCSSKeyword,
        pub mValue: i16,
    }
    #[test]
    fn bindgen_test_layout_nsCSSProps_KTableEntry() {
        assert_eq!(::std::mem::size_of::<nsCSSProps_KTableEntry>() , 4usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSProps_KTableEntry ) ));
        assert_eq! (::std::mem::align_of::<nsCSSProps_KTableEntry>() , 2usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsCSSProps_KTableEntry )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSProps_KTableEntry ) ) . mKeyword
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSProps_KTableEntry ) , "::" , stringify ! ( mKeyword )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSProps_KTableEntry ) ) . mValue
                    as * const _ as usize } , 2usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSProps_KTableEntry ) , "::" , stringify ! ( mValue )
                    ));
    }
    impl Clone for nsCSSProps_KTableEntry {
        fn clone(&self) -> Self { *self }
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps9kSIDTableE"]
        pub static mut nsCSSProps_kSIDTable:
                   [root::nsStyleStructID; 322usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kKeywordTableTableE"]
        pub static mut nsCSSProps_kKeywordTableTable:
                   [*const root::nsCSSProps_KTableEntry; 322usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kAnimTypeTableE"]
        pub static mut nsCSSProps_kAnimTypeTable:
                   [root::nsStyleAnimType; 322usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kStyleStructOffsetTableE"]
        pub static mut nsCSSProps_kStyleStructOffsetTable: [isize; 322usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps11kFlagsTableE"]
        pub static mut nsCSSProps_kFlagsTable: [u32; 370usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kParserVariantTableE"]
        pub static mut nsCSSProps_kParserVariantTable: [u32; 322usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kSubpropertyTableE"]
        pub static mut nsCSSProps_kSubpropertyTable:
                   [*const root::nsCSSPropertyID; 48usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps26gShorthandsContainingTableE"]
        pub static mut nsCSSProps_gShorthandsContainingTable:
                   [*mut root::nsCSSPropertyID; 322usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25gShorthandsContainingPoolE"]
        pub static mut nsCSSProps_gShorthandsContainingPool:
                   *mut root::nsCSSPropertyID;
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps22gPropertyCountInStructE"]
        pub static mut nsCSSProps_gPropertyCountInStruct: [usize; 24usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps22gPropertyIndexInStructE"]
        pub static mut nsCSSProps_gPropertyIndexInStruct: [usize; 322usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kLogicalGroupTableE"]
        pub static mut nsCSSProps_kLogicalGroupTable:
                   [*const root::nsCSSPropertyID; 9usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16gPropertyEnabledE"]
        pub static mut nsCSSProps_gPropertyEnabled: [bool; 478usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps13kIDLNameTableE"]
        pub static mut nsCSSProps_kIDLNameTable:
                   [*const ::std::os::raw::c_char; 370usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kIDLNameSortPositionTableE"]
        pub static mut nsCSSProps_kIDLNameSortPositionTable: [i32; 370usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19gPropertyUseCounterE"]
        pub static mut nsCSSProps_gPropertyUseCounter:
                   [root::mozilla::UseCounter; 322usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kAnimationDirectionKTableE"]
        pub static mut nsCSSProps_kAnimationDirectionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps24kAnimationFillModeKTableE"]
        pub static mut nsCSSProps_kAnimationFillModeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps30kAnimationIterationCountKTableE"]
        pub static mut nsCSSProps_kAnimationIterationCountKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kAnimationPlayStateKTableE"]
        pub static mut nsCSSProps_kAnimationPlayStateKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps30kAnimationTimingFunctionKTableE"]
        pub static mut nsCSSProps_kAnimationTimingFunctionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kAppearanceKTableE"]
        pub static mut nsCSSProps_kAppearanceKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kAzimuthKTableE"]
        pub static mut nsCSSProps_kAzimuthKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kBackfaceVisibilityKTableE"]
        pub static mut nsCSSProps_kBackfaceVisibilityKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kTransformStyleKTableE"]
        pub static mut nsCSSProps_kTransformStyleKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kImageLayerAttachmentKTableE"]
        pub static mut nsCSSProps_kImageLayerAttachmentKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kBackgroundOriginKTableE"]
        pub static mut nsCSSProps_kBackgroundOriginKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kMaskOriginKTableE"]
        pub static mut nsCSSProps_kMaskOriginKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kImageLayerPositionKTableE"]
        pub static mut nsCSSProps_kImageLayerPositionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kImageLayerRepeatKTableE"]
        pub static mut nsCSSProps_kImageLayerRepeatKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kImageLayerRepeatPartKTableE"]
        pub static mut nsCSSProps_kImageLayerRepeatPartKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kImageLayerSizeKTableE"]
        pub static mut nsCSSProps_kImageLayerSizeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps26kImageLayerCompositeKTableE"]
        pub static mut nsCSSProps_kImageLayerCompositeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kImageLayerModeKTableE"]
        pub static mut nsCSSProps_kImageLayerModeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kBackgroundClipKTableE"]
        pub static mut nsCSSProps_kBackgroundClipKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kMaskClipKTableE"]
        pub static mut nsCSSProps_kMaskClipKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kBlendModeKTableE"]
        pub static mut nsCSSProps_kBlendModeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kBorderCollapseKTableE"]
        pub static mut nsCSSProps_kBorderCollapseKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps24kBorderImageRepeatKTableE"]
        pub static mut nsCSSProps_kBorderImageRepeatKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kBorderImageSliceKTableE"]
        pub static mut nsCSSProps_kBorderImageSliceKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kBorderStyleKTableE"]
        pub static mut nsCSSProps_kBorderStyleKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kBorderWidthKTableE"]
        pub static mut nsCSSProps_kBorderWidthKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kBoxAlignKTableE"]
        pub static mut nsCSSProps_kBoxAlignKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kBoxDecorationBreakKTableE"]
        pub static mut nsCSSProps_kBoxDecorationBreakKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kBoxDirectionKTableE"]
        pub static mut nsCSSProps_kBoxDirectionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kBoxOrientKTableE"]
        pub static mut nsCSSProps_kBoxOrientKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kBoxPackKTableE"]
        pub static mut nsCSSProps_kBoxPackKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps26kClipPathGeometryBoxKTableE"]
        pub static mut nsCSSProps_kClipPathGeometryBoxKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kCounterRangeKTableE"]
        pub static mut nsCSSProps_kCounterRangeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kCounterSpeakAsKTableE"]
        pub static mut nsCSSProps_kCounterSpeakAsKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kCounterSymbolsSystemKTableE"]
        pub static mut nsCSSProps_kCounterSymbolsSystemKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kCounterSystemKTableE"]
        pub static mut nsCSSProps_kCounterSystemKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kDominantBaselineKTableE"]
        pub static mut nsCSSProps_kDominantBaselineKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kShapeRadiusKTableE"]
        pub static mut nsCSSProps_kShapeRadiusKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kFillRuleKTableE"]
        pub static mut nsCSSProps_kFillRuleKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kFilterFunctionKTableE"]
        pub static mut nsCSSProps_kFilterFunctionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kImageRenderingKTableE"]
        pub static mut nsCSSProps_kImageRenderingKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kShapeOutsideShapeBoxKTableE"]
        pub static mut nsCSSProps_kShapeOutsideShapeBoxKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kShapeRenderingKTableE"]
        pub static mut nsCSSProps_kShapeRenderingKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kStrokeLinecapKTableE"]
        pub static mut nsCSSProps_kStrokeLinecapKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kStrokeLinejoinKTableE"]
        pub static mut nsCSSProps_kStrokeLinejoinKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kStrokeContextValueKTableE"]
        pub static mut nsCSSProps_kStrokeContextValueKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kVectorEffectKTableE"]
        pub static mut nsCSSProps_kVectorEffectKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kTextAnchorKTableE"]
        pub static mut nsCSSProps_kTextAnchorKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kTextRenderingKTableE"]
        pub static mut nsCSSProps_kTextRenderingKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kColorAdjustKTableE"]
        pub static mut nsCSSProps_kColorAdjustKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kColorInterpolationKTableE"]
        pub static mut nsCSSProps_kColorInterpolationKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kColumnFillKTableE"]
        pub static mut nsCSSProps_kColumnFillKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kColumnSpanKTableE"]
        pub static mut nsCSSProps_kColumnSpanKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kBoxPropSourceKTableE"]
        pub static mut nsCSSProps_kBoxPropSourceKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kBoxShadowTypeKTableE"]
        pub static mut nsCSSProps_kBoxShadowTypeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kBoxSizingKTableE"]
        pub static mut nsCSSProps_kBoxSizingKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kCaptionSideKTableE"]
        pub static mut nsCSSProps_kCaptionSideKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps12kClearKTableE"]
        pub static mut nsCSSProps_kClearKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps12kColorKTableE"]
        pub static mut nsCSSProps_kColorKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kContentKTableE"]
        pub static mut nsCSSProps_kContentKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps33kControlCharacterVisibilityKTableE"]
        pub static mut nsCSSProps_kControlCharacterVisibilityKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps13kCursorKTableE"]
        pub static mut nsCSSProps_kCursorKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kDirectionKTableE"]
        pub static mut nsCSSProps_kDirectionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kDisplayKTableE"]
        pub static mut nsCSSProps_kDisplayKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kElevationKTableE"]
        pub static mut nsCSSProps_kElevationKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kEmptyCellsKTableE"]
        pub static mut nsCSSProps_kEmptyCellsKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kAlignAllKeywordsE"]
        pub static mut nsCSSProps_kAlignAllKeywords:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps22kAlignOverflowPositionE"]
        pub static mut nsCSSProps_kAlignOverflowPosition:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kAlignSelfPositionE"]
        pub static mut nsCSSProps_kAlignSelfPosition:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps12kAlignLegacyE"]
        pub static mut nsCSSProps_kAlignLegacy:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kAlignLegacyPositionE"]
        pub static mut nsCSSProps_kAlignLegacyPosition:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps31kAlignAutoNormalStretchBaselineE"]
        pub static mut nsCSSProps_kAlignAutoNormalStretchBaseline:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kAlignNormalStretchBaselineE"]
        pub static mut nsCSSProps_kAlignNormalStretchBaseline:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kAlignNormalBaselineE"]
        pub static mut nsCSSProps_kAlignNormalBaseline:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kAlignContentDistributionE"]
        pub static mut nsCSSProps_kAlignContentDistribution:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kAlignContentPositionE"]
        pub static mut nsCSSProps_kAlignContentPosition:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps31kAutoCompletionAlignJustifySelfE"]
        pub static mut nsCSSProps_kAutoCompletionAlignJustifySelf:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kAutoCompletionAlignItemsE"]
        pub static mut nsCSSProps_kAutoCompletionAlignItems:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps34kAutoCompletionAlignJustifyContentE"]
        pub static mut nsCSSProps_kAutoCompletionAlignJustifyContent:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kFlexDirectionKTableE"]
        pub static mut nsCSSProps_kFlexDirectionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kFlexWrapKTableE"]
        pub static mut nsCSSProps_kFlexWrapKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps12kFloatKTableE"]
        pub static mut nsCSSProps_kFloatKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kFloatEdgeKTableE"]
        pub static mut nsCSSProps_kFloatEdgeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kFontDisplayKTableE"]
        pub static mut nsCSSProps_kFontDisplayKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps11kFontKTableE"]
        pub static mut nsCSSProps_kFontKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kFontKerningKTableE"]
        pub static mut nsCSSProps_kFontKerningKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kFontSizeKTableE"]
        pub static mut nsCSSProps_kFontSizeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kFontSmoothingKTableE"]
        pub static mut nsCSSProps_kFontSmoothingKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kFontStretchKTableE"]
        pub static mut nsCSSProps_kFontStretchKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kFontStyleKTableE"]
        pub static mut nsCSSProps_kFontStyleKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kFontSynthesisKTableE"]
        pub static mut nsCSSProps_kFontSynthesisKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kFontVariantKTableE"]
        pub static mut nsCSSProps_kFontVariantKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps28kFontVariantAlternatesKTableE"]
        pub static mut nsCSSProps_kFontVariantAlternatesKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps33kFontVariantAlternatesFuncsKTableE"]
        pub static mut nsCSSProps_kFontVariantAlternatesFuncsKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps22kFontVariantCapsKTableE"]
        pub static mut nsCSSProps_kFontVariantCapsKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kFontVariantEastAsianKTableE"]
        pub static mut nsCSSProps_kFontVariantEastAsianKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kFontVariantLigaturesKTableE"]
        pub static mut nsCSSProps_kFontVariantLigaturesKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kFontVariantNumericKTableE"]
        pub static mut nsCSSProps_kFontVariantNumericKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps26kFontVariantPositionKTableE"]
        pub static mut nsCSSProps_kFontVariantPositionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kFontWeightKTableE"]
        pub static mut nsCSSProps_kFontWeightKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kGridAutoFlowKTableE"]
        pub static mut nsCSSProps_kGridAutoFlowKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kGridTrackBreadthKTableE"]
        pub static mut nsCSSProps_kGridTrackBreadthKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kHyphensKTableE"]
        pub static mut nsCSSProps_kHyphensKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kImageOrientationKTableE"]
        pub static mut nsCSSProps_kImageOrientationKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kImageOrientationFlipKTableE"]
        pub static mut nsCSSProps_kImageOrientationFlipKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kIsolationKTableE"]
        pub static mut nsCSSProps_kIsolationKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kIMEModeKTableE"]
        pub static mut nsCSSProps_kIMEModeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kLineHeightKTableE"]
        pub static mut nsCSSProps_kLineHeightKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps24kListStylePositionKTableE"]
        pub static mut nsCSSProps_kListStylePositionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kListStyleKTableE"]
        pub static mut nsCSSProps_kListStyleKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kMaskTypeKTableE"]
        pub static mut nsCSSProps_kMaskTypeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kMathVariantKTableE"]
        pub static mut nsCSSProps_kMathVariantKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kMathDisplayKTableE"]
        pub static mut nsCSSProps_kMathDisplayKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kContainKTableE"]
        pub static mut nsCSSProps_kContainKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kContextOpacityKTableE"]
        pub static mut nsCSSProps_kContextOpacityKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kContextPatternKTableE"]
        pub static mut nsCSSProps_kContextPatternKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kObjectFitKTableE"]
        pub static mut nsCSSProps_kObjectFitKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps13kOrientKTableE"]
        pub static mut nsCSSProps_kOrientKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kOutlineStyleKTableE"]
        pub static mut nsCSSProps_kOutlineStyleKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kOverflowKTableE"]
        pub static mut nsCSSProps_kOverflowKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kOverflowSubKTableE"]
        pub static mut nsCSSProps_kOverflowSubKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps22kOverflowClipBoxKTableE"]
        pub static mut nsCSSProps_kOverflowClipBoxKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kOverflowWrapKTableE"]
        pub static mut nsCSSProps_kOverflowWrapKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kPageBreakKTableE"]
        pub static mut nsCSSProps_kPageBreakKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps22kPageBreakInsideKTableE"]
        pub static mut nsCSSProps_kPageBreakInsideKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kPageMarksKTableE"]
        pub static mut nsCSSProps_kPageMarksKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kPageSizeKTableE"]
        pub static mut nsCSSProps_kPageSizeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps12kPitchKTableE"]
        pub static mut nsCSSProps_kPitchKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kPointerEventsKTableE"]
        pub static mut nsCSSProps_kPointerEventsKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kPositionKTableE"]
        pub static mut nsCSSProps_kPositionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps26kRadialGradientShapeKTableE"]
        pub static mut nsCSSProps_kRadialGradientShapeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kRadialGradientSizeKTableE"]
        pub static mut nsCSSProps_kRadialGradientSizeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps31kRadialGradientLegacySizeKTableE"]
        pub static mut nsCSSProps_kRadialGradientLegacySizeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps13kResizeKTableE"]
        pub static mut nsCSSProps_kResizeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kRubyAlignKTableE"]
        pub static mut nsCSSProps_kRubyAlignKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kRubyPositionKTableE"]
        pub static mut nsCSSProps_kRubyPositionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kScrollBehaviorKTableE"]
        pub static mut nsCSSProps_kScrollBehaviorKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kScrollSnapTypeKTableE"]
        pub static mut nsCSSProps_kScrollSnapTypeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps12kSpeakKTableE"]
        pub static mut nsCSSProps_kSpeakKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kSpeakHeaderKTableE"]
        pub static mut nsCSSProps_kSpeakHeaderKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kSpeakNumeralKTableE"]
        pub static mut nsCSSProps_kSpeakNumeralKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kSpeakPunctuationKTableE"]
        pub static mut nsCSSProps_kSpeakPunctuationKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kSpeechRateKTableE"]
        pub static mut nsCSSProps_kSpeechRateKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kStackSizingKTableE"]
        pub static mut nsCSSProps_kStackSizingKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kTableLayoutKTableE"]
        pub static mut nsCSSProps_kTableLayoutKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kTextAlignKTableE"]
        pub static mut nsCSSProps_kTextAlignKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kTextAlignLastKTableE"]
        pub static mut nsCSSProps_kTextAlignLastKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kTextCombineUprightKTableE"]
        pub static mut nsCSSProps_kTextCombineUprightKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kTextDecorationLineKTableE"]
        pub static mut nsCSSProps_kTextDecorationLineKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps26kTextDecorationStyleKTableE"]
        pub static mut nsCSSProps_kTextDecorationStyleKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kTextEmphasisPositionKTableE"]
        pub static mut nsCSSProps_kTextEmphasisPositionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps28kTextEmphasisStyleFillKTableE"]
        pub static mut nsCSSProps_kTextEmphasisStyleFillKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps29kTextEmphasisStyleShapeKTableE"]
        pub static mut nsCSSProps_kTextEmphasisStyleShapeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kTextJustifyKTableE"]
        pub static mut nsCSSProps_kTextJustifyKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps22kTextOrientationKTableE"]
        pub static mut nsCSSProps_kTextOrientationKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kTextOverflowKTableE"]
        pub static mut nsCSSProps_kTextOverflowKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kTextSizeAdjustKTableE"]
        pub static mut nsCSSProps_kTextSizeAdjustKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kTextTransformKTableE"]
        pub static mut nsCSSProps_kTextTransformKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kTouchActionKTableE"]
        pub static mut nsCSSProps_kTouchActionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kTopLayerKTableE"]
        pub static mut nsCSSProps_kTopLayerKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kTransformBoxKTableE"]
        pub static mut nsCSSProps_kTransformBoxKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps31kTransitionTimingFunctionKTableE"]
        pub static mut nsCSSProps_kTransitionTimingFunctionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kUnicodeBidiKTableE"]
        pub static mut nsCSSProps_kUnicodeBidiKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kUserFocusKTableE"]
        pub static mut nsCSSProps_kUserFocusKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kUserInputKTableE"]
        pub static mut nsCSSProps_kUserInputKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kUserModifyKTableE"]
        pub static mut nsCSSProps_kUserModifyKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kUserSelectKTableE"]
        pub static mut nsCSSProps_kUserSelectKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kVerticalAlignKTableE"]
        pub static mut nsCSSProps_kVerticalAlignKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kVisibilityKTableE"]
        pub static mut nsCSSProps_kVisibilityKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps13kVolumeKTableE"]
        pub static mut nsCSSProps_kVolumeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kWhitespaceKTableE"]
        pub static mut nsCSSProps_kWhitespaceKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps12kWidthKTableE"]
        pub static mut nsCSSProps_kWidthKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kWindowDraggingKTableE"]
        pub static mut nsCSSProps_kWindowDraggingKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kWindowShadowKTableE"]
        pub static mut nsCSSProps_kWindowShadowKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kWordBreakKTableE"]
        pub static mut nsCSSProps_kWordBreakKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kWritingModeKTableE"]
        pub static mut nsCSSProps_kWritingModeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    #[test]
    fn bindgen_test_layout_nsCSSProps() {
        assert_eq!(::std::mem::size_of::<nsCSSProps>() , 1usize , concat ! (
                   "Size of: " , stringify ! ( nsCSSProps ) ));
        assert_eq! (::std::mem::align_of::<nsCSSProps>() , 1usize , concat ! (
                    "Alignment of " , stringify ! ( nsCSSProps ) ));
    }
    impl Clone for nsCSSProps {
        fn clone(&self) -> Self { *self }
    }
    /**
 * Class to safely handle main-thread-only pointers off the main thread.
 *
 * Classes like XPCWrappedJS are main-thread-only, which means that it is
 * forbidden to call methods on instances of these classes off the main thread.
 * For various reasons (see bug 771074), this restriction recently began to
 * apply to AddRef/Release as well.
 *
 * This presents a problem for consumers that wish to hold a callback alive
 * on non-main-thread code. A common example of this is the proxy callback
 * pattern, where non-main-thread code holds a strong-reference to the callback
 * object, and dispatches new Runnables (also with a strong reference) to the
 * main thread in order to execute the callback. This involves several AddRef
 * and Release calls on the other thread, which is (now) verboten.
 *
 * The basic idea of this class is to introduce a layer of indirection.
 * nsMainThreadPtrHolder is a threadsafe reference-counted class that internally
 * maintains one strong reference to the main-thread-only object. It must be
 * instantiated on the main thread (so that the AddRef of the underlying object
 * happens on the main thread), but consumers may subsequently pass references
 * to the holder anywhere they please. These references are meant to be opaque
 * when accessed off-main-thread (assertions enforce this).
 *
 * The semantics of RefPtr<nsMainThreadPtrHolder<T> > would be cumbersome, so
 * we also introduce nsMainThreadPtrHandle<T>, which is conceptually identical
 * to the above (though it includes various convenience methods). The basic
 * pattern is as follows.
 *
 * // On the main thread:
 * nsCOMPtr<nsIFooCallback> callback = ...;
 * nsMainThreadPtrHandle<nsIFooCallback> callbackHandle =
 *   new nsMainThreadPtrHolder<nsIFooCallback>(callback);
 * // Pass callbackHandle to structs/classes that might be accessed on other
 * // threads.
 *
 * All structs and classes that might be accessed on other threads should store
 * an nsMainThreadPtrHandle<T> rather than an nsCOMPtr<T>.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMainThreadPtrHolder<T> {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mRawPtr: *mut T,
        pub mStrict: bool,
        pub mMainThreadEventTarget: root::nsCOMPtr,
        pub mName: *const ::std::os::raw::c_char,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    pub type nsMainThreadPtrHolder_HasThreadSafeRefCnt =
        root::mozilla::TrueType;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMainThreadPtrHandle<T> {
        pub mPtr: root::RefPtr<root::nsMainThreadPtrHolder<T>>,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct imgRequestProxy {
        pub _base: root::imgIRequest,
        pub _base_1: root::mozilla::image::IProgressObserver,
        pub _base_2: root::nsISupportsPriority,
        pub _base_3: root::nsISecurityInfoProvider,
        pub _base_4: root::nsITimedChannel,
        pub mRefCnt: root::nsAutoRefCnt,
        pub mBehaviour: root::mozilla::UniquePtr<root::ProxyBehaviour>,
        pub mURI: root::RefPtr<root::mozilla::image::ImageURL>,
        pub mListener: *mut root::imgINotificationObserver,
        pub mLoadGroup: root::nsCOMPtr,
        pub mLoadFlags: root::nsLoadFlags,
        pub mLockCount: u32,
        pub mAnimationConsumers: u32,
        pub mCanceled: bool,
        pub mIsInLoadGroup: bool,
        pub mListenerIsStrongRef: bool,
        pub mDecodeRequested: bool,
        pub mDeferNotifications: bool,
    }
    pub type imgRequestProxy_Image = root::mozilla::image::Image;
    pub type imgRequestProxy_ImageURL = root::mozilla::image::ImageURL;
    pub type imgRequestProxy_ProgressTracker =
        root::mozilla::image::ProgressTracker;
    pub type imgRequestProxy_HasThreadSafeRefCnt = root::mozilla::FalseType;
    #[repr(C)]
    #[derive(Debug)]
    pub struct imgRequestProxy_imgCancelRunnable {
        pub _base: root::mozilla::Runnable,
        pub mOwner: root::RefPtr<root::imgRequestProxy>,
        pub mStatus: root::nsresult,
    }
    #[test]
    fn bindgen_test_layout_imgRequestProxy_imgCancelRunnable() {
        assert_eq!(::std::mem::size_of::<imgRequestProxy_imgCancelRunnable>()
                   , 48usize , concat ! (
                   "Size of: " , stringify ! (
                   imgRequestProxy_imgCancelRunnable ) ));
        assert_eq! (::std::mem::align_of::<imgRequestProxy_imgCancelRunnable>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    imgRequestProxy_imgCancelRunnable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const imgRequestProxy_imgCancelRunnable ) )
                    . mOwner as * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    imgRequestProxy_imgCancelRunnable ) , "::" , stringify ! (
                    mOwner ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const imgRequestProxy_imgCancelRunnable ) )
                    . mStatus as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    imgRequestProxy_imgCancelRunnable ) , "::" , stringify ! (
                    mStatus ) ));
    }
    #[test]
    fn bindgen_test_layout_imgRequestProxy() {
        assert_eq!(::std::mem::size_of::<imgRequestProxy>() , 112usize ,
                   concat ! ( "Size of: " , stringify ! ( imgRequestProxy )
                   ));
        assert_eq! (::std::mem::align_of::<imgRequestProxy>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( imgRequestProxy ) ));
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSUnit {
        eCSSUnit_Null = 0,
        eCSSUnit_Auto = 1,
        eCSSUnit_Inherit = 2,
        eCSSUnit_Initial = 3,
        eCSSUnit_Unset = 4,
        eCSSUnit_None = 5,
        eCSSUnit_Normal = 6,
        eCSSUnit_System_Font = 7,
        eCSSUnit_All = 8,
        eCSSUnit_Dummy = 9,
        eCSSUnit_DummyInherit = 10,
        eCSSUnit_String = 11,
        eCSSUnit_Ident = 12,
        eCSSUnit_Attr = 14,
        eCSSUnit_Local_Font = 15,
        eCSSUnit_Font_Format = 16,
        eCSSUnit_Element = 17,
        eCSSUnit_Array = 20,
        eCSSUnit_Counter = 21,
        eCSSUnit_Counters = 22,
        eCSSUnit_Cubic_Bezier = 23,
        eCSSUnit_Steps = 24,
        eCSSUnit_Symbols = 25,
        eCSSUnit_Function = 26,
        eCSSUnit_Calc = 30,
        eCSSUnit_Calc_Plus = 31,
        eCSSUnit_Calc_Minus = 32,
        eCSSUnit_Calc_Times_L = 33,
        eCSSUnit_Calc_Times_R = 34,
        eCSSUnit_Calc_Divided = 35,
        eCSSUnit_URL = 40,
        eCSSUnit_Image = 41,
        eCSSUnit_Gradient = 42,
        eCSSUnit_TokenStream = 43,
        eCSSUnit_GridTemplateAreas = 44,
        eCSSUnit_Pair = 50,
        eCSSUnit_Triplet = 51,
        eCSSUnit_Rect = 52,
        eCSSUnit_List = 53,
        eCSSUnit_ListDep = 54,
        eCSSUnit_SharedList = 55,
        eCSSUnit_PairList = 56,
        eCSSUnit_PairListDep = 57,
        eCSSUnit_FontFamilyList = 58,
        eCSSUnit_AtomIdent = 60,
        eCSSUnit_Integer = 70,
        eCSSUnit_Enumerated = 71,
        eCSSUnit_EnumColor = 80,
        eCSSUnit_RGBColor = 81,
        eCSSUnit_RGBAColor = 82,
        eCSSUnit_HexColor = 83,
        eCSSUnit_ShortHexColor = 84,
        eCSSUnit_HexColorAlpha = 85,
        eCSSUnit_ShortHexColorAlpha = 86,
        eCSSUnit_PercentageRGBColor = 87,
        eCSSUnit_PercentageRGBAColor = 88,
        eCSSUnit_HSLColor = 89,
        eCSSUnit_HSLAColor = 90,
        eCSSUnit_ComplexColor = 91,
        eCSSUnit_Percent = 100,
        eCSSUnit_Number = 101,
        eCSSUnit_PhysicalMillimeter = 200,
        eCSSUnit_ViewportWidth = 700,
        eCSSUnit_ViewportHeight = 701,
        eCSSUnit_ViewportMin = 702,
        eCSSUnit_ViewportMax = 703,
        eCSSUnit_EM = 800,
        eCSSUnit_XHeight = 801,
        eCSSUnit_Char = 802,
        eCSSUnit_RootEM = 803,
        eCSSUnit_Point = 900,
        eCSSUnit_Inch = 901,
        eCSSUnit_Millimeter = 902,
        eCSSUnit_Centimeter = 903,
        eCSSUnit_Pica = 904,
        eCSSUnit_Quarter = 905,
        eCSSUnit_Pixel = 906,
        eCSSUnit_Degree = 1000,
        eCSSUnit_Grad = 1001,
        eCSSUnit_Radian = 1002,
        eCSSUnit_Turn = 1003,
        eCSSUnit_Hertz = 2000,
        eCSSUnit_Kilohertz = 2001,
        eCSSUnit_Seconds = 3000,
        eCSSUnit_Milliseconds = 3001,
        eCSSUnit_FlexFraction = 4000,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueGradient {
        pub mIsRadial: bool,
        pub mIsRepeating: bool,
        pub mIsLegacySyntax: bool,
        pub mIsMozLegacySyntax: bool,
        pub mIsExplicitSize: bool,
        pub mBgPos: root::nsCSSValuePair,
        pub mAngle: root::nsCSSValue,
        pub mRadialValues: [root::nsCSSValue; 2usize],
        pub mStops: root::nsTArray<root::nsCSSValueGradientStop>,
        pub mRefCnt: root::nsAutoRefCnt,
    }
    pub type nsCSSValueGradient_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValueGradient() {
        assert_eq!(::std::mem::size_of::<nsCSSValueGradient>() , 104usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCSSValueGradient )
                   ));
        assert_eq! (::std::mem::align_of::<nsCSSValueGradient>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueGradient ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) . mIsRadial as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mIsRadial ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) . mIsRepeating
                    as * const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mIsRepeating ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) .
                    mIsLegacySyntax as * const _ as usize } , 2usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mIsLegacySyntax ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) .
                    mIsMozLegacySyntax as * const _ as usize } , 3usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mIsMozLegacySyntax ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) .
                    mIsExplicitSize as * const _ as usize } , 4usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mIsExplicitSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) . mBgPos as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mBgPos ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) . mAngle as *
                    const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mAngle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) .
                    mRadialValues as * const _ as usize } , 56usize , concat !
                    (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mRadialValues ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) . mStops as *
                    const _ as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mStops ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) . mRefCnt as *
                    const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mRefCnt ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValuePair {
        pub mXValue: root::nsCSSValue,
        pub mYValue: root::nsCSSValue,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValuePair() {
        assert_eq!(::std::mem::size_of::<nsCSSValuePair>() , 32usize , concat
                   ! ( "Size of: " , stringify ! ( nsCSSValuePair ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValuePair>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsCSSValuePair ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePair ) ) . mXValue as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValuePair ) ,
                    "::" , stringify ! ( mXValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePair ) ) . mYValue as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValuePair ) ,
                    "::" , stringify ! ( mYValue ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValuePair_heap {
        pub _base: root::nsCSSValuePair,
        pub mRefCnt: root::nsAutoRefCnt,
    }
    pub type nsCSSValuePair_heap_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValuePair_heap() {
        assert_eq!(::std::mem::size_of::<nsCSSValuePair_heap>() , 40usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSValuePair_heap ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValuePair_heap>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValuePair_heap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePair_heap ) ) . mRefCnt as
                    * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValuePair_heap
                    ) , "::" , stringify ! ( mRefCnt ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueTokenStream {
        pub mRefCnt: root::nsAutoRefCnt,
        pub mPropertyID: root::nsCSSPropertyID,
        pub mShorthandPropertyID: root::nsCSSPropertyID,
        pub mTokenStream: ::nsstring::nsStringRepr,
        pub mBaseURI: root::nsCOMPtr,
        pub mSheetURI: root::nsCOMPtr,
        pub mSheetPrincipal: root::nsCOMPtr,
        pub mLineNumber: u32,
        pub mLineOffset: u32,
        pub mLevel: root::mozilla::SheetType,
    }
    pub type nsCSSValueTokenStream_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValueTokenStream() {
        assert_eq!(::std::mem::size_of::<nsCSSValueTokenStream>() , 72usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSValueTokenStream ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValueTokenStream>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueTokenStream )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) . mRefCnt
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! ( mRefCnt )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) .
                    mPropertyID as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! ( mPropertyID
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) .
                    mShorthandPropertyID as * const _ as usize } , 12usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! (
                    mShorthandPropertyID ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) .
                    mTokenStream as * const _ as usize } , 16usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! (
                    mTokenStream ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) . mBaseURI
                    as * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! ( mBaseURI )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) . mSheetURI
                    as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! ( mSheetURI )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) .
                    mSheetPrincipal as * const _ as usize } , 48usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! (
                    mSheetPrincipal ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) .
                    mLineNumber as * const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! ( mLineNumber
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) .
                    mLineOffset as * const _ as usize } , 60usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! ( mLineOffset
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) . mLevel as
                    * const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! ( mLevel )
                    ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSRect {
        pub mTop: root::nsCSSValue,
        pub mRight: root::nsCSSValue,
        pub mBottom: root::nsCSSValue,
        pub mLeft: root::nsCSSValue,
    }
    pub type nsCSSRect_side_type = *mut root::nsCSSValue;
    extern "C" {
        #[link_name = "_ZN9nsCSSRect5sidesE"]
        pub static mut nsCSSRect_sides: [root::nsCSSRect_side_type; 4usize];
    }
    #[test]
    fn bindgen_test_layout_nsCSSRect() {
        assert_eq!(::std::mem::size_of::<nsCSSRect>() , 64usize , concat ! (
                   "Size of: " , stringify ! ( nsCSSRect ) ));
        assert_eq! (::std::mem::align_of::<nsCSSRect>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsCSSRect ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSRect ) ) . mTop as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSRect ) , "::"
                    , stringify ! ( mTop ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSRect ) ) . mRight as * const _
                    as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSRect ) , "::"
                    , stringify ! ( mRight ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSRect ) ) . mBottom as * const _
                    as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSRect ) , "::"
                    , stringify ! ( mBottom ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSRect ) ) . mLeft as * const _ as
                    usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSRect ) , "::"
                    , stringify ! ( mLeft ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSRect_heap {
        pub _base: root::nsCSSRect,
        pub mRefCnt: root::nsAutoRefCnt,
    }
    pub type nsCSSRect_heap_HasThreadSafeRefCnt = root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSRect_heap() {
        assert_eq!(::std::mem::size_of::<nsCSSRect_heap>() , 72usize , concat
                   ! ( "Size of: " , stringify ! ( nsCSSRect_heap ) ));
        assert_eq! (::std::mem::align_of::<nsCSSRect_heap>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsCSSRect_heap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSRect_heap ) ) . mRefCnt as *
                    const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSRect_heap ) ,
                    "::" , stringify ! ( mRefCnt ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueList {
        pub mValue: root::nsCSSValue,
        pub mNext: *mut root::nsCSSValueList,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValueList() {
        assert_eq!(::std::mem::size_of::<nsCSSValueList>() , 24usize , concat
                   ! ( "Size of: " , stringify ! ( nsCSSValueList ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValueList>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsCSSValueList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueList ) ) . mValue as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueList ) ,
                    "::" , stringify ! ( mValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueList ) ) . mNext as * const
                    _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueList ) ,
                    "::" , stringify ! ( mNext ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueList_heap {
        pub _base: root::nsCSSValueList,
        pub mRefCnt: root::nsAutoRefCnt,
    }
    pub type nsCSSValueList_heap_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValueList_heap() {
        assert_eq!(::std::mem::size_of::<nsCSSValueList_heap>() , 32usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSValueList_heap ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValueList_heap>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueList_heap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueList_heap ) ) . mRefCnt as
                    * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueList_heap
                    ) , "::" , stringify ! ( mRefCnt ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueSharedList {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mHead: *mut root::nsCSSValueList,
    }
    pub type nsCSSValueSharedList_HasThreadSafeRefCnt =
        root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsCSSValueSharedList() {
        assert_eq!(::std::mem::size_of::<nsCSSValueSharedList>() , 16usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSValueSharedList ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValueSharedList>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueSharedList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueSharedList ) ) . mRefCnt as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueSharedList ) , "::" , stringify ! ( mRefCnt )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueSharedList ) ) . mHead as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueSharedList ) , "::" , stringify ! ( mHead ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValuePairList {
        pub mXValue: root::nsCSSValue,
        pub mYValue: root::nsCSSValue,
        pub mNext: *mut root::nsCSSValuePairList,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValuePairList() {
        assert_eq!(::std::mem::size_of::<nsCSSValuePairList>() , 40usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCSSValuePairList )
                   ));
        assert_eq! (::std::mem::align_of::<nsCSSValuePairList>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValuePairList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePairList ) ) . mXValue as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValuePairList
                    ) , "::" , stringify ! ( mXValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePairList ) ) . mYValue as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValuePairList
                    ) , "::" , stringify ! ( mYValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePairList ) ) . mNext as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValuePairList
                    ) , "::" , stringify ! ( mNext ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValuePairList_heap {
        pub _base: root::nsCSSValuePairList,
        pub mRefCnt: root::nsAutoRefCnt,
    }
    pub type nsCSSValuePairList_heap_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValuePairList_heap() {
        assert_eq!(::std::mem::size_of::<nsCSSValuePairList_heap>() , 48usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsCSSValuePairList_heap ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValuePairList_heap>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsCSSValuePairList_heap )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePairList_heap ) ) . mRefCnt
                    as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValuePairList_heap ) , "::" , stringify ! ( mRefCnt )
                    ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueTriplet {
        pub mXValue: root::nsCSSValue,
        pub mYValue: root::nsCSSValue,
        pub mZValue: root::nsCSSValue,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValueTriplet() {
        assert_eq!(::std::mem::size_of::<nsCSSValueTriplet>() , 48usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCSSValueTriplet )
                   ));
        assert_eq! (::std::mem::align_of::<nsCSSValueTriplet>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueTriplet ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTriplet ) ) . mXValue as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueTriplet )
                    , "::" , stringify ! ( mXValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTriplet ) ) . mYValue as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueTriplet )
                    , "::" , stringify ! ( mYValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTriplet ) ) . mZValue as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueTriplet )
                    , "::" , stringify ! ( mZValue ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueTriplet_heap {
        pub _base: root::nsCSSValueTriplet,
        pub mRefCnt: root::nsAutoRefCnt,
    }
    pub type nsCSSValueTriplet_heap_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValueTriplet_heap() {
        assert_eq!(::std::mem::size_of::<nsCSSValueTriplet_heap>() , 56usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSValueTriplet_heap ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValueTriplet_heap>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueTriplet_heap )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTriplet_heap ) ) . mRefCnt
                    as * const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTriplet_heap ) , "::" , stringify ! ( mRefCnt )
                    ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueFloatColor {
        pub mRefCnt: root::nsAutoRefCnt,
        pub mComponent1: f32,
        pub mComponent2: f32,
        pub mComponent3: f32,
        pub mAlpha: f32,
    }
    pub type nsCSSValueFloatColor_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValueFloatColor() {
        assert_eq!(::std::mem::size_of::<nsCSSValueFloatColor>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSValueFloatColor ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValueFloatColor>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueFloatColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueFloatColor ) ) . mRefCnt as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueFloatColor ) , "::" , stringify ! ( mRefCnt )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueFloatColor ) ) .
                    mComponent1 as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueFloatColor ) , "::" , stringify ! ( mComponent1
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueFloatColor ) ) .
                    mComponent2 as * const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueFloatColor ) , "::" , stringify ! ( mComponent2
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueFloatColor ) ) .
                    mComponent3 as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueFloatColor ) , "::" , stringify ! ( mComponent3
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueFloatColor ) ) . mAlpha as
                    * const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueFloatColor ) , "::" , stringify ! ( mAlpha ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValue {
        pub mUnit: root::nsCSSUnit,
        pub mValue: root::nsCSSValue__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValue_Array {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mCount: usize,
        pub mArray: [root::nsCSSValue; 1usize],
    }
    pub type nsCSSValue_Array_HasThreadSafeRefCnt = root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsCSSValue_Array() {
        assert_eq!(::std::mem::size_of::<nsCSSValue_Array>() , 32usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCSSValue_Array )
                   ));
        assert_eq! (::std::mem::align_of::<nsCSSValue_Array>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValue_Array ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue_Array ) ) . mRefCnt as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValue_Array )
                    , "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue_Array ) ) . mCount as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValue_Array )
                    , "::" , stringify ! ( mCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue_Array ) ) . mArray as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValue_Array )
                    , "::" , stringify ! ( mArray ) ));
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSValue_Serialization {
        eNormalized = 0,
        eAuthorSpecified = 1,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCSSValue__bindgen_ty_1 {
        pub mInt: root::__BindgenUnionField<i32>,
        pub mFloat: root::__BindgenUnionField<f32>,
        pub mString: root::__BindgenUnionField<*mut root::nsStringBuffer>,
        pub mColor: root::__BindgenUnionField<root::nscolor>,
        pub mAtom: root::__BindgenUnionField<*mut root::nsIAtom>,
        pub mArray: root::__BindgenUnionField<*mut root::nsCSSValue_Array>,
        pub mURL: root::__BindgenUnionField<*mut root::mozilla::css::URLValue>,
        pub mImage: root::__BindgenUnionField<*mut root::mozilla::css::ImageValue>,
        pub mGridTemplateAreas: root::__BindgenUnionField<*mut root::mozilla::css::GridTemplateAreasValue>,
        pub mGradient: root::__BindgenUnionField<*mut root::nsCSSValueGradient>,
        pub mTokenStream: root::__BindgenUnionField<*mut root::nsCSSValueTokenStream>,
        pub mPair: root::__BindgenUnionField<*mut root::nsCSSValuePair_heap>,
        pub mRect: root::__BindgenUnionField<*mut root::nsCSSRect_heap>,
        pub mTriplet: root::__BindgenUnionField<*mut root::nsCSSValueTriplet_heap>,
        pub mList: root::__BindgenUnionField<*mut root::nsCSSValueList_heap>,
        pub mListDependent: root::__BindgenUnionField<*mut root::nsCSSValueList>,
        pub mSharedList: root::__BindgenUnionField<*mut root::nsCSSValueSharedList>,
        pub mPairList: root::__BindgenUnionField<*mut root::nsCSSValuePairList_heap>,
        pub mPairListDependent: root::__BindgenUnionField<*mut root::nsCSSValuePairList>,
        pub mFloatColor: root::__BindgenUnionField<*mut root::nsCSSValueFloatColor>,
        pub mFontFamilyList: root::__BindgenUnionField<*mut root::mozilla::css::FontFamilyListRefCnt>,
        pub mComplexColor: root::__BindgenUnionField<*mut root::mozilla::css::ComplexColorValue>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValue__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsCSSValue__bindgen_ty_1>() , 8usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValue__bindgen_ty_1>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsCSSValue__bindgen_ty_1 )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mInt
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mInt )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mFloat
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mFloat )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mString as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mString
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mColor
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mColor )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mAtom
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mAtom )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mArray
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mArray )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mURL
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mURL )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mImage
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mImage )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mGridTemplateAreas as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mGridTemplateAreas ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mGradient as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mGradient ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mTokenStream as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mTokenStream ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mPair
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mPair )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mRect
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mRect )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mTriplet as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mTriplet
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mList
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mList )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mListDependent as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mListDependent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mSharedList as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mSharedList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mPairList as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mPairList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mPairListDependent as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mPairListDependent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mFloatColor as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mFloatColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mFontFamilyList as * const _ as usize } , 0usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mFontFamilyList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mComplexColor as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mComplexColor ) ));
    }
    impl Clone for nsCSSValue__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsCSSValue() {
        assert_eq!(::std::mem::size_of::<nsCSSValue>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsCSSValue ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValue>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsCSSValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue ) ) . mUnit as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValue ) , "::"
                    , stringify ! ( mUnit ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue ) ) . mValue as * const _
                    as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValue ) , "::"
                    , stringify ! ( mValue ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueGradientStop {
        pub mLocation: root::nsCSSValue,
        pub mColor: root::nsCSSValue,
        pub mIsInterpolationHint: bool,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValueGradientStop() {
        assert_eq!(::std::mem::size_of::<nsCSSValueGradientStop>() , 40usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSValueGradientStop ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValueGradientStop>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueGradientStop )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradientStop ) ) .
                    mLocation as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueGradientStop ) , "::" , stringify ! ( mLocation
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradientStop ) ) . mColor
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueGradientStop ) , "::" , stringify ! ( mColor )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradientStop ) ) .
                    mIsInterpolationHint as * const _ as usize } , 32usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueGradientStop ) , "::" , stringify ! (
                    mIsInterpolationHint ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct imgIContainer {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsISecurityInfoProvider {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISecurityInfoProvider_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsISecurityInfoProvider() {
        assert_eq!(::std::mem::size_of::<nsISecurityInfoProvider>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsISecurityInfoProvider ) ));
        assert_eq! (::std::mem::align_of::<nsISecurityInfoProvider>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsISecurityInfoProvider )
                    ));
    }
    impl Clone for nsISecurityInfoProvider {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsISupportsPriority {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISupportsPriority_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsISupportsPriority_PRIORITY_HIGHEST:
              root::nsISupportsPriority__bindgen_ty_1 =
        nsISupportsPriority__bindgen_ty_1::PRIORITY_HIGHEST;
    pub const nsISupportsPriority_PRIORITY_HIGH:
              root::nsISupportsPriority__bindgen_ty_1 =
        nsISupportsPriority__bindgen_ty_1::PRIORITY_HIGH;
    pub const nsISupportsPriority_PRIORITY_NORMAL:
              root::nsISupportsPriority__bindgen_ty_1 =
        nsISupportsPriority__bindgen_ty_1::PRIORITY_NORMAL;
    pub const nsISupportsPriority_PRIORITY_LOW:
              root::nsISupportsPriority__bindgen_ty_1 =
        nsISupportsPriority__bindgen_ty_1::PRIORITY_LOW;
    pub const nsISupportsPriority_PRIORITY_LOWEST:
              root::nsISupportsPriority__bindgen_ty_1 =
        nsISupportsPriority__bindgen_ty_1::PRIORITY_LOWEST;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsISupportsPriority__bindgen_ty_1 {
        PRIORITY_HIGHEST = -20,
        PRIORITY_HIGH = -10,
        PRIORITY_NORMAL = 0,
        PRIORITY_LOW = 10,
        PRIORITY_LOWEST = 20,
    }
    #[test]
    fn bindgen_test_layout_nsISupportsPriority() {
        assert_eq!(::std::mem::size_of::<nsISupportsPriority>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsISupportsPriority ) ));
        assert_eq! (::std::mem::align_of::<nsISupportsPriority>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsISupportsPriority ) ));
    }
    impl Clone for nsISupportsPriority {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsITimedChannel {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsITimedChannel_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsITimedChannel() {
        assert_eq!(::std::mem::size_of::<nsITimedChannel>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsITimedChannel ) ));
        assert_eq! (::std::mem::align_of::<nsITimedChannel>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsITimedChannel ) ));
    }
    impl Clone for nsITimedChannel {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIAsyncVerifyRedirectCallback {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIAsyncVerifyRedirectCallback_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIAsyncVerifyRedirectCallback() {
        assert_eq!(::std::mem::size_of::<nsIAsyncVerifyRedirectCallback>() ,
                   8usize , concat ! (
                   "Size of: " , stringify ! ( nsIAsyncVerifyRedirectCallback
                   ) ));
        assert_eq! (::std::mem::align_of::<nsIAsyncVerifyRedirectCallback>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsIAsyncVerifyRedirectCallback ) ));
    }
    impl Clone for nsIAsyncVerifyRedirectCallback {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIChannelEventSink {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIChannelEventSink_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsIChannelEventSink_REDIRECT_TEMPORARY:
              root::nsIChannelEventSink__bindgen_ty_1 =
        nsIChannelEventSink__bindgen_ty_1::REDIRECT_TEMPORARY;
    pub const nsIChannelEventSink_REDIRECT_PERMANENT:
              root::nsIChannelEventSink__bindgen_ty_1 =
        nsIChannelEventSink__bindgen_ty_1::REDIRECT_PERMANENT;
    pub const nsIChannelEventSink_REDIRECT_INTERNAL:
              root::nsIChannelEventSink__bindgen_ty_1 =
        nsIChannelEventSink__bindgen_ty_1::REDIRECT_INTERNAL;
    pub const nsIChannelEventSink_REDIRECT_STS_UPGRADE:
              root::nsIChannelEventSink__bindgen_ty_1 =
        nsIChannelEventSink__bindgen_ty_1::REDIRECT_STS_UPGRADE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIChannelEventSink__bindgen_ty_1 {
        REDIRECT_TEMPORARY = 1,
        REDIRECT_PERMANENT = 2,
        REDIRECT_INTERNAL = 4,
        REDIRECT_STS_UPGRADE = 8,
    }
    #[test]
    fn bindgen_test_layout_nsIChannelEventSink() {
        assert_eq!(::std::mem::size_of::<nsIChannelEventSink>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIChannelEventSink ) ));
        assert_eq! (::std::mem::align_of::<nsIChannelEventSink>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIChannelEventSink ) ));
    }
    impl Clone for nsIChannelEventSink {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIThreadRetargetableStreamListener {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIThreadRetargetableStreamListener_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIThreadRetargetableStreamListener() {
        assert_eq!(::std::mem::size_of::<nsIThreadRetargetableStreamListener>()
                   , 8usize , concat ! (
                   "Size of: " , stringify ! (
                   nsIThreadRetargetableStreamListener ) ));
        assert_eq! (::std::mem::align_of::<nsIThreadRetargetableStreamListener>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsIThreadRetargetableStreamListener ) ));
    }
    impl Clone for nsIThreadRetargetableStreamListener {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct imgCacheValidator {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct imgLoader {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct imgCacheEntry {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIApplicationCache {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct imgRequest {
        pub _base: root::nsIStreamListener,
        pub _base_1: root::nsIThreadRetargetableStreamListener,
        pub _base_2: root::nsIChannelEventSink,
        pub _base_3: root::nsIInterfaceRequestor,
        pub _base_4: root::nsIAsyncVerifyRedirectCallback,
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mLoader: *mut root::imgLoader,
        pub mRequest: root::nsCOMPtr,
        pub mURI: root::RefPtr<root::mozilla::image::ImageURL>,
        pub mCurrentURI: root::nsCOMPtr,
        pub mLoadingPrincipal: root::nsCOMPtr,
        pub mPrincipal: root::nsCOMPtr,
        pub mProperties: root::nsCOMPtr,
        pub mSecurityInfo: root::nsCOMPtr,
        pub mChannel: root::nsCOMPtr,
        pub mPrevChannelSink: root::nsCOMPtr,
        pub mApplicationCache: root::nsCOMPtr,
        pub mTimedChannel: root::nsCOMPtr,
        pub mContentType: root::nsCString,
        pub mCacheEntry: root::RefPtr<root::imgCacheEntry>,
        /// The key under which this imgRequest is stored in the image cache.
        pub mCacheKey: root::imgRequest_ImageCacheKey,
        pub mLoadId: *mut ::std::os::raw::c_void,
        /// Raw pointer to the first proxy that was added to this imgRequest. Use only
  /// pointer comparisons; there's no guarantee this will remain valid.
        pub mFirstProxy: *mut ::std::os::raw::c_void,
        pub mValidator: *mut root::imgCacheValidator,
        pub mRedirectCallback: root::nsCOMPtr,
        pub mNewRedirectChannel: root::nsCOMPtr,
        pub mInnerWindowId: u64,
        pub mCORSMode: i32,
        pub mReferrerPolicy: root::imgRequest_ReferrerPolicy,
        pub mImageErrorCode: root::nsresult,
        pub mBoostCategoriesRequested: u32,
        pub mMutex: root::mozilla::Mutex,
        pub mProgressTracker: root::RefPtr<root::mozilla::image::ProgressTracker>,
        pub mImage: root::RefPtr<root::mozilla::image::Image>,
        pub _bitfield_1: u8,
        pub __bindgen_padding_0: [u8; 7usize],
    }
    pub type imgRequest_Image = root::mozilla::image::Image;
    pub type imgRequest_ImageCacheKey = root::mozilla::image::ImageCacheKey;
    pub type imgRequest_ImageURL = root::mozilla::image::ImageURL;
    pub type imgRequest_ProgressTracker =
        root::mozilla::image::ProgressTracker;
    pub use self::super::root::mozilla::net::ReferrerPolicy as
            imgRequest_ReferrerPolicy;
    pub type imgRequest_HasThreadSafeRefCnt = root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_imgRequest() {
        assert_eq!(::std::mem::size_of::<imgRequest>() , 376usize , concat ! (
                   "Size of: " , stringify ! ( imgRequest ) ));
        assert_eq! (::std::mem::align_of::<imgRequest>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( imgRequest ) ));
    }
    impl imgRequest {
        #[inline]
        pub fn mIsMultiPartChannel(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 1u64 as u8;
            let val = (unit_field_val & mask) >> 0usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsMultiPartChannel(&mut self, val: bool) {
            let mask = 1u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 0usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn mGotData(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 2u64 as u8;
            let val = (unit_field_val & mask) >> 1usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mGotData(&mut self, val: bool) {
            let mask = 2u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 1usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn mIsInCache(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 4u64 as u8;
            let val = (unit_field_val & mask) >> 2usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsInCache(&mut self, val: bool) {
            let mask = 4u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 2usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn mDecodeRequested(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 8u64 as u8;
            let val = (unit_field_val & mask) >> 3usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mDecodeRequested(&mut self, val: bool) {
            let mask = 8u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 3usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn mNewPartPending(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 16u64 as u8;
            let val = (unit_field_val & mask) >> 4usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mNewPartPending(&mut self, val: bool) {
            let mask = 16u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 4usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn mHadInsecureRedirect(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 32u64 as u8;
            let val = (unit_field_val & mask) >> 5usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHadInsecureRedirect(&mut self, val: bool) {
            let mask = 32u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 5usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn new_bitfield_1(mIsMultiPartChannel: bool, mGotData: bool,
                              mIsInCache: bool, mDecodeRequested: bool,
                              mNewPartPending: bool,
                              mHadInsecureRedirect: bool) -> u8 {
            ({
                 ({
                      ({
                           ({
                                ({
                                     ({ 0 } |
                                          ((mIsMultiPartChannel as u8 as u8)
                                               << 0usize) & (1u64 as u8))
                                 } |
                                     ((mGotData as u8 as u8) << 1usize) &
                                         (2u64 as u8))
                            } |
                                ((mIsInCache as u8 as u8) << 2usize) &
                                    (4u64 as u8))
                       } |
                           ((mDecodeRequested as u8 as u8) << 3usize) &
                               (8u64 as u8))
                  } |
                      ((mNewPartPending as u8 as u8) << 4usize) &
                          (16u64 as u8))
             } |
                 ((mHadInsecureRedirect as u8 as u8) << 5usize) &
                     (32u64 as u8))
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ProxyBehaviour {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleVisibility {
        pub mImageOrientation: root::nsStyleImageOrientation,
        pub mDirection: u8,
        pub mVisible: u8,
        pub mImageRendering: u8,
        pub mWritingMode: u8,
        pub mTextOrientation: u8,
        pub mColorAdjust: u8,
    }
    pub const nsStyleVisibility_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleVisibility() {
        assert_eq!(::std::mem::size_of::<nsStyleVisibility>() , 7usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleVisibility )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleVisibility>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleVisibility ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVisibility ) ) .
                    mImageOrientation as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleVisibility )
                    , "::" , stringify ! ( mImageOrientation ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVisibility ) ) . mDirection as
                    * const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleVisibility )
                    , "::" , stringify ! ( mDirection ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVisibility ) ) . mVisible as *
                    const _ as usize } , 2usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleVisibility )
                    , "::" , stringify ! ( mVisible ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVisibility ) ) .
                    mImageRendering as * const _ as usize } , 3usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleVisibility )
                    , "::" , stringify ! ( mImageRendering ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVisibility ) ) . mWritingMode
                    as * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleVisibility )
                    , "::" , stringify ! ( mWritingMode ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVisibility ) ) .
                    mTextOrientation as * const _ as usize } , 5usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleVisibility )
                    , "::" , stringify ! ( mTextOrientation ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVisibility ) ) . mColorAdjust
                    as * const _ as usize } , 6usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleVisibility )
                    , "::" , stringify ! ( mColorAdjust ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleFont {
        pub mFont: root::nsFont,
        pub mSize: root::nscoord,
        pub mGenericID: u8,
        pub mScriptLevel: i8,
        pub mMathVariant: u8,
        pub mMathDisplay: u8,
        pub mMinFontSizeRatio: u8,
        pub mExplicitLanguage: bool,
        pub mAllowZoom: bool,
        pub mScriptUnconstrainedSize: root::nscoord,
        pub mScriptMinSize: root::nscoord,
        pub mScriptSizeMultiplier: f32,
        pub mLanguage: root::nsCOMPtr,
    }
    pub const nsStyleFont_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleFont() {
        assert_eq!(::std::mem::size_of::<nsStyleFont>() , 120usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleFont ) ));
        assert_eq! (::std::mem::align_of::<nsStyleFont>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleFont ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mFont as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mFont ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mSize as * const _
                    as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mGenericID as *
                    const _ as usize } , 92usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mGenericID ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mScriptLevel as *
                    const _ as usize } , 93usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mScriptLevel ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mMathVariant as *
                    const _ as usize } , 94usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mMathVariant ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mMathDisplay as *
                    const _ as usize } , 95usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mMathDisplay ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mMinFontSizeRatio
                    as * const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mMinFontSizeRatio ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mExplicitLanguage
                    as * const _ as usize } , 97usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mExplicitLanguage ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mAllowZoom as *
                    const _ as usize } , 98usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mAllowZoom ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) .
                    mScriptUnconstrainedSize as * const _ as usize } ,
                    100usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mScriptUnconstrainedSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mScriptMinSize as *
                    const _ as usize } , 104usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mScriptMinSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) .
                    mScriptSizeMultiplier as * const _ as usize } , 108usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mScriptSizeMultiplier ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mLanguage as *
                    const _ as usize } , 112usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mLanguage ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleGradientStop {
        pub mLocation: root::nsStyleCoord,
        pub mColor: root::nscolor,
        pub mIsInterpolationHint: bool,
    }
    #[test]
    fn bindgen_test_layout_nsStyleGradientStop() {
        assert_eq!(::std::mem::size_of::<nsStyleGradientStop>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsStyleGradientStop ) ));
        assert_eq! (::std::mem::align_of::<nsStyleGradientStop>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleGradientStop ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradientStop ) ) . mLocation
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradientStop
                    ) , "::" , stringify ! ( mLocation ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradientStop ) ) . mColor as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradientStop
                    ) , "::" , stringify ! ( mColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradientStop ) ) .
                    mIsInterpolationHint as * const _ as usize } , 20usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradientStop
                    ) , "::" , stringify ! ( mIsInterpolationHint ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleGradient {
        pub mShape: u8,
        pub mSize: u8,
        pub mRepeating: bool,
        pub mLegacySyntax: bool,
        pub mMozLegacySyntax: bool,
        pub mBgPosX: root::nsStyleCoord,
        pub mBgPosY: root::nsStyleCoord,
        pub mAngle: root::nsStyleCoord,
        pub mRadiusX: root::nsStyleCoord,
        pub mRadiusY: root::nsStyleCoord,
        pub mStops: root::nsTArray<root::nsStyleGradientStop>,
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
    }
    pub type nsStyleGradient_HasThreadSafeRefCnt = root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsStyleGradient() {
        assert_eq!(::std::mem::size_of::<nsStyleGradient>() , 104usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleGradient )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleGradient>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleGradient ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mShape as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mShape ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mSize as *
                    const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mRepeating as *
                    const _ as usize } , 2usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mRepeating ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mLegacySyntax
                    as * const _ as usize } , 3usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mLegacySyntax ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) .
                    mMozLegacySyntax as * const _ as usize } , 4usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mMozLegacySyntax ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mBgPosX as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mBgPosX ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mBgPosY as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mBgPosY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mAngle as *
                    const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mAngle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mRadiusX as *
                    const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mRadiusX ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mRadiusY as *
                    const _ as usize } , 72usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mRadiusY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mStops as *
                    const _ as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mStops ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mRefCnt as *
                    const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mRefCnt ) ));
    }
    /**
 * A wrapper for an imgRequestProxy that supports off-main-thread creation
 * and equality comparison.
 *
 * An nsStyleImageRequest can be created in two ways:
 *
 * 1. Using the constructor that takes an imgRequestProxy.  This must
 *    be called from the main thread.  The nsStyleImageRequest is
 *    immediately considered "resolved", and the get() method that
 *    returns the imgRequestProxy can be called.
 *
 * 2. Using the constructor that takes the URL, base URI, referrer
 *    and principal that can be used to inititiate an image load and
 *    produce an imgRequestProxy later.  This can be called from
 *    any thread.  The nsStyleImageRequest is not considered "resolved"
 *    at this point, and the Resolve() method must be called later
 *    to initiate the image load and make calls to get() valid.
 *
 * Calls to TrackImage(), UntrackImage(), LockImage(), UnlockImage() and
 * RequestDiscard() are made to the imgRequestProxy and ImageTracker as
 * appropriate, according to the mode flags passed in to the constructor.
 *
 * The main thread constructor takes a pointer to the css::ImageValue that
 * is the specified url() value, while the off-main-thread constructor
 * creates a new css::ImageValue to represent the url() information passed
 * to the constructor.  This ImageValue is held on to for the comparisons done
 * in DefinitelyEquals(), so that we don't need to call into the non-OMT-safe
 * Equals() on the nsIURI objects returned from imgRequestProxy::GetURI().
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleImageRequest {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mRequestProxy: root::RefPtr<root::imgRequestProxy>,
        pub mImageValue: root::RefPtr<root::mozilla::css::ImageValue>,
        pub mImageTracker: root::RefPtr<root::mozilla::dom::ImageTracker>,
        pub mDocGroup: root::RefPtr<root::mozilla::dom::DocGroup>,
        pub mModeFlags: root::nsStyleImageRequest_Mode,
        pub mResolved: bool,
    }
    pub type nsStyleImageRequest_URLValueData =
        root::mozilla::css::URLValueData;
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageRequest_Mode { Track = 1, Discard = 2, }
    pub type nsStyleImageRequest_HasThreadSafeRefCnt =
        root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsStyleImageRequest() {
        assert_eq!(::std::mem::size_of::<nsStyleImageRequest>() , 48usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsStyleImageRequest ) ));
        assert_eq! (::std::mem::align_of::<nsStyleImageRequest>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleImageRequest ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageRequest ) ) . mRefCnt as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageRequest
                    ) , "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageRequest ) ) .
                    mRequestProxy as * const _ as usize } , 8usize , concat !
                    (
                    "Alignment of field: " , stringify ! ( nsStyleImageRequest
                    ) , "::" , stringify ! ( mRequestProxy ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageRequest ) ) . mImageValue
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageRequest
                    ) , "::" , stringify ! ( mImageValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageRequest ) ) .
                    mImageTracker as * const _ as usize } , 24usize , concat !
                    (
                    "Alignment of field: " , stringify ! ( nsStyleImageRequest
                    ) , "::" , stringify ! ( mImageTracker ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageRequest ) ) . mDocGroup
                    as * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageRequest
                    ) , "::" , stringify ! ( mDocGroup ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageRequest ) ) . mModeFlags
                    as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageRequest
                    ) , "::" , stringify ! ( mModeFlags ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageRequest ) ) . mResolved
                    as * const _ as usize } , 41usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageRequest
                    ) , "::" , stringify ! ( mResolved ) ));
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageType {
        eStyleImageType_Null = 0,
        eStyleImageType_Image = 1,
        eStyleImageType_Gradient = 2,
        eStyleImageType_Element = 3,
        eStyleImageType_URL = 4,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct CachedBorderImageData {
        pub mCachedSVGViewportSize: [u32; 3usize],
        pub mSubImages: root::nsCOMArray,
    }
    #[test]
    fn bindgen_test_layout_CachedBorderImageData() {
        assert_eq!(::std::mem::size_of::<CachedBorderImageData>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( CachedBorderImageData ) ));
        assert_eq! (::std::mem::align_of::<CachedBorderImageData>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( CachedBorderImageData )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CachedBorderImageData ) ) .
                    mCachedSVGViewportSize as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    CachedBorderImageData ) , "::" , stringify ! (
                    mCachedSVGViewportSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CachedBorderImageData ) ) .
                    mSubImages as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CachedBorderImageData ) , "::" , stringify ! ( mSubImages
                    ) ));
    }
    /**
 * Represents a paintable image of one of the following types.
 * (1) A real image loaded from an external source.
 * (2) A CSS linear or radial gradient.
 * (3) An element within a document, or an <img>, <video>, or <canvas> element
 *     not in a document.
 * (*) Optionally a crop rect can be set to paint a partial (rectangular)
 * region of an image. (Currently, this feature is only supported with an
 * image of type (1)).
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleImage {
        pub mCachedBIData: root::mozilla::UniquePtr<root::CachedBorderImageData>,
        pub mType: root::nsStyleImageType,
        pub __bindgen_anon_1: root::nsStyleImage__bindgen_ty_1,
        pub mCropRect: root::mozilla::UniquePtr<root::nsStyleSides>,
    }
    pub type nsStyleImage_URLValue = root::mozilla::css::URLValue;
    pub type nsStyleImage_URLValueData = root::mozilla::css::URLValueData;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleImage__bindgen_ty_1 {
        pub mImage: root::__BindgenUnionField<*mut root::nsStyleImageRequest>,
        pub mGradient: root::__BindgenUnionField<*mut root::nsStyleGradient>,
        pub mURLValue: root::__BindgenUnionField<*mut root::nsStyleImage_URLValue>,
        pub mElementId: root::__BindgenUnionField<*mut root::nsIAtom>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsStyleImage__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleImage__bindgen_ty_1>() ,
                   8usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleImage__bindgen_ty_1 )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleImage__bindgen_ty_1>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsStyleImage__bindgen_ty_1
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImage__bindgen_ty_1 ) ) .
                    mImage as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImage__bindgen_ty_1 ) , "::" , stringify ! ( mImage
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImage__bindgen_ty_1 ) ) .
                    mGradient as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImage__bindgen_ty_1 ) , "::" , stringify ! (
                    mGradient ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImage__bindgen_ty_1 ) ) .
                    mURLValue as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImage__bindgen_ty_1 ) , "::" , stringify ! (
                    mURLValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImage__bindgen_ty_1 ) ) .
                    mElementId as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImage__bindgen_ty_1 ) , "::" , stringify ! (
                    mElementId ) ));
    }
    impl Clone for nsStyleImage__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsStyleImage() {
        assert_eq!(::std::mem::size_of::<nsStyleImage>() , 32usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleImage ) ));
        assert_eq! (::std::mem::align_of::<nsStyleImage>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleImage ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImage ) ) . mCachedBIData as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImage ) ,
                    "::" , stringify ! ( mCachedBIData ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImage ) ) . mType as * const _
                    as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImage ) ,
                    "::" , stringify ! ( mType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImage ) ) . mCropRect as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImage ) ,
                    "::" , stringify ! ( mCropRect ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleColor {
        pub mColor: root::nscolor,
    }
    pub const nsStyleColor_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleColor() {
        assert_eq!(::std::mem::size_of::<nsStyleColor>() , 4usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleColor ) ));
        assert_eq! (::std::mem::align_of::<nsStyleColor>() , 4usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColor ) ) . mColor as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColor ) ,
                    "::" , stringify ! ( mColor ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleImageLayers {
        pub mAttachmentCount: u32,
        pub mClipCount: u32,
        pub mOriginCount: u32,
        pub mRepeatCount: u32,
        pub mPositionXCount: u32,
        pub mPositionYCount: u32,
        pub mImageCount: u32,
        pub mSizeCount: u32,
        pub mMaskModeCount: u32,
        pub mBlendModeCount: u32,
        pub mCompositeCount: u32,
        pub mLayers: root::nsStyleAutoArray<root::nsStyleImageLayers_Layer>,
    }
    pub const nsStyleImageLayers_shorthand:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::shorthand;
    pub const nsStyleImageLayers_color: root::nsStyleImageLayers__bindgen_ty_1
              =
        nsStyleImageLayers__bindgen_ty_1::color;
    pub const nsStyleImageLayers_image: root::nsStyleImageLayers__bindgen_ty_1
              =
        nsStyleImageLayers__bindgen_ty_1::image;
    pub const nsStyleImageLayers_repeat:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::repeat;
    pub const nsStyleImageLayers_positionX:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::positionX;
    pub const nsStyleImageLayers_positionY:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::positionY;
    pub const nsStyleImageLayers_clip: root::nsStyleImageLayers__bindgen_ty_1
              =
        nsStyleImageLayers__bindgen_ty_1::clip;
    pub const nsStyleImageLayers_origin:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::origin;
    pub const nsStyleImageLayers_size: root::nsStyleImageLayers__bindgen_ty_1
              =
        nsStyleImageLayers__bindgen_ty_1::size;
    pub const nsStyleImageLayers_attachment:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::attachment;
    pub const nsStyleImageLayers_maskMode:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::maskMode;
    pub const nsStyleImageLayers_composite:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::composite;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageLayers__bindgen_ty_1 {
        shorthand = 0,
        color = 1,
        image = 2,
        repeat = 3,
        positionX = 4,
        positionY = 5,
        clip = 6,
        origin = 7,
        size = 8,
        attachment = 9,
        maskMode = 10,
        composite = 11,
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageLayers_LayerType { Background = 0, Mask = 1, }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleImageLayers_Size {
        pub mWidth: root::nsStyleImageLayers_Size_Dimension,
        pub mHeight: root::nsStyleImageLayers_Size_Dimension,
        pub mWidthType: u8,
        pub mHeightType: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleImageLayers_Size_Dimension {
        pub _base: root::nsStyleCoord_CalcValue,
    }
    #[test]
    fn bindgen_test_layout_nsStyleImageLayers_Size_Dimension() {
        assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Size_Dimension>()
                   , 12usize , concat ! (
                   "Size of: " , stringify ! (
                   nsStyleImageLayers_Size_Dimension ) ));
        assert_eq! (::std::mem::align_of::<nsStyleImageLayers_Size_Dimension>()
                    , 4usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsStyleImageLayers_Size_Dimension ) ));
    }
    impl Clone for nsStyleImageLayers_Size_Dimension {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageLayers_Size_DimensionType {
        eContain = 0,
        eCover = 1,
        eAuto = 2,
        eLengthPercentage = 3,
        eDimensionType_COUNT = 4,
    }
    #[test]
    fn bindgen_test_layout_nsStyleImageLayers_Size() {
        assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Size>() , 28usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsStyleImageLayers_Size ) ));
        assert_eq! (::std::mem::align_of::<nsStyleImageLayers_Size>() , 4usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsStyleImageLayers_Size )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Size ) ) . mWidth
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Size ) , "::" , stringify ! ( mWidth )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Size ) ) . mHeight
                    as * const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Size ) , "::" , stringify ! ( mHeight )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Size ) ) .
                    mWidthType as * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Size ) , "::" , stringify ! (
                    mWidthType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Size ) ) .
                    mHeightType as * const _ as usize } , 25usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Size ) , "::" , stringify ! (
                    mHeightType ) ));
    }
    impl Clone for nsStyleImageLayers_Size {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleImageLayers_Repeat {
        pub mXRepeat: root::mozilla::StyleImageLayerRepeat,
        pub mYRepeat: root::mozilla::StyleImageLayerRepeat,
    }
    #[test]
    fn bindgen_test_layout_nsStyleImageLayers_Repeat() {
        assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Repeat>() , 2usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsStyleImageLayers_Repeat ) ));
        assert_eq! (::std::mem::align_of::<nsStyleImageLayers_Repeat>() ,
                    1usize , concat ! (
                    "Alignment of " , stringify ! ( nsStyleImageLayers_Repeat
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Repeat ) ) .
                    mXRepeat as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Repeat ) , "::" , stringify ! (
                    mXRepeat ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Repeat ) ) .
                    mYRepeat as * const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Repeat ) , "::" , stringify ! (
                    mYRepeat ) ));
    }
    impl Clone for nsStyleImageLayers_Repeat {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleImageLayers_Layer {
        pub mImage: root::nsStyleImage,
        pub mPosition: root::mozilla::Position,
        pub mSize: root::nsStyleImageLayers_Size,
        pub mClip: root::nsStyleImageLayers_Layer_StyleGeometryBox,
        pub mOrigin: root::nsStyleImageLayers_Layer_StyleGeometryBox,
        pub mAttachment: u8,
        pub mBlendMode: u8,
        pub mComposite: u8,
        pub mMaskMode: u8,
        pub mRepeat: root::nsStyleImageLayers_Repeat,
    }
    pub use self::super::root::mozilla::StyleGeometryBox as
            nsStyleImageLayers_Layer_StyleGeometryBox;
    #[test]
    fn bindgen_test_layout_nsStyleImageLayers_Layer() {
        assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Layer>() , 96usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsStyleImageLayers_Layer ) ));
        assert_eq! (::std::mem::align_of::<nsStyleImageLayers_Layer>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsStyleImageLayers_Layer )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) . mImage
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! ( mImage )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) .
                    mPosition as * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! (
                    mPosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) . mSize
                    as * const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! ( mSize )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) . mClip
                    as * const _ as usize } , 84usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! ( mClip )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) .
                    mOrigin as * const _ as usize } , 85usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! ( mOrigin
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) .
                    mAttachment as * const _ as usize } , 86usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! (
                    mAttachment ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) .
                    mBlendMode as * const _ as usize } , 87usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! (
                    mBlendMode ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) .
                    mComposite as * const _ as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! (
                    mComposite ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) .
                    mMaskMode as * const _ as usize } , 89usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! (
                    mMaskMode ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) .
                    mRepeat as * const _ as usize } , 90usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! ( mRepeat
                    ) ));
    }
    extern "C" {
        #[link_name = "_ZN18nsStyleImageLayers21kBackgroundLayerTableE"]
        pub static mut nsStyleImageLayers_kBackgroundLayerTable:
                   [root::nsCSSPropertyID; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN18nsStyleImageLayers15kMaskLayerTableE"]
        pub static mut nsStyleImageLayers_kMaskLayerTable:
                   [root::nsCSSPropertyID; 0usize];
    }
    #[test]
    fn bindgen_test_layout_nsStyleImageLayers() {
        assert_eq!(::std::mem::size_of::<nsStyleImageLayers>() , 152usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleImageLayers )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleImageLayers>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleImageLayers ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) .
                    mAttachmentCount as * const _ as usize } , 0usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mAttachmentCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) . mClipCount
                    as * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mClipCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) . mOriginCount
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mOriginCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) . mRepeatCount
                    as * const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mRepeatCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) .
                    mPositionXCount as * const _ as usize } , 16usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mPositionXCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) .
                    mPositionYCount as * const _ as usize } , 20usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mPositionYCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) . mImageCount
                    as * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mImageCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) . mSizeCount
                    as * const _ as usize } , 28usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mSizeCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) .
                    mMaskModeCount as * const _ as usize } , 32usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mMaskModeCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) .
                    mBlendModeCount as * const _ as usize } , 36usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mBlendModeCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) .
                    mCompositeCount as * const _ as usize } , 40usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mCompositeCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) . mLayers as *
                    const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mLayers ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleBackground {
        pub mImage: root::nsStyleImageLayers,
        pub mBackgroundColor: root::mozilla::StyleComplexColor,
    }
    pub const nsStyleBackground_kHasFinishStyle: bool = true;
    #[test]
    fn bindgen_test_layout_nsStyleBackground() {
        assert_eq!(::std::mem::size_of::<nsStyleBackground>() , 160usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleBackground )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleBackground>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleBackground ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBackground ) ) . mImage as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBackground )
                    , "::" , stringify ! ( mImage ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBackground ) ) .
                    mBackgroundColor as * const _ as usize } , 152usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBackground )
                    , "::" , stringify ! ( mBackgroundColor ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleMargin {
        pub mMargin: root::nsStyleSides,
    }
    pub const nsStyleMargin_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleMargin() {
        assert_eq!(::std::mem::size_of::<nsStyleMargin>() , 40usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleMargin ) ));
        assert_eq! (::std::mem::align_of::<nsStyleMargin>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleMargin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleMargin ) ) . mMargin as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleMargin ) ,
                    "::" , stringify ! ( mMargin ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStylePadding {
        pub mPadding: root::nsStyleSides,
    }
    pub const nsStylePadding_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStylePadding() {
        assert_eq!(::std::mem::size_of::<nsStylePadding>() , 40usize , concat
                   ! ( "Size of: " , stringify ! ( nsStylePadding ) ));
        assert_eq! (::std::mem::align_of::<nsStylePadding>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStylePadding ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePadding ) ) . mPadding as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePadding ) ,
                    "::" , stringify ! ( mPadding ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsBorderColors {
        pub mNext: *mut root::nsBorderColors,
        pub mColor: root::nscolor,
    }
    #[test]
    fn bindgen_test_layout_nsBorderColors() {
        assert_eq!(::std::mem::size_of::<nsBorderColors>() , 16usize , concat
                   ! ( "Size of: " , stringify ! ( nsBorderColors ) ));
        assert_eq! (::std::mem::align_of::<nsBorderColors>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsBorderColors ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsBorderColors ) ) . mNext as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsBorderColors ) ,
                    "::" , stringify ! ( mNext ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsBorderColors ) ) . mColor as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsBorderColors ) ,
                    "::" , stringify ! ( mColor ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSShadowItem {
        pub mXOffset: root::nscoord,
        pub mYOffset: root::nscoord,
        pub mRadius: root::nscoord,
        pub mSpread: root::nscoord,
        pub mColor: root::nscolor,
        pub mHasColor: bool,
        pub mInset: bool,
    }
    #[test]
    fn bindgen_test_layout_nsCSSShadowItem() {
        assert_eq!(::std::mem::size_of::<nsCSSShadowItem>() , 24usize , concat
                   ! ( "Size of: " , stringify ! ( nsCSSShadowItem ) ));
        assert_eq! (::std::mem::align_of::<nsCSSShadowItem>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSShadowItem ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowItem ) ) . mXOffset as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowItem ) ,
                    "::" , stringify ! ( mXOffset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowItem ) ) . mYOffset as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowItem ) ,
                    "::" , stringify ! ( mYOffset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowItem ) ) . mRadius as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowItem ) ,
                    "::" , stringify ! ( mRadius ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowItem ) ) . mSpread as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowItem ) ,
                    "::" , stringify ! ( mSpread ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowItem ) ) . mColor as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowItem ) ,
                    "::" , stringify ! ( mColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowItem ) ) . mHasColor as *
                    const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowItem ) ,
                    "::" , stringify ! ( mHasColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowItem ) ) . mInset as *
                    const _ as usize } , 21usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowItem ) ,
                    "::" , stringify ! ( mInset ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSShadowArray {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mLength: u32,
        pub mArray: [root::nsCSSShadowItem; 1usize],
    }
    pub type nsCSSShadowArray_HasThreadSafeRefCnt = root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsCSSShadowArray() {
        assert_eq!(::std::mem::size_of::<nsCSSShadowArray>() , 40usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCSSShadowArray )
                   ));
        assert_eq! (::std::mem::align_of::<nsCSSShadowArray>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSShadowArray ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowArray ) ) . mRefCnt as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowArray )
                    , "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowArray ) ) . mLength as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowArray )
                    , "::" , stringify ! ( mLength ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowArray ) ) . mArray as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowArray )
                    , "::" , stringify ! ( mArray ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleBorder {
        pub mBorderColors: *mut *mut root::nsBorderColors,
        pub mBorderRadius: root::nsStyleCorners,
        pub mBorderImageSource: root::nsStyleImage,
        pub mBorderImageSlice: root::nsStyleSides,
        pub mBorderImageWidth: root::nsStyleSides,
        pub mBorderImageOutset: root::nsStyleSides,
        pub mBorderImageFill: u8,
        pub mBorderImageRepeatH: u8,
        pub mBorderImageRepeatV: u8,
        pub mFloatEdge: root::mozilla::StyleFloatEdge,
        pub mBoxDecorationBreak: root::mozilla::StyleBoxDecorationBreak,
        pub mBorderStyle: [u8; 4usize],
        pub __bindgen_anon_1: root::nsStyleBorder__bindgen_ty_1,
        pub mComputedBorder: root::nsMargin,
        pub mBorder: root::nsMargin,
        pub mTwipsPerPixel: root::nscoord,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleBorder__bindgen_ty_1 {
        pub __bindgen_anon_1: root::__BindgenUnionField<root::nsStyleBorder__bindgen_ty_1__bindgen_ty_1>,
        pub mBorderColor: root::__BindgenUnionField<[root::mozilla::StyleComplexColor; 4usize]>,
        pub bindgen_union_field: [u32; 8usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleBorder__bindgen_ty_1__bindgen_ty_1 {
        pub mBorderTopColor: root::mozilla::StyleComplexColor,
        pub mBorderRightColor: root::mozilla::StyleComplexColor,
        pub mBorderBottomColor: root::mozilla::StyleComplexColor,
        pub mBorderLeftColor: root::mozilla::StyleComplexColor,
    }
    #[test]
    fn bindgen_test_layout_nsStyleBorder__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleBorder__bindgen_ty_1__bindgen_ty_1>()
                   , 32usize , concat ! (
                   "Size of: " , stringify ! (
                   nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) ));
        assert_eq! (::std::mem::align_of::<nsStyleBorder__bindgen_ty_1__bindgen_ty_1>()
                    , 4usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsStyleBorder__bindgen_ty_1__bindgen_ty_1
                    ) ) . mBorderTopColor as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mBorderTopColor ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsStyleBorder__bindgen_ty_1__bindgen_ty_1
                    ) ) . mBorderRightColor as * const _ as usize } , 8usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mBorderRightColor ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsStyleBorder__bindgen_ty_1__bindgen_ty_1
                    ) ) . mBorderBottomColor as * const _ as usize } , 16usize
                    , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mBorderBottomColor ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsStyleBorder__bindgen_ty_1__bindgen_ty_1
                    ) ) . mBorderLeftColor as * const _ as usize } , 24usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mBorderLeftColor ) ));
    }
    impl Clone for nsStyleBorder__bindgen_ty_1__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsStyleBorder__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleBorder__bindgen_ty_1>() ,
                   32usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleBorder__bindgen_ty_1 )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleBorder__bindgen_ty_1>() ,
                    4usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsStyleBorder__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder__bindgen_ty_1 ) ) .
                    mBorderColor as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleBorder__bindgen_ty_1 ) , "::" , stringify ! (
                    mBorderColor ) ));
    }
    impl Clone for nsStyleBorder__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    pub const nsStyleBorder_kHasFinishStyle: bool = true;
    #[test]
    fn bindgen_test_layout_nsStyleBorder() {
        assert_eq!(::std::mem::size_of::<nsStyleBorder>() , 312usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleBorder ) ));
        assert_eq! (::std::mem::align_of::<nsStyleBorder>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleBorder ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mBorderColors as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderColors ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mBorderRadius as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderRadius ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) .
                    mBorderImageSource as * const _ as usize } , 80usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderImageSource ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mBorderImageSlice
                    as * const _ as usize } , 112usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderImageSlice ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mBorderImageWidth
                    as * const _ as usize } , 152usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderImageWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) .
                    mBorderImageOutset as * const _ as usize } , 192usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderImageOutset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mBorderImageFill
                    as * const _ as usize } , 232usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderImageFill ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) .
                    mBorderImageRepeatH as * const _ as usize } , 233usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderImageRepeatH ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) .
                    mBorderImageRepeatV as * const _ as usize } , 234usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderImageRepeatV ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mFloatEdge as *
                    const _ as usize } , 235usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mFloatEdge ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) .
                    mBoxDecorationBreak as * const _ as usize } , 236usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBoxDecorationBreak ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mBorderStyle as *
                    const _ as usize } , 237usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mComputedBorder
                    as * const _ as usize } , 276usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mComputedBorder ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mBorder as *
                    const _ as usize } , 292usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorder ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mTwipsPerPixel as
                    * const _ as usize } , 308usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mTwipsPerPixel ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleOutline {
        pub mOutlineRadius: root::nsStyleCorners,
        pub mOutlineWidth: root::nscoord,
        pub mOutlineOffset: root::nscoord,
        pub mOutlineColor: root::mozilla::StyleComplexColor,
        pub mOutlineStyle: u8,
        pub mActualOutlineWidth: root::nscoord,
        pub mTwipsPerPixel: root::nscoord,
    }
    pub const nsStyleOutline_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleOutline() {
        assert_eq!(::std::mem::size_of::<nsStyleOutline>() , 104usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleOutline ) ));
        assert_eq! (::std::mem::align_of::<nsStyleOutline>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleOutline ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleOutline ) ) . mOutlineRadius
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleOutline ) ,
                    "::" , stringify ! ( mOutlineRadius ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleOutline ) ) . mOutlineWidth as
                    * const _ as usize } , 72usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleOutline ) ,
                    "::" , stringify ! ( mOutlineWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleOutline ) ) . mOutlineOffset
                    as * const _ as usize } , 76usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleOutline ) ,
                    "::" , stringify ! ( mOutlineOffset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleOutline ) ) . mOutlineColor as
                    * const _ as usize } , 80usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleOutline ) ,
                    "::" , stringify ! ( mOutlineColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleOutline ) ) . mOutlineStyle as
                    * const _ as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleOutline ) ,
                    "::" , stringify ! ( mOutlineStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleOutline ) ) .
                    mActualOutlineWidth as * const _ as usize } , 92usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleOutline ) ,
                    "::" , stringify ! ( mActualOutlineWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleOutline ) ) . mTwipsPerPixel
                    as * const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleOutline ) ,
                    "::" , stringify ! ( mTwipsPerPixel ) ));
    }
    /**
 * An object that allows sharing of arrays that store 'quotes' property
 * values.  This is particularly important for inheritance, where we want
 * to share the same 'quotes' value with a parent style context.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleQuoteValues {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mQuotePairs: root::nsStyleQuoteValues_QuotePairArray,
    }
    pub type nsStyleQuoteValues_QuotePairArray =
        root::nsTArray<root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr>>;
    pub type nsStyleQuoteValues_HasThreadSafeRefCnt = root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsStyleQuoteValues() {
        assert_eq!(::std::mem::size_of::<nsStyleQuoteValues>() , 16usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleQuoteValues )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleQuoteValues>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleQuoteValues ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleQuoteValues ) ) . mRefCnt as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleQuoteValues
                    ) , "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleQuoteValues ) ) . mQuotePairs
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleQuoteValues
                    ) , "::" , stringify ! ( mQuotePairs ) ));
    }
    #[test]
    fn __bindgen_test_layout_StaticRefPtr_instantiation_86() {
        assert_eq!(::std::mem::size_of::<root::mozilla::StaticRefPtr<root::nsStyleQuoteValues>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::StaticRefPtr<root::nsStyleQuoteValues> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::StaticRefPtr<root::nsStyleQuoteValues>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::StaticRefPtr<root::nsStyleQuoteValues> ) ));
    }
    #[test]
    fn __bindgen_test_layout_StaticRefPtr_instantiation_87() {
        assert_eq!(::std::mem::size_of::<root::mozilla::StaticRefPtr<root::nsStyleQuoteValues>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::StaticRefPtr<root::nsStyleQuoteValues> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::StaticRefPtr<root::nsStyleQuoteValues>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::StaticRefPtr<root::nsStyleQuoteValues> ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleList {
        pub mListStylePosition: u8,
        pub mListStyleImage: root::RefPtr<root::nsStyleImageRequest>,
        pub mCounterStyle: root::mozilla::CounterStylePtr,
        pub mQuotes: root::RefPtr<root::nsStyleQuoteValues>,
        pub mImageRegion: root::nsRect,
    }
    pub const nsStyleList_kHasFinishStyle: bool = true;
    extern "C" {
        #[link_name = "_ZN11nsStyleList14sInitialQuotesE"]
        pub static mut nsStyleList_sInitialQuotes:
                   root::mozilla::StaticRefPtr<root::nsStyleQuoteValues>;
    }
    extern "C" {
        #[link_name = "_ZN11nsStyleList11sNoneQuotesE"]
        pub static mut nsStyleList_sNoneQuotes:
                   root::mozilla::StaticRefPtr<root::nsStyleQuoteValues>;
    }
    #[test]
    fn bindgen_test_layout_nsStyleList() {
        assert_eq!(::std::mem::size_of::<nsStyleList>() , 48usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleList ) ));
        assert_eq! (::std::mem::align_of::<nsStyleList>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleList ) ) . mListStylePosition
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleList ) ,
                    "::" , stringify ! ( mListStylePosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleList ) ) . mListStyleImage as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleList ) ,
                    "::" , stringify ! ( mListStyleImage ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleList ) ) . mCounterStyle as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleList ) ,
                    "::" , stringify ! ( mCounterStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleList ) ) . mQuotes as * const
                    _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleList ) ,
                    "::" , stringify ! ( mQuotes ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleList ) ) . mImageRegion as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleList ) ,
                    "::" , stringify ! ( mImageRegion ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleGridLine {
        pub mHasSpan: bool,
        pub mInteger: i32,
        pub mLineName: ::nsstring::nsStringRepr,
    }
    pub const nsStyleGridLine_kMinLine: i32 = -10000;
    pub const nsStyleGridLine_kMaxLine: i32 = 10000;
    #[test]
    fn bindgen_test_layout_nsStyleGridLine() {
        assert_eq!(::std::mem::size_of::<nsStyleGridLine>() , 24usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleGridLine ) ));
        assert_eq! (::std::mem::align_of::<nsStyleGridLine>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleGridLine ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridLine ) ) . mHasSpan as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridLine ) ,
                    "::" , stringify ! ( mHasSpan ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridLine ) ) . mInteger as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridLine ) ,
                    "::" , stringify ! ( mInteger ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridLine ) ) . mLineName as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridLine ) ,
                    "::" , stringify ! ( mLineName ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleGridTemplate {
        pub mLineNameLists: root::nsTArray<root::nsTArray<::nsstring::nsStringRepr>>,
        pub mMinTrackSizingFunctions: root::nsTArray<root::nsStyleCoord>,
        pub mMaxTrackSizingFunctions: root::nsTArray<root::nsStyleCoord>,
        pub mRepeatAutoLineNameListBefore: root::nsTArray<::nsstring::nsStringRepr>,
        pub mRepeatAutoLineNameListAfter: root::nsTArray<::nsstring::nsStringRepr>,
        pub mRepeatAutoIndex: i16,
        pub _bitfield_1: u8,
        pub __bindgen_padding_0: [u8; 5usize],
    }
    #[test]
    fn bindgen_test_layout_nsStyleGridTemplate() {
        assert_eq!(::std::mem::size_of::<nsStyleGridTemplate>() , 48usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsStyleGridTemplate ) ));
        assert_eq! (::std::mem::align_of::<nsStyleGridTemplate>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleGridTemplate ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridTemplate ) ) .
                    mLineNameLists as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! ( nsStyleGridTemplate
                    ) , "::" , stringify ! ( mLineNameLists ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridTemplate ) ) .
                    mMinTrackSizingFunctions as * const _ as usize } , 8usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridTemplate
                    ) , "::" , stringify ! ( mMinTrackSizingFunctions ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridTemplate ) ) .
                    mMaxTrackSizingFunctions as * const _ as usize } , 16usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridTemplate
                    ) , "::" , stringify ! ( mMaxTrackSizingFunctions ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridTemplate ) ) .
                    mRepeatAutoLineNameListBefore as * const _ as usize } ,
                    24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridTemplate
                    ) , "::" , stringify ! ( mRepeatAutoLineNameListBefore )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridTemplate ) ) .
                    mRepeatAutoLineNameListAfter as * const _ as usize } ,
                    32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridTemplate
                    ) , "::" , stringify ! ( mRepeatAutoLineNameListAfter )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridTemplate ) ) .
                    mRepeatAutoIndex as * const _ as usize } , 40usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridTemplate
                    ) , "::" , stringify ! ( mRepeatAutoIndex ) ));
    }
    impl nsStyleGridTemplate {
        #[inline]
        pub fn mIsAutoFill(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 1u64 as u8;
            let val = (unit_field_val & mask) >> 0usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsAutoFill(&mut self, val: bool) {
            let mask = 1u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 0usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn mIsSubgrid(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 2u64 as u8;
            let val = (unit_field_val & mask) >> 1usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsSubgrid(&mut self, val: bool) {
            let mask = 2u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 1usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn new_bitfield_1(mIsAutoFill: bool, mIsSubgrid: bool) -> u8 {
            ({
                 ({ 0 } |
                      ((mIsAutoFill as u8 as u8) << 0usize) & (1u64 as u8))
             } | ((mIsSubgrid as u8 as u8) << 1usize) & (2u64 as u8))
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStylePosition {
        pub mObjectPosition: root::mozilla::Position,
        pub mOffset: root::nsStyleSides,
        pub mWidth: root::nsStyleCoord,
        pub mMinWidth: root::nsStyleCoord,
        pub mMaxWidth: root::nsStyleCoord,
        pub mHeight: root::nsStyleCoord,
        pub mMinHeight: root::nsStyleCoord,
        pub mMaxHeight: root::nsStyleCoord,
        pub mFlexBasis: root::nsStyleCoord,
        pub mGridAutoColumnsMin: root::nsStyleCoord,
        pub mGridAutoColumnsMax: root::nsStyleCoord,
        pub mGridAutoRowsMin: root::nsStyleCoord,
        pub mGridAutoRowsMax: root::nsStyleCoord,
        pub mGridAutoFlow: u8,
        pub mBoxSizing: root::mozilla::StyleBoxSizing,
        pub mAlignContent: u16,
        pub mAlignItems: u8,
        pub mAlignSelf: u8,
        pub mJustifyContent: u16,
        pub mJustifyItems: u8,
        pub mJustifySelf: u8,
        pub mFlexDirection: u8,
        pub mFlexWrap: u8,
        pub mObjectFit: u8,
        pub mOrder: i32,
        pub mFlexGrow: f32,
        pub mFlexShrink: f32,
        pub mZIndex: root::nsStyleCoord,
        pub mGridTemplateColumns: root::nsStyleGridTemplate,
        pub mGridTemplateRows: root::nsStyleGridTemplate,
        pub mGridTemplateAreas: root::RefPtr<root::mozilla::css::GridTemplateAreasValue>,
        pub mGridColumnStart: root::nsStyleGridLine,
        pub mGridColumnEnd: root::nsStyleGridLine,
        pub mGridRowStart: root::nsStyleGridLine,
        pub mGridRowEnd: root::nsStyleGridLine,
        pub mGridColumnGap: root::nsStyleCoord,
        pub mGridRowGap: root::nsStyleCoord,
    }
    pub const nsStylePosition_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStylePosition() {
        assert_eq!(::std::mem::size_of::<nsStylePosition>() , 520usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStylePosition )
                   ));
        assert_eq! (::std::mem::align_of::<nsStylePosition>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStylePosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mObjectPosition
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mObjectPosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mOffset as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mOffset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mWidth as *
                    const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mMinWidth as *
                    const _ as usize } , 80usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mMinWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mMaxWidth as *
                    const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mMaxWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mHeight as *
                    const _ as usize } , 112usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mHeight ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mMinHeight as *
                    const _ as usize } , 128usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mMinHeight ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mMaxHeight as *
                    const _ as usize } , 144usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mMaxHeight ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mFlexBasis as *
                    const _ as usize } , 160usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mFlexBasis ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridAutoColumnsMin as * const _ as usize } , 176usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridAutoColumnsMin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridAutoColumnsMax as * const _ as usize } , 192usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridAutoColumnsMax ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridAutoRowsMin as * const _ as usize } , 208usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridAutoRowsMin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridAutoRowsMax as * const _ as usize } , 224usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridAutoRowsMax ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mGridAutoFlow
                    as * const _ as usize } , 240usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridAutoFlow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mBoxSizing as *
                    const _ as usize } , 241usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mBoxSizing ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mAlignContent
                    as * const _ as usize } , 242usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mAlignContent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mAlignItems as
                    * const _ as usize } , 244usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mAlignItems ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mAlignSelf as *
                    const _ as usize } , 245usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mAlignSelf ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mJustifyContent
                    as * const _ as usize } , 246usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mJustifyContent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mJustifyItems
                    as * const _ as usize } , 248usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mJustifyItems ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mJustifySelf as
                    * const _ as usize } , 249usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mJustifySelf ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mFlexDirection
                    as * const _ as usize } , 250usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mFlexDirection ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mFlexWrap as *
                    const _ as usize } , 251usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mFlexWrap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mObjectFit as *
                    const _ as usize } , 252usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mObjectFit ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mOrder as *
                    const _ as usize } , 256usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mOrder ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mFlexGrow as *
                    const _ as usize } , 260usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mFlexGrow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mFlexShrink as
                    * const _ as usize } , 264usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mFlexShrink ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mZIndex as *
                    const _ as usize } , 272usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mZIndex ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridTemplateColumns as * const _ as usize } , 288usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridTemplateColumns ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridTemplateRows as * const _ as usize } , 336usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridTemplateRows ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridTemplateAreas as * const _ as usize } , 384usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridTemplateAreas ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridColumnStart as * const _ as usize } , 392usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridColumnStart ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mGridColumnEnd
                    as * const _ as usize } , 416usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridColumnEnd ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mGridRowStart
                    as * const _ as usize } , 440usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridRowStart ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mGridRowEnd as
                    * const _ as usize } , 464usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridRowEnd ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mGridColumnGap
                    as * const _ as usize } , 488usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridColumnGap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mGridRowGap as
                    * const _ as usize } , 504usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridRowGap ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleTextOverflowSide {
        pub mString: ::nsstring::nsStringRepr,
        pub mType: u8,
    }
    #[test]
    fn bindgen_test_layout_nsStyleTextOverflowSide() {
        assert_eq!(::std::mem::size_of::<nsStyleTextOverflowSide>() , 24usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsStyleTextOverflowSide ) ));
        assert_eq! (::std::mem::align_of::<nsStyleTextOverflowSide>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsStyleTextOverflowSide )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextOverflowSide ) ) . mString
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleTextOverflowSide ) , "::" , stringify ! ( mString )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextOverflowSide ) ) . mType
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleTextOverflowSide ) , "::" , stringify ! ( mType )
                    ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleTextOverflow {
        pub mLeft: root::nsStyleTextOverflowSide,
        pub mRight: root::nsStyleTextOverflowSide,
        pub mLogicalDirections: bool,
    }
    #[test]
    fn bindgen_test_layout_nsStyleTextOverflow() {
        assert_eq!(::std::mem::size_of::<nsStyleTextOverflow>() , 56usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsStyleTextOverflow ) ));
        assert_eq! (::std::mem::align_of::<nsStyleTextOverflow>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleTextOverflow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextOverflow ) ) . mLeft as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextOverflow
                    ) , "::" , stringify ! ( mLeft ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextOverflow ) ) . mRight as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextOverflow
                    ) , "::" , stringify ! ( mRight ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextOverflow ) ) .
                    mLogicalDirections as * const _ as usize } , 48usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextOverflow
                    ) , "::" , stringify ! ( mLogicalDirections ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleTextReset {
        pub mTextOverflow: root::nsStyleTextOverflow,
        pub mTextDecorationLine: u8,
        pub mTextDecorationStyle: u8,
        pub mUnicodeBidi: u8,
        pub mInitialLetterSink: root::nscoord,
        pub mInitialLetterSize: f32,
        pub mTextDecorationColor: root::mozilla::StyleComplexColor,
    }
    pub const nsStyleTextReset_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleTextReset() {
        assert_eq!(::std::mem::size_of::<nsStyleTextReset>() , 80usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleTextReset )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleTextReset>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleTextReset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextReset ) ) . mTextOverflow
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextReset )
                    , "::" , stringify ! ( mTextOverflow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextReset ) ) .
                    mTextDecorationLine as * const _ as usize } , 56usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextReset )
                    , "::" , stringify ! ( mTextDecorationLine ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextReset ) ) .
                    mTextDecorationStyle as * const _ as usize } , 57usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextReset )
                    , "::" , stringify ! ( mTextDecorationStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextReset ) ) . mUnicodeBidi
                    as * const _ as usize } , 58usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextReset )
                    , "::" , stringify ! ( mUnicodeBidi ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextReset ) ) .
                    mInitialLetterSink as * const _ as usize } , 60usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextReset )
                    , "::" , stringify ! ( mInitialLetterSink ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextReset ) ) .
                    mInitialLetterSize as * const _ as usize } , 64usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextReset )
                    , "::" , stringify ! ( mInitialLetterSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextReset ) ) .
                    mTextDecorationColor as * const _ as usize } , 68usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextReset )
                    , "::" , stringify ! ( mTextDecorationColor ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleText {
        pub mTextAlign: u8,
        pub mTextAlignLast: u8,
        pub _bitfield_1: u8,
        pub mTextJustify: root::mozilla::StyleTextJustify,
        pub mTextTransform: u8,
        pub mWhiteSpace: root::mozilla::StyleWhiteSpace,
        pub mWordBreak: u8,
        pub mOverflowWrap: u8,
        pub mHyphens: root::mozilla::StyleHyphens,
        pub mRubyAlign: u8,
        pub mRubyPosition: u8,
        pub mTextSizeAdjust: u8,
        pub mTextCombineUpright: u8,
        pub mControlCharacterVisibility: u8,
        pub mTextEmphasisPosition: u8,
        pub mTextEmphasisStyle: u8,
        pub mTextRendering: u8,
        pub mTextEmphasisColor: root::mozilla::StyleComplexColor,
        pub mWebkitTextFillColor: root::mozilla::StyleComplexColor,
        pub mWebkitTextStrokeColor: root::mozilla::StyleComplexColor,
        pub mTabSize: root::nsStyleCoord,
        pub mWordSpacing: root::nsStyleCoord,
        pub mLetterSpacing: root::nsStyleCoord,
        pub mLineHeight: root::nsStyleCoord,
        pub mTextIndent: root::nsStyleCoord,
        pub mWebkitTextStrokeWidth: root::nscoord,
        pub mTextShadow: root::RefPtr<root::nsCSSShadowArray>,
        pub mTextEmphasisStyleString: ::nsstring::nsStringRepr,
    }
    pub const nsStyleText_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleText() {
        assert_eq!(::std::mem::size_of::<nsStyleText>() , 160usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleText ) ));
        assert_eq! (::std::mem::align_of::<nsStyleText>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleText ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextAlign as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextAlign ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextAlignLast as *
                    const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextAlignLast ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextJustify as *
                    const _ as usize } , 3usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextJustify ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextTransform as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextTransform ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mWhiteSpace as *
                    const _ as usize } , 5usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mWhiteSpace ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mWordBreak as *
                    const _ as usize } , 6usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mWordBreak ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mOverflowWrap as *
                    const _ as usize } , 7usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mOverflowWrap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mHyphens as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mHyphens ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mRubyAlign as *
                    const _ as usize } , 9usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mRubyAlign ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mRubyPosition as *
                    const _ as usize } , 10usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mRubyPosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextSizeAdjust as
                    * const _ as usize } , 11usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextSizeAdjust ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextCombineUpright
                    as * const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextCombineUpright ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) .
                    mControlCharacterVisibility as * const _ as usize } ,
                    13usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mControlCharacterVisibility ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) .
                    mTextEmphasisPosition as * const _ as usize } , 14usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextEmphasisPosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextEmphasisStyle
                    as * const _ as usize } , 15usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextEmphasisStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextRendering as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextRendering ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextEmphasisColor
                    as * const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextEmphasisColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) .
                    mWebkitTextFillColor as * const _ as usize } , 28usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mWebkitTextFillColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) .
                    mWebkitTextStrokeColor as * const _ as usize } , 36usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mWebkitTextStrokeColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTabSize as * const
                    _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTabSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mWordSpacing as *
                    const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mWordSpacing ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mLetterSpacing as *
                    const _ as usize } , 80usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mLetterSpacing ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mLineHeight as *
                    const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mLineHeight ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextIndent as *
                    const _ as usize } , 112usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextIndent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) .
                    mWebkitTextStrokeWidth as * const _ as usize } , 128usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mWebkitTextStrokeWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextShadow as *
                    const _ as usize } , 136usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextShadow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) .
                    mTextEmphasisStyleString as * const _ as usize } ,
                    144usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextEmphasisStyleString ) ));
    }
    impl nsStyleText {
        #[inline]
        pub fn mTextAlignTrue(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 1u64 as u8;
            let val = (unit_field_val & mask) >> 0usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mTextAlignTrue(&mut self, val: bool) {
            let mask = 1u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 0usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn mTextAlignLastTrue(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 2u64 as u8;
            let val = (unit_field_val & mask) >> 1usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mTextAlignLastTrue(&mut self, val: bool) {
            let mask = 2u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 1usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn new_bitfield_1(mTextAlignTrue: bool, mTextAlignLastTrue: bool)
         -> u8 {
            ({
                 ({ 0 } |
                      ((mTextAlignTrue as u8 as u8) << 0usize) & (1u64 as u8))
             } | ((mTextAlignLastTrue as u8 as u8) << 1usize) & (2u64 as u8))
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleImageOrientation {
        pub mOrientation: u8,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageOrientation_Bits {
        ORIENTATION_MASK = 3,
        FLIP_MASK = 4,
        FROM_IMAGE_MASK = 8,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageOrientation_Angles {
        ANGLE_0 = 0,
        ANGLE_90 = 1,
        ANGLE_180 = 2,
        ANGLE_270 = 3,
    }
    #[test]
    fn bindgen_test_layout_nsStyleImageOrientation() {
        assert_eq!(::std::mem::size_of::<nsStyleImageOrientation>() , 1usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsStyleImageOrientation ) ));
        assert_eq! (::std::mem::align_of::<nsStyleImageOrientation>() , 1usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsStyleImageOrientation )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageOrientation ) ) .
                    mOrientation as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageOrientation ) , "::" , stringify ! (
                    mOrientation ) ));
    }
    impl Clone for nsStyleImageOrientation {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTimingFunction {
        pub mType: root::nsTimingFunction_Type,
        pub __bindgen_anon_1: root::nsTimingFunction__bindgen_ty_1,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsTimingFunction_Type {
        Ease = 0,
        Linear = 1,
        EaseIn = 2,
        EaseOut = 3,
        EaseInOut = 4,
        StepStart = 5,
        StepEnd = 6,
        CubicBezier = 7,
        Frames = 8,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsTimingFunction_Keyword { Implicit = 0, Explicit = 1, }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTimingFunction__bindgen_ty_1 {
        pub mFunc: root::__BindgenUnionField<root::nsTimingFunction__bindgen_ty_1__bindgen_ty_1>,
        pub __bindgen_anon_1: root::__BindgenUnionField<root::nsTimingFunction__bindgen_ty_1__bindgen_ty_2>,
        pub bindgen_union_field: [u32; 4usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTimingFunction__bindgen_ty_1__bindgen_ty_1 {
        pub mX1: f32,
        pub mY1: f32,
        pub mX2: f32,
        pub mY2: f32,
    }
    #[test]
    fn bindgen_test_layout_nsTimingFunction__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsTimingFunction__bindgen_ty_1__bindgen_ty_1>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) ));
        assert_eq! (::std::mem::align_of::<nsTimingFunction__bindgen_ty_1__bindgen_ty_1>()
                    , 4usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsTimingFunction__bindgen_ty_1__bindgen_ty_1
                    ) ) . mX1 as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mX1 ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsTimingFunction__bindgen_ty_1__bindgen_ty_1
                    ) ) . mY1 as * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mY1 ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsTimingFunction__bindgen_ty_1__bindgen_ty_1
                    ) ) . mX2 as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mX2 ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsTimingFunction__bindgen_ty_1__bindgen_ty_1
                    ) ) . mY2 as * const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mY2 ) ));
    }
    impl Clone for nsTimingFunction__bindgen_ty_1__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTimingFunction__bindgen_ty_1__bindgen_ty_2 {
        pub mStepsOrFrames: u32,
    }
    #[test]
    fn bindgen_test_layout_nsTimingFunction__bindgen_ty_1__bindgen_ty_2() {
        assert_eq!(::std::mem::size_of::<nsTimingFunction__bindgen_ty_1__bindgen_ty_2>()
                   , 4usize , concat ! (
                   "Size of: " , stringify ! (
                   nsTimingFunction__bindgen_ty_1__bindgen_ty_2 ) ));
        assert_eq! (::std::mem::align_of::<nsTimingFunction__bindgen_ty_1__bindgen_ty_2>()
                    , 4usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsTimingFunction__bindgen_ty_1__bindgen_ty_2 ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsTimingFunction__bindgen_ty_1__bindgen_ty_2
                    ) ) . mStepsOrFrames as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTimingFunction__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                    stringify ! ( mStepsOrFrames ) ));
    }
    impl Clone for nsTimingFunction__bindgen_ty_1__bindgen_ty_2 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsTimingFunction__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsTimingFunction__bindgen_ty_1>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( nsTimingFunction__bindgen_ty_1
                   ) ));
        assert_eq! (::std::mem::align_of::<nsTimingFunction__bindgen_ty_1>() ,
                    4usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsTimingFunction__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsTimingFunction__bindgen_ty_1 ) ) .
                    mFunc as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTimingFunction__bindgen_ty_1 ) , "::" , stringify ! (
                    mFunc ) ));
    }
    impl Clone for nsTimingFunction__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsTimingFunction() {
        assert_eq!(::std::mem::size_of::<nsTimingFunction>() , 20usize ,
                   concat ! ( "Size of: " , stringify ! ( nsTimingFunction )
                   ));
        assert_eq! (::std::mem::align_of::<nsTimingFunction>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsTimingFunction ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsTimingFunction ) ) . mType as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsTimingFunction )
                    , "::" , stringify ! ( mType ) ));
    }
    impl Clone for nsTimingFunction {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct BindingHolder {
        pub mPtr: root::RefPtr<root::mozilla::css::URLValue>,
    }
    #[test]
    fn bindgen_test_layout_BindingHolder() {
        assert_eq!(::std::mem::size_of::<BindingHolder>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( BindingHolder ) ));
        assert_eq! (::std::mem::align_of::<BindingHolder>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( BindingHolder ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const BindingHolder ) ) . mPtr as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( BindingHolder ) ,
                    "::" , stringify ! ( mPtr ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleTable {
        pub mLayoutStrategy: u8,
        pub mSpan: i32,
    }
    pub const nsStyleTable_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleTable() {
        assert_eq!(::std::mem::size_of::<nsStyleTable>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleTable ) ));
        assert_eq! (::std::mem::align_of::<nsStyleTable>() , 4usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTable ) ) . mLayoutStrategy as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTable ) ,
                    "::" , stringify ! ( mLayoutStrategy ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTable ) ) . mSpan as * const _
                    as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTable ) ,
                    "::" , stringify ! ( mSpan ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleTableBorder {
        pub mBorderSpacingCol: root::nscoord,
        pub mBorderSpacingRow: root::nscoord,
        pub mBorderCollapse: u8,
        pub mCaptionSide: u8,
        pub mEmptyCells: u8,
    }
    pub const nsStyleTableBorder_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleTableBorder() {
        assert_eq!(::std::mem::size_of::<nsStyleTableBorder>() , 12usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleTableBorder )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleTableBorder>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleTableBorder ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTableBorder ) ) .
                    mBorderSpacingCol as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTableBorder
                    ) , "::" , stringify ! ( mBorderSpacingCol ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTableBorder ) ) .
                    mBorderSpacingRow as * const _ as usize } , 4usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTableBorder
                    ) , "::" , stringify ! ( mBorderSpacingRow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTableBorder ) ) .
                    mBorderCollapse as * const _ as usize } , 8usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleTableBorder
                    ) , "::" , stringify ! ( mBorderCollapse ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTableBorder ) ) . mCaptionSide
                    as * const _ as usize } , 9usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTableBorder
                    ) , "::" , stringify ! ( mCaptionSide ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTableBorder ) ) . mEmptyCells
                    as * const _ as usize } , 10usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTableBorder
                    ) , "::" , stringify ! ( mEmptyCells ) ));
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleContentType {
        eStyleContentType_String = 1,
        eStyleContentType_Image = 10,
        eStyleContentType_Attr = 20,
        eStyleContentType_Counter = 30,
        eStyleContentType_Counters = 31,
        eStyleContentType_OpenQuote = 40,
        eStyleContentType_CloseQuote = 41,
        eStyleContentType_NoOpenQuote = 42,
        eStyleContentType_NoCloseQuote = 43,
        eStyleContentType_AltContent = 50,
        eStyleContentType_Uninitialized = 51,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleContentData {
        pub mType: root::nsStyleContentType,
        pub mContent: root::nsStyleContentData__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleContentData_CounterFunction {
        pub mIdent: ::nsstring::nsStringRepr,
        pub mSeparator: ::nsstring::nsStringRepr,
        pub mCounterStyle: root::mozilla::CounterStylePtr,
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
    }
    pub type nsStyleContentData_CounterFunction_HasThreadSafeRefCnt =
        root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsStyleContentData_CounterFunction() {
        assert_eq!(::std::mem::size_of::<nsStyleContentData_CounterFunction>()
                   , 48usize , concat ! (
                   "Size of: " , stringify ! (
                   nsStyleContentData_CounterFunction ) ));
        assert_eq! (::std::mem::align_of::<nsStyleContentData_CounterFunction>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsStyleContentData_CounterFunction ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData_CounterFunction )
                    ) . mIdent as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleContentData_CounterFunction ) , "::" , stringify !
                    ( mIdent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData_CounterFunction )
                    ) . mSeparator as * const _ as usize } , 16usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleContentData_CounterFunction ) , "::" , stringify !
                    ( mSeparator ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData_CounterFunction )
                    ) . mCounterStyle as * const _ as usize } , 32usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleContentData_CounterFunction ) , "::" , stringify !
                    ( mCounterStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData_CounterFunction )
                    ) . mRefCnt as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleContentData_CounterFunction ) , "::" , stringify !
                    ( mRefCnt ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleContentData__bindgen_ty_1 {
        pub mString: root::__BindgenUnionField<*mut u16>,
        pub mImage: root::__BindgenUnionField<*mut root::nsStyleImageRequest>,
        pub mCounters: root::__BindgenUnionField<*mut root::nsStyleContentData_CounterFunction>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsStyleContentData__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleContentData__bindgen_ty_1>() ,
                   8usize , concat ! (
                   "Size of: " , stringify ! (
                   nsStyleContentData__bindgen_ty_1 ) ));
        assert_eq! (::std::mem::align_of::<nsStyleContentData__bindgen_ty_1>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsStyleContentData__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData__bindgen_ty_1 ) )
                    . mString as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleContentData__bindgen_ty_1 ) , "::" , stringify ! (
                    mString ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData__bindgen_ty_1 ) )
                    . mImage as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleContentData__bindgen_ty_1 ) , "::" , stringify ! (
                    mImage ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData__bindgen_ty_1 ) )
                    . mCounters as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleContentData__bindgen_ty_1 ) , "::" , stringify ! (
                    mCounters ) ));
    }
    impl Clone for nsStyleContentData__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsStyleContentData() {
        assert_eq!(::std::mem::size_of::<nsStyleContentData>() , 16usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleContentData )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleContentData>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleContentData ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData ) ) . mType as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleContentData
                    ) , "::" , stringify ! ( mType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData ) ) . mContent as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleContentData
                    ) , "::" , stringify ! ( mContent ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleCounterData {
        pub mCounter: ::nsstring::nsStringRepr,
        pub mValue: i32,
    }
    #[test]
    fn bindgen_test_layout_nsStyleCounterData() {
        assert_eq!(::std::mem::size_of::<nsStyleCounterData>() , 24usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleCounterData )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleCounterData>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleCounterData ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCounterData ) ) . mCounter as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleCounterData
                    ) , "::" , stringify ! ( mCounter ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCounterData ) ) . mValue as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleCounterData
                    ) , "::" , stringify ! ( mValue ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleContent {
        pub mContents: root::nsTArray<root::nsStyleContentData>,
        pub mIncrements: root::nsTArray<root::nsStyleCounterData>,
        pub mResets: root::nsTArray<root::nsStyleCounterData>,
    }
    pub const nsStyleContent_kHasFinishStyle: bool = true;
    #[test]
    fn bindgen_test_layout_nsStyleContent() {
        assert_eq!(::std::mem::size_of::<nsStyleContent>() , 24usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleContent ) ));
        assert_eq! (::std::mem::align_of::<nsStyleContent>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleContent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContent ) ) . mContents as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleContent ) ,
                    "::" , stringify ! ( mContents ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContent ) ) . mIncrements as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleContent ) ,
                    "::" , stringify ! ( mIncrements ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContent ) ) . mResets as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleContent ) ,
                    "::" , stringify ! ( mResets ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleUIReset {
        pub mUserSelect: root::mozilla::StyleUserSelect,
        pub mForceBrokenImageIcon: u8,
        pub mIMEMode: u8,
        pub mWindowDragging: root::mozilla::StyleWindowDragging,
        pub mWindowShadow: u8,
        pub mWindowOpacity: f32,
        pub mSpecifiedWindowTransform: root::RefPtr<root::nsCSSValueSharedList>,
        pub mWindowTransformOrigin: [root::nsStyleCoord; 2usize],
    }
    pub const nsStyleUIReset_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleUIReset() {
        assert_eq!(::std::mem::size_of::<nsStyleUIReset>() , 56usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleUIReset ) ));
        assert_eq! (::std::mem::align_of::<nsStyleUIReset>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleUIReset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUIReset ) ) . mUserSelect as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUIReset ) ,
                    "::" , stringify ! ( mUserSelect ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUIReset ) ) .
                    mForceBrokenImageIcon as * const _ as usize } , 1usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUIReset ) ,
                    "::" , stringify ! ( mForceBrokenImageIcon ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUIReset ) ) . mIMEMode as *
                    const _ as usize } , 2usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUIReset ) ,
                    "::" , stringify ! ( mIMEMode ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUIReset ) ) . mWindowDragging
                    as * const _ as usize } , 3usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUIReset ) ,
                    "::" , stringify ! ( mWindowDragging ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUIReset ) ) . mWindowShadow as
                    * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUIReset ) ,
                    "::" , stringify ! ( mWindowShadow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUIReset ) ) . mWindowOpacity
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUIReset ) ,
                    "::" , stringify ! ( mWindowOpacity ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUIReset ) ) .
                    mSpecifiedWindowTransform as * const _ as usize } ,
                    16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUIReset ) ,
                    "::" , stringify ! ( mSpecifiedWindowTransform ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUIReset ) ) .
                    mWindowTransformOrigin as * const _ as usize } , 24usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUIReset ) ,
                    "::" , stringify ! ( mWindowTransformOrigin ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCursorImage {
        pub mHaveHotspot: bool,
        pub mHotspotX: f32,
        pub mHotspotY: f32,
        pub mImage: root::RefPtr<root::nsStyleImageRequest>,
    }
    #[test]
    fn bindgen_test_layout_nsCursorImage() {
        assert_eq!(::std::mem::size_of::<nsCursorImage>() , 24usize , concat !
                   ( "Size of: " , stringify ! ( nsCursorImage ) ));
        assert_eq! (::std::mem::align_of::<nsCursorImage>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsCursorImage ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCursorImage ) ) . mHaveHotspot as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCursorImage ) ,
                    "::" , stringify ! ( mHaveHotspot ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCursorImage ) ) . mHotspotX as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCursorImage ) ,
                    "::" , stringify ! ( mHotspotX ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCursorImage ) ) . mHotspotY as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCursorImage ) ,
                    "::" , stringify ! ( mHotspotY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCursorImage ) ) . mImage as * const
                    _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCursorImage ) ,
                    "::" , stringify ! ( mImage ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleUserInterface {
        pub mUserInput: root::mozilla::StyleUserInput,
        pub mUserModify: root::mozilla::StyleUserModify,
        pub mUserFocus: root::mozilla::StyleUserFocus,
        pub mPointerEvents: u8,
        pub mCursor: u8,
        pub mCursorImages: root::nsTArray<root::nsCursorImage>,
        pub mCaretColor: root::mozilla::StyleComplexColor,
    }
    pub const nsStyleUserInterface_kHasFinishStyle: bool = true;
    #[test]
    fn bindgen_test_layout_nsStyleUserInterface() {
        assert_eq!(::std::mem::size_of::<nsStyleUserInterface>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsStyleUserInterface ) ));
        assert_eq! (::std::mem::align_of::<nsStyleUserInterface>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleUserInterface ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUserInterface ) ) . mUserInput
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleUserInterface ) , "::" , stringify ! ( mUserInput )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUserInterface ) ) .
                    mUserModify as * const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleUserInterface ) , "::" , stringify ! ( mUserModify
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUserInterface ) ) . mUserFocus
                    as * const _ as usize } , 2usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleUserInterface ) , "::" , stringify ! ( mUserFocus )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUserInterface ) ) .
                    mPointerEvents as * const _ as usize } , 3usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsStyleUserInterface ) , "::" , stringify ! (
                    mPointerEvents ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUserInterface ) ) . mCursor as
                    * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleUserInterface ) , "::" , stringify ! ( mCursor )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUserInterface ) ) .
                    mCursorImages as * const _ as usize } , 8usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsStyleUserInterface ) , "::" , stringify ! (
                    mCursorImages ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUserInterface ) ) .
                    mCaretColor as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleUserInterface ) , "::" , stringify ! ( mCaretColor
                    ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleXUL {
        pub mBoxFlex: f32,
        pub mBoxOrdinal: u32,
        pub mBoxAlign: root::mozilla::StyleBoxAlign,
        pub mBoxDirection: root::mozilla::StyleBoxDirection,
        pub mBoxOrient: root::mozilla::StyleBoxOrient,
        pub mBoxPack: root::mozilla::StyleBoxPack,
        pub mStackSizing: root::mozilla::StyleStackSizing,
    }
    pub const nsStyleXUL_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleXUL() {
        assert_eq!(::std::mem::size_of::<nsStyleXUL>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleXUL ) ));
        assert_eq! (::std::mem::align_of::<nsStyleXUL>() , 4usize , concat ! (
                    "Alignment of " , stringify ! ( nsStyleXUL ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleXUL ) ) . mBoxFlex as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::"
                    , stringify ! ( mBoxFlex ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleXUL ) ) . mBoxOrdinal as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::"
                    , stringify ! ( mBoxOrdinal ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleXUL ) ) . mBoxAlign as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::"
                    , stringify ! ( mBoxAlign ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleXUL ) ) . mBoxDirection as *
                    const _ as usize } , 9usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::"
                    , stringify ! ( mBoxDirection ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleXUL ) ) . mBoxOrient as *
                    const _ as usize } , 10usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::"
                    , stringify ! ( mBoxOrient ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleXUL ) ) . mBoxPack as * const
                    _ as usize } , 11usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::"
                    , stringify ! ( mBoxPack ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleXUL ) ) . mStackSizing as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::"
                    , stringify ! ( mStackSizing ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleColumn {
        pub mColumnCount: u32,
        pub mColumnWidth: root::nsStyleCoord,
        pub mColumnGap: root::nsStyleCoord,
        pub mColumnRuleColor: root::mozilla::StyleComplexColor,
        pub mColumnRuleStyle: u8,
        pub mColumnFill: u8,
        pub mColumnSpan: u8,
        pub mColumnRuleWidth: root::nscoord,
        pub mTwipsPerPixel: root::nscoord,
    }
    pub const nsStyleColumn_kHasFinishStyle: bool = false;
    pub const nsStyleColumn_kMaxColumnCount: u32 = 1000;
    #[test]
    fn bindgen_test_layout_nsStyleColumn() {
        assert_eq!(::std::mem::size_of::<nsStyleColumn>() , 64usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleColumn ) ));
        assert_eq! (::std::mem::align_of::<nsStyleColumn>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleColumn ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnCount as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnWidth as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnGap as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnGap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnRuleColor
                    as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnRuleColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnRuleStyle
                    as * const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnRuleStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnFill as *
                    const _ as usize } , 49usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnFill ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnSpan as *
                    const _ as usize } , 50usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnSpan ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnRuleWidth
                    as * const _ as usize } , 52usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnRuleWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mTwipsPerPixel as
                    * const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mTwipsPerPixel ) ));
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleSVGPaintType {
        eStyleSVGPaintType_None = 1,
        eStyleSVGPaintType_Color = 2,
        eStyleSVGPaintType_Server = 3,
        eStyleSVGPaintType_ContextFill = 4,
        eStyleSVGPaintType_ContextStroke = 5,
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleSVGFallbackType {
        eStyleSVGFallbackType_NotSet = 0,
        eStyleSVGFallbackType_None = 1,
        eStyleSVGFallbackType_Color = 2,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleSVGPaint {
        pub mPaint: root::nsStyleSVGPaint__bindgen_ty_1,
        pub mType: root::nsStyleSVGPaintType,
        pub mFallbackType: root::nsStyleSVGFallbackType,
        pub mFallbackColor: root::nscolor,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleSVGPaint__bindgen_ty_1 {
        pub mColor: root::__BindgenUnionField<root::nscolor>,
        pub mPaintServer: root::__BindgenUnionField<*mut root::mozilla::css::URLValue>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsStyleSVGPaint__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleSVGPaint__bindgen_ty_1>() ,
                   8usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleSVGPaint__bindgen_ty_1 )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleSVGPaint__bindgen_ty_1>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsStyleSVGPaint__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGPaint__bindgen_ty_1 ) ) .
                    mColor as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleSVGPaint__bindgen_ty_1 ) , "::" , stringify ! (
                    mColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGPaint__bindgen_ty_1 ) ) .
                    mPaintServer as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleSVGPaint__bindgen_ty_1 ) , "::" , stringify ! (
                    mPaintServer ) ));
    }
    impl Clone for nsStyleSVGPaint__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsStyleSVGPaint() {
        assert_eq!(::std::mem::size_of::<nsStyleSVGPaint>() , 16usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleSVGPaint ) ));
        assert_eq! (::std::mem::align_of::<nsStyleSVGPaint>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleSVGPaint ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGPaint ) ) . mPaint as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGPaint ) ,
                    "::" , stringify ! ( mPaint ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGPaint ) ) . mType as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGPaint ) ,
                    "::" , stringify ! ( mType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGPaint ) ) . mFallbackType
                    as * const _ as usize } , 9usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGPaint ) ,
                    "::" , stringify ! ( mFallbackType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGPaint ) ) . mFallbackColor
                    as * const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGPaint ) ,
                    "::" , stringify ! ( mFallbackColor ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleSVG {
        pub mFill: root::nsStyleSVGPaint,
        pub mStroke: root::nsStyleSVGPaint,
        pub mMarkerEnd: root::RefPtr<root::mozilla::css::URLValue>,
        pub mMarkerMid: root::RefPtr<root::mozilla::css::URLValue>,
        pub mMarkerStart: root::RefPtr<root::mozilla::css::URLValue>,
        pub mStrokeDasharray: root::nsTArray<root::nsStyleCoord>,
        pub mContextProps: root::nsTArray<root::nsCOMPtr>,
        pub mStrokeDashoffset: root::nsStyleCoord,
        pub mStrokeWidth: root::nsStyleCoord,
        pub mFillOpacity: f32,
        pub mStrokeMiterlimit: f32,
        pub mStrokeOpacity: f32,
        pub mClipRule: root::mozilla::StyleFillRule,
        pub mColorInterpolation: u8,
        pub mColorInterpolationFilters: u8,
        pub mFillRule: root::mozilla::StyleFillRule,
        pub mPaintOrder: u8,
        pub mShapeRendering: u8,
        pub mStrokeLinecap: u8,
        pub mStrokeLinejoin: u8,
        pub mTextAnchor: u8,
        pub mContextPropsBits: u8,
        pub mContextFlags: u8,
    }
    pub const nsStyleSVG_FILL_OPACITY_SOURCE_MASK:
              root::nsStyleSVG__bindgen_ty_1 =
        nsStyleSVG__bindgen_ty_1::FILL_OPACITY_SOURCE_MASK;
    pub const nsStyleSVG_STROKE_OPACITY_SOURCE_MASK:
              root::nsStyleSVG__bindgen_ty_1 =
        nsStyleSVG__bindgen_ty_1::STROKE_OPACITY_SOURCE_MASK;
    pub const nsStyleSVG_STROKE_DASHARRAY_CONTEXT:
              root::nsStyleSVG__bindgen_ty_1 =
        nsStyleSVG__bindgen_ty_1::STROKE_DASHARRAY_CONTEXT;
    pub const nsStyleSVG_STROKE_DASHOFFSET_CONTEXT:
              root::nsStyleSVG__bindgen_ty_1 =
        nsStyleSVG__bindgen_ty_1::STROKE_DASHOFFSET_CONTEXT;
    pub const nsStyleSVG_STROKE_WIDTH_CONTEXT: root::nsStyleSVG__bindgen_ty_1
              =
        nsStyleSVG__bindgen_ty_1::STROKE_WIDTH_CONTEXT;
    pub const nsStyleSVG_FILL_OPACITY_SOURCE_SHIFT:
              root::nsStyleSVG__bindgen_ty_1 =
        nsStyleSVG__bindgen_ty_1::FILL_OPACITY_SOURCE_SHIFT;
    pub const nsStyleSVG_STROKE_OPACITY_SOURCE_SHIFT:
              root::nsStyleSVG__bindgen_ty_1 =
        nsStyleSVG__bindgen_ty_1::STROKE_OPACITY_SOURCE_SHIFT;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleSVG__bindgen_ty_1 {
        FILL_OPACITY_SOURCE_MASK = 3,
        STROKE_OPACITY_SOURCE_MASK = 12,
        STROKE_DASHARRAY_CONTEXT = 16,
        STROKE_DASHOFFSET_CONTEXT = 32,
        STROKE_WIDTH_CONTEXT = 64,
        FILL_OPACITY_SOURCE_SHIFT = 0,
        STROKE_OPACITY_SOURCE_SHIFT = 2,
    }
    pub const nsStyleSVG_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleSVG() {
        assert_eq!(::std::mem::size_of::<nsStyleSVG>() , 128usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleSVG ) ));
        assert_eq! (::std::mem::align_of::<nsStyleSVG>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsStyleSVG ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mFill as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mFill ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStroke as * const _
                    as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStroke ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mMarkerEnd as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mMarkerEnd ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mMarkerMid as *
                    const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mMarkerMid ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mMarkerStart as *
                    const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mMarkerStart ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeDasharray as
                    * const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStrokeDasharray ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mContextProps as *
                    const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mContextProps ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeDashoffset as
                    * const _ as usize } , 72usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStrokeDashoffset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeWidth as *
                    const _ as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStrokeWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mFillOpacity as *
                    const _ as usize } , 104usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mFillOpacity ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeMiterlimit as
                    * const _ as usize } , 108usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStrokeMiterlimit ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeOpacity as *
                    const _ as usize } , 112usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStrokeOpacity ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mClipRule as * const
                    _ as usize } , 116usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mClipRule ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mColorInterpolation
                    as * const _ as usize } , 117usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mColorInterpolation ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) .
                    mColorInterpolationFilters as * const _ as usize } ,
                    118usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mColorInterpolationFilters ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mFillRule as * const
                    _ as usize } , 119usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mFillRule ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mPaintOrder as *
                    const _ as usize } , 120usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mPaintOrder ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mShapeRendering as *
                    const _ as usize } , 121usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mShapeRendering ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeLinecap as *
                    const _ as usize } , 122usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStrokeLinecap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeLinejoin as *
                    const _ as usize } , 123usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStrokeLinejoin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mTextAnchor as *
                    const _ as usize } , 124usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mTextAnchor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mContextPropsBits as
                    * const _ as usize } , 125usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mContextPropsBits ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mContextFlags as *
                    const _ as usize } , 126usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mContextFlags ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleFilter {
        pub mType: u32,
        pub mFilterParameter: root::nsStyleCoord,
        pub __bindgen_anon_1: root::nsStyleFilter__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleFilter__bindgen_ty_1 {
        pub mURL: root::__BindgenUnionField<*mut root::mozilla::css::URLValue>,
        pub mDropShadow: root::__BindgenUnionField<*mut root::nsCSSShadowArray>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsStyleFilter__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleFilter__bindgen_ty_1>() ,
                   8usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleFilter__bindgen_ty_1 )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleFilter__bindgen_ty_1>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsStyleFilter__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFilter__bindgen_ty_1 ) ) .
                    mURL as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleFilter__bindgen_ty_1 ) , "::" , stringify ! ( mURL
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFilter__bindgen_ty_1 ) ) .
                    mDropShadow as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleFilter__bindgen_ty_1 ) , "::" , stringify ! (
                    mDropShadow ) ));
    }
    impl Clone for nsStyleFilter__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    pub const nsStyleFilter_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleFilter() {
        assert_eq!(::std::mem::size_of::<nsStyleFilter>() , 32usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleFilter ) ));
        assert_eq! (::std::mem::align_of::<nsStyleFilter>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleFilter ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFilter ) ) . mType as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFilter ) ,
                    "::" , stringify ! ( mType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFilter ) ) . mFilterParameter
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFilter ) ,
                    "::" , stringify ! ( mFilterParameter ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleSVGReset {
        pub mMask: root::nsStyleImageLayers,
        pub mClipPath: root::mozilla::StyleShapeSource,
        pub mStopColor: root::nscolor,
        pub mFloodColor: root::nscolor,
        pub mLightingColor: root::nscolor,
        pub mStopOpacity: f32,
        pub mFloodOpacity: f32,
        pub mDominantBaseline: u8,
        pub mVectorEffect: u8,
        pub mMaskType: u8,
    }
    pub const nsStyleSVGReset_kHasFinishStyle: bool = true;
    #[test]
    fn bindgen_test_layout_nsStyleSVGReset() {
        assert_eq!(::std::mem::size_of::<nsStyleSVGReset>() , 192usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleSVGReset )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleSVGReset>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleSVGReset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mMask as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mMask ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mClipPath as *
                    const _ as usize } , 152usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mClipPath ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mStopColor as *
                    const _ as usize } , 168usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mStopColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mFloodColor as
                    * const _ as usize } , 172usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mFloodColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mLightingColor
                    as * const _ as usize } , 176usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mLightingColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mStopOpacity as
                    * const _ as usize } , 180usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mStopOpacity ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mFloodOpacity
                    as * const _ as usize } , 184usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mFloodOpacity ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) .
                    mDominantBaseline as * const _ as usize } , 188usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mDominantBaseline ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mVectorEffect
                    as * const _ as usize } , 189usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mVectorEffect ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mMaskType as *
                    const _ as usize } , 190usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mMaskType ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleVariables {
        pub mVariables: root::mozilla::CSSVariableValues,
    }
    pub const nsStyleVariables_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleVariables() {
        assert_eq!(::std::mem::size_of::<nsStyleVariables>() , 48usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleVariables )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleVariables>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleVariables ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVariables ) ) . mVariables as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleVariables )
                    , "::" , stringify ! ( mVariables ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleEffects {
        pub mFilters: root::nsTArray<root::nsStyleFilter>,
        pub mBoxShadow: root::RefPtr<root::nsCSSShadowArray>,
        pub mClip: root::nsRect,
        pub mOpacity: f32,
        pub mClipFlags: u8,
        pub mMixBlendMode: u8,
    }
    pub const nsStyleEffects_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleEffects() {
        assert_eq!(::std::mem::size_of::<nsStyleEffects>() , 40usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleEffects ) ));
        assert_eq! (::std::mem::align_of::<nsStyleEffects>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleEffects ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleEffects ) ) . mFilters as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleEffects ) ,
                    "::" , stringify ! ( mFilters ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleEffects ) ) . mBoxShadow as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleEffects ) ,
                    "::" , stringify ! ( mBoxShadow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleEffects ) ) . mClip as * const
                    _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleEffects ) ,
                    "::" , stringify ! ( mClip ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleEffects ) ) . mOpacity as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleEffects ) ,
                    "::" , stringify ! ( mOpacity ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleEffects ) ) . mClipFlags as *
                    const _ as usize } , 36usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleEffects ) ,
                    "::" , stringify ! ( mClipFlags ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleEffects ) ) . mMixBlendMode as
                    * const _ as usize } , 37usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleEffects ) ,
                    "::" , stringify ! ( mMixBlendMode ) ));
    }
    /**
 * These *_Simple types are used to map Gecko types to layout-equivalent but
 * simpler Rust types, to aid Rust binding generation.
 *
 * If something in this types or the assertions below needs to change, ask
 * bholley, heycam or emilio before!
 *
 * <div rustbindgen="true" replaces="nsPoint">
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsPoint {
        pub x: root::nscoord,
        pub y: root::nscoord,
    }
    #[test]
    fn bindgen_test_layout_nsPoint() {
        assert_eq!(::std::mem::size_of::<nsPoint>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsPoint ) ));
        assert_eq! (::std::mem::align_of::<nsPoint>() , 4usize , concat ! (
                    "Alignment of " , stringify ! ( nsPoint ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPoint ) ) . x as * const _ as usize
                    } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPoint ) , "::" ,
                    stringify ! ( x ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPoint ) ) . y as * const _ as usize
                    } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPoint ) , "::" ,
                    stringify ! ( y ) ));
    }
    impl Clone for nsPoint {
        fn clone(&self) -> Self { *self }
    }
    /**
 * <div rustbindgen="true" replaces="nsMargin">
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsMargin {
        pub top: root::nscoord,
        pub right: root::nscoord,
        pub bottom: root::nscoord,
        pub left: root::nscoord,
    }
    #[test]
    fn bindgen_test_layout_nsMargin() {
        assert_eq!(::std::mem::size_of::<nsMargin>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsMargin ) ));
        assert_eq! (::std::mem::align_of::<nsMargin>() , 4usize , concat ! (
                    "Alignment of " , stringify ! ( nsMargin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMargin ) ) . top as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMargin ) , "::" ,
                    stringify ! ( top ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMargin ) ) . right as * const _ as
                    usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMargin ) , "::" ,
                    stringify ! ( right ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMargin ) ) . bottom as * const _ as
                    usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMargin ) , "::" ,
                    stringify ! ( bottom ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMargin ) ) . left as * const _ as
                    usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMargin ) , "::" ,
                    stringify ! ( left ) ));
    }
    impl Clone for nsMargin {
        fn clone(&self) -> Self { *self }
    }
    /**
 * <div rustbindgen="true" replaces="nsRect">
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsRect {
        pub x: root::nscoord,
        pub y: root::nscoord,
        pub width: root::nscoord,
        pub height: root::nscoord,
    }
    #[test]
    fn bindgen_test_layout_nsRect() {
        assert_eq!(::std::mem::size_of::<nsRect>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsRect ) ));
        assert_eq! (::std::mem::align_of::<nsRect>() , 4usize , concat ! (
                    "Alignment of " , stringify ! ( nsRect ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRect ) ) . x as * const _ as usize
                    } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsRect ) , "::" ,
                    stringify ! ( x ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRect ) ) . y as * const _ as usize
                    } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsRect ) , "::" ,
                    stringify ! ( y ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRect ) ) . width as * const _ as
                    usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsRect ) , "::" ,
                    stringify ! ( width ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRect ) ) . height as * const _ as
                    usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsRect ) , "::" ,
                    stringify ! ( height ) ));
    }
    impl Clone for nsRect {
        fn clone(&self) -> Self { *self }
    }
    /**
 * <div rustbindgen="true" replaces="nsSize">
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsSize {
        pub width: root::nscoord,
        pub height: root::nscoord,
    }
    #[test]
    fn bindgen_test_layout_nsSize() {
        assert_eq!(::std::mem::size_of::<nsSize>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsSize ) ));
        assert_eq! (::std::mem::align_of::<nsSize>() , 4usize , concat ! (
                    "Alignment of " , stringify ! ( nsSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSize ) ) . width as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSize ) , "::" ,
                    stringify ! ( width ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSize ) ) . height as * const _ as
                    usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSize ) , "::" ,
                    stringify ! ( height ) ));
    }
    impl Clone for nsSize {
        fn clone(&self) -> Self { *self }
    }
    /**
 * <div rustbindgen replaces="nsTArray"></div>
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsTArray<T> {
        pub mBuffer: *mut T,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    /**
 * <div rustbindgen replaces="nsCOMArray"></div>
 *
 * mozilla::ArrayIterator doesn't work well with bindgen.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCOMArray {
        pub mBuffer: root::nsTArray<*mut root::nsISupports>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RawServoStyleSet {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RawServoAnimationValueMap {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RawServoStyleSheet {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RawServoDeclarationBlock {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RawServoStyleRule {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RawServoAnimationValue {
        _unused: [u8; 0],
    }
    pub mod nsStyleTransformMatrix {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum MatrixTransformOperator { Interpolate = 0, Accumulate = 1, }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsCSSPropertyIDSet {
        _unused: [u8; 0],
    }
    pub type RawGeckoNode = root::nsINode;
    pub type RawGeckoElement = root::mozilla::dom::Element;
    pub type RawGeckoDocument = root::nsIDocument;
    pub type RawGeckoPresContext = root::nsPresContext;
    pub type RawGeckoXBLBinding = root::nsXBLBinding;
    pub type RawGeckoURLExtraData = root::mozilla::URLExtraData;
    pub type RawGeckoServoAnimationValueList =
        root::nsTArray<root::RefPtr<root::RawServoAnimationValue>>;
    pub type RawGeckoKeyframeList = root::nsTArray<root::mozilla::Keyframe>;
    pub type RawGeckoComputedKeyframeValuesList =
        root::nsTArray<root::nsTArray<root::mozilla::PropertyStyleAnimationValuePair>>;
    pub type RawGeckoStyleAnimationList =
        root::nsStyleAutoArray<root::mozilla::StyleAnimation>;
    pub type RawGeckoFontFaceRuleList =
        root::nsTArray<root::nsFontFaceRuleContainer>;
    pub type RawGeckoAnimationPropertySegment =
        root::mozilla::AnimationPropertySegment;
    pub type RawGeckoComputedTiming = root::mozilla::ComputedTiming;
    pub type RawGeckoServoStyleRuleList =
        root::nsTArray<*const root::RawServoStyleRule>;
    pub type RawGeckoCSSPropertyIDList =
        root::nsTArray<root::nsCSSPropertyID>;
    pub type RawGeckoGfxMatrix4x4 = [root::mozilla::gfx::Float; 16usize];
    pub type RawGeckoStyleChildrenIterator =
        root::mozilla::dom::StyleChildrenIterator;
    pub type RawServoAnimationValueMapBorrowedMut =
        *mut root::RawServoAnimationValueMap;
    pub type RawGeckoNodeBorrowed = *const root::RawGeckoNode;
    pub type RawGeckoNodeBorrowedOrNull = *const root::RawGeckoNode;
    pub type RawGeckoElementBorrowed = *const root::RawGeckoElement;
    pub type RawGeckoElementBorrowedOrNull = *const root::RawGeckoElement;
    pub type RawGeckoDocumentBorrowed = *const root::RawGeckoDocument;
    pub type RawGeckoDocumentBorrowedOrNull = *const root::RawGeckoDocument;
    pub type RawGeckoXBLBindingBorrowed = *const root::RawGeckoXBLBinding;
    pub type RawGeckoXBLBindingBorrowedOrNull =
        *const root::RawGeckoXBLBinding;
    pub type RawGeckoPresContextOwned = *mut root::RawGeckoPresContext;
    pub type RawGeckoPresContextBorrowed = *const root::RawGeckoPresContext;
    pub type RawGeckoPresContextBorrowedMut = *mut root::RawGeckoPresContext;
    pub type RawGeckoServoAnimationValueListBorrowedMut =
        *mut root::RawGeckoServoAnimationValueList;
    pub type RawGeckoServoAnimationValueListBorrowed =
        *const root::RawGeckoServoAnimationValueList;
    pub type RawGeckoKeyframeListBorrowedMut =
        *mut root::RawGeckoKeyframeList;
    pub type RawGeckoKeyframeListBorrowed = *const root::RawGeckoKeyframeList;
    pub type RawGeckoComputedKeyframeValuesListBorrowedMut =
        *mut root::RawGeckoComputedKeyframeValuesList;
    pub type RawGeckoStyleAnimationListBorrowed =
        *const root::RawGeckoStyleAnimationList;
    pub type RawGeckoFontFaceRuleListBorrowedMut =
        *mut root::RawGeckoFontFaceRuleList;
    pub type RawGeckoAnimationPropertySegmentBorrowed =
        *const root::RawGeckoAnimationPropertySegment;
    pub type RawGeckoComputedTimingBorrowed =
        *const root::RawGeckoComputedTiming;
    pub type RawGeckoServoStyleRuleListBorrowedMut =
        *mut root::RawGeckoServoStyleRuleList;
    pub type RawGeckoCSSPropertyIDListBorrowed =
        *const root::RawGeckoCSSPropertyIDList;
    pub type RawGeckoStyleChildrenIteratorBorrowedMut =
        *mut root::RawGeckoStyleChildrenIterator;
    pub const ThemeWidgetType_NS_THEME_NONE: root::ThemeWidgetType = 0;
    pub const ThemeWidgetType_NS_THEME_BUTTON: root::ThemeWidgetType = 1;
    pub const ThemeWidgetType_NS_THEME_RADIO: root::ThemeWidgetType = 2;
    pub const ThemeWidgetType_NS_THEME_CHECKBOX: root::ThemeWidgetType = 3;
    pub const ThemeWidgetType_NS_THEME_BUTTON_BEVEL: root::ThemeWidgetType =
        4;
    pub const ThemeWidgetType_NS_THEME_FOCUS_OUTLINE: root::ThemeWidgetType =
        5;
    pub const ThemeWidgetType_NS_THEME_TOOLBOX: root::ThemeWidgetType = 6;
    pub const ThemeWidgetType_NS_THEME_TOOLBAR: root::ThemeWidgetType = 7;
    pub const ThemeWidgetType_NS_THEME_TOOLBARBUTTON: root::ThemeWidgetType =
        8;
    pub const ThemeWidgetType_NS_THEME_DUALBUTTON: root::ThemeWidgetType = 9;
    pub const ThemeWidgetType_NS_THEME_TOOLBARBUTTON_DROPDOWN:
              root::ThemeWidgetType =
        10;
    pub const ThemeWidgetType_NS_THEME_BUTTON_ARROW_UP: root::ThemeWidgetType
              =
        11;
    pub const ThemeWidgetType_NS_THEME_BUTTON_ARROW_DOWN:
              root::ThemeWidgetType =
        12;
    pub const ThemeWidgetType_NS_THEME_BUTTON_ARROW_NEXT:
              root::ThemeWidgetType =
        13;
    pub const ThemeWidgetType_NS_THEME_BUTTON_ARROW_PREVIOUS:
              root::ThemeWidgetType =
        14;
    pub const ThemeWidgetType_NS_THEME_SEPARATOR: root::ThemeWidgetType = 15;
    pub const ThemeWidgetType_NS_THEME_TOOLBARGRIPPER: root::ThemeWidgetType =
        16;
    pub const ThemeWidgetType_NS_THEME_SPLITTER: root::ThemeWidgetType = 17;
    pub const ThemeWidgetType_NS_THEME_STATUSBAR: root::ThemeWidgetType = 18;
    pub const ThemeWidgetType_NS_THEME_STATUSBARPANEL: root::ThemeWidgetType =
        19;
    pub const ThemeWidgetType_NS_THEME_RESIZERPANEL: root::ThemeWidgetType =
        20;
    pub const ThemeWidgetType_NS_THEME_RESIZER: root::ThemeWidgetType = 21;
    pub const ThemeWidgetType_NS_THEME_LISTBOX: root::ThemeWidgetType = 22;
    pub const ThemeWidgetType_NS_THEME_LISTITEM: root::ThemeWidgetType = 23;
    pub const ThemeWidgetType_NS_THEME_TREEVIEW: root::ThemeWidgetType = 24;
    pub const ThemeWidgetType_NS_THEME_TREEITEM: root::ThemeWidgetType = 25;
    pub const ThemeWidgetType_NS_THEME_TREETWISTY: root::ThemeWidgetType = 26;
    pub const ThemeWidgetType_NS_THEME_TREELINE: root::ThemeWidgetType = 27;
    pub const ThemeWidgetType_NS_THEME_TREEHEADER: root::ThemeWidgetType = 28;
    pub const ThemeWidgetType_NS_THEME_TREEHEADERCELL: root::ThemeWidgetType =
        29;
    pub const ThemeWidgetType_NS_THEME_TREEHEADERSORTARROW:
              root::ThemeWidgetType =
        30;
    pub const ThemeWidgetType_NS_THEME_TREETWISTYOPEN: root::ThemeWidgetType =
        31;
    pub const ThemeWidgetType_NS_THEME_PROGRESSBAR: root::ThemeWidgetType =
        32;
    pub const ThemeWidgetType_NS_THEME_PROGRESSCHUNK: root::ThemeWidgetType =
        33;
    pub const ThemeWidgetType_NS_THEME_PROGRESSBAR_VERTICAL:
              root::ThemeWidgetType =
        34;
    pub const ThemeWidgetType_NS_THEME_PROGRESSCHUNK_VERTICAL:
              root::ThemeWidgetType =
        35;
    pub const ThemeWidgetType_NS_THEME_METERBAR: root::ThemeWidgetType = 36;
    pub const ThemeWidgetType_NS_THEME_METERCHUNK: root::ThemeWidgetType = 37;
    pub const ThemeWidgetType_NS_THEME_TAB: root::ThemeWidgetType = 38;
    pub const ThemeWidgetType_NS_THEME_TABPANEL: root::ThemeWidgetType = 39;
    pub const ThemeWidgetType_NS_THEME_TABPANELS: root::ThemeWidgetType = 40;
    pub const ThemeWidgetType_NS_THEME_TAB_SCROLL_ARROW_BACK:
              root::ThemeWidgetType =
        41;
    pub const ThemeWidgetType_NS_THEME_TAB_SCROLL_ARROW_FORWARD:
              root::ThemeWidgetType =
        42;
    pub const ThemeWidgetType_NS_THEME_TOOLTIP: root::ThemeWidgetType = 43;
    pub const ThemeWidgetType_NS_THEME_SPINNER: root::ThemeWidgetType = 44;
    pub const ThemeWidgetType_NS_THEME_SPINNER_UPBUTTON: root::ThemeWidgetType
              =
        45;
    pub const ThemeWidgetType_NS_THEME_SPINNER_DOWNBUTTON:
              root::ThemeWidgetType =
        46;
    pub const ThemeWidgetType_NS_THEME_SPINNER_TEXTFIELD:
              root::ThemeWidgetType =
        47;
    pub const ThemeWidgetType_NS_THEME_NUMBER_INPUT: root::ThemeWidgetType =
        48;
    pub const ThemeWidgetType_NS_THEME_SCROLLBAR: root::ThemeWidgetType = 49;
    pub const ThemeWidgetType_NS_THEME_SCROLLBAR_SMALL: root::ThemeWidgetType
              =
        50;
    pub const ThemeWidgetType_NS_THEME_SCROLLBAR_HORIZONTAL:
              root::ThemeWidgetType =
        51;
    pub const ThemeWidgetType_NS_THEME_SCROLLBAR_VERTICAL:
              root::ThemeWidgetType =
        52;
    pub const ThemeWidgetType_NS_THEME_SCROLLBARBUTTON_UP:
              root::ThemeWidgetType =
        53;
    pub const ThemeWidgetType_NS_THEME_SCROLLBARBUTTON_DOWN:
              root::ThemeWidgetType =
        54;
    pub const ThemeWidgetType_NS_THEME_SCROLLBARBUTTON_LEFT:
              root::ThemeWidgetType =
        55;
    pub const ThemeWidgetType_NS_THEME_SCROLLBARBUTTON_RIGHT:
              root::ThemeWidgetType =
        56;
    pub const ThemeWidgetType_NS_THEME_SCROLLBARTRACK_HORIZONTAL:
              root::ThemeWidgetType =
        57;
    pub const ThemeWidgetType_NS_THEME_SCROLLBARTRACK_VERTICAL:
              root::ThemeWidgetType =
        58;
    pub const ThemeWidgetType_NS_THEME_SCROLLBARTHUMB_HORIZONTAL:
              root::ThemeWidgetType =
        59;
    pub const ThemeWidgetType_NS_THEME_SCROLLBARTHUMB_VERTICAL:
              root::ThemeWidgetType =
        60;
    pub const ThemeWidgetType_NS_THEME_SCROLLBAR_NON_DISAPPEARING:
              root::ThemeWidgetType =
        61;
    pub const ThemeWidgetType_NS_THEME_TEXTFIELD: root::ThemeWidgetType = 62;
    pub const ThemeWidgetType_NS_THEME_CARET: root::ThemeWidgetType = 63;
    pub const ThemeWidgetType_NS_THEME_TEXTFIELD_MULTILINE:
              root::ThemeWidgetType =
        64;
    pub const ThemeWidgetType_NS_THEME_SEARCHFIELD: root::ThemeWidgetType =
        65;
    pub const ThemeWidgetType_NS_THEME_MENULIST: root::ThemeWidgetType = 66;
    pub const ThemeWidgetType_NS_THEME_MENULIST_BUTTON: root::ThemeWidgetType
              =
        67;
    pub const ThemeWidgetType_NS_THEME_MENULIST_TEXT: root::ThemeWidgetType =
        68;
    pub const ThemeWidgetType_NS_THEME_MENULIST_TEXTFIELD:
              root::ThemeWidgetType =
        69;
    pub const ThemeWidgetType_NS_THEME_SCALE_HORIZONTAL: root::ThemeWidgetType
              =
        70;
    pub const ThemeWidgetType_NS_THEME_SCALE_VERTICAL: root::ThemeWidgetType =
        71;
    pub const ThemeWidgetType_NS_THEME_SCALETHUMB_HORIZONTAL:
              root::ThemeWidgetType =
        72;
    pub const ThemeWidgetType_NS_THEME_SCALETHUMB_VERTICAL:
              root::ThemeWidgetType =
        73;
    pub const ThemeWidgetType_NS_THEME_SCALETHUMBSTART: root::ThemeWidgetType
              =
        74;
    pub const ThemeWidgetType_NS_THEME_SCALETHUMBEND: root::ThemeWidgetType =
        75;
    pub const ThemeWidgetType_NS_THEME_SCALETHUMBTICK: root::ThemeWidgetType =
        76;
    pub const ThemeWidgetType_NS_THEME_RANGE: root::ThemeWidgetType = 77;
    pub const ThemeWidgetType_NS_THEME_RANGE_THUMB: root::ThemeWidgetType =
        78;
    pub const ThemeWidgetType_NS_THEME_GROUPBOX: root::ThemeWidgetType = 79;
    pub const ThemeWidgetType_NS_THEME_CHECKBOX_CONTAINER:
              root::ThemeWidgetType =
        80;
    pub const ThemeWidgetType_NS_THEME_RADIO_CONTAINER: root::ThemeWidgetType
              =
        81;
    pub const ThemeWidgetType_NS_THEME_CHECKBOX_LABEL: root::ThemeWidgetType =
        82;
    pub const ThemeWidgetType_NS_THEME_RADIO_LABEL: root::ThemeWidgetType =
        83;
    pub const ThemeWidgetType_NS_THEME_BUTTON_FOCUS: root::ThemeWidgetType =
        84;
    pub const ThemeWidgetType_NS_THEME_WINDOW: root::ThemeWidgetType = 85;
    pub const ThemeWidgetType_NS_THEME_DIALOG: root::ThemeWidgetType = 86;
    pub const ThemeWidgetType_NS_THEME_MENUBAR: root::ThemeWidgetType = 87;
    pub const ThemeWidgetType_NS_THEME_MENUPOPUP: root::ThemeWidgetType = 88;
    pub const ThemeWidgetType_NS_THEME_MENUITEM: root::ThemeWidgetType = 89;
    pub const ThemeWidgetType_NS_THEME_CHECKMENUITEM: root::ThemeWidgetType =
        90;
    pub const ThemeWidgetType_NS_THEME_RADIOMENUITEM: root::ThemeWidgetType =
        91;
    pub const ThemeWidgetType_NS_THEME_MENUCHECKBOX: root::ThemeWidgetType =
        92;
    pub const ThemeWidgetType_NS_THEME_MENURADIO: root::ThemeWidgetType = 93;
    pub const ThemeWidgetType_NS_THEME_MENUSEPARATOR: root::ThemeWidgetType =
        94;
    pub const ThemeWidgetType_NS_THEME_MENUARROW: root::ThemeWidgetType = 95;
    pub const ThemeWidgetType_NS_THEME_MENUIMAGE: root::ThemeWidgetType = 96;
    pub const ThemeWidgetType_NS_THEME_MENUITEMTEXT: root::ThemeWidgetType =
        97;
    pub const ThemeWidgetType_NS_THEME_WIN_COMMUNICATIONS_TOOLBOX:
              root::ThemeWidgetType =
        98;
    pub const ThemeWidgetType_NS_THEME_WIN_MEDIA_TOOLBOX:
              root::ThemeWidgetType =
        99;
    pub const ThemeWidgetType_NS_THEME_WIN_BROWSERTABBAR_TOOLBOX:
              root::ThemeWidgetType =
        100;
    pub const ThemeWidgetType_NS_THEME_MAC_FULLSCREEN_BUTTON:
              root::ThemeWidgetType =
        101;
    pub const ThemeWidgetType_NS_THEME_MAC_HELP_BUTTON: root::ThemeWidgetType
              =
        102;
    pub const ThemeWidgetType_NS_THEME_WIN_BORDERLESS_GLASS:
              root::ThemeWidgetType =
        103;
    pub const ThemeWidgetType_NS_THEME_WIN_GLASS: root::ThemeWidgetType = 104;
    pub const ThemeWidgetType_NS_THEME_WINDOW_TITLEBAR: root::ThemeWidgetType
              =
        105;
    pub const ThemeWidgetType_NS_THEME_WINDOW_TITLEBAR_MAXIMIZED:
              root::ThemeWidgetType =
        106;
    pub const ThemeWidgetType_NS_THEME_WINDOW_FRAME_LEFT:
              root::ThemeWidgetType =
        107;
    pub const ThemeWidgetType_NS_THEME_WINDOW_FRAME_RIGHT:
              root::ThemeWidgetType =
        108;
    pub const ThemeWidgetType_NS_THEME_WINDOW_FRAME_BOTTOM:
              root::ThemeWidgetType =
        109;
    pub const ThemeWidgetType_NS_THEME_WINDOW_BUTTON_CLOSE:
              root::ThemeWidgetType =
        110;
    pub const ThemeWidgetType_NS_THEME_WINDOW_BUTTON_MINIMIZE:
              root::ThemeWidgetType =
        111;
    pub const ThemeWidgetType_NS_THEME_WINDOW_BUTTON_MAXIMIZE:
              root::ThemeWidgetType =
        112;
    pub const ThemeWidgetType_NS_THEME_WINDOW_BUTTON_RESTORE:
              root::ThemeWidgetType =
        113;
    pub const ThemeWidgetType_NS_THEME_WINDOW_BUTTON_BOX:
              root::ThemeWidgetType =
        114;
    pub const ThemeWidgetType_NS_THEME_WINDOW_BUTTON_BOX_MAXIMIZED:
              root::ThemeWidgetType =
        115;
    pub const ThemeWidgetType_NS_THEME_WIN_EXCLUDE_GLASS:
              root::ThemeWidgetType =
        116;
    pub const ThemeWidgetType_NS_THEME_MAC_VIBRANCY_LIGHT:
              root::ThemeWidgetType =
        117;
    pub const ThemeWidgetType_NS_THEME_MAC_VIBRANCY_DARK:
              root::ThemeWidgetType =
        118;
    pub const ThemeWidgetType_NS_THEME_MAC_DISCLOSURE_BUTTON_OPEN:
              root::ThemeWidgetType =
        119;
    pub const ThemeWidgetType_NS_THEME_MAC_DISCLOSURE_BUTTON_CLOSED:
              root::ThemeWidgetType =
        120;
    pub const ThemeWidgetType_NS_THEME_GTK_INFO_BAR: root::ThemeWidgetType =
        121;
    pub const ThemeWidgetType_NS_THEME_MAC_SOURCE_LIST: root::ThemeWidgetType
              =
        122;
    pub const ThemeWidgetType_NS_THEME_MAC_SOURCE_LIST_SELECTION:
              root::ThemeWidgetType =
        123;
    pub const ThemeWidgetType_NS_THEME_MAC_ACTIVE_SOURCE_LIST_SELECTION:
              root::ThemeWidgetType =
        124;
    pub const ThemeWidgetType_ThemeWidgetType_COUNT: root::ThemeWidgetType =
        125;
    pub type ThemeWidgetType = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIConsoleReportCollector {
        _unused: [u8; 0],
    }
    /**
 * An nsMediaQueryResultCacheKey records what feature/value combinations
 * a set of media query results are valid for.  This allows the caller
 * to quickly learn whether a prior result of media query evaluation is
 * still valid (e.g., due to a window size change) without rerunning all
 * of the evaluation and rebuilding the list of rules.
 *
 * This object may not be used after any media rules in any of the
 * sheets it was given to have been modified.  However, this is
 * generally not a problem since ClearRuleCascades is called on the
 * sheet whenever this happens, and these objects are stored inside the
 * rule cascades.  (FIXME: We're not actually doing this all the time.)
 *
 * The implementation could be further optimized in the future to store
 * ranges (combinations of less-than, less-than-or-equal, greater-than,
 * greater-than-or-equal, equal, not-equal, present, not-present) for
 * each feature rather than simply storing the list of expressions.
 * However, this requires combining any such ranges.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMediaQueryResultCacheKey {
        pub mMedium: root::nsCOMPtr,
        pub mFeatureCache: root::nsTArray<root::nsMediaQueryResultCacheKey_FeatureEntry>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMediaQueryResultCacheKey_ExpressionEntry {
        pub mExpression: root::nsMediaExpression,
        pub mExpressionMatches: bool,
    }
    #[test]
    fn bindgen_test_layout_nsMediaQueryResultCacheKey_ExpressionEntry() {
        assert_eq!(::std::mem::size_of::<nsMediaQueryResultCacheKey_ExpressionEntry>()
                   , 40usize , concat ! (
                   "Size of: " , stringify ! (
                   nsMediaQueryResultCacheKey_ExpressionEntry ) ));
        assert_eq! (::std::mem::align_of::<nsMediaQueryResultCacheKey_ExpressionEntry>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsMediaQueryResultCacheKey_ExpressionEntry ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsMediaQueryResultCacheKey_ExpressionEntry )
                    ) . mExpression as * const _ as usize } , 0usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsMediaQueryResultCacheKey_ExpressionEntry ) , "::" ,
                    stringify ! ( mExpression ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsMediaQueryResultCacheKey_ExpressionEntry )
                    ) . mExpressionMatches as * const _ as usize } , 32usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsMediaQueryResultCacheKey_ExpressionEntry ) , "::" ,
                    stringify ! ( mExpressionMatches ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMediaQueryResultCacheKey_FeatureEntry {
        pub mFeature: *const root::nsMediaFeature,
        pub mExpressions: root::nsTArray<root::nsMediaQueryResultCacheKey_ExpressionEntry>,
    }
    #[test]
    fn bindgen_test_layout_nsMediaQueryResultCacheKey_FeatureEntry() {
        assert_eq!(::std::mem::size_of::<nsMediaQueryResultCacheKey_FeatureEntry>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsMediaQueryResultCacheKey_FeatureEntry ) ));
        assert_eq! (::std::mem::align_of::<nsMediaQueryResultCacheKey_FeatureEntry>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsMediaQueryResultCacheKey_FeatureEntry ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsMediaQueryResultCacheKey_FeatureEntry )
                    ) . mFeature as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsMediaQueryResultCacheKey_FeatureEntry ) , "::" ,
                    stringify ! ( mFeature ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsMediaQueryResultCacheKey_FeatureEntry )
                    ) . mExpressions as * const _ as usize } , 8usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsMediaQueryResultCacheKey_FeatureEntry ) , "::" ,
                    stringify ! ( mExpressions ) ));
    }
    #[test]
    fn bindgen_test_layout_nsMediaQueryResultCacheKey() {
        assert_eq!(::std::mem::size_of::<nsMediaQueryResultCacheKey>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( nsMediaQueryResultCacheKey )
                   ));
        assert_eq! (::std::mem::align_of::<nsMediaQueryResultCacheKey>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsMediaQueryResultCacheKey
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaQueryResultCacheKey ) ) .
                    mMedium as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsMediaQueryResultCacheKey ) , "::" , stringify ! (
                    mMedium ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaQueryResultCacheKey ) ) .
                    mFeatureCache as * const _ as usize } , 8usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsMediaQueryResultCacheKey ) , "::" , stringify ! (
                    mFeatureCache ) ));
    }
    /**
 * Utility class to provide scaling defined in a keySplines element.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsSMILKeySpline {
        pub mX1: f64,
        pub mY1: f64,
        pub mX2: f64,
        pub mY2: f64,
        pub mSampleValues: [f64; 11usize],
    }
    pub const nsSMILKeySpline_kSplineTableSize:
              root::nsSMILKeySpline__bindgen_ty_1 =
        nsSMILKeySpline__bindgen_ty_1::kSplineTableSize;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsSMILKeySpline__bindgen_ty_1 { kSplineTableSize = 11, }
    extern "C" {
        #[link_name = "_ZN15nsSMILKeySpline15kSampleStepSizeE"]
        pub static nsSMILKeySpline_kSampleStepSize: f64;
    }
    #[test]
    fn bindgen_test_layout_nsSMILKeySpline() {
        assert_eq!(::std::mem::size_of::<nsSMILKeySpline>() , 120usize ,
                   concat ! ( "Size of: " , stringify ! ( nsSMILKeySpline )
                   ));
        assert_eq! (::std::mem::align_of::<nsSMILKeySpline>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsSMILKeySpline ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSMILKeySpline ) ) . mX1 as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSMILKeySpline ) ,
                    "::" , stringify ! ( mX1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSMILKeySpline ) ) . mY1 as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSMILKeySpline ) ,
                    "::" , stringify ! ( mY1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSMILKeySpline ) ) . mX2 as * const
                    _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSMILKeySpline ) ,
                    "::" , stringify ! ( mX2 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSMILKeySpline ) ) . mY2 as * const
                    _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSMILKeySpline ) ,
                    "::" , stringify ! ( mY2 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSMILKeySpline ) ) . mSampleValues
                    as * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSMILKeySpline ) ,
                    "::" , stringify ! ( mSampleValues ) ));
    }
    impl Clone for nsSMILKeySpline {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsSVGAngle {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsSVGIntegerPair {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsSVGLength2 {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsSVGNumberPair {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsSVGViewBox {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsStyledElement {
        _unused: [u8; 0],
    }
    /**
 * A class used to construct a nsString from a nsStringBuffer (we might
 * want to move this to nsString at some point).
 *
 * WARNING: Note that nsCheapString doesn't take an explicit length -- it
 * assumes the string is maximally large, given the nsStringBuffer's storage
 * size.  This means the given string buffer *must* be sized exactly correctly
 * for the string it contains (including one byte for a null terminator).  If
 * it has any unused storage space, then that will result in bogus characters
 * at the end of our nsCheapString.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCheapString {
        pub _base: ::nsstring::nsStringRepr,
    }
    #[test]
    fn bindgen_test_layout_nsCheapString() {
        assert_eq!(::std::mem::size_of::<nsCheapString>() , 16usize , concat !
                   ( "Size of: " , stringify ! ( nsCheapString ) ));
        assert_eq! (::std::mem::align_of::<nsCheapString>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsCheapString ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsMappedAttributes {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsMappedAttributeElement {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ElementRuleProcessorData {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct PseudoElementRuleProcessorData {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AnonBoxRuleProcessorData {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct XULTreeRuleProcessorData {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct StateRuleProcessorData {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct PseudoElementStateRuleProcessorData {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AttributeRuleProcessorData {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIStyleRuleProcessor {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIStyleRuleProcessor_COMTypeInfo {
        pub _address: u8,
    }
    pub type nsIStyleRuleProcessor_EnumFunc =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::nsIStyleRuleProcessor,
                                                   arg2:
                                                       *mut ::std::os::raw::c_void)
                                  -> bool>;
    #[test]
    fn bindgen_test_layout_nsIStyleRuleProcessor() {
        assert_eq!(::std::mem::size_of::<nsIStyleRuleProcessor>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIStyleRuleProcessor ) ));
        assert_eq! (::std::mem::align_of::<nsIStyleRuleProcessor>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIStyleRuleProcessor )
                    ));
    }
    impl Clone for nsIStyleRuleProcessor {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsXBLPrototypeBinding {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsAnonymousContentList {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsLabelsNodeList {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDOMTokenList {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDOMStringMap {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMMozNamedAttrMap {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMMozNamedAttrMap_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMMozNamedAttrMap() {
        assert_eq!(::std::mem::size_of::<nsIDOMMozNamedAttrMap>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIDOMMozNamedAttrMap ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMMozNamedAttrMap>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMMozNamedAttrMap )
                    ));
    }
    impl Clone for nsIDOMMozNamedAttrMap {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIAttribute {
        pub _base: root::nsINode,
        pub mAttrMap: root::RefPtr<root::nsDOMAttributeMap>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIAttribute_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIAttribute() {
        assert_eq!(::std::mem::size_of::<nsIAttribute>() , 96usize , concat !
                   ( "Size of: " , stringify ! ( nsIAttribute ) ));
        assert_eq! (::std::mem::align_of::<nsIAttribute>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsIAttribute ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIAttribute ) ) . mAttrMap as *
                    const _ as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIAttribute ) ,
                    "::" , stringify ! ( mAttrMap ) ));
    }
    /**
 * Structure used as a key for caching Attrs in nsDOMAttributeMap's mAttributeCache.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsAttrKey {
        /**
   * The namespace of the attribute
   */
        pub mNamespaceID: i32,
        /**
   * The atom for attribute, stored as void*, to make sure that we only use it
   * for the hashcode, and we can never dereference it.
   */
        pub mLocalName: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_nsAttrKey() {
        assert_eq!(::std::mem::size_of::<nsAttrKey>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsAttrKey ) ));
        assert_eq! (::std::mem::align_of::<nsAttrKey>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsAttrKey ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrKey ) ) . mNamespaceID as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAttrKey ) , "::"
                    , stringify ! ( mNamespaceID ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrKey ) ) . mLocalName as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAttrKey ) , "::"
                    , stringify ! ( mLocalName ) ));
    }
    impl Clone for nsAttrKey {
        fn clone(&self) -> Self { *self }
    }
    /**
 * PLDHashEntryHdr implementation for nsAttrKey.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAttrHashKey {
        pub _base: root::PLDHashEntryHdr,
        pub mKey: root::nsAttrKey,
    }
    pub type nsAttrHashKey_KeyType = *const root::nsAttrKey;
    pub type nsAttrHashKey_KeyTypePointer = *const root::nsAttrKey;
    pub const nsAttrHashKey_ALLOW_MEMMOVE: root::nsAttrHashKey__bindgen_ty_1 =
        nsAttrHashKey__bindgen_ty_1::ALLOW_MEMMOVE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsAttrHashKey__bindgen_ty_1 { ALLOW_MEMMOVE = 1, }
    #[test]
    fn bindgen_test_layout_nsAttrHashKey() {
        assert_eq!(::std::mem::size_of::<nsAttrHashKey>() , 24usize , concat !
                   ( "Size of: " , stringify ! ( nsAttrHashKey ) ));
        assert_eq! (::std::mem::align_of::<nsAttrHashKey>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsAttrHashKey ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrHashKey ) ) . mKey as * const _
                    as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAttrHashKey ) ,
                    "::" , stringify ! ( mKey ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsScrollbarFrame {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIScrollbarMediator {
        pub _base: root::nsQueryFrame,
    }
    pub type nsIScrollbarMediator_Has_NS_DECL_QUERYFRAME_TARGET =
        root::nsIScrollbarMediator;
    #[repr(u32)]
    /**
   * When set to ENABLE_SNAP, additional scrolling will be performed after the
   * scroll operation to maintain the constraints set by CSS Scroll snapping.
   * The additional scrolling may include asynchronous smooth scrolls that
   * continue to animate after the initial scroll position has been set.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIScrollbarMediator_ScrollSnapMode {
        DISABLE_SNAP = 0,
        ENABLE_SNAP = 1,
    }
    extern "C" {
        #[link_name = "_ZN20nsIScrollbarMediator9kFrameIIDE"]
        pub static nsIScrollbarMediator_kFrameIID:
                   root::nsQueryFrame_FrameIID;
    }
    #[test]
    fn bindgen_test_layout_nsIScrollbarMediator() {
        assert_eq!(::std::mem::size_of::<nsIScrollbarMediator>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIScrollbarMediator ) ));
        assert_eq! (::std::mem::align_of::<nsIScrollbarMediator>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIScrollbarMediator ) ));
    }
    impl Clone for nsIScrollbarMediator {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsBoxLayoutState {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIScrollPositionListener {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsSMILValue {
        _unused: [u8; 0],
    }
    #[repr(C)]
    pub struct nsISMILAttr__bindgen_vtable(::std::os::raw::c_void);
    ////////////////////////////////////////////////////////////////////////
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsISMILAttr {
        pub vtable_: *const nsISMILAttr__bindgen_vtable,
    }
    #[test]
    fn bindgen_test_layout_nsISMILAttr() {
        assert_eq!(::std::mem::size_of::<nsISMILAttr>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsISMILAttr ) ));
        assert_eq! (::std::mem::align_of::<nsISMILAttr>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsISMILAttr ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mozAutoDocUpdate {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsAttrValueOrString {
        _unused: [u8; 0],
    }
    pub const ELEMENT_SHARED_RESTYLE_BIT_1: root::_bindgen_ty_85 =
        _bindgen_ty_85::ELEMENT_SHARED_RESTYLE_BIT_1;
    pub const ELEMENT_SHARED_RESTYLE_BIT_2: root::_bindgen_ty_85 =
        _bindgen_ty_85::ELEMENT_SHARED_RESTYLE_BIT_2;
    pub const ELEMENT_SHARED_RESTYLE_BIT_3: root::_bindgen_ty_85 =
        _bindgen_ty_85::ELEMENT_SHARED_RESTYLE_BIT_3;
    pub const ELEMENT_SHARED_RESTYLE_BIT_4: root::_bindgen_ty_85 =
        _bindgen_ty_85::ELEMENT_SHARED_RESTYLE_BIT_4;
    pub const ELEMENT_HAS_DIRTY_DESCENDANTS_FOR_SERVO: root::_bindgen_ty_85 =
        _bindgen_ty_85::ELEMENT_SHARED_RESTYLE_BIT_1;
    pub const ELEMENT_HAS_ANIMATION_ONLY_DIRTY_DESCENDANTS_FOR_SERVO:
              root::_bindgen_ty_85 =
        _bindgen_ty_85::ELEMENT_SHARED_RESTYLE_BIT_2;
    pub const ELEMENT_HAS_SNAPSHOT: root::_bindgen_ty_85 =
        _bindgen_ty_85::ELEMENT_SHARED_RESTYLE_BIT_3;
    pub const ELEMENT_HANDLED_SNAPSHOT: root::_bindgen_ty_85 =
        _bindgen_ty_85::ELEMENT_SHARED_RESTYLE_BIT_4;
    pub const ELEMENT_HAS_PENDING_RESTYLE: root::_bindgen_ty_85 =
        _bindgen_ty_85::ELEMENT_SHARED_RESTYLE_BIT_1;
    pub const ELEMENT_IS_POTENTIAL_RESTYLE_ROOT: root::_bindgen_ty_85 =
        _bindgen_ty_85::ELEMENT_SHARED_RESTYLE_BIT_2;
    pub const ELEMENT_HAS_PENDING_ANIMATION_ONLY_RESTYLE: root::_bindgen_ty_85
              =
        _bindgen_ty_85::ELEMENT_SHARED_RESTYLE_BIT_3;
    pub const ELEMENT_IS_POTENTIAL_ANIMATION_ONLY_RESTYLE_ROOT:
              root::_bindgen_ty_85 =
        _bindgen_ty_85::ELEMENT_SHARED_RESTYLE_BIT_4;
    pub const ELEMENT_IS_CONDITIONAL_RESTYLE_ANCESTOR: root::_bindgen_ty_85 =
        _bindgen_ty_85::ELEMENT_IS_CONDITIONAL_RESTYLE_ANCESTOR;
    pub const ELEMENT_PENDING_RESTYLE_FLAGS: root::_bindgen_ty_85 =
        _bindgen_ty_85::ELEMENT_PENDING_RESTYLE_FLAGS;
    pub const ELEMENT_POTENTIAL_RESTYLE_ROOT_FLAGS: root::_bindgen_ty_85 =
        _bindgen_ty_85::ELEMENT_POTENTIAL_RESTYLE_ROOT_FLAGS;
    pub const ELEMENT_ALL_RESTYLE_FLAGS: root::_bindgen_ty_85 =
        _bindgen_ty_85::ELEMENT_ALL_RESTYLE_FLAGS;
    pub const ELEMENT_HAS_SCROLLGRAB: root::_bindgen_ty_85 =
        _bindgen_ty_85::ELEMENT_HAS_SCROLLGRAB;
    pub const ELEMENT_TYPE_SPECIFIC_BITS_OFFSET: root::_bindgen_ty_85 =
        _bindgen_ty_85::ELEMENT_TYPE_SPECIFIC_BITS_OFFSET;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum _bindgen_ty_85 {
        ELEMENT_SHARED_RESTYLE_BIT_1 = 8388608,
        ELEMENT_SHARED_RESTYLE_BIT_2 = 16777216,
        ELEMENT_SHARED_RESTYLE_BIT_3 = 33554432,
        ELEMENT_SHARED_RESTYLE_BIT_4 = 67108864,
        ELEMENT_IS_CONDITIONAL_RESTYLE_ANCESTOR = 134217728,
        ELEMENT_PENDING_RESTYLE_FLAGS = 41943040,
        ELEMENT_POTENTIAL_RESTYLE_ROOT_FLAGS = 83886080,
        ELEMENT_ALL_RESTYLE_FLAGS = 260046848,
        ELEMENT_HAS_SCROLLGRAB = 268435456,
        ELEMENT_TYPE_SPECIFIC_BITS_OFFSET = 27,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct LookAndFeelInt {
        pub id: i32,
        pub value: i32,
    }
    #[test]
    fn bindgen_test_layout_LookAndFeelInt() {
        assert_eq!(::std::mem::size_of::<LookAndFeelInt>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( LookAndFeelInt ) ));
        assert_eq! (::std::mem::align_of::<LookAndFeelInt>() , 4usize , concat
                    ! ( "Alignment of " , stringify ! ( LookAndFeelInt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const LookAndFeelInt ) ) . id as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( LookAndFeelInt ) ,
                    "::" , stringify ! ( id ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const LookAndFeelInt ) ) . value as * const
                    _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( LookAndFeelInt ) ,
                    "::" , stringify ! ( value ) ));
    }
    impl Clone for LookAndFeelInt {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIStyleRule {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSFontFaceRule {
        pub _base: root::mozilla::css::Rule,
        pub _base_1: root::nsIDOMCSSFontFaceRule,
        pub mDecl: root::nsCSSFontFaceStyleDecl,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCSSFontFaceRule_cycleCollection {
        pub _base: root::mozilla::css::Rule_cycleCollection,
    }
    #[test]
    fn bindgen_test_layout_nsCSSFontFaceRule_cycleCollection() {
        assert_eq!(::std::mem::size_of::<nsCSSFontFaceRule_cycleCollection>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsCSSFontFaceRule_cycleCollection ) ));
        assert_eq! (::std::mem::align_of::<nsCSSFontFaceRule_cycleCollection>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsCSSFontFaceRule_cycleCollection ) ));
    }
    impl Clone for nsCSSFontFaceRule_cycleCollection {
        fn clone(&self) -> Self { *self }
    }
    extern "C" {
        #[link_name = "_ZN17nsCSSFontFaceRule21_cycleCollectorGlobalE"]
        pub static mut nsCSSFontFaceRule__cycleCollectorGlobal:
                   root::nsCSSFontFaceRule_cycleCollection;
    }
    #[test]
    fn bindgen_test_layout_nsCSSFontFaceRule() {
        assert_eq!(::std::mem::size_of::<nsCSSFontFaceRule>() , 248usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCSSFontFaceRule )
                   ));
        assert_eq! (::std::mem::align_of::<nsCSSFontFaceRule>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSFontFaceRule ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsMediaFeature {
        pub mName: *mut *mut root::nsIAtom,
        pub mRangeType: root::nsMediaFeature_RangeType,
        pub mValueType: root::nsMediaFeature_ValueType,
        pub mReqFlags: u8,
        pub mData: root::nsMediaFeature__bindgen_ty_1,
        pub mGetter: root::nsMediaFeatureValueGetter,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsMediaFeature_RangeType {
        eMinMaxAllowed = 0,
        eMinMaxNotAllowed = 1,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsMediaFeature_ValueType {
        eLength = 0,
        eInteger = 1,
        eFloat = 2,
        eBoolInteger = 3,
        eIntRatio = 4,
        eResolution = 5,
        eEnumerated = 6,
        eIdent = 7,
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsMediaFeature_RequirementFlags {
        eNoRequirements = 0,
        eHasWebkitPrefix = 1,
        eWebkitDevicePixelRatioPrefEnabled = 2,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsMediaFeature__bindgen_ty_1 {
        pub mInitializer_: root::__BindgenUnionField<*const ::std::os::raw::c_void>,
        pub mKeywordTable: root::__BindgenUnionField<*const root::nsCSSProps_KTableEntry>,
        pub mMetric: root::__BindgenUnionField<*const *const root::nsIAtom>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsMediaFeature__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsMediaFeature__bindgen_ty_1>() ,
                   8usize , concat ! (
                   "Size of: " , stringify ! ( nsMediaFeature__bindgen_ty_1 )
                   ));
        assert_eq! (::std::mem::align_of::<nsMediaFeature__bindgen_ty_1>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsMediaFeature__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature__bindgen_ty_1 ) ) .
                    mInitializer_ as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsMediaFeature__bindgen_ty_1 ) , "::" , stringify ! (
                    mInitializer_ ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature__bindgen_ty_1 ) ) .
                    mKeywordTable as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsMediaFeature__bindgen_ty_1 ) , "::" , stringify ! (
                    mKeywordTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature__bindgen_ty_1 ) ) .
                    mMetric as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsMediaFeature__bindgen_ty_1 ) , "::" , stringify ! (
                    mMetric ) ));
    }
    impl Clone for nsMediaFeature__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsMediaFeature() {
        assert_eq!(::std::mem::size_of::<nsMediaFeature>() , 40usize , concat
                   ! ( "Size of: " , stringify ! ( nsMediaFeature ) ));
        assert_eq! (::std::mem::align_of::<nsMediaFeature>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsMediaFeature ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature ) ) . mName as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaFeature ) ,
                    "::" , stringify ! ( mName ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature ) ) . mRangeType as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaFeature ) ,
                    "::" , stringify ! ( mRangeType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature ) ) . mValueType as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaFeature ) ,
                    "::" , stringify ! ( mValueType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature ) ) . mReqFlags as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaFeature ) ,
                    "::" , stringify ! ( mReqFlags ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature ) ) . mData as * const
                    _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaFeature ) ,
                    "::" , stringify ! ( mData ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature ) ) . mGetter as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaFeature ) ,
                    "::" , stringify ! ( mGetter ) ));
    }
    impl Clone for nsMediaFeature {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct ServoBundledURI {
        pub mURLString: *const u8,
        pub mURLStringLength: u32,
        pub mExtraData: *mut root::mozilla::URLExtraData,
    }
    #[test]
    fn bindgen_test_layout_ServoBundledURI() {
        assert_eq!(::std::mem::size_of::<ServoBundledURI>() , 24usize , concat
                   ! ( "Size of: " , stringify ! ( ServoBundledURI ) ));
        assert_eq! (::std::mem::align_of::<ServoBundledURI>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( ServoBundledURI ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoBundledURI ) ) . mURLString as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoBundledURI ) ,
                    "::" , stringify ! ( mURLString ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoBundledURI ) ) .
                    mURLStringLength as * const _ as usize } , 8usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( ServoBundledURI ) ,
                    "::" , stringify ! ( mURLStringLength ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoBundledURI ) ) . mExtraData as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoBundledURI ) ,
                    "::" , stringify ! ( mExtraData ) ));
    }
    impl Clone for ServoBundledURI {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct FontSizePrefs {
        pub mDefaultVariableSize: root::nscoord,
        pub mDefaultFixedSize: root::nscoord,
        pub mDefaultSerifSize: root::nscoord,
        pub mDefaultSansSerifSize: root::nscoord,
        pub mDefaultMonospaceSize: root::nscoord,
        pub mDefaultCursiveSize: root::nscoord,
        pub mDefaultFantasySize: root::nscoord,
    }
    #[test]
    fn bindgen_test_layout_FontSizePrefs() {
        assert_eq!(::std::mem::size_of::<FontSizePrefs>() , 28usize , concat !
                   ( "Size of: " , stringify ! ( FontSizePrefs ) ));
        assert_eq! (::std::mem::align_of::<FontSizePrefs>() , 4usize , concat
                    ! ( "Alignment of " , stringify ! ( FontSizePrefs ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const FontSizePrefs ) ) .
                    mDefaultVariableSize as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( FontSizePrefs ) ,
                    "::" , stringify ! ( mDefaultVariableSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const FontSizePrefs ) ) . mDefaultFixedSize
                    as * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( FontSizePrefs ) ,
                    "::" , stringify ! ( mDefaultFixedSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const FontSizePrefs ) ) . mDefaultSerifSize
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( FontSizePrefs ) ,
                    "::" , stringify ! ( mDefaultSerifSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const FontSizePrefs ) ) .
                    mDefaultSansSerifSize as * const _ as usize } , 12usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( FontSizePrefs ) ,
                    "::" , stringify ! ( mDefaultSansSerifSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const FontSizePrefs ) ) .
                    mDefaultMonospaceSize as * const _ as usize } , 16usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( FontSizePrefs ) ,
                    "::" , stringify ! ( mDefaultMonospaceSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const FontSizePrefs ) ) .
                    mDefaultCursiveSize as * const _ as usize } , 20usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( FontSizePrefs ) ,
                    "::" , stringify ! ( mDefaultCursiveSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const FontSizePrefs ) ) .
                    mDefaultFantasySize as * const _ as usize } , 24usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( FontSizePrefs ) ,
                    "::" , stringify ! ( mDefaultFantasySize ) ));
    }
    impl Clone for FontSizePrefs {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct GeckoFontMetrics {
        pub mChSize: root::nscoord,
        pub mXSize: root::nscoord,
    }
    #[test]
    fn bindgen_test_layout_GeckoFontMetrics() {
        assert_eq!(::std::mem::size_of::<GeckoFontMetrics>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( GeckoFontMetrics ) ));
        assert_eq! (::std::mem::align_of::<GeckoFontMetrics>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( GeckoFontMetrics ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const GeckoFontMetrics ) ) . mChSize as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( GeckoFontMetrics )
                    , "::" , stringify ! ( mChSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const GeckoFontMetrics ) ) . mXSize as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( GeckoFontMetrics )
                    , "::" , stringify ! ( mXSize ) ));
    }
    impl Clone for GeckoFontMetrics {
        fn clone(&self) -> Self { *self }
    }
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_after: u32 = 1;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_before: u32 = 1;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_backdrop: u32 = 0;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_cue: u32 = 36;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_firstLetter: u32 = 3;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_firstLine: u32 = 3;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozSelection: u32 = 2;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozFocusInner: u32 = 0;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozFocusOuter: u32 = 0;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozListBullet: u32 = 0;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozListNumber: u32 = 0;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozMathAnonymous: u32 = 0;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozNumberWrapper: u32 = 24;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozNumberText: u32 = 24;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozNumberSpinBox: u32 = 24;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozNumberSpinUp: u32 = 24;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozNumberSpinDown: u32 = 24;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozProgressBar: u32 = 8;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozRangeTrack: u32 = 8;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozRangeProgress: u32 = 8;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozRangeThumb: u32 = 8;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozMeterBar: u32 = 8;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozPlaceholder: u32 = 8;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_placeholder: u32 = 8;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozColorSwatch: u32 = 12;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMCSSCounterStyleRule {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMCSSCounterStyleRule_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMCSSCounterStyleRule() {
        assert_eq!(::std::mem::size_of::<nsIDOMCSSCounterStyleRule>() , 8usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsIDOMCSSCounterStyleRule ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMCSSCounterStyleRule>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIDOMCSSCounterStyleRule
                    ) ));
    }
    impl Clone for nsIDOMCSSCounterStyleRule {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsROCSSPrimitiveValue {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMCSSFontFaceRule {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMCSSFontFaceRule_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMCSSFontFaceRule() {
        assert_eq!(::std::mem::size_of::<nsIDOMCSSFontFaceRule>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIDOMCSSFontFaceRule ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMCSSFontFaceRule>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMCSSFontFaceRule )
                    ));
    }
    impl Clone for nsIDOMCSSFontFaceRule {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSFontFaceStyleDecl {
        pub _base: root::nsICSSDeclaration,
        pub mDescriptors: root::mozilla::CSSFontFaceDescriptors,
    }
    #[test]
    fn bindgen_test_layout_nsCSSFontFaceStyleDecl() {
        assert_eq!(::std::mem::size_of::<nsCSSFontFaceStyleDecl>() , 176usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsCSSFontFaceStyleDecl ) ));
        assert_eq! (::std::mem::align_of::<nsCSSFontFaceStyleDecl>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsCSSFontFaceStyleDecl )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSFontFaceStyleDecl ) ) .
                    mDescriptors as * const _ as usize } , 32usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsCSSFontFaceStyleDecl ) , "::" , stringify ! (
                    mDescriptors ) ));
    }
    pub type nsMediaFeatureValueGetter =
        ::std::option::Option<unsafe extern "C" fn(aPresContext:
                                                       *mut root::nsPresContext,
                                                   aFeature:
                                                       *const root::nsMediaFeature,
                                                   aResult:
                                                       *mut root::nsCSSValue)>;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsMediaFeatures {
        pub _address: u8,
    }
    extern "C" {
        #[link_name = "_ZN15nsMediaFeatures8featuresE"]
        pub static mut nsMediaFeatures_features:
                   [root::nsMediaFeature; 0usize];
    }
    #[test]
    fn bindgen_test_layout_nsMediaFeatures() {
        assert_eq!(::std::mem::size_of::<nsMediaFeatures>() , 1usize , concat
                   ! ( "Size of: " , stringify ! ( nsMediaFeatures ) ));
        assert_eq! (::std::mem::align_of::<nsMediaFeatures>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsMediaFeatures ) ));
    }
    impl Clone for nsMediaFeatures {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMediaExpression {
        pub mFeature: *const root::nsMediaFeature,
        pub mRange: root::nsMediaExpression_Range,
        pub mValue: root::nsCSSValue,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsMediaExpression_Range { eMin = 0, eMax = 1, eEqual = 2, }
    #[test]
    fn bindgen_test_layout_nsMediaExpression() {
        assert_eq!(::std::mem::size_of::<nsMediaExpression>() , 32usize ,
                   concat ! ( "Size of: " , stringify ! ( nsMediaExpression )
                   ));
        assert_eq! (::std::mem::align_of::<nsMediaExpression>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsMediaExpression ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaExpression ) ) . mFeature as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaExpression )
                    , "::" , stringify ! ( mFeature ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaExpression ) ) . mRange as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaExpression )
                    , "::" , stringify ! ( mRange ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaExpression ) ) . mValue as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaExpression )
                    , "::" , stringify ! ( mValue ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMediaQuery {
        pub mNegated: bool,
        pub mHasOnly: bool,
        pub mTypeOmitted: bool,
        pub mHadUnknownExpression: bool,
        pub mMediaType: root::nsCOMPtr,
        pub mExpressions: root::nsTArray<root::nsMediaExpression>,
    }
    #[test]
    fn bindgen_test_layout_nsMediaQuery() {
        assert_eq!(::std::mem::size_of::<nsMediaQuery>() , 24usize , concat !
                   ( "Size of: " , stringify ! ( nsMediaQuery ) ));
        assert_eq! (::std::mem::align_of::<nsMediaQuery>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsMediaQuery ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaQuery ) ) . mNegated as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaQuery ) ,
                    "::" , stringify ! ( mNegated ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaQuery ) ) . mHasOnly as *
                    const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaQuery ) ,
                    "::" , stringify ! ( mHasOnly ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaQuery ) ) . mTypeOmitted as *
                    const _ as usize } , 2usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaQuery ) ,
                    "::" , stringify ! ( mTypeOmitted ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaQuery ) ) .
                    mHadUnknownExpression as * const _ as usize } , 3usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaQuery ) ,
                    "::" , stringify ! ( mHadUnknownExpression ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaQuery ) ) . mMediaType as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaQuery ) ,
                    "::" , stringify ! ( mMediaType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaQuery ) ) . mExpressions as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaQuery ) ,
                    "::" , stringify ! ( mExpressions ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMediaList {
        pub _base: root::mozilla::dom::MediaList,
        pub mArray: root::nsTArray<root::nsAutoPtr<root::nsMediaQuery>>,
    }
    #[test]
    fn bindgen_test_layout_nsMediaList() {
        assert_eq!(::std::mem::size_of::<nsMediaList>() , 56usize , concat ! (
                   "Size of: " , stringify ! ( nsMediaList ) ));
        assert_eq! (::std::mem::align_of::<nsMediaList>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsMediaList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaList ) ) . mArray as * const _
                    as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaList ) ,
                    "::" , stringify ! ( mArray ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct __va_list_tag {
        pub gp_offset: ::std::os::raw::c_uint,
        pub fp_offset: ::std::os::raw::c_uint,
        pub overflow_arg_area: *mut ::std::os::raw::c_void,
        pub reg_save_area: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout___va_list_tag() {
        assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat !
                   ( "Size of: " , stringify ! ( __va_list_tag ) ));
        assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( __va_list_tag ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( __va_list_tag ) ,
                    "::" , stringify ! ( gp_offset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( __va_list_tag ) ,
                    "::" , stringify ! ( fp_offset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( __va_list_tag ) ,
                    "::" , stringify ! ( overflow_arg_area ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as
                    * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( __va_list_tag ) ,
                    "::" , stringify ! ( reg_save_area ) ));
    }
    impl Clone for __va_list_tag {
        fn clone(&self) -> Self { *self }
    }
    pub type __builtin_va_list = [root::__va_list_tag; 1usize];
    #[test]
    fn __bindgen_test_layout_IntegralConstant_instantiation_88() {
        assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
                   "Size of template specialization: " , stringify ! ( u8 )
                   ));
        assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! ( u8
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_IntegralConstant_instantiation_89() {
        assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
                   "Size of template specialization: " , stringify ! ( u8 )
                   ));
        assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! ( u8
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCharTraits_instantiation_90() {
        assert_eq!(::std::mem::size_of::<root::nsCharTraits>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCharTraits ) ));
        assert_eq!(::std::mem::align_of::<root::nsCharTraits>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCharTraits ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsReadingIterator_instantiation_91() {
        assert_eq!(::std::mem::size_of::<root::nsReadingIterator<u16>>() ,
                   24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsReadingIterator<u16> ) ));
        assert_eq!(::std::mem::align_of::<root::nsReadingIterator<u16>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsReadingIterator<u16> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsWritingIterator_instantiation_92() {
        assert_eq!(::std::mem::size_of::<root::nsWritingIterator<u16>>() ,
                   24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsWritingIterator<u16> ) ));
        assert_eq!(::std::mem::align_of::<root::nsWritingIterator<u16>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsWritingIterator<u16> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCharTraits_instantiation_93() {
        assert_eq!(::std::mem::size_of::<root::nsCharTraits>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCharTraits ) ));
        assert_eq!(::std::mem::align_of::<root::nsCharTraits>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCharTraits ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsReadingIterator_instantiation_94() {
        assert_eq!(::std::mem::size_of::<root::nsReadingIterator<::std::os::raw::c_char>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsReadingIterator<::std::os::raw::c_char> ) ));
        assert_eq!(::std::mem::align_of::<root::nsReadingIterator<::std::os::raw::c_char>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsReadingIterator<::std::os::raw::c_char> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsWritingIterator_instantiation_95() {
        assert_eq!(::std::mem::size_of::<root::nsWritingIterator<::std::os::raw::c_char>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsWritingIterator<::std::os::raw::c_char> ) ));
        assert_eq!(::std::mem::align_of::<root::nsWritingIterator<::std::os::raw::c_char>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsWritingIterator<::std::os::raw::c_char> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCharTraits_instantiation_96() {
        assert_eq!(::std::mem::size_of::<root::nsCharTraits>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCharTraits ) ));
        assert_eq!(::std::mem::align_of::<root::nsCharTraits>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCharTraits ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCharTraits_instantiation_97() {
        assert_eq!(::std::mem::size_of::<root::nsCharTraits>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCharTraits ) ));
        assert_eq!(::std::mem::align_of::<root::nsCharTraits>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCharTraits ) ));
    }
    #[test]
    fn __bindgen_test_layout__bindgen_ty_id_211044_instantiation_98() {
        assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
                   "Size of template specialization: " , stringify ! ( u8 )
                   ));
        assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! ( u8
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout__bindgen_ty_id_211080_instantiation_99() {
        assert_eq!(::std::mem::size_of::<u8>() , 1usize , concat ! (
                   "Size of template specialization: " , stringify ! ( u8 )
                   ));
        assert_eq!(::std::mem::align_of::<u8>() , 1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! ( u8
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_100() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCString>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCString> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCString>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCString> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_101() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<root::jsid>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<root::jsid> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<root::jsid>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<root::jsid> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_102() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_103() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_instantiation_104() {
        assert_eq!(::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Rooted_instantiation_105() {
        assert_eq!(::std::mem::size_of::<[u64; 3usize]>() , 24usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u64; 3usize] ) ));
        assert_eq!(::std::mem::align_of::<[u64; 3usize]>() , 8usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u64; 3usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_instantiation_106() {
        assert_eq!(::std::mem::size_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
        assert_eq!(::std::mem::align_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_107() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_108() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::mozilla::FontFamilyName>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::FontFamilyName> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::mozilla::FontFamilyName>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::FontFamilyName> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_109() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::std::os::raw::c_uint>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::std::os::raw::c_uint> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::std::os::raw::c_uint>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::std::os::raw::c_uint> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_110() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::std::os::raw::c_uint>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::std::os::raw::c_uint> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::std::os::raw::c_uint>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::std::os::raw::c_uint> ) ));
    }
    #[test]
    fn __bindgen_test_layout_PointTyped_instantiation_111() {
        assert_eq!(::std::mem::size_of::<[u32; 2usize]>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 2usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_IntPointTyped_instantiation_112() {
        assert_eq!(::std::mem::size_of::<[u32; 2usize]>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 2usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_SizeTyped_instantiation_113() {
        assert_eq!(::std::mem::size_of::<[u32; 2usize]>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 2usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_RectTyped_instantiation_114() {
        assert_eq!(::std::mem::size_of::<[u32; 4usize]>() , 16usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 4usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 4usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 4usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_IntPointTyped_instantiation_115() {
        assert_eq!(::std::mem::size_of::<[u32; 2usize]>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 2usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_IntSizeTyped_instantiation_116() {
        assert_eq!(::std::mem::size_of::<[u32; 2usize]>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 2usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_IntRectTyped_instantiation_117() {
        assert_eq!(::std::mem::size_of::<[u32; 4usize]>() , 16usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 4usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 4usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 4usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_MarginTyped_instantiation_118() {
        assert_eq!(::std::mem::size_of::<[u32; 4usize]>() , 16usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 4usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 4usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 4usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_RectTyped_instantiation_119() {
        assert_eq!(::std::mem::size_of::<[u32; 4usize]>() , 16usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 4usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 4usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 4usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_IntRectTyped_instantiation_120() {
        assert_eq!(::std::mem::size_of::<[u32; 4usize]>() , 16usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 4usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 4usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 4usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_ScaleFactor_instantiation_121() {
        assert_eq!(::std::mem::size_of::<u32>() , 4usize , concat ! (
                   "Size of template specialization: " , stringify ! ( u32 )
                   ));
        assert_eq!(::std::mem::align_of::<u32>() , 4usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   u32 ) ));
    }
    #[test]
    fn __bindgen_test_layout_ScaleFactors2D_instantiation_122() {
        assert_eq!(::std::mem::size_of::<[u32; 2usize]>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 2usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_ScaleFactors2D_instantiation_123() {
        assert_eq!(::std::mem::size_of::<[u32; 2usize]>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 2usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_ScaleFactors2D_instantiation_124() {
        assert_eq!(::std::mem::size_of::<[u32; 2usize]>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 2usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_BaseTimeDuration_instantiation_125() {
        assert_eq!(::std::mem::size_of::<root::mozilla::BaseTimeDuration>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::BaseTimeDuration ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::BaseTimeDuration>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::BaseTimeDuration ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_126() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIContent>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_127() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIContent>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_instantiation_128() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_129() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_instantiation_130() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_131() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_WeakPtr_instantiation_132() {
        assert_eq!(::std::mem::size_of::<u64>() , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! ( u64 )
                   ));
        assert_eq!(::std::mem::align_of::<u64>() , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   u64 ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsPtrHashKey_instantiation_133() {
        assert_eq!(::std::mem::size_of::<root::nsPtrHashKey<root::WeakFrame>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsPtrHashKey<root::WeakFrame> ) ));
        assert_eq!(::std::mem::align_of::<root::nsPtrHashKey<root::WeakFrame>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsPtrHashKey<root::WeakFrame> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_134() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_TErrorResult_instantiation_135() {
        assert_eq!(::std::mem::size_of::<root::mozilla::binding_danger::TErrorResult>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::binding_danger::TErrorResult ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::binding_danger::TErrorResult>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::binding_danger::TErrorResult ) ));
    }
    #[test]
    fn __bindgen_test_layout_TErrorResult_instantiation_136() {
        assert_eq!(::std::mem::size_of::<root::mozilla::binding_danger::TErrorResult>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::binding_danger::TErrorResult ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::binding_danger::TErrorResult>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::binding_danger::TErrorResult ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_137() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsStringBuffer>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsStringBuffer> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsStringBuffer>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsStringBuffer> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_138() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_instantiation_139() {
        assert_eq!(::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_140() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_141() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_142() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_instantiation_143() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_144() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_145() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_146() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_147() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_148() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsINode>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsINode> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsINode>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsINode> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_149() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_instantiation_150() {
        assert_eq!(::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_instantiation_151() {
        assert_eq!(::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_instantiation_152() {
        assert_eq!(::std::mem::size_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
        assert_eq!(::std::mem::align_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_instantiation_153() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_instantiation_154() {
        assert_eq!(::std::mem::size_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
        assert_eq!(::std::mem::align_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_instantiation_155() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::JSErrorNotes>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::JSErrorNotes>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_instantiation_156() {
        assert_eq!(::std::mem::size_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
        assert_eq!(::std::mem::align_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_instantiation_157() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_instantiation_158() {
        assert_eq!(::std::mem::size_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
        assert_eq!(::std::mem::align_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_instantiation_159() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_instantiation_160() {
        assert_eq!(::std::mem::size_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
        assert_eq!(::std::mem::align_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_instantiation_161() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
    }
    #[test]
    fn __bindgen_test_layout_iterator_instantiation_162() {
        assert_eq!(::std::mem::size_of::<root::std::iterator>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::iterator ) ));
        assert_eq!(::std::mem::align_of::<root::std::iterator>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::iterator ) ));
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_instantiation_163() {
        assert_eq!(::std::mem::size_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
        assert_eq!(::std::mem::align_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_instantiation_164() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_instantiation_165() {
        assert_eq!(::std::mem::size_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
        assert_eq!(::std::mem::align_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_instantiation_166() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_instantiation_167() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_168() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_instantiation_169() {
        assert_eq!(::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_170() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCString>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCString> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCString>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCString> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_171() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCString>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCString> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCString>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCString> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Heap_instantiation_172() {
        assert_eq!(::std::mem::size_of::<root::JS::Heap<root::JS::Value>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Heap<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Heap<root::JS::Value>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Heap<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Heap_instantiation_173() {
        assert_eq!(::std::mem::size_of::<root::JS::Heap<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Heap<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Heap<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Heap<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_TenuredHeap_instantiation_174() {
        assert_eq!(::std::mem::size_of::<root::JS::TenuredHeap>() , 8usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::TenuredHeap ) ));
        assert_eq!(::std::mem::align_of::<root::JS::TenuredHeap>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::TenuredHeap ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_175() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_NotNull_instantiation_176() {
        assert_eq!(::std::mem::size_of::<root::mozilla::NotNull<*const root::mozilla::Encoding>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::NotNull<*const root::mozilla::Encoding> )
                   ));
        assert_eq!(::std::mem::align_of::<root::mozilla::NotNull<*const root::mozilla::Encoding>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::NotNull<*const root::mozilla::Encoding> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_177() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::AnonymousContent>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::AnonymousContent>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::AnonymousContent>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::AnonymousContent>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_instantiation_178() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_179() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_instantiation_180() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_181() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_182() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::dom::Element> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::dom::Element> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_instantiation_183() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::Element> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::Element> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_instantiation_184() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_185() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCOMPtr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCOMPtr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_instantiation_186() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_187() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIDocument>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIDocument> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIDocument>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIDocument> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_188() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_instantiation_189() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_190() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::dom::Element> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::dom::Element> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_191() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIDocument>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIDocument> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIDocument>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIDocument> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_instantiation_192() {
        assert_eq!(::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::MutableHandle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::MutableHandle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_193() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsContentList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsContentList> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsContentList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsContentList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_194() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsContentList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsContentList> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsContentList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsContentList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_195() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsINode>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsINode> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsINode>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsINode> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_instantiation_196() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::Element> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::Element> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_197() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_198() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_199() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIRunnable> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIRunnable> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_instantiation_200() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_instantiation_201() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_instantiation_202() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_203() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_204() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_instantiation_205() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_instantiation_206() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsISMILAttr>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsISMILAttr> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsISMILAttr>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsISMILAttr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_207() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::mozilla::dom::NodeInfo>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::NodeInfo> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::mozilla::dom::NodeInfo>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::NodeInfo> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_208() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_209() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_210() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_211() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsRefPtrHashKey_instantiation_212() {
        assert_eq!(::std::mem::size_of::<root::nsRefPtrHashKey<root::mozilla::dom::DOMIntersectionObserver>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsRefPtrHashKey<root::mozilla::dom::DOMIntersectionObserver>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsRefPtrHashKey<root::mozilla::dom::DOMIntersectionObserver>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsRefPtrHashKey<root::mozilla::dom::DOMIntersectionObserver>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsDataHashtable_instantiation_213() {
        assert_eq!(::std::mem::size_of::<[u64; 5usize]>() , 40usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u64; 5usize] ) ));
        assert_eq!(::std::mem::align_of::<[u64; 5usize]>() , 8usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u64; 5usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_214() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_215() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_216() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_217() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_218() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_SupportsWeakPtr_instantiation_219() {
        assert_eq!(::std::mem::size_of::<u64>() , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! ( u64 )
                   ));
        assert_eq!(::std::mem::align_of::<u64>() , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   u64 ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_220() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIAtom>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIAtom>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_221() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsRect>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsRect> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsRect>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsRect> ) ));
    }
    #[test]
    fn __bindgen_test_layout_NotNull_instantiation_222() {
        assert_eq!(::std::mem::size_of::<root::mozilla::NotNull<*const root::mozilla::Encoding>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::NotNull<*const root::mozilla::Encoding> )
                   ));
        assert_eq!(::std::mem::align_of::<root::mozilla::NotNull<*const root::mozilla::Encoding>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::NotNull<*const root::mozilla::Encoding> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_NotNull_instantiation_223() {
        assert_eq!(::std::mem::size_of::<root::mozilla::NotNull<*const root::mozilla::Encoding>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::NotNull<*const root::mozilla::Encoding> )
                   ));
        assert_eq!(::std::mem::align_of::<root::mozilla::NotNull<*const root::mozilla::Encoding>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::NotNull<*const root::mozilla::Encoding> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_224() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsITimer>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsITimer> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsITimer>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsITimer> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_instantiation_225() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsRefPtrHashKey_instantiation_226() {
        assert_eq!(::std::mem::size_of::<root::nsRefPtrHashKey<root::nsIAtom>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsRefPtrHashKey<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::nsRefPtrHashKey<root::nsIAtom>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsRefPtrHashKey<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_instantiation_227() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_228() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCOMPtr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCOMPtr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_229() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIAtom>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIAtom>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_230() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::mozilla::dom::NodeInfo>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::NodeInfo> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::mozilla::dom::NodeInfo>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::NodeInfo> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_231() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::mozilla::dom::NodeInfo>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::NodeInfo> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::mozilla::dom::NodeInfo>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::NodeInfo> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_232() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::mozilla::dom::NodeInfo>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::NodeInfo> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::mozilla::dom::NodeInfo>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::NodeInfo> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_233() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::mozilla::dom::NodeInfo>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::NodeInfo> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::mozilla::dom::NodeInfo>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::NodeInfo> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_234() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_235() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_236() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsPIDOMWindow_instantiation_237() {
        assert_eq!(::std::mem::size_of::<[u64; 30usize]>() , 240usize , concat
                   ! (
                   "Size of template specialization: " , stringify ! (
                   [u64; 30usize] ) ));
        assert_eq!(::std::mem::align_of::<[u64; 30usize]>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   [u64; 30usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_238() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIContent>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsRefPtrHashtable_instantiation_239() {
        assert_eq!(::std::mem::size_of::<[u64; 5usize]>() , 40usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u64; 5usize] ) ));
        assert_eq!(::std::mem::align_of::<[u64; 5usize]>() , 8usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u64; 5usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_240() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_241() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_242() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_OwningNonNull_instantiation_243() {
        assert_eq!(::std::mem::size_of::<root::mozilla::OwningNonNull<root::nsINode>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::OwningNonNull<root::nsINode> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::OwningNonNull<root::nsINode>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::OwningNonNull<root::nsINode> ) ));
    }
    #[test]
    fn __bindgen_test_layout_OwningNonNull_instantiation_244() {
        assert_eq!(::std::mem::size_of::<root::mozilla::OwningNonNull<root::nsINode>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::OwningNonNull<root::nsINode> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::OwningNonNull<root::nsINode>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::OwningNonNull<root::nsINode> ) ));
    }
    #[test]
    fn __bindgen_test_layout_OwningNonNull_instantiation_245() {
        assert_eq!(::std::mem::size_of::<root::mozilla::OwningNonNull<root::nsINode>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::OwningNonNull<root::nsINode> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::OwningNonNull<root::nsINode>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::OwningNonNull<root::nsINode> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_246() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_247() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_248() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_instantiation_249() {
        assert_eq!(::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_250() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<root::jsid>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<root::jsid> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<root::jsid>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<root::jsid> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_instantiation_251() {
        assert_eq!(::std::mem::size_of::<root::JS::MutableHandle<root::JS::PropertyDescriptor>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::PropertyDescriptor> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::MutableHandle<root::JS::PropertyDescriptor>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::PropertyDescriptor> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_252() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<root::jsid>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<root::jsid> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<root::jsid>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<root::jsid> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_instantiation_253() {
        assert_eq!(::std::mem::size_of::<root::JS::MutableHandle<root::JS::PropertyDescriptor>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::PropertyDescriptor> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::MutableHandle<root::JS::PropertyDescriptor>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::PropertyDescriptor> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_254() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_255() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_256() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_instantiation_257() {
        assert_eq!(::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::MutableHandle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::MutableHandle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_instantiation_258() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::XBLChildrenElement>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::XBLChildrenElement> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::XBLChildrenElement>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::XBLChildrenElement> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_instantiation_259() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsPtrHashKey_instantiation_260() {
        assert_eq!(::std::mem::size_of::<root::nsPtrHashKey<::std::os::raw::c_void>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsPtrHashKey<::std::os::raw::c_void> ) ));
        assert_eq!(::std::mem::align_of::<root::nsPtrHashKey<::std::os::raw::c_void>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsPtrHashKey<::std::os::raw::c_void> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_261() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIRunnable> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIRunnable> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_262() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIRunnable> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIRunnable> ) ));
    }
    #[test]
    fn __bindgen_test_layout_NotNull_instantiation_263() {
        assert_eq!(::std::mem::size_of::<root::mozilla::NotNull<*const root::mozilla::Encoding>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::NotNull<*const root::mozilla::Encoding> )
                   ));
        assert_eq!(::std::mem::align_of::<root::mozilla::NotNull<*const root::mozilla::Encoding>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::NotNull<*const root::mozilla::Encoding> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_264() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIAtom>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIAtom>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_265() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIAtom>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIAtom>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_266() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIRunnable> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIRunnable> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsPIDOMWindow_instantiation_267() {
        assert_eq!(::std::mem::size_of::<[u64; 30usize]>() , 240usize , concat
                   ! (
                   "Size of template specialization: " , stringify ! (
                   [u64; 30usize] ) ));
        assert_eq!(::std::mem::align_of::<[u64; 30usize]>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   [u64; 30usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_instantiation_268() {
        assert_eq!(::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_instantiation_269() {
        assert_eq!(::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_270() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::mozilla::dom::CSSValue>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::CSSValue> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::mozilla::dom::CSSValue>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::CSSValue> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_instantiation_271() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsRefPtrHashtable_instantiation_272() {
        assert_eq!(::std::mem::size_of::<[u64; 5usize]>() , 40usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u64; 5usize] ) ));
        assert_eq!(::std::mem::align_of::<[u64; 5usize]>() , 8usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u64; 5usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_Rooted_instantiation_273() {
        assert_eq!(::std::mem::size_of::<[u64; 3usize]>() , 24usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u64; 3usize] ) ));
        assert_eq!(::std::mem::align_of::<[u64; 3usize]>() , 8usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u64; 3usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_Rooted_instantiation_274() {
        assert_eq!(::std::mem::size_of::<[u64; 3usize]>() , 24usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u64; 3usize] ) ));
        assert_eq!(::std::mem::align_of::<[u64; 3usize]>() , 8usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u64; 3usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_275() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsISupports>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsISupports> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsISupports>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsISupports> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_instantiation_276() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_instantiation_277() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
    }
    #[test]
    fn __bindgen_test_layout_NotNull_instantiation_278() {
        assert_eq!(::std::mem::size_of::<root::mozilla::NotNull<*const root::mozilla::Encoding>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::NotNull<*const root::mozilla::Encoding> )
                   ));
        assert_eq!(::std::mem::align_of::<root::mozilla::NotNull<*const root::mozilla::Encoding>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::NotNull<*const root::mozilla::Encoding> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_279() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_280() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_instantiation_281() {
        assert_eq!(::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_282() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_instantiation_283() {
        assert_eq!(::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_284() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_285() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_instantiation_286() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_instantiation_287() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_instantiation_288() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_289() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::css::SheetLoadData>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::css::SheetLoadData>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::css::SheetLoadData>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::css::SheetLoadData>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_instantiation_290() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_291() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::mozilla::dom::NodeInfo>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::NodeInfo> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::mozilla::dom::NodeInfo>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::NodeInfo> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_292() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_293() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_294() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<f64>>() , 8usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<f64> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<f64>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<f64> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_instantiation_295() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_296() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_instantiation_297() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_instantiation_298() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::ProfilerBacktrace>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::ProfilerBacktrace> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::ProfilerBacktrace>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::ProfilerBacktrace> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_299() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_300() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_instantiation_301() {
        assert_eq!(::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_302() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_instantiation_303() {
        assert_eq!(::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_304() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIAtom>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIAtom>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsDataHashtable_instantiation_305() {
        assert_eq!(::std::mem::size_of::<[u64; 5usize]>() , 40usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u64; 5usize] ) ));
        assert_eq!(::std::mem::align_of::<[u64; 5usize]>() , 8usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u64; 5usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_OwningNonNull_instantiation_306() {
        assert_eq!(::std::mem::size_of::<root::mozilla::OwningNonNull<root::mozilla::EffectCompositor_AnimationStyleRuleProcessor>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::OwningNonNull<root::mozilla::EffectCompositor_AnimationStyleRuleProcessor>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::OwningNonNull<root::mozilla::EffectCompositor_AnimationStyleRuleProcessor>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::OwningNonNull<root::mozilla::EffectCompositor_AnimationStyleRuleProcessor>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsRefPtrHashKey_instantiation_307() {
        assert_eq!(::std::mem::size_of::<root::nsRefPtrHashKey<root::nsIAtom>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsRefPtrHashKey<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::nsRefPtrHashKey<root::nsIAtom>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsRefPtrHashKey<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsRefPtrHashKey_instantiation_308() {
        assert_eq!(::std::mem::size_of::<root::nsRefPtrHashKey<root::nsIContent>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsRefPtrHashKey<root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::nsRefPtrHashKey<root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsRefPtrHashKey<root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_instantiation_309() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_instantiation_310() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_311() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::mozilla::URLExtraData>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::URLExtraData> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::mozilla::URLExtraData>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::URLExtraData> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsMainThreadPtrHolder_instantiation_312() {
        assert_eq!(::std::mem::size_of::<root::nsMainThreadPtrHolder<root::nsIURI>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsMainThreadPtrHolder<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::nsMainThreadPtrHolder<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsMainThreadPtrHolder<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_313() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::mozilla::URLExtraData>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::URLExtraData> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::mozilla::URLExtraData>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::URLExtraData> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_314() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_315() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_316() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::mozilla::URLExtraData>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::URLExtraData> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::mozilla::URLExtraData>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::URLExtraData> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_317() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::mozilla::URLExtraData>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::URLExtraData> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::mozilla::URLExtraData>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::URLExtraData> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsPtrHashKey_instantiation_318() {
        assert_eq!(::std::mem::size_of::<root::nsPtrHashKey<root::nsIDocument>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsPtrHashKey<root::nsIDocument> ) ));
        assert_eq!(::std::mem::align_of::<root::nsPtrHashKey<root::nsIDocument>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsPtrHashKey<root::nsIDocument> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_319() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIAtom>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIAtom>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_instantiation_320() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_instantiation_321() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsCSSValueList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsCSSValueList> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsCSSValueList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsCSSValueList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_instantiation_322() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_instantiation_323() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsCSSValuePairList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsCSSValuePairList> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsCSSValuePairList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsCSSValuePairList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_324() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsStringBuffer>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsStringBuffer> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsStringBuffer>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsStringBuffer> ) ));
    }
    #[test]
    fn __bindgen_test_layout_SupportsWeakPtr_instantiation_325() {
        assert_eq!(::std::mem::size_of::<u64>() , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! ( u64 )
                   ));
        assert_eq!(::std::mem::align_of::<u64>() , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   u64 ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_326() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_327() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_328() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIAtom>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIAtom>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_329() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Maybe_instantiation_330() {
        assert_eq!(::std::mem::size_of::<[u32; 3usize]>() , 12usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 3usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 3usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 3usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_Maybe_instantiation_331() {
        assert_eq!(::std::mem::size_of::<[u32; 3usize]>() , 12usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 3usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 3usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 3usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_332() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsStyleImageRequest>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsStyleImageRequest> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsStyleImageRequest>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsStyleImageRequest> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_333() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIAtom>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIAtom>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_instantiation_334() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_instantiation_335() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsStyleSides>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsStyleSides> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsStyleSides>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsStyleSides> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_instantiation_336() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_instantiation_337() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsStyleSides>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsStyleSides> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsStyleSides>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsStyleSides> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_338() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Maybe_instantiation_339() {
        assert_eq!(::std::mem::size_of::<[u32; 3usize]>() , 12usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 3usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 3usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 3usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_instantiation_340() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_instantiation_341() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_pair_instantiation_342() {
        assert_eq!(::std::mem::size_of::<root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr>>()
                   , 32usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_343() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::std::pair<::nsstring::nsStringRepr,
                                                     ::nsstring::nsStringRepr>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::std::pair<::nsstring::nsStringRepr,
                                                      ::nsstring::nsStringRepr>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_344() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_345() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_346() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsStyleCoord>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleCoord> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsStyleCoord>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleCoord> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_347() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsStyleCoord>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleCoord> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsStyleCoord>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleCoord> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_instantiation_348() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_instantiation_349() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::RawServoAnimationValue>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::RawServoAnimationValue> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::RawServoAnimationValue>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::RawServoAnimationValue> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsStyleAutoArray_instantiation_350() {
        assert_eq!(::std::mem::size_of::<root::nsStyleAutoArray<root::mozilla::StyleAnimation>>()
                   , 64usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsStyleAutoArray<root::mozilla::StyleAnimation> ) ));
        assert_eq!(::std::mem::align_of::<root::nsStyleAutoArray<root::mozilla::StyleAnimation>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsStyleAutoArray<root::mozilla::StyleAnimation> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_instantiation_351() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_instantiation_352() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsCSSValueList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsCSSValueList> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsCSSValueList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsCSSValueList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_instantiation_353() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_instantiation_354() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsCSSValuePairList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsCSSValuePairList> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsCSSValuePairList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsCSSValuePairList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_instantiation_355() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_instantiation_356() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_NonNull_instantiation_357() {
        assert_eq!(::std::mem::size_of::<root::mozilla::dom::NonNull<root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::dom::NonNull<root::mozilla::dom::Element> )
                   ));
        assert_eq!(::std::mem::align_of::<root::mozilla::dom::NonNull<root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::dom::NonNull<root::mozilla::dom::Element> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_NonNull_instantiation_358() {
        assert_eq!(::std::mem::size_of::<root::mozilla::dom::NonNull<root::mozilla::dom::CSSPseudoElement>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::dom::NonNull<root::mozilla::dom::CSSPseudoElement>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::dom::NonNull<root::mozilla::dom::CSSPseudoElement>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::dom::NonNull<root::mozilla::dom::CSSPseudoElement>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_359() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_instantiation_360() {
        assert_eq!(::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Maybe_instantiation_361() {
        assert_eq!(::std::mem::size_of::<[u64; 18usize]>() , 144usize , concat
                   ! (
                   "Size of template specialization: " , stringify ! (
                   [u64; 18usize] ) ));
        assert_eq!(::std::mem::align_of::<[u64; 18usize]>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   [u64; 18usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_Maybe_instantiation_362() {
        assert_eq!(::std::mem::size_of::<[u64; 18usize]>() , 144usize , concat
                   ! (
                   "Size of template specialization: " , stringify ! (
                   [u64; 18usize] ) ));
        assert_eq!(::std::mem::align_of::<[u64; 18usize]>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   [u64; 18usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_BaseTimeDuration_instantiation_363() {
        assert_eq!(::std::mem::size_of::<root::mozilla::BaseTimeDuration>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::BaseTimeDuration ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::BaseTimeDuration>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::BaseTimeDuration ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_instantiation_364() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_365() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::mozilla::dom::NodeInfo>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::NodeInfo> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::mozilla::dom::NodeInfo>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::NodeInfo> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_366() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::mozilla::dom::NodeInfo>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::NodeInfo> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::mozilla::dom::NodeInfo>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::NodeInfo> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_367() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_368() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_instantiation_369() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsRefPtrHashKey_instantiation_370() {
        assert_eq!(::std::mem::size_of::<root::nsRefPtrHashKey<root::mozilla::dom::DOMIntersectionObserver>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsRefPtrHashKey<root::mozilla::dom::DOMIntersectionObserver>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsRefPtrHashKey<root::mozilla::dom::DOMIntersectionObserver>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsRefPtrHashKey<root::mozilla::dom::DOMIntersectionObserver>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_371() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::mozilla::dom::NodeInfo>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::NodeInfo> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::mozilla::dom::NodeInfo>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::NodeInfo> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_372() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::mozilla::DisplayItemClip_RoundedRect>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::DisplayItemClip_RoundedRect>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::mozilla::DisplayItemClip_RoundedRect>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::DisplayItemClip_RoundedRect>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_373() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_374() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_instantiation_375() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::DOMRect>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DOMRect> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::DOMRect>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DOMRect> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_376() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_instantiation_377() {
        assert_eq!(::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Sequence_instantiation_378() {
        assert_eq!(::std::mem::size_of::<u64>() , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! ( u64 )
                   ));
        assert_eq!(::std::mem::align_of::<u64>() , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   u64 ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_379() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Sequence_instantiation_380() {
        assert_eq!(::std::mem::size_of::<u64>() , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! ( u64 )
                   ));
        assert_eq!(::std::mem::align_of::<u64>() , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   u64 ) ));
    }
    #[test]
    fn __bindgen_test_layout_Sequence_instantiation_381() {
        assert_eq!(::std::mem::size_of::<u64>() , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! ( u64 )
                   ));
        assert_eq!(::std::mem::align_of::<u64>() , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   u64 ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_382() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_383() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_instantiation_384() {
        assert_eq!(::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_385() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_instantiation_386() {
        assert_eq!(::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_387() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsRefPtrHashKey_instantiation_388() {
        assert_eq!(::std::mem::size_of::<root::nsRefPtrHashKey<root::mozilla::dom::Element>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsRefPtrHashKey<root::mozilla::dom::Element> ) ));
        assert_eq!(::std::mem::align_of::<root::nsRefPtrHashKey<root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsRefPtrHashKey<root::mozilla::dom::Element> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsClassHashtable_instantiation_389() {
        assert_eq!(::std::mem::size_of::<[u64; 5usize]>() , 40usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u64; 5usize] ) ));
        assert_eq!(::std::mem::align_of::<[u64; 5usize]>() , 8usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u64; 5usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_390() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_391() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_392() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_393() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_already_AddRefed_instantiation_394() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::mozilla::dom::CSSValue>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::CSSValue> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::mozilla::dom::CSSValue>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::CSSValue> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Handle_instantiation_395() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_instantiation_396() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::mozilla::css::DocumentRule>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::css::DocumentRule> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::mozilla::css::DocumentRule>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::css::DocumentRule> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsAutoPtr_instantiation_397() {
        assert_eq!(::std::mem::size_of::<root::nsAutoPtr<root::nsMediaQuery>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsAutoPtr<root::nsMediaQuery> ) ));
        assert_eq!(::std::mem::align_of::<root::nsAutoPtr<root::nsMediaQuery>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsAutoPtr<root::nsMediaQuery> ) ));
    }
}
