/* automatically generated by rust-bindgen */

pub use self::root::*;
pub use self::root::mozilla::*;
pub use self::root::mozilla::css::*;
pub use self::root::mozilla::dom::*;
use atomic_refcell::AtomicRefCell;
use data::ElementData;
pub type ServoUnsafeCell<T> = ::std::cell::UnsafeCell<T>;
pub type ServoCell<T> = ::std::cell::Cell<T>;
pub type ServoNodeData = AtomicRefCell<ElementData>;
pub type ServoWritingMode = ::logical_geometry::WritingMode;
pub type ServoFontComputationData = ::properties::FontComputationData;
pub type ServoCustomPropertiesMap = Option<::servo_arc::Arc<::custom_properties::CustomPropertiesMap>>;
pub type ServoRuleNode = Option<::rule_tree::StrongRuleNode>;
pub type ServoVisitedStyle = Option<::servo_arc::RawOffsetArc<::properties::ComputedValues>>;
pub type ServoComputedValueFlags = ::properties::computed_value_flags::ComputedValueFlags;
pub type ServoRawOffsetArc<T> = ::servo_arc::RawOffsetArc<T>;
pub type ServoStyleContextStrong = ::gecko_bindings::sugar::ownership::Strong<::properties::ComputedValues>;

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
    impl <T> __BindgenUnionField<T> {
        #[inline]
        pub fn new() -> Self {
            __BindgenUnionField(::std::marker::PhantomData)
        }
        #[inline]
        pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
        #[inline]
        pub unsafe fn as_mut(&mut self) -> &mut T {
            ::std::mem::transmute(self)
        }
    }
    impl <T> ::std::default::Default for __BindgenUnionField<T> {
        #[inline]
        fn default() -> Self { Self::new() }
    }
    impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
        #[inline]
        fn clone(&self) -> Self { Self::new() }
    }
    impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
    impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            fmt.write_str("__BindgenUnionField")
        }
    }
    #[allow(unused_imports)]
    use self::super::root;
    pub const NS_FONT_STYLE_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_STYLE_ITALIC: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_STYLE_OBLIQUE: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_WEIGHT_NORMAL: ::std::os::raw::c_uint = 400;
    pub const NS_FONT_WEIGHT_BOLD: ::std::os::raw::c_uint = 700;
    pub const NS_FONT_WEIGHT_THIN: ::std::os::raw::c_uint = 100;
    pub const NS_FONT_STRETCH_ULTRA_CONDENSED: ::std::os::raw::c_int = -4;
    pub const NS_FONT_STRETCH_EXTRA_CONDENSED: ::std::os::raw::c_int = -3;
    pub const NS_FONT_STRETCH_CONDENSED: ::std::os::raw::c_int = -2;
    pub const NS_FONT_STRETCH_SEMI_CONDENSED: ::std::os::raw::c_int = -1;
    pub const NS_FONT_STRETCH_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_STRETCH_SEMI_EXPANDED: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_STRETCH_EXPANDED: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_STRETCH_EXTRA_EXPANDED: ::std::os::raw::c_uint = 3;
    pub const NS_FONT_STRETCH_ULTRA_EXPANDED: ::std::os::raw::c_uint = 4;
    pub const NS_FONT_SMOOTHING_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_SMOOTHING_GRAYSCALE: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_KERNING_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_KERNING_NONE: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_KERNING_NORMAL: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_SYNTHESIS_WEIGHT: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_SYNTHESIS_STYLE: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_DISPLAY_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_DISPLAY_BLOCK: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_DISPLAY_SWAP: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_DISPLAY_FALLBACK: ::std::os::raw::c_uint = 3;
    pub const NS_FONT_DISPLAY_OPTIONAL: ::std::os::raw::c_uint = 4;
    pub const NS_FONT_VARIANT_ALTERNATES_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_ALTERNATES_HISTORICAL: ::std::os::raw::c_uint =
        1;
    pub const NS_FONT_VARIANT_ALTERNATES_STYLISTIC: ::std::os::raw::c_uint =
        2;
    pub const NS_FONT_VARIANT_ALTERNATES_STYLESET: ::std::os::raw::c_uint = 4;
    pub const NS_FONT_VARIANT_ALTERNATES_CHARACTER_VARIANT:
              ::std::os::raw::c_uint =
        8;
    pub const NS_FONT_VARIANT_ALTERNATES_SWASH: ::std::os::raw::c_uint = 16;
    pub const NS_FONT_VARIANT_ALTERNATES_ORNAMENTS: ::std::os::raw::c_uint =
        32;
    pub const NS_FONT_VARIANT_ALTERNATES_ANNOTATION: ::std::os::raw::c_uint =
        64;
    pub const NS_FONT_VARIANT_ALTERNATES_COUNT: ::std::os::raw::c_uint = 7;
    pub const NS_FONT_VARIANT_ALTERNATES_ENUMERATED_MASK:
              ::std::os::raw::c_uint =
        1;
    pub const NS_FONT_VARIANT_ALTERNATES_FUNCTIONAL_MASK:
              ::std::os::raw::c_uint =
        126;
    pub const NS_FONT_VARIANT_CAPS_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_CAPS_SMALLCAPS: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_VARIANT_CAPS_ALLSMALL: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_VARIANT_CAPS_PETITECAPS: ::std::os::raw::c_uint = 3;
    pub const NS_FONT_VARIANT_CAPS_ALLPETITE: ::std::os::raw::c_uint = 4;
    pub const NS_FONT_VARIANT_CAPS_TITLING: ::std::os::raw::c_uint = 5;
    pub const NS_FONT_VARIANT_CAPS_UNICASE: ::std::os::raw::c_uint = 6;
    pub const NS_FONT_VARIANT_EAST_ASIAN_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_EAST_ASIAN_JIS78: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_VARIANT_EAST_ASIAN_JIS83: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_VARIANT_EAST_ASIAN_JIS90: ::std::os::raw::c_uint = 4;
    pub const NS_FONT_VARIANT_EAST_ASIAN_JIS04: ::std::os::raw::c_uint = 8;
    pub const NS_FONT_VARIANT_EAST_ASIAN_SIMPLIFIED: ::std::os::raw::c_uint =
        16;
    pub const NS_FONT_VARIANT_EAST_ASIAN_TRADITIONAL: ::std::os::raw::c_uint =
        32;
    pub const NS_FONT_VARIANT_EAST_ASIAN_FULL_WIDTH: ::std::os::raw::c_uint =
        64;
    pub const NS_FONT_VARIANT_EAST_ASIAN_PROP_WIDTH: ::std::os::raw::c_uint =
        128;
    pub const NS_FONT_VARIANT_EAST_ASIAN_RUBY: ::std::os::raw::c_uint = 256;
    pub const NS_FONT_VARIANT_EAST_ASIAN_COUNT: ::std::os::raw::c_uint = 9;
    pub const NS_FONT_VARIANT_EAST_ASIAN_VARIANT_MASK: ::std::os::raw::c_uint
              =
        63;
    pub const NS_FONT_VARIANT_EAST_ASIAN_WIDTH_MASK: ::std::os::raw::c_uint =
        192;
    pub const NS_FONT_VARIANT_LIGATURES_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_LIGATURES_NONE: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_VARIANT_LIGATURES_COMMON: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_VARIANT_LIGATURES_NO_COMMON: ::std::os::raw::c_uint = 4;
    pub const NS_FONT_VARIANT_LIGATURES_DISCRETIONARY: ::std::os::raw::c_uint
              =
        8;
    pub const NS_FONT_VARIANT_LIGATURES_NO_DISCRETIONARY:
              ::std::os::raw::c_uint =
        16;
    pub const NS_FONT_VARIANT_LIGATURES_HISTORICAL: ::std::os::raw::c_uint =
        32;
    pub const NS_FONT_VARIANT_LIGATURES_NO_HISTORICAL: ::std::os::raw::c_uint
              =
        64;
    pub const NS_FONT_VARIANT_LIGATURES_CONTEXTUAL: ::std::os::raw::c_uint =
        128;
    pub const NS_FONT_VARIANT_LIGATURES_NO_CONTEXTUAL: ::std::os::raw::c_uint
              =
        256;
    pub const NS_FONT_VARIANT_LIGATURES_COUNT: ::std::os::raw::c_uint = 9;
    pub const NS_FONT_VARIANT_LIGATURES_COMMON_MASK: ::std::os::raw::c_uint =
        6;
    pub const NS_FONT_VARIANT_LIGATURES_DISCRETIONARY_MASK:
              ::std::os::raw::c_uint =
        24;
    pub const NS_FONT_VARIANT_LIGATURES_HISTORICAL_MASK:
              ::std::os::raw::c_uint =
        96;
    pub const NS_FONT_VARIANT_LIGATURES_CONTEXTUAL_MASK:
              ::std::os::raw::c_uint =
        384;
    pub const NS_FONT_VARIANT_NUMERIC_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_NUMERIC_LINING: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_VARIANT_NUMERIC_OLDSTYLE: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_VARIANT_NUMERIC_PROPORTIONAL: ::std::os::raw::c_uint =
        4;
    pub const NS_FONT_VARIANT_NUMERIC_TABULAR: ::std::os::raw::c_uint = 8;
    pub const NS_FONT_VARIANT_NUMERIC_DIAGONAL_FRACTIONS:
              ::std::os::raw::c_uint =
        16;
    pub const NS_FONT_VARIANT_NUMERIC_STACKED_FRACTIONS:
              ::std::os::raw::c_uint =
        32;
    pub const NS_FONT_VARIANT_NUMERIC_SLASHZERO: ::std::os::raw::c_uint = 64;
    pub const NS_FONT_VARIANT_NUMERIC_ORDINAL: ::std::os::raw::c_uint = 128;
    pub const NS_FONT_VARIANT_NUMERIC_COUNT: ::std::os::raw::c_uint = 8;
    pub const NS_FONT_VARIANT_NUMERIC_FIGURE_MASK: ::std::os::raw::c_uint = 3;
    pub const NS_FONT_VARIANT_NUMERIC_SPACING_MASK: ::std::os::raw::c_uint =
        12;
    pub const NS_FONT_VARIANT_NUMERIC_FRACTION_MASK: ::std::os::raw::c_uint =
        48;
    pub const NS_FONT_VARIANT_POSITION_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_POSITION_SUPER: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_VARIANT_POSITION_SUB: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_VARIANT_WIDTH_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_WIDTH_FULL: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_VARIANT_WIDTH_HALF: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_VARIANT_WIDTH_THIRD: ::std::os::raw::c_uint = 3;
    pub const NS_FONT_VARIANT_WIDTH_QUARTER: ::std::os::raw::c_uint = 4;
    pub const NS_FONT_SUBSCRIPT_OFFSET_RATIO: f64 = 0.2;
    pub const NS_FONT_SUPERSCRIPT_OFFSET_RATIO: f64 = 0.34;
    pub const NS_FONT_SUB_SUPER_SIZE_RATIO_SMALL: f64 = 0.82;
    pub const NS_FONT_SUB_SUPER_SIZE_RATIO_LARGE: f64 = 0.667;
    pub const NS_FONT_SUB_SUPER_SMALL_SIZE: f64 = 20.;
    pub const NS_FONT_SUB_SUPER_LARGE_SIZE: f64 = 45.;
    pub const NS_FONT_VARIANT_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_SMALL_CAPS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_AZIMUTH_LEFT_SIDE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_AZIMUTH_FAR_LEFT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_AZIMUTH_LEFT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_AZIMUTH_CENTER_LEFT: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_AZIMUTH_CENTER: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_AZIMUTH_CENTER_RIGHT: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_AZIMUTH_RIGHT: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_AZIMUTH_FAR_RIGHT: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_AZIMUTH_RIGHT_SIDE: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_AZIMUTH_BEHIND: ::std::os::raw::c_uint = 128;
    pub const NS_STYLE_AZIMUTH_LEFTWARDS: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_AZIMUTH_RIGHTWARDS: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_ELEVATION_BELOW: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_ELEVATION_LEVEL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_ELEVATION_ABOVE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_ELEVATION_HIGHER: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_ELEVATION_LOWER: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_PITCH_X_LOW: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PITCH_LOW: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_PITCH_MEDIUM: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_PITCH_HIGH: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_PITCH_X_HIGH: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_SPEAK_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SPEAK_NORMAL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SPEAK_SPELL_OUT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_SPEAK_HEADER_ONCE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SPEAK_HEADER_ALWAYS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SPEAK_NUMERAL_DIGITS: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SPEAK_NUMERAL_CONTINUOUS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SPEAK_PUNCTUATION_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SPEAK_PUNCTUATION_CODE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SPEECH_RATE_X_SLOW: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SPEECH_RATE_SLOW: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SPEECH_RATE_MEDIUM: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_SPEECH_RATE_FAST: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_SPEECH_RATE_X_FAST: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_SPEECH_RATE_FASTER: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_SPEECH_RATE_SLOWER: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_VOLUME_SILENT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_VOLUME_X_SOFT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_VOLUME_SOFT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_VOLUME_MEDIUM: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_VOLUME_LOUD: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_VOLUME_X_LOUD: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_COLOR_INHERIT_FROM_BODY: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_WILL_CHANGE_STACKING_CONTEXT: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_WILL_CHANGE_TRANSFORM: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_WILL_CHANGE_SCROLL: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_WILL_CHANGE_OPACITY: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_WILL_CHANGE_FIXPOS_CB: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_WILL_CHANGE_ABSPOS_CB: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_ANIMATION_ITERATION_COUNT_INFINITE:
              ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_ANIMATION_PLAY_STATE_RUNNING: ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_ANIMATION_PLAY_STATE_PAUSED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_IMAGELAYER_ATTACHMENT_SCROLL: ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_IMAGELAYER_ATTACHMENT_FIXED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_IMAGELAYER_ATTACHMENT_LOCAL: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_IMAGELAYER_CLIP_MOZ_ALMOST_PADDING:
              ::std::os::raw::c_uint =
        127;
    pub const NS_STYLE_IMAGELAYER_POSITION_CENTER: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_IMAGELAYER_POSITION_TOP: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_IMAGELAYER_POSITION_BOTTOM: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_IMAGELAYER_POSITION_LEFT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_IMAGELAYER_POSITION_RIGHT: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_IMAGELAYER_SIZE_CONTAIN: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_IMAGELAYER_SIZE_COVER: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_MASK_MODE_ALPHA: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_MASK_MODE_LUMINANCE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_MASK_MODE_MATCH_SOURCE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_BG_INLINE_POLICY_EACH_BOX: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BG_INLINE_POLICY_CONTINUOUS: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_BG_INLINE_POLICY_BOUNDING_BOX: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_BORDER_COLLAPSE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BORDER_SEPARATE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BORDER_WIDTH_THIN: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BORDER_WIDTH_MEDIUM: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BORDER_WIDTH_THICK: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_BORDER_STYLE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BORDER_STYLE_GROOVE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BORDER_STYLE_RIDGE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_BORDER_STYLE_DOTTED: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_BORDER_STYLE_DASHED: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_BORDER_STYLE_SOLID: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_BORDER_STYLE_DOUBLE: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_BORDER_STYLE_INSET: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_BORDER_STYLE_OUTSET: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_BORDER_STYLE_HIDDEN: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_BORDER_STYLE_AUTO: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_BORDER_IMAGE_REPEAT_STRETCH: ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_BORDER_IMAGE_REPEAT_REPEAT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BORDER_IMAGE_REPEAT_ROUND: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_BORDER_IMAGE_REPEAT_SPACE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_BORDER_IMAGE_SLICE_NOFILL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BORDER_IMAGE_SLICE_FILL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CURSOR_AUTO: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CURSOR_CROSSHAIR: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_CURSOR_DEFAULT: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_CURSOR_POINTER: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_CURSOR_MOVE: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_CURSOR_E_RESIZE: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_CURSOR_NE_RESIZE: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_CURSOR_NW_RESIZE: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_CURSOR_N_RESIZE: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_CURSOR_SE_RESIZE: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_CURSOR_SW_RESIZE: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_CURSOR_S_RESIZE: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_CURSOR_W_RESIZE: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_CURSOR_TEXT: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_CURSOR_WAIT: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_CURSOR_HELP: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_CURSOR_COPY: ::std::os::raw::c_uint = 17;
    pub const NS_STYLE_CURSOR_ALIAS: ::std::os::raw::c_uint = 18;
    pub const NS_STYLE_CURSOR_CONTEXT_MENU: ::std::os::raw::c_uint = 19;
    pub const NS_STYLE_CURSOR_CELL: ::std::os::raw::c_uint = 20;
    pub const NS_STYLE_CURSOR_GRAB: ::std::os::raw::c_uint = 21;
    pub const NS_STYLE_CURSOR_GRABBING: ::std::os::raw::c_uint = 22;
    pub const NS_STYLE_CURSOR_SPINNING: ::std::os::raw::c_uint = 23;
    pub const NS_STYLE_CURSOR_ZOOM_IN: ::std::os::raw::c_uint = 24;
    pub const NS_STYLE_CURSOR_ZOOM_OUT: ::std::os::raw::c_uint = 25;
    pub const NS_STYLE_CURSOR_NOT_ALLOWED: ::std::os::raw::c_uint = 26;
    pub const NS_STYLE_CURSOR_COL_RESIZE: ::std::os::raw::c_uint = 27;
    pub const NS_STYLE_CURSOR_ROW_RESIZE: ::std::os::raw::c_uint = 28;
    pub const NS_STYLE_CURSOR_NO_DROP: ::std::os::raw::c_uint = 29;
    pub const NS_STYLE_CURSOR_VERTICAL_TEXT: ::std::os::raw::c_uint = 30;
    pub const NS_STYLE_CURSOR_ALL_SCROLL: ::std::os::raw::c_uint = 31;
    pub const NS_STYLE_CURSOR_NESW_RESIZE: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_CURSOR_NWSE_RESIZE: ::std::os::raw::c_uint = 33;
    pub const NS_STYLE_CURSOR_NS_RESIZE: ::std::os::raw::c_uint = 34;
    pub const NS_STYLE_CURSOR_EW_RESIZE: ::std::os::raw::c_uint = 35;
    pub const NS_STYLE_CURSOR_NONE: ::std::os::raw::c_uint = 36;
    pub const NS_STYLE_DIRECTION_LTR: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_DIRECTION_RTL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WRITING_MODE_HORIZONTAL_TB: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_WRITING_MODE_VERTICAL_RL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WRITING_MODE_VERTICAL_LR: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_WRITING_MODE_SIDEWAYS_MASK: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_WRITING_MODE_SIDEWAYS_RL: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_WRITING_MODE_SIDEWAYS_LR: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_CONTAIN_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CONTAIN_STRICT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CONTAIN_LAYOUT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_CONTAIN_STYLE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_CONTAIN_PAINT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_CONTAIN_ALL_BITS: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_ALIGN_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_ALIGN_NORMAL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_ALIGN_START: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_ALIGN_END: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_ALIGN_FLEX_START: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_ALIGN_FLEX_END: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_ALIGN_CENTER: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_ALIGN_LEFT: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_ALIGN_RIGHT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_ALIGN_BASELINE: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_ALIGN_LAST_BASELINE: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_ALIGN_STRETCH: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_ALIGN_SELF_START: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_ALIGN_SELF_END: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_ALIGN_SPACE_BETWEEN: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_ALIGN_SPACE_AROUND: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_ALIGN_SPACE_EVENLY: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_ALIGN_LEGACY: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_ALIGN_SAFE: ::std::os::raw::c_uint = 64;
    pub const NS_STYLE_ALIGN_UNSAFE: ::std::os::raw::c_uint = 128;
    pub const NS_STYLE_ALIGN_FLAG_BITS: ::std::os::raw::c_uint = 224;
    pub const NS_STYLE_ALIGN_ALL_BITS: ::std::os::raw::c_uint = 255;
    pub const NS_STYLE_ALIGN_ALL_SHIFT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_JUSTIFY_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_JUSTIFY_NORMAL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_JUSTIFY_START: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_JUSTIFY_END: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_JUSTIFY_FLEX_START: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_JUSTIFY_FLEX_END: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_JUSTIFY_CENTER: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_JUSTIFY_LEFT: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_JUSTIFY_RIGHT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_JUSTIFY_BASELINE: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_JUSTIFY_LAST_BASELINE: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_JUSTIFY_STRETCH: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_JUSTIFY_SELF_START: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_JUSTIFY_SELF_END: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_JUSTIFY_SPACE_BETWEEN: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_JUSTIFY_SPACE_AROUND: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_JUSTIFY_SPACE_EVENLY: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_JUSTIFY_LEGACY: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_JUSTIFY_SAFE: ::std::os::raw::c_uint = 64;
    pub const NS_STYLE_JUSTIFY_UNSAFE: ::std::os::raw::c_uint = 128;
    pub const NS_STYLE_JUSTIFY_FLAG_BITS: ::std::os::raw::c_uint = 224;
    pub const NS_STYLE_JUSTIFY_ALL_BITS: ::std::os::raw::c_uint = 255;
    pub const NS_STYLE_JUSTIFY_ALL_SHIFT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_FLEX_DIRECTION_ROW: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FLEX_DIRECTION_ROW_REVERSE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FLEX_DIRECTION_COLUMN: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FLEX_DIRECTION_COLUMN_REVERSE: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_FLEX_WRAP_NOWRAP: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FLEX_WRAP_WRAP: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FLEX_WRAP_WRAP_REVERSE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_ORDER_INITIAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_JUSTIFY_CONTENT_FLEX_START: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_JUSTIFY_CONTENT_FLEX_END: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_JUSTIFY_CONTENT_CENTER: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_JUSTIFY_CONTENT_SPACE_BETWEEN: ::std::os::raw::c_uint =
        14;
    pub const NS_STYLE_JUSTIFY_CONTENT_SPACE_AROUND: ::std::os::raw::c_uint =
        15;
    pub const NS_STYLE_FILTER_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FILTER_URL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FILTER_BLUR: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FILTER_BRIGHTNESS: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_FILTER_CONTRAST: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_FILTER_GRAYSCALE: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_FILTER_INVERT: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_FILTER_OPACITY: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_FILTER_SATURATE: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_FILTER_SEPIA: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_FILTER_HUE_ROTATE: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_FILTER_DROP_SHADOW: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_FONT_STYLE_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FONT_STYLE_ITALIC: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FONT_STYLE_OBLIQUE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FONT_WEIGHT_NORMAL: ::std::os::raw::c_uint = 400;
    pub const NS_STYLE_FONT_WEIGHT_BOLD: ::std::os::raw::c_uint = 700;
    pub const NS_STYLE_FONT_WEIGHT_BOLDER: ::std::os::raw::c_int = -1;
    pub const NS_STYLE_FONT_WEIGHT_LIGHTER: ::std::os::raw::c_int = -2;
    pub const NS_STYLE_FONT_SIZE_XXSMALL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FONT_SIZE_XSMALL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FONT_SIZE_SMALL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FONT_SIZE_MEDIUM: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_FONT_SIZE_LARGE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_FONT_SIZE_XLARGE: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_FONT_SIZE_XXLARGE: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_FONT_SIZE_XXXLARGE: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_FONT_SIZE_LARGER: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_FONT_SIZE_SMALLER: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_FONT_STRETCH_ULTRA_CONDENSED: ::std::os::raw::c_int =
        -4;
    pub const NS_STYLE_FONT_STRETCH_EXTRA_CONDENSED: ::std::os::raw::c_int =
        -3;
    pub const NS_STYLE_FONT_STRETCH_CONDENSED: ::std::os::raw::c_int = -2;
    pub const NS_STYLE_FONT_STRETCH_SEMI_CONDENSED: ::std::os::raw::c_int =
        -1;
    pub const NS_STYLE_FONT_STRETCH_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FONT_STRETCH_SEMI_EXPANDED: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FONT_STRETCH_EXPANDED: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FONT_STRETCH_EXTRA_EXPANDED: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_FONT_STRETCH_ULTRA_EXPANDED: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_FONT_CAPTION: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FONT_ICON: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FONT_MENU: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_FONT_MESSAGE_BOX: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_FONT_SMALL_CAPTION: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_FONT_STATUS_BAR: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_FONT_WINDOW: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_FONT_DOCUMENT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_FONT_WORKSPACE: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_FONT_DESKTOP: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_FONT_INFO: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_FONT_DIALOG: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_FONT_BUTTON: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_FONT_PULL_DOWN_MENU: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_FONT_LIST: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_FONT_FIELD: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_GRID_AUTO_FLOW_ROW: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_GRID_AUTO_FLOW_COLUMN: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_GRID_AUTO_FLOW_DENSE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_GRID_TEMPLATE_SUBGRID: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_GRID_REPEAT_AUTO_FILL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_GRID_REPEAT_AUTO_FIT: ::std::os::raw::c_uint = 1;
    pub const NS_MATHML_DEFAULT_SCRIPT_SIZE_MULTIPLIER: f64 = 0.71;
    pub const NS_MATHML_DEFAULT_SCRIPT_MIN_SIZE_PT: ::std::os::raw::c_uint =
        8;
    pub const NS_MATHML_MATHVARIANT_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_MATHML_MATHVARIANT_NORMAL: ::std::os::raw::c_uint = 1;
    pub const NS_MATHML_MATHVARIANT_BOLD: ::std::os::raw::c_uint = 2;
    pub const NS_MATHML_MATHVARIANT_ITALIC: ::std::os::raw::c_uint = 3;
    pub const NS_MATHML_MATHVARIANT_BOLD_ITALIC: ::std::os::raw::c_uint = 4;
    pub const NS_MATHML_MATHVARIANT_SCRIPT: ::std::os::raw::c_uint = 5;
    pub const NS_MATHML_MATHVARIANT_BOLD_SCRIPT: ::std::os::raw::c_uint = 6;
    pub const NS_MATHML_MATHVARIANT_FRAKTUR: ::std::os::raw::c_uint = 7;
    pub const NS_MATHML_MATHVARIANT_DOUBLE_STRUCK: ::std::os::raw::c_uint = 8;
    pub const NS_MATHML_MATHVARIANT_BOLD_FRAKTUR: ::std::os::raw::c_uint = 9;
    pub const NS_MATHML_MATHVARIANT_SANS_SERIF: ::std::os::raw::c_uint = 10;
    pub const NS_MATHML_MATHVARIANT_BOLD_SANS_SERIF: ::std::os::raw::c_uint =
        11;
    pub const NS_MATHML_MATHVARIANT_SANS_SERIF_ITALIC: ::std::os::raw::c_uint
              =
        12;
    pub const NS_MATHML_MATHVARIANT_SANS_SERIF_BOLD_ITALIC:
              ::std::os::raw::c_uint =
        13;
    pub const NS_MATHML_MATHVARIANT_MONOSPACE: ::std::os::raw::c_uint = 14;
    pub const NS_MATHML_MATHVARIANT_INITIAL: ::std::os::raw::c_uint = 15;
    pub const NS_MATHML_MATHVARIANT_TAILED: ::std::os::raw::c_uint = 16;
    pub const NS_MATHML_MATHVARIANT_LOOPED: ::std::os::raw::c_uint = 17;
    pub const NS_MATHML_MATHVARIANT_STRETCHED: ::std::os::raw::c_uint = 18;
    pub const NS_MATHML_DISPLAYSTYLE_INLINE: ::std::os::raw::c_uint = 0;
    pub const NS_MATHML_DISPLAYSTYLE_BLOCK: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WIDTH_MAX_CONTENT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_WIDTH_MIN_CONTENT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WIDTH_FIT_CONTENT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_WIDTH_AVAILABLE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_POSITION_STATIC: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_POSITION_RELATIVE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_POSITION_ABSOLUTE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_POSITION_FIXED: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_POSITION_STICKY: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_CLIP_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CLIP_RECT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CLIP_TYPE_MASK: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_CLIP_LEFT_AUTO: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_CLIP_TOP_AUTO: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_CLIP_RIGHT_AUTO: ::std::os::raw::c_uint = 64;
    pub const NS_STYLE_CLIP_BOTTOM_AUTO: ::std::os::raw::c_uint = 128;
    pub const NS_STYLE_FRAME_YES: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FRAME_NO: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FRAME_0: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FRAME_1: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_FRAME_ON: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_FRAME_OFF: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_FRAME_AUTO: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_FRAME_SCROLL: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_FRAME_NOSCROLL: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_OVERFLOW_VISIBLE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_OVERFLOW_HIDDEN: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_OVERFLOW_SCROLL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_OVERFLOW_AUTO: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_OVERFLOW_CLIP: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_OVERFLOW_SCROLLBARS_HORIZONTAL: ::std::os::raw::c_uint
              =
        5;
    pub const NS_STYLE_OVERFLOW_SCROLLBARS_VERTICAL: ::std::os::raw::c_uint =
        6;
    pub const NS_STYLE_OVERFLOW_CLIP_BOX_PADDING_BOX: ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_OVERFLOW_CLIP_BOX_CONTENT_BOX: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_LIST_STYLE_CUSTOM: ::std::os::raw::c_int = -1;
    pub const NS_STYLE_LIST_STYLE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_LIST_STYLE_DECIMAL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_LIST_STYLE_DISC: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_LIST_STYLE_CIRCLE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_LIST_STYLE_SQUARE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_LIST_STYLE_DISCLOSURE_CLOSED: ::std::os::raw::c_uint =
        5;
    pub const NS_STYLE_LIST_STYLE_DISCLOSURE_OPEN: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_LIST_STYLE_HEBREW: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_LIST_STYLE_JAPANESE_INFORMAL: ::std::os::raw::c_uint =
        8;
    pub const NS_STYLE_LIST_STYLE_JAPANESE_FORMAL: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_LIST_STYLE_KOREAN_HANGUL_FORMAL: ::std::os::raw::c_uint
              =
        10;
    pub const NS_STYLE_LIST_STYLE_KOREAN_HANJA_INFORMAL:
              ::std::os::raw::c_uint =
        11;
    pub const NS_STYLE_LIST_STYLE_KOREAN_HANJA_FORMAL: ::std::os::raw::c_uint
              =
        12;
    pub const NS_STYLE_LIST_STYLE_SIMP_CHINESE_INFORMAL:
              ::std::os::raw::c_uint =
        13;
    pub const NS_STYLE_LIST_STYLE_SIMP_CHINESE_FORMAL: ::std::os::raw::c_uint
              =
        14;
    pub const NS_STYLE_LIST_STYLE_TRAD_CHINESE_INFORMAL:
              ::std::os::raw::c_uint =
        15;
    pub const NS_STYLE_LIST_STYLE_TRAD_CHINESE_FORMAL: ::std::os::raw::c_uint
              =
        16;
    pub const NS_STYLE_LIST_STYLE_ETHIOPIC_NUMERIC: ::std::os::raw::c_uint =
        17;
    pub const NS_STYLE_LIST_STYLE_LOWER_ROMAN: ::std::os::raw::c_uint = 100;
    pub const NS_STYLE_LIST_STYLE_UPPER_ROMAN: ::std::os::raw::c_uint = 101;
    pub const NS_STYLE_LIST_STYLE_LOWER_ALPHA: ::std::os::raw::c_uint = 102;
    pub const NS_STYLE_LIST_STYLE_UPPER_ALPHA: ::std::os::raw::c_uint = 103;
    pub const NS_STYLE_LIST_STYLE_POSITION_INSIDE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_LIST_STYLE_POSITION_OUTSIDE: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_MARGIN_SIZE_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_POINTER_EVENTS_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_POINTER_EVENTS_VISIBLEPAINTED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_POINTER_EVENTS_VISIBLEFILL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_POINTER_EVENTS_VISIBLESTROKE: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_POINTER_EVENTS_VISIBLE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_POINTER_EVENTS_PAINTED: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_POINTER_EVENTS_FILL: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_POINTER_EVENTS_STROKE: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_POINTER_EVENTS_ALL: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_POINTER_EVENTS_AUTO: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_IMAGE_ORIENTATION_FLIP: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_IMAGE_ORIENTATION_FROM_IMAGE: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_ISOLATION_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_ISOLATION_ISOLATE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_OBJECT_FIT_FILL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_OBJECT_FIT_CONTAIN: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_OBJECT_FIT_COVER: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_OBJECT_FIT_NONE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_OBJECT_FIT_SCALE_DOWN: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_RESIZE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_RESIZE_BOTH: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_RESIZE_HORIZONTAL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_RESIZE_VERTICAL: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_TEXT_ALIGN_START: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_ALIGN_LEFT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_ALIGN_RIGHT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_ALIGN_CENTER: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_TEXT_ALIGN_JUSTIFY: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_TEXT_ALIGN_CHAR: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_TEXT_ALIGN_END: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_TEXT_ALIGN_AUTO: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_TEXT_ALIGN_MOZ_CENTER: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_TEXT_ALIGN_MOZ_RIGHT: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_TEXT_ALIGN_MOZ_LEFT: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_TEXT_ALIGN_MOZ_CENTER_OR_INHERIT:
              ::std::os::raw::c_uint =
        11;
    pub const NS_STYLE_TEXT_ALIGN_UNSAFE: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_TEXT_ALIGN_MATCH_PARENT: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_TEXT_DECORATION_LINE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE: ::std::os::raw::c_uint
              =
        1;
    pub const NS_STYLE_TEXT_DECORATION_LINE_OVERLINE: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH:
              ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_TEXT_DECORATION_LINE_BLINK: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_TEXT_DECORATION_LINE_OVERRIDE_ALL:
              ::std::os::raw::c_uint =
        16;
    pub const NS_STYLE_TEXT_DECORATION_LINE_LINES_MASK: ::std::os::raw::c_uint
              =
        7;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_DOTTED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_DASHED: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_SOLID: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_DOUBLE: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_WAVY: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_MAX: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_TEXT_OVERFLOW_CLIP: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_OVERFLOW_ELLIPSIS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_OVERFLOW_STRING: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_TRANSFORM_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_TRANSFORM_CAPITALIZE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_TRANSFORM_LOWERCASE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_TRANSFORM_UPPERCASE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_TEXT_TRANSFORM_FULL_WIDTH: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_TOUCH_ACTION_NONE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TOUCH_ACTION_AUTO: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TOUCH_ACTION_PAN_X: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_TOUCH_ACTION_PAN_Y: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_TOUCH_ACTION_MANIPULATION: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_TOP_LAYER_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TOP_LAYER_TOP: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE: ::std::os::raw::c_uint
              =
        0;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_LINEAR:
              ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN:
              ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_OUT:
              ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN_OUT:
              ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_STEP_START:
              ::std::os::raw::c_uint =
        5;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_STEP_END:
              ::std::os::raw::c_uint =
        6;
    pub const NS_STYLE_VERTICAL_ALIGN_BASELINE: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_VERTICAL_ALIGN_SUB: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_VERTICAL_ALIGN_SUPER: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_VERTICAL_ALIGN_TOP: ::std::os::raw::c_uint = 17;
    pub const NS_STYLE_VERTICAL_ALIGN_TEXT_TOP: ::std::os::raw::c_uint = 18;
    pub const NS_STYLE_VERTICAL_ALIGN_MIDDLE: ::std::os::raw::c_uint = 19;
    pub const NS_STYLE_VERTICAL_ALIGN_TEXT_BOTTOM: ::std::os::raw::c_uint =
        20;
    pub const NS_STYLE_VERTICAL_ALIGN_BOTTOM: ::std::os::raw::c_uint = 21;
    pub const NS_STYLE_VERTICAL_ALIGN_MIDDLE_WITH_BASELINE:
              ::std::os::raw::c_uint =
        22;
    pub const NS_STYLE_VISIBILITY_HIDDEN: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_VISIBILITY_VISIBLE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_VISIBILITY_COLLAPSE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TABSIZE_INITIAL: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_WORDBREAK_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_WORDBREAK_BREAK_ALL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WORDBREAK_KEEP_ALL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_OVERFLOWWRAP_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_OVERFLOWWRAP_BREAK_WORD: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_RUBY_ALIGN_START: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_RUBY_ALIGN_CENTER: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_RUBY_ALIGN_SPACE_BETWEEN: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_RUBY_ALIGN_SPACE_AROUND: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_RUBY_POSITION_OVER: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_RUBY_POSITION_UNDER: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_RUBY_POSITION_INTER_CHARACTER: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_SIZE_ADJUST_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_SIZE_ADJUST_AUTO: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_ORIENTATION_MIXED: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_ORIENTATION_UPRIGHT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_ORIENTATION_SIDEWAYS: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_ALL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_DIGITS_2: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_DIGITS_3: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_DIGITS_4: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_LINE_HEIGHT_BLOCK_HEIGHT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_UNICODE_BIDI_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_UNICODE_BIDI_EMBED: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_UNICODE_BIDI_ISOLATE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_UNICODE_BIDI_BIDI_OVERRIDE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_UNICODE_BIDI_ISOLATE_OVERRIDE: ::std::os::raw::c_uint =
        6;
    pub const NS_STYLE_UNICODE_BIDI_PLAINTEXT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_TABLE_LAYOUT_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TABLE_LAYOUT_FIXED: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TABLE_EMPTY_CELLS_HIDE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TABLE_EMPTY_CELLS_SHOW: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CAPTION_SIDE_TOP: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CAPTION_SIDE_RIGHT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CAPTION_SIDE_BOTTOM: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_CAPTION_SIDE_LEFT: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE: ::std::os::raw::c_uint =
        5;
    pub const NS_STYLE_CELL_SCOPE_ROW: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CELL_SCOPE_COL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CELL_SCOPE_ROWGROUP: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_CELL_SCOPE_COLGROUP: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_PAGE_MARKS_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_PAGE_MARKS_CROP: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PAGE_MARKS_REGISTER: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_PAGE_SIZE_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_PAGE_SIZE_PORTRAIT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PAGE_SIZE_LANDSCAPE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_PAGE_BREAK_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_PAGE_BREAK_ALWAYS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PAGE_BREAK_AVOID: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_PAGE_BREAK_LEFT: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_PAGE_BREAK_RIGHT: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_COLUMN_COUNT_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COLUMN_COUNT_UNLIMITED: ::std::os::raw::c_int = -1;
    pub const NS_STYLE_COLUMN_FILL_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COLUMN_FILL_BALANCE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_COLUMN_SPAN_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COLUMN_SPAN_ALL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_IME_MODE_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_IME_MODE_NORMAL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_IME_MODE_ACTIVE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_IME_MODE_DISABLED: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_IME_MODE_INACTIVE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_GRADIENT_SHAPE_LINEAR: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_GRADIENT_SHAPE_ELLIPTICAL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_GRADIENT_SHAPE_CIRCULAR: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_GRADIENT_SIZE_CLOSEST_SIDE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_GRADIENT_SIZE_CLOSEST_CORNER: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_GRADIENT_SIZE_FARTHEST_SIDE: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_GRADIENT_SIZE_FARTHEST_CORNER: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_GRADIENT_SIZE_EXPLICIT_SIZE: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_CONTEXT_PROPERTY_FILL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CONTEXT_PROPERTY_STROKE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_CONTEXT_PROPERTY_FILL_OPACITY: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_CONTEXT_PROPERTY_STROKE_OPACITY: ::std::os::raw::c_uint
              =
        8;
    pub const NS_STYLE_WINDOW_SHADOW_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_WINDOW_SHADOW_DEFAULT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WINDOW_SHADOW_MENU: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_WINDOW_SHADOW_TOOLTIP: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_WINDOW_SHADOW_SHEET: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_DOMINANT_BASELINE_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_DOMINANT_BASELINE_USE_SCRIPT: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_DOMINANT_BASELINE_NO_CHANGE: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_DOMINANT_BASELINE_RESET_SIZE: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_DOMINANT_BASELINE_IDEOGRAPHIC: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_DOMINANT_BASELINE_ALPHABETIC: ::std::os::raw::c_uint =
        5;
    pub const NS_STYLE_DOMINANT_BASELINE_HANGING: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_DOMINANT_BASELINE_MATHEMATICAL: ::std::os::raw::c_uint
              =
        7;
    pub const NS_STYLE_DOMINANT_BASELINE_CENTRAL: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_DOMINANT_BASELINE_MIDDLE: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_DOMINANT_BASELINE_TEXT_AFTER_EDGE:
              ::std::os::raw::c_uint =
        10;
    pub const NS_STYLE_DOMINANT_BASELINE_TEXT_BEFORE_EDGE:
              ::std::os::raw::c_uint =
        11;
    pub const NS_STYLE_IMAGE_RENDERING_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_IMAGE_RENDERING_OPTIMIZESPEED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_IMAGE_RENDERING_OPTIMIZEQUALITY: ::std::os::raw::c_uint
              =
        2;
    pub const NS_STYLE_IMAGE_RENDERING_CRISPEDGES: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_MASK_TYPE_LUMINANCE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_MASK_TYPE_ALPHA: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PAINT_ORDER_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_PAINT_ORDER_FILL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PAINT_ORDER_STROKE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_PAINT_ORDER_MARKERS: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_PAINT_ORDER_LAST_VALUE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_PAINT_ORDER_BITWIDTH: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_SHAPE_RENDERING_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SHAPE_RENDERING_OPTIMIZESPEED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_SHAPE_RENDERING_CRISPEDGES: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_SHAPE_RENDERING_GEOMETRICPRECISION:
              ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_STROKE_LINECAP_BUTT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_STROKE_LINECAP_ROUND: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_STROKE_LINECAP_SQUARE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_STROKE_LINEJOIN_MITER: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_STROKE_LINEJOIN_ROUND: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_STROKE_LINEJOIN_BEVEL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_STROKE_PROP_CONTEXT_VALUE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_ANCHOR_START: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_ANCHOR_MIDDLE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_ANCHOR_END: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_OVER: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_UNDER: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_LEFT: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_RIGHT: ::std::os::raw::c_uint =
        8;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_DEFAULT: ::std::os::raw::c_uint
              =
        9;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_DEFAULT_ZH:
              ::std::os::raw::c_uint =
        10;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_FILL_MASK: ::std::os::raw::c_uint =
        8;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_FILLED: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_OPEN: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_SHAPE_MASK: ::std::os::raw::c_uint
              =
        7;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_DOT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_CIRCLE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_DOUBLE_CIRCLE:
              ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_TRIANGLE: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_SESAME: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_STRING: ::std::os::raw::c_uint =
        255;
    pub const NS_STYLE_TEXT_RENDERING_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_RENDERING_OPTIMIZESPEED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_TEXT_RENDERING_OPTIMIZELEGIBILITY:
              ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_RENDERING_GEOMETRICPRECISION:
              ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_COLOR_ADJUST_ECONOMY: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COLOR_ADJUST_EXACT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_COLOR_INTERPOLATION_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COLOR_INTERPOLATION_SRGB: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_COLOR_INTERPOLATION_LINEARRGB: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_VECTOR_EFFECT_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_VECTOR_EFFECT_NON_SCALING_STROKE:
              ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_BACKFACE_VISIBILITY_VISIBLE: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_BACKFACE_VISIBILITY_HIDDEN: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TRANSFORM_STYLE_FLAT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TRANSFORM_STYLE_PRESERVE_3D: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_CONTEXT_FILL_OPACITY: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CONTEXT_STROKE_OPACITY: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BLEND_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BLEND_MULTIPLY: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BLEND_SCREEN: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_BLEND_OVERLAY: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_BLEND_DARKEN: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_BLEND_LIGHTEN: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_BLEND_COLOR_DODGE: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_BLEND_COLOR_BURN: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_BLEND_HARD_LIGHT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_BLEND_SOFT_LIGHT: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_BLEND_DIFFERENCE: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_BLEND_EXCLUSION: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_BLEND_HUE: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_BLEND_SATURATION: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_BLEND_COLOR: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_BLEND_LUMINOSITY: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_MASK_COMPOSITE_ADD: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_MASK_COMPOSITE_SUBTRACT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_MASK_COMPOSITE_INTERSECT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_MASK_COMPOSITE_EXCLUDE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_CONTROL_CHARACTER_VISIBILITY_HIDDEN:
              ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_CONTROL_CHARACTER_VISIBILITY_VISIBLE:
              ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_COUNTER_SYSTEM_CYCLIC: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COUNTER_SYSTEM_NUMERIC: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_COUNTER_SYSTEM_ALPHABETIC: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_COUNTER_SYSTEM_SYMBOLIC: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_COUNTER_SYSTEM_ADDITIVE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_COUNTER_SYSTEM_FIXED: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_COUNTER_SYSTEM_EXTENDS: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_COUNTER_RANGE_INFINITE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COUNTER_SPEAKAS_BULLETS: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COUNTER_SPEAKAS_NUMBERS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_COUNTER_SPEAKAS_WORDS: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_COUNTER_SPEAKAS_SPELL_OUT: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_COUNTER_SPEAKAS_OTHER: ::std::os::raw::c_uint = 255;
    pub const NS_STYLE_SCROLL_BEHAVIOR_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SCROLL_BEHAVIOR_SMOOTH: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SCROLL_SNAP_TYPE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SCROLL_SNAP_TYPE_MANDATORY: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SCROLL_SNAP_TYPE_PROXIMITY: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_ORIENTATION_PORTRAIT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_ORIENTATION_LANDSCAPE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SCAN_PROGRESSIVE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SCAN_INTERLACE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_DISPLAY_MODE_BROWSER: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_DISPLAY_MODE_MINIMAL_UI: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_DISPLAY_MODE_STANDALONE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_DISPLAY_MODE_FULLSCREEN: ::std::os::raw::c_uint = 3;
    pub const CSS_PSEUDO_ELEMENT_IS_CSS2: ::std::os::raw::c_uint = 1;
    pub const CSS_PSEUDO_ELEMENT_CONTAINS_ELEMENTS: ::std::os::raw::c_uint =
        2;
    pub const CSS_PSEUDO_ELEMENT_SUPPORTS_STYLE_ATTRIBUTE:
              ::std::os::raw::c_uint =
        4;
    pub const CSS_PSEUDO_ELEMENT_SUPPORTS_USER_ACTION_STATE:
              ::std::os::raw::c_uint =
        8;
    pub const CSS_PSEUDO_ELEMENT_UA_SHEET_ONLY: ::std::os::raw::c_uint = 16;
    pub const CSS_PSEUDO_ELEMENT_IS_JS_CREATED_NAC: ::std::os::raw::c_uint =
        32;
    pub const CSS_PSEUDO_ELEMENT_IS_FLEX_OR_GRID_ITEM: ::std::os::raw::c_uint
              =
        64;
    pub const kNameSpaceID_Unknown: ::std::os::raw::c_int = -1;
    pub const kNameSpaceID_XMLNS: ::std::os::raw::c_uint = 1;
    pub const kNameSpaceID_XML: ::std::os::raw::c_uint = 2;
    pub const kNameSpaceID_XHTML: ::std::os::raw::c_uint = 3;
    pub const kNameSpaceID_XLink: ::std::os::raw::c_uint = 4;
    pub const kNameSpaceID_XSLT: ::std::os::raw::c_uint = 5;
    pub const kNameSpaceID_XBL: ::std::os::raw::c_uint = 6;
    pub const kNameSpaceID_MathML: ::std::os::raw::c_uint = 7;
    pub const kNameSpaceID_RDF: ::std::os::raw::c_uint = 8;
    pub const kNameSpaceID_XUL: ::std::os::raw::c_uint = 9;
    pub const kNameSpaceID_SVG: ::std::os::raw::c_uint = 10;
    pub const kNameSpaceID_disabled_MathML: ::std::os::raw::c_uint = 11;
    pub const kNameSpaceID_disabled_SVG: ::std::os::raw::c_uint = 12;
    pub const kNameSpaceID_LastBuiltin: ::std::os::raw::c_uint = 12;
    pub const kNameSpaceID_Wildcard: ::std::os::raw::c_int = -2147483648;
    pub const NS_AUTHOR_SPECIFIED_BACKGROUND: ::std::os::raw::c_uint = 1;
    pub const NS_AUTHOR_SPECIFIED_BORDER: ::std::os::raw::c_uint = 2;
    pub const NS_AUTHOR_SPECIFIED_PADDING: ::std::os::raw::c_uint = 4;
    pub const NS_AUTHOR_SPECIFIED_TEXT_SHADOW: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_INHERIT_MASK: ::std::os::raw::c_uint = 16777215;
    pub const NS_STYLE_HAS_TEXT_DECORATION_LINES: ::std::os::raw::c_uint =
        16777216;
    pub const NS_STYLE_HAS_PSEUDO_ELEMENT_DATA: ::std::os::raw::c_uint =
        33554432;
    pub const NS_STYLE_RELEVANT_LINK_VISITED: ::std::os::raw::c_uint =
        67108864;
    pub const NS_STYLE_IS_STYLE_IF_VISITED: ::std::os::raw::c_uint =
        134217728;
    pub const NS_STYLE_CHILD_USES_GRANDANCESTOR_STYLE: ::std::os::raw::c_uint
              =
        268435456;
    pub const NS_STYLE_IS_SHARED: ::std::os::raw::c_uint = 536870912;
    pub const NS_STYLE_IS_GOING_AWAY: ::std::os::raw::c_uint = 1073741824;
    pub const NS_STYLE_SUPPRESS_LINEBREAK: ::std::os::raw::c_uint =
        2147483648;
    pub const NS_STYLE_IN_DISPLAY_NONE_SUBTREE: ::std::os::raw::c_ulonglong =
        4294967296;
    pub const NS_STYLE_INELIGIBLE_FOR_SHARING: ::std::os::raw::c_ulonglong =
        8589934592;
    pub const NS_STYLE_HAS_CHILD_THAT_USES_RESET_STYLE:
              ::std::os::raw::c_ulonglong =
        17179869184;
    pub const NS_STYLE_IS_TEXT_COMBINED: ::std::os::raw::c_ulonglong =
        34359738368;
    pub const NS_STYLE_CONTEXT_IS_GECKO: ::std::os::raw::c_ulonglong =
        68719476736;
    pub const NS_STYLE_CONTEXT_TYPE_SHIFT: ::std::os::raw::c_uint = 37;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pair<_T1, _T2> {
            pub first: _T1,
            pub second: _T2,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T1>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T2>>,
        }
        pub type pair_first_type<_T1> = _T1;
        pub type pair_second_type<_T2> = _T2;
        pub type pair__EnableB = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pair__CheckArgs {
            pub _address: u8,
        }
        pub type pair__CheckArgsDep = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pair__CheckTupleLikeConstructor {
            pub _address: u8,
        }
        pub type pair__CheckTLC = u8;
        pub type conditional_type<_If> = _If;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct input_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_input_iterator_tag() {
            assert_eq!(::std::mem::size_of::<input_iterator_tag>() , 1usize ,
                       concat ! (
                       "Size of: " , stringify ! ( input_iterator_tag ) ));
            assert_eq! (::std::mem::align_of::<input_iterator_tag>() , 1usize
                        , concat ! (
                        "Alignment of " , stringify ! ( input_iterator_tag )
                        ));
        }
        impl Clone for input_iterator_tag {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct forward_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_forward_iterator_tag() {
            assert_eq!(::std::mem::size_of::<forward_iterator_tag>() , 1usize
                       , concat ! (
                       "Size of: " , stringify ! ( forward_iterator_tag ) ));
            assert_eq! (::std::mem::align_of::<forward_iterator_tag>() ,
                        1usize , concat ! (
                        "Alignment of " , stringify ! ( forward_iterator_tag )
                        ));
        }
        impl Clone for forward_iterator_tag {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct bidirectional_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_bidirectional_iterator_tag() {
            assert_eq!(::std::mem::size_of::<bidirectional_iterator_tag>() ,
                       1usize , concat ! (
                       "Size of: " , stringify ! ( bidirectional_iterator_tag
                       ) ));
            assert_eq! (::std::mem::align_of::<bidirectional_iterator_tag>() ,
                        1usize , concat ! (
                        "Alignment of " , stringify ! (
                        bidirectional_iterator_tag ) ));
        }
        impl Clone for bidirectional_iterator_tag {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct random_access_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_random_access_iterator_tag() {
            assert_eq!(::std::mem::size_of::<random_access_iterator_tag>() ,
                       1usize , concat ! (
                       "Size of: " , stringify ! ( random_access_iterator_tag
                       ) ));
            assert_eq! (::std::mem::align_of::<random_access_iterator_tag>() ,
                        1usize , concat ! (
                        "Alignment of " , stringify ! (
                        random_access_iterator_tag ) ));
        }
        impl Clone for random_access_iterator_tag {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        pub type iterator_iterator_category<_Category> = _Category;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct atomic {
        }
        pub type atomic___base = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct function {
            pub _address: u8,
        }
        pub type __bit_iterator_difference_type = [u8; 0usize];
        pub type __bit_iterator_value_type = bool;
        pub type __bit_iterator_pointer = u8;
        pub type __bit_iterator_reference = u8;
        pub type __bit_iterator_iterator_category =
            root::std::random_access_iterator_tag;
        pub type __bit_iterator___storage_type = [u8; 0usize];
        pub type __bit_iterator___storage_pointer = [u8; 0usize];
        #[repr(C)]
        pub struct __bit_const_reference {
            pub __seg_: root::std::__bit_const_reference___storage_pointer,
            pub __mask_: root::std::__bit_const_reference___storage_type,
        }
        pub type __bit_const_reference___storage_type = [u8; 0usize];
        pub type __bit_const_reference___storage_pointer = [u8; 0usize];
        pub type __bit_reference___storage_type = [u8; 0usize];
        pub type __bit_reference___storage_pointer = [u8; 0usize];
        pub type __bitset_difference_type = isize;
        pub type __bitset_size_type = usize;
        pub type __bitset___storage_type = root::std::__bitset_size_type;
        pub type __bitset___self = u8;
        pub type __bitset___storage_pointer =
            *mut root::std::__bitset___storage_type;
        pub type __bitset___const_storage_pointer =
            *const root::std::__bitset___storage_type;
        pub const __bitset___bits_per_word: ::std::os::raw::c_uint = 64;
        pub type __bitset_reference = u8;
        pub type __bitset_const_reference = root::std::__bit_const_reference;
        pub type __bitset_iterator = u8;
        pub type __bitset_const_iterator = u8;
        extern "C" {
            #[link_name = "__n_words"]
            pub static bitset___n_words: ::std::os::raw::c_uint;
        }
        pub type bitset_base = u8;
        pub type bitset_reference = root::std::bitset_base;
        pub type bitset_const_reference = root::std::bitset_base;
    }
    pub mod mozilla {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct fallible_t {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_fallible_t() {
            assert_eq!(::std::mem::size_of::<fallible_t>() , 1usize , concat !
                       ( "Size of: " , stringify ! ( fallible_t ) ));
            assert_eq! (::std::mem::align_of::<fallible_t>() , 1usize , concat
                        ! ( "Alignment of " , stringify ! ( fallible_t ) ));
        }
        impl Clone for fallible_t {
            fn clone(&self) -> Self { *self }
        }
        pub type IntegralConstant_ValueType<T> = T;
        pub type IntegralConstant_Type = u8;
        /// Convenient aliases.
        pub type TrueType = u8;
        pub type FalseType = u8;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct nsStringRepr {
                pub mData: *mut root::mozilla::detail::nsStringRepr_char_type,
                pub mLength: root::mozilla::detail::nsStringRepr_size_type,
                pub mDataFlags: root::mozilla::detail::nsStringRepr_DataFlags,
                pub mClassFlags: root::mozilla::detail::nsStringRepr_ClassFlags,
            }
            pub type nsStringRepr_fallible_t = root::mozilla::fallible_t;
            pub type nsStringRepr_char_type = u16;
            pub type nsStringRepr_self_type =
                root::mozilla::detail::nsStringRepr;
            pub type nsStringRepr_base_string_type =
                root::mozilla::detail::nsStringRepr_self_type;
            pub type nsStringRepr_substring_type = root::nsAString;
            pub type nsStringRepr_substring_tuple_type =
                root::nsSubstringTuple;
            pub type nsStringRepr_string_type = ::nsstring::nsStringRepr;
            pub type nsStringRepr_const_iterator =
                root::nsReadingIterator<root::mozilla::detail::nsStringRepr_char_type>;
            pub type nsStringRepr_iterator =
                root::nsWritingIterator<root::mozilla::detail::nsStringRepr_char_type>;
            pub type nsStringRepr_comparator_type = root::nsStringComparator;
            pub type nsStringRepr_char_iterator =
                *mut root::mozilla::detail::nsStringRepr_char_type;
            pub type nsStringRepr_const_char_iterator =
                *const root::mozilla::detail::nsStringRepr_char_type;
            pub type nsStringRepr_index_type = u32;
            pub type nsStringRepr_size_type = u32;
            pub use self::super::super::super::root::mozilla::detail::StringDataFlags
                    as nsStringRepr_DataFlags;
            pub use self::super::super::super::root::mozilla::detail::StringClassFlags
                    as nsStringRepr_ClassFlags;
            #[test]
            fn bindgen_test_layout_nsStringRepr() {
                assert_eq!(::std::mem::size_of::<nsStringRepr>() , 16usize ,
                           concat ! (
                           "Size of: " , stringify ! ( nsStringRepr ) ));
                assert_eq! (::std::mem::align_of::<nsStringRepr>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( nsStringRepr ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const nsStringRepr ) ) . mData as *
                            const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            nsStringRepr ) , "::" , stringify ! ( mData ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const nsStringRepr ) ) . mLength as
                            * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            nsStringRepr ) , "::" , stringify ! ( mLength )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const nsStringRepr ) ) . mDataFlags
                            as * const _ as usize } , 12usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            nsStringRepr ) , "::" , stringify ! ( mDataFlags )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const nsStringRepr ) ) .
                            mClassFlags as * const _ as usize } , 14usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            nsStringRepr ) , "::" , stringify ! ( mClassFlags
                            ) ));
            }
            impl Clone for nsStringRepr {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct nsCStringRepr {
                pub mData: *mut root::mozilla::detail::nsCStringRepr_char_type,
                pub mLength: root::mozilla::detail::nsCStringRepr_size_type,
                pub mDataFlags: root::mozilla::detail::nsCStringRepr_DataFlags,
                pub mClassFlags: root::mozilla::detail::nsCStringRepr_ClassFlags,
            }
            pub type nsCStringRepr_fallible_t = root::mozilla::fallible_t;
            pub type nsCStringRepr_char_type = ::std::os::raw::c_char;
            pub type nsCStringRepr_self_type =
                root::mozilla::detail::nsCStringRepr;
            pub type nsCStringRepr_base_string_type =
                root::mozilla::detail::nsCStringRepr_self_type;
            pub type nsCStringRepr_substring_type = root::nsACString;
            pub type nsCStringRepr_substring_tuple_type =
                root::nsCSubstringTuple;
            pub type nsCStringRepr_string_type = root::nsCString;
            pub type nsCStringRepr_const_iterator =
                root::nsReadingIterator<root::mozilla::detail::nsCStringRepr_char_type>;
            pub type nsCStringRepr_iterator =
                root::nsWritingIterator<root::mozilla::detail::nsCStringRepr_char_type>;
            pub type nsCStringRepr_comparator_type =
                root::nsCStringComparator;
            pub type nsCStringRepr_char_iterator =
                *mut root::mozilla::detail::nsCStringRepr_char_type;
            pub type nsCStringRepr_const_char_iterator =
                *const root::mozilla::detail::nsCStringRepr_char_type;
            pub type nsCStringRepr_index_type = u32;
            pub type nsCStringRepr_size_type = u32;
            pub use self::super::super::super::root::mozilla::detail::StringDataFlags
                    as nsCStringRepr_DataFlags;
            pub use self::super::super::super::root::mozilla::detail::StringClassFlags
                    as nsCStringRepr_ClassFlags;
            #[test]
            fn bindgen_test_layout_nsCStringRepr() {
                assert_eq!(::std::mem::size_of::<nsCStringRepr>() , 16usize ,
                           concat ! (
                           "Size of: " , stringify ! ( nsCStringRepr ) ));
                assert_eq! (::std::mem::align_of::<nsCStringRepr>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( nsCStringRepr )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const nsCStringRepr ) ) . mData as
                            * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            nsCStringRepr ) , "::" , stringify ! ( mData ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const nsCStringRepr ) ) . mLength
                            as * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            nsCStringRepr ) , "::" , stringify ! ( mLength )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const nsCStringRepr ) ) .
                            mDataFlags as * const _ as usize } , 12usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            nsCStringRepr ) , "::" , stringify ! ( mDataFlags
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const nsCStringRepr ) ) .
                            mClassFlags as * const _ as usize } , 14usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            nsCStringRepr ) , "::" , stringify ! ( mClassFlags
                            ) ));
            }
            impl Clone for nsCStringRepr {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AllocPolicyBasedFreePolicy {
                pub _address: u8,
            }
            #[repr(u16)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum StringDataFlags {
                TERMINATED = 1,
                VOIDED = 2,
                SHARED = 4,
                OWNED = 8,
                FIXED = 16,
                LITERAL = 32,
            }
            #[repr(u16)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum StringClassFlags { FIXED = 1, NULL_TERMINATED = 2, }
            /// LinkedList supports refcounted elements using this adapter class. Clients
            /// using LinkedList<RefPtr<T>> will get a data structure that holds a strong
            /// reference to T as long as T is in the list.
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct LinkedListElementTraits {
                pub _address: u8,
            }
            pub type LinkedListElementTraits_RawType<T> = *mut T;
            pub type LinkedListElementTraits_ConstRawType<T> = *mut T;
            pub type LinkedListElementTraits_ClientType<T> = *mut T;
            pub type LinkedListElementTraits_ConstClientType<T> = *mut T;
            #[repr(C)]
            #[derive(Debug)]
            pub struct GuardObjectNotificationReceiver {
                pub mStatementDone: bool,
            }
            #[test]
            fn bindgen_test_layout_GuardObjectNotificationReceiver() {
                assert_eq!(::std::mem::size_of::<GuardObjectNotificationReceiver>()
                           , 1usize , concat ! (
                           "Size of: " , stringify ! (
                           GuardObjectNotificationReceiver ) ));
                assert_eq! (::std::mem::align_of::<GuardObjectNotificationReceiver>()
                            , 1usize , concat ! (
                            "Alignment of " , stringify ! (
                            GuardObjectNotificationReceiver ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const GuardObjectNotificationReceiver )
                            ) . mStatementDone as * const _ as usize } ,
                            0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            GuardObjectNotificationReceiver ) , "::" ,
                            stringify ! ( mStatementDone ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct WeakReference {
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ThreadLocal<T> {
                pub mValue: T,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            }
        }
        pub type Conditional_Type<A> = A;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ArenaObjectID {
            eArenaObjectID_DummyBeforeFirstObjectID = 173,
            eArenaObjectID_GeckoStyleContext = 174,
            eArenaObjectID_nsLineBox = 175,
            eArenaObjectID_nsRuleNode = 176,
            eArenaObjectID_DisplayItemData = 177,
            eArenaObjectID_nsInheritedStyleData = 178,
            eArenaObjectID_nsResetStyleData = 179,
            eArenaObjectID_nsConditionalResetStyleData = 180,
            eArenaObjectID_nsConditionalResetStyleDataEntry = 181,
            eArenaObjectID_nsFrameList = 182,
            eArenaObjectID_CustomCounterStyle = 183,
            eArenaObjectID_DependentBuiltinCounterStyle = 184,
            eArenaObjectID_nsCallbackEventRequest = 185,
            eArenaObjectID_nsIntervalSet_Interval = 186,
            eArenaObjectID_CellData = 187,
            eArenaObjectID_BCCellData = 188,
            eArenaObjectID_nsStyleFont = 189,
            eArenaObjectID_nsStyleColor = 190,
            eArenaObjectID_nsStyleList = 191,
            eArenaObjectID_nsStyleText = 192,
            eArenaObjectID_nsStyleVisibility = 193,
            eArenaObjectID_nsStyleUserInterface = 194,
            eArenaObjectID_nsStyleTableBorder = 195,
            eArenaObjectID_nsStyleSVG = 196,
            eArenaObjectID_nsStyleVariables = 197,
            eArenaObjectID_nsStyleBackground = 198,
            eArenaObjectID_nsStylePosition = 199,
            eArenaObjectID_nsStyleTextReset = 200,
            eArenaObjectID_nsStyleDisplay = 201,
            eArenaObjectID_nsStyleContent = 202,
            eArenaObjectID_nsStyleUIReset = 203,
            eArenaObjectID_nsStyleTable = 204,
            eArenaObjectID_nsStyleMargin = 205,
            eArenaObjectID_nsStylePadding = 206,
            eArenaObjectID_nsStyleBorder = 207,
            eArenaObjectID_nsStyleOutline = 208,
            eArenaObjectID_nsStyleXUL = 209,
            eArenaObjectID_nsStyleSVGReset = 210,
            eArenaObjectID_nsStyleColumn = 211,
            eArenaObjectID_nsStyleEffects = 212,
            eArenaObjectID_COUNT = 213,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct MallocAllocPolicy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_MallocAllocPolicy() {
            assert_eq!(::std::mem::size_of::<MallocAllocPolicy>() , 1usize ,
                       concat ! (
                       "Size of: " , stringify ! ( MallocAllocPolicy ) ));
            assert_eq! (::std::mem::align_of::<MallocAllocPolicy>() , 1usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( MallocAllocPolicy )
                        ));
        }
        impl Clone for MallocAllocPolicy {
            fn clone(&self) -> Self { *self }
        }
        /// A default deletion policy using plain old operator delete.
        ///
        /// Note that this type can be specialized, but authors should beware of the risk
        /// that the specialization may at some point cease to match (either because it
        /// gets moved to a different compilation unit or the signature changes). If the
        /// non-specialized (|delete|-based) version compiles for that type but does the
        /// wrong thing, bad things could happen.
        ///
        /// This is a non-issue for types which are always incomplete (i.e. opaque handle
        /// types), since |delete|-ing such a type will always trigger a compilation
        /// error.
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DefaultDelete {
            pub _address: u8,
        }
        pub type MallocSizeOf =
            ::std::option::Option<unsafe extern "C" fn(p:
                                                           *const ::std::os::raw::c_void)
                                      -> usize>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ReverseIterator<IteratorT> {
            pub mCurrent: IteratorT,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<IteratorT>>,
        }
        pub type Array_iterator<T> = *mut T;
        pub type Array_const_iterator<T> = *mut T;
        pub type Array_reverse_iterator<T> =
            root::mozilla::ReverseIterator<T>;
        pub type Array_const_reverse_iterator<T> =
            root::mozilla::ReverseIterator<T>;
        pub mod css {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug)]
            pub struct ErrorReporter {
                pub mError: root::nsAutoString,
                pub mErrorLine: ::nsstring::nsStringRepr,
                pub mFileName: ::nsstring::nsStringRepr,
                pub mScanner: *const root::nsCSSScanner,
                pub mSheet: *const root::mozilla::StyleSheet,
                pub mLoader: *const root::mozilla::css::Loader,
                pub mURI: *mut root::nsIURI,
                pub mInnerWindowID: u64,
                pub mErrorLineNumber: u32,
                pub mPrevErrorLineNumber: u32,
                pub mErrorColNumber: u32,
            }
            #[test]
            fn bindgen_test_layout_ErrorReporter() {
                assert_eq!(::std::mem::size_of::<ErrorReporter>() , 248usize ,
                           concat ! (
                           "Size of: " , stringify ! ( ErrorReporter ) ));
                assert_eq! (::std::mem::align_of::<ErrorReporter>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( ErrorReporter )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ErrorReporter ) ) . mError as
                            * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ErrorReporter ) , "::" , stringify ! ( mError )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ErrorReporter ) ) .
                            mErrorLine as * const _ as usize } , 160usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ErrorReporter ) , "::" , stringify ! ( mErrorLine
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ErrorReporter ) ) . mFileName
                            as * const _ as usize } , 176usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ErrorReporter ) , "::" , stringify ! ( mFileName )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ErrorReporter ) ) . mScanner
                            as * const _ as usize } , 192usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ErrorReporter ) , "::" , stringify ! ( mScanner )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ErrorReporter ) ) . mSheet as
                            * const _ as usize } , 200usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ErrorReporter ) , "::" , stringify ! ( mSheet )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ErrorReporter ) ) . mLoader
                            as * const _ as usize } , 208usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ErrorReporter ) , "::" , stringify ! ( mLoader )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ErrorReporter ) ) . mURI as *
                            const _ as usize } , 216usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ErrorReporter ) , "::" , stringify ! ( mURI ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ErrorReporter ) ) .
                            mInnerWindowID as * const _ as usize } , 224usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            ErrorReporter ) , "::" , stringify ! (
                            mInnerWindowID ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ErrorReporter ) ) .
                            mErrorLineNumber as * const _ as usize } ,
                            232usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ErrorReporter ) , "::" , stringify ! (
                            mErrorLineNumber ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ErrorReporter ) ) .
                            mPrevErrorLineNumber as * const _ as usize } ,
                            236usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ErrorReporter ) , "::" , stringify ! (
                            mPrevErrorLineNumber ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ErrorReporter ) ) .
                            mErrorColNumber as * const _ as usize } , 240usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            ErrorReporter ) , "::" , stringify ! (
                            mErrorColNumber ) ));
            }
            #[repr(u8)]
            /// Enum defining the mode in which a sheet is to be parsed.  This is
            /// usually, but not always, the same as the cascade level at which the
            /// sheet will apply (see nsStyleSet.h).  Most of the Loader APIs only
            /// support loading of author sheets.
            ///
            /// Author sheets are the normal case: styles embedded in or linked
            /// from HTML pages.  They are also the most restricted.
            ///
            /// User sheets can do anything author sheets can do, and also get
            /// access to a few CSS extensions that are not yet suitable for
            /// exposure on the public Web, but are very useful for expressing
            /// user style overrides, such as @-moz-document rules.
            ///
            /// XXX: eUserSheetFeatures was added in bug 1035091, but some patches in
            /// that bug never landed to use this enum value. Currently, all the features
            /// in user sheet are also available in author sheet.
            ///
            /// Agent sheets have access to all author- and user-sheet features
            /// plus more extensions that are necessary for internal use but,
            /// again, not yet suitable for exposure on the public Web.  Some of
            /// these are outright unsafe to expose; in particular, incorrect
            /// styling of anonymous box pseudo-elements can violate layout
            /// invariants.
            ///
            /// Agent sheets that do not use any unsafe rules could use
            /// eSafeAgentSheetFeatures when creating the sheet. This enum value allows
            /// Servo backend to recognize the sheets as the agent level, but Gecko
            /// backend will parse it under _author_ level.
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum SheetParsingMode {
                eAuthorSheetFeatures = 0,
                eUserSheetFeatures = 1,
                eAgentSheetFeatures = 2,
                eSafeAgentSheetFeatures = 3,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct GroupRule {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct Rule {
                pub _base: root::nsIDOMCSSRule,
                pub _base_1: root::nsWrapperCache,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub _mOwningThread: root::nsAutoOwningThread,
                pub mSheet: *mut root::mozilla::StyleSheet,
                pub mParentRule: *mut root::mozilla::css::GroupRule,
                pub mLineNumber: u32,
                pub mColumnNumber: u32,
            }
            pub type Rule_HasThreadSafeRefCnt = root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Rule_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_Rule_cycleCollection() {
                assert_eq!(::std::mem::size_of::<Rule_cycleCollection>() ,
                           16usize , concat ! (
                           "Size of: " , stringify ! ( Rule_cycleCollection )
                           ));
                assert_eq! (::std::mem::align_of::<Rule_cycleCollection>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            Rule_cycleCollection ) ));
            }
            impl Clone for Rule_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            pub const Rule_UNKNOWN_RULE:
                      root::mozilla::css::Rule__bindgen_ty_1 =
                Rule__bindgen_ty_1::UNKNOWN_RULE;
            pub const Rule_CHARSET_RULE:
                      root::mozilla::css::Rule__bindgen_ty_1 =
                Rule__bindgen_ty_1::CHARSET_RULE;
            pub const Rule_IMPORT_RULE: root::mozilla::css::Rule__bindgen_ty_1
                      =
                Rule__bindgen_ty_1::IMPORT_RULE;
            pub const Rule_NAMESPACE_RULE:
                      root::mozilla::css::Rule__bindgen_ty_1 =
                Rule__bindgen_ty_1::NAMESPACE_RULE;
            pub const Rule_STYLE_RULE: root::mozilla::css::Rule__bindgen_ty_1
                      =
                Rule__bindgen_ty_1::STYLE_RULE;
            pub const Rule_MEDIA_RULE: root::mozilla::css::Rule__bindgen_ty_1
                      =
                Rule__bindgen_ty_1::MEDIA_RULE;
            pub const Rule_FONT_FACE_RULE:
                      root::mozilla::css::Rule__bindgen_ty_1 =
                Rule__bindgen_ty_1::FONT_FACE_RULE;
            pub const Rule_PAGE_RULE: root::mozilla::css::Rule__bindgen_ty_1 =
                Rule__bindgen_ty_1::PAGE_RULE;
            pub const Rule_KEYFRAME_RULE:
                      root::mozilla::css::Rule__bindgen_ty_1 =
                Rule__bindgen_ty_1::KEYFRAME_RULE;
            pub const Rule_KEYFRAMES_RULE:
                      root::mozilla::css::Rule__bindgen_ty_1 =
                Rule__bindgen_ty_1::KEYFRAMES_RULE;
            pub const Rule_DOCUMENT_RULE:
                      root::mozilla::css::Rule__bindgen_ty_1 =
                Rule__bindgen_ty_1::DOCUMENT_RULE;
            pub const Rule_SUPPORTS_RULE:
                      root::mozilla::css::Rule__bindgen_ty_1 =
                Rule__bindgen_ty_1::SUPPORTS_RULE;
            pub const Rule_FONT_FEATURE_VALUES_RULE:
                      root::mozilla::css::Rule__bindgen_ty_1 =
                Rule__bindgen_ty_1::FONT_FEATURE_VALUES_RULE;
            pub const Rule_COUNTER_STYLE_RULE:
                      root::mozilla::css::Rule__bindgen_ty_1 =
                Rule__bindgen_ty_1::COUNTER_STYLE_RULE;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum Rule__bindgen_ty_1 {
                UNKNOWN_RULE = 0,
                CHARSET_RULE = 1,
                IMPORT_RULE = 2,
                NAMESPACE_RULE = 3,
                STYLE_RULE = 4,
                MEDIA_RULE = 5,
                FONT_FACE_RULE = 6,
                PAGE_RULE = 7,
                KEYFRAME_RULE = 8,
                KEYFRAMES_RULE = 9,
                DOCUMENT_RULE = 10,
                SUPPORTS_RULE = 11,
                FONT_FEATURE_VALUES_RULE = 12,
                COUNTER_STYLE_RULE = 13,
            }
            extern "C" {
                #[link_name = "_ZN7mozilla3css4Rule21_cycleCollectorGlobalE"]
                pub static mut Rule__cycleCollectorGlobal:
                           root::mozilla::css::Rule_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_Rule() {
                assert_eq!(::std::mem::size_of::<Rule>() , 72usize , concat !
                           ( "Size of: " , stringify ! ( Rule ) ));
                assert_eq! (::std::mem::align_of::<Rule>() , 8usize , concat !
                            ( "Alignment of " , stringify ! ( Rule ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct Loader {
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub _mOwningThread: root::nsAutoOwningThread,
                pub mSheets: root::nsAutoPtr<root::mozilla::css::Loader_Sheets>,
                pub mParsingDatas: [u64; 10usize],
                pub mPostedEvents: root::mozilla::css::Loader_LoadDataArray,
                pub mObservers: [u64; 2usize],
                pub mDocument: *mut root::nsIDocument,
                pub mDocGroup: root::RefPtr<root::mozilla::dom::DocGroup>,
                pub mDatasToNotifyOn: u32,
                pub mCompatMode: root::nsCompatibility,
                pub mPreferredSheet: ::nsstring::nsStringRepr,
                pub mStyleBackendType: [u8; 2usize],
                pub mEnabled: bool,
                pub mReporter: root::nsCOMPtr<root::nsIConsoleReportCollector>,
                pub mSyncCallback: bool,
            }
            pub use self::super::super::super::root::mozilla::net::ReferrerPolicy
                    as Loader_ReferrerPolicy;
            pub type Loader_HasThreadSafeRefCnt = root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Loader_cycleCollection {
                pub _base: root::nsCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_Loader_cycleCollection() {
                assert_eq!(::std::mem::size_of::<Loader_cycleCollection>() ,
                           16usize , concat ! (
                           "Size of: " , stringify ! ( Loader_cycleCollection
                           ) ));
                assert_eq! (::std::mem::align_of::<Loader_cycleCollection>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            Loader_cycleCollection ) ));
            }
            impl Clone for Loader_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            pub type Loader_LoadDataArray =
                root::nsTArray<root::RefPtr<root::mozilla::css::SheetLoadData>>;
            #[repr(C)]
            #[derive(Debug)]
            pub struct Loader_Sheets {
                pub mCompleteSheets: [u64; 6usize],
                pub mLoadingDatas: [u64; 6usize],
                pub mPendingDatas: [u64; 6usize],
            }
            #[test]
            fn bindgen_test_layout_Loader_Sheets() {
                assert_eq!(::std::mem::size_of::<Loader_Sheets>() , 144usize ,
                           concat ! (
                           "Size of: " , stringify ! ( Loader_Sheets ) ));
                assert_eq! (::std::mem::align_of::<Loader_Sheets>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( Loader_Sheets )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader_Sheets ) ) .
                            mCompleteSheets as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            Loader_Sheets ) , "::" , stringify ! (
                            mCompleteSheets ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader_Sheets ) ) .
                            mLoadingDatas as * const _ as usize } , 48usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            Loader_Sheets ) , "::" , stringify ! (
                            mLoadingDatas ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader_Sheets ) ) .
                            mPendingDatas as * const _ as usize } , 96usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            Loader_Sheets ) , "::" , stringify ! (
                            mPendingDatas ) ));
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3css6Loader21_cycleCollectorGlobalE"]
                pub static mut Loader__cycleCollectorGlobal:
                           root::mozilla::css::Loader_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_Loader() {
                assert_eq!(::std::mem::size_of::<Loader>() , 192usize , concat
                           ! ( "Size of: " , stringify ! ( Loader ) ));
                assert_eq! (::std::mem::align_of::<Loader>() , 8usize , concat
                            ! ( "Alignment of " , stringify ! ( Loader ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mRefCnt as *
                            const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mRefCnt ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . _mOwningThread
                            as * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( _mOwningThread ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mSheets as *
                            const _ as usize } , 16usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mSheets ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mParsingDatas as
                            * const _ as usize } , 24usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mParsingDatas ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mPostedEvents as
                            * const _ as usize } , 104usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mPostedEvents ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mObservers as *
                            const _ as usize } , 112usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mObservers ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mDocument as *
                            const _ as usize } , 128usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mDocument ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mDocGroup as *
                            const _ as usize } , 136usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mDocGroup ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mDatasToNotifyOn
                            as * const _ as usize } , 144usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mDatasToNotifyOn ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mCompatMode as *
                            const _ as usize } , 148usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mCompatMode ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mPreferredSheet
                            as * const _ as usize } , 152usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mPreferredSheet ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) .
                            mStyleBackendType as * const _ as usize } ,
                            168usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mStyleBackendType ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mEnabled as *
                            const _ as usize } , 170usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mEnabled ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mReporter as *
                            const _ as usize } , 176usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mReporter ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Loader ) ) . mSyncCallback as
                            * const _ as usize } , 184usize , concat ! (
                            "Alignment of field: " , stringify ! ( Loader ) ,
                            "::" , stringify ! ( mSyncCallback ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ImageLoader {
                _unused: [u8; 0],
            }
            #[repr(C)]
            pub struct URLValueData__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct URLValueData {
                pub vtable_: *const URLValueData__bindgen_vtable,
                pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
                pub mURI: root::nsMainThreadPtrHandle<root::nsIURI>,
                pub mString: ::nsstring::nsStringRepr,
                pub mExtraData: root::RefPtr<root::mozilla::URLExtraData>,
                pub mURIResolved: bool,
                pub mIsLocalRef: [u8; 2usize],
                pub mMightHaveRef: [u8; 2usize],
            }
            pub type URLValueData_HasThreadSafeRefCnt =
                root::mozilla::TrueType;
            #[test]
            fn bindgen_test_layout_URLValueData() {
                assert_eq!(::std::mem::size_of::<URLValueData>() , 56usize ,
                           concat ! (
                           "Size of: " , stringify ! ( URLValueData ) ));
                assert_eq! (::std::mem::align_of::<URLValueData>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( URLValueData ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLValueData ) ) . mRefCnt as
                            * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            URLValueData ) , "::" , stringify ! ( mRefCnt )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLValueData ) ) . mURI as *
                            const _ as usize } , 16usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            URLValueData ) , "::" , stringify ! ( mURI ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLValueData ) ) . mString as
                            * const _ as usize } , 24usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            URLValueData ) , "::" , stringify ! ( mString )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLValueData ) ) . mExtraData
                            as * const _ as usize } , 40usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            URLValueData ) , "::" , stringify ! ( mExtraData )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLValueData ) ) .
                            mURIResolved as * const _ as usize } , 48usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            URLValueData ) , "::" , stringify ! ( mURIResolved
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLValueData ) ) .
                            mIsLocalRef as * const _ as usize } , 49usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            URLValueData ) , "::" , stringify ! ( mIsLocalRef
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLValueData ) ) .
                            mMightHaveRef as * const _ as usize } , 51usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            URLValueData ) , "::" , stringify ! (
                            mMightHaveRef ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct URLValue {
                pub _base: root::mozilla::css::URLValueData,
            }
            #[test]
            fn bindgen_test_layout_URLValue() {
                assert_eq!(::std::mem::size_of::<URLValue>() , 56usize ,
                           concat ! ( "Size of: " , stringify ! ( URLValue )
                           ));
                assert_eq! (::std::mem::align_of::<URLValue>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( URLValue ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ImageValue {
                pub _base: root::mozilla::css::URLValueData,
                pub mRequests: [u64; 6usize],
                pub mLoadedImage: bool,
            }
            #[test]
            fn bindgen_test_layout_ImageValue() {
                assert_eq!(::std::mem::size_of::<ImageValue>() , 112usize ,
                           concat ! ( "Size of: " , stringify ! ( ImageValue )
                           ));
                assert_eq! (::std::mem::align_of::<ImageValue>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( ImageValue ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ImageValue ) ) . mRequests as
                            * const _ as usize } , 56usize , concat ! (
                            "Alignment of field: " , stringify ! ( ImageValue
                            ) , "::" , stringify ! ( mRequests ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ImageValue ) ) . mLoadedImage
                            as * const _ as usize } , 104usize , concat ! (
                            "Alignment of field: " , stringify ! ( ImageValue
                            ) , "::" , stringify ! ( mLoadedImage ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct GridNamedArea {
                pub mName: ::nsstring::nsStringRepr,
                pub mColumnStart: u32,
                pub mColumnEnd: u32,
                pub mRowStart: u32,
                pub mRowEnd: u32,
            }
            #[test]
            fn bindgen_test_layout_GridNamedArea() {
                assert_eq!(::std::mem::size_of::<GridNamedArea>() , 32usize ,
                           concat ! (
                           "Size of: " , stringify ! ( GridNamedArea ) ));
                assert_eq! (::std::mem::align_of::<GridNamedArea>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( GridNamedArea )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridNamedArea ) ) . mName as
                            * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            GridNamedArea ) , "::" , stringify ! ( mName ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridNamedArea ) ) .
                            mColumnStart as * const _ as usize } , 16usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GridNamedArea ) , "::" , stringify ! (
                            mColumnStart ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridNamedArea ) ) .
                            mColumnEnd as * const _ as usize } , 20usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GridNamedArea ) , "::" , stringify ! ( mColumnEnd
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridNamedArea ) ) . mRowStart
                            as * const _ as usize } , 24usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            GridNamedArea ) , "::" , stringify ! ( mRowStart )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridNamedArea ) ) . mRowEnd
                            as * const _ as usize } , 28usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            GridNamedArea ) , "::" , stringify ! ( mRowEnd )
                            ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct GridTemplateAreasValue {
                pub mNamedAreas: root::nsTArray<root::mozilla::css::GridNamedArea>,
                pub mTemplates: root::nsTArray<::nsstring::nsStringRepr>,
                pub mNColumns: u32,
                pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
            }
            pub type GridTemplateAreasValue_HasThreadSafeRefCnt =
                root::mozilla::TrueType;
            #[test]
            fn bindgen_test_layout_GridTemplateAreasValue() {
                assert_eq!(::std::mem::size_of::<GridTemplateAreasValue>() ,
                           32usize , concat ! (
                           "Size of: " , stringify ! ( GridTemplateAreasValue
                           ) ));
                assert_eq! (::std::mem::align_of::<GridTemplateAreasValue>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            GridTemplateAreasValue ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridTemplateAreasValue ) ) .
                            mNamedAreas as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GridTemplateAreasValue ) , "::" , stringify ! (
                            mNamedAreas ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridTemplateAreasValue ) ) .
                            mTemplates as * const _ as usize } , 8usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GridTemplateAreasValue ) , "::" , stringify ! (
                            mTemplates ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridTemplateAreasValue ) ) .
                            mNColumns as * const _ as usize } , 16usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GridTemplateAreasValue ) , "::" , stringify ! (
                            mNColumns ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridTemplateAreasValue ) ) .
                            mRefCnt as * const _ as usize } , 24usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            GridTemplateAreasValue ) , "::" , stringify ! (
                            mRefCnt ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct FontFamilyListRefCnt {
                pub _base: root::mozilla::FontFamilyList,
                pub mRefCnt: root::nsAutoRefCnt,
                pub _mOwningThread: root::nsAutoOwningThread,
            }
            pub type FontFamilyListRefCnt_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[test]
            fn bindgen_test_layout_FontFamilyListRefCnt() {
                assert_eq!(::std::mem::size_of::<FontFamilyListRefCnt>() ,
                           32usize , concat ! (
                           "Size of: " , stringify ! ( FontFamilyListRefCnt )
                           ));
                assert_eq! (::std::mem::align_of::<FontFamilyListRefCnt>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            FontFamilyListRefCnt ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FontFamilyListRefCnt ) ) .
                            mRefCnt as * const _ as usize } , 16usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            FontFamilyListRefCnt ) , "::" , stringify ! (
                            mRefCnt ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FontFamilyListRefCnt ) ) .
                            _mOwningThread as * const _ as usize } , 24usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FontFamilyListRefCnt ) , "::" , stringify ! (
                            _mOwningThread ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct RGBAColorData {
                pub mR: f32,
                pub mG: f32,
                pub mB: f32,
                pub mA: f32,
            }
            #[test]
            fn bindgen_test_layout_RGBAColorData() {
                assert_eq!(::std::mem::size_of::<RGBAColorData>() , 16usize ,
                           concat ! (
                           "Size of: " , stringify ! ( RGBAColorData ) ));
                assert_eq! (::std::mem::align_of::<RGBAColorData>() , 4usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( RGBAColorData )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const RGBAColorData ) ) . mR as *
                            const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            RGBAColorData ) , "::" , stringify ! ( mR ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const RGBAColorData ) ) . mG as *
                            const _ as usize } , 4usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            RGBAColorData ) , "::" , stringify ! ( mG ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const RGBAColorData ) ) . mB as *
                            const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            RGBAColorData ) , "::" , stringify ! ( mB ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const RGBAColorData ) ) . mA as *
                            const _ as usize } , 12usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            RGBAColorData ) , "::" , stringify ! ( mA ) ));
            }
            impl Clone for RGBAColorData {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct ComplexColorData {
                pub mColor: root::mozilla::css::RGBAColorData,
                pub mForegroundRatio: f32,
            }
            #[test]
            fn bindgen_test_layout_ComplexColorData() {
                assert_eq!(::std::mem::size_of::<ComplexColorData>() , 20usize
                           , concat ! (
                           "Size of: " , stringify ! ( ComplexColorData ) ));
                assert_eq! (::std::mem::align_of::<ComplexColorData>() ,
                            4usize , concat ! (
                            "Alignment of " , stringify ! ( ComplexColorData )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ComplexColorData ) ) . mColor
                            as * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ComplexColorData ) , "::" , stringify ! ( mColor )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ComplexColorData ) ) .
                            mForegroundRatio as * const _ as usize } , 16usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            ComplexColorData ) , "::" , stringify ! (
                            mForegroundRatio ) ));
            }
            impl Clone for ComplexColorData {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ComplexColorValue {
                pub _base: root::mozilla::css::ComplexColorData,
                pub mRefCnt: root::nsAutoRefCnt,
                pub _mOwningThread: root::nsAutoOwningThread,
            }
            pub type ComplexColorValue_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[test]
            fn bindgen_test_layout_ComplexColorValue() {
                assert_eq!(::std::mem::size_of::<ComplexColorValue>() ,
                           40usize , concat ! (
                           "Size of: " , stringify ! ( ComplexColorValue ) ));
                assert_eq! (::std::mem::align_of::<ComplexColorValue>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! ( ComplexColorValue
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ComplexColorValue ) ) .
                            mRefCnt as * const _ as usize } , 24usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            ComplexColorValue ) , "::" , stringify ! ( mRefCnt
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ComplexColorValue ) ) .
                            _mOwningThread as * const _ as usize } , 32usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ComplexColorValue ) , "::" , stringify ! (
                            _mOwningThread ) ));
            }
            /// Style sheet reuse *
            #[repr(C)]
            #[derive(Debug)]
            pub struct LoaderReusableStyleSheets {
                pub mReusableSheets: root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>,
            }
            #[test]
            fn bindgen_test_layout_LoaderReusableStyleSheets() {
                assert_eq!(::std::mem::size_of::<LoaderReusableStyleSheets>()
                           , 8usize , concat ! (
                           "Size of: " , stringify ! (
                           LoaderReusableStyleSheets ) ));
                assert_eq! (::std::mem::align_of::<LoaderReusableStyleSheets>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            LoaderReusableStyleSheets ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const LoaderReusableStyleSheets ) )
                            . mReusableSheets as * const _ as usize } , 0usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            LoaderReusableStyleSheets ) , "::" , stringify ! (
                            mReusableSheets ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct SheetLoadData {
                _unused: [u8; 0],
            }
            #[repr(i32)]
            /// Enum defining the type of URL matching function for a @-moz-document rule
            /// condition.
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum URLMatchingFunction {
                eURL = 0,
                eURLPrefix = 1,
                eDomain = 2,
                eRegExp = 3,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DocumentRule {
                _unused: [u8; 0],
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ThreadSafeAutoRefCnt {
            pub mValue: u64,
        }
        pub const ThreadSafeAutoRefCnt_isThreadSafe: bool = true;
        #[test]
        fn bindgen_test_layout_ThreadSafeAutoRefCnt() {
            assert_eq!(::std::mem::size_of::<ThreadSafeAutoRefCnt>() , 8usize
                       , concat ! (
                       "Size of: " , stringify ! ( ThreadSafeAutoRefCnt ) ));
            assert_eq! (::std::mem::align_of::<ThreadSafeAutoRefCnt>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! ( ThreadSafeAutoRefCnt )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ThreadSafeAutoRefCnt ) ) . mValue
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ThreadSafeAutoRefCnt ) , "::" , stringify ! ( mValue )
                        ));
        }
        impl Clone for ThreadSafeAutoRefCnt {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct OwningNonNull<T> {
            pub mPtr: root::RefPtr<T>,
            pub mInited: bool,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StaticRefPtr<T> {
            pub mRawPtr: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type EnumeratedArray_ArrayType = u8;
        pub type EnumeratedArray_iterator =
            root::mozilla::EnumeratedArray_ArrayType;
        pub type EnumeratedArray_const_iterator =
            root::mozilla::EnumeratedArray_ArrayType;
        pub type EnumeratedArray_reverse_iterator =
            root::mozilla::EnumeratedArray_ArrayType;
        pub type EnumeratedArray_const_reverse_iterator =
            root::mozilla::EnumeratedArray_ArrayType;
        #[repr(C)]
        #[derive(Debug)]
        pub struct LinkedListElement {
            pub mNext: *mut root::mozilla::LinkedListElement,
            pub mPrev: *mut root::mozilla::LinkedListElement,
            pub mIsSentinel: bool,
        }
        pub type LinkedListElement_Traits =
            root::mozilla::detail::LinkedListElementTraits;
        pub type LinkedListElement_RawType =
            root::mozilla::LinkedListElement_Traits;
        pub type LinkedListElement_ConstRawType =
            root::mozilla::LinkedListElement_Traits;
        pub type LinkedListElement_ClientType =
            root::mozilla::LinkedListElement_Traits;
        pub type LinkedListElement_ConstClientType =
            root::mozilla::LinkedListElement_Traits;
        pub const LinkedListElement_NodeKind_Sentinel:
                  root::mozilla::LinkedListElement_NodeKind =
            LinkedListElement_NodeKind::Normal;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LinkedListElement_NodeKind { Normal = 0, }
        #[repr(C)]
        #[derive(Debug)]
        pub struct LinkedList {
            pub sentinel: root::mozilla::LinkedListElement,
        }
        pub type LinkedList_Traits =
            root::mozilla::detail::LinkedListElementTraits;
        pub type LinkedList_RawType = root::mozilla::LinkedList_Traits;
        pub type LinkedList_ConstRawType = root::mozilla::LinkedList_Traits;
        pub type LinkedList_ClientType = root::mozilla::LinkedList_Traits;
        pub type LinkedList_ConstClientType =
            root::mozilla::LinkedList_Traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct LinkedList_Iterator {
            pub mCurrent: root::mozilla::LinkedList_RawType,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Maybe {
        }
        pub type Maybe_ValueType<T> = T;
        pub mod gfx {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type Float = f32;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct FontVariation {
                pub mTag: u32,
                pub mValue: f32,
            }
            #[test]
            fn bindgen_test_layout_FontVariation() {
                assert_eq!(::std::mem::size_of::<FontVariation>() , 8usize ,
                           concat ! (
                           "Size of: " , stringify ! ( FontVariation ) ));
                assert_eq! (::std::mem::align_of::<FontVariation>() , 4usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( FontVariation )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FontVariation ) ) . mTag as *
                            const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FontVariation ) , "::" , stringify ! ( mTag ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FontVariation ) ) . mValue as
                            * const _ as usize } , 4usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FontVariation ) , "::" , stringify ! ( mValue )
                            ));
            }
            impl Clone for FontVariation {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct SourceSurface {
                _unused: [u8; 0],
            }
        }
        pub mod layers {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct LayerManager {
                _unused: [u8; 0],
            }
        }
        pub mod dom {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum PlaybackDirection {
                Normal = 0,
                Reverse = 1,
                Alternate = 2,
                Alternate_reverse = 3,
                EndGuard_ = 4,
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum FillMode {
                None = 0,
                Forwards = 1,
                Backwards = 2,
                Both = 3,
                Auto = 4,
                EndGuard_ = 5,
            }
            pub mod binding_detail {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct RecordEntry<KeyType, ValueType> {
                    pub mKey: KeyType,
                    pub mValue: ValueType,
                    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<KeyType>>,
                    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<ValueType>>,
                }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct AllOwningUnionBase {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_AllOwningUnionBase() {
                assert_eq!(::std::mem::size_of::<AllOwningUnionBase>() ,
                           1usize , concat ! (
                           "Size of: " , stringify ! ( AllOwningUnionBase )
                           ));
                assert_eq! (::std::mem::align_of::<AllOwningUnionBase>() ,
                            1usize , concat ! (
                            "Alignment of " , stringify ! ( AllOwningUnionBase
                            ) ));
            }
            impl Clone for AllOwningUnionBase {
                fn clone(&self) -> Self { *self }
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum CallerType { System = 0, NonSystem = 1, }
            #[repr(C)]
            #[derive(Debug)]
            pub struct GlobalObject {
                pub mGlobalJSObject: [u64; 3usize],
                pub mCx: *mut root::JSContext,
                pub mGlobalObject: *mut root::nsISupports,
            }
            #[test]
            fn bindgen_test_layout_GlobalObject() {
                assert_eq!(::std::mem::size_of::<GlobalObject>() , 40usize ,
                           concat ! (
                           "Size of: " , stringify ! ( GlobalObject ) ));
                assert_eq! (::std::mem::align_of::<GlobalObject>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( GlobalObject ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GlobalObject ) ) .
                            mGlobalJSObject as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GlobalObject ) , "::" , stringify ! (
                            mGlobalJSObject ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GlobalObject ) ) . mCx as *
                            const _ as usize } , 24usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            GlobalObject ) , "::" , stringify ! ( mCx ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GlobalObject ) ) .
                            mGlobalObject as * const _ as usize } , 32usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GlobalObject ) , "::" , stringify ! (
                            mGlobalObject ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Sequence {
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Nullable {
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CSSImportRule {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct MediaList {
                pub _base: root::nsIDOMMediaList,
                pub _base_1: root::nsWrapperCache,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub _mOwningThread: root::nsAutoOwningThread,
                pub mStyleSheet: *mut root::mozilla::StyleSheet,
            }
            pub type MediaList_HasThreadSafeRefCnt = root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct MediaList_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_MediaList_cycleCollection() {
                assert_eq!(::std::mem::size_of::<MediaList_cycleCollection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           MediaList_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<MediaList_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            MediaList_cycleCollection ) ));
            }
            impl Clone for MediaList_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom9MediaList21_cycleCollectorGlobalE"]
                pub static mut MediaList__cycleCollectorGlobal:
                           root::mozilla::dom::MediaList_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_MediaList() {
                assert_eq!(::std::mem::size_of::<MediaList>() , 56usize ,
                           concat ! ( "Size of: " , stringify ! ( MediaList )
                           ));
                assert_eq! (::std::mem::align_of::<MediaList>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( MediaList ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct SRIMetadata {
                pub mHashes: root::nsTArray<root::nsCString>,
                pub mIntegrityString: ::nsstring::nsStringRepr,
                pub mAlgorithm: root::nsCString,
                pub mAlgorithmType: i8,
                pub mEmpty: bool,
            }
            pub const SRIMetadata_MAX_ALTERNATE_HASHES: u32 = 256;
            pub const SRIMetadata_UNKNOWN_ALGORITHM: i8 = -1;
            #[test]
            fn bindgen_test_layout_SRIMetadata() {
                assert_eq!(::std::mem::size_of::<SRIMetadata>() , 48usize ,
                           concat ! (
                           "Size of: " , stringify ! ( SRIMetadata ) ));
                assert_eq! (::std::mem::align_of::<SRIMetadata>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( SRIMetadata ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const SRIMetadata ) ) . mHashes as
                            * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! ( SRIMetadata
                            ) , "::" , stringify ! ( mHashes ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const SRIMetadata ) ) .
                            mIntegrityString as * const _ as usize } , 8usize
                            , concat ! (
                            "Alignment of field: " , stringify ! ( SRIMetadata
                            ) , "::" , stringify ! ( mIntegrityString ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const SRIMetadata ) ) . mAlgorithm
                            as * const _ as usize } , 24usize , concat ! (
                            "Alignment of field: " , stringify ! ( SRIMetadata
                            ) , "::" , stringify ! ( mAlgorithm ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const SRIMetadata ) ) .
                            mAlgorithmType as * const _ as usize } , 40usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! ( SRIMetadata
                            ) , "::" , stringify ! ( mAlgorithmType ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const SRIMetadata ) ) . mEmpty as *
                            const _ as usize } , 41usize , concat ! (
                            "Alignment of field: " , stringify ! ( SRIMetadata
                            ) , "::" , stringify ! ( mEmpty ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct Element {
                pub _base: root::mozilla::dom::FragmentOrElement,
                pub mState: root::mozilla::EventStates,
                pub mServoData: ::gecko_bindings::structs::ServoCell<*mut ::gecko_bindings::structs::ServoNodeData>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Element_COMTypeInfo {
                pub _address: u8,
            }
            /// StyleStateLocks is used to specify which event states should be locked,
            /// and whether they should be locked to on or off.
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Element_StyleStateLocks {
                pub mLocks: root::mozilla::EventStates,
                pub mValues: root::mozilla::EventStates,
            }
            #[test]
            fn bindgen_test_layout_Element_StyleStateLocks() {
                assert_eq!(::std::mem::size_of::<Element_StyleStateLocks>() ,
                           16usize , concat ! (
                           "Size of: " , stringify ! ( Element_StyleStateLocks
                           ) ));
                assert_eq! (::std::mem::align_of::<Element_StyleStateLocks>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            Element_StyleStateLocks ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Element_StyleStateLocks ) ) .
                            mLocks as * const _ as usize } , 0usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            Element_StyleStateLocks ) , "::" , stringify ! (
                            mLocks ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Element_StyleStateLocks ) ) .
                            mValues as * const _ as usize } , 8usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            Element_StyleStateLocks ) , "::" , stringify ! (
                            mValues ) ));
            }
            impl Clone for Element_StyleStateLocks {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Element_MappedAttributeEntry {
                pub attribute: *mut *mut root::nsIAtom,
            }
            #[test]
            fn bindgen_test_layout_Element_MappedAttributeEntry() {
                assert_eq!(::std::mem::size_of::<Element_MappedAttributeEntry>()
                           , 8usize , concat ! (
                           "Size of: " , stringify ! (
                           Element_MappedAttributeEntry ) ));
                assert_eq! (::std::mem::align_of::<Element_MappedAttributeEntry>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            Element_MappedAttributeEntry ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const Element_MappedAttributeEntry ) )
                            . attribute as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            Element_MappedAttributeEntry ) , "::" , stringify
                            ! ( attribute ) ));
            }
            impl Clone for Element_MappedAttributeEntry {
                fn clone(&self) -> Self { *self }
            }
            pub const Element_kAllServoDescendantBits: u32 = 25296896;
            pub const Element_kFireMutationEvent: bool = true;
            pub const Element_kDontFireMutationEvent: bool = false;
            pub const Element_kNotifyDocumentObservers: bool = true;
            pub const Element_kDontNotifyDocumentObservers: bool = false;
            pub const Element_kCallAfterSetAttr: bool = true;
            pub const Element_kDontCallAfterSetAttr: bool = false;
            #[test]
            fn bindgen_test_layout_Element() {
                assert_eq!(::std::mem::size_of::<Element>() , 128usize ,
                           concat ! ( "Size of: " , stringify ! ( Element )
                           ));
                assert_eq! (::std::mem::align_of::<Element>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( Element ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Element ) ) . mState as *
                            const _ as usize } , 112usize , concat ! (
                            "Alignment of field: " , stringify ! ( Element ) ,
                            "::" , stringify ! ( mState ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Element ) ) . mServoData as *
                            const _ as usize } , 120usize , concat ! (
                            "Alignment of field: " , stringify ! ( Element ) ,
                            "::" , stringify ! ( mServoData ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ShadowRoot {
                _unused: [u8; 0],
            }
            /// Struct that stores info on an attribute. The name and value must either both
            /// be null or both be non-null.
            ///
            /// Note that, just as the pointers returned by GetAttrNameAt, the pointers that
            /// this struct hold are only valid until the element or its attributes are
            /// mutated (directly or via script).
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct BorrowedAttrInfo {
                pub mName: *const root::nsAttrName,
                pub mValue: *const root::nsAttrValue,
            }
            #[test]
            fn bindgen_test_layout_BorrowedAttrInfo() {
                assert_eq!(::std::mem::size_of::<BorrowedAttrInfo>() , 16usize
                           , concat ! (
                           "Size of: " , stringify ! ( BorrowedAttrInfo ) ));
                assert_eq! (::std::mem::align_of::<BorrowedAttrInfo>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! ( BorrowedAttrInfo )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const BorrowedAttrInfo ) ) . mName
                            as * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            BorrowedAttrInfo ) , "::" , stringify ! ( mName )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const BorrowedAttrInfo ) ) . mValue
                            as * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            BorrowedAttrInfo ) , "::" , stringify ! ( mValue )
                            ));
            }
            impl Clone for BorrowedAttrInfo {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct NodeInfo {
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub _mOwningThread: root::nsAutoOwningThread,
                pub mDocument: *mut root::nsIDocument,
                pub mInner: root::mozilla::dom::NodeInfo_NodeInfoInner,
                pub mOwnerManager: root::RefPtr<root::nsNodeInfoManager>,
                pub mQualifiedName: ::nsstring::nsStringRepr,
                pub mNodeName: ::nsstring::nsStringRepr,
                pub mLocalName: ::nsstring::nsStringRepr,
            }
            pub type NodeInfo_HasThreadSafeRefCnt = root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct NodeInfo_cycleCollection {
                pub _base: root::nsCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_NodeInfo_cycleCollection() {
                assert_eq!(::std::mem::size_of::<NodeInfo_cycleCollection>() ,
                           16usize , concat ! (
                           "Size of: " , stringify ! (
                           NodeInfo_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<NodeInfo_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            NodeInfo_cycleCollection ) ));
            }
            impl Clone for NodeInfo_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct NodeInfo_NodeInfoInner {
                pub mName: *const root::nsIAtom,
                pub mPrefix: *mut root::nsIAtom,
                pub mNamespaceID: i32,
                pub mNodeType: u16,
                pub mNameString: *const root::nsAString,
                pub mExtraName: *mut root::nsIAtom,
                pub mHash: root::PLHashNumber,
                pub mHashInitialized: bool,
            }
            #[test]
            fn bindgen_test_layout_NodeInfo_NodeInfoInner() {
                assert_eq!(::std::mem::size_of::<NodeInfo_NodeInfoInner>() ,
                           48usize , concat ! (
                           "Size of: " , stringify ! ( NodeInfo_NodeInfoInner
                           ) ));
                assert_eq! (::std::mem::align_of::<NodeInfo_NodeInfoInner>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            NodeInfo_NodeInfoInner ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) .
                            mName as * const _ as usize } , 0usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            NodeInfo_NodeInfoInner ) , "::" , stringify ! (
                            mName ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) .
                            mPrefix as * const _ as usize } , 8usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            NodeInfo_NodeInfoInner ) , "::" , stringify ! (
                            mPrefix ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) .
                            mNamespaceID as * const _ as usize } , 16usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            NodeInfo_NodeInfoInner ) , "::" , stringify ! (
                            mNamespaceID ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) .
                            mNodeType as * const _ as usize } , 20usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            NodeInfo_NodeInfoInner ) , "::" , stringify ! (
                            mNodeType ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) .
                            mNameString as * const _ as usize } , 24usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            NodeInfo_NodeInfoInner ) , "::" , stringify ! (
                            mNameString ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) .
                            mExtraName as * const _ as usize } , 32usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            NodeInfo_NodeInfoInner ) , "::" , stringify ! (
                            mExtraName ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) .
                            mHash as * const _ as usize } , 40usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            NodeInfo_NodeInfoInner ) , "::" , stringify ! (
                            mHash ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) .
                            mHashInitialized as * const _ as usize } , 44usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            NodeInfo_NodeInfoInner ) , "::" , stringify ! (
                            mHashInitialized ) ));
            }
            impl Clone for NodeInfo_NodeInfoInner {
                fn clone(&self) -> Self { *self }
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom8NodeInfo21_cycleCollectorGlobalE"]
                pub static mut NodeInfo__cycleCollectorGlobal:
                           root::mozilla::dom::NodeInfo_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_NodeInfo() {
                assert_eq!(::std::mem::size_of::<NodeInfo>() , 128usize ,
                           concat ! ( "Size of: " , stringify ! ( NodeInfo )
                           ));
                assert_eq! (::std::mem::align_of::<NodeInfo>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( NodeInfo ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo ) ) . mRefCnt as *
                            const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! ( NodeInfo )
                            , "::" , stringify ! ( mRefCnt ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo ) ) . _mOwningThread
                            as * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! ( NodeInfo )
                            , "::" , stringify ! ( _mOwningThread ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo ) ) . mDocument as *
                            const _ as usize } , 16usize , concat ! (
                            "Alignment of field: " , stringify ! ( NodeInfo )
                            , "::" , stringify ! ( mDocument ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo ) ) . mInner as *
                            const _ as usize } , 24usize , concat ! (
                            "Alignment of field: " , stringify ! ( NodeInfo )
                            , "::" , stringify ! ( mInner ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo ) ) . mOwnerManager
                            as * const _ as usize } , 72usize , concat ! (
                            "Alignment of field: " , stringify ! ( NodeInfo )
                            , "::" , stringify ! ( mOwnerManager ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo ) ) . mQualifiedName
                            as * const _ as usize } , 80usize , concat ! (
                            "Alignment of field: " , stringify ! ( NodeInfo )
                            , "::" , stringify ! ( mQualifiedName ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo ) ) . mNodeName as *
                            const _ as usize } , 96usize , concat ! (
                            "Alignment of field: " , stringify ! ( NodeInfo )
                            , "::" , stringify ! ( mNodeName ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo ) ) . mLocalName as
                            * const _ as usize } , 112usize , concat ! (
                            "Alignment of field: " , stringify ! ( NodeInfo )
                            , "::" , stringify ! ( mLocalName ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct EventTarget {
                pub _base: root::nsIDOMEventTarget,
                pub _base_1: root::nsWrapperCache,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EventTarget_COMTypeInfo {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_EventTarget() {
                assert_eq!(::std::mem::size_of::<EventTarget>() , 32usize ,
                           concat ! (
                           "Size of: " , stringify ! ( EventTarget ) ));
                assert_eq! (::std::mem::align_of::<EventTarget>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( EventTarget ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct BoxQuadOptions {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ConvertCoordinateOptions {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DOMPoint {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DOMQuad {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct DOMRectReadOnly {
                pub _base: root::nsISupports,
                pub _base_1: root::nsWrapperCache,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub _mOwningThread: root::nsAutoOwningThread,
                pub mParent: root::nsCOMPtr<root::nsISupports>,
            }
            pub type DOMRectReadOnly_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DOMRectReadOnly_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_DOMRectReadOnly_cycleCollection() {
                assert_eq!(::std::mem::size_of::<DOMRectReadOnly_cycleCollection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           DOMRectReadOnly_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<DOMRectReadOnly_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            DOMRectReadOnly_cycleCollection ) ));
            }
            impl Clone for DOMRectReadOnly_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom15DOMRectReadOnly21_cycleCollectorGlobalE"]
                pub static mut DOMRectReadOnly__cycleCollectorGlobal:
                           root::mozilla::dom::DOMRectReadOnly_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_DOMRectReadOnly() {
                assert_eq!(::std::mem::size_of::<DOMRectReadOnly>() , 56usize
                           , concat ! (
                           "Size of: " , stringify ! ( DOMRectReadOnly ) ));
                assert_eq! (::std::mem::align_of::<DOMRectReadOnly>() , 8usize
                            , concat ! (
                            "Alignment of " , stringify ! ( DOMRectReadOnly )
                            ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct OwningNodeOrString {
                pub mType: root::mozilla::dom::OwningNodeOrString_Type,
                pub mValue: root::mozilla::dom::OwningNodeOrString_Value,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum OwningNodeOrString_Type {
                eUninitialized = 0,
                eNode = 1,
                eString = 2,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct OwningNodeOrString_Value {
                pub _bindgen_opaque_blob: [u64; 2usize],
            }
            #[test]
            fn bindgen_test_layout_OwningNodeOrString_Value() {
                assert_eq!(::std::mem::size_of::<OwningNodeOrString_Value>() ,
                           16usize , concat ! (
                           "Size of: " , stringify ! (
                           OwningNodeOrString_Value ) ));
                assert_eq! (::std::mem::align_of::<OwningNodeOrString_Value>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            OwningNodeOrString_Value ) ));
            }
            impl Clone for OwningNodeOrString_Value {
                fn clone(&self) -> Self { *self }
            }
            #[test]
            fn bindgen_test_layout_OwningNodeOrString() {
                assert_eq!(::std::mem::size_of::<OwningNodeOrString>() ,
                           24usize , concat ! (
                           "Size of: " , stringify ! ( OwningNodeOrString )
                           ));
                assert_eq! (::std::mem::align_of::<OwningNodeOrString>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! ( OwningNodeOrString
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const OwningNodeOrString ) ) .
                            mType as * const _ as usize } , 0usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            OwningNodeOrString ) , "::" , stringify ! ( mType
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const OwningNodeOrString ) ) .
                            mValue as * const _ as usize } , 8usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            OwningNodeOrString ) , "::" , stringify ! ( mValue
                            ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TextOrElementOrDocument {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DOMPointInit {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TabGroup {
                _unused: [u8; 0],
            }
            #[repr(C)]
            pub struct DispatcherTrait__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DispatcherTrait {
                pub vtable_: *const DispatcherTrait__bindgen_vtable,
            }
            #[test]
            fn bindgen_test_layout_DispatcherTrait() {
                assert_eq!(::std::mem::size_of::<DispatcherTrait>() , 8usize ,
                           concat ! (
                           "Size of: " , stringify ! ( DispatcherTrait ) ));
                assert_eq! (::std::mem::align_of::<DispatcherTrait>() , 8usize
                            , concat ! (
                            "Alignment of " , stringify ! ( DispatcherTrait )
                            ));
            }
            impl Clone for DispatcherTrait {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ScriptSettingsStackEntry {
                pub mGlobalObject: root::nsCOMPtr<root::nsIGlobalObject>,
                pub mType: root::mozilla::dom::ScriptSettingsStackEntry_Type,
                pub mOlder: *mut root::mozilla::dom::ScriptSettingsStackEntry,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum ScriptSettingsStackEntry_Type {
                eEntryScript = 0,
                eIncumbentScript = 1,
                eJSAPI = 2,
                eNoJSAPI = 3,
            }
            #[test]
            fn bindgen_test_layout_ScriptSettingsStackEntry() {
                assert_eq!(::std::mem::size_of::<ScriptSettingsStackEntry>() ,
                           24usize , concat ! (
                           "Size of: " , stringify ! (
                           ScriptSettingsStackEntry ) ));
                assert_eq! (::std::mem::align_of::<ScriptSettingsStackEntry>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            ScriptSettingsStackEntry ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScriptSettingsStackEntry ) )
                            . mGlobalObject as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ScriptSettingsStackEntry ) , "::" , stringify ! (
                            mGlobalObject ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScriptSettingsStackEntry ) )
                            . mType as * const _ as usize } , 8usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            ScriptSettingsStackEntry ) , "::" , stringify ! (
                            mType ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScriptSettingsStackEntry ) )
                            . mOlder as * const _ as usize } , 16usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ScriptSettingsStackEntry ) , "::" , stringify ! (
                            mOlder ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct AutoJSAPI {
                pub _base: root::mozilla::dom::ScriptSettingsStackEntry,
                pub mAutoRequest: [u64; 3usize],
                pub mAutoNullableCompartment: [u64; 4usize],
                pub mCx: *mut root::JSContext,
                pub mIsMainThread: bool,
                pub mOldWarningReporter: [u64; 2usize],
            }
            #[test]
            fn bindgen_test_layout_AutoJSAPI() {
                assert_eq!(::std::mem::size_of::<AutoJSAPI>() , 112usize ,
                           concat ! ( "Size of: " , stringify ! ( AutoJSAPI )
                           ));
                assert_eq! (::std::mem::align_of::<AutoJSAPI>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( AutoJSAPI ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AutoJSAPI ) ) . mAutoRequest
                            as * const _ as usize } , 24usize , concat ! (
                            "Alignment of field: " , stringify ! ( AutoJSAPI )
                            , "::" , stringify ! ( mAutoRequest ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AutoJSAPI ) ) .
                            mAutoNullableCompartment as * const _ as usize } ,
                            48usize , concat ! (
                            "Alignment of field: " , stringify ! ( AutoJSAPI )
                            , "::" , stringify ! ( mAutoNullableCompartment )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AutoJSAPI ) ) . mCx as *
                            const _ as usize } , 80usize , concat ! (
                            "Alignment of field: " , stringify ! ( AutoJSAPI )
                            , "::" , stringify ! ( mCx ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AutoJSAPI ) ) . mIsMainThread
                            as * const _ as usize } , 88usize , concat ! (
                            "Alignment of field: " , stringify ! ( AutoJSAPI )
                            , "::" , stringify ! ( mIsMainThread ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AutoJSAPI ) ) .
                            mOldWarningReporter as * const _ as usize } ,
                            96usize , concat ! (
                            "Alignment of field: " , stringify ! ( AutoJSAPI )
                            , "::" , stringify ! ( mOldWarningReporter ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct AutoEntryScript {
                pub _base: root::mozilla::dom::AutoJSAPI,
                pub mWebIDLCallerPrincipal: *mut root::nsIPrincipal,
                pub mDocShellEntryMonitor: [u64; 5usize],
                pub mCallerOverride: root::JS::AutoHideScriptedCaller,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct AutoEntryScript_DocshellEntryMonitor {
                pub _base: root::JS::dbg::AutoEntryMonitor,
                pub mReason: *const ::std::os::raw::c_char,
            }
            #[test]
            fn bindgen_test_layout_AutoEntryScript_DocshellEntryMonitor() {
                assert_eq!(::std::mem::size_of::<AutoEntryScript_DocshellEntryMonitor>()
                           , 32usize , concat ! (
                           "Size of: " , stringify ! (
                           AutoEntryScript_DocshellEntryMonitor ) ));
                assert_eq! (::std::mem::align_of::<AutoEntryScript_DocshellEntryMonitor>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            AutoEntryScript_DocshellEntryMonitor ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const AutoEntryScript_DocshellEntryMonitor
                            ) ) . mReason as * const _ as usize } , 24usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            AutoEntryScript_DocshellEntryMonitor ) , "::" ,
                            stringify ! ( mReason ) ));
            }
            #[test]
            fn bindgen_test_layout_AutoEntryScript() {
                assert_eq!(::std::mem::size_of::<AutoEntryScript>() , 176usize
                           , concat ! (
                           "Size of: " , stringify ! ( AutoEntryScript ) ));
                assert_eq! (::std::mem::align_of::<AutoEntryScript>() , 8usize
                            , concat ! (
                            "Alignment of " , stringify ! ( AutoEntryScript )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AutoEntryScript ) ) .
                            mWebIDLCallerPrincipal as * const _ as usize } ,
                            112usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            AutoEntryScript ) , "::" , stringify ! (
                            mWebIDLCallerPrincipal ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AutoEntryScript ) ) .
                            mDocShellEntryMonitor as * const _ as usize } ,
                            120usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            AutoEntryScript ) , "::" , stringify ! (
                            mDocShellEntryMonitor ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AutoEntryScript ) ) .
                            mCallerOverride as * const _ as usize } , 160usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            AutoEntryScript ) , "::" , stringify ! (
                            mCallerOverride ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct AutoIncumbentScript {
                pub _base: root::mozilla::dom::ScriptSettingsStackEntry,
                pub mCallerOverride: root::JS::AutoHideScriptedCaller,
            }
            #[test]
            fn bindgen_test_layout_AutoIncumbentScript() {
                assert_eq!(::std::mem::size_of::<AutoIncumbentScript>() ,
                           40usize , concat ! (
                           "Size of: " , stringify ! ( AutoIncumbentScript )
                           ));
                assert_eq! (::std::mem::align_of::<AutoIncumbentScript>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            AutoIncumbentScript ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AutoIncumbentScript ) ) .
                            mCallerOverride as * const _ as usize } , 24usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            AutoIncumbentScript ) , "::" , stringify ! (
                            mCallerOverride ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AudioContext {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DocGroup {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ServiceWorkerRegistration {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TimeoutManager {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct PrefSetting {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallbackObject {
                pub _base: root::nsISupports,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub _mOwningThread: root::nsAutoOwningThread,
                pub mCallback: root::JS::Heap<*mut root::JSObject>,
                pub mCreationStack: root::JS::Heap<*mut root::JSObject>,
                pub mIncumbentGlobal: root::nsCOMPtr<root::nsIGlobalObject>,
                pub mIncumbentJSGlobal: root::JS::TenuredHeap,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CallbackObject_COMTypeInfo {
                pub _address: u8,
            }
            pub type CallbackObject_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct CallbackObject_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_CallbackObject_cycleCollection() {
                assert_eq!(::std::mem::size_of::<CallbackObject_cycleCollection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           CallbackObject_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<CallbackObject_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            CallbackObject_cycleCollection ) ));
            }
            impl Clone for CallbackObject_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum CallbackObject_ExceptionHandling {
                eReportExceptions = 0,
                eRethrowContentExceptions = 1,
                eRethrowExceptions = 2,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallbackObject_JSObjectsDropper {
                pub mHolder: root::RefPtr<root::mozilla::dom::CallbackObject>,
            }
            #[test]
            fn bindgen_test_layout_CallbackObject_JSObjectsDropper() {
                assert_eq!(::std::mem::size_of::<CallbackObject_JSObjectsDropper>()
                           , 8usize , concat ! (
                           "Size of: " , stringify ! (
                           CallbackObject_JSObjectsDropper ) ));
                assert_eq! (::std::mem::align_of::<CallbackObject_JSObjectsDropper>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            CallbackObject_JSObjectsDropper ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const CallbackObject_JSObjectsDropper )
                            ) . mHolder as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_JSObjectsDropper ) , "::" ,
                            stringify ! ( mHolder ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct CallbackObject_FastCallbackConstructor {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_CallbackObject_FastCallbackConstructor() {
                assert_eq!(::std::mem::size_of::<CallbackObject_FastCallbackConstructor>()
                           , 1usize , concat ! (
                           "Size of: " , stringify ! (
                           CallbackObject_FastCallbackConstructor ) ));
                assert_eq! (::std::mem::align_of::<CallbackObject_FastCallbackConstructor>()
                            , 1usize , concat ! (
                            "Alignment of " , stringify ! (
                            CallbackObject_FastCallbackConstructor ) ));
            }
            impl Clone for CallbackObject_FastCallbackConstructor {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallbackObject_CallSetup {
                pub mCx: *mut root::JSContext,
                pub mCompartment: *mut root::JSCompartment,
                pub mAutoEntryScript: [u64; 23usize],
                pub mAutoIncumbentScript: [u64; 6usize],
                pub mRootedCallable: [u64; 4usize],
                pub mAsyncStack: [u64; 4usize],
                pub mAsyncStackSetter: [u64; 7usize],
                pub mAc: [u64; 4usize],
                pub mErrorResult: *mut root::mozilla::ErrorResult,
                pub mExceptionHandling: root::mozilla::dom::CallbackObject_ExceptionHandling,
                pub mIsMainThread: bool,
            }
            #[test]
            fn bindgen_test_layout_CallbackObject_CallSetup() {
                assert_eq!(::std::mem::size_of::<CallbackObject_CallSetup>() ,
                           416usize , concat ! (
                           "Size of: " , stringify ! (
                           CallbackObject_CallSetup ) ));
                assert_eq! (::std::mem::align_of::<CallbackObject_CallSetup>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            CallbackObject_CallSetup ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mCx as * const _ as usize } , 0usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mCx ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mCompartment as * const _ as usize } , 8usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mCompartment ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mAutoEntryScript as * const _ as usize } ,
                            16usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mAutoEntryScript ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mAutoIncumbentScript as * const _ as usize } ,
                            200usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mAutoIncumbentScript ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mRootedCallable as * const _ as usize } ,
                            248usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mRootedCallable ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mAsyncStack as * const _ as usize } , 280usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mAsyncStack ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mAsyncStackSetter as * const _ as usize } ,
                            312usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mAsyncStackSetter ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mAc as * const _ as usize } , 368usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mAc ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mErrorResult as * const _ as usize } , 400usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mErrorResult ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mExceptionHandling as * const _ as usize } ,
                            408usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mExceptionHandling ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mIsMainThread as * const _ as usize } , 412usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mIsMainThread ) ));
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom14CallbackObject21_cycleCollectorGlobalE"]
                pub static mut CallbackObject__cycleCollectorGlobal:
                           root::mozilla::dom::CallbackObject_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_CallbackObject() {
                assert_eq!(::std::mem::size_of::<CallbackObject>() , 56usize ,
                           concat ! (
                           "Size of: " , stringify ! ( CallbackObject ) ));
                assert_eq! (::std::mem::align_of::<CallbackObject>() , 8usize
                            , concat ! (
                            "Alignment of " , stringify ! ( CallbackObject )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject ) ) . mRefCnt
                            as * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject ) , "::" , stringify ! ( mRefCnt )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject ) ) .
                            _mOwningThread as * const _ as usize } , 16usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject ) , "::" , stringify ! (
                            _mOwningThread ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject ) ) .
                            mCallback as * const _ as usize } , 24usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject ) , "::" , stringify ! ( mCallback
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject ) ) .
                            mCreationStack as * const _ as usize } , 32usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject ) , "::" , stringify ! (
                            mCreationStack ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject ) ) .
                            mIncumbentGlobal as * const _ as usize } , 40usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject ) , "::" , stringify ! (
                            mIncumbentGlobal ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject ) ) .
                            mIncumbentJSGlobal as * const _ as usize } ,
                            48usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject ) , "::" , stringify ! (
                            mIncumbentJSGlobal ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallbackFunction {
                pub _base: root::mozilla::dom::CallbackObject,
            }
            #[test]
            fn bindgen_test_layout_CallbackFunction() {
                assert_eq!(::std::mem::size_of::<CallbackFunction>() , 56usize
                           , concat ! (
                           "Size of: " , stringify ! ( CallbackFunction ) ));
                assert_eq! (::std::mem::align_of::<CallbackFunction>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! ( CallbackFunction )
                            ));
            }
            pub mod prototypes {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
            pub mod constructors {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
            pub mod namedpropertiesobjects {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum VisibilityState {
                Hidden = 0,
                Visible = 1,
                Prerender = 2,
                EndGuard_ = 3,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Animation {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AnonymousContent {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct Attr {
                pub _base: root::nsIAttribute,
                pub _base_1: root::nsIDOMAttr,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub _mOwningThread: root::nsAutoOwningThread,
                pub mValue: ::nsstring::nsStringRepr,
            }
            pub type Attr_HasThreadSafeRefCnt = root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Attr_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_Attr_cycleCollection() {
                assert_eq!(::std::mem::size_of::<Attr_cycleCollection>() ,
                           16usize , concat ! (
                           "Size of: " , stringify ! ( Attr_cycleCollection )
                           ));
                assert_eq! (::std::mem::align_of::<Attr_cycleCollection>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            Attr_cycleCollection ) ));
            }
            impl Clone for Attr_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            extern "C" {
                #[link_name = "_ZN7mozilla3dom4Attr21_cycleCollectorGlobalE"]
                pub static mut Attr__cycleCollectorGlobal:
                           root::mozilla::dom::Attr_cycleCollection;
            }
            extern "C" {
                #[link_name = "_ZN7mozilla3dom4Attr12sInitializedE"]
                pub static mut Attr_sInitialized: bool;
            }
            #[test]
            fn bindgen_test_layout_Attr() {
                assert_eq!(::std::mem::size_of::<Attr>() , 136usize , concat !
                           ( "Size of: " , stringify ! ( Attr ) ));
                assert_eq! (::std::mem::align_of::<Attr>() , 8usize , concat !
                            ( "Alignment of " , stringify ! ( Attr ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct DOMIntersectionObserver {
                pub _base: root::nsISupports,
                pub _base_1: root::nsWrapperCache,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub _mOwningThread: root::nsAutoOwningThread,
                pub mOwner: root::nsCOMPtr<root::nsPIDOMWindowInner>,
                pub mDocument: root::RefPtr<root::nsIDocument>,
                pub mCallback: root::RefPtr<root::mozilla::dom::IntersectionCallback>,
                pub mRoot: root::RefPtr<root::mozilla::dom::Element>,
                pub mRootMargin: root::nsCSSRect,
                pub mThresholds: root::nsTArray<f64>,
                pub mObservationTargets: root::nsTArray<*mut root::mozilla::dom::Element>,
                pub mQueuedEntries: root::nsTArray<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>,
                pub mConnected: bool,
            }
            pub type DOMIntersectionObserver_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DOMIntersectionObserver_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_DOMIntersectionObserver_cycleCollection() {
                assert_eq!(::std::mem::size_of::<DOMIntersectionObserver_cycleCollection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           DOMIntersectionObserver_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<DOMIntersectionObserver_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            DOMIntersectionObserver_cycleCollection ) ));
            }
            impl Clone for DOMIntersectionObserver_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DOMIntersectionObserver_COMTypeInfo {
                pub _address: u8,
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom23DOMIntersectionObserver21_cycleCollectorGlobalE"]
                pub static mut DOMIntersectionObserver__cycleCollectorGlobal:
                           root::mozilla::dom::DOMIntersectionObserver_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_DOMIntersectionObserver() {
                assert_eq!(::std::mem::size_of::<DOMIntersectionObserver>() ,
                           176usize , concat ! (
                           "Size of: " , stringify ! ( DOMIntersectionObserver
                           ) ));
                assert_eq! (::std::mem::align_of::<DOMIntersectionObserver>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            DOMIntersectionObserver ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct FontFaceSet {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct FrameRequestCallback {
                pub _base: root::mozilla::dom::CallbackFunction,
            }
            #[test]
            fn bindgen_test_layout_FrameRequestCallback() {
                assert_eq!(::std::mem::size_of::<FrameRequestCallback>() ,
                           56usize , concat ! (
                           "Size of: " , stringify ! ( FrameRequestCallback )
                           ));
                assert_eq! (::std::mem::align_of::<FrameRequestCallback>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            FrameRequestCallback ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct FullscreenRequest {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ImageTracker {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Link {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct MediaQueryList {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct XPathEvaluator {
                _unused: [u8; 0],
            }
            pub type Record_EntryType<KeyType, ValueType> =
                root::mozilla::dom::binding_detail::RecordEntry<KeyType,
                                                                ValueType>;
            #[repr(C)]
            #[derive(Debug)]
            pub struct URLParams {
                pub mParams: root::nsTArray<root::mozilla::dom::URLParams_Param>,
            }
            #[repr(C)]
            pub struct URLParams_ForEachIterator__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct URLParams_ForEachIterator {
                pub vtable_: *const URLParams_ForEachIterator__bindgen_vtable,
            }
            #[test]
            fn bindgen_test_layout_URLParams_ForEachIterator() {
                assert_eq!(::std::mem::size_of::<URLParams_ForEachIterator>()
                           , 8usize , concat ! (
                           "Size of: " , stringify ! (
                           URLParams_ForEachIterator ) ));
                assert_eq! (::std::mem::align_of::<URLParams_ForEachIterator>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            URLParams_ForEachIterator ) ));
            }
            impl Clone for URLParams_ForEachIterator {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct URLParams_Param {
                pub mKey: ::nsstring::nsStringRepr,
                pub mValue: ::nsstring::nsStringRepr,
            }
            #[test]
            fn bindgen_test_layout_URLParams_Param() {
                assert_eq!(::std::mem::size_of::<URLParams_Param>() , 32usize
                           , concat ! (
                           "Size of: " , stringify ! ( URLParams_Param ) ));
                assert_eq! (::std::mem::align_of::<URLParams_Param>() , 8usize
                            , concat ! (
                            "Alignment of " , stringify ! ( URLParams_Param )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLParams_Param ) ) . mKey as
                            * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            URLParams_Param ) , "::" , stringify ! ( mKey )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLParams_Param ) ) . mValue
                            as * const _ as usize } , 16usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            URLParams_Param ) , "::" , stringify ! ( mValue )
                            ));
            }
            #[test]
            fn bindgen_test_layout_URLParams() {
                assert_eq!(::std::mem::size_of::<URLParams>() , 8usize ,
                           concat ! ( "Size of: " , stringify ! ( URLParams )
                           ));
                assert_eq! (::std::mem::align_of::<URLParams>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( URLParams ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLParams ) ) . mParams as *
                            const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! ( URLParams )
                            , "::" , stringify ! ( mParams ) ));
            }
            /// StyleChildrenIterator traverses the children of the element from the
            /// perspective of the style system, particularly the children we need to
            /// traverse during restyle.
            ///
            /// At present, this is identical to AllChildrenIterator with
            /// (eAllChildren | eSkipDocumentLevelNativeAnonymousContent). We used to have
            /// detect and skip any native anonymous children that are used to implement some
            /// special magic in here that went away, but we keep the separate class so
            /// we can reintroduce special magic back if needed.
            ///
            /// Note: it assumes that no mutation of the DOM or frame tree takes place during
            /// iteration, and will break horribly if that is not true.
            ///
            /// We require this to be memmovable since Rust code can create and move
            /// StyleChildrenIterators.
            #[repr(C)]
            #[derive(Debug)]
            pub struct StyleChildrenIterator {
                pub _base: root::mozilla::dom::AllChildrenIterator,
            }
            #[test]
            fn bindgen_test_layout_StyleChildrenIterator() {
                assert_eq!(::std::mem::size_of::<StyleChildrenIterator>() ,
                           88usize , concat ! (
                           "Size of: " , stringify ! ( StyleChildrenIterator )
                           ));
                assert_eq! (::std::mem::align_of::<StyleChildrenIterator>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            StyleChildrenIterator ) ));
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum CompositeOperation {
                Replace = 0,
                Add = 1,
                Accumulate = 2,
                EndGuard_ = 3,
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum IterationCompositeOperation {
                Replace = 0,
                Accumulate = 1,
                EndGuard_ = 2,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct XBLChildrenElement {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CustomElementData {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct FragmentOrElement {
                pub _base: root::nsIContent,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub _mOwningThread: root::nsAutoOwningThread,
                /// Array containing all attributes and children for this element
                pub mAttrsAndChildren: root::nsAttrAndChildArray,
            }
            pub type FragmentOrElement_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct FragmentOrElement_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_FragmentOrElement_cycleCollection() {
                assert_eq!(::std::mem::size_of::<FragmentOrElement_cycleCollection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           FragmentOrElement_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<FragmentOrElement_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            FragmentOrElement_cycleCollection ) ));
            }
            impl Clone for FragmentOrElement_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            /// There are a set of DOM- and scripting-specific instance variables
            /// that may only be instantiated when a content object is accessed
            /// through the DOM. Rather than burn actual slots in the content
            /// objects for each of these instance variables, we put them off
            /// in a side structure that's only allocated when the content is
            /// accessed through the DOM.
            #[repr(C)]
            #[derive(Debug)]
            pub struct FragmentOrElement_nsExtendedDOMSlots {
                /// SMIL Overridde style rules (for SMIL animation of CSS properties)
                /// @see Element::GetSMILOverrideStyle
                pub mSMILOverrideStyle: root::nsCOMPtr<root::nsICSSDeclaration>,
                /// Holds any SMIL override style declaration for this element.
                pub mSMILOverrideStyleDeclaration: root::RefPtr<root::mozilla::DeclarationBlock>,
                /// The nearest enclosing content node with a binding that created us.
                /// @see FragmentOrElement::GetBindingParent
                pub mBindingParent: *mut root::nsIContent,
                /// The controllers of the XUL Element.
                pub mControllers: root::nsCOMPtr<root::nsIControllers>,
                /// An object implementing the .labels property for this element.
                pub mLabelsList: root::RefPtr<root::nsLabelsNodeList>,
                /// ShadowRoot bound to the element.
                pub mShadowRoot: root::RefPtr<root::mozilla::dom::ShadowRoot>,
                /// The root ShadowRoot of this element if it is in a shadow tree.
                pub mContainingShadow: root::RefPtr<root::mozilla::dom::ShadowRoot>,
                /// An array of web component insertion points to which this element
                /// is distributed.
                pub mDestInsertionPoints: root::nsTArray<*mut root::nsIContent>,
                /// XBL binding installed on the element.
                pub mXBLBinding: root::RefPtr<root::nsXBLBinding>,
                /// XBL binding installed on the lement.
                pub mXBLInsertionParent: root::nsCOMPtr<root::nsIContent>,
                /// Web components custom element data.
                pub mCustomElementData: root::RefPtr<root::mozilla::dom::CustomElementData>,
                /// Registered Intersection Observers on the element.
                pub mRegisteredIntersectionObservers: [u64; 6usize],
                /// For XUL to hold either frameloader or opener.
                pub mFrameLoaderOrOpener: root::nsCOMPtr<root::nsISupports>,
            }
            #[test]
            fn bindgen_test_layout_FragmentOrElement_nsExtendedDOMSlots() {
                assert_eq!(::std::mem::size_of::<FragmentOrElement_nsExtendedDOMSlots>()
                           , 144usize , concat ! (
                           "Size of: " , stringify ! (
                           FragmentOrElement_nsExtendedDOMSlots ) ));
                assert_eq! (::std::mem::align_of::<FragmentOrElement_nsExtendedDOMSlots>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            FragmentOrElement_nsExtendedDOMSlots ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const FragmentOrElement_nsExtendedDOMSlots
                            ) ) . mSMILOverrideStyle as * const _ as usize } ,
                            0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsExtendedDOMSlots ) , "::" ,
                            stringify ! ( mSMILOverrideStyle ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const FragmentOrElement_nsExtendedDOMSlots
                            ) ) . mSMILOverrideStyleDeclaration as * const _
                            as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsExtendedDOMSlots ) , "::" ,
                            stringify ! ( mSMILOverrideStyleDeclaration ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const FragmentOrElement_nsExtendedDOMSlots
                            ) ) . mBindingParent as * const _ as usize } ,
                            16usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsExtendedDOMSlots ) , "::" ,
                            stringify ! ( mBindingParent ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const FragmentOrElement_nsExtendedDOMSlots
                            ) ) . mControllers as * const _ as usize } ,
                            24usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsExtendedDOMSlots ) , "::" ,
                            stringify ! ( mControllers ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const FragmentOrElement_nsExtendedDOMSlots
                            ) ) . mLabelsList as * const _ as usize } ,
                            32usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsExtendedDOMSlots ) , "::" ,
                            stringify ! ( mLabelsList ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const FragmentOrElement_nsExtendedDOMSlots
                            ) ) . mShadowRoot as * const _ as usize } ,
                            40usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsExtendedDOMSlots ) , "::" ,
                            stringify ! ( mShadowRoot ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const FragmentOrElement_nsExtendedDOMSlots
                            ) ) . mContainingShadow as * const _ as usize } ,
                            48usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsExtendedDOMSlots ) , "::" ,
                            stringify ! ( mContainingShadow ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const FragmentOrElement_nsExtendedDOMSlots
                            ) ) . mDestInsertionPoints as * const _ as usize }
                            , 56usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsExtendedDOMSlots ) , "::" ,
                            stringify ! ( mDestInsertionPoints ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const FragmentOrElement_nsExtendedDOMSlots
                            ) ) . mXBLBinding as * const _ as usize } ,
                            64usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsExtendedDOMSlots ) , "::" ,
                            stringify ! ( mXBLBinding ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const FragmentOrElement_nsExtendedDOMSlots
                            ) ) . mXBLInsertionParent as * const _ as usize }
                            , 72usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsExtendedDOMSlots ) , "::" ,
                            stringify ! ( mXBLInsertionParent ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const FragmentOrElement_nsExtendedDOMSlots
                            ) ) . mCustomElementData as * const _ as usize } ,
                            80usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsExtendedDOMSlots ) , "::" ,
                            stringify ! ( mCustomElementData ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const FragmentOrElement_nsExtendedDOMSlots
                            ) ) . mRegisteredIntersectionObservers as * const
                            _ as usize } , 88usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsExtendedDOMSlots ) , "::" ,
                            stringify ! ( mRegisteredIntersectionObservers )
                            ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const FragmentOrElement_nsExtendedDOMSlots
                            ) ) . mFrameLoaderOrOpener as * const _ as usize }
                            , 136usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsExtendedDOMSlots ) , "::" ,
                            stringify ! ( mFrameLoaderOrOpener ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct FragmentOrElement_nsDOMSlots {
                pub _base: root::nsINode_nsSlots,
                /// The .style attribute (an interface that forwards to the actual
                /// style rules)
                /// @see nsGenericHTMLElement::GetStyle
                pub mStyle: root::nsCOMPtr<root::nsICSSDeclaration>,
                /// The .dataset attribute.
                /// @see nsGenericHTMLElement::GetDataset
                pub mDataset: *mut root::nsDOMStringMap,
                /// An object implementing nsIDOMMozNamedAttrMap for this content (attributes)
                /// @see FragmentOrElement::GetAttributes
                pub mAttributeMap: root::RefPtr<root::nsDOMAttributeMap>,
                /// An object implementing the .children property for this element.
                pub mChildrenList: root::RefPtr<root::nsContentList>,
                /// An object implementing the .classList property for this element.
                pub mClassList: root::RefPtr<root::nsDOMTokenList>,
                pub mExtendedSlots: root::mozilla::UniquePtr<root::mozilla::dom::FragmentOrElement_nsExtendedDOMSlots>,
            }
            #[test]
            fn bindgen_test_layout_FragmentOrElement_nsDOMSlots() {
                assert_eq!(::std::mem::size_of::<FragmentOrElement_nsDOMSlots>()
                           , 120usize , concat ! (
                           "Size of: " , stringify ! (
                           FragmentOrElement_nsDOMSlots ) ));
                assert_eq! (::std::mem::align_of::<FragmentOrElement_nsDOMSlots>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mStyle as * const _ as usize } , 72usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mStyle ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mDataset as * const _ as usize } , 80usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mDataset ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mAttributeMap as * const _ as usize } , 88usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mAttributeMap ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mChildrenList as * const _ as usize } , 96usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mChildrenList ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mClassList as * const _ as usize } , 104usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mClassList ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mExtendedSlots as * const _ as usize } ,
                            112usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mExtendedSlots ) ));
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom17FragmentOrElement21_cycleCollectorGlobalE"]
                pub static mut FragmentOrElement__cycleCollectorGlobal:
                           root::mozilla::dom::FragmentOrElement_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_FragmentOrElement() {
                assert_eq!(::std::mem::size_of::<FragmentOrElement>() ,
                           112usize , concat ! (
                           "Size of: " , stringify ! ( FragmentOrElement ) ));
                assert_eq! (::std::mem::align_of::<FragmentOrElement>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! ( FragmentOrElement
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FragmentOrElement ) ) .
                            mRefCnt as * const _ as usize } , 88usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement ) , "::" , stringify ! ( mRefCnt
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FragmentOrElement ) ) .
                            _mOwningThread as * const _ as usize } , 96usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement ) , "::" , stringify ! (
                            _mOwningThread ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FragmentOrElement ) ) .
                            mAttrsAndChildren as * const _ as usize } ,
                            104usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement ) , "::" , stringify ! (
                            mAttrsAndChildren ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct DOMRect {
                pub _base: root::mozilla::dom::DOMRectReadOnly,
                pub _base_1: root::nsIDOMClientRect,
                pub mX: f64,
                pub mY: f64,
                pub mWidth: f64,
                pub mHeight: f64,
            }
            #[test]
            fn bindgen_test_layout_DOMRect() {
                assert_eq!(::std::mem::size_of::<DOMRect>() , 96usize , concat
                           ! ( "Size of: " , stringify ! ( DOMRect ) ));
                assert_eq! (::std::mem::align_of::<DOMRect>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( DOMRect ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct DOMIntersectionObserverEntry {
                pub _base: root::nsISupports,
                pub _base_1: root::nsWrapperCache,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub _mOwningThread: root::nsAutoOwningThread,
                pub mOwner: root::nsCOMPtr<root::nsISupports>,
                pub mTime: root::DOMHighResTimeStamp,
                pub mRootBounds: root::RefPtr<root::mozilla::dom::DOMRect>,
                pub mBoundingClientRect: root::RefPtr<root::mozilla::dom::DOMRect>,
                pub mIntersectionRect: root::RefPtr<root::mozilla::dom::DOMRect>,
                pub mIsIntersecting: bool,
                pub mTarget: root::RefPtr<root::mozilla::dom::Element>,
                pub mIntersectionRatio: f64,
            }
            pub type DOMIntersectionObserverEntry_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DOMIntersectionObserverEntry_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_DOMIntersectionObserverEntry_cycleCollection() {
                assert_eq!(::std::mem::size_of::<DOMIntersectionObserverEntry_cycleCollection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           DOMIntersectionObserverEntry_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<DOMIntersectionObserverEntry_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            DOMIntersectionObserverEntry_cycleCollection ) ));
            }
            impl Clone for DOMIntersectionObserverEntry_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom28DOMIntersectionObserverEntry21_cycleCollectorGlobalE"]
                pub static mut
                           DOMIntersectionObserverEntry__cycleCollectorGlobal:
                           root::mozilla::dom::DOMIntersectionObserverEntry_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_DOMIntersectionObserverEntry() {
                assert_eq!(::std::mem::size_of::<DOMIntersectionObserverEntry>()
                           , 112usize , concat ! (
                           "Size of: " , stringify ! (
                           DOMIntersectionObserverEntry ) ));
                assert_eq! (::std::mem::align_of::<DOMIntersectionObserverEntry>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            DOMIntersectionObserverEntry ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IntersectionCallback {
                pub _base: root::mozilla::dom::CallbackFunction,
            }
            #[test]
            fn bindgen_test_layout_IntersectionCallback() {
                assert_eq!(::std::mem::size_of::<IntersectionCallback>() ,
                           56usize , concat ! (
                           "Size of: " , stringify ! ( IntersectionCallback )
                           ));
                assert_eq! (::std::mem::align_of::<IntersectionCallback>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            IntersectionCallback ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Grid {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ExplicitChildIterator {
                pub mParent: *const root::nsIContent,
                pub mChild: *mut root::nsIContent,
                pub mDefaultChild: *mut root::nsIContent,
                pub mShadowIterator: root::nsAutoPtr<root::mozilla::dom::ExplicitChildIterator>,
                pub mIsFirst: bool,
                pub mIndexInInserted: u32,
            }
            #[test]
            fn bindgen_test_layout_ExplicitChildIterator() {
                assert_eq!(::std::mem::size_of::<ExplicitChildIterator>() ,
                           40usize , concat ! (
                           "Size of: " , stringify ! ( ExplicitChildIterator )
                           ));
                assert_eq! (::std::mem::align_of::<ExplicitChildIterator>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            ExplicitChildIterator ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ExplicitChildIterator ) ) .
                            mParent as * const _ as usize } , 0usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            ExplicitChildIterator ) , "::" , stringify ! (
                            mParent ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ExplicitChildIterator ) ) .
                            mChild as * const _ as usize } , 8usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            ExplicitChildIterator ) , "::" , stringify ! (
                            mChild ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ExplicitChildIterator ) ) .
                            mDefaultChild as * const _ as usize } , 16usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ExplicitChildIterator ) , "::" , stringify ! (
                            mDefaultChild ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ExplicitChildIterator ) ) .
                            mShadowIterator as * const _ as usize } , 24usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            ExplicitChildIterator ) , "::" , stringify ! (
                            mShadowIterator ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ExplicitChildIterator ) ) .
                            mIsFirst as * const _ as usize } , 32usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ExplicitChildIterator ) , "::" , stringify ! (
                            mIsFirst ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ExplicitChildIterator ) ) .
                            mIndexInInserted as * const _ as usize } , 36usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            ExplicitChildIterator ) , "::" , stringify ! (
                            mIndexInInserted ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct FlattenedChildIterator {
                pub _base: root::mozilla::dom::ExplicitChildIterator,
                pub mXBLInvolved: bool,
            }
            #[test]
            fn bindgen_test_layout_FlattenedChildIterator() {
                assert_eq!(::std::mem::size_of::<FlattenedChildIterator>() ,
                           48usize , concat ! (
                           "Size of: " , stringify ! ( FlattenedChildIterator
                           ) ));
                assert_eq! (::std::mem::align_of::<FlattenedChildIterator>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            FlattenedChildIterator ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FlattenedChildIterator ) ) .
                            mXBLInvolved as * const _ as usize } , 40usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FlattenedChildIterator ) , "::" , stringify ! (
                            mXBLInvolved ) ));
            }
            /// AllChildrenIterator traverses the children of an element including before /
            /// after content and optionally XBL children.  The iterator can be initialized
            /// to start at the end by providing false for aStartAtBeginning in order to
            /// start iterating in reverse from the last child.
            ///
            /// Note: it assumes that no mutation of the DOM or frame tree takes place during
            /// iteration, and will break horribly if that is not true.
            #[repr(C)]
            #[derive(Debug)]
            pub struct AllChildrenIterator {
                pub _base: root::mozilla::dom::FlattenedChildIterator,
                pub mOriginalContent: *const root::nsIContent,
                pub mAnonKids: root::nsTArray<*mut root::nsIContent>,
                pub mAnonKidsIdx: u32,
                pub mFlags: u32,
                pub mPhase: root::mozilla::dom::AllChildrenIterator_IteratorPhase,
                pub mMutationGuard: root::nsMutationGuard,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum AllChildrenIterator_IteratorPhase {
                eAtBegin = 0,
                eAtBeforeKid = 1,
                eAtExplicitKids = 2,
                eAtAnonKids = 3,
                eAtAfterKid = 4,
                eAtEnd = 5,
            }
            #[test]
            fn bindgen_test_layout_AllChildrenIterator() {
                assert_eq!(::std::mem::size_of::<AllChildrenIterator>() ,
                           88usize , concat ! (
                           "Size of: " , stringify ! ( AllChildrenIterator )
                           ));
                assert_eq! (::std::mem::align_of::<AllChildrenIterator>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            AllChildrenIterator ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AllChildrenIterator ) ) .
                            mOriginalContent as * const _ as usize } , 48usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            AllChildrenIterator ) , "::" , stringify ! (
                            mOriginalContent ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AllChildrenIterator ) ) .
                            mAnonKids as * const _ as usize } , 56usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            AllChildrenIterator ) , "::" , stringify ! (
                            mAnonKids ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AllChildrenIterator ) ) .
                            mAnonKidsIdx as * const _ as usize } , 64usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            AllChildrenIterator ) , "::" , stringify ! (
                            mAnonKidsIdx ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AllChildrenIterator ) ) .
                            mFlags as * const _ as usize } , 68usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            AllChildrenIterator ) , "::" , stringify ! (
                            mFlags ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AllChildrenIterator ) ) .
                            mPhase as * const _ as usize } , 72usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            AllChildrenIterator ) , "::" , stringify ! (
                            mPhase ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AllChildrenIterator ) ) .
                            mMutationGuard as * const _ as usize } , 80usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            AllChildrenIterator ) , "::" , stringify ! (
                            mMutationGuard ) ));
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct CSSVariableValues {
            /// Map of variable names to IDs.  Variable IDs are indexes into
            /// mVariables.
            pub mVariableIDs: [u64; 6usize],
            /// Array of variables, indexed by variable ID.
            pub mVariables: root::nsTArray<root::mozilla::CSSVariableValues_Variable>,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct CSSVariableValues_Variable {
            pub mVariableName: ::nsstring::nsStringRepr,
            pub mValue: ::nsstring::nsStringRepr,
            pub mFirstToken: root::nsCSSTokenSerializationType,
            pub mLastToken: root::nsCSSTokenSerializationType,
        }
        #[test]
        fn bindgen_test_layout_CSSVariableValues_Variable() {
            assert_eq!(::std::mem::size_of::<CSSVariableValues_Variable>() ,
                       40usize , concat ! (
                       "Size of: " , stringify ! ( CSSVariableValues_Variable
                       ) ));
            assert_eq! (::std::mem::align_of::<CSSVariableValues_Variable>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! (
                        CSSVariableValues_Variable ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSVariableValues_Variable ) ) .
                        mVariableName as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        CSSVariableValues_Variable ) , "::" , stringify ! (
                        mVariableName ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSVariableValues_Variable ) ) .
                        mValue as * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        CSSVariableValues_Variable ) , "::" , stringify ! (
                        mValue ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSVariableValues_Variable ) ) .
                        mFirstToken as * const _ as usize } , 32usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        CSSVariableValues_Variable ) , "::" , stringify ! (
                        mFirstToken ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSVariableValues_Variable ) ) .
                        mLastToken as * const _ as usize } , 36usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        CSSVariableValues_Variable ) , "::" , stringify ! (
                        mLastToken ) ));
        }
        #[test]
        fn bindgen_test_layout_CSSVariableValues() {
            assert_eq!(::std::mem::size_of::<CSSVariableValues>() , 56usize ,
                       concat ! (
                       "Size of: " , stringify ! ( CSSVariableValues ) ));
            assert_eq! (::std::mem::align_of::<CSSVariableValues>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( CSSVariableValues )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSVariableValues ) ) .
                        mVariableIDs as * const _ as usize } , 0usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        CSSVariableValues ) , "::" , stringify ! (
                        mVariableIDs ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSVariableValues ) ) .
                        mVariables as * const _ as usize } , 48usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        CSSVariableValues ) , "::" , stringify ! ( mVariables
                        ) ));
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum SheetType {
            Agent = 0,
            User = 1,
            PresHint = 2,
            Doc = 3,
            ScopedDoc = 4,
            StyleAttr = 5,
            Override = 6,
            Animation = 7,
            Transition = 8,
            Count = 9,
            Unknown = 255,
        }
        /// This struct represents a combined color from a numeric color and
        /// the current foreground color (currentcolor keyword).
        /// Conceptually, the formula is "color * (1 - p) + currentcolor * p"
        /// where p is mForegroundRatio. See mozilla::LinearBlendColors for
        /// the actual algorithm.
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleComplexColor {
            pub mColor: root::nscolor,
            pub mForegroundRatio: u8,
            pub mIsAuto: bool,
        }
        #[test]
        fn bindgen_test_layout_StyleComplexColor() {
            assert_eq!(::std::mem::size_of::<StyleComplexColor>() , 8usize ,
                       concat ! (
                       "Size of: " , stringify ! ( StyleComplexColor ) ));
            assert_eq! (::std::mem::align_of::<StyleComplexColor>() , 4usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StyleComplexColor )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleComplexColor ) ) . mColor as
                        * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleComplexColor ) , "::" , stringify ! ( mColor )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleComplexColor ) ) .
                        mForegroundRatio as * const _ as usize } , 4usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleComplexColor ) , "::" , stringify ! (
                        mForegroundRatio ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleComplexColor ) ) . mIsAuto
                        as * const _ as usize } , 5usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleComplexColor ) , "::" , stringify ! ( mIsAuto )
                        ));
        }
        impl Clone for StyleComplexColor {
            fn clone(&self) -> Self { *self }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum Side {
            eSideTop = 0,
            eSideRight = 1,
            eSideBottom = 2,
            eSideLeft = 3,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum HalfCorner {
            eCornerTopLeftX = 0,
            eCornerTopLeftY = 1,
            eCornerTopRightX = 2,
            eCornerTopRightY = 3,
            eCornerBottomRightX = 4,
            eCornerBottomRightY = 5,
            eCornerBottomLeftX = 6,
            eCornerBottomLeftY = 7,
        }
        pub const FontFamilyType_eFamily_generic_first:
                  root::mozilla::FontFamilyType =
            FontFamilyType::eFamily_serif;
        pub const FontFamilyType_eFamily_generic_last:
                  root::mozilla::FontFamilyType =
            FontFamilyType::eFamily_fantasy;
        pub const FontFamilyType_eFamily_generic_count:
                  root::mozilla::FontFamilyType =
            FontFamilyType::eFamily_monospace;
        #[repr(u32)]
        /// type of font family name, either a name (e.g. Helvetica) or a
        /// generic (e.g. serif, sans-serif), with the ability to distinguish
        /// between unquoted and quoted names for serializaiton
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum FontFamilyType {
            eFamily_none = 0,
            eFamily_named = 1,
            eFamily_named_quoted = 2,
            eFamily_serif = 3,
            eFamily_sans_serif = 4,
            eFamily_monospace = 5,
            eFamily_cursive = 6,
            eFamily_fantasy = 7,
            eFamily_moz_variable = 8,
            eFamily_moz_fixed = 9,
        }
        /// font family name, a string for the name if not a generic and
        /// a font type indicated named family or which generic family
        #[repr(C)]
        #[derive(Debug)]
        pub struct FontFamilyName {
            pub mType: root::mozilla::FontFamilyType,
            pub mName: ::nsstring::nsStringRepr,
        }
        #[test]
        fn bindgen_test_layout_FontFamilyName() {
            assert_eq!(::std::mem::size_of::<FontFamilyName>() , 24usize ,
                       concat ! ( "Size of: " , stringify ! ( FontFamilyName )
                       ));
            assert_eq! (::std::mem::align_of::<FontFamilyName>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( FontFamilyName ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const FontFamilyName ) ) . mType as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( FontFamilyName
                        ) , "::" , stringify ! ( mType ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const FontFamilyName ) ) . mName as *
                        const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( FontFamilyName
                        ) , "::" , stringify ! ( mName ) ));
        }
        /// font family list, array of font families and a default font type.
        /// font family names are either named strings or generics. the default
        /// font type is used to preserve the variable font fallback behavior
        #[repr(C)]
        #[derive(Debug)]
        pub struct FontFamilyList {
            pub mFontlist: root::nsTArray<root::mozilla::FontFamilyName>,
            pub mDefaultFontType: root::mozilla::FontFamilyType,
        }
        #[test]
        fn bindgen_test_layout_FontFamilyList() {
            assert_eq!(::std::mem::size_of::<FontFamilyList>() , 16usize ,
                       concat ! ( "Size of: " , stringify ! ( FontFamilyList )
                       ));
            assert_eq! (::std::mem::align_of::<FontFamilyList>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( FontFamilyList ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const FontFamilyList ) ) . mFontlist as
                        * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( FontFamilyList
                        ) , "::" , stringify ! ( mFontlist ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const FontFamilyList ) ) .
                        mDefaultFontType as * const _ as usize } , 8usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( FontFamilyList
                        ) , "::" , stringify ! ( mDefaultFontType ) ));
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBasicShapeType {
            Polygon = 0,
            Circle = 1,
            Ellipse = 2,
            Inset = 3,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxAlign {
            Stretch = 0,
            Start = 1,
            Center = 2,
            Baseline = 3,
            End = 4,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxDecorationBreak { Slice = 0, Clone = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxDirection { Normal = 0, Reverse = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxOrient { Horizontal = 0, Vertical = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxPack { Start = 0, Center = 1, End = 2, Justify = 3, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxSizing { Content = 0, Border = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleClear {
            None = 0,
            Left = 1,
            Right = 2,
            InlineStart = 3,
            InlineEnd = 4,
            Both = 5,
            Line = 8,
            Max = 13,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleGeometryBox {
            ContentBox = 0,
            PaddingBox = 1,
            BorderBox = 2,
            MarginBox = 3,
            FillBox = 4,
            StrokeBox = 5,
            ViewBox = 6,
            NoClip = 7,
            Text = 8,
            NoBox = 9,
            MozAlmostPadding = 127,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleFillRule { Nonzero = 0, Evenodd = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleFloat {
            None = 0,
            Left = 1,
            Right = 2,
            InlineStart = 3,
            InlineEnd = 4,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleFloatEdge { ContentBox = 0, MarginBox = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleHyphens { None = 0, Manual = 1, Auto = 2, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleShapeRadius { ClosestSide = 0, FarthestSide = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleShapeSourceType {
            None = 0,
            URL = 1,
            Shape = 2,
            Box = 3,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleStackSizing {
            Ignore = 0,
            StretchToFit = 1,
            IgnoreHorizontal = 2,
            IgnoreVertical = 3,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleTextJustify {
            None = 0,
            Auto = 1,
            InterWord = 2,
            InterCharacter = 3,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleUserFocus {
            None = 0,
            Ignore = 1,
            Normal = 2,
            SelectAll = 3,
            SelectBefore = 4,
            SelectAfter = 5,
            SelectSame = 6,
            SelectMenu = 7,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleUserSelect {
            None = 0,
            Text = 1,
            Element = 2,
            Elements = 3,
            All = 4,
            Toggle = 5,
            TriState = 6,
            Auto = 7,
            MozAll = 8,
            MozText = 9,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleUserInput {
            None = 0,
            Enabled = 1,
            Disabled = 2,
            Auto = 3,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleUserModify {
            ReadOnly = 0,
            ReadWrite = 1,
            WriteOnly = 2,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleWindowDragging { Default = 0, Drag = 1, NoDrag = 2, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleOrient {
            Inline = 0,
            Block = 1,
            Horizontal = 2,
            Vertical = 3,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleImageLayerRepeat {
            NoRepeat = 0,
            RepeatX = 1,
            RepeatY = 2,
            Repeat = 3,
            Space = 4,
            Round = 5,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleDisplay {
            None = 0,
            Block = 1,
            FlowRoot = 2,
            Inline = 3,
            InlineBlock = 4,
            ListItem = 5,
            Table = 6,
            InlineTable = 7,
            TableRowGroup = 8,
            TableColumn = 9,
            TableColumnGroup = 10,
            TableHeaderGroup = 11,
            TableFooterGroup = 12,
            TableRow = 13,
            TableCell = 14,
            TableCaption = 15,
            Flex = 16,
            InlineFlex = 17,
            Grid = 18,
            InlineGrid = 19,
            Ruby = 20,
            RubyBase = 21,
            RubyBaseContainer = 22,
            RubyText = 23,
            RubyTextContainer = 24,
            Contents = 25,
            WebkitBox = 26,
            WebkitInlineBox = 27,
            MozBox = 28,
            MozInlineBox = 29,
            MozGrid = 30,
            MozInlineGrid = 31,
            MozGridGroup = 32,
            MozGridLine = 33,
            MozStack = 34,
            MozInlineStack = 35,
            MozDeck = 36,
            MozGroupbox = 37,
            MozPopup = 38,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleGridTrackBreadth { MaxContent = 1, MinContent = 2, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleWhiteSpace {
            Normal = 0,
            Pre = 1,
            Nowrap = 2,
            PreWrap = 3,
            PreLine = 4,
            PreSpace = 5,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NotNull<T> {
            pub mBasePtr: T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WeakPtr {
        }
        pub type WeakPtr_WeakReference = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SupportsWeakPtr {
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ShortcutKeyCandidate {
            _unused: [u8; 0],
        }
        /// EventStates is the class used to represent the event states of nsIContent
        /// instances. These states are calculated by IntrinsicState() and
        /// ContentStatesChanged() has to be called when one of them changes thus
        /// informing the layout/style engine of the change.
        /// Event states are associated with pseudo-classes.
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct EventStates {
            pub mStates: root::mozilla::EventStates_InternalType,
        }
        pub type EventStates_InternalType = u64;
        pub type EventStates_ServoType = u64;
        #[test]
        fn bindgen_test_layout_EventStates() {
            assert_eq!(::std::mem::size_of::<EventStates>() , 8usize , concat
                       ! ( "Size of: " , stringify ! ( EventStates ) ));
            assert_eq! (::std::mem::align_of::<EventStates>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( EventStates ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const EventStates ) ) . mStates as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( EventStates ) ,
                        "::" , stringify ! ( mStates ) ));
        }
        impl Clone for EventStates {
            fn clone(&self) -> Self { *self }
        }
        pub const ServoTraversalFlags_Empty:
                  root::mozilla::ServoTraversalFlags =
            0;
        pub const ServoTraversalFlags_AnimationOnly:
                  root::mozilla::ServoTraversalFlags =
            1;
        pub const ServoTraversalFlags_ForCSSRuleChanges:
                  root::mozilla::ServoTraversalFlags =
            2;
        pub const ServoTraversalFlags_UnstyledOnly:
                  root::mozilla::ServoTraversalFlags =
            4;
        pub const ServoTraversalFlags_Forgetful:
                  root::mozilla::ServoTraversalFlags =
            8;
        pub const ServoTraversalFlags_ClearDirtyBits:
                  root::mozilla::ServoTraversalFlags =
            32;
        pub const ServoTraversalFlags_ClearAnimationOnlyDirtyDescendants:
                  root::mozilla::ServoTraversalFlags =
            64;
        pub const ServoTraversalFlags_ParallelTraversal:
                  root::mozilla::ServoTraversalFlags =
            128;
        pub const ServoTraversalFlags_FlushThrottledAnimations:
                  root::mozilla::ServoTraversalFlags =
            256;
        pub type ServoTraversalFlags = u32;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleRuleInclusion { All = 0, DefaultOnly = 1, }
        pub const UpdateAnimationsTasks_CSSAnimations:
                  root::mozilla::UpdateAnimationsTasks =
            1;
        pub const UpdateAnimationsTasks_CSSTransitions:
                  root::mozilla::UpdateAnimationsTasks =
            2;
        pub const UpdateAnimationsTasks_EffectProperties:
                  root::mozilla::UpdateAnimationsTasks =
            4;
        pub const UpdateAnimationsTasks_CascadeResults:
                  root::mozilla::UpdateAnimationsTasks =
            8;
        pub type UpdateAnimationsTasks = u8;
        pub const ParsingMode_Default: root::mozilla::ParsingMode = 0;
        pub const ParsingMode_AllowUnitlessLength: root::mozilla::ParsingMode
                  =
            1;
        pub const ParsingMode_AllowAllNumericValues:
                  root::mozilla::ParsingMode =
            2;
        pub type ParsingMode = u8;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum InheritTarget {
            Text = 0,
            FirstLetterContinuation = 1,
            PlaceholderFrame = 2,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ServoKeywordSize {
            Empty = 0,
            XXSmall = 1,
            XSmall = 2,
            Small = 3,
            Medium = 4,
            Large = 5,
            XLarge = 6,
            XXLarge = 7,
            XXXLarge = 8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ServoStyleContext {
            pub _base: root::nsStyleContext,
            pub mPresContext: *mut root::nsPresContext,
            pub mSource: root::ServoComputedData,
            pub mNextInheritingAnonBoxStyle: root::RefPtr<root::mozilla::ServoStyleContext>,
            pub mNextLazyPseudoStyle: root::RefPtr<root::mozilla::ServoStyleContext>,
        }
        #[test]
        fn bindgen_test_layout_ServoStyleContext() {
            assert_eq!(::std::mem::size_of::<ServoStyleContext>() , 272usize ,
                       concat ! (
                       "Size of: " , stringify ! ( ServoStyleContext ) ));
            assert_eq! (::std::mem::align_of::<ServoStyleContext>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ServoStyleContext )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoStyleContext ) ) .
                        mPresContext as * const _ as usize } , 24usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoStyleContext ) , "::" , stringify ! (
                        mPresContext ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoStyleContext ) ) . mSource
                        as * const _ as usize } , 32usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoStyleContext ) , "::" , stringify ! ( mSource )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoStyleContext ) ) .
                        mNextInheritingAnonBoxStyle as * const _ as usize } ,
                        256usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoStyleContext ) , "::" , stringify ! (
                        mNextInheritingAnonBoxStyle ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoStyleContext ) ) .
                        mNextLazyPseudoStyle as * const _ as usize } ,
                        264usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoStyleContext ) , "::" , stringify ! (
                        mNextLazyPseudoStyle ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoFont {
            pub gecko: root::nsStyleFont,
        }
        #[test]
        fn bindgen_test_layout_GeckoFont() {
            assert_eq!(::std::mem::size_of::<GeckoFont>() , 120usize , concat
                       ! ( "Size of: " , stringify ! ( GeckoFont ) ));
            assert_eq! (::std::mem::align_of::<GeckoFont>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( GeckoFont ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoFont ) ) . gecko as * const
                        _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GeckoFont ) ,
                        "::" , stringify ! ( gecko ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoColor {
            pub gecko: root::nsStyleColor,
        }
        #[test]
        fn bindgen_test_layout_GeckoColor() {
            assert_eq!(::std::mem::size_of::<GeckoColor>() , 4usize , concat !
                       ( "Size of: " , stringify ! ( GeckoColor ) ));
            assert_eq! (::std::mem::align_of::<GeckoColor>() , 4usize , concat
                        ! ( "Alignment of " , stringify ! ( GeckoColor ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoColor ) ) . gecko as * const
                        _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GeckoColor ) ,
                        "::" , stringify ! ( gecko ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoList {
            pub gecko: root::nsStyleList,
        }
        #[test]
        fn bindgen_test_layout_GeckoList() {
            assert_eq!(::std::mem::size_of::<GeckoList>() , 48usize , concat !
                       ( "Size of: " , stringify ! ( GeckoList ) ));
            assert_eq! (::std::mem::align_of::<GeckoList>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( GeckoList ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoList ) ) . gecko as * const
                        _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GeckoList ) ,
                        "::" , stringify ! ( gecko ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoText {
            pub gecko: root::nsStyleText,
        }
        #[test]
        fn bindgen_test_layout_GeckoText() {
            assert_eq!(::std::mem::size_of::<GeckoText>() , 160usize , concat
                       ! ( "Size of: " , stringify ! ( GeckoText ) ));
            assert_eq! (::std::mem::align_of::<GeckoText>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( GeckoText ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoText ) ) . gecko as * const
                        _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GeckoText ) ,
                        "::" , stringify ! ( gecko ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoVisibility {
            pub gecko: root::nsStyleVisibility,
        }
        #[test]
        fn bindgen_test_layout_GeckoVisibility() {
            assert_eq!(::std::mem::size_of::<GeckoVisibility>() , 7usize ,
                       concat ! (
                       "Size of: " , stringify ! ( GeckoVisibility ) ));
            assert_eq! (::std::mem::align_of::<GeckoVisibility>() , 1usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( GeckoVisibility ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoVisibility ) ) . gecko as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GeckoVisibility
                        ) , "::" , stringify ! ( gecko ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoUserInterface {
            pub gecko: root::nsStyleUserInterface,
        }
        #[test]
        fn bindgen_test_layout_GeckoUserInterface() {
            assert_eq!(::std::mem::size_of::<GeckoUserInterface>() , 24usize ,
                       concat ! (
                       "Size of: " , stringify ! ( GeckoUserInterface ) ));
            assert_eq! (::std::mem::align_of::<GeckoUserInterface>() , 8usize
                        , concat ! (
                        "Alignment of " , stringify ! ( GeckoUserInterface )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoUserInterface ) ) . gecko as
                        * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        GeckoUserInterface ) , "::" , stringify ! ( gecko )
                        ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoTableBorder {
            pub gecko: root::nsStyleTableBorder,
        }
        #[test]
        fn bindgen_test_layout_GeckoTableBorder() {
            assert_eq!(::std::mem::size_of::<GeckoTableBorder>() , 12usize ,
                       concat ! (
                       "Size of: " , stringify ! ( GeckoTableBorder ) ));
            assert_eq! (::std::mem::align_of::<GeckoTableBorder>() , 4usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( GeckoTableBorder ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoTableBorder ) ) . gecko as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        GeckoTableBorder ) , "::" , stringify ! ( gecko ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoSVG {
            pub gecko: root::nsStyleSVG,
        }
        #[test]
        fn bindgen_test_layout_GeckoSVG() {
            assert_eq!(::std::mem::size_of::<GeckoSVG>() , 128usize , concat !
                       ( "Size of: " , stringify ! ( GeckoSVG ) ));
            assert_eq! (::std::mem::align_of::<GeckoSVG>() , 8usize , concat !
                        ( "Alignment of " , stringify ! ( GeckoSVG ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoSVG ) ) . gecko as * const _
                        as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GeckoSVG ) ,
                        "::" , stringify ! ( gecko ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoBackground {
            pub gecko: root::nsStyleBackground,
        }
        #[test]
        fn bindgen_test_layout_GeckoBackground() {
            assert_eq!(::std::mem::size_of::<GeckoBackground>() , 160usize ,
                       concat ! (
                       "Size of: " , stringify ! ( GeckoBackground ) ));
            assert_eq! (::std::mem::align_of::<GeckoBackground>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( GeckoBackground ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoBackground ) ) . gecko as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GeckoBackground
                        ) , "::" , stringify ! ( gecko ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoPosition {
            pub gecko: root::nsStylePosition,
        }
        #[test]
        fn bindgen_test_layout_GeckoPosition() {
            assert_eq!(::std::mem::size_of::<GeckoPosition>() , 440usize ,
                       concat ! ( "Size of: " , stringify ! ( GeckoPosition )
                       ));
            assert_eq! (::std::mem::align_of::<GeckoPosition>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( GeckoPosition ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoPosition ) ) . gecko as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GeckoPosition )
                        , "::" , stringify ! ( gecko ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoTextReset {
            pub gecko: root::nsStyleTextReset,
        }
        #[test]
        fn bindgen_test_layout_GeckoTextReset() {
            assert_eq!(::std::mem::size_of::<GeckoTextReset>() , 80usize ,
                       concat ! ( "Size of: " , stringify ! ( GeckoTextReset )
                       ));
            assert_eq! (::std::mem::align_of::<GeckoTextReset>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( GeckoTextReset ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoTextReset ) ) . gecko as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GeckoTextReset
                        ) , "::" , stringify ! ( gecko ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoDisplay {
            pub gecko: root::nsStyleDisplay,
        }
        #[test]
        fn bindgen_test_layout_GeckoDisplay() {
            assert_eq!(::std::mem::size_of::<GeckoDisplay>() , 416usize ,
                       concat ! ( "Size of: " , stringify ! ( GeckoDisplay )
                       ));
            assert_eq! (::std::mem::align_of::<GeckoDisplay>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( GeckoDisplay ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoDisplay ) ) . gecko as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GeckoDisplay )
                        , "::" , stringify ! ( gecko ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoContent {
            pub gecko: root::nsStyleContent,
        }
        #[test]
        fn bindgen_test_layout_GeckoContent() {
            assert_eq!(::std::mem::size_of::<GeckoContent>() , 24usize ,
                       concat ! ( "Size of: " , stringify ! ( GeckoContent )
                       ));
            assert_eq! (::std::mem::align_of::<GeckoContent>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( GeckoContent ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoContent ) ) . gecko as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GeckoContent )
                        , "::" , stringify ! ( gecko ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoUIReset {
            pub gecko: root::nsStyleUIReset,
        }
        #[test]
        fn bindgen_test_layout_GeckoUIReset() {
            assert_eq!(::std::mem::size_of::<GeckoUIReset>() , 56usize ,
                       concat ! ( "Size of: " , stringify ! ( GeckoUIReset )
                       ));
            assert_eq! (::std::mem::align_of::<GeckoUIReset>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( GeckoUIReset ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoUIReset ) ) . gecko as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GeckoUIReset )
                        , "::" , stringify ! ( gecko ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoTable {
            pub gecko: root::nsStyleTable,
        }
        #[test]
        fn bindgen_test_layout_GeckoTable() {
            assert_eq!(::std::mem::size_of::<GeckoTable>() , 8usize , concat !
                       ( "Size of: " , stringify ! ( GeckoTable ) ));
            assert_eq! (::std::mem::align_of::<GeckoTable>() , 4usize , concat
                        ! ( "Alignment of " , stringify ! ( GeckoTable ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoTable ) ) . gecko as * const
                        _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GeckoTable ) ,
                        "::" , stringify ! ( gecko ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoMargin {
            pub gecko: root::nsStyleMargin,
        }
        #[test]
        fn bindgen_test_layout_GeckoMargin() {
            assert_eq!(::std::mem::size_of::<GeckoMargin>() , 40usize , concat
                       ! ( "Size of: " , stringify ! ( GeckoMargin ) ));
            assert_eq! (::std::mem::align_of::<GeckoMargin>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( GeckoMargin ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoMargin ) ) . gecko as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GeckoMargin ) ,
                        "::" , stringify ! ( gecko ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoPadding {
            pub gecko: root::nsStylePadding,
        }
        #[test]
        fn bindgen_test_layout_GeckoPadding() {
            assert_eq!(::std::mem::size_of::<GeckoPadding>() , 40usize ,
                       concat ! ( "Size of: " , stringify ! ( GeckoPadding )
                       ));
            assert_eq! (::std::mem::align_of::<GeckoPadding>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( GeckoPadding ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoPadding ) ) . gecko as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GeckoPadding )
                        , "::" , stringify ! ( gecko ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoBorder {
            pub gecko: root::nsStyleBorder,
        }
        #[test]
        fn bindgen_test_layout_GeckoBorder() {
            assert_eq!(::std::mem::size_of::<GeckoBorder>() , 312usize ,
                       concat ! ( "Size of: " , stringify ! ( GeckoBorder )
                       ));
            assert_eq! (::std::mem::align_of::<GeckoBorder>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( GeckoBorder ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoBorder ) ) . gecko as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GeckoBorder ) ,
                        "::" , stringify ! ( gecko ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoOutline {
            pub gecko: root::nsStyleOutline,
        }
        #[test]
        fn bindgen_test_layout_GeckoOutline() {
            assert_eq!(::std::mem::size_of::<GeckoOutline>() , 104usize ,
                       concat ! ( "Size of: " , stringify ! ( GeckoOutline )
                       ));
            assert_eq! (::std::mem::align_of::<GeckoOutline>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( GeckoOutline ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoOutline ) ) . gecko as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GeckoOutline )
                        , "::" , stringify ! ( gecko ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoXUL {
            pub gecko: root::nsStyleXUL,
        }
        #[test]
        fn bindgen_test_layout_GeckoXUL() {
            assert_eq!(::std::mem::size_of::<GeckoXUL>() , 16usize , concat !
                       ( "Size of: " , stringify ! ( GeckoXUL ) ));
            assert_eq! (::std::mem::align_of::<GeckoXUL>() , 4usize , concat !
                        ( "Alignment of " , stringify ! ( GeckoXUL ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoXUL ) ) . gecko as * const _
                        as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GeckoXUL ) ,
                        "::" , stringify ! ( gecko ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoSVGReset {
            pub gecko: root::nsStyleSVGReset,
        }
        #[test]
        fn bindgen_test_layout_GeckoSVGReset() {
            assert_eq!(::std::mem::size_of::<GeckoSVGReset>() , 192usize ,
                       concat ! ( "Size of: " , stringify ! ( GeckoSVGReset )
                       ));
            assert_eq! (::std::mem::align_of::<GeckoSVGReset>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( GeckoSVGReset ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoSVGReset ) ) . gecko as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GeckoSVGReset )
                        , "::" , stringify ! ( gecko ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoColumn {
            pub gecko: root::nsStyleColumn,
        }
        #[test]
        fn bindgen_test_layout_GeckoColumn() {
            assert_eq!(::std::mem::size_of::<GeckoColumn>() , 64usize , concat
                       ! ( "Size of: " , stringify ! ( GeckoColumn ) ));
            assert_eq! (::std::mem::align_of::<GeckoColumn>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( GeckoColumn ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoColumn ) ) . gecko as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GeckoColumn ) ,
                        "::" , stringify ! ( gecko ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct GeckoEffects {
            pub gecko: root::nsStyleEffects,
        }
        #[test]
        fn bindgen_test_layout_GeckoEffects() {
            assert_eq!(::std::mem::size_of::<GeckoEffects>() , 40usize ,
                       concat ! ( "Size of: " , stringify ! ( GeckoEffects )
                       ));
            assert_eq! (::std::mem::align_of::<GeckoEffects>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( GeckoEffects ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GeckoEffects ) ) . gecko as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GeckoEffects )
                        , "::" , stringify ! ( gecko ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ServoStyleSetSizes {
            pub mStylistRuleTree: usize,
            pub mStylistPrecomputedPseudos: usize,
            pub mStylistElementAndPseudosMaps: usize,
            pub mStylistInvalidationMap: usize,
            pub mStylistRevalidationSelectors: usize,
            pub mStylistOther: usize,
            pub mOther: usize,
        }
        #[test]
        fn bindgen_test_layout_ServoStyleSetSizes() {
            assert_eq!(::std::mem::size_of::<ServoStyleSetSizes>() , 56usize ,
                       concat ! (
                       "Size of: " , stringify ! ( ServoStyleSetSizes ) ));
            assert_eq! (::std::mem::align_of::<ServoStyleSetSizes>() , 8usize
                        , concat ! (
                        "Alignment of " , stringify ! ( ServoStyleSetSizes )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoStyleSetSizes ) ) .
                        mStylistRuleTree as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoStyleSetSizes ) , "::" , stringify ! (
                        mStylistRuleTree ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoStyleSetSizes ) ) .
                        mStylistPrecomputedPseudos as * const _ as usize } ,
                        8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoStyleSetSizes ) , "::" , stringify ! (
                        mStylistPrecomputedPseudos ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoStyleSetSizes ) ) .
                        mStylistElementAndPseudosMaps as * const _ as usize }
                        , 16usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoStyleSetSizes ) , "::" , stringify ! (
                        mStylistElementAndPseudosMaps ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoStyleSetSizes ) ) .
                        mStylistInvalidationMap as * const _ as usize } ,
                        24usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoStyleSetSizes ) , "::" , stringify ! (
                        mStylistInvalidationMap ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoStyleSetSizes ) ) .
                        mStylistRevalidationSelectors as * const _ as usize }
                        , 32usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoStyleSetSizes ) , "::" , stringify ! (
                        mStylistRevalidationSelectors ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoStyleSetSizes ) ) .
                        mStylistOther as * const _ as usize } , 40usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoStyleSetSizes ) , "::" , stringify ! (
                        mStylistOther ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoStyleSetSizes ) ) . mOther
                        as * const _ as usize } , 48usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoStyleSetSizes ) , "::" , stringify ! ( mOther )
                        ));
        }
        impl Clone for ServoStyleSetSizes {
            fn clone(&self) -> Self { *self }
        }
        #[repr(u8)]
        /// Enumeration that represents one of the two supported style system backends.
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBackendType { None = 0, Gecko = 1, Servo = 2, }
        pub type TimeStampValue = u64;
        /// Instances of this class represent moments in time, or a special
        /// "null" moment. We do not use the non-monotonic system clock or
        /// local time, since they can be reset, causing apparent backward
        /// travel in time, which can confuse algorithms. Instead we measure
        /// elapsed time according to the system.  This time can never go
        /// backwards (i.e. it never wraps around, at least not in less than
        /// five million years of system elapsed time). It might not advance
        /// while the system is sleeping. If TimeStamp::SetNow() is not called
        /// at all for hours or days, we might not notice the passage of some
        /// of that time.
        ///
        /// We deliberately do not expose a way to convert TimeStamps to some
        /// particular unit. All you can do is compute a difference between two
        /// TimeStamps to get a TimeDuration. You can also add a TimeDuration
        /// to a TimeStamp to get a new TimeStamp. You can't do something
        /// meaningless like add two TimeStamps.
        ///
        /// Internally this is implemented as either a wrapper around
        /// - high-resolution, monotonic, system clocks if they exist on this
        /// platform
        /// - PRIntervalTime otherwise.  We detect wraparounds of
        /// PRIntervalTime and work around them.
        ///
        /// This class is similar to C++11's time_point, however it is
        /// explicitly nullable and provides an IsNull() method. time_point
        /// is initialized to the clock's epoch and provides a
        /// time_since_epoch() method that functions similiarly. i.e.
        /// t.IsNull() is equivalent to t.time_since_epoch() == decltype(t)::duration::zero();
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct TimeStamp {
            /// When built with PRIntervalTime, a value of 0 means this instance
            /// is "null". Otherwise, the low 32 bits represent a PRIntervalTime,
            /// and the high 32 bits represent a counter of the number of
            /// rollovers of PRIntervalTime that we've seen. This counter starts
            /// at 1 to avoid a real time colliding with the "null" value.
            ///
            /// PR_INTERVAL_MAX is set at 100,000 ticks per second. So the minimum
            /// time to wrap around is about 2^64/100000 seconds, i.e. about
            /// 5,849,424 years.
            ///
            /// When using a system clock, a value is system dependent.
            pub mValue: root::mozilla::TimeStampValue,
        }
        #[test]
        fn bindgen_test_layout_TimeStamp() {
            assert_eq!(::std::mem::size_of::<TimeStamp>() , 8usize , concat !
                       ( "Size of: " , stringify ! ( TimeStamp ) ));
            assert_eq! (::std::mem::align_of::<TimeStamp>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( TimeStamp ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const TimeStamp ) ) . mValue as * const
                        _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( TimeStamp ) ,
                        "::" , stringify ! ( mValue ) ));
        }
        impl Clone for TimeStamp {
            fn clone(&self) -> Self { *self }
        }
        /// Instances of this class represent the length of an interval of time.
        /// Negative durations are allowed, meaning the end is before the start.
        ///
        /// Internally the duration is stored as a int64_t in units of
        /// PR_TicksPerSecond() when building with NSPR interval timers, or a
        /// system-dependent unit when building with system clocks.  The
        /// system-dependent unit must be constant, otherwise the semantics of
        /// this class would be broken.
        ///
        /// The ValueCalculator template parameter determines how arithmetic
        /// operations are performed on the integer count of ticks (mValue).
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BaseTimeDuration {
            pub mValue: i64,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BaseTimeDuration__SomethingVeryRandomHere {
            pub _address: u8,
        }
        pub type Vector_Impl = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Vector_CapacityAndReserved {
            pub mCapacity: usize,
            pub mReserved: usize,
        }
        pub type Vector_ElementType<T> = T;
        pub const Vector_InlineLength: root::mozilla::Vector__bindgen_ty_1 =
            Vector__bindgen_ty_1::InlineLength;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum Vector__bindgen_ty_1 { InlineLength = 0, }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Vector_Range<T> {
            pub mCur: *mut T,
            pub mEnd: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Vector_ConstRange<T> {
            pub mCur: *mut T,
            pub mEnd: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ErrorResult {
            pub _bindgen_opaque_blob: [u64; 4usize],
        }
        pub type ErrorResult_BaseErrorResult =
            root::mozilla::binding_danger::TErrorResult;
        #[test]
        fn bindgen_test_layout_ErrorResult() {
            assert_eq!(::std::mem::size_of::<ErrorResult>() , 32usize , concat
                       ! ( "Size of: " , stringify ! ( ErrorResult ) ));
            assert_eq! (::std::mem::align_of::<ErrorResult>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ErrorResult ) ));
        }
        impl Clone for ErrorResult {
            fn clone(&self) -> Self { *self }
        }
        pub mod binding_danger {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            /// Templated implementation class for various ErrorResult-like things.  The
            /// instantiations differ only in terms of their cleanup policies (used in the
            /// destructor), which they can specify via the template argument.  Note that
            /// this means it's safe to reinterpret_cast between the instantiations unless
            /// you plan to invoke the destructor through such a cast pointer.
            ///
            /// A cleanup policy consists of two booleans: whether to assert that we've been
            /// reported or suppressed, and whether to then go ahead and suppress the
            /// exception.
            #[repr(C)]
            #[derive(Debug)]
            pub struct TErrorResult {
                pub mResult: root::nsresult,
                pub __bindgen_anon_1: root::mozilla::binding_danger::TErrorResult__bindgen_ty_1,
                pub mMightHaveUnreportedJSException: bool,
                pub mUnionState: root::mozilla::binding_danger::TErrorResult_UnionState,
                pub _mOwningThread: root::nsAutoOwningThread,
            }
            pub const TErrorResult_UnionState_HasDOMExceptionInfo:
                      root::mozilla::binding_danger::TErrorResult_UnionState =
                TErrorResult_UnionState::HasMessage;
            pub const TErrorResult_UnionState_HasJSException:
                      root::mozilla::binding_danger::TErrorResult_UnionState =
                TErrorResult_UnionState::HasMessage;
            pub const TErrorResult_UnionState_HasNothing:
                      root::mozilla::binding_danger::TErrorResult_UnionState =
                TErrorResult_UnionState::HasMessage;
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum TErrorResult_UnionState { HasMessage = 0, }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TErrorResult_Message {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TErrorResult_DOMExceptionInfo {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TErrorResult__bindgen_ty_1 {
                pub mMessage: root::__BindgenUnionField<*mut root::mozilla::binding_danger::TErrorResult_Message>,
                pub mJSException: root::__BindgenUnionField<root::JS::Value>,
                pub mDOMExceptionInfo: root::__BindgenUnionField<*mut root::mozilla::binding_danger::TErrorResult_DOMExceptionInfo>,
                pub bindgen_union_field: u64,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct AssertAndSuppressCleanupPolicy {
                pub _address: u8,
            }
            pub const AssertAndSuppressCleanupPolicy_assertHandled: bool =
                true;
            pub const AssertAndSuppressCleanupPolicy_suppress: bool = true;
            #[test]
            fn bindgen_test_layout_AssertAndSuppressCleanupPolicy() {
                assert_eq!(::std::mem::size_of::<AssertAndSuppressCleanupPolicy>()
                           , 1usize , concat ! (
                           "Size of: " , stringify ! (
                           AssertAndSuppressCleanupPolicy ) ));
                assert_eq! (::std::mem::align_of::<AssertAndSuppressCleanupPolicy>()
                            , 1usize , concat ! (
                            "Alignment of " , stringify ! (
                            AssertAndSuppressCleanupPolicy ) ));
            }
            impl Clone for AssertAndSuppressCleanupPolicy {
                fn clone(&self) -> Self { *self }
            }
        }
        /// Superclass for data common to CSSStyleSheet and ServoStyleSheet.
        #[repr(C)]
        #[derive(Debug)]
        pub struct StyleSheet {
            pub _base: root::nsIDOMCSSStyleSheet,
            pub _base_1: root::nsICSSLoaderObserver,
            pub _base_2: root::nsWrapperCache,
            pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
            pub _mOwningThread: root::nsAutoOwningThread,
            pub mParent: *mut root::mozilla::StyleSheet,
            pub mTitle: ::nsstring::nsStringRepr,
            pub mDocument: *mut root::nsIDocument,
            pub mOwningNode: *mut root::nsINode,
            pub mOwnerRule: *mut root::mozilla::dom::CSSImportRule,
            pub mMedia: root::RefPtr<root::mozilla::dom::MediaList>,
            pub mNext: root::RefPtr<root::mozilla::StyleSheet>,
            pub mParsingMode: root::mozilla::css::SheetParsingMode,
            pub mType: root::mozilla::StyleBackendType,
            pub mDisabled: bool,
            pub mDirty: bool,
            pub mDocumentAssociationMode: root::mozilla::StyleSheet_DocumentAssociationMode,
            pub mInner: *mut root::mozilla::StyleSheetInfo,
            pub mStyleSets: root::nsTArray<root::mozilla::StyleSetHandle>,
        }
        pub type StyleSheet_HasThreadSafeRefCnt = root::mozilla::FalseType;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleSheet_cycleCollection {
            pub _base: root::nsXPCOMCycleCollectionParticipant,
        }
        #[test]
        fn bindgen_test_layout_StyleSheet_cycleCollection() {
            assert_eq!(::std::mem::size_of::<StyleSheet_cycleCollection>() ,
                       16usize , concat ! (
                       "Size of: " , stringify ! ( StyleSheet_cycleCollection
                       ) ));
            assert_eq! (::std::mem::align_of::<StyleSheet_cycleCollection>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! (
                        StyleSheet_cycleCollection ) ));
        }
        impl Clone for StyleSheet_cycleCollection {
            fn clone(&self) -> Self { *self }
        }
        #[repr(i32)]
        /// The different changes that a stylesheet may go through.
        ///
        /// Used by the StyleSets in order to handle more efficiently some kinds of
        /// changes.
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleSheet_ChangeType {
            Added = 0,
            Removed = 1,
            ApplicableStateChanged = 2,
            RuleAdded = 3,
            RuleRemoved = 4,
            RuleChanged = 5,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleSheet_DocumentAssociationMode {
            OwnedByDocument = 0,
            NotOwnedByDocument = 1,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleSheet_ChildSheetListBuilder {
            pub sheetSlot: *mut root::RefPtr<root::mozilla::StyleSheet>,
            pub parent: *mut root::mozilla::StyleSheet,
        }
        #[test]
        fn bindgen_test_layout_StyleSheet_ChildSheetListBuilder() {
            assert_eq!(::std::mem::size_of::<StyleSheet_ChildSheetListBuilder>()
                       , 16usize , concat ! (
                       "Size of: " , stringify ! (
                       StyleSheet_ChildSheetListBuilder ) ));
            assert_eq! (::std::mem::align_of::<StyleSheet_ChildSheetListBuilder>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        StyleSheet_ChildSheetListBuilder ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleSheet_ChildSheetListBuilder ) )
                        . sheetSlot as * const _ as usize } , 0usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        StyleSheet_ChildSheetListBuilder ) , "::" , stringify
                        ! ( sheetSlot ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleSheet_ChildSheetListBuilder ) )
                        . parent as * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleSheet_ChildSheetListBuilder ) , "::" , stringify
                        ! ( parent ) ));
        }
        impl Clone for StyleSheet_ChildSheetListBuilder {
            fn clone(&self) -> Self { *self }
        }
        extern "C" {
            #[link_name = "_ZN7mozilla10StyleSheet21_cycleCollectorGlobalE"]
            pub static mut StyleSheet__cycleCollectorGlobal:
                       root::mozilla::StyleSheet_cycleCollection;
        }
        #[test]
        fn bindgen_test_layout_StyleSheet() {
            assert_eq!(::std::mem::size_of::<StyleSheet>() , 144usize , concat
                       ! ( "Size of: " , stringify ! ( StyleSheet ) ));
            assert_eq! (::std::mem::align_of::<StyleSheet>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( StyleSheet ) ));
        }
        pub mod net {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum ReferrerPolicy {
                RP_No_Referrer = 2,
                RP_Origin = 3,
                RP_No_Referrer_When_Downgrade = 1,
                RP_Origin_When_Crossorigin = 4,
                RP_Unsafe_URL = 5,
                RP_Same_Origin = 6,
                RP_Strict_Origin = 7,
                RP_Strict_Origin_When_Cross_Origin = 8,
                RP_Unset = 0,
            }
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum CORSMode {
            CORS_NONE = 0,
            CORS_ANONYMOUS = 1,
            CORS_USE_CREDENTIALS = 2,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct CSSStyleSheet {
            pub _base: root::mozilla::StyleSheet,
            pub mRuleCollection: root::RefPtr<root::CSSRuleListImpl>,
            pub mInRuleProcessorCache: bool,
            pub mScopeElement: root::RefPtr<root::mozilla::dom::Element>,
            pub mRuleProcessors: *mut u8,
        }
        pub use self::super::super::root::mozilla::net::ReferrerPolicy as
                CSSStyleSheet_ReferrerPolicy;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct CSSStyleSheet_cycleCollection {
            pub _base: root::mozilla::StyleSheet_cycleCollection,
        }
        #[test]
        fn bindgen_test_layout_CSSStyleSheet_cycleCollection() {
            assert_eq!(::std::mem::size_of::<CSSStyleSheet_cycleCollection>()
                       , 16usize , concat ! (
                       "Size of: " , stringify ! (
                       CSSStyleSheet_cycleCollection ) ));
            assert_eq! (::std::mem::align_of::<CSSStyleSheet_cycleCollection>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        CSSStyleSheet_cycleCollection ) ));
        }
        impl Clone for CSSStyleSheet_cycleCollection {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CSSStyleSheet_COMTypeInfo {
            pub _address: u8,
        }
        extern "C" {
            #[link_name =
                  "_ZN7mozilla13CSSStyleSheet21_cycleCollectorGlobalE"]
            pub static mut CSSStyleSheet__cycleCollectorGlobal:
                       root::mozilla::CSSStyleSheet_cycleCollection;
        }
        #[test]
        fn bindgen_test_layout_CSSStyleSheet() {
            assert_eq!(::std::mem::size_of::<CSSStyleSheet>() , 176usize ,
                       concat ! ( "Size of: " , stringify ! ( CSSStyleSheet )
                       ));
            assert_eq! (::std::mem::align_of::<CSSStyleSheet>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( CSSStyleSheet ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSStyleSheet ) ) .
                        mRuleCollection as * const _ as usize } , 144usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( CSSStyleSheet )
                        , "::" , stringify ! ( mRuleCollection ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSStyleSheet ) ) .
                        mInRuleProcessorCache as * const _ as usize } ,
                        152usize , concat ! (
                        "Alignment of field: " , stringify ! ( CSSStyleSheet )
                        , "::" , stringify ! ( mInRuleProcessorCache ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSStyleSheet ) ) . mScopeElement
                        as * const _ as usize } , 160usize , concat ! (
                        "Alignment of field: " , stringify ! ( CSSStyleSheet )
                        , "::" , stringify ! ( mScopeElement ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSStyleSheet ) ) .
                        mRuleProcessors as * const _ as usize } , 168usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( CSSStyleSheet )
                        , "::" , stringify ! ( mRuleProcessors ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ServoStyleSheet {
            pub _base: root::mozilla::StyleSheet,
            pub mRuleList: root::RefPtr<root::mozilla::ServoCSSRuleList>,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ServoStyleSheet_cycleCollection {
            pub _base: root::mozilla::StyleSheet_cycleCollection,
        }
        #[test]
        fn bindgen_test_layout_ServoStyleSheet_cycleCollection() {
            assert_eq!(::std::mem::size_of::<ServoStyleSheet_cycleCollection>()
                       , 16usize , concat ! (
                       "Size of: " , stringify ! (
                       ServoStyleSheet_cycleCollection ) ));
            assert_eq! (::std::mem::align_of::<ServoStyleSheet_cycleCollection>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        ServoStyleSheet_cycleCollection ) ));
        }
        impl Clone for ServoStyleSheet_cycleCollection {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ServoStyleSheet_COMTypeInfo {
            pub _address: u8,
        }
        extern "C" {
            #[link_name =
                  "_ZN7mozilla15ServoStyleSheet21_cycleCollectorGlobalE"]
            pub static mut ServoStyleSheet__cycleCollectorGlobal:
                       root::mozilla::ServoStyleSheet_cycleCollection;
        }
        #[test]
        fn bindgen_test_layout_ServoStyleSheet() {
            assert_eq!(::std::mem::size_of::<ServoStyleSheet>() , 152usize ,
                       concat ! (
                       "Size of: " , stringify ! ( ServoStyleSheet ) ));
            assert_eq! (::std::mem::align_of::<ServoStyleSheet>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ServoStyleSheet ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoStyleSheet ) ) . mRuleList
                        as * const _ as usize } , 144usize , concat ! (
                        "Alignment of field: " , stringify ! ( ServoStyleSheet
                        ) , "::" , stringify ! ( mRuleList ) ));
        }
        /// Smart pointer class that can hold a pointer to either an nsStyleSet
        /// or a ServoStyleSet.
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleSetHandle {
            pub mPtr: root::mozilla::StyleSetHandle_Ptr,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleSetHandle_Ptr {
            pub mValue: usize,
        }
        #[test]
        fn bindgen_test_layout_StyleSetHandle_Ptr() {
            assert_eq!(::std::mem::size_of::<StyleSetHandle_Ptr>() , 8usize ,
                       concat ! (
                       "Size of: " , stringify ! ( StyleSetHandle_Ptr ) ));
            assert_eq! (::std::mem::align_of::<StyleSetHandle_Ptr>() , 8usize
                        , concat ! (
                        "Alignment of " , stringify ! ( StyleSetHandle_Ptr )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSetHandle_Ptr ) ) . mValue
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleSetHandle_Ptr ) , "::" , stringify ! ( mValue )
                        ));
        }
        impl Clone for StyleSetHandle_Ptr {
            fn clone(&self) -> Self { *self }
        }
        #[test]
        fn bindgen_test_layout_StyleSetHandle() {
            assert_eq!(::std::mem::size_of::<StyleSetHandle>() , 8usize ,
                       concat ! ( "Size of: " , stringify ! ( StyleSetHandle )
                       ));
            assert_eq! (::std::mem::align_of::<StyleSetHandle>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StyleSetHandle ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSetHandle ) ) . mPtr as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleSetHandle
                        ) , "::" , stringify ! ( mPtr ) ));
        }
        impl Clone for StyleSetHandle {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        pub struct StyleSheetInfo__bindgen_vtable(::std::os::raw::c_void);
        /// Struct for data common to CSSStyleSheetInner and ServoStyleSheet.
        #[repr(C)]
        #[derive(Debug)]
        pub struct StyleSheetInfo {
            pub vtable_: *const StyleSheetInfo__bindgen_vtable,
            pub mSheetURI: root::nsCOMPtr<root::nsIURI>,
            pub mOriginalSheetURI: root::nsCOMPtr<root::nsIURI>,
            pub mBaseURI: root::nsCOMPtr<root::nsIURI>,
            pub mPrincipal: root::nsCOMPtr<root::nsIPrincipal>,
            pub mCORSMode: root::mozilla::CORSMode,
            pub mReferrerPolicy: root::mozilla::StyleSheetInfo_ReferrerPolicy,
            pub mIntegrity: root::mozilla::dom::SRIMetadata,
            pub mComplete: bool,
            pub mFirstChild: root::RefPtr<root::mozilla::StyleSheet>,
            pub mSheets: [u64; 10usize],
            pub mSourceMapURL: ::nsstring::nsStringRepr,
            pub mPrincipalSet: bool,
        }
        pub use self::super::super::root::mozilla::net::ReferrerPolicy as
                StyleSheetInfo_ReferrerPolicy;
        #[test]
        fn bindgen_test_layout_StyleSheetInfo() {
            assert_eq!(::std::mem::size_of::<StyleSheetInfo>() , 216usize ,
                       concat ! ( "Size of: " , stringify ! ( StyleSheetInfo )
                       ));
            assert_eq! (::std::mem::align_of::<StyleSheetInfo>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StyleSheetInfo ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSheetInfo ) ) . mSheetURI as
                        * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleSheetInfo
                        ) , "::" , stringify ! ( mSheetURI ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSheetInfo ) ) .
                        mOriginalSheetURI as * const _ as usize } , 16usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StyleSheetInfo
                        ) , "::" , stringify ! ( mOriginalSheetURI ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSheetInfo ) ) . mBaseURI as
                        * const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleSheetInfo
                        ) , "::" , stringify ! ( mBaseURI ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSheetInfo ) ) . mPrincipal
                        as * const _ as usize } , 32usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleSheetInfo
                        ) , "::" , stringify ! ( mPrincipal ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSheetInfo ) ) . mCORSMode as
                        * const _ as usize } , 40usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleSheetInfo
                        ) , "::" , stringify ! ( mCORSMode ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSheetInfo ) ) .
                        mReferrerPolicy as * const _ as usize } , 44usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StyleSheetInfo
                        ) , "::" , stringify ! ( mReferrerPolicy ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSheetInfo ) ) . mIntegrity
                        as * const _ as usize } , 48usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleSheetInfo
                        ) , "::" , stringify ! ( mIntegrity ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSheetInfo ) ) . mComplete as
                        * const _ as usize } , 96usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleSheetInfo
                        ) , "::" , stringify ! ( mComplete ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSheetInfo ) ) . mFirstChild
                        as * const _ as usize } , 104usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleSheetInfo
                        ) , "::" , stringify ! ( mFirstChild ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSheetInfo ) ) . mSheets as *
                        const _ as usize } , 112usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleSheetInfo
                        ) , "::" , stringify ! ( mSheets ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSheetInfo ) ) .
                        mSourceMapURL as * const _ as usize } , 192usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StyleSheetInfo
                        ) , "::" , stringify ! ( mSourceMapURL ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSheetInfo ) ) .
                        mPrincipalSet as * const _ as usize } , 208usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StyleSheetInfo
                        ) , "::" , stringify ! ( mPrincipalSet ) ));
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum CSSEnabledState {
            eForAllContent = 0,
            eInUASheets = 1,
            eInChrome = 2,
            eIgnoreEnabledState = 255,
        }
        pub type CSSPseudoElementTypeBase = u8;
        pub const CSSPseudoElementType_InheritingAnonBox:
                  root::mozilla::CSSPseudoElementType =
            CSSPseudoElementType::Count;
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum CSSPseudoElementType {
            after = 0,
            before = 1,
            backdrop = 2,
            cue = 3,
            firstLetter = 4,
            firstLine = 5,
            mozSelection = 6,
            mozFocusInner = 7,
            mozFocusOuter = 8,
            mozListBullet = 9,
            mozListNumber = 10,
            mozMathAnonymous = 11,
            mozNumberWrapper = 12,
            mozNumberText = 13,
            mozNumberSpinBox = 14,
            mozNumberSpinUp = 15,
            mozNumberSpinDown = 16,
            mozProgressBar = 17,
            mozRangeTrack = 18,
            mozRangeProgress = 19,
            mozRangeThumb = 20,
            mozMeterBar = 21,
            mozPlaceholder = 22,
            placeholder = 23,
            mozColorSwatch = 24,
            Count = 25,
            NonInheritingAnonBox = 26,
            XULTree = 27,
            NotPseudo = 28,
            MAX = 29,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct SeenPtrs {
            pub _bindgen_opaque_blob: [u64; 6usize],
        }
        #[test]
        fn bindgen_test_layout_SeenPtrs() {
            assert_eq!(::std::mem::size_of::<SeenPtrs>() , 48usize , concat !
                       ( "Size of: " , stringify ! ( SeenPtrs ) ));
            assert_eq! (::std::mem::align_of::<SeenPtrs>() , 8usize , concat !
                        ( "Alignment of " , stringify ! ( SeenPtrs ) ));
        }
        impl Clone for SeenPtrs {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct URLExtraData {
            pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
            pub mBaseURI: root::nsCOMPtr<root::nsIURI>,
            pub mReferrer: root::nsCOMPtr<root::nsIURI>,
            pub mPrincipal: root::nsCOMPtr<root::nsIPrincipal>,
            pub mIsChrome: bool,
        }
        pub type URLExtraData_HasThreadSafeRefCnt = root::mozilla::TrueType;
        extern "C" {
            #[link_name = "_ZN7mozilla12URLExtraData6sDummyE"]
            pub static mut URLExtraData_sDummy:
                       root::mozilla::StaticRefPtr<root::mozilla::URLExtraData>;
        }
        #[test]
        fn bindgen_test_layout_URLExtraData() {
            assert_eq!(::std::mem::size_of::<URLExtraData>() , 40usize ,
                       concat ! ( "Size of: " , stringify ! ( URLExtraData )
                       ));
            assert_eq! (::std::mem::align_of::<URLExtraData>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( URLExtraData ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const URLExtraData ) ) . mRefCnt as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( URLExtraData )
                        , "::" , stringify ! ( mRefCnt ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const URLExtraData ) ) . mBaseURI as *
                        const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( URLExtraData )
                        , "::" , stringify ! ( mBaseURI ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const URLExtraData ) ) . mReferrer as *
                        const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! ( URLExtraData )
                        , "::" , stringify ! ( mReferrer ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const URLExtraData ) ) . mPrincipal as
                        * const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! ( URLExtraData )
                        , "::" , stringify ! ( mPrincipal ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const URLExtraData ) ) . mIsChrome as *
                        const _ as usize } , 32usize , concat ! (
                        "Alignment of field: " , stringify ! ( URLExtraData )
                        , "::" , stringify ! ( mIsChrome ) ));
        }
        #[test]
        fn __bindgen_test_layout_StaticRefPtr_open0_URLExtraData_close0_instantiation() {
            assert_eq!(::std::mem::size_of::<root::mozilla::StaticRefPtr<root::mozilla::URLExtraData>>()
                       , 8usize , concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::mozilla::StaticRefPtr<root::mozilla::URLExtraData>
                       ) ));
            assert_eq!(::std::mem::align_of::<root::mozilla::StaticRefPtr<root::mozilla::URLExtraData>>()
                       , 8usize , concat ! (
                       "Alignment of template specialization: " , stringify !
                       (
                       root::mozilla::StaticRefPtr<root::mozilla::URLExtraData>
                       ) ));
        }
        pub mod widget {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IMEState {
                _unused: [u8; 0],
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ArenaAllocator_ArenaHeader {
            /// The location in memory of the data portion of the arena.
            pub offset: usize,
            /// The location in memory of the end of the data portion of the arena.
            pub tail: usize,
        }
        impl Clone for ArenaAllocator_ArenaHeader {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ArenaAllocator_ArenaChunk {
            pub header: root::mozilla::ArenaAllocator_ArenaHeader,
            pub next: *mut root::mozilla::ArenaAllocator_ArenaChunk,
        }
        impl Clone for ArenaAllocator_ArenaChunk {
            fn clone(&self) -> Self { *self }
        }
        pub mod a11y {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DocAccessible {
                _unused: [u8; 0],
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Encoding {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Runnable {
            pub _base: root::nsIRunnable,
            pub _base_1: root::nsINamed,
            pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
            pub _mOwningThread: root::nsAutoOwningThread,
            pub mName: *const ::std::os::raw::c_char,
        }
        pub type Runnable_HasThreadSafeRefCnt = root::mozilla::TrueType;
        #[test]
        fn bindgen_test_layout_Runnable() {
            assert_eq!(::std::mem::size_of::<Runnable>() , 40usize , concat !
                       ( "Size of: " , stringify ! ( Runnable ) ));
            assert_eq! (::std::mem::align_of::<Runnable>() , 8usize , concat !
                        ( "Alignment of " , stringify ! ( Runnable ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AbstractThread {
            _unused: [u8; 0],
        }
        pub type Preferences_PrefSetting = root::mozilla::dom::PrefSetting;
        #[repr(C)]
        #[derive(Debug)]
        pub struct CycleCollectedJSContext_RunInMetastableStateData {
            pub mRunnable: root::nsCOMPtr<root::nsIRunnable>,
            pub mRecursionDepth: u32,
        }
        #[test]
        fn bindgen_test_layout_CycleCollectedJSContext_RunInMetastableStateData() {
            assert_eq!(::std::mem::size_of::<CycleCollectedJSContext_RunInMetastableStateData>()
                       , 16usize , concat ! (
                       "Size of: " , stringify ! (
                       CycleCollectedJSContext_RunInMetastableStateData ) ));
            assert_eq! (::std::mem::align_of::<CycleCollectedJSContext_RunInMetastableStateData>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        CycleCollectedJSContext_RunInMetastableStateData ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const
                        CycleCollectedJSContext_RunInMetastableStateData ) ) .
                        mRunnable as * const _ as usize } , 0usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        CycleCollectedJSContext_RunInMetastableStateData ) ,
                        "::" , stringify ! ( mRunnable ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const
                        CycleCollectedJSContext_RunInMetastableStateData ) ) .
                        mRecursionDepth as * const _ as usize } , 8usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        CycleCollectedJSContext_RunInMetastableStateData ) ,
                        "::" , stringify ! ( mRecursionDepth ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SegmentedVector_SegmentImpl_Storage {
            pub mBuf: root::__BindgenUnionField<*mut ::std::os::raw::c_char>,
            pub mAlign: root::__BindgenUnionField<u8>,
            pub bindgen_union_field: u64,
        }
        pub type SegmentedVector_Segment = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SegmentedVector_IterImpl {
            pub mSegment: *mut root::mozilla::SegmentedVector_Segment,
            pub mIndex: usize,
        }
        #[repr(i16)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum UseCounter {
            eUseCounter_UNKNOWN = -1,
            eUseCounter_SVGSVGElement_getElementById = 0,
            eUseCounter_SVGSVGElement_currentScale_getter = 1,
            eUseCounter_SVGSVGElement_currentScale_setter = 2,
            eUseCounter_property_Fill = 3,
            eUseCounter_property_FillOpacity = 4,
            eUseCounter_XMLDocument_async_getter = 5,
            eUseCounter_XMLDocument_async_setter = 6,
            eUseCounter_DOMError_name_getter = 7,
            eUseCounter_DOMError_name_setter = 8,
            eUseCounter_DOMError_message_getter = 9,
            eUseCounter_DOMError_message_setter = 10,
            eUseCounter_custom_DOMErrorConstructor = 11,
            eUseCounter_PushManager_subscribe = 12,
            eUseCounter_PushSubscription_unsubscribe = 13,
            eUseCounter_Window_sidebar_getter = 14,
            eUseCounter_Window_sidebar_setter = 15,
            eUseCounter_External_addSearchEngine = 16,
            eUseCounter_OfflineResourceList_swapCache = 17,
            eUseCounter_OfflineResourceList_update = 18,
            eUseCounter_OfflineResourceList_status_getter = 19,
            eUseCounter_OfflineResourceList_status_setter = 20,
            eUseCounter_OfflineResourceList_onchecking_getter = 21,
            eUseCounter_OfflineResourceList_onchecking_setter = 22,
            eUseCounter_OfflineResourceList_onerror_getter = 23,
            eUseCounter_OfflineResourceList_onerror_setter = 24,
            eUseCounter_OfflineResourceList_onnoupdate_getter = 25,
            eUseCounter_OfflineResourceList_onnoupdate_setter = 26,
            eUseCounter_OfflineResourceList_ondownloading_getter = 27,
            eUseCounter_OfflineResourceList_ondownloading_setter = 28,
            eUseCounter_OfflineResourceList_onprogress_getter = 29,
            eUseCounter_OfflineResourceList_onprogress_setter = 30,
            eUseCounter_OfflineResourceList_onupdateready_getter = 31,
            eUseCounter_OfflineResourceList_onupdateready_setter = 32,
            eUseCounter_OfflineResourceList_oncached_getter = 33,
            eUseCounter_OfflineResourceList_oncached_setter = 34,
            eUseCounter_OfflineResourceList_onobsolete_getter = 35,
            eUseCounter_OfflineResourceList_onobsolete_setter = 36,
            eUseCounter_IDBDatabase_createMutableFile = 37,
            eUseCounter_IDBDatabase_mozCreateFileHandle = 38,
            eUseCounter_IDBMutableFile_open = 39,
            eUseCounter_IDBMutableFile_getFile = 40,
            eUseCounter_DataTransfer_addElement = 41,
            eUseCounter_DataTransfer_mozItemCount_getter = 42,
            eUseCounter_DataTransfer_mozItemCount_setter = 43,
            eUseCounter_DataTransfer_mozCursor_getter = 44,
            eUseCounter_DataTransfer_mozCursor_setter = 45,
            eUseCounter_DataTransfer_mozTypesAt = 46,
            eUseCounter_DataTransfer_mozClearDataAt = 47,
            eUseCounter_DataTransfer_mozSetDataAt = 48,
            eUseCounter_DataTransfer_mozGetDataAt = 49,
            eUseCounter_DataTransfer_mozUserCancelled_getter = 50,
            eUseCounter_DataTransfer_mozUserCancelled_setter = 51,
            eUseCounter_DataTransfer_mozSourceNode_getter = 52,
            eUseCounter_DataTransfer_mozSourceNode_setter = 53,
            eUseCounter_custom_JS_asmjs = 54,
            eUseCounter_custom_JS_wasm = 55,
            eUseCounter_GetAttributeNode = 56,
            eUseCounter_SetAttributeNode = 57,
            eUseCounter_GetAttributeNodeNS = 58,
            eUseCounter_SetAttributeNodeNS = 59,
            eUseCounter_RemoveAttributeNode = 60,
            eUseCounter_CreateAttribute = 61,
            eUseCounter_CreateAttributeNS = 62,
            eUseCounter_NodeValue = 63,
            eUseCounter_TextContent = 64,
            eUseCounter_EnablePrivilege = 65,
            eUseCounter_DOMExceptionCode = 66,
            eUseCounter_NoExposedProps = 67,
            eUseCounter_MutationEvent = 68,
            eUseCounter_Components = 69,
            eUseCounter_PrefixedVisibilityAPI = 70,
            eUseCounter_NodeIteratorDetach = 71,
            eUseCounter_LenientThis = 72,
            eUseCounter_GetPreventDefault = 73,
            eUseCounter_GetSetUserData = 74,
            eUseCounter_MozGetAsFile = 75,
            eUseCounter_UseOfCaptureEvents = 76,
            eUseCounter_UseOfReleaseEvents = 77,
            eUseCounter_UseOfDOM3LoadMethod = 78,
            eUseCounter_ChromeUseOfDOM3LoadMethod = 79,
            eUseCounter_ShowModalDialog = 80,
            eUseCounter_Window_Content = 81,
            eUseCounter_SyncXMLHttpRequest = 82,
            eUseCounter_Window_Cc_ontrollers = 83,
            eUseCounter_ImportXULIntoContent = 84,
            eUseCounter_PannerNodeDoppler = 85,
            eUseCounter_NavigatorGetUserMedia = 86,
            eUseCounter_WebrtcDeprecatedPrefix = 87,
            eUseCounter_RTCPeerConnectionGetStreams = 88,
            eUseCounter_AppCache = 89,
            eUseCounter_PrefixedImageSmoothingEnabled = 90,
            eUseCounter_PrefixedFullscreenAPI = 91,
            eUseCounter_LenientSetter = 92,
            eUseCounter_FileLastModifiedDate = 93,
            eUseCounter_ImageBitmapRenderingContext_TransferImageBitmap = 94,
            eUseCounter_URLCreateObjectURL_MediaStream = 95,
            eUseCounter_XMLBaseAttribute = 96,
            eUseCounter_XMLBaseAttributeForStyleAttr = 97,
            eUseCounter_Count = 98,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ScrollbarStyles {
            pub mHorizontal: u8,
            pub mVertical: u8,
            pub mScrollBehavior: u8,
            pub mScrollSnapTypeX: u8,
            pub mScrollSnapTypeY: u8,
            pub mScrollSnapPointsX: root::nsStyleCoord,
            pub mScrollSnapPointsY: root::nsStyleCoord,
            pub mScrollSnapDestinationX: root::nsStyleCoord_CalcValue,
            pub mScrollSnapDestinationY: root::nsStyleCoord_CalcValue,
        }
        #[test]
        fn bindgen_test_layout_ScrollbarStyles() {
            assert_eq!(::std::mem::size_of::<ScrollbarStyles>() , 64usize ,
                       concat ! (
                       "Size of: " , stringify ! ( ScrollbarStyles ) ));
            assert_eq! (::std::mem::align_of::<ScrollbarStyles>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ScrollbarStyles ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) . mHorizontal
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mHorizontal ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) . mVertical
                        as * const _ as usize } , 1usize , concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mVertical ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) .
                        mScrollBehavior as * const _ as usize } , 2usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mScrollBehavior ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) .
                        mScrollSnapTypeX as * const _ as usize } , 3usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mScrollSnapTypeX ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) .
                        mScrollSnapTypeY as * const _ as usize } , 4usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mScrollSnapTypeY ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) .
                        mScrollSnapPointsX as * const _ as usize } , 8usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mScrollSnapPointsX ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) .
                        mScrollSnapPointsY as * const _ as usize } , 24usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mScrollSnapPointsY ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) .
                        mScrollSnapDestinationX as * const _ as usize } ,
                        40usize , concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mScrollSnapDestinationX ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) .
                        mScrollSnapDestinationY as * const _ as usize } ,
                        52usize , concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mScrollSnapDestinationY ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct LangGroupFontPrefs {
            pub mLangGroup: root::nsCOMPtr<root::nsIAtom>,
            pub mMinimumFontSize: root::nscoord,
            pub mDefaultVariableFont: root::nsFont,
            pub mDefaultFixedFont: root::nsFont,
            pub mDefaultSerifFont: root::nsFont,
            pub mDefaultSansSerifFont: root::nsFont,
            pub mDefaultMonospaceFont: root::nsFont,
            pub mDefaultCursiveFont: root::nsFont,
            pub mDefaultFantasyFont: root::nsFont,
            pub mNext: root::nsAutoPtr<root::mozilla::LangGroupFontPrefs>,
        }
        #[test]
        fn bindgen_test_layout_LangGroupFontPrefs() {
            assert_eq!(::std::mem::size_of::<LangGroupFontPrefs>() , 640usize
                       , concat ! (
                       "Size of: " , stringify ! ( LangGroupFontPrefs ) ));
            assert_eq! (::std::mem::align_of::<LangGroupFontPrefs>() , 8usize
                        , concat ! (
                        "Alignment of " , stringify ! ( LangGroupFontPrefs )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mLangGroup as * const _ as usize } , 0usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! ( mLangGroup
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mMinimumFontSize as * const _ as usize } , 8usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mMinimumFontSize ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mDefaultVariableFont as * const _ as usize } , 16usize
                        , concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mDefaultVariableFont ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mDefaultFixedFont as * const _ as usize } , 104usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mDefaultFixedFont ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mDefaultSerifFont as * const _ as usize } , 192usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mDefaultSerifFont ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mDefaultSansSerifFont as * const _ as usize } ,
                        280usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mDefaultSansSerifFont ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mDefaultMonospaceFont as * const _ as usize } ,
                        368usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mDefaultMonospaceFont ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mDefaultCursiveFont as * const _ as usize } , 456usize
                        , concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mDefaultCursiveFont ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mDefaultFantasyFont as * const _ as usize } , 544usize
                        , concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mDefaultFantasyFont ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) . mNext as
                        * const _ as usize } , 632usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! ( mNext )
                        ));
        }
        /// Some functionality that has historically lived on nsPresContext does not
        /// actually need to be per-document. This singleton class serves as a host
        /// for that functionality. We delegate to it from nsPresContext where
        /// appropriate, and use it standalone in some cases as well.
        #[repr(C)]
        #[derive(Debug)]
        pub struct StaticPresData {
            pub mLangService: *mut root::nsLanguageAtomService,
            pub mBorderWidthTable: [root::nscoord; 3usize],
            pub mStaticLangGroupFontPrefs: root::mozilla::LangGroupFontPrefs,
        }
        #[test]
        fn bindgen_test_layout_StaticPresData() {
            assert_eq!(::std::mem::size_of::<StaticPresData>() , 664usize ,
                       concat ! ( "Size of: " , stringify ! ( StaticPresData )
                       ));
            assert_eq! (::std::mem::align_of::<StaticPresData>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StaticPresData ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StaticPresData ) ) . mLangService
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( StaticPresData
                        ) , "::" , stringify ! ( mLangService ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StaticPresData ) ) .
                        mBorderWidthTable as * const _ as usize } , 8usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StaticPresData
                        ) , "::" , stringify ! ( mBorderWidthTable ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StaticPresData ) ) .
                        mStaticLangGroupFontPrefs as * const _ as usize } ,
                        24usize , concat ! (
                        "Alignment of field: " , stringify ! ( StaticPresData
                        ) , "::" , stringify ! ( mStaticLangGroupFontPrefs )
                        ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct EffectCompositor {
            pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
            pub _mOwningThread: root::nsAutoOwningThread,
            pub mPresContext: *mut root::nsPresContext,
            pub mElementsToRestyle: [u64; 12usize],
            pub mIsInPreTraverse: bool,
            pub mRuleProcessors: [u64; 4usize],
        }
        pub type EffectCompositor_HasThreadSafeRefCnt =
            root::mozilla::FalseType;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct EffectCompositor_cycleCollection {
            pub _base: root::nsCycleCollectionParticipant,
        }
        #[test]
        fn bindgen_test_layout_EffectCompositor_cycleCollection() {
            assert_eq!(::std::mem::size_of::<EffectCompositor_cycleCollection>()
                       , 16usize , concat ! (
                       "Size of: " , stringify ! (
                       EffectCompositor_cycleCollection ) ));
            assert_eq! (::std::mem::align_of::<EffectCompositor_cycleCollection>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        EffectCompositor_cycleCollection ) ));
        }
        impl Clone for EffectCompositor_cycleCollection {
            fn clone(&self) -> Self { *self }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum EffectCompositor_CascadeLevel {
            Animations = 0,
            Transitions = 1,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum EffectCompositor_RestyleType {
            Throttled = 0,
            Standard = 1,
            Layer = 2,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct EffectCompositor_AnimationStyleRuleProcessor {
            pub _base: root::nsIStyleRuleProcessor,
            pub mRefCnt: root::nsAutoRefCnt,
            pub _mOwningThread: root::nsAutoOwningThread,
            pub mCompositor: *mut root::mozilla::EffectCompositor,
            pub mCascadeLevel: root::mozilla::EffectCompositor_CascadeLevel,
        }
        pub type EffectCompositor_AnimationStyleRuleProcessor_HasThreadSafeRefCnt
            = root::mozilla::FalseType;
        #[test]
        fn bindgen_test_layout_EffectCompositor_AnimationStyleRuleProcessor() {
            assert_eq!(::std::mem::size_of::<EffectCompositor_AnimationStyleRuleProcessor>()
                       , 40usize , concat ! (
                       "Size of: " , stringify ! (
                       EffectCompositor_AnimationStyleRuleProcessor ) ));
            assert_eq! (::std::mem::align_of::<EffectCompositor_AnimationStyleRuleProcessor>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        EffectCompositor_AnimationStyleRuleProcessor ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const
                        EffectCompositor_AnimationStyleRuleProcessor ) ) .
                        mRefCnt as * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor_AnimationStyleRuleProcessor ) , "::"
                        , stringify ! ( mRefCnt ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const
                        EffectCompositor_AnimationStyleRuleProcessor ) ) .
                        _mOwningThread as * const _ as usize } , 16usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor_AnimationStyleRuleProcessor ) , "::"
                        , stringify ! ( _mOwningThread ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const
                        EffectCompositor_AnimationStyleRuleProcessor ) ) .
                        mCompositor as * const _ as usize } , 24usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor_AnimationStyleRuleProcessor ) , "::"
                        , stringify ! ( mCompositor ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const
                        EffectCompositor_AnimationStyleRuleProcessor ) ) .
                        mCascadeLevel as * const _ as usize } , 32usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor_AnimationStyleRuleProcessor ) , "::"
                        , stringify ! ( mCascadeLevel ) ));
        }
        extern "C" {
            #[link_name =
                  "_ZN7mozilla16EffectCompositor21_cycleCollectorGlobalE"]
            pub static mut EffectCompositor__cycleCollectorGlobal:
                       root::mozilla::EffectCompositor_cycleCollection;
        }
        pub const EffectCompositor_kCascadeLevelCount: usize = 2;
        #[test]
        fn bindgen_test_layout_EffectCompositor() {
            assert_eq!(::std::mem::size_of::<EffectCompositor>() , 160usize ,
                       concat ! (
                       "Size of: " , stringify ! ( EffectCompositor ) ));
            assert_eq! (::std::mem::align_of::<EffectCompositor>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( EffectCompositor ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const EffectCompositor ) ) . mRefCnt as
                        * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor ) , "::" , stringify ! ( mRefCnt )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const EffectCompositor ) ) .
                        _mOwningThread as * const _ as usize } , 8usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor ) , "::" , stringify ! (
                        _mOwningThread ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const EffectCompositor ) ) .
                        mPresContext as * const _ as usize } , 16usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor ) , "::" , stringify ! ( mPresContext
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const EffectCompositor ) ) .
                        mElementsToRestyle as * const _ as usize } , 24usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor ) , "::" , stringify ! (
                        mElementsToRestyle ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const EffectCompositor ) ) .
                        mIsInPreTraverse as * const _ as usize } , 120usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor ) , "::" , stringify ! (
                        mIsInPreTraverse ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const EffectCompositor ) ) .
                        mRuleProcessors as * const _ as usize } , 128usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor ) , "::" , stringify ! (
                        mRuleProcessors ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EventStateManager {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct CounterStyleManager {
            pub mRefCnt: root::nsAutoRefCnt,
            pub _mOwningThread: root::nsAutoOwningThread,
            pub mPresContext: *mut root::nsPresContext,
            pub mStyles: [u64; 6usize],
            pub mRetiredStyles: root::nsTArray<*mut root::mozilla::CounterStyle>,
        }
        pub type CounterStyleManager_HasThreadSafeRefCnt =
            root::mozilla::FalseType;
        #[test]
        fn bindgen_test_layout_CounterStyleManager() {
            assert_eq!(::std::mem::size_of::<CounterStyleManager>() , 80usize
                       , concat ! (
                       "Size of: " , stringify ! ( CounterStyleManager ) ));
            assert_eq! (::std::mem::align_of::<CounterStyleManager>() , 8usize
                        , concat ! (
                        "Alignment of " , stringify ! ( CounterStyleManager )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CounterStyleManager ) ) . mRefCnt
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        CounterStyleManager ) , "::" , stringify ! ( mRefCnt )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CounterStyleManager ) ) .
                        _mOwningThread as * const _ as usize } , 8usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        CounterStyleManager ) , "::" , stringify ! (
                        _mOwningThread ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CounterStyleManager ) ) .
                        mPresContext as * const _ as usize } , 16usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        CounterStyleManager ) , "::" , stringify ! (
                        mPresContext ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CounterStyleManager ) ) . mStyles
                        as * const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        CounterStyleManager ) , "::" , stringify ! ( mStyles )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CounterStyleManager ) ) .
                        mRetiredStyles as * const _ as usize } , 72usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        CounterStyleManager ) , "::" , stringify ! (
                        mRetiredStyles ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RestyleManager {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct XREAppData_NSFreePolicy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_XREAppData_NSFreePolicy() {
            assert_eq!(::std::mem::size_of::<XREAppData_NSFreePolicy>() ,
                       1usize , concat ! (
                       "Size of: " , stringify ! ( XREAppData_NSFreePolicy )
                       ));
            assert_eq! (::std::mem::align_of::<XREAppData_NSFreePolicy>() ,
                        1usize , concat ! (
                        "Alignment of " , stringify ! (
                        XREAppData_NSFreePolicy ) ));
        }
        impl Clone for XREAppData_NSFreePolicy {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        pub struct SchedulerGroup__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct SchedulerGroup {
            pub vtable_: *const SchedulerGroup__bindgen_vtable,
            pub mIsRunning: bool,
            pub mEventTargets: [root::nsCOMPtr<root::nsISerialEventTarget>; 8usize],
            pub mAbstractThreads: [root::RefPtr<root::mozilla::AbstractThread>; 8usize],
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SchedulerGroup_Runnable {
            pub _base: root::mozilla::Runnable,
            pub _base_1: root::nsIRunnablePriority,
            pub _base_2: root::nsILabelableRunnable,
            pub mRunnable: root::nsCOMPtr<root::nsIRunnable>,
            pub mGroup: root::RefPtr<root::mozilla::SchedulerGroup>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SchedulerGroup_Runnable_COMTypeInfo {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_SchedulerGroup_Runnable() {
            assert_eq!(::std::mem::size_of::<SchedulerGroup_Runnable>() ,
                       72usize , concat ! (
                       "Size of: " , stringify ! ( SchedulerGroup_Runnable )
                       ));
            assert_eq! (::std::mem::align_of::<SchedulerGroup_Runnable>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! (
                        SchedulerGroup_Runnable ) ));
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum SchedulerGroup_ValidationType {
            StartValidation = 0,
            EndValidation = 1,
        }
        extern "C" {
            #[link_name =
                  "_ZN7mozilla14SchedulerGroup20sTlsValidatingAccessE"]
            pub static mut SchedulerGroup_sTlsValidatingAccess:
                       root::mozilla::detail::ThreadLocal<bool>;
        }
        #[test]
        fn bindgen_test_layout_SchedulerGroup() {
            assert_eq!(::std::mem::size_of::<SchedulerGroup>() , 144usize ,
                       concat ! ( "Size of: " , stringify ! ( SchedulerGroup )
                       ));
            assert_eq! (::std::mem::align_of::<SchedulerGroup>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( SchedulerGroup ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const SchedulerGroup ) ) . mIsRunning
                        as * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( SchedulerGroup
                        ) , "::" , stringify ! ( mIsRunning ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const SchedulerGroup ) ) .
                        mEventTargets as * const _ as usize } , 16usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( SchedulerGroup
                        ) , "::" , stringify ! ( mEventTargets ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const SchedulerGroup ) ) .
                        mAbstractThreads as * const _ as usize } , 80usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( SchedulerGroup
                        ) , "::" , stringify ! ( mAbstractThreads ) ));
        }
        #[test]
        fn __bindgen_test_layout_ThreadLocal_open0_bool__close0_instantiation() {
            assert_eq!(::std::mem::size_of::<root::mozilla::detail::ThreadLocal<bool>>()
                       , 1usize , concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::mozilla::detail::ThreadLocal<bool> ) ));
            assert_eq!(::std::mem::align_of::<root::mozilla::detail::ThreadLocal<bool>>()
                       , 1usize , concat ! (
                       "Alignment of template specialization: " , stringify !
                       ( root::mozilla::detail::ThreadLocal<bool> ) ));
        }
        pub mod image {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ImageURL {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Image {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ProgressTracker {
                _unused: [u8; 0],
            }
            #[repr(C)]
            pub struct IProgressObserver__bindgen_vtable(::std::os::raw::c_void);
            /// An interface for observing changes to image state, as reported by
            /// ProgressTracker.
            ///
            /// This is the ImageLib-internal version of imgINotificationObserver,
            /// essentially, with implementation details that code outside of ImageLib
            /// shouldn't see.
            ///
            /// XXX(seth): It's preferable to avoid adding anything to this interface if
            /// possible.  In the long term, it would be ideal to get to a place where we can
            /// just use the imgINotificationObserver interface internally as well.
            #[repr(C)]
            #[derive(Debug)]
            pub struct IProgressObserver {
                pub vtable_: *const IProgressObserver__bindgen_vtable,
                pub _base: u64,
            }
            #[test]
            fn bindgen_test_layout_IProgressObserver() {
                assert_eq!(::std::mem::size_of::<IProgressObserver>() ,
                           16usize , concat ! (
                           "Size of: " , stringify ! ( IProgressObserver ) ));
                assert_eq! (::std::mem::align_of::<IProgressObserver>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! ( IProgressObserver
                            ) ));
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AnonymousCounterStyle {
            pub _base: root::mozilla::CounterStyle,
            pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
            pub mSingleString: bool,
            pub mSystem: u8,
            pub mSymbols: root::nsTArray<::nsstring::nsStringRepr>,
        }
        pub type AnonymousCounterStyle_HasThreadSafeRefCnt =
            root::mozilla::TrueType;
        #[test]
        fn bindgen_test_layout_AnonymousCounterStyle() {
            assert_eq!(::std::mem::size_of::<AnonymousCounterStyle>() ,
                       40usize , concat ! (
                       "Size of: " , stringify ! ( AnonymousCounterStyle ) ));
            assert_eq! (::std::mem::align_of::<AnonymousCounterStyle>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! ( AnonymousCounterStyle
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnonymousCounterStyle ) ) .
                        mRefCnt as * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        AnonymousCounterStyle ) , "::" , stringify ! ( mRefCnt
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnonymousCounterStyle ) ) .
                        mSingleString as * const _ as usize } , 24usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        AnonymousCounterStyle ) , "::" , stringify ! (
                        mSingleString ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnonymousCounterStyle ) ) .
                        mSystem as * const _ as usize } , 25usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        AnonymousCounterStyle ) , "::" , stringify ! ( mSystem
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnonymousCounterStyle ) ) .
                        mSymbols as * const _ as usize } , 32usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        AnonymousCounterStyle ) , "::" , stringify ! (
                        mSymbols ) ));
        }
        #[repr(C)]
        pub struct CounterStyle__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct CounterStyle {
            pub vtable_: *const CounterStyle__bindgen_vtable,
            pub mStyle: i32,
        }
        #[test]
        fn bindgen_test_layout_CounterStyle() {
            assert_eq!(::std::mem::size_of::<CounterStyle>() , 16usize ,
                       concat ! ( "Size of: " , stringify ! ( CounterStyle )
                       ));
            assert_eq! (::std::mem::align_of::<CounterStyle>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( CounterStyle ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CounterStyle ) ) . mStyle as *
                        const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( CounterStyle )
                        , "::" , stringify ! ( mStyle ) ));
        }
        impl Clone for CounterStyle {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct CounterStylePtr {
            pub mRaw: usize,
        }
        #[repr(u64)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum CounterStylePtr_Type {
            eCounterStyle = 0,
            eAnonymousCounterStyle = 1,
            eUnresolvedAtom = 2,
            eMask = 3,
        }
        #[test]
        fn bindgen_test_layout_CounterStylePtr() {
            assert_eq!(::std::mem::size_of::<CounterStylePtr>() , 8usize ,
                       concat ! (
                       "Size of: " , stringify ! ( CounterStylePtr ) ));
            assert_eq! (::std::mem::align_of::<CounterStylePtr>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( CounterStylePtr ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CounterStylePtr ) ) . mRaw as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( CounterStylePtr
                        ) , "::" , stringify ! ( mRaw ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct Position {
            pub mXPosition: root::mozilla::Position_Coord,
            pub mYPosition: root::mozilla::Position_Coord,
        }
        pub type Position_Coord = root::nsStyleCoord_CalcValue;
        #[test]
        fn bindgen_test_layout_Position() {
            assert_eq!(::std::mem::size_of::<Position>() , 24usize , concat !
                       ( "Size of: " , stringify ! ( Position ) ));
            assert_eq! (::std::mem::align_of::<Position>() , 4usize , concat !
                        ( "Alignment of " , stringify ! ( Position ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Position ) ) . mXPosition as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Position ) ,
                        "::" , stringify ! ( mXPosition ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Position ) ) . mYPosition as *
                        const _ as usize } , 12usize , concat ! (
                        "Alignment of field: " , stringify ! ( Position ) ,
                        "::" , stringify ! ( mYPosition ) ));
        }
        impl Clone for Position {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct StyleTransition {
            pub mTimingFunction: root::nsTimingFunction,
            pub mDuration: f32,
            pub mDelay: f32,
            pub mProperty: root::nsCSSPropertyID,
            pub mUnknownProperty: root::nsCOMPtr<root::nsIAtom>,
        }
        #[test]
        fn bindgen_test_layout_StyleTransition() {
            assert_eq!(::std::mem::size_of::<StyleTransition>() , 40usize ,
                       concat ! (
                       "Size of: " , stringify ! ( StyleTransition ) ));
            assert_eq! (::std::mem::align_of::<StyleTransition>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StyleTransition ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleTransition ) ) .
                        mTimingFunction as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StyleTransition
                        ) , "::" , stringify ! ( mTimingFunction ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleTransition ) ) . mDuration
                        as * const _ as usize } , 20usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleTransition
                        ) , "::" , stringify ! ( mDuration ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleTransition ) ) . mDelay as *
                        const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleTransition
                        ) , "::" , stringify ! ( mDelay ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleTransition ) ) . mProperty
                        as * const _ as usize } , 28usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleTransition
                        ) , "::" , stringify ! ( mProperty ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleTransition ) ) .
                        mUnknownProperty as * const _ as usize } , 32usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StyleTransition
                        ) , "::" , stringify ! ( mUnknownProperty ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct StyleAnimation {
            pub mTimingFunction: root::nsTimingFunction,
            pub mDuration: f32,
            pub mDelay: f32,
            pub mName: ::nsstring::nsStringRepr,
            pub mDirection: root::mozilla::dom::PlaybackDirection,
            pub mFillMode: root::mozilla::dom::FillMode,
            pub mPlayState: u8,
            pub mIterationCount: f32,
        }
        #[test]
        fn bindgen_test_layout_StyleAnimation() {
            assert_eq!(::std::mem::size_of::<StyleAnimation>() , 56usize ,
                       concat ! ( "Size of: " , stringify ! ( StyleAnimation )
                       ));
            assert_eq! (::std::mem::align_of::<StyleAnimation>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StyleAnimation ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) .
                        mTimingFunction as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mTimingFunction ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) . mDuration as
                        * const _ as usize } , 20usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mDuration ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) . mDelay as *
                        const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mDelay ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) . mName as *
                        const _ as usize } , 32usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mName ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) . mDirection
                        as * const _ as usize } , 48usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mDirection ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) . mFillMode as
                        * const _ as usize } , 49usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mFillMode ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) . mPlayState
                        as * const _ as usize } , 50usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mPlayState ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) .
                        mIterationCount as * const _ as usize } , 52usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mIterationCount ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct StyleBasicShape {
            pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
            pub mType: root::mozilla::StyleBasicShapeType,
            pub mFillRule: root::mozilla::StyleFillRule,
            pub mCoordinates: root::nsTArray<root::nsStyleCoord>,
            pub mPosition: root::mozilla::Position,
            pub mRadius: root::nsStyleCorners,
        }
        pub type StyleBasicShape_HasThreadSafeRefCnt =
            root::mozilla::TrueType;
        #[test]
        fn bindgen_test_layout_StyleBasicShape() {
            assert_eq!(::std::mem::size_of::<StyleBasicShape>() , 120usize ,
                       concat ! (
                       "Size of: " , stringify ! ( StyleBasicShape ) ));
            assert_eq! (::std::mem::align_of::<StyleBasicShape>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StyleBasicShape ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleBasicShape ) ) . mRefCnt as
                        * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleBasicShape
                        ) , "::" , stringify ! ( mRefCnt ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleBasicShape ) ) . mType as *
                        const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleBasicShape
                        ) , "::" , stringify ! ( mType ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleBasicShape ) ) . mFillRule
                        as * const _ as usize } , 9usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleBasicShape
                        ) , "::" , stringify ! ( mFillRule ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleBasicShape ) ) .
                        mCoordinates as * const _ as usize } , 16usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StyleBasicShape
                        ) , "::" , stringify ! ( mCoordinates ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleBasicShape ) ) . mPosition
                        as * const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleBasicShape
                        ) , "::" , stringify ! ( mPosition ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleBasicShape ) ) . mRadius as
                        * const _ as usize } , 48usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleBasicShape
                        ) , "::" , stringify ! ( mRadius ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct StyleShapeSource {
            pub __bindgen_anon_1: root::mozilla::StyleShapeSource__bindgen_ty_1,
            pub mType: root::mozilla::StyleShapeSourceType,
            pub mReferenceBox: root::mozilla::StyleGeometryBox,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleShapeSource__bindgen_ty_1 {
            pub mBasicShape: root::__BindgenUnionField<*mut root::mozilla::StyleBasicShape>,
            pub mURL: root::__BindgenUnionField<*mut root::mozilla::css::URLValue>,
            pub bindgen_union_field: u64,
        }
        #[test]
        fn bindgen_test_layout_StyleShapeSource__bindgen_ty_1() {
            assert_eq!(::std::mem::size_of::<StyleShapeSource__bindgen_ty_1>()
                       , 8usize , concat ! (
                       "Size of: " , stringify ! (
                       StyleShapeSource__bindgen_ty_1 ) ));
            assert_eq! (::std::mem::align_of::<StyleShapeSource__bindgen_ty_1>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        StyleShapeSource__bindgen_ty_1 ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleShapeSource__bindgen_ty_1 )
                        ) . mBasicShape as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleShapeSource__bindgen_ty_1 ) , "::" , stringify !
                        ( mBasicShape ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleShapeSource__bindgen_ty_1 )
                        ) . mURL as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleShapeSource__bindgen_ty_1 ) , "::" , stringify !
                        ( mURL ) ));
        }
        impl Clone for StyleShapeSource__bindgen_ty_1 {
            fn clone(&self) -> Self { *self }
        }
        #[test]
        fn bindgen_test_layout_StyleShapeSource() {
            assert_eq!(::std::mem::size_of::<StyleShapeSource>() , 16usize ,
                       concat ! (
                       "Size of: " , stringify ! ( StyleShapeSource ) ));
            assert_eq! (::std::mem::align_of::<StyleShapeSource>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StyleShapeSource ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleShapeSource ) ) . mType as *
                        const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleShapeSource ) , "::" , stringify ! ( mType ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleShapeSource ) ) .
                        mReferenceBox as * const _ as usize } , 9usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleShapeSource ) , "::" , stringify ! (
                        mReferenceBox ) ));
        }
        /// <div rustbindgen="true" replaces="mozilla::UniquePtr">
        ///
        /// TODO(Emilio): This is a workaround and we should be able to get rid of this
        /// one.
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct UniquePtr<T> {
            pub mPtr: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub const SERVO_PREF_ENABLED_align_content: bool = false;
        pub const SERVO_PREF_ENABLED_align_items: bool = false;
        pub const SERVO_PREF_ENABLED_align_self: bool = false;
        pub const SERVO_PREF_ENABLED_all: bool = true;
        pub const SERVO_PREF_ENABLED_animation: bool = false;
        pub const SERVO_PREF_ENABLED_animation_delay: bool = false;
        pub const SERVO_PREF_ENABLED_animation_direction: bool = false;
        pub const SERVO_PREF_ENABLED_animation_duration: bool = false;
        pub const SERVO_PREF_ENABLED_animation_fill_mode: bool = false;
        pub const SERVO_PREF_ENABLED_animation_iteration_count: bool = false;
        pub const SERVO_PREF_ENABLED_animation_name: bool = false;
        pub const SERVO_PREF_ENABLED_animation_play_state: bool = false;
        pub const SERVO_PREF_ENABLED_animation_timing_function: bool = false;
        pub const SERVO_PREF_ENABLED__moz_appearance: bool = false;
        pub const SERVO_PREF_ENABLED_backface_visibility: bool = false;
        pub const SERVO_PREF_ENABLED_background: bool = false;
        pub const SERVO_PREF_ENABLED_background_attachment: bool = false;
        pub const SERVO_PREF_ENABLED_background_blend_mode: bool = true;
        pub const SERVO_PREF_ENABLED_background_clip: bool = false;
        pub const SERVO_PREF_ENABLED_background_color: bool = false;
        pub const SERVO_PREF_ENABLED_background_image: bool = false;
        pub const SERVO_PREF_ENABLED_background_origin: bool = false;
        pub const SERVO_PREF_ENABLED_background_position: bool = false;
        pub const SERVO_PREF_ENABLED_background_position_x: bool = false;
        pub const SERVO_PREF_ENABLED_background_position_y: bool = false;
        pub const SERVO_PREF_ENABLED_background_repeat: bool = false;
        pub const SERVO_PREF_ENABLED_background_size: bool = false;
        pub const SERVO_PREF_ENABLED__moz_binding: bool = false;
        pub const SERVO_PREF_ENABLED_block_size: bool = false;
        pub const SERVO_PREF_ENABLED_border: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_end: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_end_color: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_end_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_end_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_start: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_start_color: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_start_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_start_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_bottom: bool = false;
        pub const SERVO_PREF_ENABLED_border_bottom_color: bool = false;
        pub const SERVO_PREF_ENABLED__moz_border_bottom_colors: bool = false;
        pub const SERVO_PREF_ENABLED_border_bottom_left_radius: bool = false;
        pub const SERVO_PREF_ENABLED_border_bottom_right_radius: bool = false;
        pub const SERVO_PREF_ENABLED_border_bottom_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_bottom_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_collapse: bool = false;
        pub const SERVO_PREF_ENABLED_border_color: bool = false;
        pub const SERVO_PREF_ENABLED_border_image: bool = false;
        pub const SERVO_PREF_ENABLED_border_image_outset: bool = false;
        pub const SERVO_PREF_ENABLED_border_image_repeat: bool = false;
        pub const SERVO_PREF_ENABLED_border_image_slice: bool = false;
        pub const SERVO_PREF_ENABLED_border_image_source: bool = false;
        pub const SERVO_PREF_ENABLED_border_image_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_end: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_end_color: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_end_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_end_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_start: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_start_color: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_start_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_start_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_left: bool = false;
        pub const SERVO_PREF_ENABLED_border_left_color: bool = false;
        pub const SERVO_PREF_ENABLED__moz_border_left_colors: bool = false;
        pub const SERVO_PREF_ENABLED_border_left_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_left_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_radius: bool = false;
        pub const SERVO_PREF_ENABLED_border_right: bool = false;
        pub const SERVO_PREF_ENABLED_border_right_color: bool = false;
        pub const SERVO_PREF_ENABLED__moz_border_right_colors: bool = false;
        pub const SERVO_PREF_ENABLED_border_right_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_right_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_spacing: bool = false;
        pub const SERVO_PREF_ENABLED_border_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_top: bool = false;
        pub const SERVO_PREF_ENABLED_border_top_color: bool = false;
        pub const SERVO_PREF_ENABLED__moz_border_top_colors: bool = false;
        pub const SERVO_PREF_ENABLED_border_top_left_radius: bool = false;
        pub const SERVO_PREF_ENABLED_border_top_right_radius: bool = false;
        pub const SERVO_PREF_ENABLED_border_top_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_top_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_width: bool = false;
        pub const SERVO_PREF_ENABLED_bottom: bool = false;
        pub const SERVO_PREF_ENABLED__moz_box_align: bool = false;
        pub const SERVO_PREF_ENABLED_box_decoration_break: bool = true;
        pub const SERVO_PREF_ENABLED__moz_box_direction: bool = false;
        pub const SERVO_PREF_ENABLED__moz_box_flex: bool = false;
        pub const SERVO_PREF_ENABLED__moz_box_ordinal_group: bool = false;
        pub const SERVO_PREF_ENABLED__moz_box_orient: bool = false;
        pub const SERVO_PREF_ENABLED__moz_box_pack: bool = false;
        pub const SERVO_PREF_ENABLED_box_shadow: bool = false;
        pub const SERVO_PREF_ENABLED_box_sizing: bool = false;
        pub const SERVO_PREF_ENABLED_caption_side: bool = false;
        pub const SERVO_PREF_ENABLED_caret_color: bool = false;
        pub const SERVO_PREF_ENABLED_clear: bool = false;
        pub const SERVO_PREF_ENABLED_clip: bool = false;
        pub const SERVO_PREF_ENABLED_clip_path: bool = false;
        pub const SERVO_PREF_ENABLED_clip_rule: bool = false;
        pub const SERVO_PREF_ENABLED_color: bool = false;
        pub const SERVO_PREF_ENABLED_color_adjust: bool = true;
        pub const SERVO_PREF_ENABLED_color_interpolation: bool = false;
        pub const SERVO_PREF_ENABLED_color_interpolation_filters: bool =
            false;
        pub const SERVO_PREF_ENABLED_column_count: bool = false;
        pub const SERVO_PREF_ENABLED_column_fill: bool = false;
        pub const SERVO_PREF_ENABLED_column_gap: bool = false;
        pub const SERVO_PREF_ENABLED_column_rule: bool = false;
        pub const SERVO_PREF_ENABLED_column_rule_color: bool = false;
        pub const SERVO_PREF_ENABLED_column_rule_style: bool = false;
        pub const SERVO_PREF_ENABLED_column_rule_width: bool = false;
        pub const SERVO_PREF_ENABLED_column_span: bool = true;
        pub const SERVO_PREF_ENABLED_column_width: bool = false;
        pub const SERVO_PREF_ENABLED_columns: bool = false;
        pub const SERVO_PREF_ENABLED_contain: bool = true;
        pub const SERVO_PREF_ENABLED_content: bool = false;
        pub const SERVO_PREF_ENABLED__moz_context_properties: bool = false;
        pub const SERVO_PREF_ENABLED__moz_control_character_visibility: bool =
            false;
        pub const SERVO_PREF_ENABLED_counter_increment: bool = false;
        pub const SERVO_PREF_ENABLED_counter_reset: bool = false;
        pub const SERVO_PREF_ENABLED_cursor: bool = false;
        pub const SERVO_PREF_ENABLED_direction: bool = false;
        pub const SERVO_PREF_ENABLED_display: bool = false;
        pub const SERVO_PREF_ENABLED_dominant_baseline: bool = false;
        pub const SERVO_PREF_ENABLED_empty_cells: bool = false;
        pub const SERVO_PREF_ENABLED_fill: bool = false;
        pub const SERVO_PREF_ENABLED_fill_opacity: bool = false;
        pub const SERVO_PREF_ENABLED_fill_rule: bool = false;
        pub const SERVO_PREF_ENABLED_filter: bool = false;
        pub const SERVO_PREF_ENABLED_flex: bool = false;
        pub const SERVO_PREF_ENABLED_flex_basis: bool = false;
        pub const SERVO_PREF_ENABLED_flex_direction: bool = false;
        pub const SERVO_PREF_ENABLED_flex_flow: bool = false;
        pub const SERVO_PREF_ENABLED_flex_grow: bool = false;
        pub const SERVO_PREF_ENABLED_flex_shrink: bool = false;
        pub const SERVO_PREF_ENABLED_flex_wrap: bool = false;
        pub const SERVO_PREF_ENABLED_float_: bool = false;
        pub const SERVO_PREF_ENABLED__moz_float_edge: bool = false;
        pub const SERVO_PREF_ENABLED_flood_color: bool = false;
        pub const SERVO_PREF_ENABLED_flood_opacity: bool = false;
        pub const SERVO_PREF_ENABLED_font: bool = false;
        pub const SERVO_PREF_ENABLED_font_family: bool = false;
        pub const SERVO_PREF_ENABLED_font_feature_settings: bool = false;
        pub const SERVO_PREF_ENABLED_font_kerning: bool = false;
        pub const SERVO_PREF_ENABLED_font_language_override: bool = false;
        pub const SERVO_PREF_ENABLED_font_size: bool = false;
        pub const SERVO_PREF_ENABLED_font_size_adjust: bool = false;
        pub const SERVO_PREF_ENABLED_font_stretch: bool = false;
        pub const SERVO_PREF_ENABLED_font_style: bool = false;
        pub const SERVO_PREF_ENABLED_font_synthesis: bool = false;
        pub const SERVO_PREF_ENABLED_font_variant: bool = false;
        pub const SERVO_PREF_ENABLED_font_variant_alternates: bool = false;
        pub const SERVO_PREF_ENABLED_font_variant_caps: bool = false;
        pub const SERVO_PREF_ENABLED_font_variant_east_asian: bool = false;
        pub const SERVO_PREF_ENABLED_font_variant_ligatures: bool = false;
        pub const SERVO_PREF_ENABLED_font_variant_numeric: bool = false;
        pub const SERVO_PREF_ENABLED_font_variant_position: bool = false;
        pub const SERVO_PREF_ENABLED_font_variation_settings: bool = true;
        pub const SERVO_PREF_ENABLED_font_weight: bool = false;
        pub const SERVO_PREF_ENABLED__moz_force_broken_image_icon: bool =
            false;
        pub const SERVO_PREF_ENABLED_grid: bool = true;
        pub const SERVO_PREF_ENABLED_grid_area: bool = true;
        pub const SERVO_PREF_ENABLED_grid_auto_columns: bool = true;
        pub const SERVO_PREF_ENABLED_grid_auto_flow: bool = true;
        pub const SERVO_PREF_ENABLED_grid_auto_rows: bool = true;
        pub const SERVO_PREF_ENABLED_grid_column: bool = true;
        pub const SERVO_PREF_ENABLED_grid_column_end: bool = true;
        pub const SERVO_PREF_ENABLED_grid_column_gap: bool = true;
        pub const SERVO_PREF_ENABLED_grid_column_start: bool = true;
        pub const SERVO_PREF_ENABLED_grid_gap: bool = true;
        pub const SERVO_PREF_ENABLED_grid_row: bool = true;
        pub const SERVO_PREF_ENABLED_grid_row_end: bool = true;
        pub const SERVO_PREF_ENABLED_grid_row_gap: bool = true;
        pub const SERVO_PREF_ENABLED_grid_row_start: bool = true;
        pub const SERVO_PREF_ENABLED_grid_template: bool = true;
        pub const SERVO_PREF_ENABLED_grid_template_areas: bool = true;
        pub const SERVO_PREF_ENABLED_grid_template_columns: bool = true;
        pub const SERVO_PREF_ENABLED_grid_template_rows: bool = true;
        pub const SERVO_PREF_ENABLED_height: bool = false;
        pub const SERVO_PREF_ENABLED_hyphens: bool = false;
        pub const SERVO_PREF_ENABLED_initial_letter: bool = true;
        pub const SERVO_PREF_ENABLED_image_orientation: bool = true;
        pub const SERVO_PREF_ENABLED__moz_image_region: bool = false;
        pub const SERVO_PREF_ENABLED_image_rendering: bool = false;
        pub const SERVO_PREF_ENABLED_ime_mode: bool = false;
        pub const SERVO_PREF_ENABLED_inline_size: bool = false;
        pub const SERVO_PREF_ENABLED_isolation: bool = true;
        pub const SERVO_PREF_ENABLED_justify_content: bool = false;
        pub const SERVO_PREF_ENABLED_justify_items: bool = false;
        pub const SERVO_PREF_ENABLED_justify_self: bool = false;
        pub const SERVO_PREF_ENABLED__x_lang: bool = false;
        pub const SERVO_PREF_ENABLED_left: bool = false;
        pub const SERVO_PREF_ENABLED_letter_spacing: bool = false;
        pub const SERVO_PREF_ENABLED_lighting_color: bool = false;
        pub const SERVO_PREF_ENABLED_line_height: bool = false;
        pub const SERVO_PREF_ENABLED_list_style: bool = false;
        pub const SERVO_PREF_ENABLED_list_style_image: bool = false;
        pub const SERVO_PREF_ENABLED_list_style_position: bool = false;
        pub const SERVO_PREF_ENABLED_list_style_type: bool = false;
        pub const SERVO_PREF_ENABLED_margin: bool = false;
        pub const SERVO_PREF_ENABLED_margin_block_end: bool = false;
        pub const SERVO_PREF_ENABLED_margin_block_start: bool = false;
        pub const SERVO_PREF_ENABLED_margin_bottom: bool = false;
        pub const SERVO_PREF_ENABLED_margin_inline_end: bool = false;
        pub const SERVO_PREF_ENABLED_margin_inline_start: bool = false;
        pub const SERVO_PREF_ENABLED_margin_left: bool = false;
        pub const SERVO_PREF_ENABLED_margin_right: bool = false;
        pub const SERVO_PREF_ENABLED_margin_top: bool = false;
        pub const SERVO_PREF_ENABLED_marker: bool = false;
        pub const SERVO_PREF_ENABLED_marker_end: bool = false;
        pub const SERVO_PREF_ENABLED_marker_mid: bool = false;
        pub const SERVO_PREF_ENABLED_marker_start: bool = false;
        pub const SERVO_PREF_ENABLED_mask: bool = false;
        pub const SERVO_PREF_ENABLED_mask_clip: bool = false;
        pub const SERVO_PREF_ENABLED_mask_composite: bool = false;
        pub const SERVO_PREF_ENABLED_mask_image: bool = false;
        pub const SERVO_PREF_ENABLED_mask_mode: bool = false;
        pub const SERVO_PREF_ENABLED_mask_origin: bool = false;
        pub const SERVO_PREF_ENABLED_mask_position: bool = false;
        pub const SERVO_PREF_ENABLED_mask_position_x: bool = false;
        pub const SERVO_PREF_ENABLED_mask_position_y: bool = false;
        pub const SERVO_PREF_ENABLED_mask_repeat: bool = false;
        pub const SERVO_PREF_ENABLED_mask_size: bool = false;
        pub const SERVO_PREF_ENABLED_mask_type: bool = false;
        pub const SERVO_PREF_ENABLED__moz_math_display: bool = false;
        pub const SERVO_PREF_ENABLED__moz_math_variant: bool = false;
        pub const SERVO_PREF_ENABLED_max_block_size: bool = false;
        pub const SERVO_PREF_ENABLED_max_height: bool = false;
        pub const SERVO_PREF_ENABLED_max_inline_size: bool = false;
        pub const SERVO_PREF_ENABLED_max_width: bool = false;
        pub const SERVO_PREF_ENABLED_min_block_size: bool = false;
        pub const SERVO_PREF_ENABLED__moz_min_font_size_ratio: bool = false;
        pub const SERVO_PREF_ENABLED_min_height: bool = false;
        pub const SERVO_PREF_ENABLED_min_inline_size: bool = false;
        pub const SERVO_PREF_ENABLED_min_width: bool = false;
        pub const SERVO_PREF_ENABLED_mix_blend_mode: bool = true;
        pub const SERVO_PREF_ENABLED_object_fit: bool = false;
        pub const SERVO_PREF_ENABLED_object_position: bool = false;
        pub const SERVO_PREF_ENABLED_offset_block_end: bool = false;
        pub const SERVO_PREF_ENABLED_offset_block_start: bool = false;
        pub const SERVO_PREF_ENABLED_offset_inline_end: bool = false;
        pub const SERVO_PREF_ENABLED_offset_inline_start: bool = false;
        pub const SERVO_PREF_ENABLED_opacity: bool = false;
        pub const SERVO_PREF_ENABLED_order: bool = false;
        pub const SERVO_PREF_ENABLED__moz_orient: bool = false;
        pub const SERVO_PREF_ENABLED__moz_osx_font_smoothing: bool = true;
        pub const SERVO_PREF_ENABLED_outline: bool = false;
        pub const SERVO_PREF_ENABLED_outline_color: bool = false;
        pub const SERVO_PREF_ENABLED_outline_offset: bool = false;
        pub const SERVO_PREF_ENABLED__moz_outline_radius: bool = false;
        pub const SERVO_PREF_ENABLED__moz_outline_radius_bottomleft: bool =
            false;
        pub const SERVO_PREF_ENABLED__moz_outline_radius_bottomright: bool =
            false;
        pub const SERVO_PREF_ENABLED__moz_outline_radius_topleft: bool =
            false;
        pub const SERVO_PREF_ENABLED__moz_outline_radius_topright: bool =
            false;
        pub const SERVO_PREF_ENABLED_outline_style: bool = false;
        pub const SERVO_PREF_ENABLED_outline_width: bool = false;
        pub const SERVO_PREF_ENABLED_overflow: bool = false;
        pub const SERVO_PREF_ENABLED_overflow_clip_box: bool = true;
        pub const SERVO_PREF_ENABLED_overflow_x: bool = false;
        pub const SERVO_PREF_ENABLED_overflow_y: bool = false;
        pub const SERVO_PREF_ENABLED_padding: bool = false;
        pub const SERVO_PREF_ENABLED_padding_block_end: bool = false;
        pub const SERVO_PREF_ENABLED_padding_block_start: bool = false;
        pub const SERVO_PREF_ENABLED_padding_bottom: bool = false;
        pub const SERVO_PREF_ENABLED_padding_inline_end: bool = false;
        pub const SERVO_PREF_ENABLED_padding_inline_start: bool = false;
        pub const SERVO_PREF_ENABLED_padding_left: bool = false;
        pub const SERVO_PREF_ENABLED_padding_right: bool = false;
        pub const SERVO_PREF_ENABLED_padding_top: bool = false;
        pub const SERVO_PREF_ENABLED_page_break_after: bool = false;
        pub const SERVO_PREF_ENABLED_page_break_before: bool = false;
        pub const SERVO_PREF_ENABLED_page_break_inside: bool = false;
        pub const SERVO_PREF_ENABLED_paint_order: bool = true;
        pub const SERVO_PREF_ENABLED_perspective: bool = false;
        pub const SERVO_PREF_ENABLED_perspective_origin: bool = false;
        pub const SERVO_PREF_ENABLED_place_content: bool = false;
        pub const SERVO_PREF_ENABLED_place_items: bool = false;
        pub const SERVO_PREF_ENABLED_place_self: bool = false;
        pub const SERVO_PREF_ENABLED_pointer_events: bool = false;
        pub const SERVO_PREF_ENABLED_position: bool = false;
        pub const SERVO_PREF_ENABLED_quotes: bool = false;
        pub const SERVO_PREF_ENABLED_resize: bool = false;
        pub const SERVO_PREF_ENABLED_right: bool = false;
        pub const SERVO_PREF_ENABLED_ruby_align: bool = false;
        pub const SERVO_PREF_ENABLED_ruby_position: bool = false;
        pub const SERVO_PREF_ENABLED__moz_script_level: bool = false;
        pub const SERVO_PREF_ENABLED__moz_script_min_size: bool = false;
        pub const SERVO_PREF_ENABLED__moz_script_size_multiplier: bool =
            false;
        pub const SERVO_PREF_ENABLED_scroll_behavior: bool = true;
        pub const SERVO_PREF_ENABLED_scroll_snap_coordinate: bool = true;
        pub const SERVO_PREF_ENABLED_scroll_snap_destination: bool = true;
        pub const SERVO_PREF_ENABLED_scroll_snap_points_x: bool = true;
        pub const SERVO_PREF_ENABLED_scroll_snap_points_y: bool = true;
        pub const SERVO_PREF_ENABLED_scroll_snap_type: bool = true;
        pub const SERVO_PREF_ENABLED_scroll_snap_type_x: bool = true;
        pub const SERVO_PREF_ENABLED_scroll_snap_type_y: bool = true;
        pub const SERVO_PREF_ENABLED_shape_outside: bool = true;
        pub const SERVO_PREF_ENABLED_shape_rendering: bool = false;
        pub const SERVO_PREF_ENABLED__x_span: bool = false;
        pub const SERVO_PREF_ENABLED__moz_stack_sizing: bool = false;
        pub const SERVO_PREF_ENABLED_stop_color: bool = false;
        pub const SERVO_PREF_ENABLED_stop_opacity: bool = false;
        pub const SERVO_PREF_ENABLED_stroke: bool = false;
        pub const SERVO_PREF_ENABLED_stroke_dasharray: bool = false;
        pub const SERVO_PREF_ENABLED_stroke_dashoffset: bool = false;
        pub const SERVO_PREF_ENABLED_stroke_linecap: bool = false;
        pub const SERVO_PREF_ENABLED_stroke_linejoin: bool = false;
        pub const SERVO_PREF_ENABLED_stroke_miterlimit: bool = false;
        pub const SERVO_PREF_ENABLED_stroke_opacity: bool = false;
        pub const SERVO_PREF_ENABLED_stroke_width: bool = false;
        pub const SERVO_PREF_ENABLED__x_system_font: bool = false;
        pub const SERVO_PREF_ENABLED__moz_tab_size: bool = false;
        pub const SERVO_PREF_ENABLED_table_layout: bool = false;
        pub const SERVO_PREF_ENABLED_text_align: bool = false;
        pub const SERVO_PREF_ENABLED_text_align_last: bool = false;
        pub const SERVO_PREF_ENABLED_text_anchor: bool = false;
        pub const SERVO_PREF_ENABLED_text_combine_upright: bool = true;
        pub const SERVO_PREF_ENABLED_text_decoration: bool = false;
        pub const SERVO_PREF_ENABLED_text_decoration_color: bool = false;
        pub const SERVO_PREF_ENABLED_text_decoration_line: bool = false;
        pub const SERVO_PREF_ENABLED_text_decoration_style: bool = false;
        pub const SERVO_PREF_ENABLED_text_emphasis: bool = false;
        pub const SERVO_PREF_ENABLED_text_emphasis_color: bool = false;
        pub const SERVO_PREF_ENABLED_text_emphasis_position: bool = false;
        pub const SERVO_PREF_ENABLED_text_emphasis_style: bool = false;
        pub const SERVO_PREF_ENABLED__webkit_text_fill_color: bool = true;
        pub const SERVO_PREF_ENABLED_text_indent: bool = false;
        pub const SERVO_PREF_ENABLED_text_justify: bool = true;
        pub const SERVO_PREF_ENABLED_text_orientation: bool = false;
        pub const SERVO_PREF_ENABLED_text_overflow: bool = false;
        pub const SERVO_PREF_ENABLED_text_rendering: bool = false;
        pub const SERVO_PREF_ENABLED_text_shadow: bool = false;
        pub const SERVO_PREF_ENABLED__moz_text_size_adjust: bool = false;
        pub const SERVO_PREF_ENABLED__webkit_text_stroke: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_text_stroke_color: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_text_stroke_width: bool = true;
        pub const SERVO_PREF_ENABLED_text_transform: bool = false;
        pub const SERVO_PREF_ENABLED__x_text_zoom: bool = false;
        pub const SERVO_PREF_ENABLED_top: bool = false;
        pub const SERVO_PREF_ENABLED__moz_top_layer: bool = false;
        pub const SERVO_PREF_ENABLED_touch_action: bool = true;
        pub const SERVO_PREF_ENABLED_transform: bool = false;
        pub const SERVO_PREF_ENABLED__moz_transform: bool = true;
        pub const SERVO_PREF_ENABLED_transform_box: bool = true;
        pub const SERVO_PREF_ENABLED_transform_origin: bool = false;
        pub const SERVO_PREF_ENABLED_transform_style: bool = false;
        pub const SERVO_PREF_ENABLED_transition: bool = false;
        pub const SERVO_PREF_ENABLED_transition_delay: bool = false;
        pub const SERVO_PREF_ENABLED_transition_duration: bool = false;
        pub const SERVO_PREF_ENABLED_transition_property: bool = false;
        pub const SERVO_PREF_ENABLED_transition_timing_function: bool = false;
        pub const SERVO_PREF_ENABLED_unicode_bidi: bool = false;
        pub const SERVO_PREF_ENABLED__moz_user_focus: bool = false;
        pub const SERVO_PREF_ENABLED__moz_user_input: bool = false;
        pub const SERVO_PREF_ENABLED__moz_user_modify: bool = false;
        pub const SERVO_PREF_ENABLED__moz_user_select: bool = false;
        pub const SERVO_PREF_ENABLED_vector_effect: bool = false;
        pub const SERVO_PREF_ENABLED_vertical_align: bool = false;
        pub const SERVO_PREF_ENABLED_visibility: bool = false;
        pub const SERVO_PREF_ENABLED_white_space: bool = false;
        pub const SERVO_PREF_ENABLED_width: bool = false;
        pub const SERVO_PREF_ENABLED_will_change: bool = false;
        pub const SERVO_PREF_ENABLED__moz_window_dragging: bool = false;
        pub const SERVO_PREF_ENABLED__moz_window_shadow: bool = false;
        pub const SERVO_PREF_ENABLED__moz_window_opacity: bool = false;
        pub const SERVO_PREF_ENABLED__moz_window_transform: bool = false;
        pub const SERVO_PREF_ENABLED__moz_window_transform_origin: bool =
            false;
        pub const SERVO_PREF_ENABLED_word_break: bool = false;
        pub const SERVO_PREF_ENABLED_word_spacing: bool = false;
        pub const SERVO_PREF_ENABLED_overflow_wrap: bool = false;
        pub const SERVO_PREF_ENABLED_writing_mode: bool = false;
        pub const SERVO_PREF_ENABLED_z_index: bool = false;
        pub const SERVO_PREF_ENABLED_word_wrap: bool = false;
        pub const SERVO_PREF_ENABLED__moz_transform_origin: bool = true;
        pub const SERVO_PREF_ENABLED__moz_perspective_origin: bool = true;
        pub const SERVO_PREF_ENABLED__moz_perspective: bool = true;
        pub const SERVO_PREF_ENABLED__moz_transform_style: bool = true;
        pub const SERVO_PREF_ENABLED__moz_backface_visibility: bool = true;
        pub const SERVO_PREF_ENABLED__moz_border_image: bool = true;
        pub const SERVO_PREF_ENABLED__moz_transition: bool = true;
        pub const SERVO_PREF_ENABLED__moz_transition_delay: bool = true;
        pub const SERVO_PREF_ENABLED__moz_transition_duration: bool = true;
        pub const SERVO_PREF_ENABLED__moz_transition_property: bool = true;
        pub const SERVO_PREF_ENABLED__moz_transition_timing_function: bool =
            true;
        pub const SERVO_PREF_ENABLED__moz_animation: bool = true;
        pub const SERVO_PREF_ENABLED__moz_animation_delay: bool = true;
        pub const SERVO_PREF_ENABLED__moz_animation_direction: bool = true;
        pub const SERVO_PREF_ENABLED__moz_animation_duration: bool = true;
        pub const SERVO_PREF_ENABLED__moz_animation_fill_mode: bool = true;
        pub const SERVO_PREF_ENABLED__moz_animation_iteration_count: bool =
            true;
        pub const SERVO_PREF_ENABLED__moz_animation_name: bool = true;
        pub const SERVO_PREF_ENABLED__moz_animation_play_state: bool = true;
        pub const SERVO_PREF_ENABLED__moz_animation_timing_function: bool =
            true;
        pub const SERVO_PREF_ENABLED__moz_box_sizing: bool = true;
        pub const SERVO_PREF_ENABLED__moz_font_feature_settings: bool = true;
        pub const SERVO_PREF_ENABLED__moz_font_language_override: bool = true;
        pub const SERVO_PREF_ENABLED__moz_padding_end: bool = false;
        pub const SERVO_PREF_ENABLED__moz_padding_start: bool = false;
        pub const SERVO_PREF_ENABLED__moz_margin_end: bool = false;
        pub const SERVO_PREF_ENABLED__moz_margin_start: bool = false;
        pub const SERVO_PREF_ENABLED__moz_border_end: bool = false;
        pub const SERVO_PREF_ENABLED__moz_border_end_color: bool = false;
        pub const SERVO_PREF_ENABLED__moz_border_end_style: bool = false;
        pub const SERVO_PREF_ENABLED__moz_border_end_width: bool = false;
        pub const SERVO_PREF_ENABLED__moz_border_start: bool = false;
        pub const SERVO_PREF_ENABLED__moz_border_start_color: bool = false;
        pub const SERVO_PREF_ENABLED__moz_border_start_style: bool = false;
        pub const SERVO_PREF_ENABLED__moz_border_start_width: bool = false;
        pub const SERVO_PREF_ENABLED__moz_hyphens: bool = false;
        pub const SERVO_PREF_ENABLED__moz_column_count: bool = false;
        pub const SERVO_PREF_ENABLED__moz_column_fill: bool = false;
        pub const SERVO_PREF_ENABLED__moz_column_gap: bool = false;
        pub const SERVO_PREF_ENABLED__moz_column_rule: bool = false;
        pub const SERVO_PREF_ENABLED__moz_column_rule_color: bool = false;
        pub const SERVO_PREF_ENABLED__moz_column_rule_style: bool = false;
        pub const SERVO_PREF_ENABLED__moz_column_rule_width: bool = false;
        pub const SERVO_PREF_ENABLED__moz_column_width: bool = false;
        pub const SERVO_PREF_ENABLED__moz_columns: bool = false;
        pub const SERVO_PREF_ENABLED__webkit_animation: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_animation_delay: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_animation_direction: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_animation_duration: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_animation_fill_mode: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_animation_iteration_count: bool =
            true;
        pub const SERVO_PREF_ENABLED__webkit_animation_name: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_animation_play_state: bool =
            true;
        pub const SERVO_PREF_ENABLED__webkit_animation_timing_function: bool =
            true;
        pub const SERVO_PREF_ENABLED__webkit_filter: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_text_size_adjust: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_transform: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_transform_origin: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_transform_style: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_backface_visibility: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_perspective: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_perspective_origin: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_transition: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_transition_delay: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_transition_duration: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_transition_property: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_transition_timing_function: bool
                  =
            true;
        pub const SERVO_PREF_ENABLED__webkit_border_radius: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_border_top_left_radius: bool =
            true;
        pub const SERVO_PREF_ENABLED__webkit_border_top_right_radius: bool =
            true;
        pub const SERVO_PREF_ENABLED__webkit_border_bottom_left_radius: bool =
            true;
        pub const SERVO_PREF_ENABLED__webkit_border_bottom_right_radius: bool
                  =
            true;
        pub const SERVO_PREF_ENABLED__webkit_background_clip: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_background_origin: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_background_size: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_border_image: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_box_shadow: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_box_sizing: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_box_flex: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_box_ordinal_group: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_box_orient: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_box_direction: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_box_align: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_box_pack: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_flex_direction: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_flex_wrap: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_flex_flow: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_order: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_flex: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_flex_grow: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_flex_shrink: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_flex_basis: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_justify_content: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_align_items: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_align_self: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_align_content: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_user_select: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_mask: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_mask_clip: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_mask_composite: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_mask_image: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_mask_origin: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_mask_position: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_mask_position_x: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_mask_position_y: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_mask_repeat: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_mask_size: bool = true;
        /// This class holds all non-tree-structural state of an element that might be
        /// used for selector matching eventually.
        ///
        /// This means the attributes, and the element state, such as :hover, :active,
        /// etc...
        #[repr(C)]
        #[derive(Debug)]
        pub struct ServoElementSnapshot {
            pub mAttrs: root::nsTArray<root::mozilla::ServoAttrSnapshot>,
            pub mClass: root::nsAttrValue,
            pub mState: root::mozilla::ServoElementSnapshot_ServoStateType,
            pub mContains: root::mozilla::ServoElementSnapshot_Flags,
            pub _bitfield_1: u8,
            pub __bindgen_padding_0: [u16; 3usize],
        }
        pub type ServoElementSnapshot_BorrowedAttrInfo =
            root::mozilla::dom::BorrowedAttrInfo;
        pub type ServoElementSnapshot_Element = root::mozilla::dom::Element;
        pub type ServoElementSnapshot_ServoStateType =
            root::mozilla::EventStates_ServoType;
        pub use self::super::super::root::mozilla::ServoElementSnapshotFlags
                as ServoElementSnapshot_Flags;
        #[test]
        fn bindgen_test_layout_ServoElementSnapshot() {
            assert_eq!(::std::mem::size_of::<ServoElementSnapshot>() , 32usize
                       , concat ! (
                       "Size of: " , stringify ! ( ServoElementSnapshot ) ));
            assert_eq! (::std::mem::align_of::<ServoElementSnapshot>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! ( ServoElementSnapshot )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoElementSnapshot ) ) . mAttrs
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoElementSnapshot ) , "::" , stringify ! ( mAttrs )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoElementSnapshot ) ) . mClass
                        as * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoElementSnapshot ) , "::" , stringify ! ( mClass )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoElementSnapshot ) ) . mState
                        as * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoElementSnapshot ) , "::" , stringify ! ( mState )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoElementSnapshot ) ) .
                        mContains as * const _ as usize } , 24usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        ServoElementSnapshot ) , "::" , stringify ! (
                        mContains ) ));
        }
        impl ServoElementSnapshot {
            #[inline]
            pub fn mIsHTMLElementInHTMLDocument(&self) -> bool {
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                let mask = 1u64 as u8;
                let val = (unit_field_val & mask) >> 0usize;
                unsafe { ::std::mem::transmute(val as u8) }
            }
            #[inline]
            pub fn set_mIsHTMLElementInHTMLDocument(&mut self, val: bool) {
                let mask = 1u64 as u8;
                let val = val as u8 as u8;
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                unit_field_val &= !mask;
                unit_field_val |= (val << 0usize) & mask;
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                        *const _ as *const u8,
                                                    &mut self._bitfield_1 as
                                                        *mut _ as *mut u8,
                                                    ::std::mem::size_of::<u8>());
                }
            }
            #[inline]
            pub fn mIsInChromeDocument(&self) -> bool {
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                let mask = 2u64 as u8;
                let val = (unit_field_val & mask) >> 1usize;
                unsafe { ::std::mem::transmute(val as u8) }
            }
            #[inline]
            pub fn set_mIsInChromeDocument(&mut self, val: bool) {
                let mask = 2u64 as u8;
                let val = val as u8 as u8;
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                unit_field_val &= !mask;
                unit_field_val |= (val << 1usize) & mask;
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                        *const _ as *const u8,
                                                    &mut self._bitfield_1 as
                                                        *mut _ as *mut u8,
                                                    ::std::mem::size_of::<u8>());
                }
            }
            #[inline]
            pub fn mSupportsLangAttr(&self) -> bool {
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                let mask = 4u64 as u8;
                let val = (unit_field_val & mask) >> 2usize;
                unsafe { ::std::mem::transmute(val as u8) }
            }
            #[inline]
            pub fn set_mSupportsLangAttr(&mut self, val: bool) {
                let mask = 4u64 as u8;
                let val = val as u8 as u8;
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                unit_field_val &= !mask;
                unit_field_val |= (val << 2usize) & mask;
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                        *const _ as *const u8,
                                                    &mut self._bitfield_1 as
                                                        *mut _ as *mut u8,
                                                    ::std::mem::size_of::<u8>());
                }
            }
            #[inline]
            pub fn mIsTableBorderNonzero(&self) -> bool {
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                let mask = 8u64 as u8;
                let val = (unit_field_val & mask) >> 3usize;
                unsafe { ::std::mem::transmute(val as u8) }
            }
            #[inline]
            pub fn set_mIsTableBorderNonzero(&mut self, val: bool) {
                let mask = 8u64 as u8;
                let val = val as u8 as u8;
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                unit_field_val &= !mask;
                unit_field_val |= (val << 3usize) & mask;
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                        *const _ as *const u8,
                                                    &mut self._bitfield_1 as
                                                        *mut _ as *mut u8,
                                                    ::std::mem::size_of::<u8>());
                }
            }
            #[inline]
            pub fn mIsMozBrowserFrame(&self) -> bool {
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                let mask = 16u64 as u8;
                let val = (unit_field_val & mask) >> 4usize;
                unsafe { ::std::mem::transmute(val as u8) }
            }
            #[inline]
            pub fn set_mIsMozBrowserFrame(&mut self, val: bool) {
                let mask = 16u64 as u8;
                let val = val as u8 as u8;
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                unit_field_val &= !mask;
                unit_field_val |= (val << 4usize) & mask;
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                        *const _ as *const u8,
                                                    &mut self._bitfield_1 as
                                                        *mut _ as *mut u8,
                                                    ::std::mem::size_of::<u8>());
                }
            }
            #[inline]
            pub fn mClassAttributeChanged(&self) -> bool {
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                let mask = 32u64 as u8;
                let val = (unit_field_val & mask) >> 5usize;
                unsafe { ::std::mem::transmute(val as u8) }
            }
            #[inline]
            pub fn set_mClassAttributeChanged(&mut self, val: bool) {
                let mask = 32u64 as u8;
                let val = val as u8 as u8;
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                unit_field_val &= !mask;
                unit_field_val |= (val << 5usize) & mask;
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                        *const _ as *const u8,
                                                    &mut self._bitfield_1 as
                                                        *mut _ as *mut u8,
                                                    ::std::mem::size_of::<u8>());
                }
            }
            #[inline]
            pub fn mIdAttributeChanged(&self) -> bool {
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                let mask = 64u64 as u8;
                let val = (unit_field_val & mask) >> 6usize;
                unsafe { ::std::mem::transmute(val as u8) }
            }
            #[inline]
            pub fn set_mIdAttributeChanged(&mut self, val: bool) {
                let mask = 64u64 as u8;
                let val = val as u8 as u8;
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                unit_field_val &= !mask;
                unit_field_val |= (val << 6usize) & mask;
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                        *const _ as *const u8,
                                                    &mut self._bitfield_1 as
                                                        *mut _ as *mut u8,
                                                    ::std::mem::size_of::<u8>());
                }
            }
            #[inline]
            pub fn mOtherAttributeChanged(&self) -> bool {
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                let mask = 128u64 as u8;
                let val = (unit_field_val & mask) >> 7usize;
                unsafe { ::std::mem::transmute(val as u8) }
            }
            #[inline]
            pub fn set_mOtherAttributeChanged(&mut self, val: bool) {
                let mask = 128u64 as u8;
                let val = val as u8 as u8;
                let mut unit_field_val: u8 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u8 as *mut u8,
                                                    ::std::mem::size_of::<u8>())
                };
                unit_field_val &= !mask;
                unit_field_val |= (val << 7usize) & mask;
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                        *const _ as *const u8,
                                                    &mut self._bitfield_1 as
                                                        *mut _ as *mut u8,
                                                    ::std::mem::size_of::<u8>());
                }
            }
            #[inline]
            pub fn new_bitfield_1(mIsHTMLElementInHTMLDocument: bool,
                                  mIsInChromeDocument: bool,
                                  mSupportsLangAttr: bool,
                                  mIsTableBorderNonzero: bool,
                                  mIsMozBrowserFrame: bool,
                                  mClassAttributeChanged: bool,
                                  mIdAttributeChanged: bool,
                                  mOtherAttributeChanged: bool) -> u8 {
                ({
                     ({
                          ({
                               ({
                                    ({
                                         ({
                                              ({
                                                   ({ 0 } |
                                                        ((mIsHTMLElementInHTMLDocument
                                                              as u8 as u8) <<
                                                             0usize) &
                                                            (1u64 as u8))
                                               } |
                                                   ((mIsInChromeDocument as u8
                                                         as u8) << 1usize) &
                                                       (2u64 as u8))
                                          } |
                                              ((mSupportsLangAttr as u8 as u8)
                                                   << 2usize) & (4u64 as u8))
                                     } |
                                         ((mIsTableBorderNonzero as u8 as u8)
                                              << 3usize) & (8u64 as u8))
                                } |
                                    ((mIsMozBrowserFrame as u8 as u8) <<
                                         4usize) & (16u64 as u8))
                           } |
                               ((mClassAttributeChanged as u8 as u8) <<
                                    5usize) & (32u64 as u8))
                      } |
                          ((mIdAttributeChanged as u8 as u8) << 6usize) &
                              (64u64 as u8))
                 } |
                     ((mOtherAttributeChanged as u8 as u8) << 7usize) &
                         (128u64 as u8))
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AnimationPropertySegment {
            pub mFromKey: f32,
            pub mToKey: f32,
            pub mFromValue: root::mozilla::AnimationValue,
            pub mToValue: root::mozilla::AnimationValue,
            pub mTimingFunction: [u64; 18usize],
            pub mFromComposite: root::mozilla::dom::CompositeOperation,
            pub mToComposite: root::mozilla::dom::CompositeOperation,
        }
        #[test]
        fn bindgen_test_layout_AnimationPropertySegment() {
            assert_eq!(::std::mem::size_of::<AnimationPropertySegment>() ,
                       208usize , concat ! (
                       "Size of: " , stringify ! ( AnimationPropertySegment )
                       ));
            assert_eq! (::std::mem::align_of::<AnimationPropertySegment>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! (
                        AnimationPropertySegment ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnimationPropertySegment ) ) .
                        mFromKey as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        AnimationPropertySegment ) , "::" , stringify ! (
                        mFromKey ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnimationPropertySegment ) ) .
                        mToKey as * const _ as usize } , 4usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        AnimationPropertySegment ) , "::" , stringify ! (
                        mToKey ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnimationPropertySegment ) ) .
                        mFromValue as * const _ as usize } , 8usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        AnimationPropertySegment ) , "::" , stringify ! (
                        mFromValue ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnimationPropertySegment ) ) .
                        mToValue as * const _ as usize } , 32usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        AnimationPropertySegment ) , "::" , stringify ! (
                        mToValue ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnimationPropertySegment ) ) .
                        mTimingFunction as * const _ as usize } , 56usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        AnimationPropertySegment ) , "::" , stringify ! (
                        mTimingFunction ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnimationPropertySegment ) ) .
                        mFromComposite as * const _ as usize } , 200usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        AnimationPropertySegment ) , "::" , stringify ! (
                        mFromComposite ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnimationPropertySegment ) ) .
                        mToComposite as * const _ as usize } , 201usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        AnimationPropertySegment ) , "::" , stringify ! (
                        mToComposite ) ));
        }
        /// Stores the results of calculating the timing properties of an animation
        /// at a given sample time.
        #[repr(C)]
        #[derive(Debug)]
        pub struct ComputedTiming {
            pub mActiveDuration: root::mozilla::StickyTimeDuration,
            pub mActiveTime: root::mozilla::StickyTimeDuration,
            pub mEndTime: root::mozilla::StickyTimeDuration,
            pub mProgress: [u64; 2usize],
            pub mCurrentIteration: u64,
            pub mIterations: f64,
            pub mIterationStart: f64,
            pub mDuration: root::mozilla::StickyTimeDuration,
            pub mFill: root::mozilla::dom::FillMode,
            pub mPhase: root::mozilla::ComputedTiming_AnimationPhase,
            pub mBeforeFlag: root::mozilla::ComputedTimingFunction_BeforeFlag,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ComputedTiming_AnimationPhase {
            Idle = 0,
            Before = 1,
            Active = 2,
            After = 3,
        }
        #[test]
        fn bindgen_test_layout_ComputedTiming() {
            assert_eq!(::std::mem::size_of::<ComputedTiming>() , 88usize ,
                       concat ! ( "Size of: " , stringify ! ( ComputedTiming )
                       ));
            assert_eq! (::std::mem::align_of::<ComputedTiming>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ComputedTiming ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTiming ) ) .
                        mActiveDuration as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ComputedTiming
                        ) , "::" , stringify ! ( mActiveDuration ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTiming ) ) . mActiveTime
                        as * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( ComputedTiming
                        ) , "::" , stringify ! ( mActiveTime ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTiming ) ) . mEndTime as
                        * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! ( ComputedTiming
                        ) , "::" , stringify ! ( mEndTime ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTiming ) ) . mProgress as
                        * const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! ( ComputedTiming
                        ) , "::" , stringify ! ( mProgress ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTiming ) ) .
                        mCurrentIteration as * const _ as usize } , 40usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ComputedTiming
                        ) , "::" , stringify ! ( mCurrentIteration ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTiming ) ) . mIterations
                        as * const _ as usize } , 48usize , concat ! (
                        "Alignment of field: " , stringify ! ( ComputedTiming
                        ) , "::" , stringify ! ( mIterations ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTiming ) ) .
                        mIterationStart as * const _ as usize } , 56usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ComputedTiming
                        ) , "::" , stringify ! ( mIterationStart ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTiming ) ) . mDuration as
                        * const _ as usize } , 64usize , concat ! (
                        "Alignment of field: " , stringify ! ( ComputedTiming
                        ) , "::" , stringify ! ( mDuration ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTiming ) ) . mFill as *
                        const _ as usize } , 72usize , concat ! (
                        "Alignment of field: " , stringify ! ( ComputedTiming
                        ) , "::" , stringify ! ( mFill ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTiming ) ) . mPhase as *
                        const _ as usize } , 76usize , concat ! (
                        "Alignment of field: " , stringify ! ( ComputedTiming
                        ) , "::" , stringify ! ( mPhase ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTiming ) ) . mBeforeFlag
                        as * const _ as usize } , 80usize , concat ! (
                        "Alignment of field: " , stringify ! ( ComputedTiming
                        ) , "::" , stringify ! ( mBeforeFlag ) ));
        }
        /// A single keyframe.
        ///
        /// This is the canonical form in which keyframe effects are stored and
        /// corresponds closely to the type of objects returned via the getKeyframes()
        /// API.
        ///
        /// Before computing an output animation value, however, we flatten these frames
        /// down to a series of per-property value arrays where we also resolve any
        /// overlapping shorthands/longhands, convert specified CSS values to computed
        /// values, etc.
        ///
        /// When the target element or style context changes, however, we rebuild these
        /// per-property arrays from the original list of keyframes objects. As a result,
        /// these objects represent the master definition of the effect's values.
        #[repr(C)]
        #[derive(Debug)]
        pub struct Keyframe {
            pub mOffset: [u64; 2usize],
            pub mComputedOffset: f64,
            pub mTimingFunction: [u64; 18usize],
            pub mComposite: [u8; 2usize],
            pub mPropertyValues: root::nsTArray<root::mozilla::PropertyValuePair>,
        }
        pub const Keyframe_kComputedOffsetNotSet: f64 = -1.;
        #[test]
        fn bindgen_test_layout_Keyframe() {
            assert_eq!(::std::mem::size_of::<Keyframe>() , 184usize , concat !
                       ( "Size of: " , stringify ! ( Keyframe ) ));
            assert_eq! (::std::mem::align_of::<Keyframe>() , 8usize , concat !
                        ( "Alignment of " , stringify ! ( Keyframe ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Keyframe ) ) . mOffset as * const
                        _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Keyframe ) ,
                        "::" , stringify ! ( mOffset ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Keyframe ) ) . mComputedOffset as
                        * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! ( Keyframe ) ,
                        "::" , stringify ! ( mComputedOffset ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Keyframe ) ) . mTimingFunction as
                        * const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! ( Keyframe ) ,
                        "::" , stringify ! ( mTimingFunction ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Keyframe ) ) . mComposite as *
                        const _ as usize } , 168usize , concat ! (
                        "Alignment of field: " , stringify ! ( Keyframe ) ,
                        "::" , stringify ! ( mComposite ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Keyframe ) ) . mPropertyValues as
                        * const _ as usize } , 176usize , concat ! (
                        "Alignment of field: " , stringify ! ( Keyframe ) ,
                        "::" , stringify ! ( mPropertyValues ) ));
        }
        /// A property-value pair specified on a keyframe.
        #[repr(C)]
        #[derive(Debug)]
        pub struct PropertyValuePair {
            pub mProperty: root::nsCSSPropertyID,
            pub mValue: root::nsCSSValue,
            pub mServoDeclarationBlock: root::RefPtr<root::RawServoDeclarationBlock>,
            pub mSimulateComputeValuesFailure: bool,
        }
        #[test]
        fn bindgen_test_layout_PropertyValuePair() {
            assert_eq!(::std::mem::size_of::<PropertyValuePair>() , 40usize ,
                       concat ! (
                       "Size of: " , stringify ! ( PropertyValuePair ) ));
            assert_eq! (::std::mem::align_of::<PropertyValuePair>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( PropertyValuePair )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PropertyValuePair ) ) . mProperty
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        PropertyValuePair ) , "::" , stringify ! ( mProperty )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PropertyValuePair ) ) . mValue as
                        * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        PropertyValuePair ) , "::" , stringify ! ( mValue )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PropertyValuePair ) ) .
                        mServoDeclarationBlock as * const _ as usize } ,
                        24usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        PropertyValuePair ) , "::" , stringify ! (
                        mServoDeclarationBlock ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PropertyValuePair ) ) .
                        mSimulateComputeValuesFailure as * const _ as usize }
                        , 32usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        PropertyValuePair ) , "::" , stringify ! (
                        mSimulateComputeValuesFailure ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct PropertyStyleAnimationValuePair {
            pub mProperty: root::nsCSSPropertyID,
            pub mValue: root::mozilla::AnimationValue,
        }
        #[test]
        fn bindgen_test_layout_PropertyStyleAnimationValuePair() {
            assert_eq!(::std::mem::size_of::<PropertyStyleAnimationValuePair>()
                       , 32usize , concat ! (
                       "Size of: " , stringify ! (
                       PropertyStyleAnimationValuePair ) ));
            assert_eq! (::std::mem::align_of::<PropertyStyleAnimationValuePair>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        PropertyStyleAnimationValuePair ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PropertyStyleAnimationValuePair )
                        ) . mProperty as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        PropertyStyleAnimationValuePair ) , "::" , stringify !
                        ( mProperty ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PropertyStyleAnimationValuePair )
                        ) . mValue as * const _ as usize } , 8usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        PropertyStyleAnimationValuePair ) , "::" , stringify !
                        ( mValue ) ));
        }
        pub const OriginFlags_UserAgent: root::mozilla::OriginFlags =
            OriginFlags(1);
        pub const OriginFlags_User: root::mozilla::OriginFlags =
            OriginFlags(2);
        pub const OriginFlags_Author: root::mozilla::OriginFlags =
            OriginFlags(4);
        pub const OriginFlags_All: root::mozilla::OriginFlags =
            OriginFlags(7);
        impl ::std::ops::BitOr<root::mozilla::OriginFlags> for
         root::mozilla::OriginFlags {
            type
            Output
            =
            Self;
            #[inline]
            fn bitor(self, other: Self) -> Self {
                OriginFlags(self.0 | other.0)
            }
        }
        impl ::std::ops::BitOrAssign for root::mozilla::OriginFlags {
            #[inline]
            fn bitor_assign(&mut self, rhs: root::mozilla::OriginFlags) {
                self.0 |= rhs.0;
            }
        }
        impl ::std::ops::BitAnd<root::mozilla::OriginFlags> for
         root::mozilla::OriginFlags {
            type
            Output
            =
            Self;
            #[inline]
            fn bitand(self, other: Self) -> Self {
                OriginFlags(self.0 & other.0)
            }
        }
        impl ::std::ops::BitAndAssign for root::mozilla::OriginFlags {
            #[inline]
            fn bitand_assign(&mut self, rhs: root::mozilla::OriginFlags) {
                self.0 &= rhs.0;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub struct OriginFlags(pub u8);
        pub type ComputedKeyframeValues =
            root::nsTArray<root::mozilla::PropertyStyleAnimationValuePair>;
        #[test]
        fn __bindgen_test_layout_DefaultDelete_open0_RawServoStyleSet_close0_instantiation() {
            assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                       1usize , concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::mozilla::DefaultDelete ) ));
            assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>()
                       , 1usize , concat ! (
                       "Alignment of template specialization: " , stringify !
                       ( root::mozilla::DefaultDelete ) ));
        }
        /// Utility class to handle animated style values
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleAnimationValue {
            pub _bindgen_opaque_blob: [u64; 2usize],
        }
        #[repr(u32)]
        /// The types and values for the values that we extract and animate.
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleAnimationValue_Unit {
            eUnit_Null = 0,
            eUnit_Normal = 1,
            eUnit_Auto = 2,
            eUnit_None = 3,
            eUnit_Enumerated = 4,
            eUnit_Visibility = 5,
            eUnit_Integer = 6,
            eUnit_Coord = 7,
            eUnit_Percent = 8,
            eUnit_Float = 9,
            eUnit_Color = 10,
            eUnit_CurrentColor = 11,
            eUnit_ComplexColor = 12,
            eUnit_Calc = 13,
            eUnit_ObjectPosition = 14,
            eUnit_URL = 15,
            eUnit_DiscreteCSSValue = 16,
            eUnit_CSSValuePair = 17,
            eUnit_CSSValueTriplet = 18,
            eUnit_CSSRect = 19,
            eUnit_Dasharray = 20,
            eUnit_Shadow = 21,
            eUnit_Shape = 22,
            eUnit_Filter = 23,
            eUnit_Transform = 24,
            eUnit_BackgroundPositionCoord = 25,
            eUnit_CSSValuePairList = 26,
            eUnit_UnparsedString = 27,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleAnimationValue__bindgen_ty_1 {
            pub mInt: root::__BindgenUnionField<i32>,
            pub mCoord: root::__BindgenUnionField<root::nscoord>,
            pub mFloat: root::__BindgenUnionField<f32>,
            pub mCSSValue: root::__BindgenUnionField<*mut root::nsCSSValue>,
            pub mCSSValuePair: root::__BindgenUnionField<*mut root::nsCSSValuePair>,
            pub mCSSValueTriplet: root::__BindgenUnionField<*mut root::nsCSSValueTriplet>,
            pub mCSSRect: root::__BindgenUnionField<*mut root::nsCSSRect>,
            pub mCSSValueArray: root::__BindgenUnionField<*mut root::nsCSSValue_Array>,
            pub mCSSValueList: root::__BindgenUnionField<*mut root::nsCSSValueList>,
            pub mCSSValueSharedList: root::__BindgenUnionField<*mut root::nsCSSValueSharedList>,
            pub mCSSValuePairList: root::__BindgenUnionField<*mut root::nsCSSValuePairList>,
            pub mString: root::__BindgenUnionField<*mut root::nsStringBuffer>,
            pub mComplexColor: root::__BindgenUnionField<*mut root::mozilla::css::ComplexColorValue>,
            pub bindgen_union_field: u64,
        }
        #[test]
        fn bindgen_test_layout_StyleAnimationValue__bindgen_ty_1() {
            assert_eq!(::std::mem::size_of::<StyleAnimationValue__bindgen_ty_1>()
                       , 8usize , concat ! (
                       "Size of: " , stringify ! (
                       StyleAnimationValue__bindgen_ty_1 ) ));
            assert_eq! (::std::mem::align_of::<StyleAnimationValue__bindgen_ty_1>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mInt as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mInt ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCoord as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCoord ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mFloat as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mFloat ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSValue as * const _ as usize } , 0usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSValue ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSValuePair as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSValuePair ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSValueTriplet as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSValueTriplet ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSRect as * const _ as usize } , 0usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSRect ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSValueArray as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSValueArray ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSValueList as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSValueList ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSValueSharedList as * const _ as usize } , 0usize
                        , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSValueSharedList ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSValuePairList as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSValuePairList ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mString as * const _ as usize } , 0usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mString ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mComplexColor as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mComplexColor ) ));
        }
        impl Clone for StyleAnimationValue__bindgen_ty_1 {
            fn clone(&self) -> Self { *self }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleAnimationValue_IntegerConstructorType {
            IntegerConstructor = 0,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleAnimationValue_CoordConstructorType {
            CoordConstructor = 0,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleAnimationValue_PercentConstructorType {
            PercentConstructor = 0,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleAnimationValue_FloatConstructorType {
            FloatConstructor = 0,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleAnimationValue_ColorConstructorType {
            ColorConstructor = 0,
        }
        #[test]
        fn bindgen_test_layout_StyleAnimationValue() {
            assert_eq!(::std::mem::size_of::<StyleAnimationValue>() , 16usize
                       , concat ! (
                       "Size of: " , stringify ! ( StyleAnimationValue ) ));
            assert_eq! (::std::mem::align_of::<StyleAnimationValue>() , 8usize
                        , concat ! (
                        "Alignment of " , stringify ! ( StyleAnimationValue )
                        ));
        }
        impl Clone for StyleAnimationValue {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AnimationValue {
            pub mGecko: root::mozilla::StyleAnimationValue,
            pub mServo: root::RefPtr<root::RawServoAnimationValue>,
        }
        #[test]
        fn bindgen_test_layout_AnimationValue() {
            assert_eq!(::std::mem::size_of::<AnimationValue>() , 24usize ,
                       concat ! ( "Size of: " , stringify ! ( AnimationValue )
                       ));
            assert_eq! (::std::mem::align_of::<AnimationValue>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( AnimationValue ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnimationValue ) ) . mGecko as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( AnimationValue
                        ) , "::" , stringify ! ( mGecko ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnimationValue ) ) . mServo as *
                        const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! ( AnimationValue
                        ) , "::" , stringify ! ( mServo ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ServoCSSRuleList {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ServoStyleSheetInner {
            pub _base: root::mozilla::StyleSheetInfo,
            pub mContents: root::RefPtr<root::RawServoStyleSheetContents>,
            pub mURLData: root::RefPtr<root::mozilla::URLExtraData>,
        }
        #[test]
        fn bindgen_test_layout_ServoStyleSheetInner() {
            assert_eq!(::std::mem::size_of::<ServoStyleSheetInner>() ,
                       232usize , concat ! (
                       "Size of: " , stringify ! ( ServoStyleSheetInner ) ));
            assert_eq! (::std::mem::align_of::<ServoStyleSheetInner>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! ( ServoStyleSheetInner )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoStyleSheetInner ) ) .
                        mContents as * const _ as usize } , 216usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        ServoStyleSheetInner ) , "::" , stringify ! (
                        mContents ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoStyleSheetInner ) ) .
                        mURLData as * const _ as usize } , 224usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        ServoStyleSheetInner ) , "::" , stringify ! ( mURLData
                        ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct URIPrincipalReferrerPolicyAndCORSModeHashKey {
            pub _base: root::nsURIHashKey,
            pub mPrincipal: root::nsCOMPtr<root::nsIPrincipal>,
            pub mCORSMode: root::mozilla::CORSMode,
            pub mReferrerPolicy: root::mozilla::URIPrincipalReferrerPolicyAndCORSModeHashKey_ReferrerPolicy,
        }
        pub type URIPrincipalReferrerPolicyAndCORSModeHashKey_KeyType =
            *mut root::mozilla::URIPrincipalReferrerPolicyAndCORSModeHashKey;
        pub type URIPrincipalReferrerPolicyAndCORSModeHashKey_KeyTypePointer =
            *const root::mozilla::URIPrincipalReferrerPolicyAndCORSModeHashKey;
        pub use self::super::super::root::mozilla::net::ReferrerPolicy as
                URIPrincipalReferrerPolicyAndCORSModeHashKey_ReferrerPolicy;
        pub const URIPrincipalReferrerPolicyAndCORSModeHashKey_ALLOW_MEMMOVE:
                  root::mozilla::URIPrincipalReferrerPolicyAndCORSModeHashKey__bindgen_ty_1
                  =
            URIPrincipalReferrerPolicyAndCORSModeHashKey__bindgen_ty_1::ALLOW_MEMMOVE;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum URIPrincipalReferrerPolicyAndCORSModeHashKey__bindgen_ty_1 {
            ALLOW_MEMMOVE = 1,
        }
        #[test]
        fn bindgen_test_layout_URIPrincipalReferrerPolicyAndCORSModeHashKey() {
            assert_eq!(::std::mem::size_of::<URIPrincipalReferrerPolicyAndCORSModeHashKey>()
                       , 32usize , concat ! (
                       "Size of: " , stringify ! (
                       URIPrincipalReferrerPolicyAndCORSModeHashKey ) ));
            assert_eq! (::std::mem::align_of::<URIPrincipalReferrerPolicyAndCORSModeHashKey>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        URIPrincipalReferrerPolicyAndCORSModeHashKey ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const
                        URIPrincipalReferrerPolicyAndCORSModeHashKey ) ) .
                        mPrincipal as * const _ as usize } , 16usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        URIPrincipalReferrerPolicyAndCORSModeHashKey ) , "::"
                        , stringify ! ( mPrincipal ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const
                        URIPrincipalReferrerPolicyAndCORSModeHashKey ) ) .
                        mCORSMode as * const _ as usize } , 24usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        URIPrincipalReferrerPolicyAndCORSModeHashKey ) , "::"
                        , stringify ! ( mCORSMode ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const
                        URIPrincipalReferrerPolicyAndCORSModeHashKey ) ) .
                        mReferrerPolicy as * const _ as usize } , 28usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        URIPrincipalReferrerPolicyAndCORSModeHashKey ) , "::"
                        , stringify ! ( mReferrerPolicy ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ComputedTimingFunction {
            pub mType: root::nsTimingFunction_Type,
            pub mTimingFunction: root::nsSMILKeySpline,
            pub mStepsOrFrames: u32,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ComputedTimingFunction_BeforeFlag { Unset = 0, Set = 1, }
        #[test]
        fn bindgen_test_layout_ComputedTimingFunction() {
            assert_eq!(::std::mem::size_of::<ComputedTimingFunction>() ,
                       136usize , concat ! (
                       "Size of: " , stringify ! ( ComputedTimingFunction )
                       ));
            assert_eq! (::std::mem::align_of::<ComputedTimingFunction>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! ( ComputedTimingFunction
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTimingFunction ) ) .
                        mType as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ComputedTimingFunction ) , "::" , stringify ! ( mType
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTimingFunction ) ) .
                        mTimingFunction as * const _ as usize } , 8usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        ComputedTimingFunction ) , "::" , stringify ! (
                        mTimingFunction ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ComputedTimingFunction ) ) .
                        mStepsOrFrames as * const _ as usize } , 128usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        ComputedTimingFunction ) , "::" , stringify ! (
                        mStepsOrFrames ) ));
        }
        impl Clone for ComputedTimingFunction {
            fn clone(&self) -> Self { *self }
        }
        /// A ValueCalculator class that performs additional checks before performing
        /// arithmetic operations such that if either operand is Forever (or the
        /// negative equivalent) the result remains Forever (or the negative equivalent
        /// as appropriate).
        ///
        /// Currently this only checks if either argument to each operation is
        /// Forever/-Forever. However, it is possible that, for example,
        /// aA + aB > INT64_MAX (or < INT64_MIN).
        ///
        /// We currently don't check for that case since we don't expect that to
        /// happen often except under test conditions in which case the wrapping
        /// behavior is probably acceptable.
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StickyTimeDurationValueCalculator {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_StickyTimeDurationValueCalculator() {
            assert_eq!(::std::mem::size_of::<StickyTimeDurationValueCalculator>()
                       , 1usize , concat ! (
                       "Size of: " , stringify ! (
                       StickyTimeDurationValueCalculator ) ));
            assert_eq! (::std::mem::align_of::<StickyTimeDurationValueCalculator>()
                        , 1usize , concat ! (
                        "Alignment of " , stringify ! (
                        StickyTimeDurationValueCalculator ) ));
        }
        impl Clone for StickyTimeDurationValueCalculator {
            fn clone(&self) -> Self { *self }
        }
        /// Specialization of BaseTimeDuration that uses
        /// StickyTimeDurationValueCalculator for arithmetic on the mValue member.
        ///
        /// Use this class when you need a time duration that is expected to hold values
        /// of Forever (or the negative equivalent) *and* when you expect that
        /// time duration to be used in arithmetic operations (and not just value
        /// comparisons).
        pub type StickyTimeDuration = root::mozilla::BaseTimeDuration;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DeclarationBlock {
            _unused: [u8; 0],
        }
        /// A structure representing a single attribute name and value.
        ///
        /// This is pretty similar to the private nsAttrAndChildArray::InternalAttr.
        #[repr(C)]
        #[derive(Debug)]
        pub struct ServoAttrSnapshot {
            pub mName: root::nsAttrName,
            pub mValue: root::nsAttrValue,
        }
        #[test]
        fn bindgen_test_layout_ServoAttrSnapshot() {
            assert_eq!(::std::mem::size_of::<ServoAttrSnapshot>() , 16usize ,
                       concat ! (
                       "Size of: " , stringify ! ( ServoAttrSnapshot ) ));
            assert_eq! (::std::mem::align_of::<ServoAttrSnapshot>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ServoAttrSnapshot )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoAttrSnapshot ) ) . mName as
                        * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoAttrSnapshot ) , "::" , stringify ! ( mName ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoAttrSnapshot ) ) . mValue as
                        * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoAttrSnapshot ) , "::" , stringify ! ( mValue )
                        ));
        }
        #[repr(u8)]
        /// A bitflags enum class used to determine what data does a ServoElementSnapshot
        /// contains.
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ServoElementSnapshotFlags {
            State = 1,
            Attributes = 2,
            Id = 4,
            MaybeClass = 8,
            OtherPseudoClassState = 16,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct NonOwningAnimationTarget {
            pub mElement: *mut root::mozilla::dom::Element,
            pub mPseudoType: root::mozilla::CSSPseudoElementType,
        }
        #[test]
        fn bindgen_test_layout_NonOwningAnimationTarget() {
            assert_eq!(::std::mem::size_of::<NonOwningAnimationTarget>() ,
                       16usize , concat ! (
                       "Size of: " , stringify ! ( NonOwningAnimationTarget )
                       ));
            assert_eq! (::std::mem::align_of::<NonOwningAnimationTarget>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! (
                        NonOwningAnimationTarget ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const NonOwningAnimationTarget ) ) .
                        mElement as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        NonOwningAnimationTarget ) , "::" , stringify ! (
                        mElement ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const NonOwningAnimationTarget ) ) .
                        mPseudoType as * const _ as usize } , 8usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        NonOwningAnimationTarget ) , "::" , stringify ! (
                        mPseudoType ) ));
        }
        impl Clone for NonOwningAnimationTarget {
            fn clone(&self) -> Self { *self }
        }
        pub mod wr {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct WrComplexClipRegion {
                _unused: [u8; 0],
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct DisplayItemClip_RoundedRect {
            pub mRect: root::nsRect,
            pub mRadii: [root::nscoord; 8usize],
        }
        #[test]
        fn bindgen_test_layout_DisplayItemClip_RoundedRect() {
            assert_eq!(::std::mem::size_of::<DisplayItemClip_RoundedRect>() ,
                       48usize , concat ! (
                       "Size of: " , stringify ! ( DisplayItemClip_RoundedRect
                       ) ));
            assert_eq! (::std::mem::align_of::<DisplayItemClip_RoundedRect>()
                        , 4usize , concat ! (
                        "Alignment of " , stringify ! (
                        DisplayItemClip_RoundedRect ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const DisplayItemClip_RoundedRect ) ) .
                        mRect as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        DisplayItemClip_RoundedRect ) , "::" , stringify ! (
                        mRect ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const DisplayItemClip_RoundedRect ) ) .
                        mRadii as * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        DisplayItemClip_RoundedRect ) , "::" , stringify ! (
                        mRadii ) ));
        }
        impl Clone for DisplayItemClip_RoundedRect {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ServoElementSnapshotTable {
            pub _base: [u64; 6usize],
        }
        #[test]
        fn bindgen_test_layout_ServoElementSnapshotTable() {
            assert_eq!(::std::mem::size_of::<ServoElementSnapshotTable>() ,
                       48usize , concat ! (
                       "Size of: " , stringify ! ( ServoElementSnapshotTable )
                       ));
            assert_eq! (::std::mem::align_of::<ServoElementSnapshotTable>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! (
                        ServoElementSnapshotTable ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct LookAndFeel {
            pub _address: u8,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LookAndFeel_ColorID {
            eColorID_WindowBackground = 0,
            eColorID_WindowForeground = 1,
            eColorID_WidgetBackground = 2,
            eColorID_WidgetForeground = 3,
            eColorID_WidgetSelectBackground = 4,
            eColorID_WidgetSelectForeground = 5,
            eColorID_Widget3DHighlight = 6,
            eColorID_Widget3DShadow = 7,
            eColorID_TextBackground = 8,
            eColorID_TextForeground = 9,
            eColorID_TextSelectBackground = 10,
            eColorID_TextSelectForeground = 11,
            eColorID_TextSelectForegroundCustom = 12,
            eColorID_TextSelectBackgroundDisabled = 13,
            eColorID_TextSelectBackgroundAttention = 14,
            eColorID_TextHighlightBackground = 15,
            eColorID_TextHighlightForeground = 16,
            eColorID_IMERawInputBackground = 17,
            eColorID_IMERawInputForeground = 18,
            eColorID_IMERawInputUnderline = 19,
            eColorID_IMESelectedRawTextBackground = 20,
            eColorID_IMESelectedRawTextForeground = 21,
            eColorID_IMESelectedRawTextUnderline = 22,
            eColorID_IMEConvertedTextBackground = 23,
            eColorID_IMEConvertedTextForeground = 24,
            eColorID_IMEConvertedTextUnderline = 25,
            eColorID_IMESelectedConvertedTextBackground = 26,
            eColorID_IMESelectedConvertedTextForeground = 27,
            eColorID_IMESelectedConvertedTextUnderline = 28,
            eColorID_SpellCheckerUnderline = 29,
            eColorID_activeborder = 30,
            eColorID_activecaption = 31,
            eColorID_appworkspace = 32,
            eColorID_background = 33,
            eColorID_buttonface = 34,
            eColorID_buttonhighlight = 35,
            eColorID_buttonshadow = 36,
            eColorID_buttontext = 37,
            eColorID_captiontext = 38,
            eColorID_graytext = 39,
            eColorID_highlight = 40,
            eColorID_highlighttext = 41,
            eColorID_inactiveborder = 42,
            eColorID_inactivecaption = 43,
            eColorID_inactivecaptiontext = 44,
            eColorID_infobackground = 45,
            eColorID_infotext = 46,
            eColorID_menu = 47,
            eColorID_menutext = 48,
            eColorID_scrollbar = 49,
            eColorID_threeddarkshadow = 50,
            eColorID_threedface = 51,
            eColorID_threedhighlight = 52,
            eColorID_threedlightshadow = 53,
            eColorID_threedshadow = 54,
            eColorID_window = 55,
            eColorID_windowframe = 56,
            eColorID_windowtext = 57,
            eColorID__moz_buttondefault = 58,
            eColorID__moz_field = 59,
            eColorID__moz_fieldtext = 60,
            eColorID__moz_dialog = 61,
            eColorID__moz_dialogtext = 62,
            eColorID__moz_dragtargetzone = 63,
            eColorID__moz_cellhighlight = 64,
            eColorID__moz_cellhighlighttext = 65,
            eColorID__moz_html_cellhighlight = 66,
            eColorID__moz_html_cellhighlighttext = 67,
            eColorID__moz_buttonhoverface = 68,
            eColorID__moz_buttonhovertext = 69,
            eColorID__moz_menuhover = 70,
            eColorID__moz_menuhovertext = 71,
            eColorID__moz_menubartext = 72,
            eColorID__moz_menubarhovertext = 73,
            eColorID__moz_eventreerow = 74,
            eColorID__moz_oddtreerow = 75,
            eColorID__moz_mac_buttonactivetext = 76,
            eColorID__moz_mac_chrome_active = 77,
            eColorID__moz_mac_chrome_inactive = 78,
            eColorID__moz_mac_defaultbuttontext = 79,
            eColorID__moz_mac_focusring = 80,
            eColorID__moz_mac_menuselect = 81,
            eColorID__moz_mac_menushadow = 82,
            eColorID__moz_mac_menutextdisable = 83,
            eColorID__moz_mac_menutextselect = 84,
            eColorID__moz_mac_disabledtoolbartext = 85,
            eColorID__moz_mac_secondaryhighlight = 86,
            eColorID__moz_win_accentcolor = 87,
            eColorID__moz_win_accentcolortext = 88,
            eColorID__moz_win_mediatext = 89,
            eColorID__moz_win_communicationstext = 90,
            eColorID__moz_nativehyperlinktext = 91,
            eColorID__moz_comboboxtext = 92,
            eColorID__moz_combobox = 93,
            eColorID__moz_gtk_info_bar_text = 94,
            eColorID_LAST_COLOR = 95,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LookAndFeel_IntID {
            eIntID_CaretBlinkTime = 0,
            eIntID_CaretWidth = 1,
            eIntID_ShowCaretDuringSelection = 2,
            eIntID_SelectTextfieldsOnKeyFocus = 3,
            eIntID_SubmenuDelay = 4,
            eIntID_MenusCanOverlapOSBar = 5,
            eIntID_UseOverlayScrollbars = 6,
            eIntID_AllowOverlayScrollbarsOverlap = 7,
            eIntID_ShowHideScrollbars = 8,
            eIntID_SkipNavigatingDisabledMenuItem = 9,
            eIntID_DragThresholdX = 10,
            eIntID_DragThresholdY = 11,
            eIntID_UseAccessibilityTheme = 12,
            eIntID_ScrollArrowStyle = 13,
            eIntID_ScrollSliderStyle = 14,
            eIntID_ScrollButtonLeftMouseButtonAction = 15,
            eIntID_ScrollButtonMiddleMouseButtonAction = 16,
            eIntID_ScrollButtonRightMouseButtonAction = 17,
            eIntID_TreeOpenDelay = 18,
            eIntID_TreeCloseDelay = 19,
            eIntID_TreeLazyScrollDelay = 20,
            eIntID_TreeScrollDelay = 21,
            eIntID_TreeScrollLinesMax = 22,
            eIntID_TabFocusModel = 23,
            eIntID_ChosenMenuItemsShouldBlink = 24,
            eIntID_WindowsAccentColorInTitlebar = 25,
            eIntID_WindowsDefaultTheme = 26,
            eIntID_DWMCompositor = 27,
            eIntID_WindowsClassic = 28,
            eIntID_WindowsGlass = 29,
            eIntID_TouchEnabled = 30,
            eIntID_MacGraphiteTheme = 31,
            eIntID_MacYosemiteTheme = 32,
            eIntID_AlertNotificationOrigin = 33,
            eIntID_ScrollToClick = 34,
            eIntID_IMERawInputUnderlineStyle = 35,
            eIntID_IMESelectedRawTextUnderlineStyle = 36,
            eIntID_IMEConvertedTextUnderlineStyle = 37,
            eIntID_IMESelectedConvertedTextUnderline = 38,
            eIntID_SpellCheckerUnderlineStyle = 39,
            eIntID_MenuBarDrag = 40,
            eIntID_WindowsThemeIdentifier = 41,
            eIntID_OperatingSystemVersionIdentifier = 42,
            eIntID_ScrollbarButtonAutoRepeatBehavior = 43,
            eIntID_TooltipDelay = 44,
            eIntID_SwipeAnimationEnabled = 45,
            eIntID_ColorPickerAvailable = 46,
            eIntID_PhysicalHomeButton = 47,
            eIntID_ScrollbarDisplayOnMouseMove = 48,
            eIntID_ScrollbarFadeBeginDelay = 49,
            eIntID_ScrollbarFadeDuration = 50,
            eIntID_ContextMenuOffsetVertical = 51,
            eIntID_ContextMenuOffsetHorizontal = 52,
        }
        #[repr(u32)]
        /// Windows themes we currently detect.
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LookAndFeel_WindowsTheme {
            eWindowsTheme_Generic = 0,
            eWindowsTheme_Classic = 1,
            eWindowsTheme_Aero = 2,
            eWindowsTheme_LunaBlue = 3,
            eWindowsTheme_LunaOlive = 4,
            eWindowsTheme_LunaSilver = 5,
            eWindowsTheme_Royale = 6,
            eWindowsTheme_Zune = 7,
            eWindowsTheme_AeroLite = 8,
        }
        #[repr(u32)]
        /// Operating system versions.
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LookAndFeel_OperatingSystemVersion {
            eOperatingSystemVersion_Windows7 = 2,
            eOperatingSystemVersion_Windows8 = 3,
            eOperatingSystemVersion_Windows10 = 4,
            eOperatingSystemVersion_Unknown = 5,
        }
        pub const LookAndFeel_eScrollArrow_None:
                  root::mozilla::LookAndFeel__bindgen_ty_1 =
            LookAndFeel__bindgen_ty_1::eScrollArrow_None;
        pub const LookAndFeel_eScrollArrow_StartBackward:
                  root::mozilla::LookAndFeel__bindgen_ty_1 =
            LookAndFeel__bindgen_ty_1::eScrollArrow_StartBackward;
        pub const LookAndFeel_eScrollArrow_StartForward:
                  root::mozilla::LookAndFeel__bindgen_ty_1 =
            LookAndFeel__bindgen_ty_1::eScrollArrow_StartForward;
        pub const LookAndFeel_eScrollArrow_EndBackward:
                  root::mozilla::LookAndFeel__bindgen_ty_1 =
            LookAndFeel__bindgen_ty_1::eScrollArrow_EndBackward;
        pub const LookAndFeel_eScrollArrow_EndForward:
                  root::mozilla::LookAndFeel__bindgen_ty_1 =
            LookAndFeel__bindgen_ty_1::eScrollArrow_EndForward;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LookAndFeel__bindgen_ty_1 {
            eScrollArrow_None = 0,
            eScrollArrow_StartBackward = 4096,
            eScrollArrow_StartForward = 256,
            eScrollArrow_EndBackward = 16,
            eScrollArrow_EndForward = 1,
        }
        pub const LookAndFeel_eScrollArrowStyle_Single:
                  root::mozilla::LookAndFeel__bindgen_ty_2 =
            LookAndFeel__bindgen_ty_2::eScrollArrowStyle_Single;
        pub const LookAndFeel_eScrollArrowStyle_BothAtBottom:
                  root::mozilla::LookAndFeel__bindgen_ty_2 =
            LookAndFeel__bindgen_ty_2::eScrollArrowStyle_BothAtBottom;
        pub const LookAndFeel_eScrollArrowStyle_BothAtEachEnd:
                  root::mozilla::LookAndFeel__bindgen_ty_2 =
            LookAndFeel__bindgen_ty_2::eScrollArrowStyle_BothAtEachEnd;
        pub const LookAndFeel_eScrollArrowStyle_BothAtTop:
                  root::mozilla::LookAndFeel__bindgen_ty_2 =
            LookAndFeel__bindgen_ty_2::eScrollArrowStyle_BothAtTop;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LookAndFeel__bindgen_ty_2 {
            eScrollArrowStyle_Single = 4097,
            eScrollArrowStyle_BothAtBottom = 17,
            eScrollArrowStyle_BothAtEachEnd = 4369,
            eScrollArrowStyle_BothAtTop = 4352,
        }
        pub const LookAndFeel_eScrollThumbStyle_Normal:
                  root::mozilla::LookAndFeel__bindgen_ty_3 =
            LookAndFeel__bindgen_ty_3::eScrollThumbStyle_Normal;
        pub const LookAndFeel_eScrollThumbStyle_Proportional:
                  root::mozilla::LookAndFeel__bindgen_ty_3 =
            LookAndFeel__bindgen_ty_3::eScrollThumbStyle_Proportional;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LookAndFeel__bindgen_ty_3 {
            eScrollThumbStyle_Normal = 0,
            eScrollThumbStyle_Proportional = 1,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LookAndFeel_FloatID {
            eFloatID_IMEUnderlineRelativeSize = 0,
            eFloatID_SpellCheckerUnderlineRelativeSize = 1,
            eFloatID_CaretAspectRatio = 2,
        }
        pub const LookAndFeel_FontID_FontID_MINIMUM:
                  root::mozilla::LookAndFeel_FontID =
            LookAndFeel_FontID::eFont_Caption;
        pub const LookAndFeel_FontID_FontID_MAXIMUM:
                  root::mozilla::LookAndFeel_FontID =
            LookAndFeel_FontID::eFont_Widget;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LookAndFeel_FontID {
            eFont_Caption = 1,
            eFont_Icon = 2,
            eFont_Menu = 3,
            eFont_MessageBox = 4,
            eFont_SmallCaption = 5,
            eFont_StatusBar = 6,
            eFont_Window = 7,
            eFont_Document = 8,
            eFont_Workspace = 9,
            eFont_Desktop = 10,
            eFont_Info = 11,
            eFont_Dialog = 12,
            eFont_Button = 13,
            eFont_PullDownMenu = 14,
            eFont_List = 15,
            eFont_Field = 16,
            eFont_Tooltips = 17,
            eFont_Widget = 18,
        }
        #[test]
        fn bindgen_test_layout_LookAndFeel() {
            assert_eq!(::std::mem::size_of::<LookAndFeel>() , 1usize , concat
                       ! ( "Size of: " , stringify ! ( LookAndFeel ) ));
            assert_eq! (::std::mem::align_of::<LookAndFeel>() , 1usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( LookAndFeel ) ));
        }
        impl Clone for LookAndFeel {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StylePrefs {
            pub _address: u8,
        }
        extern "C" {
            #[link_name = "_ZN7mozilla10StylePrefs19sFontDisplayEnabledE"]
            pub static mut StylePrefs_sFontDisplayEnabled: bool;
        }
        extern "C" {
            #[link_name = "_ZN7mozilla10StylePrefs19sOpentypeSVGEnabledE"]
            pub static mut StylePrefs_sOpentypeSVGEnabled: bool;
        }
        extern "C" {
            #[link_name =
                  "_ZN7mozilla10StylePrefs29sWebkitPrefixedAliasesEnabledE"]
            pub static mut StylePrefs_sWebkitPrefixedAliasesEnabled: bool;
        }
        extern "C" {
            #[link_name =
                  "_ZN7mozilla10StylePrefs30sWebkitDevicePixelRatioEnabledE"]
            pub static mut StylePrefs_sWebkitDevicePixelRatioEnabled: bool;
        }
        extern "C" {
            #[link_name = "_ZN7mozilla10StylePrefs20sMozGradientsEnabledE"]
            pub static mut StylePrefs_sMozGradientsEnabled: bool;
        }
        extern "C" {
            #[link_name = "_ZN7mozilla10StylePrefs22sControlCharVisibilityE"]
            pub static mut StylePrefs_sControlCharVisibility: bool;
        }
        extern "C" {
            #[link_name =
                  "_ZN7mozilla10StylePrefs28sFramesTimingFunctionEnabledE"]
            pub static mut StylePrefs_sFramesTimingFunctionEnabled: bool;
        }
        extern "C" {
            #[link_name =
                  "_ZN7mozilla10StylePrefs31sUnprefixedFullscreenApiEnabledE"]
            pub static mut StylePrefs_sUnprefixedFullscreenApiEnabled: bool;
        }
        #[test]
        fn bindgen_test_layout_StylePrefs() {
            assert_eq!(::std::mem::size_of::<StylePrefs>() , 1usize , concat !
                       ( "Size of: " , stringify ! ( StylePrefs ) ));
            assert_eq! (::std::mem::align_of::<StylePrefs>() , 1usize , concat
                        ! ( "Alignment of " , stringify ! ( StylePrefs ) ));
        }
        impl Clone for StylePrefs {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct PseudoElementHashEntry {
            pub _base: root::PLDHashEntryHdr,
            pub mElement: root::RefPtr<root::mozilla::dom::Element>,
            pub mPseudoType: root::mozilla::CSSPseudoElementType,
        }
        pub type PseudoElementHashEntry_KeyType =
            root::mozilla::NonOwningAnimationTarget;
        pub type PseudoElementHashEntry_KeyTypePointer =
            *const root::mozilla::NonOwningAnimationTarget;
        pub const PseudoElementHashEntry_ALLOW_MEMMOVE:
                  root::mozilla::PseudoElementHashEntry__bindgen_ty_1 =
            PseudoElementHashEntry__bindgen_ty_1::ALLOW_MEMMOVE;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum PseudoElementHashEntry__bindgen_ty_1 { ALLOW_MEMMOVE = 1, }
        #[test]
        fn bindgen_test_layout_PseudoElementHashEntry() {
            assert_eq!(::std::mem::size_of::<PseudoElementHashEntry>() ,
                       24usize , concat ! (
                       "Size of: " , stringify ! ( PseudoElementHashEntry )
                       ));
            assert_eq! (::std::mem::align_of::<PseudoElementHashEntry>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! ( PseudoElementHashEntry
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PseudoElementHashEntry ) ) .
                        mElement as * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        PseudoElementHashEntry ) , "::" , stringify ! (
                        mElement ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PseudoElementHashEntry ) ) .
                        mPseudoType as * const _ as usize } , 16usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        PseudoElementHashEntry ) , "::" , stringify ! (
                        mPseudoType ) ));
        }
        pub type CSSPseudoClassTypeBase = u8;
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum CSSPseudoClassType {
            empty = 0,
            mozOnlyWhitespace = 1,
            mozEmptyExceptChildrenWithLocalname = 2,
            lang = 3,
            root = 4,
            any = 5,
            firstChild = 6,
            firstNode = 7,
            lastChild = 8,
            lastNode = 9,
            onlyChild = 10,
            firstOfType = 11,
            lastOfType = 12,
            onlyOfType = 13,
            nthChild = 14,
            nthLastChild = 15,
            nthOfType = 16,
            nthLastOfType = 17,
            mozIsHTML = 18,
            unresolved = 19,
            mozNativeAnonymous = 20,
            mozUseShadowTreeRoot = 21,
            mozSystemMetric = 22,
            mozLocaleDir = 23,
            mozLWTheme = 24,
            mozLWThemeBrightText = 25,
            mozLWThemeDarkText = 26,
            mozWindowInactive = 27,
            mozTableBorderNonzero = 28,
            mozBrowserFrame = 29,
            scope = 30,
            negation = 31,
            dir = 32,
            link = 33,
            mozAnyLink = 34,
            anyLink = 35,
            visited = 36,
            active = 37,
            checked = 38,
            disabled = 39,
            enabled = 40,
            focus = 41,
            focusWithin = 42,
            hover = 43,
            mozDragOver = 44,
            target = 45,
            indeterminate = 46,
            mozDevtoolsHighlighted = 47,
            mozStyleeditorTransitioning = 48,
            fullscreen = 49,
            mozFullScreen = 50,
            mozFocusRing = 51,
            mozBroken = 52,
            mozLoading = 53,
            mozUserDisabled = 54,
            mozSuppressed = 55,
            mozHandlerClickToPlay = 56,
            mozHandlerVulnerableUpdatable = 57,
            mozHandlerVulnerableNoUpdate = 58,
            mozHandlerDisabled = 59,
            mozHandlerBlocked = 60,
            mozHandlerCrashed = 61,
            mozMathIncrementScriptLevel = 62,
            mozHasDirAttr = 63,
            mozDirAttrLTR = 64,
            mozDirAttrRTL = 65,
            mozDirAttrLikeAuto = 66,
            mozAutofill = 67,
            mozAutofillPreview = 68,
            required = 69,
            optional = 70,
            valid = 71,
            invalid = 72,
            inRange = 73,
            outOfRange = 74,
            defaultPseudo = 75,
            placeholderShown = 76,
            mozReadOnly = 77,
            mozReadWrite = 78,
            mozSubmitInvalid = 79,
            mozUIInvalid = 80,
            mozUIValid = 81,
            mozMeterOptimum = 82,
            mozMeterSubOptimum = 83,
            mozMeterSubSubOptimum = 84,
            mozPlaceholder = 85,
            Count = 86,
            NotPseudo = 87,
            MAX = 88,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ServoMediaList {
            pub _base: root::mozilla::dom::MediaList,
            pub mRawList: root::RefPtr<root::RawServoMediaList>,
        }
        #[test]
        fn bindgen_test_layout_ServoMediaList() {
            assert_eq!(::std::mem::size_of::<ServoMediaList>() , 64usize ,
                       concat ! ( "Size of: " , stringify ! ( ServoMediaList )
                       ));
            assert_eq! (::std::mem::align_of::<ServoMediaList>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ServoMediaList ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoMediaList ) ) . mRawList as
                        * const _ as usize } , 56usize , concat ! (
                        "Alignment of field: " , stringify ! ( ServoMediaList
                        ) , "::" , stringify ! ( mRawList ) ));
        }
        /// A PostTraversalTask is a task to be performed immediately after a Servo
        /// traversal.  There are just a few tasks we need to perform, so we use this
        /// class rather than Runnables, to avoid virtual calls and some allocations.
        ///
        /// A PostTraversalTask is only safe to run immediately after the Servo
        /// traversal, since it can hold raw pointers to DOM objects.
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct PostTraversalTask {
            pub mType: root::mozilla::PostTraversalTask_Type,
            pub mTarget: *mut ::std::os::raw::c_void,
            pub mResult: root::nsresult,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum PostTraversalTask_Type {
            ResolveFontFaceLoadedPromise = 0,
            RejectFontFaceLoadedPromise = 1,
            DispatchLoadingEventAndReplaceReadyPromise = 2,
            DispatchFontFaceSetCheckLoadingFinishedAfterDelay = 3,
            LoadFontEntry = 4,
        }
        #[test]
        fn bindgen_test_layout_PostTraversalTask() {
            assert_eq!(::std::mem::size_of::<PostTraversalTask>() , 24usize ,
                       concat ! (
                       "Size of: " , stringify ! ( PostTraversalTask ) ));
            assert_eq! (::std::mem::align_of::<PostTraversalTask>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( PostTraversalTask )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PostTraversalTask ) ) . mType as
                        * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        PostTraversalTask ) , "::" , stringify ! ( mType ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PostTraversalTask ) ) . mTarget
                        as * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        PostTraversalTask ) , "::" , stringify ! ( mTarget )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PostTraversalTask ) ) . mResult
                        as * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        PostTraversalTask ) , "::" , stringify ! ( mResult )
                        ));
        }
        impl Clone for PostTraversalTask {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct CSSFontFaceDescriptors {
            pub mFamily: root::nsCSSValue,
            pub mStyle: root::nsCSSValue,
            pub mWeight: root::nsCSSValue,
            pub mStretch: root::nsCSSValue,
            pub mSrc: root::nsCSSValue,
            pub mUnicodeRange: root::nsCSSValue,
            pub mFontFeatureSettings: root::nsCSSValue,
            pub mFontLanguageOverride: root::nsCSSValue,
            pub mDisplay: root::nsCSSValue,
        }
        extern "C" {
            #[link_name = "_ZN7mozilla22CSSFontFaceDescriptors6FieldsE"]
            pub static mut CSSFontFaceDescriptors_Fields:
                       [*const root::nsCSSValue; 0usize];
        }
        #[test]
        fn bindgen_test_layout_CSSFontFaceDescriptors() {
            assert_eq!(::std::mem::size_of::<CSSFontFaceDescriptors>() ,
                       144usize , concat ! (
                       "Size of: " , stringify ! ( CSSFontFaceDescriptors )
                       ));
            assert_eq! (::std::mem::align_of::<CSSFontFaceDescriptors>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! ( CSSFontFaceDescriptors
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSFontFaceDescriptors ) ) .
                        mFamily as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        CSSFontFaceDescriptors ) , "::" , stringify ! (
                        mFamily ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSFontFaceDescriptors ) ) .
                        mStyle as * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        CSSFontFaceDescriptors ) , "::" , stringify ! ( mStyle
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSFontFaceDescriptors ) ) .
                        mWeight as * const _ as usize } , 32usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        CSSFontFaceDescriptors ) , "::" , stringify ! (
                        mWeight ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSFontFaceDescriptors ) ) .
                        mStretch as * const _ as usize } , 48usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        CSSFontFaceDescriptors ) , "::" , stringify ! (
                        mStretch ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSFontFaceDescriptors ) ) . mSrc
                        as * const _ as usize } , 64usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        CSSFontFaceDescriptors ) , "::" , stringify ! ( mSrc )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSFontFaceDescriptors ) ) .
                        mUnicodeRange as * const _ as usize } , 80usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        CSSFontFaceDescriptors ) , "::" , stringify ! (
                        mUnicodeRange ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSFontFaceDescriptors ) ) .
                        mFontFeatureSettings as * const _ as usize } , 96usize
                        , concat ! (
                        "Alignment of field: " , stringify ! (
                        CSSFontFaceDescriptors ) , "::" , stringify ! (
                        mFontFeatureSettings ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSFontFaceDescriptors ) ) .
                        mFontLanguageOverride as * const _ as usize } ,
                        112usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        CSSFontFaceDescriptors ) , "::" , stringify ! (
                        mFontLanguageOverride ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSFontFaceDescriptors ) ) .
                        mDisplay as * const _ as usize } , 128usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        CSSFontFaceDescriptors ) , "::" , stringify ! (
                        mDisplay ) ));
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct InfallibleAllocPolicy {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_InfallibleAllocPolicy() {
        assert_eq!(::std::mem::size_of::<InfallibleAllocPolicy>() , 1usize ,
                   concat ! (
                   "Size of: " , stringify ! ( InfallibleAllocPolicy ) ));
        assert_eq! (::std::mem::align_of::<InfallibleAllocPolicy>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( InfallibleAllocPolicy )
                    ));
    }
    impl Clone for InfallibleAllocPolicy {
        fn clone(&self) -> Self { *self }
    }
    /// MozRefCountType is Mozilla's reference count type.
    ///
    /// We use the same type to represent the refcount of RefCounted objects
    /// as well, in order to be able to use the leak detection facilities
    /// that are implemented by XPCOM.
    ///
    /// Note that this type is not in the mozilla namespace so that it is
    /// usable for both C and C++ code.
    pub type MozRefCountType = usize;
    pub const nsresult_NS_ERROR_NO_INTERFACE: root::nsresult =
        nsresult::NS_NOINTERFACE;
    pub const nsresult_NS_ERROR_INVALID_ARG: root::nsresult =
        nsresult::NS_ERROR_ILLEGAL_VALUE;
    pub const nsresult_NS_ERROR_INVALID_POINTER: root::nsresult =
        nsresult::NS_ERROR_ILLEGAL_VALUE;
    pub const nsresult_NS_ERROR_NULL_POINTER: root::nsresult =
        nsresult::NS_ERROR_ILLEGAL_VALUE;
    pub const nsresult_NS_BINDING_SUCCEEDED: root::nsresult = nsresult::NS_OK;
    pub const nsresult_NS_NET_STATUS_RESOLVING_HOST: root::nsresult =
        nsresult::NS_BINDING_REDIRECTED;
    pub const nsresult_NS_NET_STATUS_RESOLVED_HOST: root::nsresult =
        nsresult::NS_ERROR_ALREADY_CONNECTED;
    pub const nsresult_NS_NET_STATUS_CONNECTED_TO: root::nsresult =
        nsresult::NS_BINDING_RETARGETED;
    pub const nsresult_NS_NET_STATUS_TLS_HANDSHAKE_STARTING: root::nsresult =
        nsresult::NS_ERROR_NOT_CONNECTED;
    pub const nsresult_NS_NET_STATUS_TLS_HANDSHAKE_ENDED: root::nsresult =
        nsresult::NS_ERROR_CONNECTION_REFUSED;
    pub const nsresult_NS_NET_STATUS_WAITING_FOR: root::nsresult =
        nsresult::NS_ERROR_MALFORMED_URI;
    pub const nsresult_NS_STATE_PROPERTY_EXISTS: root::nsresult =
        nsresult::NS_OK;
    pub const nsresult_NS_ERROR_HTMLPARSER_CONTINUE: root::nsresult =
        nsresult::NS_OK;
    pub const nsresult_NS_RDF_ASSERTION_ACCEPTED: root::nsresult =
        nsresult::NS_OK;
    pub const nsresult_NS_EXACT_LENGTH: root::nsresult =
        nsresult::NS_OK_UDEC_EXACTLENGTH;
    pub const nsresult_NS_PARTIAL_MORE_INPUT: root::nsresult =
        nsresult::NS_OK_UDEC_MOREINPUT;
    pub const nsresult_NS_PARTIAL_MORE_OUTPUT: root::nsresult =
        nsresult::NS_OK_UDEC_MOREOUTPUT;
    pub const nsresult_NS_ERROR_ILLEGAL_INPUT: root::nsresult =
        nsresult::NS_ERROR_UDEC_ILLEGALINPUT;
    pub const nsresult_NS_ERROR_XPATH_INVALID_ARG: root::nsresult =
        nsresult::NS_ERROR_ILLEGAL_VALUE;
    pub const nsresult_NS_SUCCESS_RESTART_APP: root::nsresult =
        nsresult::NS_SUCCESS_DONT_FIXUP;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsresult {
        NS_OK = 0,
        NS_ERROR_BASE = 3253927936,
        NS_ERROR_NOT_INITIALIZED = 3253927937,
        NS_ERROR_ALREADY_INITIALIZED = 3253927938,
        NS_ERROR_NOT_IMPLEMENTED = 2147500033,
        NS_NOINTERFACE = 2147500034,
        NS_ERROR_ABORT = 2147500036,
        NS_ERROR_FAILURE = 2147500037,
        NS_ERROR_UNEXPECTED = 2147549183,
        NS_ERROR_OUT_OF_MEMORY = 2147942414,
        NS_ERROR_ILLEGAL_VALUE = 2147942487,
        NS_ERROR_NO_AGGREGATION = 2147746064,
        NS_ERROR_NOT_AVAILABLE = 2147746065,
        NS_ERROR_FACTORY_NOT_REGISTERED = 2147746132,
        NS_ERROR_FACTORY_REGISTER_AGAIN = 2147746133,
        NS_ERROR_FACTORY_NOT_LOADED = 2147746296,
        NS_ERROR_FACTORY_NO_SIGNATURE_SUPPORT = 3253928193,
        NS_ERROR_FACTORY_EXISTS = 3253928192,
        NS_ERROR_CANNOT_CONVERT_DATA = 2152071169,
        NS_ERROR_OBJECT_IS_IMMUTABLE = 2152071170,
        NS_ERROR_LOSS_OF_SIGNIFICANT_DATA = 2152071171,
        NS_ERROR_NOT_SAME_THREAD = 2152071172,
        NS_ERROR_ILLEGAL_DURING_SHUTDOWN = 2152071198,
        NS_ERROR_SERVICE_NOT_AVAILABLE = 2152071190,
        NS_SUCCESS_LOSS_OF_INSIGNIFICANT_DATA = 4587521,
        NS_SUCCESS_INTERRUPTED_TRAVERSE = 4587522,
        NS_ERROR_SERVICE_NOT_FOUND = 4587542,
        NS_ERROR_SERVICE_IN_USE = 4587543,
        NS_BASE_STREAM_CLOSED = 2152136706,
        NS_BASE_STREAM_OSERROR = 2152136707,
        NS_BASE_STREAM_ILLEGAL_ARGS = 2152136708,
        NS_BASE_STREAM_NO_CONVERTER = 2152136709,
        NS_BASE_STREAM_BAD_CONVERSION = 2152136710,
        NS_BASE_STREAM_WOULD_BLOCK = 2152136711,
        NS_ERROR_GFX_PRINTER_NO_PRINTER_AVAILABLE = 2152202241,
        NS_ERROR_GFX_PRINTER_NAME_NOT_FOUND = 2152202242,
        NS_ERROR_GFX_PRINTER_COULD_NOT_OPEN_FILE = 2152202243,
        NS_ERROR_GFX_PRINTER_STARTDOC = 2152202244,
        NS_ERROR_GFX_PRINTER_ENDDOC = 2152202245,
        NS_ERROR_GFX_PRINTER_STARTPAGE = 2152202246,
        NS_ERROR_GFX_PRINTER_DOC_IS_BUSY = 2152202247,
        NS_ERROR_GFX_CMAP_MALFORMED = 2152202291,
        NS_SUCCESS_EVENT_CONSUMED = 4784129,
        NS_SUCCESS_EVENT_HANDLED_ASYNCHRONOUSLY = 4784130,
        NS_BINDING_FAILED = 2152398849,
        NS_BINDING_ABORTED = 2152398850,
        NS_BINDING_REDIRECTED = 2152398851,
        NS_BINDING_RETARGETED = 2152398852,
        NS_ERROR_MALFORMED_URI = 2152398858,
        NS_ERROR_IN_PROGRESS = 2152398863,
        NS_ERROR_NO_CONTENT = 2152398865,
        NS_ERROR_UNKNOWN_PROTOCOL = 2152398866,
        NS_ERROR_INVALID_CONTENT_ENCODING = 2152398875,
        NS_ERROR_CORRUPTED_CONTENT = 2152398877,
        NS_ERROR_INVALID_SIGNATURE = 2152398906,
        NS_ERROR_FIRST_HEADER_FIELD_COMPONENT_EMPTY = 2152398882,
        NS_ERROR_ALREADY_OPENED = 2152398921,
        NS_ERROR_ALREADY_CONNECTED = 2152398859,
        NS_ERROR_NOT_CONNECTED = 2152398860,
        NS_ERROR_CONNECTION_REFUSED = 2152398861,
        NS_ERROR_NET_TIMEOUT = 2152398862,
        NS_ERROR_OFFLINE = 2152398864,
        NS_ERROR_PORT_ACCESS_NOT_ALLOWED = 2152398867,
        NS_ERROR_NET_RESET = 2152398868,
        NS_ERROR_NET_INTERRUPT = 2152398919,
        NS_ERROR_PROXY_CONNECTION_REFUSED = 2152398920,
        NS_ERROR_NET_PARTIAL_TRANSFER = 2152398924,
        NS_ERROR_NET_INADEQUATE_SECURITY = 2152398930,
        NS_ERROR_NOT_RESUMABLE = 2152398873,
        NS_ERROR_REDIRECT_LOOP = 2152398879,
        NS_ERROR_ENTITY_CHANGED = 2152398880,
        NS_ERROR_UNSAFE_CONTENT_TYPE = 2152398922,
        NS_ERROR_REMOTE_XUL = 2152398923,
        NS_ERROR_LOAD_SHOWED_ERRORPAGE = 2152398925,
        NS_ERROR_DOCSHELL_DYING = 2152398926,
        NS_ERROR_FTP_LOGIN = 2152398869,
        NS_ERROR_FTP_CWD = 2152398870,
        NS_ERROR_FTP_PASV = 2152398871,
        NS_ERROR_FTP_PWD = 2152398872,
        NS_ERROR_FTP_LIST = 2152398876,
        NS_ERROR_UNKNOWN_HOST = 2152398878,
        NS_ERROR_DNS_LOOKUP_QUEUE_FULL = 2152398881,
        NS_ERROR_UNKNOWN_PROXY_HOST = 2152398890,
        NS_ERROR_UNKNOWN_SOCKET_TYPE = 2152398899,
        NS_ERROR_SOCKET_CREATE_FAILED = 2152398900,
        NS_ERROR_SOCKET_ADDRESS_NOT_SUPPORTED = 2152398901,
        NS_ERROR_SOCKET_ADDRESS_IN_USE = 2152398902,
        NS_ERROR_CACHE_KEY_NOT_FOUND = 2152398909,
        NS_ERROR_CACHE_DATA_IS_STREAM = 2152398910,
        NS_ERROR_CACHE_DATA_IS_NOT_STREAM = 2152398911,
        NS_ERROR_CACHE_WAIT_FOR_VALIDATION = 2152398912,
        NS_ERROR_CACHE_ENTRY_DOOMED = 2152398913,
        NS_ERROR_CACHE_READ_ACCESS_DENIED = 2152398914,
        NS_ERROR_CACHE_WRITE_ACCESS_DENIED = 2152398915,
        NS_ERROR_CACHE_IN_USE = 2152398916,
        NS_ERROR_DOCUMENT_NOT_CACHED = 2152398918,
        NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS = 2152398928,
        NS_ERROR_HOST_IS_IP_ADDRESS = 2152398929,
        NS_SUCCESS_ADOPTED_DATA = 4915290,
        NS_NET_STATUS_BEGIN_FTP_TRANSACTION = 4915227,
        NS_NET_STATUS_END_FTP_TRANSACTION = 4915228,
        NS_SUCCESS_AUTH_FINISHED = 4915240,
        NS_NET_STATUS_READING = 2152398856,
        NS_NET_STATUS_WRITING = 2152398857,
        NS_NET_STATUS_CONNECTING_TO = 2152398855,
        NS_NET_STATUS_SENDING_TO = 2152398853,
        NS_NET_STATUS_RECEIVING_FROM = 2152398854,
        NS_ERROR_INTERCEPTION_FAILED = 2152398948,
        NS_ERROR_HSTS_PRIMING_TIMEOUT = 2152398958,
        NS_ERROR_PLUGINS_PLUGINSNOTCHANGED = 2152465384,
        NS_ERROR_PLUGIN_DISABLED = 2152465385,
        NS_ERROR_PLUGIN_BLOCKLISTED = 2152465386,
        NS_ERROR_PLUGIN_TIME_RANGE_NOT_SUPPORTED = 2152465387,
        NS_ERROR_PLUGIN_CLICKTOPLAY = 2152465388,
        NS_TABLELAYOUT_CELL_NOT_FOUND = 5046272,
        NS_OK_PARSE_SHEET = 5046273,
        NS_POSITION_BEFORE_TABLE = 5046275,
        NS_STATE_PROPERTY_NOT_THERE = 5046277,
        NS_ERROR_HTMLPARSER_EOF = 2152596456,
        NS_ERROR_HTMLPARSER_UNKNOWN = 2152596457,
        NS_ERROR_HTMLPARSER_CANTPROPAGATE = 2152596458,
        NS_ERROR_HTMLPARSER_CONTEXTMISMATCH = 2152596459,
        NS_ERROR_HTMLPARSER_BADFILENAME = 2152596460,
        NS_ERROR_HTMLPARSER_BADURL = 2152596461,
        NS_ERROR_HTMLPARSER_INVALIDPARSERCONTEXT = 2152596462,
        NS_ERROR_HTMLPARSER_INTERRUPTED = 2152596463,
        NS_ERROR_HTMLPARSER_BLOCK = 2152596464,
        NS_ERROR_HTMLPARSER_BADTOKENIZER = 2152596465,
        NS_ERROR_HTMLPARSER_BADATTRIBUTE = 2152596466,
        NS_ERROR_HTMLPARSER_UNRESOLVEDDTD = 2152596467,
        NS_ERROR_HTMLPARSER_MISPLACEDTABLECONTENT = 2152596468,
        NS_ERROR_HTMLPARSER_BADDTD = 2152596469,
        NS_ERROR_HTMLPARSER_BADCONTEXT = 2152596470,
        NS_ERROR_HTMLPARSER_STOPPARSING = 2152596471,
        NS_ERROR_HTMLPARSER_UNTERMINATEDSTRINGLITERAL = 2152596472,
        NS_ERROR_HTMLPARSER_HIERARCHYTOODEEP = 2152596473,
        NS_ERROR_HTMLPARSER_FAKE_ENDTAG = 2152596474,
        NS_ERROR_HTMLPARSER_INVALID_COMMENT = 2152596475,
        NS_HTMLTOKENS_NOT_AN_ENTITY = 5113808,
        NS_HTMLPARSER_VALID_META_CHARSET = 5114808,
        NS_RDF_CURSOR_EMPTY = 5177345,
        NS_RDF_NO_VALUE = 5177346,
        NS_RDF_ASSERTION_REJECTED = 5177347,
        NS_RDF_STOP_VISIT = 5177348,
        NS_ERROR_UCONV_NOCONV = 2152726529,
        NS_ERROR_UDEC_ILLEGALINPUT = 2152726542,
        NS_OK_HAD_REPLACEMENTS = 5242883,
        NS_SUCCESS_USING_FALLBACK_LOCALE = 5242882,
        NS_OK_UDEC_EXACTLENGTH = 5242891,
        NS_OK_UDEC_MOREINPUT = 5242892,
        NS_OK_UDEC_MOREOUTPUT = 5242893,
        NS_OK_UDEC_NOBOMFOUND = 5242894,
        NS_OK_UENC_EXACTLENGTH = 5242913,
        NS_OK_UENC_MOREOUTPUT = 5242914,
        NS_ERROR_UENC_NOMAPPING = 5242915,
        NS_OK_UENC_MOREINPUT = 5242916,
        NS_ERROR_FILE_UNRECOGNIZED_PATH = 2152857601,
        NS_ERROR_FILE_UNRESOLVABLE_SYMLINK = 2152857602,
        NS_ERROR_FILE_EXECUTION_FAILED = 2152857603,
        NS_ERROR_FILE_UNKNOWN_TYPE = 2152857604,
        NS_ERROR_FILE_DESTINATION_NOT_DIR = 2152857605,
        NS_ERROR_FILE_TARGET_DOES_NOT_EXIST = 2152857606,
        NS_ERROR_FILE_COPY_OR_MOVE_FAILED = 2152857607,
        NS_ERROR_FILE_ALREADY_EXISTS = 2152857608,
        NS_ERROR_FILE_INVALID_PATH = 2152857609,
        NS_ERROR_FILE_DISK_FULL = 2152857610,
        NS_ERROR_FILE_CORRUPTED = 2152857611,
        NS_ERROR_FILE_NOT_DIRECTORY = 2152857612,
        NS_ERROR_FILE_IS_DIRECTORY = 2152857613,
        NS_ERROR_FILE_IS_LOCKED = 2152857614,
        NS_ERROR_FILE_TOO_BIG = 2152857615,
        NS_ERROR_FILE_NO_DEVICE_SPACE = 2152857616,
        NS_ERROR_FILE_NAME_TOO_LONG = 2152857617,
        NS_ERROR_FILE_NOT_FOUND = 2152857618,
        NS_ERROR_FILE_READ_ONLY = 2152857619,
        NS_ERROR_FILE_DIR_NOT_EMPTY = 2152857620,
        NS_ERROR_FILE_ACCESS_DENIED = 2152857621,
        NS_SUCCESS_FILE_DIRECTORY_EMPTY = 5373953,
        NS_SUCCESS_AGGREGATE_RESULT = 5373954,
        NS_ERROR_DOM_INDEX_SIZE_ERR = 2152923137,
        NS_ERROR_DOM_HIERARCHY_REQUEST_ERR = 2152923139,
        NS_ERROR_DOM_WRONG_DOCUMENT_ERR = 2152923140,
        NS_ERROR_DOM_INVALID_CHARACTER_ERR = 2152923141,
        NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR = 2152923143,
        NS_ERROR_DOM_NOT_FOUND_ERR = 2152923144,
        NS_ERROR_DOM_NOT_SUPPORTED_ERR = 2152923145,
        NS_ERROR_DOM_INUSE_ATTRIBUTE_ERR = 2152923146,
        NS_ERROR_DOM_INVALID_STATE_ERR = 2152923147,
        NS_ERROR_DOM_SYNTAX_ERR = 2152923148,
        NS_ERROR_DOM_INVALID_MODIFICATION_ERR = 2152923149,
        NS_ERROR_DOM_NAMESPACE_ERR = 2152923150,
        NS_ERROR_DOM_INVALID_ACCESS_ERR = 2152923151,
        NS_ERROR_DOM_TYPE_MISMATCH_ERR = 2152923153,
        NS_ERROR_DOM_SECURITY_ERR = 2152923154,
        NS_ERROR_DOM_NETWORK_ERR = 2152923155,
        NS_ERROR_DOM_ABORT_ERR = 2152923156,
        NS_ERROR_DOM_URL_MISMATCH_ERR = 2152923157,
        NS_ERROR_DOM_QUOTA_EXCEEDED_ERR = 2152923158,
        NS_ERROR_DOM_TIMEOUT_ERR = 2152923159,
        NS_ERROR_DOM_INVALID_NODE_TYPE_ERR = 2152923160,
        NS_ERROR_DOM_DATA_CLONE_ERR = 2152923161,
        NS_ERROR_TYPE_ERR = 2152923162,
        NS_ERROR_RANGE_ERR = 2152923163,
        NS_ERROR_DOM_ENCODING_NOT_SUPPORTED_ERR = 2152923164,
        NS_ERROR_DOM_INVALID_POINTER_ERR = 2152923165,
        NS_ERROR_DOM_UNKNOWN_ERR = 2152923166,
        NS_ERROR_DOM_DATA_ERR = 2152923167,
        NS_ERROR_DOM_OPERATION_ERR = 2152923168,
        NS_ERROR_DOM_NOT_ALLOWED_ERR = 2152923169,
        NS_ERROR_DOM_SECMAN_ERR = 2152924137,
        NS_ERROR_DOM_WRONG_TYPE_ERR = 2152924138,
        NS_ERROR_DOM_NOT_OBJECT_ERR = 2152924139,
        NS_ERROR_DOM_NOT_XPC_OBJECT_ERR = 2152924140,
        NS_ERROR_DOM_NOT_NUMBER_ERR = 2152924141,
        NS_ERROR_DOM_NOT_BOOLEAN_ERR = 2152924142,
        NS_ERROR_DOM_NOT_FUNCTION_ERR = 2152924143,
        NS_ERROR_DOM_TOO_FEW_PARAMETERS_ERR = 2152924144,
        NS_ERROR_DOM_BAD_DOCUMENT_DOMAIN = 2152924145,
        NS_ERROR_DOM_PROP_ACCESS_DENIED = 2152924146,
        NS_ERROR_DOM_XPCONNECT_ACCESS_DENIED = 2152924147,
        NS_ERROR_DOM_BAD_URI = 2152924148,
        NS_ERROR_DOM_RETVAL_UNDEFINED = 2152924149,
        NS_ERROR_DOM_QUOTA_REACHED = 2152924150,
        NS_ERROR_UNCATCHABLE_EXCEPTION = 2152924151,
        NS_ERROR_DOM_MALFORMED_URI = 2152924152,
        NS_ERROR_DOM_INVALID_HEADER_NAME = 2152924153,
        NS_ERROR_DOM_INVALID_STATE_XHR_HAS_INVALID_CONTEXT = 2152924154,
        NS_ERROR_DOM_INVALID_STATE_XHR_MUST_BE_OPENED = 2152924155,
        NS_ERROR_DOM_INVALID_STATE_XHR_MUST_NOT_BE_SENDING = 2152924156,
        NS_ERROR_DOM_INVALID_STATE_XHR_MUST_NOT_BE_LOADING_OR_DONE =
            2152924157,
        NS_ERROR_DOM_INVALID_STATE_XHR_HAS_WRONG_RESPONSETYPE_FOR_RESPONSEXML
            = 2152924158,
        NS_ERROR_DOM_INVALID_STATE_XHR_HAS_WRONG_RESPONSETYPE_FOR_RESPONSETEXT
            = 2152924159,
        NS_ERROR_DOM_INVALID_STATE_XHR_CHUNKED_RESPONSETYPES_UNSUPPORTED_FOR_SYNC
            = 2152924160,
        NS_ERROR_DOM_INVALID_ACCESS_XHR_TIMEOUT_AND_RESPONSETYPE_UNSUPPORTED_FOR_SYNC
            = 2152924161,
        NS_ERROR_DOM_JS_DECODING_ERROR = 2152924162,
        NS_SUCCESS_DOM_NO_OPERATION = 5439489,
        NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW = 5439490,
        NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW_UNCATCHABLE = 5439491,
        NS_IMAGELIB_SUCCESS_LOAD_FINISHED = 5505024,
        NS_IMAGELIB_CHANGING_OWNER = 5505025,
        NS_IMAGELIB_ERROR_FAILURE = 2152988677,
        NS_IMAGELIB_ERROR_NO_DECODER = 2152988678,
        NS_IMAGELIB_ERROR_NOT_FINISHED = 2152988679,
        NS_IMAGELIB_ERROR_NO_ENCODER = 2152988681,
        NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND = 5636097,
        NS_SUCCESS_EDITOR_FOUND_TARGET = 5636098,
        NS_ERROR_XPC_NOT_ENOUGH_ARGS = 2153185281,
        NS_ERROR_XPC_NEED_OUT_OBJECT = 2153185282,
        NS_ERROR_XPC_CANT_SET_OUT_VAL = 2153185283,
        NS_ERROR_XPC_NATIVE_RETURNED_FAILURE = 2153185284,
        NS_ERROR_XPC_CANT_GET_INTERFACE_INFO = 2153185285,
        NS_ERROR_XPC_CANT_GET_PARAM_IFACE_INFO = 2153185286,
        NS_ERROR_XPC_CANT_GET_METHOD_INFO = 2153185287,
        NS_ERROR_XPC_UNEXPECTED = 2153185288,
        NS_ERROR_XPC_BAD_CONVERT_JS = 2153185289,
        NS_ERROR_XPC_BAD_CONVERT_NATIVE = 2153185290,
        NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF = 2153185291,
        NS_ERROR_XPC_BAD_OP_ON_WN_PROTO = 2153185292,
        NS_ERROR_XPC_CANT_CONVERT_WN_TO_FUN = 2153185293,
        NS_ERROR_XPC_CANT_DEFINE_PROP_ON_WN = 2153185294,
        NS_ERROR_XPC_CANT_WATCH_WN_STATIC = 2153185295,
        NS_ERROR_XPC_CANT_EXPORT_WN_STATIC = 2153185296,
        NS_ERROR_XPC_SCRIPTABLE_CALL_FAILED = 2153185297,
        NS_ERROR_XPC_SCRIPTABLE_CTOR_FAILED = 2153185298,
        NS_ERROR_XPC_CANT_CALL_WO_SCRIPTABLE = 2153185299,
        NS_ERROR_XPC_CANT_CTOR_WO_SCRIPTABLE = 2153185300,
        NS_ERROR_XPC_CI_RETURNED_FAILURE = 2153185301,
        NS_ERROR_XPC_GS_RETURNED_FAILURE = 2153185302,
        NS_ERROR_XPC_BAD_CID = 2153185303,
        NS_ERROR_XPC_BAD_IID = 2153185304,
        NS_ERROR_XPC_CANT_CREATE_WN = 2153185305,
        NS_ERROR_XPC_JS_THREW_EXCEPTION = 2153185306,
        NS_ERROR_XPC_JS_THREW_NATIVE_OBJECT = 2153185307,
        NS_ERROR_XPC_JS_THREW_JS_OBJECT = 2153185308,
        NS_ERROR_XPC_JS_THREW_NULL = 2153185309,
        NS_ERROR_XPC_JS_THREW_STRING = 2153185310,
        NS_ERROR_XPC_JS_THREW_NUMBER = 2153185311,
        NS_ERROR_XPC_JAVASCRIPT_ERROR = 2153185312,
        NS_ERROR_XPC_JAVASCRIPT_ERROR_WITH_DETAILS = 2153185313,
        NS_ERROR_XPC_CANT_CONVERT_PRIMITIVE_TO_ARRAY = 2153185314,
        NS_ERROR_XPC_CANT_CONVERT_OBJECT_TO_ARRAY = 2153185315,
        NS_ERROR_XPC_NOT_ENOUGH_ELEMENTS_IN_ARRAY = 2153185316,
        NS_ERROR_XPC_CANT_GET_ARRAY_INFO = 2153185317,
        NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING = 2153185318,
        NS_ERROR_XPC_SECURITY_MANAGER_VETO = 2153185319,
        NS_ERROR_XPC_INTERFACE_NOT_SCRIPTABLE = 2153185320,
        NS_ERROR_XPC_INTERFACE_NOT_FROM_NSISUPPORTS = 2153185321,
        NS_ERROR_XPC_CANT_GET_JSOBJECT_OF_DOM_OBJECT = 2153185322,
        NS_ERROR_XPC_CANT_SET_READ_ONLY_CONSTANT = 2153185323,
        NS_ERROR_XPC_CANT_SET_READ_ONLY_ATTRIBUTE = 2153185324,
        NS_ERROR_XPC_CANT_SET_READ_ONLY_METHOD = 2153185325,
        NS_ERROR_XPC_CANT_ADD_PROP_TO_WRAPPED_NATIVE = 2153185326,
        NS_ERROR_XPC_CALL_TO_SCRIPTABLE_FAILED = 2153185327,
        NS_ERROR_XPC_JSOBJECT_HAS_NO_FUNCTION_NAMED = 2153185328,
        NS_ERROR_XPC_BAD_ID_STRING = 2153185329,
        NS_ERROR_XPC_BAD_INITIALIZER_NAME = 2153185330,
        NS_ERROR_XPC_HAS_BEEN_SHUTDOWN = 2153185331,
        NS_ERROR_XPC_CANT_MODIFY_PROP_ON_WN = 2153185332,
        NS_ERROR_XPC_BAD_CONVERT_JS_ZERO_ISNOT_NULL = 2153185333,
        NS_ERROR_XPC_CANT_PASS_CPOW_TO_NATIVE = 2153185334,
        NS_ERROR_LAUNCHED_CHILD_PROCESS = 2153251016,
        NS_ERROR_CSP_FORM_ACTION_VIOLATION = 2153381986,
        NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION = 2153381987,
        NS_ERROR_SRI_CORRUPT = 2153382088,
        NS_ERROR_SRI_DISABLED = 2153382089,
        NS_ERROR_SRI_NOT_ELIGIBLE = 2153382090,
        NS_ERROR_SRI_UNEXPECTED_HASH_TYPE = 2153382091,
        NS_ERROR_SRI_IMPORT = 2153382092,
        NS_ERROR_CMS_VERIFY_NOT_SIGNED = 2153382912,
        NS_ERROR_CMS_VERIFY_NO_CONTENT_INFO = 2153382913,
        NS_ERROR_CMS_VERIFY_BAD_DIGEST = 2153382914,
        NS_ERROR_CMS_VERIFY_NOCERT = 2153382916,
        NS_ERROR_CMS_VERIFY_UNTRUSTED = 2153382917,
        NS_ERROR_CMS_VERIFY_ERROR_UNVERIFIED = 2153382919,
        NS_ERROR_CMS_VERIFY_ERROR_PROCESSING = 2153382920,
        NS_ERROR_CMS_VERIFY_BAD_SIGNATURE = 2153382921,
        NS_ERROR_CMS_VERIFY_DIGEST_MISMATCH = 2153382922,
        NS_ERROR_CMS_VERIFY_UNKNOWN_ALGO = 2153382923,
        NS_ERROR_CMS_VERIFY_UNSUPPORTED_ALGO = 2153382924,
        NS_ERROR_CMS_VERIFY_MALFORMED_SIGNATURE = 2153382925,
        NS_ERROR_CMS_VERIFY_HEADER_MISMATCH = 2153382926,
        NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED = 2153382927,
        NS_ERROR_CMS_VERIFY_CERT_WITHOUT_ADDRESS = 2153382928,
        NS_ERROR_CMS_ENCRYPT_NO_BULK_ALG = 2153382944,
        NS_ERROR_CMS_ENCRYPT_INCOMPLETE = 2153382945,
        NS_ERROR_DOM_INVALID_EXPRESSION_ERR = 2153447475,
        NS_ERROR_DOM_TYPE_ERR = 2153447476,
        NS_ERROR_WONT_HANDLE_CONTENT = 2153578497,
        NS_ERROR_MALWARE_URI = 2153578526,
        NS_ERROR_PHISHING_URI = 2153578527,
        NS_ERROR_TRACKING_URI = 2153578530,
        NS_ERROR_UNWANTED_URI = 2153578531,
        NS_ERROR_BLOCKED_URI = 2153578533,
        NS_ERROR_HARMFUL_URI = 2153578534,
        NS_ERROR_SAVE_LINK_AS_TIMEOUT = 2153578528,
        NS_ERROR_PARSED_DATA_CACHED = 2153578529,
        NS_REFRESHURI_HEADER_FOUND = 6094850,
        NS_ERROR_CONTENT_BLOCKED = 2153644038,
        NS_ERROR_CONTENT_BLOCKED_SHOW_ALT = 2153644039,
        NS_PROPTABLE_PROP_NOT_THERE = 2153644042,
        NS_ERROR_XBL_BLOCKED = 2153644047,
        NS_ERROR_CONTENT_CRASHED = 2153644048,
        NS_HTML_STYLE_PROPERTY_NOT_THERE = 6160386,
        NS_CONTENT_BLOCKED = 6160392,
        NS_CONTENT_BLOCKED_SHOW_ALT = 6160393,
        NS_PROPTABLE_PROP_OVERWRITTEN = 6160395,
        NS_FINDBROADCASTER_NOT_FOUND = 6160396,
        NS_FINDBROADCASTER_FOUND = 6160397,
        NS_FINDBROADCASTER_AWAIT_OVERLAYS = 6160398,
        NS_ERROR_XSLT_PARSE_FAILURE = 2153775105,
        NS_ERROR_XPATH_PARSE_FAILURE = 2153775106,
        NS_ERROR_XSLT_ALREADY_SET = 2153775107,
        NS_ERROR_XSLT_EXECUTION_FAILURE = 2153775108,
        NS_ERROR_XPATH_UNKNOWN_FUNCTION = 2153775109,
        NS_ERROR_XSLT_BAD_RECURSION = 2153775110,
        NS_ERROR_XSLT_BAD_VALUE = 2153775111,
        NS_ERROR_XSLT_NODESET_EXPECTED = 2153775112,
        NS_ERROR_XSLT_ABORTED = 2153775113,
        NS_ERROR_XSLT_NETWORK_ERROR = 2153775114,
        NS_ERROR_XSLT_WRONG_MIME_TYPE = 2153775115,
        NS_ERROR_XSLT_LOAD_RECURSION = 2153775116,
        NS_ERROR_XPATH_BAD_ARGUMENT_COUNT = 2153775117,
        NS_ERROR_XPATH_BAD_EXTENSION_FUNCTION = 2153775118,
        NS_ERROR_XPATH_PAREN_EXPECTED = 2153775119,
        NS_ERROR_XPATH_INVALID_AXIS = 2153775120,
        NS_ERROR_XPATH_NO_NODE_TYPE_TEST = 2153775121,
        NS_ERROR_XPATH_BRACKET_EXPECTED = 2153775122,
        NS_ERROR_XPATH_INVALID_VAR_NAME = 2153775123,
        NS_ERROR_XPATH_UNEXPECTED_END = 2153775124,
        NS_ERROR_XPATH_OPERATOR_EXPECTED = 2153775125,
        NS_ERROR_XPATH_UNCLOSED_LITERAL = 2153775126,
        NS_ERROR_XPATH_BAD_COLON = 2153775127,
        NS_ERROR_XPATH_BAD_BANG = 2153775128,
        NS_ERROR_XPATH_ILLEGAL_CHAR = 2153775129,
        NS_ERROR_XPATH_BINARY_EXPECTED = 2153775130,
        NS_ERROR_XSLT_LOAD_BLOCKED_ERROR = 2153775131,
        NS_ERROR_XPATH_INVALID_EXPRESSION_EVALUATED = 2153775132,
        NS_ERROR_XPATH_UNBALANCED_CURLY_BRACE = 2153775133,
        NS_ERROR_XSLT_BAD_NODE_NAME = 2153775134,
        NS_ERROR_XSLT_VAR_ALREADY_SET = 2153775135,
        NS_ERROR_XSLT_CALL_TO_KEY_NOT_ALLOWED = 2153775136,
        NS_XSLT_GET_NEW_HANDLER = 6291457,
        NS_ERROR_TRANSPORT_INIT = 2153840641,
        NS_ERROR_DUPLICATE_HANDLE = 2153840642,
        NS_ERROR_BRIDGE_OPEN_PARENT = 2153840643,
        NS_ERROR_BRIDGE_OPEN_CHILD = 2153840644,
        NS_ERROR_DOM_SVG_WRONG_TYPE_ERR = 2153906176,
        NS_ERROR_DOM_SVG_MATRIX_NOT_INVERTABLE = 2153906178,
        NS_ERROR_STORAGE_BUSY = 2153971713,
        NS_ERROR_STORAGE_IOERR = 2153971714,
        NS_ERROR_STORAGE_CONSTRAINT = 2153971715,
        NS_ERROR_DOM_FILE_NOT_FOUND_ERR = 2154102784,
        NS_ERROR_DOM_FILE_NOT_READABLE_ERR = 2154102785,
        NS_ERROR_DOM_FILE_ABORT_ERR = 2154102786,
        NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR = 2154168321,
        NS_ERROR_DOM_INDEXEDDB_NOT_FOUND_ERR = 2154168323,
        NS_ERROR_DOM_INDEXEDDB_CONSTRAINT_ERR = 2154168324,
        NS_ERROR_DOM_INDEXEDDB_DATA_ERR = 2154168325,
        NS_ERROR_DOM_INDEXEDDB_NOT_ALLOWED_ERR = 2154168326,
        NS_ERROR_DOM_INDEXEDDB_TRANSACTION_INACTIVE_ERR = 2154168327,
        NS_ERROR_DOM_INDEXEDDB_ABORT_ERR = 2154168328,
        NS_ERROR_DOM_INDEXEDDB_READ_ONLY_ERR = 2154168329,
        NS_ERROR_DOM_INDEXEDDB_TIMEOUT_ERR = 2154168330,
        NS_ERROR_DOM_INDEXEDDB_QUOTA_ERR = 2154168331,
        NS_ERROR_DOM_INDEXEDDB_VERSION_ERR = 2154168332,
        NS_ERROR_DOM_INDEXEDDB_RECOVERABLE_ERR = 2154169321,
        NS_ERROR_DOM_FILEHANDLE_UNKNOWN_ERR = 2154233857,
        NS_ERROR_DOM_FILEHANDLE_NOT_ALLOWED_ERR = 2154233858,
        NS_ERROR_DOM_FILEHANDLE_INACTIVE_ERR = 2154233859,
        NS_ERROR_DOM_FILEHANDLE_ABORT_ERR = 2154233860,
        NS_ERROR_DOM_FILEHANDLE_READ_ONLY_ERR = 2154233861,
        NS_ERROR_DOM_FILEHANDLE_QUOTA_ERR = 2154233862,
        NS_ERROR_SIGNED_JAR_NOT_SIGNED = 2154299393,
        NS_ERROR_SIGNED_JAR_MODIFIED_ENTRY = 2154299394,
        NS_ERROR_SIGNED_JAR_UNSIGNED_ENTRY = 2154299395,
        NS_ERROR_SIGNED_JAR_ENTRY_MISSING = 2154299396,
        NS_ERROR_SIGNED_JAR_WRONG_SIGNATURE = 2154299397,
        NS_ERROR_SIGNED_JAR_ENTRY_TOO_LARGE = 2154299398,
        NS_ERROR_SIGNED_JAR_ENTRY_INVALID = 2154299399,
        NS_ERROR_SIGNED_JAR_MANIFEST_INVALID = 2154299400,
        NS_ERROR_DOM_FILESYSTEM_INVALID_PATH_ERR = 2154364929,
        NS_ERROR_DOM_FILESYSTEM_INVALID_MODIFICATION_ERR = 2154364930,
        NS_ERROR_DOM_FILESYSTEM_NO_MODIFICATION_ALLOWED_ERR = 2154364931,
        NS_ERROR_DOM_FILESYSTEM_PATH_EXISTS_ERR = 2154364932,
        NS_ERROR_DOM_FILESYSTEM_TYPE_MISMATCH_ERR = 2154364933,
        NS_ERROR_DOM_FILESYSTEM_UNKNOWN_ERR = 2154364934,
        NS_ERROR_SIGNED_APP_MANIFEST_INVALID = 2154496001,
        NS_ERROR_DOM_ANIM_MISSING_PROPS_ERR = 2154561537,
        NS_ERROR_DOM_PUSH_INVALID_REGISTRATION_ERR = 2154627073,
        NS_ERROR_DOM_PUSH_DENIED_ERR = 2154627074,
        NS_ERROR_DOM_PUSH_ABORT_ERR = 2154627075,
        NS_ERROR_DOM_PUSH_SERVICE_UNREACHABLE = 2154627076,
        NS_ERROR_DOM_PUSH_INVALID_KEY_ERR = 2154627077,
        NS_ERROR_DOM_PUSH_MISMATCHED_KEY_ERR = 2154627078,
        NS_ERROR_DOM_PUSH_GCM_DISABLED = 2154627079,
        NS_ERROR_DOM_MEDIA_ABORT_ERR = 2154692609,
        NS_ERROR_DOM_MEDIA_NOT_ALLOWED_ERR = 2154692610,
        NS_ERROR_DOM_MEDIA_NOT_SUPPORTED_ERR = 2154692611,
        NS_ERROR_DOM_MEDIA_DECODE_ERR = 2154692612,
        NS_ERROR_DOM_MEDIA_FATAL_ERR = 2154692613,
        NS_ERROR_DOM_MEDIA_METADATA_ERR = 2154692614,
        NS_ERROR_DOM_MEDIA_OVERFLOW_ERR = 2154692615,
        NS_ERROR_DOM_MEDIA_END_OF_STREAM = 2154692616,
        NS_ERROR_DOM_MEDIA_WAITING_FOR_DATA = 2154692617,
        NS_ERROR_DOM_MEDIA_CANCELED = 2154692618,
        NS_ERROR_DOM_MEDIA_MEDIASINK_ERR = 2154692619,
        NS_ERROR_DOM_MEDIA_DEMUXER_ERR = 2154692620,
        NS_ERROR_DOM_MEDIA_CDM_ERR = 2154692621,
        NS_ERROR_DOM_MEDIA_NEED_NEW_DECODER = 2154692622,
        NS_ERROR_DOM_MEDIA_INITIALIZING_DECODER = 2154692623,
        NS_ERROR_DOM_MEDIA_CUBEB_INITIALIZATION_ERR = 2154692709,
        NS_ERROR_UC_UPDATE_UNKNOWN = 2154758145,
        NS_ERROR_UC_UPDATE_DUPLICATE_PREFIX = 2154758146,
        NS_ERROR_UC_UPDATE_INFINITE_LOOP = 2154758147,
        NS_ERROR_UC_UPDATE_WRONG_REMOVAL_INDICES = 2154758148,
        NS_ERROR_UC_UPDATE_CHECKSUM_MISMATCH = 2154758149,
        NS_ERROR_UC_UPDATE_MISSING_CHECKSUM = 2154758150,
        NS_ERROR_UC_UPDATE_SHUTDOWNING = 2154758151,
        NS_ERROR_UC_UPDATE_TABLE_NOT_FOUND = 2154758152,
        NS_ERROR_UC_UPDATE_BUILD_PREFIX_FAILURE = 2154758153,
        NS_ERROR_UC_UPDATE_FAIL_TO_WRITE_DISK = 2154758154,
        NS_ERROR_UC_UPDATE_PROTOCOL_PARSER_ERROR = 2154758155,
        NS_ERROR_INTERNAL_ERRORRESULT_JS_EXCEPTION = 2154823681,
        NS_ERROR_INTERNAL_ERRORRESULT_DOMEXCEPTION = 2154823682,
        NS_ERROR_INTERNAL_ERRORRESULT_EXCEPTION_ON_JSCONTEXT = 2154823683,
        NS_ERROR_INTERNAL_ERRORRESULT_TYPEERROR = 2154823684,
        NS_ERROR_INTERNAL_ERRORRESULT_RANGEERROR = 2154823685,
        NS_ERROR_DOWNLOAD_COMPLETE = 2155347969,
        NS_ERROR_DOWNLOAD_NOT_PARTIAL = 2155347970,
        NS_ERROR_UNORM_MOREOUTPUT = 2155348001,
        NS_ERROR_DOCSHELL_REQUEST_REJECTED = 2155348969,
        NS_ERROR_DOCUMENT_IS_PRINTMODE = 2155349969,
        NS_SUCCESS_DONT_FIXUP = 7864321,
        NS_SUCCESS_RESTART_APP_NOT_SAME_PROFILE = 7864323,
        NS_SUCCESS_UNORM_NOTFOUND = 7864337,
        NS_ERROR_NOT_IN_TREE = 2155348006,
        NS_OK_NO_NAME_CLAUSE_HANDLED = 7864354,
    }
    pub type nsrefcnt = root::MozRefCountType;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAString {
        pub _base: root::mozilla::detail::nsStringRepr,
    }
    pub type nsAString_self_type = root::nsAString;
    extern "C" {
        #[link_name = "_ZN9nsAString12kMaxCapacityE"]
        pub static nsAString_kMaxCapacity:
                   root::mozilla::detail::nsStringRepr_size_type;
    }
    #[test]
    fn bindgen_test_layout_nsAString() {
        assert_eq!(::std::mem::size_of::<nsAString>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsAString ) ));
        assert_eq! (::std::mem::align_of::<nsAString>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsAString ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsSubstringTuple {
        pub mHead: *const root::nsSubstringTuple_self_type,
        pub mFragA: *const root::nsSubstringTuple_base_string_type,
        pub mFragB: *const root::nsSubstringTuple_base_string_type,
    }
    pub type nsSubstringTuple_char_type = u16;
    pub type nsSubstringTuple_self_type = root::nsSubstringTuple;
    pub type nsSubstringTuple_base_string_type =
        root::mozilla::detail::nsStringRepr;
    pub type nsSubstringTuple_size_type = u32;
    #[test]
    fn bindgen_test_layout_nsSubstringTuple() {
        assert_eq!(::std::mem::size_of::<nsSubstringTuple>() , 24usize ,
                   concat ! ( "Size of: " , stringify ! ( nsSubstringTuple )
                   ));
        assert_eq! (::std::mem::align_of::<nsSubstringTuple>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsSubstringTuple ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSubstringTuple ) ) . mHead as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSubstringTuple )
                    , "::" , stringify ! ( mHead ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSubstringTuple ) ) . mFragA as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSubstringTuple )
                    , "::" , stringify ! ( mFragA ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSubstringTuple ) ) . mFragB as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSubstringTuple )
                    , "::" , stringify ! ( mFragB ) ));
    }
    impl Clone for nsSubstringTuple {
        fn clone(&self) -> Self { *self }
    }
    pub type nsString_self_type = ::nsstring::nsStringRepr;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsString_Segment {
        pub mBegin: u32,
        pub mLength: u32,
    }
    #[test]
    fn bindgen_test_layout_nsString_Segment() {
        assert_eq!(::std::mem::size_of::<nsString_Segment>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsString_Segment ) ));
        assert_eq! (::std::mem::align_of::<nsString_Segment>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsString_Segment ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsString_Segment ) ) . mBegin as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsString_Segment )
                    , "::" , stringify ! ( mBegin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsString_Segment ) ) . mLength as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsString_Segment )
                    , "::" , stringify ! ( mLength ) ));
    }
    impl Clone for nsString_Segment {
        fn clone(&self) -> Self { *self }
    }
    pub type nsAutoStringN_self_type = u8;
    extern "C" {
        #[link_name = "kStorageSize"]
        pub static nsAutoStringN_kStorageSize: usize;
    }
    pub type nsAutoString = [u64; 20usize];
    #[repr(C)]
    pub struct nsStringComparator__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStringComparator {
        pub vtable_: *const nsStringComparator__bindgen_vtable,
    }
    pub type nsStringComparator_char_type = u16;
    #[test]
    fn bindgen_test_layout_nsStringComparator() {
        assert_eq!(::std::mem::size_of::<nsStringComparator>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStringComparator )
                   ));
        assert_eq! (::std::mem::align_of::<nsStringComparator>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStringComparator ) ));
    }
    impl Clone for nsStringComparator {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsACString {
        pub _base: root::mozilla::detail::nsCStringRepr,
    }
    pub type nsACString_self_type = root::nsACString;
    extern "C" {
        #[link_name = "_ZN10nsACString12kMaxCapacityE"]
        pub static nsACString_kMaxCapacity:
                   root::mozilla::detail::nsCStringRepr_size_type;
    }
    #[test]
    fn bindgen_test_layout_nsACString() {
        assert_eq!(::std::mem::size_of::<nsACString>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsACString ) ));
        assert_eq! (::std::mem::align_of::<nsACString>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsACString ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCSubstringTuple {
        pub mHead: *const root::nsCSubstringTuple_self_type,
        pub mFragA: *const root::nsCSubstringTuple_base_string_type,
        pub mFragB: *const root::nsCSubstringTuple_base_string_type,
    }
    pub type nsCSubstringTuple_char_type = ::std::os::raw::c_char;
    pub type nsCSubstringTuple_self_type = root::nsCSubstringTuple;
    pub type nsCSubstringTuple_base_string_type =
        root::mozilla::detail::nsCStringRepr;
    pub type nsCSubstringTuple_size_type = u32;
    #[test]
    fn bindgen_test_layout_nsCSubstringTuple() {
        assert_eq!(::std::mem::size_of::<nsCSubstringTuple>() , 24usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCSubstringTuple )
                   ));
        assert_eq! (::std::mem::align_of::<nsCSubstringTuple>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSubstringTuple ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSubstringTuple ) ) . mHead as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSubstringTuple )
                    , "::" , stringify ! ( mHead ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSubstringTuple ) ) . mFragA as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSubstringTuple )
                    , "::" , stringify ! ( mFragA ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSubstringTuple ) ) . mFragB as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSubstringTuple )
                    , "::" , stringify ! ( mFragB ) ));
    }
    impl Clone for nsCSubstringTuple {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCString {
        pub _base: root::nsACString,
    }
    pub type nsCString_self_type = root::nsCString;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCString_Segment {
        pub mBegin: u32,
        pub mLength: u32,
    }
    #[test]
    fn bindgen_test_layout_nsCString_Segment() {
        assert_eq!(::std::mem::size_of::<nsCString_Segment>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCString_Segment )
                   ));
        assert_eq! (::std::mem::align_of::<nsCString_Segment>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCString_Segment ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCString_Segment ) ) . mBegin as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCString_Segment )
                    , "::" , stringify ! ( mBegin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCString_Segment ) ) . mLength as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCString_Segment )
                    , "::" , stringify ! ( mLength ) ));
    }
    impl Clone for nsCString_Segment {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsCString() {
        assert_eq!(::std::mem::size_of::<nsCString>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsCString ) ));
        assert_eq! (::std::mem::align_of::<nsCString>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsCString ) ));
    }
    #[repr(C)]
    pub struct nsCStringComparator__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCStringComparator {
        pub vtable_: *const nsCStringComparator__bindgen_vtable,
    }
    pub type nsCStringComparator_char_type = ::std::os::raw::c_char;
    #[test]
    fn bindgen_test_layout_nsCStringComparator() {
        assert_eq!(::std::mem::size_of::<nsCStringComparator>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCStringComparator ) ));
        assert_eq! (::std::mem::align_of::<nsCStringComparator>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCStringComparator ) ));
    }
    impl Clone for nsCStringComparator {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    pub struct nsISupports__bindgen_vtable(::std::os::raw::c_void);
    /// Basic component object model interface. Objects which implement
    /// this interface support runtime interface discovery (QueryInterface)
    /// and a reference counted memory model (AddRef/Release). This is
    /// modelled after the win32 IUnknown API.
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsISupports {
        pub vtable_: *const nsISupports__bindgen_vtable,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISupports_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsISupports() {
        assert_eq!(::std::mem::size_of::<nsISupports>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsISupports ) ));
        assert_eq! (::std::mem::align_of::<nsISupports>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsISupports ) ));
    }
    impl Clone for nsISupports {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    pub struct nsCycleCollectionParticipant__bindgen_vtable(::std::os::raw::c_void);
    /// Participant implementation classes
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCycleCollectionParticipant {
        pub vtable_: *const nsCycleCollectionParticipant__bindgen_vtable,
        pub mMightSkip: bool,
        pub mTraverseShouldTrace: bool,
    }
    #[test]
    fn bindgen_test_layout_nsCycleCollectionParticipant() {
        assert_eq!(::std::mem::size_of::<nsCycleCollectionParticipant>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( nsCycleCollectionParticipant )
                   ));
        assert_eq! (::std::mem::align_of::<nsCycleCollectionParticipant>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsCycleCollectionParticipant ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCycleCollectionParticipant ) ) .
                    mMightSkip as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCycleCollectionParticipant ) , "::" , stringify ! (
                    mMightSkip ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCycleCollectionParticipant ) ) .
                    mTraverseShouldTrace as * const _ as usize } , 9usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCycleCollectionParticipant ) , "::" , stringify ! (
                    mTraverseShouldTrace ) ));
    }
    impl Clone for nsCycleCollectionParticipant {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCycleCollectingAutoRefCnt {
        pub mRefCntAndFlags: usize,
    }
    pub type nsCycleCollectingAutoRefCnt_Suspect =
        ::std::option::Option<unsafe extern "C" fn(aPtr:
                                                       *mut ::std::os::raw::c_void,
                                                   aCp:
                                                       *mut root::nsCycleCollectionParticipant,
                                                   aRefCnt:
                                                       *mut root::nsCycleCollectingAutoRefCnt,
                                                   aShouldDelete: *mut bool)>;
    #[test]
    fn bindgen_test_layout_nsCycleCollectingAutoRefCnt() {
        assert_eq!(::std::mem::size_of::<nsCycleCollectingAutoRefCnt>() ,
                   8usize , concat ! (
                   "Size of: " , stringify ! ( nsCycleCollectingAutoRefCnt )
                   ));
        assert_eq! (::std::mem::align_of::<nsCycleCollectingAutoRefCnt>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsCycleCollectingAutoRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCycleCollectingAutoRefCnt ) ) .
                    mRefCntAndFlags as * const _ as usize } , 0usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsCycleCollectingAutoRefCnt ) , "::" , stringify ! (
                    mRefCntAndFlags ) ));
    }
    impl Clone for nsCycleCollectingAutoRefCnt {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsCharTraits {
        pub _address: u8,
    }
    /// @see nsTAString
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsReadingIterator<CharT> {
        pub mStart: *mut CharT,
        pub mEnd: *mut CharT,
        pub mPosition: *mut CharT,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<CharT>>,
    }
    pub type nsReadingIterator_self_type<CharT> =
        root::nsReadingIterator<CharT>;
    pub type nsReadingIterator_difference_type = isize;
    pub type nsReadingIterator_size_type = usize;
    pub type nsReadingIterator_value_type<CharT> = CharT;
    pub type nsReadingIterator_pointer<CharT> = *mut CharT;
    pub type nsReadingIterator_reference = u8;
    /// @see nsTAString
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsWritingIterator<CharT> {
        pub mStart: *mut CharT,
        pub mEnd: *mut CharT,
        pub mPosition: *mut CharT,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<CharT>>,
    }
    pub type nsWritingIterator_self_type<CharT> =
        root::nsWritingIterator<CharT>;
    pub type nsWritingIterator_difference_type = isize;
    pub type nsWritingIterator_size_type = usize;
    pub type nsWritingIterator_value_type<CharT> = CharT;
    pub type nsWritingIterator_pointer<CharT> = *mut CharT;
    pub type nsWritingIterator_reference = u8;
    pub type AutoTArray_self_type = u8;
    pub type AutoTArray_base_type<E> = root::nsTArray<E>;
    pub type AutoTArray_Header<E> = root::AutoTArray_base_type<E>;
    pub type AutoTArray_elem_type<E> = root::AutoTArray_base_type<E>;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AutoTArray__bindgen_ty_1 {
        pub mAutoBuf: root::__BindgenUnionField<*mut ::std::os::raw::c_char>,
        pub mAlign: root::__BindgenUnionField<u8>,
        pub bindgen_union_field: u64,
    }
    pub type PRUint32 = ::std::os::raw::c_uint;
    pub type PRIntn = ::std::os::raw::c_int;
    pub type PRUintn = ::std::os::raw::c_uint;
    /// TYPES:       PRSize
    /// DESCRIPTION:
    /// A type for representing the size of objects.
    pub type PRSize = usize;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLHashEntry {
        pub next: *mut root::PLHashEntry,
        pub keyHash: root::PLHashNumber,
        pub key: *const ::std::os::raw::c_void,
        pub value: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_PLHashEntry() {
        assert_eq!(::std::mem::size_of::<PLHashEntry>() , 32usize , concat ! (
                   "Size of: " , stringify ! ( PLHashEntry ) ));
        assert_eq! (::std::mem::align_of::<PLHashEntry>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( PLHashEntry ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashEntry ) ) . next as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashEntry ) ,
                    "::" , stringify ! ( next ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashEntry ) ) . keyHash as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashEntry ) ,
                    "::" , stringify ! ( keyHash ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashEntry ) ) . key as * const _ as
                    usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashEntry ) ,
                    "::" , stringify ! ( key ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashEntry ) ) . value as * const _
                    as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashEntry ) ,
                    "::" , stringify ! ( value ) ));
    }
    impl Clone for PLHashEntry {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLHashTable {
        pub buckets: *mut *mut root::PLHashEntry,
        pub nentries: root::PRUint32,
        pub shift: root::PRUint32,
        pub keyHash: root::PLHashFunction,
        pub keyCompare: root::PLHashComparator,
        pub valueCompare: root::PLHashComparator,
        pub allocOps: *const root::PLHashAllocOps,
        pub allocPriv: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_PLHashTable() {
        assert_eq!(::std::mem::size_of::<PLHashTable>() , 56usize , concat ! (
                   "Size of: " , stringify ! ( PLHashTable ) ));
        assert_eq! (::std::mem::align_of::<PLHashTable>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( PLHashTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . buckets as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( buckets ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . nentries as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( nentries ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . shift as * const _
                    as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( shift ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . keyHash as * const
                    _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( keyHash ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . keyCompare as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( keyCompare ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . valueCompare as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( valueCompare ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . allocOps as * const
                    _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( allocOps ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . allocPriv as *
                    const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( allocPriv ) ));
    }
    impl Clone for PLHashTable {
        fn clone(&self) -> Self { *self }
    }
    pub type PLHashNumber = root::PRUint32;
    pub type PLHashFunction =
        ::std::option::Option<unsafe extern "C" fn(key:
                                                       *const ::std::os::raw::c_void)
                                  -> root::PLHashNumber>;
    pub type PLHashComparator =
        ::std::option::Option<unsafe extern "C" fn(v1:
                                                       *const ::std::os::raw::c_void,
                                                   v2:
                                                       *const ::std::os::raw::c_void)
                                  -> root::PRIntn>;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLHashAllocOps {
        pub allocTable: ::std::option::Option<unsafe extern "C" fn(pool:
                                                                       *mut ::std::os::raw::c_void,
                                                                   size:
                                                                       root::PRSize)
                                                  ->
                                                      *mut ::std::os::raw::c_void>,
        pub freeTable: ::std::option::Option<unsafe extern "C" fn(pool:
                                                                      *mut ::std::os::raw::c_void,
                                                                  item:
                                                                      *mut ::std::os::raw::c_void)>,
        pub allocEntry: ::std::option::Option<unsafe extern "C" fn(pool:
                                                                       *mut ::std::os::raw::c_void,
                                                                   key:
                                                                       *const ::std::os::raw::c_void)
                                                  -> *mut root::PLHashEntry>,
        pub freeEntry: ::std::option::Option<unsafe extern "C" fn(pool:
                                                                      *mut ::std::os::raw::c_void,
                                                                  he:
                                                                      *mut root::PLHashEntry,
                                                                  flag:
                                                                      root::PRUintn)>,
    }
    #[test]
    fn bindgen_test_layout_PLHashAllocOps() {
        assert_eq!(::std::mem::size_of::<PLHashAllocOps>() , 32usize , concat
                   ! ( "Size of: " , stringify ! ( PLHashAllocOps ) ));
        assert_eq! (::std::mem::align_of::<PLHashAllocOps>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( PLHashAllocOps ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashAllocOps ) ) . allocTable as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashAllocOps ) ,
                    "::" , stringify ! ( allocTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashAllocOps ) ) . freeTable as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashAllocOps ) ,
                    "::" , stringify ! ( freeTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashAllocOps ) ) . allocEntry as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashAllocOps ) ,
                    "::" , stringify ! ( allocEntry ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashAllocOps ) ) . freeEntry as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashAllocOps ) ,
                    "::" , stringify ! ( freeEntry ) ));
    }
    impl Clone for PLHashAllocOps {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSTokenSerializationType {
        eCSSTokenSerialization_Nothing = 0,
        eCSSTokenSerialization_Whitespace = 1,
        eCSSTokenSerialization_AtKeyword_or_Hash = 2,
        eCSSTokenSerialization_Number = 3,
        eCSSTokenSerialization_Dimension = 4,
        eCSSTokenSerialization_Percentage = 5,
        eCSSTokenSerialization_URange = 6,
        eCSSTokenSerialization_URL_or_BadURL = 7,
        eCSSTokenSerialization_Function = 8,
        eCSSTokenSerialization_Ident = 9,
        eCSSTokenSerialization_CDC = 10,
        eCSSTokenSerialization_DashMatch = 11,
        eCSSTokenSerialization_ContainsMatch = 12,
        eCSSTokenSerialization_Symbol_Hash = 13,
        eCSSTokenSerialization_Symbol_At = 14,
        eCSSTokenSerialization_Symbol_Dot_or_Plus = 15,
        eCSSTokenSerialization_Symbol_Minus = 16,
        eCSSTokenSerialization_Symbol_OpenParen = 17,
        eCSSTokenSerialization_Symbol_Question = 18,
        eCSSTokenSerialization_Symbol_Assorted = 19,
        eCSSTokenSerialization_Symbol_Equals = 20,
        eCSSTokenSerialization_Symbol_Bar = 21,
        eCSSTokenSerialization_Symbol_Slash = 22,
        eCSSTokenSerialization_Symbol_Asterisk = 23,
        eCSSTokenSerialization_Other = 24,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSScanner {
        pub mBuffer: *const u16,
        pub mOffset: u32,
        pub mCount: u32,
        pub mLineNumber: u32,
        pub mLineOffset: u32,
        pub mTokenLineNumber: u32,
        pub mTokenLineOffset: u32,
        pub mTokenOffset: u32,
        pub mRecordStartOffset: u32,
        pub mEOFCharacters: root::nsCSSScanner_EOFCharacters,
        pub mReporter: *mut root::mozilla::css::ErrorReporter,
        pub mRecording: bool,
        pub mSeenBadToken: bool,
        pub mSeenVariableReference: bool,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSScanner_EOFCharacters {
        eEOFCharacters_None = 0,
        eEOFCharacters_DropBackslash = 1,
        eEOFCharacters_ReplacementChar = 2,
        eEOFCharacters_Asterisk = 4,
        eEOFCharacters_Slash = 8,
        eEOFCharacters_DoubleQuote = 16,
        eEOFCharacters_SingleQuote = 32,
        eEOFCharacters_CloseParen = 64,
    }
    #[test]
    fn bindgen_test_layout_nsCSSScanner() {
        assert_eq!(::std::mem::size_of::<nsCSSScanner>() , 64usize , concat !
                   ( "Size of: " , stringify ! ( nsCSSScanner ) ));
        assert_eq! (::std::mem::align_of::<nsCSSScanner>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsCSSScanner ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSScanner ) ) . mBuffer as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSScanner ) ,
                    "::" , stringify ! ( mBuffer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSScanner ) ) . mOffset as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSScanner ) ,
                    "::" , stringify ! ( mOffset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSScanner ) ) . mCount as * const
                    _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSScanner ) ,
                    "::" , stringify ! ( mCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSScanner ) ) . mLineNumber as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSScanner ) ,
                    "::" , stringify ! ( mLineNumber ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSScanner ) ) . mLineOffset as *
                    const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSScanner ) ,
                    "::" , stringify ! ( mLineOffset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSScanner ) ) . mTokenLineNumber
                    as * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSScanner ) ,
                    "::" , stringify ! ( mTokenLineNumber ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSScanner ) ) . mTokenLineOffset
                    as * const _ as usize } , 28usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSScanner ) ,
                    "::" , stringify ! ( mTokenLineOffset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSScanner ) ) . mTokenOffset as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSScanner ) ,
                    "::" , stringify ! ( mTokenOffset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSScanner ) ) . mRecordStartOffset
                    as * const _ as usize } , 36usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSScanner ) ,
                    "::" , stringify ! ( mRecordStartOffset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSScanner ) ) . mEOFCharacters as
                    * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSScanner ) ,
                    "::" , stringify ! ( mEOFCharacters ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSScanner ) ) . mReporter as *
                    const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSScanner ) ,
                    "::" , stringify ! ( mReporter ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSScanner ) ) . mRecording as *
                    const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSScanner ) ,
                    "::" , stringify ! ( mRecording ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSScanner ) ) . mSeenBadToken as *
                    const _ as usize } , 57usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSScanner ) ,
                    "::" , stringify ! ( mSeenBadToken ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSScanner ) ) .
                    mSeenVariableReference as * const _ as usize } , 58usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSScanner ) ,
                    "::" , stringify ! ( mSeenVariableReference ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct PRThread {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsAutoOwningThread {
        pub mThread: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_nsAutoOwningThread() {
        assert_eq!(::std::mem::size_of::<nsAutoOwningThread>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsAutoOwningThread )
                   ));
        assert_eq! (::std::mem::align_of::<nsAutoOwningThread>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsAutoOwningThread ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAutoOwningThread ) ) . mThread as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAutoOwningThread
                    ) , "::" , stringify ! ( mThread ) ));
    }
    impl Clone for nsAutoOwningThread {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsAutoRefCnt {
        pub mValue: root::nsrefcnt,
    }
    pub const nsAutoRefCnt_isThreadSafe: bool = false;
    #[test]
    fn bindgen_test_layout_nsAutoRefCnt() {
        assert_eq!(::std::mem::size_of::<nsAutoRefCnt>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsAutoRefCnt ) ));
        assert_eq! (::std::mem::align_of::<nsAutoRefCnt>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsAutoRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAutoRefCnt ) ) . mValue as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAutoRefCnt ) ,
                    "::" , stringify ! ( mValue ) ));
    }
    impl Clone for nsAutoRefCnt {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct RefPtr<T> {
        pub mRawPtr: *mut T,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    pub type RefPtr_element_type<T> = T;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RefPtr_Proxy {
    }
    pub type RefPtr_Proxy_member_function = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RefPtr_ConstRemovingRefPtrTraits {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSContext {
        _unused: [u8; 0],
    }
    pub mod JS {
        #[allow(unused_imports)]
        use self::super::super::root;
        /// JS::Value is the interface for a single JavaScript Engine value.  A few
        /// general notes on JS::Value:
        ///
        /// - JS::Value has setX() and isX() members for X in
        ///
        /// { Int32, Double, String, Symbol, Boolean, Undefined, Null, Object, Magic }
        ///
        /// JS::Value also contains toX() for each of the non-singleton types.
        ///
        /// - Magic is a singleton type whose payload contains either a JSWhyMagic "reason" for
        /// the magic value or a uint32_t value. By providing JSWhyMagic values when
        /// creating and checking for magic values, it is possible to assert, at
        /// runtime, that only magic values with the expected reason flow through a
        /// particular value. For example, if cx->exception has a magic value, the
        /// reason must be JS_GENERATOR_CLOSING.
        ///
        /// - The JS::Value operations are preferred.  The JSVAL_* operations remain for
        /// compatibility; they may be removed at some point.  These operations mostly
        /// provide similar functionality.  But there are a few key differences.  One
        /// is that JS::Value gives null a separate type.
        /// Also, to help prevent mistakenly boxing a nullable JSObject* as an object,
        /// Value::setObject takes a JSObject&. (Conversely, Value::toObject returns a
        /// JSObject&.)  A convenience member Value::setObjectOrNull is provided.
        ///
        /// - JSVAL_VOID is the same as the singleton value of the Undefined type.
        ///
        /// - Note that JS::Value is 8 bytes on 32 and 64-bit architectures. Thus, on
        /// 32-bit user code should avoid copying jsval/JS::Value as much as possible,
        /// preferring to pass by const Value&.
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct Value {
            pub data: root::JS::Value_layout,
        }
        pub type Value_PayloadType = u64;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct Value_layout {
            pub asBits: root::__BindgenUnionField<u64>,
            pub debugView: root::__BindgenUnionField<root::JS::Value_layout__bindgen_ty_1>,
            pub s: root::__BindgenUnionField<root::JS::Value_layout__bindgen_ty_2>,
            pub asDouble: root::__BindgenUnionField<f64>,
            pub asPtr: root::__BindgenUnionField<*mut ::std::os::raw::c_void>,
            pub asWord: root::__BindgenUnionField<usize>,
            pub asUIntPtr: root::__BindgenUnionField<usize>,
            pub bindgen_union_field: u64,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct Value_layout__bindgen_ty_1 {
            pub _bitfield_1: u64,
            pub __bindgen_align: [u64; 0usize],
        }
        #[test]
        fn bindgen_test_layout_Value_layout__bindgen_ty_1() {
            assert_eq!(::std::mem::size_of::<Value_layout__bindgen_ty_1>() ,
                       8usize , concat ! (
                       "Size of: " , stringify ! ( Value_layout__bindgen_ty_1
                       ) ));
            assert_eq! (::std::mem::align_of::<Value_layout__bindgen_ty_1>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! (
                        Value_layout__bindgen_ty_1 ) ));
        }
        impl Clone for Value_layout__bindgen_ty_1 {
            fn clone(&self) -> Self { *self }
        }
        impl Value_layout__bindgen_ty_1 {
            #[inline]
            pub fn payload47(&self) -> u64 {
                let mut unit_field_val: u64 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u64 as *mut u8,
                                                    ::std::mem::size_of::<u64>())
                };
                let mask = 140737488355327u64 as u64;
                let val = (unit_field_val & mask) >> 0usize;
                unsafe { ::std::mem::transmute(val as u64) }
            }
            #[inline]
            pub fn set_payload47(&mut self, val: u64) {
                let mask = 140737488355327u64 as u64;
                let val = val as u64 as u64;
                let mut unit_field_val: u64 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u64 as *mut u8,
                                                    ::std::mem::size_of::<u64>())
                };
                unit_field_val &= !mask;
                unit_field_val |= (val << 0usize) & mask;
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                        *const _ as *const u8,
                                                    &mut self._bitfield_1 as
                                                        *mut _ as *mut u8,
                                                    ::std::mem::size_of::<u64>());
                }
            }
            #[inline]
            pub fn tag(&self) -> root::JSValueTag {
                let mut unit_field_val: u64 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u64 as *mut u8,
                                                    ::std::mem::size_of::<u64>())
                };
                let mask = 18446603336221196288u64 as u64;
                let val = (unit_field_val & mask) >> 47usize;
                unsafe { ::std::mem::transmute(val as u32) }
            }
            #[inline]
            pub fn set_tag(&mut self, val: root::JSValueTag) {
                let mask = 18446603336221196288u64 as u64;
                let val = val as u32 as u64;
                let mut unit_field_val: u64 =
                    unsafe { ::std::mem::uninitialized() };
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as
                                                        *const _ as *const u8,
                                                    &mut unit_field_val as
                                                        *mut u64 as *mut u8,
                                                    ::std::mem::size_of::<u64>())
                };
                unit_field_val &= !mask;
                unit_field_val |= (val << 47usize) & mask;
                unsafe {
                    ::std::ptr::copy_nonoverlapping(&unit_field_val as
                                                        *const _ as *const u8,
                                                    &mut self._bitfield_1 as
                                                        *mut _ as *mut u8,
                                                    ::std::mem::size_of::<u64>());
                }
            }
            #[inline]
            pub fn new_bitfield_1(payload47: u64, tag: root::JSValueTag)
             -> u64 {
                ({
                     ({ 0 } |
                          ((payload47 as u64 as u64) << 0usize) &
                              (140737488355327u64 as u64))
                 } |
                     ((tag as u32 as u64) << 47usize) &
                         (18446603336221196288u64 as u64))
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct Value_layout__bindgen_ty_2 {
            pub payload: root::JS::Value_layout__bindgen_ty_2__bindgen_ty_1,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct Value_layout__bindgen_ty_2__bindgen_ty_1 {
            pub i32: root::__BindgenUnionField<i32>,
            pub u32: root::__BindgenUnionField<u32>,
            pub why: root::__BindgenUnionField<root::JSWhyMagic>,
            pub bindgen_union_field: u32,
        }
        #[test]
        fn bindgen_test_layout_Value_layout__bindgen_ty_2__bindgen_ty_1() {
            assert_eq!(::std::mem::size_of::<Value_layout__bindgen_ty_2__bindgen_ty_1>()
                       , 4usize , concat ! (
                       "Size of: " , stringify ! (
                       Value_layout__bindgen_ty_2__bindgen_ty_1 ) ));
            assert_eq! (::std::mem::align_of::<Value_layout__bindgen_ty_2__bindgen_ty_1>()
                        , 4usize , concat ! (
                        "Alignment of " , stringify ! (
                        Value_layout__bindgen_ty_2__bindgen_ty_1 ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const Value_layout__bindgen_ty_2__bindgen_ty_1
                        ) ) . i32 as * const _ as usize } , 0usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        Value_layout__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                        stringify ! ( i32 ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const Value_layout__bindgen_ty_2__bindgen_ty_1
                        ) ) . u32 as * const _ as usize } , 0usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        Value_layout__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                        stringify ! ( u32 ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const Value_layout__bindgen_ty_2__bindgen_ty_1
                        ) ) . why as * const _ as usize } , 0usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        Value_layout__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                        stringify ! ( why ) ));
        }
        impl Clone for Value_layout__bindgen_ty_2__bindgen_ty_1 {
            fn clone(&self) -> Self { *self }
        }
        #[test]
        fn bindgen_test_layout_Value_layout__bindgen_ty_2() {
            assert_eq!(::std::mem::size_of::<Value_layout__bindgen_ty_2>() ,
                       4usize , concat ! (
                       "Size of: " , stringify ! ( Value_layout__bindgen_ty_2
                       ) ));
            assert_eq! (::std::mem::align_of::<Value_layout__bindgen_ty_2>() ,
                        4usize , concat ! (
                        "Alignment of " , stringify ! (
                        Value_layout__bindgen_ty_2 ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout__bindgen_ty_2 ) ) .
                        payload as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        Value_layout__bindgen_ty_2 ) , "::" , stringify ! (
                        payload ) ));
        }
        impl Clone for Value_layout__bindgen_ty_2 {
            fn clone(&self) -> Self { *self }
        }
        #[test]
        fn bindgen_test_layout_Value_layout() {
            assert_eq!(::std::mem::size_of::<Value_layout>() , 8usize , concat
                       ! ( "Size of: " , stringify ! ( Value_layout ) ));
            assert_eq! (::std::mem::align_of::<Value_layout>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( Value_layout ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout ) ) . asBits as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value_layout )
                        , "::" , stringify ! ( asBits ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout ) ) . debugView as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value_layout )
                        , "::" , stringify ! ( debugView ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout ) ) . s as * const _
                        as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value_layout )
                        , "::" , stringify ! ( s ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout ) ) . asDouble as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value_layout )
                        , "::" , stringify ! ( asDouble ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout ) ) . asPtr as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value_layout )
                        , "::" , stringify ! ( asPtr ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout ) ) . asWord as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value_layout )
                        , "::" , stringify ! ( asWord ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout ) ) . asUIntPtr as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value_layout )
                        , "::" , stringify ! ( asUIntPtr ) ));
        }
        impl Clone for Value_layout {
            fn clone(&self) -> Self { *self }
        }
        #[test]
        fn bindgen_test_layout_Value() {
            assert_eq!(::std::mem::size_of::<Value>() , 8usize , concat ! (
                       "Size of: " , stringify ! ( Value ) ));
            assert_eq! (::std::mem::align_of::<Value>() , 8usize , concat ! (
                        "Alignment of " , stringify ! ( Value ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value ) ) . data as * const _ as
                        usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value ) , "::"
                        , stringify ! ( data ) ));
        }
        impl Clone for Value {
            fn clone(&self) -> Self { *self }
        }
        /// Local variable of type T whose value is always rooted. This is typically
        /// used for local variables, or for non-rooted values being passed to a
        /// function that requires a handle, e.g. Foo(Root<T>(cx, x)).
        ///
        /// If you want to add additional methods to Rooted for a specific
        /// specialization, define a RootedBase<T> specialization containing them.
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Rooted {
        }
        pub type Rooted_ElementType<T> = T;
        pub type RootedObject = [u64; 3usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DeletePolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct FreePolicy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_FreePolicy() {
            assert_eq!(::std::mem::size_of::<FreePolicy>() , 1usize , concat !
                       ( "Size of: " , stringify ! ( FreePolicy ) ));
            assert_eq! (::std::mem::align_of::<FreePolicy>() , 1usize , concat
                        ! ( "Alignment of " , stringify ! ( FreePolicy ) ));
        }
        impl Clone for FreePolicy {
            fn clone(&self) -> Self { *self }
        }
        /// The Heap<T> class is a heap-stored reference to a JS GC thing. All members of
        /// heap classes that refer to GC things should use Heap<T> (or possibly
        /// TenuredHeap<T>, described below).
        ///
        /// Heap<T> is an abstraction that hides some of the complexity required to
        /// maintain GC invariants for the contained reference. It uses operator
        /// overloading to provide a normal pointer interface, but notifies the GC every
        /// time the value it contains is updated. This is necessary for generational GC,
        /// which keeps track of all pointers into the nursery.
        ///
        /// Heap<T> instances must be traced when their containing object is traced to
        /// keep the pointed-to GC thing alive.
        ///
        /// Heap<T> objects should only be used on the heap. GC references stored on the
        /// C/C++ stack must use Rooted/Handle/MutableHandle instead.
        ///
        /// Type T must be a public GC pointer type.
        #[repr(C)]
        #[derive(Debug)]
        pub struct Heap<T> {
            pub ptr: T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type Heap_ElementType<T> = T;
        pub mod dbg {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug)]
            pub struct GarbageCollectionEvent {
                pub majorGCNumber_: u64,
                pub reason: *const ::std::os::raw::c_char,
                pub nonincrementalReason: *const ::std::os::raw::c_char,
                pub collections: [u64; 5usize],
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct GarbageCollectionEvent_Collection {
                pub startTimestamp: root::mozilla::TimeStamp,
                pub endTimestamp: root::mozilla::TimeStamp,
            }
            #[test]
            fn bindgen_test_layout_GarbageCollectionEvent_Collection() {
                assert_eq!(::std::mem::size_of::<GarbageCollectionEvent_Collection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           GarbageCollectionEvent_Collection ) ));
                assert_eq! (::std::mem::align_of::<GarbageCollectionEvent_Collection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            GarbageCollectionEvent_Collection ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const GarbageCollectionEvent_Collection
                            ) ) . startTimestamp as * const _ as usize } ,
                            0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            GarbageCollectionEvent_Collection ) , "::" ,
                            stringify ! ( startTimestamp ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const GarbageCollectionEvent_Collection
                            ) ) . endTimestamp as * const _ as usize } ,
                            8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            GarbageCollectionEvent_Collection ) , "::" ,
                            stringify ! ( endTimestamp ) ));
            }
            impl Clone for GarbageCollectionEvent_Collection {
                fn clone(&self) -> Self { *self }
            }
            pub type GarbageCollectionEvent_Ptr =
                root::mozilla::UniquePtr<root::JS::dbg::GarbageCollectionEvent>;
            #[test]
            fn bindgen_test_layout_GarbageCollectionEvent() {
                assert_eq!(::std::mem::size_of::<GarbageCollectionEvent>() ,
                           64usize , concat ! (
                           "Size of: " , stringify ! ( GarbageCollectionEvent
                           ) ));
                assert_eq! (::std::mem::align_of::<GarbageCollectionEvent>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            GarbageCollectionEvent ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GarbageCollectionEvent ) ) .
                            majorGCNumber_ as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GarbageCollectionEvent ) , "::" , stringify ! (
                            majorGCNumber_ ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GarbageCollectionEvent ) ) .
                            reason as * const _ as usize } , 8usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            GarbageCollectionEvent ) , "::" , stringify ! (
                            reason ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GarbageCollectionEvent ) ) .
                            nonincrementalReason as * const _ as usize } ,
                            16usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            GarbageCollectionEvent ) , "::" , stringify ! (
                            nonincrementalReason ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GarbageCollectionEvent ) ) .
                            collections as * const _ as usize } , 24usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GarbageCollectionEvent ) , "::" , stringify ! (
                            collections ) ));
            }
            #[repr(C)]
            pub struct AutoEntryMonitor__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct AutoEntryMonitor {
                pub vtable_: *const AutoEntryMonitor__bindgen_vtable,
                pub cx_: *mut root::JSContext,
                pub savedMonitor_: *mut root::JS::dbg::AutoEntryMonitor,
            }
            #[test]
            fn bindgen_test_layout_AutoEntryMonitor() {
                assert_eq!(::std::mem::size_of::<AutoEntryMonitor>() , 24usize
                           , concat ! (
                           "Size of: " , stringify ! ( AutoEntryMonitor ) ));
                assert_eq! (::std::mem::align_of::<AutoEntryMonitor>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! ( AutoEntryMonitor )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AutoEntryMonitor ) ) . cx_ as
                            * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            AutoEntryMonitor ) , "::" , stringify ! ( cx_ )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const AutoEntryMonitor ) ) .
                            savedMonitor_ as * const _ as usize } , 16usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            AutoEntryMonitor ) , "::" , stringify ! (
                            savedMonitor_ ) ));
            }
        }
        /// The TenuredHeap<T> class is similar to the Heap<T> class above in that it
        /// encapsulates the GC concerns of an on-heap reference to a JS object. However,
        /// it has two important differences:
        ///
        /// 1) Pointers which are statically known to only reference "tenured" objects
        /// can avoid the extra overhead of SpiderMonkey's write barriers.
        ///
        /// 2) Objects in the "tenured" heap have stronger alignment restrictions than
        /// those in the "nursery", so it is possible to store flags in the lower
        /// bits of pointers known to be tenured. TenuredHeap wraps a normal tagged
        /// pointer with a nice API for accessing the flag bits and adds various
        /// assertions to ensure that it is not mis-used.
        ///
        /// GC things are said to be "tenured" when they are located in the long-lived
        /// heap: e.g. they have gained tenure as an object by surviving past at least
        /// one GC. For performance, SpiderMonkey allocates some things which are known
        /// to normally be long lived directly into the tenured generation; for example,
        /// global objects. Additionally, SpiderMonkey does not visit individual objects
        /// when deleting non-tenured objects, so object with finalizers are also always
        /// tenured; for instance, this includes most DOM objects.
        ///
        /// The considerations to keep in mind when using a TenuredHeap<T> vs a normal
        /// Heap<T> are:
        ///
        /// - It is invalid for a TenuredHeap<T> to refer to a non-tenured thing.
        /// - It is however valid for a Heap<T> to refer to a tenured thing.
        /// - It is not possible to store flag bits in a Heap<T>.
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TenuredHeap {
            pub bits: usize,
        }
        pub type TenuredHeap_ElementType<T> = T;
        pub const TenuredHeap_maskBits: root::JS::TenuredHeap__bindgen_ty_1 =
            TenuredHeap__bindgen_ty_1::maskBits;
        pub const TenuredHeap_flagsMask: root::JS::TenuredHeap__bindgen_ty_1 =
            TenuredHeap__bindgen_ty_1::maskBits;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum TenuredHeap__bindgen_ty_1 { maskBits = 0, }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ConstUTF8CharsZ {
            pub data_: *const ::std::os::raw::c_char,
        }
        pub type ConstUTF8CharsZ_CharT = ::std::os::raw::c_uchar;
        #[test]
        fn bindgen_test_layout_ConstUTF8CharsZ() {
            assert_eq!(::std::mem::size_of::<ConstUTF8CharsZ>() , 8usize ,
                       concat ! (
                       "Size of: " , stringify ! ( ConstUTF8CharsZ ) ));
            assert_eq! (::std::mem::align_of::<ConstUTF8CharsZ>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ConstUTF8CharsZ ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ConstUTF8CharsZ ) ) . data_ as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( ConstUTF8CharsZ
                        ) , "::" , stringify ! ( data_ ) ));
        }
        impl Clone for ConstUTF8CharsZ {
            fn clone(&self) -> Self { *self }
        }
        /// This class can be used to store a pointer to the youngest frame of a saved
        /// stack in the specified JSContext. This reference will be picked up by any new
        /// calls performed until the class is destroyed, with the specified asyncCause,
        /// that must not be empty.
        ///
        /// Any stack capture initiated during these new calls will go through the async
        /// stack instead of the current stack.
        ///
        /// Capturing the stack before a new call is performed will not be affected.
        ///
        /// The provided chain of SavedFrame objects can live in any compartment,
        /// although it will be copied to the compartment where the stack is captured.
        ///
        /// See also `js/src/doc/SavedFrame/SavedFrame.md` for documentation on async
        /// stack frames.
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoSetAsyncStackForNewCalls {
            pub cx: *mut root::JSContext,
            pub oldAsyncStack: root::JS::RootedObject,
            pub oldAsyncCause: *const ::std::os::raw::c_char,
            pub oldAsyncCallIsExplicit: bool,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum AutoSetAsyncStackForNewCalls_AsyncCallKind {
            IMPLICIT = 0,
            EXPLICIT = 1,
        }
        #[test]
        fn bindgen_test_layout_AutoSetAsyncStackForNewCalls() {
            assert_eq!(::std::mem::size_of::<AutoSetAsyncStackForNewCalls>() ,
                       48usize , concat ! (
                       "Size of: " , stringify ! (
                       AutoSetAsyncStackForNewCalls ) ));
            assert_eq! (::std::mem::align_of::<AutoSetAsyncStackForNewCalls>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        AutoSetAsyncStackForNewCalls ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AutoSetAsyncStackForNewCalls ) )
                        . cx as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        AutoSetAsyncStackForNewCalls ) , "::" , stringify ! (
                        cx ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AutoSetAsyncStackForNewCalls ) )
                        . oldAsyncStack as * const _ as usize } , 8usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        AutoSetAsyncStackForNewCalls ) , "::" , stringify ! (
                        oldAsyncStack ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AutoSetAsyncStackForNewCalls ) )
                        . oldAsyncCause as * const _ as usize } , 32usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        AutoSetAsyncStackForNewCalls ) , "::" , stringify ! (
                        oldAsyncCause ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AutoSetAsyncStackForNewCalls ) )
                        . oldAsyncCallIsExplicit as * const _ as usize } ,
                        40usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        AutoSetAsyncStackForNewCalls ) , "::" , stringify ! (
                        oldAsyncCallIsExplicit ) ));
        }
        pub type WarningReporter =
            ::std::option::Option<unsafe extern "C" fn(cx:
                                                           *mut root::JSContext,
                                                       report:
                                                           *mut root::JSErrorReport)>;
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoHideScriptedCaller {
            pub mContext: *mut root::JSContext,
            pub _mCheckNotUsedAsTemporary: root::mozilla::detail::GuardObjectNotificationReceiver,
        }
        #[test]
        fn bindgen_test_layout_AutoHideScriptedCaller() {
            assert_eq!(::std::mem::size_of::<AutoHideScriptedCaller>() ,
                       16usize , concat ! (
                       "Size of: " , stringify ! ( AutoHideScriptedCaller )
                       ));
            assert_eq! (::std::mem::align_of::<AutoHideScriptedCaller>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! ( AutoHideScriptedCaller
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AutoHideScriptedCaller ) ) .
                        mContext as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        AutoHideScriptedCaller ) , "::" , stringify ! (
                        mContext ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AutoHideScriptedCaller ) ) .
                        _mCheckNotUsedAsTemporary as * const _ as usize } ,
                        8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        AutoHideScriptedCaller ) , "::" , stringify ! (
                        _mCheckNotUsedAsTemporary ) ));
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSObject {
        _unused: [u8; 0],
    }
    pub mod js {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod gc {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct SystemAllocPolicy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_SystemAllocPolicy() {
            assert_eq!(::std::mem::size_of::<SystemAllocPolicy>() , 1usize ,
                       concat ! (
                       "Size of: " , stringify ! ( SystemAllocPolicy ) ));
            assert_eq! (::std::mem::align_of::<SystemAllocPolicy>() , 1usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( SystemAllocPolicy )
                        ));
        }
        impl Clone for SystemAllocPolicy {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WrappedPtrOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MutableWrappedPtrOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HeapBase {
            pub _address: u8,
        }
        #[repr(C)]
        pub struct SourceHook__bindgen_vtable(::std::os::raw::c_void);
        /// A class of objects that return source code on demand.
        ///
        /// When code is compiled with setSourceIsLazy(true), SpiderMonkey doesn't
        /// retain the source code (and doesn't do lazy bytecode generation). If we ever
        /// need the source code, say, in response to a call to Function.prototype.
        /// toSource or Debugger.Source.prototype.text, then we call the 'load' member
        /// function of the instance of this class that has hopefully been registered
        /// with the runtime, passing the code's URL, and hope that it will be able to
        /// find the source.
        #[repr(C)]
        #[derive(Debug)]
        pub struct SourceHook {
            pub vtable_: *const SourceHook__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_SourceHook() {
            assert_eq!(::std::mem::size_of::<SourceHook>() , 8usize , concat !
                       ( "Size of: " , stringify ! ( SourceHook ) ));
            assert_eq! (::std::mem::align_of::<SourceHook>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( SourceHook ) ));
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSCompartment {
        _unused: [u8; 0],
    }
    /// Describes a single error or warning that occurs in the execution of script.
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSErrorReport {
        pub _base: root::JSErrorBase,
        pub linebuf_: *const u16,
        pub linebufLength_: usize,
        pub tokenOffset_: usize,
        pub notes: root::mozilla::UniquePtr<root::JSErrorNotes>,
        pub flags: ::std::os::raw::c_uint,
        pub exnType: i16,
        pub _bitfield_1: u8,
        pub __bindgen_padding_0: u8,
    }
    #[test]
    fn bindgen_test_layout_JSErrorReport() {
        assert_eq!(::std::mem::size_of::<JSErrorReport>() , 72usize , concat !
                   ( "Size of: " , stringify ! ( JSErrorReport ) ));
        assert_eq! (::std::mem::align_of::<JSErrorReport>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( JSErrorReport ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorReport ) ) . linebuf_ as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorReport ) ,
                    "::" , stringify ! ( linebuf_ ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorReport ) ) . linebufLength_ as
                    * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorReport ) ,
                    "::" , stringify ! ( linebufLength_ ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorReport ) ) . tokenOffset_ as *
                    const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorReport ) ,
                    "::" , stringify ! ( tokenOffset_ ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorReport ) ) . notes as * const
                    _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorReport ) ,
                    "::" , stringify ! ( notes ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorReport ) ) . flags as * const
                    _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorReport ) ,
                    "::" , stringify ! ( flags ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorReport ) ) . exnType as *
                    const _ as usize } , 68usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorReport ) ,
                    "::" , stringify ! ( exnType ) ));
    }
    impl JSErrorReport {
        #[inline]
        pub fn isMuted(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 1u64 as u8;
            let val = (unit_field_val & mask) >> 0usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_isMuted(&mut self, val: bool) {
            let mask = 1u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 0usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn ownsLinebuf_(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 2u64 as u8;
            let val = (unit_field_val & mask) >> 1usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_ownsLinebuf_(&mut self, val: bool) {
            let mask = 2u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 1usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn new_bitfield_1(isMuted: bool, ownsLinebuf_: bool) -> u8 {
            ({ ({ 0 } | ((isMuted as u8 as u8) << 0usize) & (1u64 as u8)) } |
                 ((ownsLinebuf_ as u8 as u8) << 1usize) & (2u64 as u8))
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIWeakReference {
        pub _base: root::nsISupports,
        pub _mWeakRefOwningThread: root::nsAutoOwningThread,
        pub mObject: *mut root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIWeakReference_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIWeakReference() {
        assert_eq!(::std::mem::size_of::<nsIWeakReference>() , 24usize ,
                   concat ! ( "Size of: " , stringify ! ( nsIWeakReference )
                   ));
        assert_eq! (::std::mem::align_of::<nsIWeakReference>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIWeakReference ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIWeakReference ) ) .
                    _mWeakRefOwningThread as * const _ as usize } , 8usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsIWeakReference )
                    , "::" , stringify ! ( _mWeakRefOwningThread ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIWeakReference ) ) . mObject as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIWeakReference )
                    , "::" , stringify ! ( mObject ) ));
    }
    impl Clone for nsIWeakReference {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCOMPtr<T> {
        pub mRawPtr: *mut T,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    pub type nsCOMPtr_element_type<T> = T;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAutoPtr<T> {
        pub mRawPtr: *mut T,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsAutoPtr_Ptr<T> {
        pub mPtr: *mut T,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    pub type nsAutoPtr_element_type<T> = T;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsAutoPtr_Proxy {
    }
    pub type nsAutoPtr_Proxy_member_function = u8;
    pub type PLDHashNumber = u32;
    #[repr(C)]
    #[derive(Debug)]
    pub struct PLDHashTable {
        pub mOps: *const root::PLDHashTableOps,
        pub mHashShift: i16,
        pub mEntrySize: u32,
        pub mEntryCount: u32,
        pub mRemovedCount: u32,
        pub mEntryStore: root::PLDHashTable_EntryStore,
        pub mChecker: root::Checker,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct PLDHashTable_EntryStore {
        pub mEntryStore: *mut ::std::os::raw::c_char,
        pub mGeneration: u32,
    }
    #[test]
    fn bindgen_test_layout_PLDHashTable_EntryStore() {
        assert_eq!(::std::mem::size_of::<PLDHashTable_EntryStore>() , 16usize
                   , concat ! (
                   "Size of: " , stringify ! ( PLDHashTable_EntryStore ) ));
        assert_eq! (::std::mem::align_of::<PLDHashTable_EntryStore>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( PLDHashTable_EntryStore )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_EntryStore ) ) .
                    mEntryStore as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_EntryStore ) , "::" , stringify ! (
                    mEntryStore ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_EntryStore ) ) .
                    mGeneration as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_EntryStore ) , "::" , stringify ! (
                    mGeneration ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct PLDHashTable_Iterator {
        pub mTable: *mut root::PLDHashTable,
        pub mStart: *mut ::std::os::raw::c_char,
        pub mLimit: *mut ::std::os::raw::c_char,
        pub mCurrent: *mut ::std::os::raw::c_char,
        pub mNexts: u32,
        pub mNextsLimit: u32,
        pub mHaveRemoved: bool,
    }
    #[test]
    fn bindgen_test_layout_PLDHashTable_Iterator() {
        assert_eq!(::std::mem::size_of::<PLDHashTable_Iterator>() , 48usize ,
                   concat ! (
                   "Size of: " , stringify ! ( PLDHashTable_Iterator ) ));
        assert_eq! (::std::mem::align_of::<PLDHashTable_Iterator>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( PLDHashTable_Iterator )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_Iterator ) ) . mTable as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_Iterator ) , "::" , stringify ! ( mTable )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_Iterator ) ) . mStart as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_Iterator ) , "::" , stringify ! ( mStart )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_Iterator ) ) . mLimit as
                    * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_Iterator ) , "::" , stringify ! ( mLimit )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_Iterator ) ) . mCurrent
                    as * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_Iterator ) , "::" , stringify ! ( mCurrent )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_Iterator ) ) . mNexts as
                    * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_Iterator ) , "::" , stringify ! ( mNexts )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_Iterator ) ) .
                    mNextsLimit as * const _ as usize } , 36usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_Iterator ) , "::" , stringify ! ( mNextsLimit
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_Iterator ) ) .
                    mHaveRemoved as * const _ as usize } , 40usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_Iterator ) , "::" , stringify ! (
                    mHaveRemoved ) ));
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum PLDHashTable_SearchReason { ForSearchOrRemove = 0, ForAdd = 1, }
    pub const PLDHashTable_kMaxCapacity: u32 = 67108864;
    pub const PLDHashTable_kMinCapacity: u32 = 8;
    pub const PLDHashTable_kMaxInitialLength: u32 = 33554432;
    pub const PLDHashTable_kDefaultInitialLength: u32 = 4;
    pub const PLDHashTable_kHashBits: u32 = 32;
    pub const PLDHashTable_kGoldenRatio: u32 = 2654435769;
    pub const PLDHashTable_kCollisionFlag: root::PLDHashNumber = 1;
    #[test]
    fn bindgen_test_layout_PLDHashTable() {
        assert_eq!(::std::mem::size_of::<PLDHashTable>() , 48usize , concat !
                   ( "Size of: " , stringify ! ( PLDHashTable ) ));
        assert_eq! (::std::mem::align_of::<PLDHashTable>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( PLDHashTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable ) ) . mOps as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTable ) ,
                    "::" , stringify ! ( mOps ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable ) ) . mHashShift as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTable ) ,
                    "::" , stringify ! ( mHashShift ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable ) ) . mEntrySize as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTable ) ,
                    "::" , stringify ! ( mEntrySize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable ) ) . mEntryCount as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTable ) ,
                    "::" , stringify ! ( mEntryCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable ) ) . mRemovedCount as *
                    const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTable ) ,
                    "::" , stringify ! ( mRemovedCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable ) ) . mEntryStore as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTable ) ,
                    "::" , stringify ! ( mEntryStore ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable ) ) . mChecker as *
                    const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTable ) ,
                    "::" , stringify ! ( mChecker ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLDHashTableOps {
        pub hashKey: root::PLDHashHashKey,
        pub matchEntry: root::PLDHashMatchEntry,
        pub moveEntry: root::PLDHashMoveEntry,
        pub clearEntry: root::PLDHashClearEntry,
        pub initEntry: root::PLDHashInitEntry,
    }
    #[test]
    fn bindgen_test_layout_PLDHashTableOps() {
        assert_eq!(::std::mem::size_of::<PLDHashTableOps>() , 40usize , concat
                   ! ( "Size of: " , stringify ! ( PLDHashTableOps ) ));
        assert_eq! (::std::mem::align_of::<PLDHashTableOps>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( PLDHashTableOps ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTableOps ) ) . hashKey as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTableOps ) ,
                    "::" , stringify ! ( hashKey ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTableOps ) ) . matchEntry as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTableOps ) ,
                    "::" , stringify ! ( matchEntry ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTableOps ) ) . moveEntry as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTableOps ) ,
                    "::" , stringify ! ( moveEntry ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTableOps ) ) . clearEntry as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTableOps ) ,
                    "::" , stringify ! ( clearEntry ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTableOps ) ) . initEntry as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTableOps ) ,
                    "::" , stringify ! ( initEntry ) ));
    }
    impl Clone for PLDHashTableOps {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLDHashEntryHdr {
        pub mKeyHash: root::PLDHashNumber,
    }
    #[test]
    fn bindgen_test_layout_PLDHashEntryHdr() {
        assert_eq!(::std::mem::size_of::<PLDHashEntryHdr>() , 4usize , concat
                   ! ( "Size of: " , stringify ! ( PLDHashEntryHdr ) ));
        assert_eq! (::std::mem::align_of::<PLDHashEntryHdr>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( PLDHashEntryHdr ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashEntryHdr ) ) . mKeyHash as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashEntryHdr ) ,
                    "::" , stringify ! ( mKeyHash ) ));
    }
    impl Clone for PLDHashEntryHdr {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct Checker {
        pub mState: u32,
        pub mIsWritable: u32,
    }
    pub const Checker_kIdle: u32 = 0;
    pub const Checker_kRead1: u32 = 1;
    pub const Checker_kReadMax: u32 = 9999;
    pub const Checker_kWrite: u32 = 10000;
    #[test]
    fn bindgen_test_layout_Checker() {
        assert_eq!(::std::mem::size_of::<Checker>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( Checker ) ));
        assert_eq! (::std::mem::align_of::<Checker>() , 4usize , concat ! (
                    "Alignment of " , stringify ! ( Checker ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const Checker ) ) . mState as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( Checker ) , "::" ,
                    stringify ! ( mState ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const Checker ) ) . mIsWritable as * const
                    _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( Checker ) , "::" ,
                    stringify ! ( mIsWritable ) ));
    }
    impl Clone for Checker {
        fn clone(&self) -> Self { *self }
    }
    pub type PLDHashHashKey =
        ::std::option::Option<unsafe extern "C" fn(aKey:
                                                       *const ::std::os::raw::c_void)
                                  -> root::PLDHashNumber>;
    pub type PLDHashMatchEntry =
        ::std::option::Option<unsafe extern "C" fn(aEntry:
                                                       *const root::PLDHashEntryHdr,
                                                   aKey:
                                                       *const ::std::os::raw::c_void)
                                  -> bool>;
    pub type PLDHashMoveEntry =
        ::std::option::Option<unsafe extern "C" fn(aTable:
                                                       *mut root::PLDHashTable,
                                                   aFrom:
                                                       *const root::PLDHashEntryHdr,
                                                   aTo:
                                                       *mut root::PLDHashEntryHdr)>;
    pub type PLDHashClearEntry =
        ::std::option::Option<unsafe extern "C" fn(aTable:
                                                       *mut root::PLDHashTable,
                                                   aEntry:
                                                       *mut root::PLDHashEntryHdr)>;
    pub type PLDHashInitEntry =
        ::std::option::Option<unsafe extern "C" fn(aEntry:
                                                       *mut root::PLDHashEntryHdr,
                                                   aKey:
                                                       *const ::std::os::raw::c_void)>;
    /// hashkey wrapper using T* KeyType
    ///
    /// @see nsTHashtable::EntryType for specification
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPtrHashKey<T> {
        pub _base: root::PLDHashEntryHdr,
        pub mKey: *mut T,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    pub type nsPtrHashKey_KeyType<T> = *mut T;
    pub type nsPtrHashKey_KeyTypePointer<T> = *mut T;
    pub const nsPtrHashKey_ALLOW_MEMMOVE: root::nsPtrHashKey__bindgen_ty_1 =
        nsPtrHashKey__bindgen_ty_1::ALLOW_MEMMOVE;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsPtrHashKey__bindgen_ty_1 { ALLOW_MEMMOVE = 0, }
    /// hashkey wrapper using nsAString KeyType
    ///
    /// @see nsTHashtable::EntryType for specification
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStringHashKey {
        pub _base: root::PLDHashEntryHdr,
        pub mStr: ::nsstring::nsStringRepr,
    }
    pub type nsStringHashKey_KeyType = *const root::nsAString;
    pub type nsStringHashKey_KeyTypePointer = *const root::nsAString;
    pub const nsStringHashKey_ALLOW_MEMMOVE:
              root::nsStringHashKey__bindgen_ty_1 =
        nsStringHashKey__bindgen_ty_1::ALLOW_MEMMOVE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStringHashKey__bindgen_ty_1 { ALLOW_MEMMOVE = 1, }
    #[test]
    fn bindgen_test_layout_nsStringHashKey() {
        assert_eq!(::std::mem::size_of::<nsStringHashKey>() , 24usize , concat
                   ! ( "Size of: " , stringify ! ( nsStringHashKey ) ));
        assert_eq! (::std::mem::align_of::<nsStringHashKey>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStringHashKey ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStringHashKey ) ) . mStr as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStringHashKey ) ,
                    "::" , stringify ! ( mStr ) ));
    }
    /// hashkey wrapper using nsACString KeyType
    ///
    /// @see nsTHashtable::EntryType for specification
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCStringHashKey {
        pub _base: root::PLDHashEntryHdr,
        pub mStr: root::nsCString,
    }
    pub type nsCStringHashKey_KeyType = *const root::nsACString;
    pub type nsCStringHashKey_KeyTypePointer = *const root::nsACString;
    pub const nsCStringHashKey_ALLOW_MEMMOVE:
              root::nsCStringHashKey__bindgen_ty_1 =
        nsCStringHashKey__bindgen_ty_1::ALLOW_MEMMOVE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCStringHashKey__bindgen_ty_1 { ALLOW_MEMMOVE = 1, }
    #[test]
    fn bindgen_test_layout_nsCStringHashKey() {
        assert_eq!(::std::mem::size_of::<nsCStringHashKey>() , 24usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCStringHashKey )
                   ));
        assert_eq! (::std::mem::align_of::<nsCStringHashKey>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCStringHashKey ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCStringHashKey ) ) . mStr as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCStringHashKey )
                    , "::" , stringify ! ( mStr ) ));
    }
    /// hashkey wrapper using nsISupports* KeyType
    ///
    /// @see nsTHashtable::EntryType for specification
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsISupportsHashKey {
        pub _base: root::PLDHashEntryHdr,
        pub mSupports: root::nsCOMPtr<root::nsISupports>,
    }
    pub type nsISupportsHashKey_KeyType = *mut root::nsISupports;
    pub type nsISupportsHashKey_KeyTypePointer = *const root::nsISupports;
    pub const nsISupportsHashKey_ALLOW_MEMMOVE:
              root::nsISupportsHashKey__bindgen_ty_1 =
        nsISupportsHashKey__bindgen_ty_1::ALLOW_MEMMOVE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsISupportsHashKey__bindgen_ty_1 { ALLOW_MEMMOVE = 1, }
    #[test]
    fn bindgen_test_layout_nsISupportsHashKey() {
        assert_eq!(::std::mem::size_of::<nsISupportsHashKey>() , 16usize ,
                   concat ! ( "Size of: " , stringify ! ( nsISupportsHashKey )
                   ));
        assert_eq! (::std::mem::align_of::<nsISupportsHashKey>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsISupportsHashKey ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsISupportsHashKey ) ) . mSupports as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsISupportsHashKey
                    ) , "::" , stringify ! ( mSupports ) ));
    }
    /// hashkey wrapper using refcounted * KeyType
    ///
    /// @see nsTHashtable::EntryType for specification
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsRefPtrHashKey<T> {
        pub _base: root::PLDHashEntryHdr,
        pub mKey: root::RefPtr<T>,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    pub type nsRefPtrHashKey_KeyType<T> = *mut T;
    pub type nsRefPtrHashKey_KeyTypePointer<T> = *mut T;
    pub const nsRefPtrHashKey_ALLOW_MEMMOVE:
              root::nsRefPtrHashKey__bindgen_ty_1 =
        nsRefPtrHashKey__bindgen_ty_1::ALLOW_MEMMOVE;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsRefPtrHashKey__bindgen_ty_1 { ALLOW_MEMMOVE = 0, }
    /// a base class for templated hashtables.
    ///
    /// Clients will rarely need to use this class directly. Check the derived
    /// classes first, to see if they will meet your needs.
    ///
    /// @param EntryType  the templated entry-type class that is managed by the
    /// hashtable. <code>EntryType</code> must extend the following declaration,
    /// and <strong>must not declare any virtual functions or derive from classes
    /// with virtual functions.</strong>  Any vtable pointer would break the
    /// PLDHashTable code.
    /// <pre>   class EntryType : public PLDHashEntryHdr
    /// {
    /// public: or friend nsTHashtable<EntryType>;
    /// // KeyType is what we use when Get()ing or Put()ing this entry
    /// // this should either be a simple datatype (uint32_t, nsISupports*) or
    /// // a const reference (const nsAString&)
    /// typedef something KeyType;
    /// // KeyTypePointer is the pointer-version of KeyType, because
    /// // PLDHashTable.h requires keys to cast to <code>const void*</code>
    /// typedef const something* KeyTypePointer;
    ///
    /// EntryType(KeyTypePointer aKey);
    ///
    /// // A copy or C++11 Move constructor must be defined, even if
    /// // AllowMemMove() == true, otherwise you will cause link errors.
    /// EntryType(const EntryType& aEnt);  // Either this...
    /// EntryType(EntryType&& aEnt);       // ...or this
    ///
    /// // the destructor must be defined... or you will cause link errors!
    /// ~EntryType();
    ///
    /// // KeyEquals(): does this entry match this key?
    /// bool KeyEquals(KeyTypePointer aKey) const;
    ///
    /// // KeyToPointer(): Convert KeyType to KeyTypePointer
    /// static KeyTypePointer KeyToPointer(KeyType aKey);
    ///
    /// // HashKey(): calculate the hash number
    /// static PLDHashNumber HashKey(KeyTypePointer aKey);
    ///
    /// // ALLOW_MEMMOVE can we move this class with memmove(), or do we have
    /// // to use the copy constructor?
    /// enum { ALLOW_MEMMOVE = true/false };
    /// }</pre>
    ///
    /// @see nsInterfaceHashtable
    /// @see nsDataHashtable
    /// @see nsClassHashtable
    /// @author "Benjamin Smedberg <bsmedberg@covad.net>"
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsTHashtable {
    }
    pub type nsTHashtable_fallible_t = root::mozilla::fallible_t;
    /// KeyType is typedef'ed for ease of use.
    pub type nsTHashtable_KeyType = [u8; 0usize];
    /// KeyTypePointer is typedef'ed for ease of use.
    pub type nsTHashtable_KeyTypePointer = [u8; 0usize];
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsTHashtable_Iterator {
        pub _base: root::PLDHashTable_Iterator,
    }
    pub type nsTHashtable_Iterator_Base = root::PLDHashTable_Iterator;
    /// templated hashtable for simple data types
    /// This class manages simple data types that do not need construction or
    /// destruction.
    ///
    /// @param KeyClass a wrapper-class for the hashtable key, see nsHashKeys.h
    /// for a complete specification.
    /// @param DataType the datatype stored in the hashtable,
    /// for example, uint32_t or nsCOMPtr.  If UserDataType is not the same,
    /// DataType must implicitly cast to UserDataType
    /// @param UserDataType the user sees, for example uint32_t or nsISupports*
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsBaseHashtable {
    }
    pub type nsBaseHashtable_fallible_t = root::mozilla::fallible_t;
    pub type nsBaseHashtable_KeyType = [u8; 0usize];
    pub type nsBaseHashtable_EntryType<KeyClass, DataType> =
        root::nsBaseHashtableET<KeyClass, DataType>;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsBaseHashtable_LookupResult<KeyClass, DataType> {
        pub mEntry: *mut root::nsBaseHashtable_EntryType<KeyClass, DataType>,
        pub mTable: *mut u8,
        pub mTableGeneration: u32,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<KeyClass>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<DataType>>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsBaseHashtable_EntryPtr<KeyClass, DataType> {
        pub mEntry: *mut root::nsBaseHashtable_EntryType<KeyClass, DataType>,
        pub mExistingEntry: bool,
        pub mTable: *mut u8,
        pub mTableGeneration: u32,
        pub mDidInitNewEntry: bool,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<KeyClass>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<DataType>>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsBaseHashtable_Iterator {
        pub _base: root::PLDHashTable_Iterator,
    }
    pub type nsBaseHashtable_Iterator_Base = root::PLDHashTable_Iterator;
    /// the private nsTHashtable::EntryType class used by nsBaseHashtable
    /// @see nsTHashtable for the specification of this class
    /// @see nsBaseHashtable for template parameters
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsBaseHashtableET<KeyClass, DataType> {
        pub _base: KeyClass,
        pub mData: DataType,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<KeyClass>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<DataType>>,
    }
    pub type nsBaseHashtableET_KeyType = [u8; 0usize];
    pub type nsBaseHashtableET_KeyTypePointer = [u8; 0usize];
    /// templated hashtable class maps keys to simple datatypes.
    /// See nsBaseHashtable for complete declaration
    /// @param KeyClass a wrapper-class for the hashtable key, see nsHashKeys.h
    /// for a complete specification.
    /// @param DataType the simple datatype being wrapped
    /// @see nsInterfaceHashtable, nsClassHashtable
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDataHashtable {
    }
    pub type nsDataHashtable_BaseClass = u8;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTArrayHeader {
        pub mLength: u32,
        pub _bitfield_1: u32,
    }
    extern "C" {
        #[link_name = "_ZN14nsTArrayHeader9sEmptyHdrE"]
        pub static mut nsTArrayHeader_sEmptyHdr: root::nsTArrayHeader;
    }
    #[test]
    fn bindgen_test_layout_nsTArrayHeader() {
        assert_eq!(::std::mem::size_of::<nsTArrayHeader>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( nsTArrayHeader ) ));
        assert_eq! (::std::mem::align_of::<nsTArrayHeader>() , 4usize , concat
                    ! ( "Alignment of " , stringify ! ( nsTArrayHeader ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsTArrayHeader ) ) . mLength as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsTArrayHeader ) ,
                    "::" , stringify ! ( mLength ) ));
    }
    impl Clone for nsTArrayHeader {
        fn clone(&self) -> Self { *self }
    }
    impl nsTArrayHeader {
        #[inline]
        pub fn mCapacity(&self) -> u32 {
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            let mask = 2147483647u64 as u32;
            let val = (unit_field_val & mask) >> 0usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mCapacity(&mut self, val: u32) {
            let mask = 2147483647u64 as u32;
            let val = val as u32 as u32;
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 0usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u32>());
            }
        }
        #[inline]
        pub fn mIsAutoArray(&self) -> u32 {
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            let mask = 2147483648u64 as u32;
            let val = (unit_field_val & mask) >> 31usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mIsAutoArray(&mut self, val: u32) {
            let mask = 2147483648u64 as u32;
            let val = val as u32 as u32;
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 31usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u32>());
            }
        }
        #[inline]
        pub fn new_bitfield_1(mCapacity: u32, mIsAutoArray: u32) -> u32 {
            ({
                 ({ 0 } |
                      ((mCapacity as u32 as u32) << 0usize) &
                          (2147483647u64 as u32))
             } |
                 ((mIsAutoArray as u32 as u32) << 31usize) &
                     (2147483648u64 as u32))
        }
    }
    pub type nscoord = i32;
    pub type nscolor = u32;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct gfxFontFeature {
        pub mTag: u32,
        pub mValue: u32,
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeature() {
        assert_eq!(::std::mem::size_of::<gfxFontFeature>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( gfxFontFeature ) ));
        assert_eq! (::std::mem::align_of::<gfxFontFeature>() , 4usize , concat
                    ! ( "Alignment of " , stringify ! ( gfxFontFeature ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxFontFeature ) ) . mTag as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( gfxFontFeature ) ,
                    "::" , stringify ! ( mTag ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxFontFeature ) ) . mValue as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( gfxFontFeature ) ,
                    "::" , stringify ! ( mValue ) ));
    }
    impl Clone for gfxFontFeature {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxAlternateValue {
        pub alternate: u32,
        pub value: ::nsstring::nsStringRepr,
    }
    #[test]
    fn bindgen_test_layout_gfxAlternateValue() {
        assert_eq!(::std::mem::size_of::<gfxAlternateValue>() , 24usize ,
                   concat ! ( "Size of: " , stringify ! ( gfxAlternateValue )
                   ));
        assert_eq! (::std::mem::align_of::<gfxAlternateValue>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( gfxAlternateValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxAlternateValue ) ) . alternate as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( gfxAlternateValue )
                    , "::" , stringify ! ( alternate ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxAlternateValue ) ) . value as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( gfxAlternateValue )
                    , "::" , stringify ! ( value ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxFontFeatureValueSet {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mFontFeatureValues: [u64; 6usize],
    }
    pub type gfxFontFeatureValueSet_HasThreadSafeRefCnt =
        root::mozilla::TrueType;
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxFontFeatureValueSet_ValueList {
        pub name: ::nsstring::nsStringRepr,
        pub featureSelectors: root::nsTArray<u32>,
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeatureValueSet_ValueList() {
        assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet_ValueList>() ,
                   24usize , concat ! (
                   "Size of: " , stringify ! (
                   gfxFontFeatureValueSet_ValueList ) ));
        assert_eq! (::std::mem::align_of::<gfxFontFeatureValueSet_ValueList>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    gfxFontFeatureValueSet_ValueList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxFontFeatureValueSet_ValueList ) )
                    . name as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_ValueList ) , "::" , stringify ! (
                    name ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxFontFeatureValueSet_ValueList ) )
                    . featureSelectors as * const _ as usize } , 16usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_ValueList ) , "::" , stringify ! (
                    featureSelectors ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxFontFeatureValueSet_FeatureValues {
        pub alternate: u32,
        pub valuelist: root::nsTArray<root::gfxFontFeatureValueSet_ValueList>,
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeatureValueSet_FeatureValues() {
        assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet_FeatureValues>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   gfxFontFeatureValueSet_FeatureValues ) ));
        assert_eq! (::std::mem::align_of::<gfxFontFeatureValueSet_FeatureValues>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValues ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const gfxFontFeatureValueSet_FeatureValues ) )
                    . alternate as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValues ) , "::" , stringify
                    ! ( alternate ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const gfxFontFeatureValueSet_FeatureValues ) )
                    . valuelist as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValues ) , "::" , stringify
                    ! ( valuelist ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxFontFeatureValueSet_FeatureValueHashKey {
        pub mFamily: ::nsstring::nsStringRepr,
        pub mPropVal: u32,
        pub mName: ::nsstring::nsStringRepr,
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeatureValueSet_FeatureValueHashKey() {
        assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet_FeatureValueHashKey>()
                   , 40usize , concat ! (
                   "Size of: " , stringify ! (
                   gfxFontFeatureValueSet_FeatureValueHashKey ) ));
        assert_eq! (::std::mem::align_of::<gfxFontFeatureValueSet_FeatureValueHashKey>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValueHashKey ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const gfxFontFeatureValueSet_FeatureValueHashKey )
                    ) . mFamily as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValueHashKey ) , "::" ,
                    stringify ! ( mFamily ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const gfxFontFeatureValueSet_FeatureValueHashKey )
                    ) . mPropVal as * const _ as usize } , 16usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValueHashKey ) , "::" ,
                    stringify ! ( mPropVal ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const gfxFontFeatureValueSet_FeatureValueHashKey )
                    ) . mName as * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValueHashKey ) , "::" ,
                    stringify ! ( mName ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxFontFeatureValueSet_FeatureValueHashEntry {
        pub _base: root::PLDHashEntryHdr,
        pub mKey: root::gfxFontFeatureValueSet_FeatureValueHashKey,
        pub mValues: root::nsTArray<u32>,
    }
    pub type gfxFontFeatureValueSet_FeatureValueHashEntry_KeyType =
        *const root::gfxFontFeatureValueSet_FeatureValueHashKey;
    pub type gfxFontFeatureValueSet_FeatureValueHashEntry_KeyTypePointer =
        *const root::gfxFontFeatureValueSet_FeatureValueHashKey;
    pub const gfxFontFeatureValueSet_FeatureValueHashEntry_ALLOW_MEMMOVE:
              root::gfxFontFeatureValueSet_FeatureValueHashEntry__bindgen_ty_1
              =
        gfxFontFeatureValueSet_FeatureValueHashEntry__bindgen_ty_1::ALLOW_MEMMOVE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum gfxFontFeatureValueSet_FeatureValueHashEntry__bindgen_ty_1 {
        ALLOW_MEMMOVE = 1,
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeatureValueSet_FeatureValueHashEntry() {
        assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet_FeatureValueHashEntry>()
                   , 56usize , concat ! (
                   "Size of: " , stringify ! (
                   gfxFontFeatureValueSet_FeatureValueHashEntry ) ));
        assert_eq! (::std::mem::align_of::<gfxFontFeatureValueSet_FeatureValueHashEntry>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValueHashEntry ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const gfxFontFeatureValueSet_FeatureValueHashEntry
                    ) ) . mKey as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValueHashEntry ) , "::" ,
                    stringify ! ( mKey ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const gfxFontFeatureValueSet_FeatureValueHashEntry
                    ) ) . mValues as * const _ as usize } , 48usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValueHashEntry ) , "::" ,
                    stringify ! ( mValues ) ));
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeatureValueSet() {
        assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet>() , 56usize ,
                   concat ! (
                   "Size of: " , stringify ! ( gfxFontFeatureValueSet ) ));
        assert_eq! (::std::mem::align_of::<gfxFontFeatureValueSet>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( gfxFontFeatureValueSet )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxFontFeatureValueSet ) ) . mRefCnt
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet ) , "::" , stringify ! ( mRefCnt )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxFontFeatureValueSet ) ) .
                    mFontFeatureValues as * const _ as usize } , 8usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet ) , "::" , stringify ! (
                    mFontFeatureValues ) ));
    }
    pub type gfxFontVariation = root::mozilla::gfx::FontVariation;
    pub const kGenericFont_NONE: u8 = 0;
    pub const kGenericFont_moz_variable: u8 = 0;
    pub const kGenericFont_moz_fixed: u8 = 1;
    pub const kGenericFont_serif: u8 = 2;
    pub const kGenericFont_sans_serif: u8 = 4;
    pub const kGenericFont_monospace: u8 = 8;
    pub const kGenericFont_cursive: u8 = 16;
    pub const kGenericFont_fantasy: u8 = 32;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsFont {
        pub fontlist: root::mozilla::FontFamilyList,
        pub style: u8,
        pub systemFont: bool,
        pub variantCaps: u8,
        pub variantNumeric: u8,
        pub variantPosition: u8,
        pub variantWidth: u8,
        pub variantLigatures: u16,
        pub variantEastAsian: u16,
        pub variantAlternates: u16,
        pub smoothing: u8,
        pub weight: u16,
        pub stretch: i16,
        pub kerning: u8,
        pub synthesis: u8,
        pub size: root::nscoord,
        pub sizeAdjust: f32,
        pub alternateValues: root::nsTArray<root::gfxAlternateValue>,
        pub featureValueLookup: root::RefPtr<root::gfxFontFeatureValueSet>,
        pub fontFeatureSettings: root::nsTArray<root::gfxFontFeature>,
        pub fontVariationSettings: root::nsTArray<root::gfxFontVariation>,
        pub languageOverride: u32,
    }
    #[test]
    fn bindgen_test_layout_nsFont() {
        assert_eq!(::std::mem::size_of::<nsFont>() , 88usize , concat ! (
                   "Size of: " , stringify ! ( nsFont ) ));
        assert_eq! (::std::mem::align_of::<nsFont>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsFont ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . fontlist as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( fontlist ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . style as * const _ as
                    usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( style ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . systemFont as * const _
                    as usize } , 17usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( systemFont ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . variantCaps as * const _
                    as usize } , 18usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( variantCaps ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . variantNumeric as *
                    const _ as usize } , 19usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( variantNumeric ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . variantPosition as *
                    const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( variantPosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . variantWidth as * const
                    _ as usize } , 21usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( variantWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . variantLigatures as *
                    const _ as usize } , 22usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( variantLigatures ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . variantEastAsian as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( variantEastAsian ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . variantAlternates as *
                    const _ as usize } , 26usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( variantAlternates ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . smoothing as * const _
                    as usize } , 28usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( smoothing ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . weight as * const _ as
                    usize } , 30usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( weight ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . stretch as * const _ as
                    usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( stretch ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . kerning as * const _ as
                    usize } , 34usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( kerning ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . synthesis as * const _
                    as usize } , 35usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( synthesis ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . size as * const _ as
                    usize } , 36usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( size ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . sizeAdjust as * const _
                    as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( sizeAdjust ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . alternateValues as *
                    const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( alternateValues ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . featureValueLookup as *
                    const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( featureValueLookup ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . fontFeatureSettings as *
                    const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( fontFeatureSettings ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . fontVariationSettings as
                    * const _ as usize } , 72usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( fontVariationSettings ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . languageOverride as *
                    const _ as usize } , 80usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( languageOverride ) ));
    }
    /// An array of objects, similar to AutoTArray<T,1> but which is memmovable. It
    /// always has length >= 1.
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleAutoArray<T> {
        pub mFirstElement: T,
        pub mOtherElements: root::nsTArray<T>,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleAutoArray_WithSingleInitialElement {
        WITH_SINGLE_INITIAL_ELEMENT = 0,
    }
    pub const nsStyleUnit_eStyleUnit_MAX: root::nsStyleUnit =
        nsStyleUnit::eStyleUnit_Calc;
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleUnit {
        eStyleUnit_Null = 0,
        eStyleUnit_Normal = 1,
        eStyleUnit_Auto = 2,
        eStyleUnit_None = 3,
        eStyleUnit_Percent = 10,
        eStyleUnit_Factor = 11,
        eStyleUnit_Degree = 12,
        eStyleUnit_Grad = 13,
        eStyleUnit_Radian = 14,
        eStyleUnit_Turn = 15,
        eStyleUnit_FlexFraction = 16,
        eStyleUnit_Coord = 20,
        eStyleUnit_Integer = 30,
        eStyleUnit_Enumerated = 32,
        eStyleUnit_Calc = 40,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleUnion {
        pub mInt: root::__BindgenUnionField<i32>,
        pub mFloat: root::__BindgenUnionField<f32>,
        pub mPointer: root::__BindgenUnionField<*mut ::std::os::raw::c_void>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsStyleUnion() {
        assert_eq!(::std::mem::size_of::<nsStyleUnion>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleUnion ) ));
        assert_eq! (::std::mem::align_of::<nsStyleUnion>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleUnion ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUnion ) ) . mInt as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUnion ) ,
                    "::" , stringify ! ( mInt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUnion ) ) . mFloat as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUnion ) ,
                    "::" , stringify ! ( mFloat ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUnion ) ) . mPointer as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUnion ) ,
                    "::" , stringify ! ( mPointer ) ));
    }
    impl Clone for nsStyleUnion {
        fn clone(&self) -> Self { *self }
    }
    /// Class that hold a single size specification used by the style
    /// system.  The size specification consists of two parts -- a number
    /// and a unit.  The number is an integer, a floating point value, an
    /// nscoord, or undefined, and the unit is an nsStyleUnit.  Checking
    /// the unit is a must before asking for the value in any particular
    /// form.
    /// /
    /// /** <div rustbindgen private accessor="unsafe"></div>
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleCoord {
        mUnit: root::nsStyleUnit,
        mValue: root::nsStyleUnion,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleCoord_CalcValue {
        pub mLength: root::nscoord,
        pub mPercent: f32,
        pub mHasPercent: bool,
    }
    #[test]
    fn bindgen_test_layout_nsStyleCoord_CalcValue() {
        assert_eq!(::std::mem::size_of::<nsStyleCoord_CalcValue>() , 12usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsStyleCoord_CalcValue ) ));
        assert_eq! (::std::mem::align_of::<nsStyleCoord_CalcValue>() , 4usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsStyleCoord_CalcValue )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCoord_CalcValue ) ) . mLength
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleCoord_CalcValue ) , "::" , stringify ! ( mLength )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCoord_CalcValue ) ) . mPercent
                    as * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleCoord_CalcValue ) , "::" , stringify ! ( mPercent )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCoord_CalcValue ) ) .
                    mHasPercent as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleCoord_CalcValue ) , "::" , stringify ! (
                    mHasPercent ) ));
    }
    impl Clone for nsStyleCoord_CalcValue {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleCoord_Calc {
        pub _base: root::nsStyleCoord_CalcValue,
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
    }
    pub type nsStyleCoord_Calc_HasThreadSafeRefCnt = root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsStyleCoord_Calc() {
        assert_eq!(::std::mem::size_of::<nsStyleCoord_Calc>() , 24usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleCoord_Calc )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleCoord_Calc>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleCoord_Calc ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCoord_Calc ) ) . mRefCnt as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleCoord_Calc )
                    , "::" , stringify ! ( mRefCnt ) ));
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleCoord_CoordConstructorType { CoordConstructor = 0, }
    #[test]
    fn bindgen_test_layout_nsStyleCoord() {
        assert_eq!(::std::mem::size_of::<nsStyleCoord>() , 16usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleCoord ) ));
        assert_eq! (::std::mem::align_of::<nsStyleCoord>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleCoord ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCoord ) ) . mUnit as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleCoord ) ,
                    "::" , stringify ! ( mUnit ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCoord ) ) . mValue as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleCoord ) ,
                    "::" , stringify ! ( mValue ) ));
    }
    impl nsStyleCoord {
        #[inline]
        pub unsafe fn get_mUnit(&self) -> &root::nsStyleUnit { &self.mUnit }
        #[inline]
        pub unsafe fn get_mUnit_mut(&mut self) -> &mut root::nsStyleUnit {
            &mut self.mUnit
        }
        #[inline]
        pub unsafe fn get_mValue(&self) -> &root::nsStyleUnion {
            &self.mValue
        }
        #[inline]
        pub unsafe fn get_mValue_mut(&mut self) -> &mut root::nsStyleUnion {
            &mut self.mValue
        }
    }
    /// Class that represents a set of top/right/bottom/left nsStyleCoords.
    /// This is commonly used to hold the widths of the borders, margins,
    /// or paddings of a box.
    /// /
    /// /** <div rustbindgen private accessor="unsafe"></div>
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleSides {
        mUnits: [root::nsStyleUnit; 4usize],
        mValues: [root::nsStyleUnion; 4usize],
    }
    #[test]
    fn bindgen_test_layout_nsStyleSides() {
        assert_eq!(::std::mem::size_of::<nsStyleSides>() , 40usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleSides ) ));
        assert_eq! (::std::mem::align_of::<nsStyleSides>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleSides ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSides ) ) . mUnits as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSides ) ,
                    "::" , stringify ! ( mUnits ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSides ) ) . mValues as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSides ) ,
                    "::" , stringify ! ( mValues ) ));
    }
    impl nsStyleSides {
        #[inline]
        pub unsafe fn get_mUnits(&self) -> &[root::nsStyleUnit; 4usize] {
            &self.mUnits
        }
        #[inline]
        pub unsafe fn get_mUnits_mut(&mut self)
         -> &mut [root::nsStyleUnit; 4usize] {
            &mut self.mUnits
        }
        #[inline]
        pub unsafe fn get_mValues(&self) -> &[root::nsStyleUnion; 4usize] {
            &self.mValues
        }
        #[inline]
        pub unsafe fn get_mValues_mut(&mut self)
         -> &mut [root::nsStyleUnion; 4usize] {
            &mut self.mValues
        }
    }
    /// Class that represents a set of top-left/top-right/bottom-right/bottom-left
    /// nsStyleCoord pairs.  This is used to hold the dimensions of the
    /// corners of a box (for, e.g., border-radius and outline-radius).
    /// /
    /// /** <div rustbindgen private accessor="unsafe"></div>
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleCorners {
        mUnits: [root::nsStyleUnit; 8usize],
        mValues: [root::nsStyleUnion; 8usize],
    }
    #[test]
    fn bindgen_test_layout_nsStyleCorners() {
        assert_eq!(::std::mem::size_of::<nsStyleCorners>() , 72usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleCorners ) ));
        assert_eq! (::std::mem::align_of::<nsStyleCorners>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleCorners ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCorners ) ) . mUnits as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleCorners ) ,
                    "::" , stringify ! ( mUnits ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCorners ) ) . mValues as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleCorners ) ,
                    "::" , stringify ! ( mValues ) ));
    }
    impl nsStyleCorners {
        #[inline]
        pub unsafe fn get_mUnits(&self) -> &[root::nsStyleUnit; 8usize] {
            &self.mUnits
        }
        #[inline]
        pub unsafe fn get_mUnits_mut(&mut self)
         -> &mut [root::nsStyleUnit; 8usize] {
            &mut self.mUnits
        }
        #[inline]
        pub unsafe fn get_mValues(&self) -> &[root::nsStyleUnion; 8usize] {
            &self.mValues
        }
        #[inline]
        pub unsafe fn get_mValues_mut(&mut self)
         -> &mut [root::nsStyleUnion; 8usize] {
            &mut self.mValues
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsCSSSelector {
        _unused: [u8; 0],
    }
    pub const nsChangeHint_nsChangeHint_Empty: root::nsChangeHint =
        nsChangeHint(0);
    pub const nsChangeHint_nsChangeHint_RepaintFrame: root::nsChangeHint =
        nsChangeHint(1);
    pub const nsChangeHint_nsChangeHint_NeedReflow: root::nsChangeHint =
        nsChangeHint(2);
    pub const nsChangeHint_nsChangeHint_ClearAncestorIntrinsics:
              root::nsChangeHint =
        nsChangeHint(4);
    pub const nsChangeHint_nsChangeHint_ClearDescendantIntrinsics:
              root::nsChangeHint =
        nsChangeHint(8);
    pub const nsChangeHint_nsChangeHint_NeedDirtyReflow: root::nsChangeHint =
        nsChangeHint(16);
    pub const nsChangeHint_nsChangeHint_SyncFrameView: root::nsChangeHint =
        nsChangeHint(32);
    pub const nsChangeHint_nsChangeHint_UpdateCursor: root::nsChangeHint =
        nsChangeHint(64);
    pub const nsChangeHint_nsChangeHint_UpdateEffects: root::nsChangeHint =
        nsChangeHint(128);
    pub const nsChangeHint_nsChangeHint_UpdateOpacityLayer: root::nsChangeHint
              =
        nsChangeHint(256);
    pub const nsChangeHint_nsChangeHint_UpdateTransformLayer:
              root::nsChangeHint =
        nsChangeHint(512);
    pub const nsChangeHint_nsChangeHint_ReconstructFrame: root::nsChangeHint =
        nsChangeHint(1024);
    pub const nsChangeHint_nsChangeHint_UpdateOverflow: root::nsChangeHint =
        nsChangeHint(2048);
    pub const nsChangeHint_nsChangeHint_UpdateSubtreeOverflow:
              root::nsChangeHint =
        nsChangeHint(4096);
    pub const nsChangeHint_nsChangeHint_UpdatePostTransformOverflow:
              root::nsChangeHint =
        nsChangeHint(8192);
    pub const nsChangeHint_nsChangeHint_UpdateParentOverflow:
              root::nsChangeHint =
        nsChangeHint(16384);
    pub const nsChangeHint_nsChangeHint_ChildrenOnlyTransform:
              root::nsChangeHint =
        nsChangeHint(32768);
    pub const nsChangeHint_nsChangeHint_RecomputePosition: root::nsChangeHint
              =
        nsChangeHint(65536);
    pub const nsChangeHint_nsChangeHint_UpdateContainingBlock:
              root::nsChangeHint =
        nsChangeHint(131072);
    pub const nsChangeHint_nsChangeHint_BorderStyleNoneChange:
              root::nsChangeHint =
        nsChangeHint(262144);
    pub const nsChangeHint_nsChangeHint_UpdateTextPath: root::nsChangeHint =
        nsChangeHint(524288);
    pub const nsChangeHint_nsChangeHint_SchedulePaint: root::nsChangeHint =
        nsChangeHint(1048576);
    pub const nsChangeHint_nsChangeHint_NeutralChange: root::nsChangeHint =
        nsChangeHint(2097152);
    pub const nsChangeHint_nsChangeHint_InvalidateRenderingObservers:
              root::nsChangeHint =
        nsChangeHint(4194304);
    pub const nsChangeHint_nsChangeHint_ReflowChangesSizeOrPosition:
              root::nsChangeHint =
        nsChangeHint(8388608);
    pub const nsChangeHint_nsChangeHint_UpdateComputedBSize:
              root::nsChangeHint =
        nsChangeHint(16777216);
    pub const nsChangeHint_nsChangeHint_UpdateUsesOpacity: root::nsChangeHint
              =
        nsChangeHint(33554432);
    pub const nsChangeHint_nsChangeHint_UpdateBackgroundPosition:
              root::nsChangeHint =
        nsChangeHint(67108864);
    pub const nsChangeHint_nsChangeHint_AddOrRemoveTransform:
              root::nsChangeHint =
        nsChangeHint(134217728);
    pub const nsChangeHint_nsChangeHint_CSSOverflowChange: root::nsChangeHint
              =
        nsChangeHint(268435456);
    pub const nsChangeHint_nsChangeHint_UpdateWidgetProperties:
              root::nsChangeHint =
        nsChangeHint(536870912);
    pub const nsChangeHint_nsChangeHint_AllHints: root::nsChangeHint =
        nsChangeHint(1073741823);
    impl ::std::ops::BitOr<root::nsChangeHint> for root::nsChangeHint {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self { nsChangeHint(self.0 | other.0) }
    }
    impl ::std::ops::BitOrAssign for root::nsChangeHint {
        #[inline]
        fn bitor_assign(&mut self, rhs: root::nsChangeHint) {
            self.0 |= rhs.0;
        }
    }
    impl ::std::ops::BitAnd<root::nsChangeHint> for root::nsChangeHint {
        type
        Output
        =
        Self;
        #[inline]
        fn bitand(self, other: Self) -> Self {
            nsChangeHint(self.0 & other.0)
        }
    }
    impl ::std::ops::BitAndAssign for root::nsChangeHint {
        #[inline]
        fn bitand_assign(&mut self, rhs: root::nsChangeHint) {
            self.0 &= rhs.0;
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct nsChangeHint(pub u32);
    pub const nsRestyleHint_eRestyle_Self: root::nsRestyleHint =
        nsRestyleHint(1);
    pub const nsRestyleHint_eRestyle_SomeDescendants: root::nsRestyleHint =
        nsRestyleHint(2);
    pub const nsRestyleHint_eRestyle_Subtree: root::nsRestyleHint =
        nsRestyleHint(4);
    pub const nsRestyleHint_eRestyle_LaterSiblings: root::nsRestyleHint =
        nsRestyleHint(8);
    pub const nsRestyleHint_eRestyle_CSSTransitions: root::nsRestyleHint =
        nsRestyleHint(16);
    pub const nsRestyleHint_eRestyle_CSSAnimations: root::nsRestyleHint =
        nsRestyleHint(32);
    pub const nsRestyleHint_eRestyle_StyleAttribute: root::nsRestyleHint =
        nsRestyleHint(64);
    pub const nsRestyleHint_eRestyle_StyleAttribute_Animations:
              root::nsRestyleHint =
        nsRestyleHint(128);
    pub const nsRestyleHint_eRestyle_Force: root::nsRestyleHint =
        nsRestyleHint(256);
    pub const nsRestyleHint_eRestyle_ForceDescendants: root::nsRestyleHint =
        nsRestyleHint(512);
    pub const nsRestyleHint_eRestyle_AllHintsWithAnimations:
              root::nsRestyleHint =
        nsRestyleHint(176);
    impl ::std::ops::BitOr<root::nsRestyleHint> for root::nsRestyleHint {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            nsRestyleHint(self.0 | other.0)
        }
    }
    impl ::std::ops::BitOrAssign for root::nsRestyleHint {
        #[inline]
        fn bitor_assign(&mut self, rhs: root::nsRestyleHint) {
            self.0 |= rhs.0;
        }
    }
    impl ::std::ops::BitAnd<root::nsRestyleHint> for root::nsRestyleHint {
        type
        Output
        =
        Self;
        #[inline]
        fn bitand(self, other: Self) -> Self {
            nsRestyleHint(self.0 & other.0)
        }
    }
    impl ::std::ops::BitAndAssign for root::nsRestyleHint {
        #[inline]
        fn bitand_assign(&mut self, rhs: root::nsRestyleHint) {
            self.0 &= rhs.0;
        }
    }
    #[repr(C)]
    /// |nsRestyleHint| is a bitfield for the result of
    /// |HasStateDependentStyle| and |HasAttributeDependentStyle|.  When no
    /// restyling is necessary, use |nsRestyleHint(0)|.
    ///
    /// Without eRestyle_Force or eRestyle_ForceDescendants, the restyling process
    /// can stop processing at a frame when it detects no style changes and it is
    /// known that the styles of the subtree beneath it will not change, leaving
    /// the old style context on the frame.  eRestyle_Force can be used to skip this
    /// optimization on a frame, and to force its new style context to be used.
    ///
    /// Similarly, eRestyle_ForceDescendants will cause the frame and all of its
    /// descendants to be traversed and for the new style contexts that are created
    /// to be set on the frames.
    ///
    /// NOTE: When adding new restyle hints, please also add them to
    /// RestyleManager::RestyleHintToString.
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct nsRestyleHint(pub u32);
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleFont {
        pub mFont: root::nsFont,
        pub mSize: root::nscoord,
        pub mGenericID: u8,
        pub mScriptLevel: i8,
        pub mMathVariant: u8,
        pub mMathDisplay: u8,
        pub mMinFontSizeRatio: u8,
        pub mExplicitLanguage: bool,
        pub mAllowZoom: bool,
        pub mScriptUnconstrainedSize: root::nscoord,
        pub mScriptMinSize: root::nscoord,
        pub mScriptSizeMultiplier: f32,
        pub mLanguage: root::nsCOMPtr<root::nsIAtom>,
    }
    pub const nsStyleFont_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleFont() {
        assert_eq!(::std::mem::size_of::<nsStyleFont>() , 120usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleFont ) ));
        assert_eq! (::std::mem::align_of::<nsStyleFont>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleFont ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mFont as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mFont ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mSize as * const _
                    as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mGenericID as *
                    const _ as usize } , 92usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mGenericID ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mScriptLevel as *
                    const _ as usize } , 93usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mScriptLevel ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mMathVariant as *
                    const _ as usize } , 94usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mMathVariant ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mMathDisplay as *
                    const _ as usize } , 95usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mMathDisplay ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mMinFontSizeRatio
                    as * const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mMinFontSizeRatio ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mExplicitLanguage
                    as * const _ as usize } , 97usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mExplicitLanguage ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mAllowZoom as *
                    const _ as usize } , 98usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mAllowZoom ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) .
                    mScriptUnconstrainedSize as * const _ as usize } ,
                    100usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mScriptUnconstrainedSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mScriptMinSize as *
                    const _ as usize } , 104usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mScriptMinSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) .
                    mScriptSizeMultiplier as * const _ as usize } , 108usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mScriptSizeMultiplier ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mLanguage as *
                    const _ as usize } , 112usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mLanguage ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleColor {
        pub mColor: root::nscolor,
    }
    pub const nsStyleColor_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleColor() {
        assert_eq!(::std::mem::size_of::<nsStyleColor>() , 4usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleColor ) ));
        assert_eq! (::std::mem::align_of::<nsStyleColor>() , 4usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColor ) ) . mColor as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColor ) ,
                    "::" , stringify ! ( mColor ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleList {
        pub mListStylePosition: u8,
        pub mListStyleImage: root::RefPtr<root::nsStyleImageRequest>,
        pub mCounterStyle: root::mozilla::CounterStylePtr,
        pub mQuotes: root::RefPtr<root::nsStyleQuoteValues>,
        pub mImageRegion: root::nsRect,
    }
    pub const nsStyleList_kHasFinishStyle: bool = true;
    extern "C" {
        #[link_name = "_ZN11nsStyleList14sInitialQuotesE"]
        pub static mut nsStyleList_sInitialQuotes:
                   root::mozilla::StaticRefPtr<root::nsStyleQuoteValues>;
    }
    extern "C" {
        #[link_name = "_ZN11nsStyleList11sNoneQuotesE"]
        pub static mut nsStyleList_sNoneQuotes:
                   root::mozilla::StaticRefPtr<root::nsStyleQuoteValues>;
    }
    #[test]
    fn bindgen_test_layout_nsStyleList() {
        assert_eq!(::std::mem::size_of::<nsStyleList>() , 48usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleList ) ));
        assert_eq! (::std::mem::align_of::<nsStyleList>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleList ) ) . mListStylePosition
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleList ) ,
                    "::" , stringify ! ( mListStylePosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleList ) ) . mListStyleImage as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleList ) ,
                    "::" , stringify ! ( mListStyleImage ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleList ) ) . mCounterStyle as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleList ) ,
                    "::" , stringify ! ( mCounterStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleList ) ) . mQuotes as * const
                    _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleList ) ,
                    "::" , stringify ! ( mQuotes ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleList ) ) . mImageRegion as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleList ) ,
                    "::" , stringify ! ( mImageRegion ) ));
    }
    #[test]
    fn __bindgen_test_layout_StaticRefPtr_open0_nsStyleQuoteValues_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::StaticRefPtr<root::nsStyleQuoteValues>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::StaticRefPtr<root::nsStyleQuoteValues> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::StaticRefPtr<root::nsStyleQuoteValues>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::StaticRefPtr<root::nsStyleQuoteValues> ) ));
    }
    #[test]
    fn __bindgen_test_layout_StaticRefPtr_open0_nsStyleQuoteValues_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::mozilla::StaticRefPtr<root::nsStyleQuoteValues>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::StaticRefPtr<root::nsStyleQuoteValues> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::StaticRefPtr<root::nsStyleQuoteValues>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::StaticRefPtr<root::nsStyleQuoteValues> ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleText {
        pub mTextAlign: u8,
        pub mTextAlignLast: u8,
        pub _bitfield_1: u8,
        pub mTextJustify: root::mozilla::StyleTextJustify,
        pub mTextTransform: u8,
        pub mWhiteSpace: root::mozilla::StyleWhiteSpace,
        pub mWordBreak: u8,
        pub mOverflowWrap: u8,
        pub mHyphens: root::mozilla::StyleHyphens,
        pub mRubyAlign: u8,
        pub mRubyPosition: u8,
        pub mTextSizeAdjust: u8,
        pub mTextCombineUpright: u8,
        pub mControlCharacterVisibility: u8,
        pub mTextEmphasisPosition: u8,
        pub mTextEmphasisStyle: u8,
        pub mTextRendering: u8,
        pub mTextEmphasisColor: root::mozilla::StyleComplexColor,
        pub mWebkitTextFillColor: root::mozilla::StyleComplexColor,
        pub mWebkitTextStrokeColor: root::mozilla::StyleComplexColor,
        pub mTabSize: root::nsStyleCoord,
        pub mWordSpacing: root::nsStyleCoord,
        pub mLetterSpacing: root::nsStyleCoord,
        pub mLineHeight: root::nsStyleCoord,
        pub mTextIndent: root::nsStyleCoord,
        pub mWebkitTextStrokeWidth: root::nscoord,
        pub mTextShadow: root::RefPtr<root::nsCSSShadowArray>,
        pub mTextEmphasisStyleString: ::nsstring::nsStringRepr,
    }
    pub const nsStyleText_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleText() {
        assert_eq!(::std::mem::size_of::<nsStyleText>() , 160usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleText ) ));
        assert_eq! (::std::mem::align_of::<nsStyleText>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleText ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextAlign as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextAlign ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextAlignLast as *
                    const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextAlignLast ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextJustify as *
                    const _ as usize } , 3usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextJustify ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextTransform as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextTransform ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mWhiteSpace as *
                    const _ as usize } , 5usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mWhiteSpace ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mWordBreak as *
                    const _ as usize } , 6usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mWordBreak ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mOverflowWrap as *
                    const _ as usize } , 7usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mOverflowWrap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mHyphens as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mHyphens ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mRubyAlign as *
                    const _ as usize } , 9usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mRubyAlign ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mRubyPosition as *
                    const _ as usize } , 10usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mRubyPosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextSizeAdjust as
                    * const _ as usize } , 11usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextSizeAdjust ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextCombineUpright
                    as * const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextCombineUpright ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) .
                    mControlCharacterVisibility as * const _ as usize } ,
                    13usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mControlCharacterVisibility ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) .
                    mTextEmphasisPosition as * const _ as usize } , 14usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextEmphasisPosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextEmphasisStyle
                    as * const _ as usize } , 15usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextEmphasisStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextRendering as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextRendering ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextEmphasisColor
                    as * const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextEmphasisColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) .
                    mWebkitTextFillColor as * const _ as usize } , 28usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mWebkitTextFillColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) .
                    mWebkitTextStrokeColor as * const _ as usize } , 36usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mWebkitTextStrokeColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTabSize as * const
                    _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTabSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mWordSpacing as *
                    const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mWordSpacing ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mLetterSpacing as *
                    const _ as usize } , 80usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mLetterSpacing ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mLineHeight as *
                    const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mLineHeight ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextIndent as *
                    const _ as usize } , 112usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextIndent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) .
                    mWebkitTextStrokeWidth as * const _ as usize } , 128usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mWebkitTextStrokeWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextShadow as *
                    const _ as usize } , 136usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextShadow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) .
                    mTextEmphasisStyleString as * const _ as usize } ,
                    144usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextEmphasisStyleString ) ));
    }
    impl nsStyleText {
        #[inline]
        pub fn mTextAlignTrue(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 1u64 as u8;
            let val = (unit_field_val & mask) >> 0usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mTextAlignTrue(&mut self, val: bool) {
            let mask = 1u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 0usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn mTextAlignLastTrue(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 2u64 as u8;
            let val = (unit_field_val & mask) >> 1usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mTextAlignLastTrue(&mut self, val: bool) {
            let mask = 2u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 1usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn new_bitfield_1(mTextAlignTrue: bool, mTextAlignLastTrue: bool)
         -> u8 {
            ({
                 ({ 0 } |
                      ((mTextAlignTrue as u8 as u8) << 0usize) & (1u64 as u8))
             } | ((mTextAlignLastTrue as u8 as u8) << 1usize) & (2u64 as u8))
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleVisibility {
        pub mImageOrientation: root::nsStyleImageOrientation,
        pub mDirection: u8,
        pub mVisible: u8,
        pub mImageRendering: u8,
        pub mWritingMode: u8,
        pub mTextOrientation: u8,
        pub mColorAdjust: u8,
    }
    pub const nsStyleVisibility_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleVisibility() {
        assert_eq!(::std::mem::size_of::<nsStyleVisibility>() , 7usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleVisibility )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleVisibility>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleVisibility ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVisibility ) ) .
                    mImageOrientation as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleVisibility )
                    , "::" , stringify ! ( mImageOrientation ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVisibility ) ) . mDirection as
                    * const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleVisibility )
                    , "::" , stringify ! ( mDirection ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVisibility ) ) . mVisible as *
                    const _ as usize } , 2usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleVisibility )
                    , "::" , stringify ! ( mVisible ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVisibility ) ) .
                    mImageRendering as * const _ as usize } , 3usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleVisibility )
                    , "::" , stringify ! ( mImageRendering ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVisibility ) ) . mWritingMode
                    as * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleVisibility )
                    , "::" , stringify ! ( mWritingMode ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVisibility ) ) .
                    mTextOrientation as * const _ as usize } , 5usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleVisibility )
                    , "::" , stringify ! ( mTextOrientation ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVisibility ) ) . mColorAdjust
                    as * const _ as usize } , 6usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleVisibility )
                    , "::" , stringify ! ( mColorAdjust ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleUserInterface {
        pub mUserInput: root::mozilla::StyleUserInput,
        pub mUserModify: root::mozilla::StyleUserModify,
        pub mUserFocus: root::mozilla::StyleUserFocus,
        pub mPointerEvents: u8,
        pub mCursor: u8,
        pub mCursorImages: root::nsTArray<root::nsCursorImage>,
        pub mCaretColor: root::mozilla::StyleComplexColor,
    }
    pub const nsStyleUserInterface_kHasFinishStyle: bool = true;
    #[test]
    fn bindgen_test_layout_nsStyleUserInterface() {
        assert_eq!(::std::mem::size_of::<nsStyleUserInterface>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsStyleUserInterface ) ));
        assert_eq! (::std::mem::align_of::<nsStyleUserInterface>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleUserInterface ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUserInterface ) ) . mUserInput
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleUserInterface ) , "::" , stringify ! ( mUserInput )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUserInterface ) ) .
                    mUserModify as * const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleUserInterface ) , "::" , stringify ! ( mUserModify
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUserInterface ) ) . mUserFocus
                    as * const _ as usize } , 2usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleUserInterface ) , "::" , stringify ! ( mUserFocus )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUserInterface ) ) .
                    mPointerEvents as * const _ as usize } , 3usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsStyleUserInterface ) , "::" , stringify ! (
                    mPointerEvents ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUserInterface ) ) . mCursor as
                    * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleUserInterface ) , "::" , stringify ! ( mCursor )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUserInterface ) ) .
                    mCursorImages as * const _ as usize } , 8usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsStyleUserInterface ) , "::" , stringify ! (
                    mCursorImages ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUserInterface ) ) .
                    mCaretColor as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleUserInterface ) , "::" , stringify ! ( mCaretColor
                    ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleTableBorder {
        pub mBorderSpacingCol: root::nscoord,
        pub mBorderSpacingRow: root::nscoord,
        pub mBorderCollapse: u8,
        pub mCaptionSide: u8,
        pub mEmptyCells: u8,
    }
    pub const nsStyleTableBorder_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleTableBorder() {
        assert_eq!(::std::mem::size_of::<nsStyleTableBorder>() , 12usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleTableBorder )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleTableBorder>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleTableBorder ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTableBorder ) ) .
                    mBorderSpacingCol as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTableBorder
                    ) , "::" , stringify ! ( mBorderSpacingCol ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTableBorder ) ) .
                    mBorderSpacingRow as * const _ as usize } , 4usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTableBorder
                    ) , "::" , stringify ! ( mBorderSpacingRow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTableBorder ) ) .
                    mBorderCollapse as * const _ as usize } , 8usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleTableBorder
                    ) , "::" , stringify ! ( mBorderCollapse ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTableBorder ) ) . mCaptionSide
                    as * const _ as usize } , 9usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTableBorder
                    ) , "::" , stringify ! ( mCaptionSide ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTableBorder ) ) . mEmptyCells
                    as * const _ as usize } , 10usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTableBorder
                    ) , "::" , stringify ! ( mEmptyCells ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleSVG {
        pub mFill: root::nsStyleSVGPaint,
        pub mStroke: root::nsStyleSVGPaint,
        pub mMarkerEnd: root::RefPtr<root::mozilla::css::URLValue>,
        pub mMarkerMid: root::RefPtr<root::mozilla::css::URLValue>,
        pub mMarkerStart: root::RefPtr<root::mozilla::css::URLValue>,
        pub mStrokeDasharray: root::nsTArray<root::nsStyleCoord>,
        pub mContextProps: root::nsTArray<root::nsCOMPtr<root::nsIAtom>>,
        pub mStrokeDashoffset: root::nsStyleCoord,
        pub mStrokeWidth: root::nsStyleCoord,
        pub mFillOpacity: f32,
        pub mStrokeMiterlimit: f32,
        pub mStrokeOpacity: f32,
        pub mClipRule: root::mozilla::StyleFillRule,
        pub mColorInterpolation: u8,
        pub mColorInterpolationFilters: u8,
        pub mFillRule: root::mozilla::StyleFillRule,
        pub mPaintOrder: u8,
        pub mShapeRendering: u8,
        pub mStrokeLinecap: u8,
        pub mStrokeLinejoin: u8,
        pub mTextAnchor: u8,
        pub mContextPropsBits: u8,
        pub mContextFlags: u8,
    }
    pub const nsStyleSVG_kHasFinishStyle: bool = false;
    pub const nsStyleSVG_FILL_OPACITY_SOURCE_MASK: u8 = 3;
    pub const nsStyleSVG_STROKE_OPACITY_SOURCE_MASK: u8 = 12;
    pub const nsStyleSVG_STROKE_DASHARRAY_CONTEXT: u8 = 16;
    pub const nsStyleSVG_STROKE_DASHOFFSET_CONTEXT: u8 = 32;
    pub const nsStyleSVG_STROKE_WIDTH_CONTEXT: u8 = 64;
    pub const nsStyleSVG_FILL_OPACITY_SOURCE_SHIFT: u8 = 0;
    pub const nsStyleSVG_STROKE_OPACITY_SOURCE_SHIFT: u8 = 2;
    #[test]
    fn bindgen_test_layout_nsStyleSVG() {
        assert_eq!(::std::mem::size_of::<nsStyleSVG>() , 128usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleSVG ) ));
        assert_eq! (::std::mem::align_of::<nsStyleSVG>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsStyleSVG ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mFill as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mFill ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStroke as * const _
                    as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStroke ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mMarkerEnd as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mMarkerEnd ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mMarkerMid as *
                    const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mMarkerMid ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mMarkerStart as *
                    const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mMarkerStart ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeDasharray as
                    * const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStrokeDasharray ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mContextProps as *
                    const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mContextProps ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeDashoffset as
                    * const _ as usize } , 72usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStrokeDashoffset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeWidth as *
                    const _ as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStrokeWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mFillOpacity as *
                    const _ as usize } , 104usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mFillOpacity ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeMiterlimit as
                    * const _ as usize } , 108usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStrokeMiterlimit ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeOpacity as *
                    const _ as usize } , 112usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStrokeOpacity ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mClipRule as * const
                    _ as usize } , 116usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mClipRule ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mColorInterpolation
                    as * const _ as usize } , 117usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mColorInterpolation ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) .
                    mColorInterpolationFilters as * const _ as usize } ,
                    118usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mColorInterpolationFilters ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mFillRule as * const
                    _ as usize } , 119usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mFillRule ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mPaintOrder as *
                    const _ as usize } , 120usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mPaintOrder ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mShapeRendering as *
                    const _ as usize } , 121usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mShapeRendering ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeLinecap as *
                    const _ as usize } , 122usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStrokeLinecap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeLinejoin as *
                    const _ as usize } , 123usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStrokeLinejoin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mTextAnchor as *
                    const _ as usize } , 124usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mTextAnchor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mContextPropsBits as
                    * const _ as usize } , 125usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mContextPropsBits ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mContextFlags as *
                    const _ as usize } , 126usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mContextFlags ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleVariables {
        pub mVariables: root::mozilla::CSSVariableValues,
    }
    pub const nsStyleVariables_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleVariables() {
        assert_eq!(::std::mem::size_of::<nsStyleVariables>() , 56usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleVariables )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleVariables>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleVariables ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVariables ) ) . mVariables as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleVariables )
                    , "::" , stringify ! ( mVariables ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleBackground {
        pub mImage: root::nsStyleImageLayers,
        pub mBackgroundColor: root::mozilla::StyleComplexColor,
    }
    pub const nsStyleBackground_kHasFinishStyle: bool = true;
    #[test]
    fn bindgen_test_layout_nsStyleBackground() {
        assert_eq!(::std::mem::size_of::<nsStyleBackground>() , 160usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleBackground )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleBackground>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleBackground ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBackground ) ) . mImage as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBackground )
                    , "::" , stringify ! ( mImage ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBackground ) ) .
                    mBackgroundColor as * const _ as usize } , 152usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBackground )
                    , "::" , stringify ! ( mBackgroundColor ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStylePosition {
        pub mObjectPosition: root::mozilla::Position,
        pub mOffset: root::nsStyleSides,
        pub mWidth: root::nsStyleCoord,
        pub mMinWidth: root::nsStyleCoord,
        pub mMaxWidth: root::nsStyleCoord,
        pub mHeight: root::nsStyleCoord,
        pub mMinHeight: root::nsStyleCoord,
        pub mMaxHeight: root::nsStyleCoord,
        pub mFlexBasis: root::nsStyleCoord,
        pub mGridAutoColumnsMin: root::nsStyleCoord,
        pub mGridAutoColumnsMax: root::nsStyleCoord,
        pub mGridAutoRowsMin: root::nsStyleCoord,
        pub mGridAutoRowsMax: root::nsStyleCoord,
        pub mGridAutoFlow: u8,
        pub mBoxSizing: root::mozilla::StyleBoxSizing,
        pub mAlignContent: u16,
        pub mAlignItems: u8,
        pub mAlignSelf: u8,
        pub mJustifyContent: u16,
        pub mSpecifiedJustifyItems: u8,
        pub mJustifyItems: u8,
        pub mJustifySelf: u8,
        pub mFlexDirection: u8,
        pub mFlexWrap: u8,
        pub mObjectFit: u8,
        pub mOrder: i32,
        pub mFlexGrow: f32,
        pub mFlexShrink: f32,
        pub mZIndex: root::nsStyleCoord,
        pub mGridTemplateColumns: root::mozilla::UniquePtr<root::nsStyleGridTemplate>,
        pub mGridTemplateRows: root::mozilla::UniquePtr<root::nsStyleGridTemplate>,
        pub mGridTemplateAreas: root::RefPtr<root::mozilla::css::GridTemplateAreasValue>,
        pub mGridColumnStart: root::nsStyleGridLine,
        pub mGridColumnEnd: root::nsStyleGridLine,
        pub mGridRowStart: root::nsStyleGridLine,
        pub mGridRowEnd: root::nsStyleGridLine,
        pub mGridColumnGap: root::nsStyleCoord,
        pub mGridRowGap: root::nsStyleCoord,
    }
    pub const nsStylePosition_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStylePosition() {
        assert_eq!(::std::mem::size_of::<nsStylePosition>() , 440usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStylePosition )
                   ));
        assert_eq! (::std::mem::align_of::<nsStylePosition>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStylePosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mObjectPosition
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mObjectPosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mOffset as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mOffset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mWidth as *
                    const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mMinWidth as *
                    const _ as usize } , 80usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mMinWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mMaxWidth as *
                    const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mMaxWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mHeight as *
                    const _ as usize } , 112usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mHeight ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mMinHeight as *
                    const _ as usize } , 128usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mMinHeight ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mMaxHeight as *
                    const _ as usize } , 144usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mMaxHeight ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mFlexBasis as *
                    const _ as usize } , 160usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mFlexBasis ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridAutoColumnsMin as * const _ as usize } , 176usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridAutoColumnsMin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridAutoColumnsMax as * const _ as usize } , 192usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridAutoColumnsMax ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridAutoRowsMin as * const _ as usize } , 208usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridAutoRowsMin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridAutoRowsMax as * const _ as usize } , 224usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridAutoRowsMax ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mGridAutoFlow
                    as * const _ as usize } , 240usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridAutoFlow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mBoxSizing as *
                    const _ as usize } , 241usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mBoxSizing ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mAlignContent
                    as * const _ as usize } , 242usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mAlignContent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mAlignItems as
                    * const _ as usize } , 244usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mAlignItems ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mAlignSelf as *
                    const _ as usize } , 245usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mAlignSelf ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mJustifyContent
                    as * const _ as usize } , 246usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mJustifyContent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mSpecifiedJustifyItems as * const _ as usize } , 248usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mSpecifiedJustifyItems ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mJustifyItems
                    as * const _ as usize } , 249usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mJustifyItems ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mJustifySelf as
                    * const _ as usize } , 250usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mJustifySelf ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mFlexDirection
                    as * const _ as usize } , 251usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mFlexDirection ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mFlexWrap as *
                    const _ as usize } , 252usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mFlexWrap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mObjectFit as *
                    const _ as usize } , 253usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mObjectFit ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mOrder as *
                    const _ as usize } , 256usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mOrder ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mFlexGrow as *
                    const _ as usize } , 260usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mFlexGrow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mFlexShrink as
                    * const _ as usize } , 264usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mFlexShrink ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mZIndex as *
                    const _ as usize } , 272usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mZIndex ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridTemplateColumns as * const _ as usize } , 288usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridTemplateColumns ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridTemplateRows as * const _ as usize } , 296usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridTemplateRows ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridTemplateAreas as * const _ as usize } , 304usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridTemplateAreas ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridColumnStart as * const _ as usize } , 312usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridColumnStart ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mGridColumnEnd
                    as * const _ as usize } , 336usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridColumnEnd ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mGridRowStart
                    as * const _ as usize } , 360usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridRowStart ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mGridRowEnd as
                    * const _ as usize } , 384usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridRowEnd ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mGridColumnGap
                    as * const _ as usize } , 408usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridColumnGap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mGridRowGap as
                    * const _ as usize } , 424usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridRowGap ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleTextReset {
        pub mTextOverflow: root::nsStyleTextOverflow,
        pub mTextDecorationLine: u8,
        pub mTextDecorationStyle: u8,
        pub mUnicodeBidi: u8,
        pub mInitialLetterSink: root::nscoord,
        pub mInitialLetterSize: f32,
        pub mTextDecorationColor: root::mozilla::StyleComplexColor,
    }
    pub const nsStyleTextReset_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleTextReset() {
        assert_eq!(::std::mem::size_of::<nsStyleTextReset>() , 80usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleTextReset )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleTextReset>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleTextReset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextReset ) ) . mTextOverflow
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextReset )
                    , "::" , stringify ! ( mTextOverflow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextReset ) ) .
                    mTextDecorationLine as * const _ as usize } , 56usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextReset )
                    , "::" , stringify ! ( mTextDecorationLine ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextReset ) ) .
                    mTextDecorationStyle as * const _ as usize } , 57usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextReset )
                    , "::" , stringify ! ( mTextDecorationStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextReset ) ) . mUnicodeBidi
                    as * const _ as usize } , 58usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextReset )
                    , "::" , stringify ! ( mUnicodeBidi ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextReset ) ) .
                    mInitialLetterSink as * const _ as usize } , 60usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextReset )
                    , "::" , stringify ! ( mInitialLetterSink ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextReset ) ) .
                    mInitialLetterSize as * const _ as usize } , 64usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextReset )
                    , "::" , stringify ! ( mInitialLetterSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextReset ) ) .
                    mTextDecorationColor as * const _ as usize } , 68usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextReset )
                    , "::" , stringify ! ( mTextDecorationColor ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleDisplay {
        pub mBinding: root::BindingHolder,
        pub mDisplay: root::mozilla::StyleDisplay,
        pub mOriginalDisplay: root::mozilla::StyleDisplay,
        pub mContain: u8,
        pub mAppearance: u8,
        pub mPosition: u8,
        pub mFloat: root::mozilla::StyleFloat,
        pub mOriginalFloat: root::mozilla::StyleFloat,
        pub mBreakType: root::mozilla::StyleClear,
        pub mBreakInside: u8,
        pub mBreakBefore: bool,
        pub mBreakAfter: bool,
        pub mOverflowX: u8,
        pub mOverflowY: u8,
        pub mOverflowClipBox: u8,
        pub mResize: u8,
        pub mOrient: root::mozilla::StyleOrient,
        pub mIsolation: u8,
        pub mTopLayer: u8,
        pub mWillChangeBitField: u8,
        pub mWillChange: root::nsCOMArray,
        pub mTouchAction: u8,
        pub mScrollBehavior: u8,
        pub mScrollSnapTypeX: u8,
        pub mScrollSnapTypeY: u8,
        pub mScrollSnapPointsX: root::nsStyleCoord,
        pub mScrollSnapPointsY: root::nsStyleCoord,
        pub mScrollSnapDestination: root::mozilla::Position,
        pub mScrollSnapCoordinate: root::nsTArray<root::mozilla::Position>,
        pub mBackfaceVisibility: u8,
        pub mTransformStyle: u8,
        pub mTransformBox: root::nsStyleDisplay_StyleGeometryBox,
        pub mSpecifiedTransform: root::RefPtr<root::nsCSSValueSharedList>,
        pub mTransformOrigin: [root::nsStyleCoord; 3usize],
        pub mChildPerspective: root::nsStyleCoord,
        pub mPerspectiveOrigin: [root::nsStyleCoord; 2usize],
        pub mVerticalAlign: root::nsStyleCoord,
        pub mTransitions: root::nsStyleAutoArray<root::mozilla::StyleTransition>,
        pub mTransitionTimingFunctionCount: u32,
        pub mTransitionDurationCount: u32,
        pub mTransitionDelayCount: u32,
        pub mTransitionPropertyCount: u32,
        pub mAnimations: root::nsStyleAutoArray<root::mozilla::StyleAnimation>,
        pub mAnimationTimingFunctionCount: u32,
        pub mAnimationDurationCount: u32,
        pub mAnimationDelayCount: u32,
        pub mAnimationNameCount: u32,
        pub mAnimationDirectionCount: u32,
        pub mAnimationFillModeCount: u32,
        pub mAnimationPlayStateCount: u32,
        pub mAnimationIterationCountCount: u32,
        pub mShapeOutside: root::mozilla::StyleShapeSource,
    }
    pub use self::super::root::mozilla::StyleGeometryBox as
            nsStyleDisplay_StyleGeometryBox;
    pub const nsStyleDisplay_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleDisplay() {
        assert_eq!(::std::mem::size_of::<nsStyleDisplay>() , 416usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleDisplay ) ));
        assert_eq! (::std::mem::align_of::<nsStyleDisplay>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleDisplay ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mBinding as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mBinding ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mDisplay as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mDisplay ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mOriginalDisplay
                    as * const _ as usize } , 9usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mOriginalDisplay ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mContain as *
                    const _ as usize } , 10usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mContain ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mAppearance as *
                    const _ as usize } , 11usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAppearance ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mPosition as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mPosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mFloat as *
                    const _ as usize } , 13usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mFloat ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mOriginalFloat
                    as * const _ as usize } , 14usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mOriginalFloat ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mBreakType as *
                    const _ as usize } , 15usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mBreakType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mBreakInside as
                    * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mBreakInside ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mBreakBefore as
                    * const _ as usize } , 17usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mBreakBefore ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mBreakAfter as *
                    const _ as usize } , 18usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mBreakAfter ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mOverflowX as *
                    const _ as usize } , 19usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mOverflowX ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mOverflowY as *
                    const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mOverflowY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mOverflowClipBox
                    as * const _ as usize } , 21usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mOverflowClipBox ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mResize as *
                    const _ as usize } , 22usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mResize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mOrient as *
                    const _ as usize } , 23usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mOrient ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mIsolation as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mIsolation ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mTopLayer as *
                    const _ as usize } , 25usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTopLayer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mWillChangeBitField as * const _ as usize } , 26usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mWillChangeBitField ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mWillChange as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mWillChange ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mTouchAction as
                    * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTouchAction ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mScrollBehavior
                    as * const _ as usize } , 41usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mScrollBehavior ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mScrollSnapTypeX
                    as * const _ as usize } , 42usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mScrollSnapTypeX ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mScrollSnapTypeY
                    as * const _ as usize } , 43usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mScrollSnapTypeY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mScrollSnapPointsX as * const _ as usize } , 48usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mScrollSnapPointsX ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mScrollSnapPointsY as * const _ as usize } , 64usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mScrollSnapPointsY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mScrollSnapDestination as * const _ as usize } , 80usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mScrollSnapDestination ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mScrollSnapCoordinate as * const _ as usize } , 104usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mScrollSnapCoordinate ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mBackfaceVisibility as * const _ as usize } , 112usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mBackfaceVisibility ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mTransformStyle
                    as * const _ as usize } , 113usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransformStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mTransformBox as
                    * const _ as usize } , 114usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransformBox ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mSpecifiedTransform as * const _ as usize } , 120usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mSpecifiedTransform ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mTransformOrigin
                    as * const _ as usize } , 128usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransformOrigin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mChildPerspective as * const _ as usize } , 176usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mChildPerspective ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mPerspectiveOrigin as * const _ as usize } , 192usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mPerspectiveOrigin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mVerticalAlign
                    as * const _ as usize } , 224usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mVerticalAlign ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mTransitions as
                    * const _ as usize } , 240usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransitions ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mTransitionTimingFunctionCount as * const _ as usize } ,
                    288usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransitionTimingFunctionCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mTransitionDurationCount as * const _ as usize } ,
                    292usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransitionDurationCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mTransitionDelayCount as * const _ as usize } , 296usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransitionDelayCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mTransitionPropertyCount as * const _ as usize } ,
                    300usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransitionPropertyCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mAnimations as *
                    const _ as usize } , 304usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimations ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationTimingFunctionCount as * const _ as usize } ,
                    368usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationTimingFunctionCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationDurationCount as * const _ as usize } , 372usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationDurationCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationDelayCount as * const _ as usize } , 376usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationDelayCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationNameCount as * const _ as usize } , 380usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationNameCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationDirectionCount as * const _ as usize } ,
                    384usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationDirectionCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationFillModeCount as * const _ as usize } , 388usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationFillModeCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationPlayStateCount as * const _ as usize } ,
                    392usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationPlayStateCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationIterationCountCount as * const _ as usize } ,
                    396usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationIterationCountCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mShapeOutside as
                    * const _ as usize } , 400usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mShapeOutside ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleContent {
        pub mContents: root::nsTArray<root::nsStyleContentData>,
        pub mIncrements: root::nsTArray<root::nsStyleCounterData>,
        pub mResets: root::nsTArray<root::nsStyleCounterData>,
    }
    pub const nsStyleContent_kHasFinishStyle: bool = true;
    #[test]
    fn bindgen_test_layout_nsStyleContent() {
        assert_eq!(::std::mem::size_of::<nsStyleContent>() , 24usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleContent ) ));
        assert_eq! (::std::mem::align_of::<nsStyleContent>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleContent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContent ) ) . mContents as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleContent ) ,
                    "::" , stringify ! ( mContents ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContent ) ) . mIncrements as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleContent ) ,
                    "::" , stringify ! ( mIncrements ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContent ) ) . mResets as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleContent ) ,
                    "::" , stringify ! ( mResets ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleUIReset {
        pub mUserSelect: root::mozilla::StyleUserSelect,
        pub mForceBrokenImageIcon: u8,
        pub mIMEMode: u8,
        pub mWindowDragging: root::mozilla::StyleWindowDragging,
        pub mWindowShadow: u8,
        pub mWindowOpacity: f32,
        pub mSpecifiedWindowTransform: root::RefPtr<root::nsCSSValueSharedList>,
        pub mWindowTransformOrigin: [root::nsStyleCoord; 2usize],
    }
    pub const nsStyleUIReset_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleUIReset() {
        assert_eq!(::std::mem::size_of::<nsStyleUIReset>() , 56usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleUIReset ) ));
        assert_eq! (::std::mem::align_of::<nsStyleUIReset>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleUIReset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUIReset ) ) . mUserSelect as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUIReset ) ,
                    "::" , stringify ! ( mUserSelect ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUIReset ) ) .
                    mForceBrokenImageIcon as * const _ as usize } , 1usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUIReset ) ,
                    "::" , stringify ! ( mForceBrokenImageIcon ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUIReset ) ) . mIMEMode as *
                    const _ as usize } , 2usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUIReset ) ,
                    "::" , stringify ! ( mIMEMode ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUIReset ) ) . mWindowDragging
                    as * const _ as usize } , 3usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUIReset ) ,
                    "::" , stringify ! ( mWindowDragging ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUIReset ) ) . mWindowShadow as
                    * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUIReset ) ,
                    "::" , stringify ! ( mWindowShadow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUIReset ) ) . mWindowOpacity
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUIReset ) ,
                    "::" , stringify ! ( mWindowOpacity ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUIReset ) ) .
                    mSpecifiedWindowTransform as * const _ as usize } ,
                    16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUIReset ) ,
                    "::" , stringify ! ( mSpecifiedWindowTransform ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUIReset ) ) .
                    mWindowTransformOrigin as * const _ as usize } , 24usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUIReset ) ,
                    "::" , stringify ! ( mWindowTransformOrigin ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleTable {
        pub mLayoutStrategy: u8,
        pub mSpan: i32,
    }
    pub const nsStyleTable_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleTable() {
        assert_eq!(::std::mem::size_of::<nsStyleTable>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleTable ) ));
        assert_eq! (::std::mem::align_of::<nsStyleTable>() , 4usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTable ) ) . mLayoutStrategy as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTable ) ,
                    "::" , stringify ! ( mLayoutStrategy ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTable ) ) . mSpan as * const _
                    as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTable ) ,
                    "::" , stringify ! ( mSpan ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleMargin {
        pub mMargin: root::nsStyleSides,
    }
    pub const nsStyleMargin_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleMargin() {
        assert_eq!(::std::mem::size_of::<nsStyleMargin>() , 40usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleMargin ) ));
        assert_eq! (::std::mem::align_of::<nsStyleMargin>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleMargin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleMargin ) ) . mMargin as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleMargin ) ,
                    "::" , stringify ! ( mMargin ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStylePadding {
        pub mPadding: root::nsStyleSides,
    }
    pub const nsStylePadding_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStylePadding() {
        assert_eq!(::std::mem::size_of::<nsStylePadding>() , 40usize , concat
                   ! ( "Size of: " , stringify ! ( nsStylePadding ) ));
        assert_eq! (::std::mem::align_of::<nsStylePadding>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStylePadding ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePadding ) ) . mPadding as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePadding ) ,
                    "::" , stringify ! ( mPadding ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleBorder {
        pub mBorderColors: *mut *mut root::nsBorderColors,
        pub mBorderRadius: root::nsStyleCorners,
        pub mBorderImageSource: root::nsStyleImage,
        pub mBorderImageSlice: root::nsStyleSides,
        pub mBorderImageWidth: root::nsStyleSides,
        pub mBorderImageOutset: root::nsStyleSides,
        pub mBorderImageFill: u8,
        pub mBorderImageRepeatH: u8,
        pub mBorderImageRepeatV: u8,
        pub mFloatEdge: root::mozilla::StyleFloatEdge,
        pub mBoxDecorationBreak: root::mozilla::StyleBoxDecorationBreak,
        pub mBorderStyle: [u8; 4usize],
        pub __bindgen_anon_1: root::nsStyleBorder__bindgen_ty_1,
        pub mComputedBorder: root::nsMargin,
        pub mBorder: root::nsMargin,
        pub mTwipsPerPixel: root::nscoord,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleBorder__bindgen_ty_1 {
        pub __bindgen_anon_1: root::__BindgenUnionField<root::nsStyleBorder__bindgen_ty_1__bindgen_ty_1>,
        pub mBorderColor: root::__BindgenUnionField<[root::mozilla::StyleComplexColor; 4usize]>,
        pub bindgen_union_field: [u32; 8usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleBorder__bindgen_ty_1__bindgen_ty_1 {
        pub mBorderTopColor: root::mozilla::StyleComplexColor,
        pub mBorderRightColor: root::mozilla::StyleComplexColor,
        pub mBorderBottomColor: root::mozilla::StyleComplexColor,
        pub mBorderLeftColor: root::mozilla::StyleComplexColor,
    }
    #[test]
    fn bindgen_test_layout_nsStyleBorder__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleBorder__bindgen_ty_1__bindgen_ty_1>()
                   , 32usize , concat ! (
                   "Size of: " , stringify ! (
                   nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) ));
        assert_eq! (::std::mem::align_of::<nsStyleBorder__bindgen_ty_1__bindgen_ty_1>()
                    , 4usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsStyleBorder__bindgen_ty_1__bindgen_ty_1
                    ) ) . mBorderTopColor as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mBorderTopColor ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsStyleBorder__bindgen_ty_1__bindgen_ty_1
                    ) ) . mBorderRightColor as * const _ as usize } , 8usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mBorderRightColor ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsStyleBorder__bindgen_ty_1__bindgen_ty_1
                    ) ) . mBorderBottomColor as * const _ as usize } , 16usize
                    , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mBorderBottomColor ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsStyleBorder__bindgen_ty_1__bindgen_ty_1
                    ) ) . mBorderLeftColor as * const _ as usize } , 24usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mBorderLeftColor ) ));
    }
    impl Clone for nsStyleBorder__bindgen_ty_1__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsStyleBorder__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleBorder__bindgen_ty_1>() ,
                   32usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleBorder__bindgen_ty_1 )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleBorder__bindgen_ty_1>() ,
                    4usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsStyleBorder__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder__bindgen_ty_1 ) ) .
                    mBorderColor as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleBorder__bindgen_ty_1 ) , "::" , stringify ! (
                    mBorderColor ) ));
    }
    impl Clone for nsStyleBorder__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    pub const nsStyleBorder_kHasFinishStyle: bool = true;
    #[test]
    fn bindgen_test_layout_nsStyleBorder() {
        assert_eq!(::std::mem::size_of::<nsStyleBorder>() , 312usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleBorder ) ));
        assert_eq! (::std::mem::align_of::<nsStyleBorder>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleBorder ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mBorderColors as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderColors ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mBorderRadius as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderRadius ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) .
                    mBorderImageSource as * const _ as usize } , 80usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderImageSource ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mBorderImageSlice
                    as * const _ as usize } , 112usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderImageSlice ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mBorderImageWidth
                    as * const _ as usize } , 152usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderImageWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) .
                    mBorderImageOutset as * const _ as usize } , 192usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderImageOutset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mBorderImageFill
                    as * const _ as usize } , 232usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderImageFill ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) .
                    mBorderImageRepeatH as * const _ as usize } , 233usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderImageRepeatH ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) .
                    mBorderImageRepeatV as * const _ as usize } , 234usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderImageRepeatV ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mFloatEdge as *
                    const _ as usize } , 235usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mFloatEdge ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) .
                    mBoxDecorationBreak as * const _ as usize } , 236usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBoxDecorationBreak ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mBorderStyle as *
                    const _ as usize } , 237usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mComputedBorder
                    as * const _ as usize } , 276usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mComputedBorder ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mBorder as *
                    const _ as usize } , 292usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorder ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mTwipsPerPixel as
                    * const _ as usize } , 308usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mTwipsPerPixel ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleOutline {
        pub mOutlineRadius: root::nsStyleCorners,
        pub mOutlineWidth: root::nscoord,
        pub mOutlineOffset: root::nscoord,
        pub mOutlineColor: root::mozilla::StyleComplexColor,
        pub mOutlineStyle: u8,
        pub mActualOutlineWidth: root::nscoord,
        pub mTwipsPerPixel: root::nscoord,
    }
    pub const nsStyleOutline_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleOutline() {
        assert_eq!(::std::mem::size_of::<nsStyleOutline>() , 104usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleOutline ) ));
        assert_eq! (::std::mem::align_of::<nsStyleOutline>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleOutline ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleOutline ) ) . mOutlineRadius
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleOutline ) ,
                    "::" , stringify ! ( mOutlineRadius ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleOutline ) ) . mOutlineWidth as
                    * const _ as usize } , 72usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleOutline ) ,
                    "::" , stringify ! ( mOutlineWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleOutline ) ) . mOutlineOffset
                    as * const _ as usize } , 76usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleOutline ) ,
                    "::" , stringify ! ( mOutlineOffset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleOutline ) ) . mOutlineColor as
                    * const _ as usize } , 80usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleOutline ) ,
                    "::" , stringify ! ( mOutlineColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleOutline ) ) . mOutlineStyle as
                    * const _ as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleOutline ) ,
                    "::" , stringify ! ( mOutlineStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleOutline ) ) .
                    mActualOutlineWidth as * const _ as usize } , 92usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleOutline ) ,
                    "::" , stringify ! ( mActualOutlineWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleOutline ) ) . mTwipsPerPixel
                    as * const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleOutline ) ,
                    "::" , stringify ! ( mTwipsPerPixel ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleXUL {
        pub mBoxFlex: f32,
        pub mBoxOrdinal: u32,
        pub mBoxAlign: root::mozilla::StyleBoxAlign,
        pub mBoxDirection: root::mozilla::StyleBoxDirection,
        pub mBoxOrient: root::mozilla::StyleBoxOrient,
        pub mBoxPack: root::mozilla::StyleBoxPack,
        pub mStackSizing: root::mozilla::StyleStackSizing,
    }
    pub const nsStyleXUL_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleXUL() {
        assert_eq!(::std::mem::size_of::<nsStyleXUL>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleXUL ) ));
        assert_eq! (::std::mem::align_of::<nsStyleXUL>() , 4usize , concat ! (
                    "Alignment of " , stringify ! ( nsStyleXUL ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleXUL ) ) . mBoxFlex as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::"
                    , stringify ! ( mBoxFlex ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleXUL ) ) . mBoxOrdinal as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::"
                    , stringify ! ( mBoxOrdinal ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleXUL ) ) . mBoxAlign as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::"
                    , stringify ! ( mBoxAlign ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleXUL ) ) . mBoxDirection as *
                    const _ as usize } , 9usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::"
                    , stringify ! ( mBoxDirection ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleXUL ) ) . mBoxOrient as *
                    const _ as usize } , 10usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::"
                    , stringify ! ( mBoxOrient ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleXUL ) ) . mBoxPack as * const
                    _ as usize } , 11usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::"
                    , stringify ! ( mBoxPack ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleXUL ) ) . mStackSizing as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::"
                    , stringify ! ( mStackSizing ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleSVGReset {
        pub mMask: root::nsStyleImageLayers,
        pub mClipPath: root::mozilla::StyleShapeSource,
        pub mStopColor: root::nscolor,
        pub mFloodColor: root::nscolor,
        pub mLightingColor: root::nscolor,
        pub mStopOpacity: f32,
        pub mFloodOpacity: f32,
        pub mDominantBaseline: u8,
        pub mVectorEffect: u8,
        pub mMaskType: u8,
    }
    pub const nsStyleSVGReset_kHasFinishStyle: bool = true;
    #[test]
    fn bindgen_test_layout_nsStyleSVGReset() {
        assert_eq!(::std::mem::size_of::<nsStyleSVGReset>() , 192usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleSVGReset )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleSVGReset>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleSVGReset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mMask as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mMask ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mClipPath as *
                    const _ as usize } , 152usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mClipPath ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mStopColor as *
                    const _ as usize } , 168usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mStopColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mFloodColor as
                    * const _ as usize } , 172usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mFloodColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mLightingColor
                    as * const _ as usize } , 176usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mLightingColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mStopOpacity as
                    * const _ as usize } , 180usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mStopOpacity ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mFloodOpacity
                    as * const _ as usize } , 184usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mFloodOpacity ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) .
                    mDominantBaseline as * const _ as usize } , 188usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mDominantBaseline ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mVectorEffect
                    as * const _ as usize } , 189usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mVectorEffect ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mMaskType as *
                    const _ as usize } , 190usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mMaskType ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleColumn {
        pub mColumnCount: u32,
        pub mColumnWidth: root::nsStyleCoord,
        pub mColumnGap: root::nsStyleCoord,
        pub mColumnRuleColor: root::mozilla::StyleComplexColor,
        pub mColumnRuleStyle: u8,
        pub mColumnFill: u8,
        pub mColumnSpan: u8,
        pub mColumnRuleWidth: root::nscoord,
        pub mTwipsPerPixel: root::nscoord,
    }
    pub const nsStyleColumn_kHasFinishStyle: bool = false;
    pub const nsStyleColumn_kMaxColumnCount: u32 = 1000;
    #[test]
    fn bindgen_test_layout_nsStyleColumn() {
        assert_eq!(::std::mem::size_of::<nsStyleColumn>() , 64usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleColumn ) ));
        assert_eq! (::std::mem::align_of::<nsStyleColumn>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleColumn ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnCount as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnWidth as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnGap as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnGap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnRuleColor
                    as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnRuleColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnRuleStyle
                    as * const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnRuleStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnFill as *
                    const _ as usize } , 49usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnFill ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnSpan as *
                    const _ as usize } , 50usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnSpan ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnRuleWidth
                    as * const _ as usize } , 52usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnRuleWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mTwipsPerPixel as
                    * const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mTwipsPerPixel ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleEffects {
        pub mFilters: root::nsTArray<root::nsStyleFilter>,
        pub mBoxShadow: root::RefPtr<root::nsCSSShadowArray>,
        pub mClip: root::nsRect,
        pub mOpacity: f32,
        pub mClipFlags: u8,
        pub mMixBlendMode: u8,
    }
    pub const nsStyleEffects_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleEffects() {
        assert_eq!(::std::mem::size_of::<nsStyleEffects>() , 40usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleEffects ) ));
        assert_eq! (::std::mem::align_of::<nsStyleEffects>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleEffects ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleEffects ) ) . mFilters as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleEffects ) ,
                    "::" , stringify ! ( mFilters ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleEffects ) ) . mBoxShadow as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleEffects ) ,
                    "::" , stringify ! ( mBoxShadow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleEffects ) ) . mClip as * const
                    _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleEffects ) ,
                    "::" , stringify ! ( mClip ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleEffects ) ) . mOpacity as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleEffects ) ,
                    "::" , stringify ! ( mOpacity ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleEffects ) ) . mClipFlags as *
                    const _ as usize } , 36usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleEffects ) ,
                    "::" , stringify ! ( mClipFlags ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleEffects ) ) . mMixBlendMode as
                    * const _ as usize } , 37usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleEffects ) ,
                    "::" , stringify ! ( mMixBlendMode ) ));
    }
    /// We want C++ to be able to read the style struct fields of ComputedValues
    /// so we define this type on the C++ side and use the bindgenned version
    /// on the Rust side.
    #[repr(C)]
    #[derive(Debug)]
    pub struct ServoComputedData {
        pub Font: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoFont>,
        pub Color: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoColor>,
        pub List: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoList>,
        pub Text: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoText>,
        pub Visibility: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoVisibility>,
        pub UserInterface: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoUserInterface>,
        pub TableBorder: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoTableBorder>,
        pub SVG: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoSVG>,
        pub Background: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoBackground>,
        pub Position: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoPosition>,
        pub TextReset: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoTextReset>,
        pub Display: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoDisplay>,
        pub Content: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoContent>,
        pub UIReset: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoUIReset>,
        pub Table: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoTable>,
        pub Margin: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoMargin>,
        pub Padding: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoPadding>,
        pub Border: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoBorder>,
        pub Outline: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoOutline>,
        pub XUL: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoXUL>,
        pub SVGReset: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoSVGReset>,
        pub Column: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoColumn>,
        pub Effects: ::gecko_bindings::structs::ServoRawOffsetArc<root::mozilla::GeckoEffects>,
        pub custom_properties: ::gecko_bindings::structs::ServoCustomPropertiesMap,
        pub writing_mode: ::gecko_bindings::structs::ServoWritingMode,
        pub flags: ::gecko_bindings::structs::ServoComputedValueFlags,
        /// The rule node representing the ordered list of rules matched for this
        /// /// node.  Can be None for default values and text nodes.  This is
        /// /// essentially an optimization to avoid referencing the root rule node.
        pub rules: ::gecko_bindings::structs::ServoRuleNode,
        /// The element's computed values if visited, only computed if there's a
        /// /// relevant link for this element. A element's "relevant link" is the
        /// /// element being matched if it is a link or the nearest ancestor link.
        pub visited_style: ::gecko_bindings::structs::ServoVisitedStyle,
        pub font_computation_data: ::gecko_bindings::structs::ServoFontComputationData,
    }
    #[test]
    fn bindgen_test_layout_ServoComputedData() {
        assert_eq!(::std::mem::size_of::<ServoComputedData>() , 224usize ,
                   concat ! ( "Size of: " , stringify ! ( ServoComputedData )
                   ));
        assert_eq! (::std::mem::align_of::<ServoComputedData>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( ServoComputedData ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . Font as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( Font ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . Color as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( Color ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . List as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( List ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . Text as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( Text ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . Visibility as
                    * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( Visibility ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . UserInterface
                    as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( UserInterface ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . TableBorder
                    as * const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( TableBorder ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . SVG as *
                    const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( SVG ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . Background as
                    * const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( Background ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . Position as *
                    const _ as usize } , 72usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( Position ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . TextReset as
                    * const _ as usize } , 80usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( TextReset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . Display as *
                    const _ as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( Display ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . Content as *
                    const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( Content ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . UIReset as *
                    const _ as usize } , 104usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( UIReset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . Table as *
                    const _ as usize } , 112usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( Table ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . Margin as *
                    const _ as usize } , 120usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( Margin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . Padding as *
                    const _ as usize } , 128usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( Padding ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . Border as *
                    const _ as usize } , 136usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( Border ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . Outline as *
                    const _ as usize } , 144usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( Outline ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . XUL as *
                    const _ as usize } , 152usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( XUL ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . SVGReset as *
                    const _ as usize } , 160usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( SVGReset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . Column as *
                    const _ as usize } , 168usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( Column ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . Effects as *
                    const _ as usize } , 176usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( Effects ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) .
                    custom_properties as * const _ as usize } , 184usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( custom_properties ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . writing_mode
                    as * const _ as usize } , 192usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( writing_mode ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . flags as *
                    const _ as usize } , 193usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( flags ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . rules as *
                    const _ as usize } , 200usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( rules ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) . visited_style
                    as * const _ as usize } , 208usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( visited_style ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoComputedData ) ) .
                    font_computation_data as * const _ as usize } , 216usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( ServoComputedData )
                    , "::" , stringify ! ( font_computation_data ) ));
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSValueTag {
        JSVAL_TAG_MAX_DOUBLE = 131056,
        JSVAL_TAG_INT32 = 131057,
        JSVAL_TAG_UNDEFINED = 131058,
        JSVAL_TAG_NULL = 131059,
        JSVAL_TAG_BOOLEAN = 131060,
        JSVAL_TAG_MAGIC = 131061,
        JSVAL_TAG_STRING = 131062,
        JSVAL_TAG_SYMBOL = 131063,
        JSVAL_TAG_PRIVATE_GCTHING = 131064,
        JSVAL_TAG_OBJECT = 131068,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSWhyMagic {
        JS_ELEMENTS_HOLE = 0,
        JS_NO_ITER_VALUE = 1,
        JS_GENERATOR_CLOSING = 2,
        JS_NO_CONSTANT = 3,
        JS_THIS_POISON = 4,
        JS_ARG_POISON = 5,
        JS_SERIALIZE_NO_NODE = 6,
        JS_LAZY_ARGUMENTS = 7,
        JS_OPTIMIZED_ARGUMENTS = 8,
        JS_IS_CONSTRUCTING = 9,
        JS_BLOCK_NEEDS_CLONE = 10,
        JS_HASH_KEY_EMPTY = 11,
        JS_ION_ERROR = 12,
        JS_ION_BAILOUT = 13,
        JS_OPTIMIZED_OUT = 14,
        JS_UNINITIALIZED_LEXICAL = 15,
        JS_GENERIC_MAGIC = 16,
        JS_WHY_MAGIC_COUNT = 17,
    }
    /// This structure precedes the string buffers "we" allocate.  It may be the
    /// case that nsTAString::mData does not point to one of these special
    /// buffers.  The mDataFlags member variable distinguishes the buffer type.
    ///
    /// When this header is in use, it enables reference counting, and capacity
    /// tracking.  NOTE: A string buffer can be modified only if its reference
    /// count is 1.
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStringBuffer {
        pub mRefCount: u32,
        pub mStorageSize: u32,
    }
    #[test]
    fn bindgen_test_layout_nsStringBuffer() {
        assert_eq!(::std::mem::size_of::<nsStringBuffer>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( nsStringBuffer ) ));
        assert_eq! (::std::mem::align_of::<nsStringBuffer>() , 4usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStringBuffer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStringBuffer ) ) . mRefCount as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStringBuffer ) ,
                    "::" , stringify ! ( mRefCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStringBuffer ) ) . mStorageSize as
                    * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStringBuffer ) ,
                    "::" , stringify ! ( mStorageSize ) ));
    }
    impl Clone for nsStringBuffer {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIAtom {
        pub _base: root::nsISupports,
        pub _bitfield_1: u32,
        pub mHash: u32,
        /// WARNING! There is an invisible constraint on |mString|: the chars it
        /// points to must belong to an nsStringBuffer. This is so that the
        /// nsStringBuffer::FromData() calls above are valid.
        pub mString: *mut u16,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIAtom_COMTypeInfo {
        pub _address: u8,
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIAtom_AtomKind {
        DynamicAtom = 0,
        StaticAtom = 1,
        HTML5Atom = 2,
    }
    #[test]
    fn bindgen_test_layout_nsIAtom() {
        assert_eq!(::std::mem::size_of::<nsIAtom>() , 24usize , concat ! (
                   "Size of: " , stringify ! ( nsIAtom ) ));
        assert_eq! (::std::mem::align_of::<nsIAtom>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIAtom ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIAtom ) ) . mHash as * const _ as
                    usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIAtom ) , "::" ,
                    stringify ! ( mHash ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIAtom ) ) . mString as * const _ as
                    usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIAtom ) , "::" ,
                    stringify ! ( mString ) ));
    }
    impl Clone for nsIAtom {
        fn clone(&self) -> Self { *self }
    }
    impl nsIAtom {
        #[inline]
        pub fn mLength(&self) -> u32 {
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            let mask = 1073741823u64 as u32;
            let val = (unit_field_val & mask) >> 0usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mLength(&mut self, val: u32) {
            let mask = 1073741823u64 as u32;
            let val = val as u32 as u32;
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 0usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u32>());
            }
        }
        #[inline]
        pub fn mKind(&self) -> u32 {
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            let mask = 3221225472u64 as u32;
            let val = (unit_field_val & mask) >> 30usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mKind(&mut self, val: u32) {
            let mask = 3221225472u64 as u32;
            let val = val as u32 as u32;
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 30usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u32>());
            }
        }
        #[inline]
        pub fn new_bitfield_1(mLength: u32, mKind: u32) -> u32 {
            ({
                 ({ 0 } |
                      ((mLength as u32 as u32) << 0usize) &
                          (1073741823u64 as u32))
             } | ((mKind as u32 as u32) << 30usize) & (3221225472u64 as u32))
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIPrincipal {
        pub _base: root::nsISerializable,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIPrincipal_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIPrincipal() {
        assert_eq!(::std::mem::size_of::<nsIPrincipal>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIPrincipal ) ));
        assert_eq! (::std::mem::align_of::<nsIPrincipal>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsIPrincipal ) ));
    }
    impl Clone for nsIPrincipal {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    pub struct nsWrapperCache__bindgen_vtable(::std::os::raw::c_void);
    /// Class to store the wrapper for an object. This can only be used with objects
    /// that only have one non-security wrapper at a time (for an XPCWrappedNative
    /// this is usually ensured by setting an explicit parent in the PreCreate hook
    /// for the class).
    ///
    /// An instance of nsWrapperCache can be gotten from an object that implements
    /// a wrapper cache by calling QueryInterface on it. Note that this breaks XPCOM
    /// rules a bit (this object doesn't derive from nsISupports).
    ///
    /// The cache can store objects other than wrappers. We allow wrappers to use a
    /// separate JSObject to store their state (mostly expandos). If the wrapper is
    /// collected and we want to preserve this state we actually store the state
    /// object in the cache.
    ///
    /// The cache can store 2 types of objects:
    ///
    /// If WRAPPER_IS_NOT_DOM_BINDING is set (IsDOMBinding() returns false):
    /// - the JSObject of an XPCWrappedNative wrapper
    ///
    /// If WRAPPER_IS_NOT_DOM_BINDING is not set (IsDOMBinding() returns true):
    /// - a DOM binding object (regular JS object or proxy)
    ///
    /// The finalizer for the wrapper clears the cache.
    ///
    /// A compacting GC can move the wrapper object. Pointers to moved objects are
    /// usually found and updated by tracing the heap, however non-preserved wrappers
    /// are weak references and are not traced, so another approach is
    /// necessary. Instead a class hook (objectMovedOp) is provided that is called
    /// when an object is moved and is responsible for ensuring pointers are
    /// updated. It does this by calling UpdateWrapper() on the wrapper
    /// cache. SetWrapper() asserts that the hook is implemented for any wrapper set.
    ///
    /// A number of the methods are implemented in nsWrapperCacheInlines.h because we
    /// have to include some JS headers that don't play nicely with the rest of the
    /// codebase. Include nsWrapperCacheInlines.h if you need to call those methods.
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsWrapperCache {
        pub vtable_: *const nsWrapperCache__bindgen_vtable,
        pub mWrapper: *mut root::JSObject,
        pub mFlags: root::nsWrapperCache_FlagsType,
        pub mBoolFlags: u32,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsWrapperCache_COMTypeInfo {
        pub _address: u8,
    }
    pub type nsWrapperCache_FlagsType = u32;
    pub const nsWrapperCache_WRAPPER_BIT_PRESERVED:
              root::nsWrapperCache__bindgen_ty_1 =
        nsWrapperCache__bindgen_ty_1::WRAPPER_BIT_PRESERVED;
    #[repr(u32)]
    /// If this bit is set then we're preserving the wrapper, which in effect ties
    /// the lifetime of the JS object stored in the cache to the lifetime of the
    /// native object. We rely on the cycle collector to break the cycle that this
    /// causes between the native object and the JS object, so it is important that
    /// any native object that supports preserving of its wrapper
    /// traces/traverses/unlinks the cached JS object (see
    /// NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER and
    /// NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER).
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsWrapperCache__bindgen_ty_1 { WRAPPER_BIT_PRESERVED = 1, }
    pub const nsWrapperCache_WRAPPER_IS_NOT_DOM_BINDING:
              root::nsWrapperCache__bindgen_ty_2 =
        nsWrapperCache__bindgen_ty_2::WRAPPER_IS_NOT_DOM_BINDING;
    #[repr(u32)]
    /// If this bit is set then the wrapper for the native object is not a DOM
    /// binding.
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsWrapperCache__bindgen_ty_2 { WRAPPER_IS_NOT_DOM_BINDING = 2, }
    pub const nsWrapperCache_kWrapperFlagsMask:
              root::nsWrapperCache__bindgen_ty_3 =
        nsWrapperCache__bindgen_ty_3::kWrapperFlagsMask;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsWrapperCache__bindgen_ty_3 { kWrapperFlagsMask = 3, }
    #[test]
    fn bindgen_test_layout_nsWrapperCache() {
        assert_eq!(::std::mem::size_of::<nsWrapperCache>() , 24usize , concat
                   ! ( "Size of: " , stringify ! ( nsWrapperCache ) ));
        assert_eq! (::std::mem::align_of::<nsWrapperCache>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsWrapperCache ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsWrapperCache ) ) . mWrapper as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsWrapperCache ) ,
                    "::" , stringify ! ( mWrapper ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsWrapperCache ) ) . mFlags as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsWrapperCache ) ,
                    "::" , stringify ! ( mFlags ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsWrapperCache ) ) . mBoolFlags as *
                    const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsWrapperCache ) ,
                    "::" , stringify ! ( mBoolFlags ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsILoadGroup {
        pub _base: root::nsIRequest,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsILoadGroup_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsILoadGroup() {
        assert_eq!(::std::mem::size_of::<nsILoadGroup>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsILoadGroup ) ));
        assert_eq! (::std::mem::align_of::<nsILoadGroup>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsILoadGroup ) ));
    }
    impl Clone for nsILoadGroup {
        fn clone(&self) -> Self { *self }
    }
    pub type nsLoadFlags = u32;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIRequest {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIRequest_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsIRequest_LOAD_REQUESTMASK: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_REQUESTMASK;
    pub const nsIRequest_LOAD_NORMAL: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_NORMAL;
    pub const nsIRequest_LOAD_BACKGROUND: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_BACKGROUND;
    pub const nsIRequest_LOAD_HTML_OBJECT_DATA: root::nsIRequest__bindgen_ty_1
              =
        nsIRequest__bindgen_ty_1::LOAD_HTML_OBJECT_DATA;
    pub const nsIRequest_LOAD_DOCUMENT_NEEDS_COOKIE:
              root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_DOCUMENT_NEEDS_COOKIE;
    pub const nsIRequest_INHIBIT_CACHING: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::INHIBIT_CACHING;
    pub const nsIRequest_INHIBIT_PERSISTENT_CACHING:
              root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::INHIBIT_PERSISTENT_CACHING;
    pub const nsIRequest_LOAD_BYPASS_CACHE: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_BYPASS_CACHE;
    pub const nsIRequest_LOAD_FROM_CACHE: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_FROM_CACHE;
    pub const nsIRequest_VALIDATE_ALWAYS: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::VALIDATE_ALWAYS;
    pub const nsIRequest_VALIDATE_NEVER: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::VALIDATE_NEVER;
    pub const nsIRequest_VALIDATE_ONCE_PER_SESSION:
              root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::VALIDATE_ONCE_PER_SESSION;
    pub const nsIRequest_LOAD_ANONYMOUS: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_ANONYMOUS;
    pub const nsIRequest_LOAD_FRESH_CONNECTION: root::nsIRequest__bindgen_ty_1
              =
        nsIRequest__bindgen_ty_1::LOAD_FRESH_CONNECTION;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIRequest__bindgen_ty_1 {
        LOAD_REQUESTMASK = 65535,
        LOAD_NORMAL = 0,
        LOAD_BACKGROUND = 1,
        LOAD_HTML_OBJECT_DATA = 2,
        LOAD_DOCUMENT_NEEDS_COOKIE = 4,
        INHIBIT_CACHING = 128,
        INHIBIT_PERSISTENT_CACHING = 256,
        LOAD_BYPASS_CACHE = 512,
        LOAD_FROM_CACHE = 1024,
        VALIDATE_ALWAYS = 2048,
        VALIDATE_NEVER = 4096,
        VALIDATE_ONCE_PER_SESSION = 8192,
        LOAD_ANONYMOUS = 16384,
        LOAD_FRESH_CONNECTION = 32768,
    }
    #[test]
    fn bindgen_test_layout_nsIRequest() {
        assert_eq!(::std::mem::size_of::<nsIRequest>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIRequest ) ));
        assert_eq! (::std::mem::align_of::<nsIRequest>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIRequest ) ));
    }
    impl Clone for nsIRequest {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIURI {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIURI_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIURI() {
        assert_eq!(::std::mem::size_of::<nsIURI>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIURI ) ));
        assert_eq! (::std::mem::align_of::<nsIURI>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIURI ) ));
    }
    impl Clone for nsIURI {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMNode {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMNode_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsIDOMNode_ELEMENT_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::ELEMENT_NODE;
    pub const nsIDOMNode_ATTRIBUTE_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::ATTRIBUTE_NODE;
    pub const nsIDOMNode_TEXT_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::TEXT_NODE;
    pub const nsIDOMNode_CDATA_SECTION_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::CDATA_SECTION_NODE;
    pub const nsIDOMNode_ENTITY_REFERENCE_NODE: root::nsIDOMNode__bindgen_ty_1
              =
        nsIDOMNode__bindgen_ty_1::ENTITY_REFERENCE_NODE;
    pub const nsIDOMNode_ENTITY_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::ENTITY_NODE;
    pub const nsIDOMNode_PROCESSING_INSTRUCTION_NODE:
              root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::PROCESSING_INSTRUCTION_NODE;
    pub const nsIDOMNode_COMMENT_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::COMMENT_NODE;
    pub const nsIDOMNode_DOCUMENT_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::DOCUMENT_NODE;
    pub const nsIDOMNode_DOCUMENT_TYPE_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::DOCUMENT_TYPE_NODE;
    pub const nsIDOMNode_DOCUMENT_FRAGMENT_NODE:
              root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::DOCUMENT_FRAGMENT_NODE;
    pub const nsIDOMNode_NOTATION_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::NOTATION_NODE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDOMNode__bindgen_ty_1 {
        ELEMENT_NODE = 1,
        ATTRIBUTE_NODE = 2,
        TEXT_NODE = 3,
        CDATA_SECTION_NODE = 4,
        ENTITY_REFERENCE_NODE = 5,
        ENTITY_NODE = 6,
        PROCESSING_INSTRUCTION_NODE = 7,
        COMMENT_NODE = 8,
        DOCUMENT_NODE = 9,
        DOCUMENT_TYPE_NODE = 10,
        DOCUMENT_FRAGMENT_NODE = 11,
        NOTATION_NODE = 12,
    }
    pub const nsIDOMNode_DOCUMENT_POSITION_DISCONNECTED:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_DISCONNECTED;
    pub const nsIDOMNode_DOCUMENT_POSITION_PRECEDING:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_PRECEDING;
    pub const nsIDOMNode_DOCUMENT_POSITION_FOLLOWING:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_FOLLOWING;
    pub const nsIDOMNode_DOCUMENT_POSITION_CONTAINS:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_CONTAINS;
    pub const nsIDOMNode_DOCUMENT_POSITION_CONTAINED_BY:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_CONTAINED_BY;
    pub const nsIDOMNode_DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDOMNode__bindgen_ty_2 {
        DOCUMENT_POSITION_DISCONNECTED = 1,
        DOCUMENT_POSITION_PRECEDING = 2,
        DOCUMENT_POSITION_FOLLOWING = 4,
        DOCUMENT_POSITION_CONTAINS = 8,
        DOCUMENT_POSITION_CONTAINED_BY = 16,
        DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMNode() {
        assert_eq!(::std::mem::size_of::<nsIDOMNode>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIDOMNode ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMNode>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIDOMNode ) ));
    }
    impl Clone for nsIDOMNode {
        fn clone(&self) -> Self { *self }
    }
    /// An internal interface that abstracts some DOMNode-related parts that both
    /// nsIContent and nsIDocument share.  An instance of this interface has a list
    /// of nsIContent children and provides access to them.
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsINode {
        pub _base: root::mozilla::dom::EventTarget,
        pub mNodeInfo: root::RefPtr<root::mozilla::dom::NodeInfo>,
        pub mParent: *mut root::nsINode,
        pub mNextSibling: *mut root::nsIContent,
        pub mPreviousSibling: *mut root::nsIContent,
        pub mFirstChild: *mut root::nsIContent,
        pub __bindgen_anon_1: root::nsINode__bindgen_ty_1,
        pub mSlots: *mut root::nsINode_nsSlots,
    }
    pub type nsINode_BoxQuadOptions = root::mozilla::dom::BoxQuadOptions;
    pub type nsINode_ConvertCoordinateOptions =
        root::mozilla::dom::ConvertCoordinateOptions;
    pub type nsINode_DOMPoint = root::mozilla::dom::DOMPoint;
    pub type nsINode_DOMPointInit = root::mozilla::dom::DOMPointInit;
    pub type nsINode_DOMQuad = root::mozilla::dom::DOMQuad;
    pub type nsINode_DOMRectReadOnly = root::mozilla::dom::DOMRectReadOnly;
    pub type nsINode_OwningNodeOrString =
        root::mozilla::dom::OwningNodeOrString;
    pub type nsINode_TextOrElementOrDocument =
        root::mozilla::dom::TextOrElementOrDocument;
    pub use self::super::root::mozilla::dom::CallerType as nsINode_CallerType;
    pub type nsINode_ErrorResult = root::mozilla::ErrorResult;
    pub type nsINode_Sequence = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsINode_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsINode_eCONTENT: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eCONTENT;
    pub const nsINode_eDOCUMENT: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eDOCUMENT;
    pub const nsINode_eATTRIBUTE: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eATTRIBUTE;
    pub const nsINode_eTEXT: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eTEXT;
    pub const nsINode_ePROCESSING_INSTRUCTION: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::ePROCESSING_INSTRUCTION;
    pub const nsINode_eCOMMENT: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eCOMMENT;
    pub const nsINode_eHTML_FORM_CONTROL: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eHTML_FORM_CONTROL;
    pub const nsINode_eDOCUMENT_FRAGMENT: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eDOCUMENT_FRAGMENT;
    pub const nsINode_eDATA_NODE: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eDATA_NODE;
    pub const nsINode_eMEDIA: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eMEDIA;
    pub const nsINode_eANIMATION: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eANIMATION;
    pub const nsINode_eFILTER: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eFILTER;
    #[repr(u32)]
    /// Bit-flags to pass (or'ed together) to IsNodeOfType()
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsINode__bindgen_ty_2 {
        eCONTENT = 1,
        eDOCUMENT = 2,
        eATTRIBUTE = 4,
        eTEXT = 8,
        ePROCESSING_INSTRUCTION = 16,
        eCOMMENT = 32,
        eHTML_FORM_CONTROL = 64,
        eDOCUMENT_FRAGMENT = 128,
        eDATA_NODE = 256,
        eMEDIA = 512,
        eANIMATION = 1024,
        eFILTER = 2048,
    }
    #[repr(C)]
    pub struct nsINode_nsSlots__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsINode_nsSlots {
        pub vtable_: *const nsINode_nsSlots__bindgen_vtable,
        /// A list of mutation observers
        pub mMutationObservers: [u64; 4usize],
        /// An object implementing nsIDOMNodeList for this content (childNodes)
        /// @see nsIDOMNodeList
        /// @see nsGenericHTMLElement::GetChildNodes
        pub mChildNodes: root::RefPtr<root::nsAttrChildContentList>,
        /// Weak reference to this node.  This is cleared by the destructor of
        /// nsNodeWeakReference.
        pub mWeakReference: *mut root::nsNodeWeakReference,
        /// A set of ranges which are in the selection and which have this node as
        /// their endpoints' common ancestor.  This is a UniquePtr instead of just a
        /// LinkedList, because that prevents us from pushing DOMSlots up to the next
        /// allocation bucket size, at the cost of some complexity.
        pub mCommonAncestorRanges: root::mozilla::UniquePtr<root::mozilla::LinkedList>,
        /// Number of descendant nodes in the uncomposed document that have been
        /// explicitly set as editable.
        pub mEditableDescendantCount: u32,
    }
    #[test]
    fn bindgen_test_layout_nsINode_nsSlots() {
        assert_eq!(::std::mem::size_of::<nsINode_nsSlots>() , 72usize , concat
                   ! ( "Size of: " , stringify ! ( nsINode_nsSlots ) ));
        assert_eq! (::std::mem::align_of::<nsINode_nsSlots>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsINode_nsSlots ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode_nsSlots ) ) .
                    mMutationObservers as * const _ as usize } , 8usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsINode_nsSlots ) ,
                    "::" , stringify ! ( mMutationObservers ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode_nsSlots ) ) . mChildNodes as
                    * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode_nsSlots ) ,
                    "::" , stringify ! ( mChildNodes ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode_nsSlots ) ) . mWeakReference
                    as * const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode_nsSlots ) ,
                    "::" , stringify ! ( mWeakReference ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode_nsSlots ) ) .
                    mCommonAncestorRanges as * const _ as usize } , 56usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsINode_nsSlots ) ,
                    "::" , stringify ! ( mCommonAncestorRanges ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode_nsSlots ) ) .
                    mEditableDescendantCount as * const _ as usize } , 64usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode_nsSlots ) ,
                    "::" , stringify ! ( mEditableDescendantCount ) ));
    }
    #[repr(u32)]
    /// Boolean flags
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsINode_BooleanFlag {
        NodeHasRenderingObservers = 0,
        IsInDocument = 1,
        ParentIsContent = 2,
        NodeIsElement = 3,
        ElementHasID = 4,
        ElementMayHaveClass = 5,
        ElementMayHaveStyle = 6,
        ElementHasName = 7,
        ElementMayHaveContentEditableAttr = 8,
        NodeIsCommonAncestorForRangeInSelection = 9,
        NodeIsDescendantOfCommonAncestorForRangeInSelection = 10,
        NodeIsCCMarkedRoot = 11,
        NodeIsCCBlackTree = 12,
        NodeIsPurpleRoot = 13,
        ElementHasLockedStyleStates = 14,
        ElementHasPointerLock = 15,
        NodeMayHaveDOMMutationObserver = 16,
        NodeIsContent = 17,
        ElementHasAnimations = 18,
        NodeHasValidDirAttribute = 19,
        NodeHasDirAutoSet = 20,
        NodeHasTextNodeDirectionalityMap = 21,
        NodeAncestorHasDirAuto = 22,
        ElementIsInStyleScope = 23,
        ElementIsScopedStyleRoot = 24,
        NodeHandlingClick = 25,
        NodeHasRelevantHoverRules = 26,
        ElementHasWeirdParserInsertionMode = 27,
        ParserHasNotified = 28,
        MayBeApzAware = 29,
        ElementMayHaveAnonymousChildren = 30,
        NodeMayHaveChildrenWithLayoutBoxesDisabled = 31,
        BooleanFlagCount = 32,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsINode__bindgen_ty_1 {
        pub mPrimaryFrame: root::__BindgenUnionField<*mut root::nsIFrame>,
        pub mSubtreeRoot: root::__BindgenUnionField<*mut root::nsINode>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsINode__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsINode__bindgen_ty_1>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsINode__bindgen_ty_1 ) ));
        assert_eq! (::std::mem::align_of::<nsINode__bindgen_ty_1>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsINode__bindgen_ty_1 )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode__bindgen_ty_1 ) ) .
                    mPrimaryFrame as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsINode__bindgen_ty_1 ) , "::" , stringify ! (
                    mPrimaryFrame ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode__bindgen_ty_1 ) ) .
                    mSubtreeRoot as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsINode__bindgen_ty_1 ) , "::" , stringify ! (
                    mSubtreeRoot ) ));
    }
    impl Clone for nsINode__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsINode() {
        assert_eq!(::std::mem::size_of::<nsINode>() , 88usize , concat ! (
                   "Size of: " , stringify ! ( nsINode ) ));
        assert_eq! (::std::mem::align_of::<nsINode>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsINode ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode ) ) . mNodeInfo as * const _
                    as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode ) , "::" ,
                    stringify ! ( mNodeInfo ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode ) ) . mParent as * const _ as
                    usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode ) , "::" ,
                    stringify ! ( mParent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode ) ) . mNextSibling as * const
                    _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode ) , "::" ,
                    stringify ! ( mNextSibling ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode ) ) . mPreviousSibling as *
                    const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode ) , "::" ,
                    stringify ! ( mPreviousSibling ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode ) ) . mFirstChild as * const
                    _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode ) , "::" ,
                    stringify ! ( mFirstChild ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode ) ) . mSlots as * const _ as
                    usize } , 80usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode ) , "::" ,
                    stringify ! ( mSlots ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIRedirectHistoryEntry {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSAutoRequest {
        pub mContext: *mut root::JSContext,
        pub _mCheckNotUsedAsTemporary: root::mozilla::detail::GuardObjectNotificationReceiver,
    }
    #[test]
    fn bindgen_test_layout_JSAutoRequest() {
        assert_eq!(::std::mem::size_of::<JSAutoRequest>() , 16usize , concat !
                   ( "Size of: " , stringify ! ( JSAutoRequest ) ));
        assert_eq! (::std::mem::align_of::<JSAutoRequest>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( JSAutoRequest ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSAutoRequest ) ) . mContext as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSAutoRequest ) ,
                    "::" , stringify ! ( mContext ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSAutoRequest ) ) .
                    _mCheckNotUsedAsTemporary as * const _ as usize } , 8usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( JSAutoRequest ) ,
                    "::" , stringify ! ( _mCheckNotUsedAsTemporary ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSAutoCompartment {
        pub cx_: *mut root::JSContext,
        pub oldCompartment_: *mut root::JSCompartment,
        pub _mCheckNotUsedAsTemporary: root::mozilla::detail::GuardObjectNotificationReceiver,
    }
    #[test]
    fn bindgen_test_layout_JSAutoCompartment() {
        assert_eq!(::std::mem::size_of::<JSAutoCompartment>() , 24usize ,
                   concat ! ( "Size of: " , stringify ! ( JSAutoCompartment )
                   ));
        assert_eq! (::std::mem::align_of::<JSAutoCompartment>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( JSAutoCompartment ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSAutoCompartment ) ) . cx_ as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSAutoCompartment )
                    , "::" , stringify ! ( cx_ ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSAutoCompartment ) ) .
                    oldCompartment_ as * const _ as usize } , 8usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( JSAutoCompartment )
                    , "::" , stringify ! ( oldCompartment_ ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSAutoCompartment ) ) .
                    _mCheckNotUsedAsTemporary as * const _ as usize } ,
                    16usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSAutoCompartment )
                    , "::" , stringify ! ( _mCheckNotUsedAsTemporary ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSAutoNullableCompartment {
        pub cx_: *mut root::JSContext,
        pub oldCompartment_: *mut root::JSCompartment,
        pub _mCheckNotUsedAsTemporary: root::mozilla::detail::GuardObjectNotificationReceiver,
    }
    #[test]
    fn bindgen_test_layout_JSAutoNullableCompartment() {
        assert_eq!(::std::mem::size_of::<JSAutoNullableCompartment>() ,
                   24usize , concat ! (
                   "Size of: " , stringify ! ( JSAutoNullableCompartment ) ));
        assert_eq! (::std::mem::align_of::<JSAutoNullableCompartment>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( JSAutoNullableCompartment
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSAutoNullableCompartment ) ) . cx_
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    JSAutoNullableCompartment ) , "::" , stringify ! ( cx_ )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSAutoNullableCompartment ) ) .
                    oldCompartment_ as * const _ as usize } , 8usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    JSAutoNullableCompartment ) , "::" , stringify ! (
                    oldCompartment_ ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSAutoNullableCompartment ) ) .
                    _mCheckNotUsedAsTemporary as * const _ as usize } ,
                    16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    JSAutoNullableCompartment ) , "::" , stringify ! (
                    _mCheckNotUsedAsTemporary ) ));
    }
    /// Base class that implements parts shared by JSErrorReport and
    /// JSErrorNotes::Note.
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSErrorBase {
        pub message_: root::JS::ConstUTF8CharsZ,
        pub filename: *const ::std::os::raw::c_char,
        pub lineno: ::std::os::raw::c_uint,
        pub column: ::std::os::raw::c_uint,
        pub errorNumber: ::std::os::raw::c_uint,
        pub _bitfield_1: u8,
        pub __bindgen_padding_0: [u8; 3usize],
    }
    #[test]
    fn bindgen_test_layout_JSErrorBase() {
        assert_eq!(::std::mem::size_of::<JSErrorBase>() , 32usize , concat ! (
                   "Size of: " , stringify ! ( JSErrorBase ) ));
        assert_eq! (::std::mem::align_of::<JSErrorBase>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( JSErrorBase ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorBase ) ) . message_ as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorBase ) ,
                    "::" , stringify ! ( message_ ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorBase ) ) . filename as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorBase ) ,
                    "::" , stringify ! ( filename ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorBase ) ) . lineno as * const _
                    as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorBase ) ,
                    "::" , stringify ! ( lineno ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorBase ) ) . column as * const _
                    as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorBase ) ,
                    "::" , stringify ! ( column ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorBase ) ) . errorNumber as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorBase ) ,
                    "::" , stringify ! ( errorNumber ) ));
    }
    impl JSErrorBase {
        #[inline]
        pub fn ownsMessage_(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 1u64 as u8;
            let val = (unit_field_val & mask) >> 0usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_ownsMessage_(&mut self, val: bool) {
            let mask = 1u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 0usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn new_bitfield_1(ownsMessage_: bool) -> u8 {
            ({ 0 } | ((ownsMessage_ as u8 as u8) << 0usize) & (1u64 as u8))
        }
    }
    /// Notes associated with JSErrorReport.
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSErrorNotes {
        pub notes_: [u64; 6usize],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSErrorNotes_Note {
        pub _base: root::JSErrorBase,
    }
    #[test]
    fn bindgen_test_layout_JSErrorNotes_Note() {
        assert_eq!(::std::mem::size_of::<JSErrorNotes_Note>() , 32usize ,
                   concat ! ( "Size of: " , stringify ! ( JSErrorNotes_Note )
                   ));
        assert_eq! (::std::mem::align_of::<JSErrorNotes_Note>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( JSErrorNotes_Note ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSErrorNotes_iterator {
        pub note_: *mut root::mozilla::UniquePtr<root::JSErrorNotes_Note>,
    }
    #[test]
    fn bindgen_test_layout_JSErrorNotes_iterator() {
        assert_eq!(::std::mem::size_of::<JSErrorNotes_iterator>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( JSErrorNotes_iterator ) ));
        assert_eq! (::std::mem::align_of::<JSErrorNotes_iterator>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( JSErrorNotes_iterator )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorNotes_iterator ) ) . note_ as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    JSErrorNotes_iterator ) , "::" , stringify ! ( note_ ) ));
    }
    #[test]
    fn bindgen_test_layout_JSErrorNotes() {
        assert_eq!(::std::mem::size_of::<JSErrorNotes>() , 48usize , concat !
                   ( "Size of: " , stringify ! ( JSErrorNotes ) ));
        assert_eq! (::std::mem::align_of::<JSErrorNotes>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( JSErrorNotes ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorNotes ) ) . notes_ as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorNotes ) ,
                    "::" , stringify ! ( notes_ ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsISerializable {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISerializable_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsISerializable() {
        assert_eq!(::std::mem::size_of::<nsISerializable>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsISerializable ) ));
        assert_eq! (::std::mem::align_of::<nsISerializable>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsISerializable ) ));
    }
    impl Clone for nsISerializable {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIChannel {
        pub _base: root::nsIRequest,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIChannel_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsIChannel_LOAD_DOCUMENT_URI: root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_DOCUMENT_URI;
    pub const nsIChannel_LOAD_RETARGETED_DOCUMENT_URI:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_RETARGETED_DOCUMENT_URI;
    pub const nsIChannel_LOAD_REPLACE: root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_REPLACE;
    pub const nsIChannel_LOAD_INITIAL_DOCUMENT_URI:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_INITIAL_DOCUMENT_URI;
    pub const nsIChannel_LOAD_TARGETED: root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_TARGETED;
    pub const nsIChannel_LOAD_CALL_CONTENT_SNIFFERS:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_CALL_CONTENT_SNIFFERS;
    pub const nsIChannel_LOAD_CLASSIFY_URI: root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_CLASSIFY_URI;
    pub const nsIChannel_LOAD_MEDIA_SNIFFER_OVERRIDES_CONTENT_TYPE:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_MEDIA_SNIFFER_OVERRIDES_CONTENT_TYPE;
    pub const nsIChannel_LOAD_EXPLICIT_CREDENTIALS:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_EXPLICIT_CREDENTIALS;
    pub const nsIChannel_LOAD_BYPASS_SERVICE_WORKER:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_BYPASS_SERVICE_WORKER;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIChannel__bindgen_ty_1 {
        LOAD_DOCUMENT_URI = 65536,
        LOAD_RETARGETED_DOCUMENT_URI = 131072,
        LOAD_REPLACE = 262144,
        LOAD_INITIAL_DOCUMENT_URI = 524288,
        LOAD_TARGETED = 1048576,
        LOAD_CALL_CONTENT_SNIFFERS = 2097152,
        LOAD_CLASSIFY_URI = 4194304,
        LOAD_MEDIA_SNIFFER_OVERRIDES_CONTENT_TYPE = 8388608,
        LOAD_EXPLICIT_CREDENTIALS = 16777216,
        LOAD_BYPASS_SERVICE_WORKER = 33554432,
    }
    pub const nsIChannel_DISPOSITION_INLINE: root::nsIChannel__bindgen_ty_2 =
        nsIChannel__bindgen_ty_2::DISPOSITION_INLINE;
    pub const nsIChannel_DISPOSITION_ATTACHMENT:
              root::nsIChannel__bindgen_ty_2 =
        nsIChannel__bindgen_ty_2::DISPOSITION_ATTACHMENT;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIChannel__bindgen_ty_2 {
        DISPOSITION_INLINE = 0,
        DISPOSITION_ATTACHMENT = 1,
    }
    #[test]
    fn bindgen_test_layout_nsIChannel() {
        assert_eq!(::std::mem::size_of::<nsIChannel>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIChannel ) ));
        assert_eq! (::std::mem::align_of::<nsIChannel>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIChannel ) ));
    }
    impl Clone for nsIChannel {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIStreamListener {
        pub _base: root::nsIRequestObserver,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIStreamListener_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIStreamListener() {
        assert_eq!(::std::mem::size_of::<nsIStreamListener>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsIStreamListener )
                   ));
        assert_eq! (::std::mem::align_of::<nsIStreamListener>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIStreamListener ) ));
    }
    impl Clone for nsIStreamListener {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsICSSLoaderObserver {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsICSSLoaderObserver_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsICSSLoaderObserver() {
        assert_eq!(::std::mem::size_of::<nsICSSLoaderObserver>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsICSSLoaderObserver ) ));
        assert_eq! (::std::mem::align_of::<nsICSSLoaderObserver>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsICSSLoaderObserver ) ));
    }
    impl Clone for nsICSSLoaderObserver {
        fn clone(&self) -> Self { *self }
    }
    pub type DOMHighResTimeStamp = f64;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMAttr {
        pub _base: root::nsIDOMNode,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMAttr_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMAttr() {
        assert_eq!(::std::mem::size_of::<nsIDOMAttr>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIDOMAttr ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMAttr>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIDOMAttr ) ));
    }
    impl Clone for nsIDOMAttr {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMClientRect {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMClientRect_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMClientRect() {
        assert_eq!(::std::mem::size_of::<nsIDOMClientRect>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsIDOMClientRect ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMClientRect>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMClientRect ) ));
    }
    impl Clone for nsIDOMClientRect {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMStyleSheet {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMStyleSheet_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMStyleSheet() {
        assert_eq!(::std::mem::size_of::<nsIDOMStyleSheet>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsIDOMStyleSheet ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMStyleSheet>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMStyleSheet ) ));
    }
    impl Clone for nsIDOMStyleSheet {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMMediaList {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMMediaList_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMMediaList() {
        assert_eq!(::std::mem::size_of::<nsIDOMMediaList>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsIDOMMediaList ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMMediaList>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMMediaList ) ));
    }
    impl Clone for nsIDOMMediaList {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMEventTarget {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMEventTarget_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMEventTarget() {
        assert_eq!(::std::mem::size_of::<nsIDOMEventTarget>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsIDOMEventTarget )
                   ));
        assert_eq! (::std::mem::align_of::<nsIDOMEventTarget>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMEventTarget ) ));
    }
    impl Clone for nsIDOMEventTarget {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMHTMLCollection {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMHTMLCollection_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMHTMLCollection() {
        assert_eq!(::std::mem::size_of::<nsIDOMHTMLCollection>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIDOMHTMLCollection ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMHTMLCollection>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMHTMLCollection ) ));
    }
    impl Clone for nsIDOMHTMLCollection {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMCSSRule {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMCSSRule_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsIDOMCSSRule_UNKNOWN_RULE: root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::UNKNOWN_RULE;
    pub const nsIDOMCSSRule_STYLE_RULE: root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::STYLE_RULE;
    pub const nsIDOMCSSRule_CHARSET_RULE: root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::CHARSET_RULE;
    pub const nsIDOMCSSRule_IMPORT_RULE: root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::IMPORT_RULE;
    pub const nsIDOMCSSRule_MEDIA_RULE: root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::MEDIA_RULE;
    pub const nsIDOMCSSRule_FONT_FACE_RULE: root::nsIDOMCSSRule__bindgen_ty_1
              =
        nsIDOMCSSRule__bindgen_ty_1::FONT_FACE_RULE;
    pub const nsIDOMCSSRule_PAGE_RULE: root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::PAGE_RULE;
    pub const nsIDOMCSSRule_KEYFRAMES_RULE: root::nsIDOMCSSRule__bindgen_ty_1
              =
        nsIDOMCSSRule__bindgen_ty_1::KEYFRAMES_RULE;
    pub const nsIDOMCSSRule_KEYFRAME_RULE: root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::KEYFRAME_RULE;
    pub const nsIDOMCSSRule_MOZ_KEYFRAMES_RULE:
              root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::KEYFRAMES_RULE;
    pub const nsIDOMCSSRule_MOZ_KEYFRAME_RULE:
              root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::KEYFRAME_RULE;
    pub const nsIDOMCSSRule_NAMESPACE_RULE: root::nsIDOMCSSRule__bindgen_ty_1
              =
        nsIDOMCSSRule__bindgen_ty_1::NAMESPACE_RULE;
    pub const nsIDOMCSSRule_COUNTER_STYLE_RULE:
              root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::COUNTER_STYLE_RULE;
    pub const nsIDOMCSSRule_SUPPORTS_RULE: root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::SUPPORTS_RULE;
    pub const nsIDOMCSSRule_DOCUMENT_RULE: root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::DOCUMENT_RULE;
    pub const nsIDOMCSSRule_FONT_FEATURE_VALUES_RULE:
              root::nsIDOMCSSRule__bindgen_ty_1 =
        nsIDOMCSSRule__bindgen_ty_1::FONT_FEATURE_VALUES_RULE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDOMCSSRule__bindgen_ty_1 {
        UNKNOWN_RULE = 0,
        STYLE_RULE = 1,
        CHARSET_RULE = 2,
        IMPORT_RULE = 3,
        MEDIA_RULE = 4,
        FONT_FACE_RULE = 5,
        PAGE_RULE = 6,
        KEYFRAMES_RULE = 7,
        KEYFRAME_RULE = 8,
        NAMESPACE_RULE = 10,
        COUNTER_STYLE_RULE = 11,
        SUPPORTS_RULE = 12,
        DOCUMENT_RULE = 13,
        FONT_FEATURE_VALUES_RULE = 14,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMCSSRule() {
        assert_eq!(::std::mem::size_of::<nsIDOMCSSRule>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( nsIDOMCSSRule ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMCSSRule>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsIDOMCSSRule ) ));
    }
    impl Clone for nsIDOMCSSRule {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMCSSStyleSheet {
        pub _base: root::nsIDOMStyleSheet,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMCSSStyleSheet_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMCSSStyleSheet() {
        assert_eq!(::std::mem::size_of::<nsIDOMCSSStyleSheet>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIDOMCSSStyleSheet ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMCSSStyleSheet>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMCSSStyleSheet ) ));
    }
    impl Clone for nsIDOMCSSStyleSheet {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMCSSStyleDeclaration {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMCSSStyleDeclaration_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMCSSStyleDeclaration() {
        assert_eq!(::std::mem::size_of::<nsIDOMCSSStyleDeclaration>() , 8usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsIDOMCSSStyleDeclaration ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMCSSStyleDeclaration>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIDOMCSSStyleDeclaration
                    ) ));
    }
    impl Clone for nsIDOMCSSStyleDeclaration {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsScriptObjectTracer {
        pub _base: root::nsCycleCollectionParticipant,
    }
    #[test]
    fn bindgen_test_layout_nsScriptObjectTracer() {
        assert_eq!(::std::mem::size_of::<nsScriptObjectTracer>() , 16usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsScriptObjectTracer ) ));
        assert_eq! (::std::mem::align_of::<nsScriptObjectTracer>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsScriptObjectTracer ) ));
    }
    impl Clone for nsScriptObjectTracer {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsXPCOMCycleCollectionParticipant {
        pub _base: root::nsScriptObjectTracer,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsXPCOMCycleCollectionParticipant_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsXPCOMCycleCollectionParticipant() {
        assert_eq!(::std::mem::size_of::<nsXPCOMCycleCollectionParticipant>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsXPCOMCycleCollectionParticipant ) ));
        assert_eq! (::std::mem::align_of::<nsXPCOMCycleCollectionParticipant>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsXPCOMCycleCollectionParticipant ) ));
    }
    impl Clone for nsXPCOMCycleCollectionParticipant {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIDocument {
        pub _base: root::nsINode,
        pub _base_1: root::mozilla::dom::DispatcherTrait,
        pub mDeprecationWarnedAbout: u64,
        pub mDocWarningWarnedAbout: u64,
        pub mSelectorCache: root::nsAutoPtr<root::nsIDocument_SelectorCache>,
        pub mReferrer: root::nsCString,
        pub mLastModified: ::nsstring::nsStringRepr,
        pub mDocumentURI: root::nsCOMPtr<root::nsIURI>,
        pub mOriginalURI: root::nsCOMPtr<root::nsIURI>,
        pub mChromeXHRDocURI: root::nsCOMPtr<root::nsIURI>,
        pub mDocumentBaseURI: root::nsCOMPtr<root::nsIURI>,
        pub mChromeXHRDocBaseURI: root::nsCOMPtr<root::nsIURI>,
        pub mCachedURLData: root::RefPtr<root::mozilla::URLExtraData>,
        pub mDocumentLoadGroup: root::nsWeakPtr,
        pub mReferrerPolicySet: bool,
        pub mReferrerPolicy: root::nsIDocument_ReferrerPolicyEnum,
        pub mBlockAllMixedContent: bool,
        pub mBlockAllMixedContentPreloads: bool,
        pub mUpgradeInsecureRequests: bool,
        pub mUpgradeInsecurePreloads: bool,
        pub mHSTSPrimingURIList: [u64; 6usize],
        pub mDocumentContainer: u64,
        pub mCharacterSet: root::mozilla::NotNull<*const root::nsIDocument_Encoding>,
        pub mCharacterSetSource: i32,
        pub mParentDocument: *mut root::nsIDocument,
        pub mCachedRootElement: *mut root::mozilla::dom::Element,
        pub mNodeInfoManager: *mut root::nsNodeInfoManager,
        pub mCSSLoader: root::RefPtr<root::mozilla::css::Loader>,
        pub mStyleImageLoader: root::RefPtr<root::mozilla::css::ImageLoader>,
        pub mAttrStyleSheet: root::RefPtr<root::nsHTMLStyleSheet>,
        pub mStyleAttrStyleSheet: root::RefPtr<root::nsHTMLCSSStyleSheet>,
        pub mImageTracker: root::RefPtr<root::mozilla::dom::ImageTracker>,
        pub mActivityObservers: u64,
        pub mLinksToUpdate: [u64; 3usize],
        pub mAnimationController: root::RefPtr<root::nsSMILAnimationController>,
        pub mPropertyTable: root::nsPropertyTable,
        pub mExtraPropertyTables: root::nsTArray<root::nsAutoPtr<root::nsPropertyTable>>,
        pub mChildrenCollection: root::nsCOMPtr<root::nsIHTMLCollection>,
        pub mFontFaceSet: root::RefPtr<root::mozilla::dom::FontFaceSet>,
        pub mLastFocusTime: root::mozilla::TimeStamp,
        pub _bitfield_1: [u8; 7usize],
        pub mCompatMode: root::nsCompatibility,
        pub mReadyState: root::nsIDocument_ReadyState,
        pub mStyleBackendType: root::mozilla::StyleBackendType,
        pub mVisibilityState: root::mozilla::dom::VisibilityState,
        pub mType: root::nsIDocument_Type,
        pub mDefaultElementType: u8,
        pub mAllowXULXBL: root::nsIDocument_Tri,
        /// This is true while FlushPendingLinkUpdates executes.  Calls to
        /// [Un]RegisterPendingLinkUpdate will assert when this is true.
        pub mIsLinkUpdateRegistrationsForbidden: bool,
        pub mScriptGlobalObject: root::nsCOMPtr<root::nsIScriptGlobalObject>,
        pub mOriginalDocument: root::nsCOMPtr<root::nsIDocument>,
        pub mBidiOptions: u32,
        pub mSandboxFlags: u32,
        pub mContentLanguage: root::nsCString,
        pub mChannel: root::nsCOMPtr<root::nsIChannel>,
        pub mContentType: root::nsCString,
        pub mId: ::nsstring::nsStringRepr,
        pub mSecurityInfo: root::nsCOMPtr<root::nsISupports>,
        pub mFailedChannel: root::nsCOMPtr<root::nsIChannel>,
        pub mPartID: u32,
        pub mMarkedCCGeneration: u32,
        pub mPresShell: *mut root::nsIPresShell,
        pub mSubtreeModifiedTargets: root::nsCOMArray,
        pub mSubtreeModifiedDepth: u32,
        pub mDisplayDocument: root::nsCOMPtr<root::nsIDocument>,
        pub mEventsSuppressed: u32,
        /// The number number of external scripts (ones with the src attribute) that
        /// have this document as their owner and that are being evaluated right now.
        pub mExternalScriptsBeingEvaluated: u32,
        /// The current frame request callback handle
        pub mFrameRequestCallbackCounter: i32,
        pub mStaticCloneCount: u32,
        pub mBlockedTrackingNodes: root::nsTArray<root::nsWeakPtr>,
        pub mWindow: *mut root::nsPIDOMWindowInner,
        pub mCachedEncoder: root::nsCOMPtr<root::nsIDocumentEncoder>,
        pub mFrameRequestCallbacks: root::nsTArray<root::nsIDocument_FrameRequest>,
        pub mBFCacheEntry: *mut root::nsIBFCacheEntry,
        pub mBaseTarget: ::nsstring::nsStringRepr,
        pub mStateObjectContainer: root::nsCOMPtr<root::nsIStructuredCloneContainer>,
        pub mStateObjectCached: root::nsCOMPtr<root::nsIVariant>,
        pub mInSyncOperationCount: u32,
        pub mXPathEvaluator: root::RefPtr<root::mozilla::dom::XPathEvaluator>,
        pub mAnonymousContents: root::nsTArray<root::RefPtr<root::mozilla::dom::AnonymousContent>>,
        pub mBlockDOMContentLoaded: u32,
        pub mDOMMediaQueryLists: root::mozilla::LinkedList,
        pub mUseCounters: [u64; 2usize],
        pub mChildDocumentUseCounters: [u64; 2usize],
        pub mNotifiedPageForUseCounter: [u64; 2usize],
        pub mIncCounters: u16,
        pub mUserHasInteracted: bool,
        pub mPageUnloadingEventTimeStamp: root::mozilla::TimeStamp,
        pub mDocGroup: root::RefPtr<root::mozilla::dom::DocGroup>,
        pub mTrackingScripts: [u64; 6usize],
        pub mBufferedCSPViolations: root::nsTArray<root::nsCOMPtr<root::nsIRunnable>>,
        pub mServoRestyleRoot: root::nsCOMPtr<root::nsINode>,
        pub mServoRestyleRootDirtyBits: u32,
    }
    pub type nsIDocument_GlobalObject = root::mozilla::dom::GlobalObject;
    pub type nsIDocument_Encoding = root::mozilla::Encoding;
    pub type nsIDocument_NotNull<T> = root::mozilla::NotNull<T>;
    pub use self::super::root::mozilla::net::ReferrerPolicy as
            nsIDocument_ReferrerPolicyEnum;
    pub type nsIDocument_Element = root::mozilla::dom::Element;
    pub type nsIDocument_FullscreenRequest =
        root::mozilla::dom::FullscreenRequest;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDocument_COMTypeInfo {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIDocument_PageUnloadingEventTimeStamp {
        pub mDocument: root::nsCOMPtr<root::nsIDocument>,
        pub mSet: bool,
    }
    #[test]
    fn bindgen_test_layout_nsIDocument_PageUnloadingEventTimeStamp() {
        assert_eq!(::std::mem::size_of::<nsIDocument_PageUnloadingEventTimeStamp>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsIDocument_PageUnloadingEventTimeStamp ) ));
        assert_eq! (::std::mem::align_of::<nsIDocument_PageUnloadingEventTimeStamp>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsIDocument_PageUnloadingEventTimeStamp ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsIDocument_PageUnloadingEventTimeStamp )
                    ) . mDocument as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsIDocument_PageUnloadingEventTimeStamp ) , "::" ,
                    stringify ! ( mDocument ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsIDocument_PageUnloadingEventTimeStamp )
                    ) . mSet as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsIDocument_PageUnloadingEventTimeStamp ) , "::" ,
                    stringify ! ( mSet ) ));
    }
    /// This gets fired when the element that an id refers to changes.
    /// This fires at difficult times. It is generally not safe to do anything
    /// which could modify the DOM in any way. Use
    /// nsContentUtils::AddScriptRunner.
    /// @return true to keep the callback in the callback set, false
    /// to remove it.
    pub type nsIDocument_IDTargetObserver =
        ::std::option::Option<unsafe extern "C" fn(aOldElement:
                                                       *mut root::nsIDocument_Element,
                                                   aNewelement:
                                                       *mut root::nsIDocument_Element,
                                                   aData:
                                                       *mut ::std::os::raw::c_void)
                                  -> bool>;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIDocument_SelectorCacheKey {
        pub mKey: ::nsstring::nsStringRepr,
        pub mState: root::nsExpirationState,
    }
    #[test]
    fn bindgen_test_layout_nsIDocument_SelectorCacheKey() {
        assert_eq!(::std::mem::size_of::<nsIDocument_SelectorCacheKey>() ,
                   24usize , concat ! (
                   "Size of: " , stringify ! ( nsIDocument_SelectorCacheKey )
                   ));
        assert_eq! (::std::mem::align_of::<nsIDocument_SelectorCacheKey>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsIDocument_SelectorCacheKey ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIDocument_SelectorCacheKey ) ) .
                    mKey as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsIDocument_SelectorCacheKey ) , "::" , stringify ! ( mKey
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIDocument_SelectorCacheKey ) ) .
                    mState as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsIDocument_SelectorCacheKey ) , "::" , stringify ! (
                    mState ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDocument_SelectorCacheKeyDeleter {
        _unused: [u8; 0],
    }
    #[repr(C)]
    pub struct nsIDocument_SelectorCache__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDocument_SelectorCache {
        pub _bindgen_opaque_blob: [u64; 18usize],
    }
    #[test]
    fn bindgen_test_layout_nsIDocument_SelectorCache() {
        assert_eq!(::std::mem::size_of::<nsIDocument_SelectorCache>() ,
                   144usize , concat ! (
                   "Size of: " , stringify ! ( nsIDocument_SelectorCache ) ));
        assert_eq! (::std::mem::align_of::<nsIDocument_SelectorCache>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIDocument_SelectorCache
                    ) ));
    }
    impl Clone for nsIDocument_SelectorCache {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_additionalSheetType {
        eAgentSheet = 0,
        eUserSheet = 1,
        eAuthorSheet = 2,
        AdditionalSheetTypeCount = 3,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_ReadyState {
        READYSTATE_UNINITIALIZED = 0,
        READYSTATE_LOADING = 1,
        READYSTATE_INTERACTIVE = 3,
        READYSTATE_COMPLETE = 4,
    }
    /// Enumerate all subdocuments.
    /// The enumerator callback should return true to continue enumerating, or
    /// false to stop.  This will never get passed a null aDocument.
    pub type nsIDocument_nsSubDocEnumFunc =
        ::std::option::Option<unsafe extern "C" fn(aDocument:
                                                       *mut root::nsIDocument,
                                                   aData:
                                                       *mut ::std::os::raw::c_void)
                                  -> bool>;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_ElementsFromPointFlags {
        IGNORE_ROOT_SCROLL_FRAME = 1,
        FLUSH_LAYOUT = 2,
        IS_ELEMENT_FROM_POINT = 4,
    }
    /// A class that represents an external resource load that has begun but
    /// doesn't have a document yet.  Observers can be registered on this object,
    /// and will be notified after the document is created.  Observers registered
    /// after the document has been created will NOT be notified.  When observers
    /// are notified, the subject will be the newly-created document, the topic
    /// will be "external-resource-document-created", and the data will be null.
    /// If document creation fails for some reason, observers will still be
    /// notified, with a null document pointer.
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIDocument_ExternalResourceLoad {
        pub _base: root::nsISupports,
        pub mObservers: [u64; 10usize],
    }
    #[test]
    fn bindgen_test_layout_nsIDocument_ExternalResourceLoad() {
        assert_eq!(::std::mem::size_of::<nsIDocument_ExternalResourceLoad>() ,
                   88usize , concat ! (
                   "Size of: " , stringify ! (
                   nsIDocument_ExternalResourceLoad ) ));
        assert_eq! (::std::mem::align_of::<nsIDocument_ExternalResourceLoad>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsIDocument_ExternalResourceLoad ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIDocument_ExternalResourceLoad ) )
                    . mObservers as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsIDocument_ExternalResourceLoad ) , "::" , stringify ! (
                    mObservers ) ));
    }
    pub type nsIDocument_ActivityObserverEnumerator =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::nsISupports,
                                                   arg2:
                                                       *mut ::std::os::raw::c_void)>;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_DocumentTheme {
        Doc_Theme_Uninitialized = 0,
        Doc_Theme_None = 1,
        Doc_Theme_Neutral = 2,
        Doc_Theme_Dark = 3,
        Doc_Theme_Bright = 4,
    }
    pub type nsIDocument_FrameRequestCallbackList =
        root::nsTArray<root::RefPtr<root::mozilla::dom::FrameRequestCallback>>;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_DeprecatedOperations {
        eGetAttributeNode = 0,
        eSetAttributeNode = 1,
        eGetAttributeNodeNS = 2,
        eSetAttributeNodeNS = 3,
        eRemoveAttributeNode = 4,
        eCreateAttribute = 5,
        eCreateAttributeNS = 6,
        eNodeValue = 7,
        eTextContent = 8,
        eEnablePrivilege = 9,
        eDOMExceptionCode = 10,
        eNoExposedProps = 11,
        eMutationEvent = 12,
        eComponents = 13,
        ePrefixedVisibilityAPI = 14,
        eNodeIteratorDetach = 15,
        eLenientThis = 16,
        eGetPreventDefault = 17,
        eGetSetUserData = 18,
        eMozGetAsFile = 19,
        eUseOfCaptureEvents = 20,
        eUseOfReleaseEvents = 21,
        eUseOfDOM3LoadMethod = 22,
        eChromeUseOfDOM3LoadMethod = 23,
        eShowModalDialog = 24,
        eWindow_Content = 25,
        eSyncXMLHttpRequest = 26,
        eWindow_Cc_ontrollers = 27,
        eImportXULIntoContent = 28,
        ePannerNodeDoppler = 29,
        eNavigatorGetUserMedia = 30,
        eWebrtcDeprecatedPrefix = 31,
        eRTCPeerConnectionGetStreams = 32,
        eAppCache = 33,
        ePrefixedImageSmoothingEnabled = 34,
        ePrefixedFullscreenAPI = 35,
        eLenientSetter = 36,
        eFileLastModifiedDate = 37,
        eImageBitmapRenderingContext_TransferImageBitmap = 38,
        eURLCreateObjectURL_MediaStream = 39,
        eXMLBaseAttribute = 40,
        eXMLBaseAttributeForStyleAttr = 41,
        eDeprecatedOperationCount = 42,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_DocumentWarnings {
        eIgnoringWillChangeOverBudget = 0,
        ePreventDefaultFromPassiveListener = 1,
        eSVGReferenceLoop = 2,
        eSVGReferenceChainLengthExceeded = 3,
        eDocumentWarningCount = 4,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_ElementCallbackType {
        eCreated = 0,
        eAttached = 1,
        eDetached = 2,
        eAttributeChanged = 3,
    }
    pub const nsIDocument_eScopedStyle_Unknown:
              root::nsIDocument__bindgen_ty_1 =
        nsIDocument__bindgen_ty_1::eScopedStyle_Unknown;
    pub const nsIDocument_eScopedStyle_Disabled:
              root::nsIDocument__bindgen_ty_1 =
        nsIDocument__bindgen_ty_1::eScopedStyle_Disabled;
    pub const nsIDocument_eScopedStyle_Enabled:
              root::nsIDocument__bindgen_ty_1 =
        nsIDocument__bindgen_ty_1::eScopedStyle_Enabled;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument__bindgen_ty_1 {
        eScopedStyle_Unknown = 0,
        eScopedStyle_Disabled = 1,
        eScopedStyle_Enabled = 2,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_Type {
        eUnknown = 0,
        eHTML = 1,
        eXHTML = 2,
        eGenericXML = 3,
        eSVG = 4,
        eXUL = 5,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_Tri { eTriUnset = 0, eTriFalse = 1, eTriTrue = 2, }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDocument_FrameRequest {
        _unused: [u8; 0],
    }
    pub const nsIDocument_kSegmentSize: usize = 128;
    #[test]
    fn bindgen_test_layout_nsIDocument() {
        assert_eq!(::std::mem::size_of::<nsIDocument>() , 904usize , concat !
                   ( "Size of: " , stringify ! ( nsIDocument ) ));
        assert_eq! (::std::mem::align_of::<nsIDocument>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsIDocument ) ));
    }
    impl nsIDocument {
        #[inline]
        pub fn mBidiEnabled(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 1u64 as u64;
            let val = (unit_field_val & mask) >> 0usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mBidiEnabled(&mut self, val: bool) {
            let mask = 1u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 0usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mMathMLEnabled(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 2u64 as u64;
            let val = (unit_field_val & mask) >> 1usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mMathMLEnabled(&mut self, val: bool) {
            let mask = 2u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 1usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsInitialDocumentInWindow(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 4u64 as u64;
            let val = (unit_field_val & mask) >> 2usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsInitialDocumentInWindow(&mut self, val: bool) {
            let mask = 4u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 2usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIgnoreDocGroupMismatches(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 8u64 as u64;
            let val = (unit_field_val & mask) >> 3usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIgnoreDocGroupMismatches(&mut self, val: bool) {
            let mask = 8u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 3usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mLoadedAsData(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 16u64 as u64;
            let val = (unit_field_val & mask) >> 4usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mLoadedAsData(&mut self, val: bool) {
            let mask = 16u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 4usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mLoadedAsInteractiveData(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 32u64 as u64;
            let val = (unit_field_val & mask) >> 5usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mLoadedAsInteractiveData(&mut self, val: bool) {
            let mask = 32u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 5usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mMayStartLayout(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 64u64 as u64;
            let val = (unit_field_val & mask) >> 6usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mMayStartLayout(&mut self, val: bool) {
            let mask = 64u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 6usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHaveFiredTitleChange(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 128u64 as u64;
            let val = (unit_field_val & mask) >> 7usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHaveFiredTitleChange(&mut self, val: bool) {
            let mask = 128u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 7usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsShowing(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 256u64 as u64;
            let val = (unit_field_val & mask) >> 8usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsShowing(&mut self, val: bool) {
            let mask = 256u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 8usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mVisible(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 512u64 as u64;
            let val = (unit_field_val & mask) >> 9usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mVisible(&mut self, val: bool) {
            let mask = 512u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 9usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasReferrerPolicyCSP(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 1024u64 as u64;
            let val = (unit_field_val & mask) >> 10usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasReferrerPolicyCSP(&mut self, val: bool) {
            let mask = 1024u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 10usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mRemovedFromDocShell(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 2048u64 as u64;
            let val = (unit_field_val & mask) >> 11usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mRemovedFromDocShell(&mut self, val: bool) {
            let mask = 2048u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 11usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mAllowDNSPrefetch(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 4096u64 as u64;
            let val = (unit_field_val & mask) >> 12usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mAllowDNSPrefetch(&mut self, val: bool) {
            let mask = 4096u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 12usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsStaticDocument(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 8192u64 as u64;
            let val = (unit_field_val & mask) >> 13usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsStaticDocument(&mut self, val: bool) {
            let mask = 8192u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 13usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mCreatingStaticClone(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 16384u64 as u64;
            let val = (unit_field_val & mask) >> 14usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mCreatingStaticClone(&mut self, val: bool) {
            let mask = 16384u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 14usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mInUnlinkOrDeletion(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 32768u64 as u64;
            let val = (unit_field_val & mask) >> 15usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mInUnlinkOrDeletion(&mut self, val: bool) {
            let mask = 32768u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 15usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasHadScriptHandlingObject(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 65536u64 as u64;
            let val = (unit_field_val & mask) >> 16usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasHadScriptHandlingObject(&mut self, val: bool) {
            let mask = 65536u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 16usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsBeingUsedAsImage(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 131072u64 as u64;
            let val = (unit_field_val & mask) >> 17usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsBeingUsedAsImage(&mut self, val: bool) {
            let mask = 131072u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 17usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsSyntheticDocument(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 262144u64 as u64;
            let val = (unit_field_val & mask) >> 18usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsSyntheticDocument(&mut self, val: bool) {
            let mask = 262144u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 18usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasLinksToUpdate(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 524288u64 as u64;
            let val = (unit_field_val & mask) >> 19usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasLinksToUpdate(&mut self, val: bool) {
            let mask = 524288u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 19usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasLinksToUpdateRunnable(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 1048576u64 as u64;
            let val = (unit_field_val & mask) >> 20usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasLinksToUpdateRunnable(&mut self, val: bool) {
            let mask = 1048576u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 20usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mMayHaveDOMMutationObservers(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 2097152u64 as u64;
            let val = (unit_field_val & mask) >> 21usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mMayHaveDOMMutationObservers(&mut self, val: bool) {
            let mask = 2097152u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 21usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mMayHaveAnimationObservers(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 4194304u64 as u64;
            let val = (unit_field_val & mask) >> 22usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mMayHaveAnimationObservers(&mut self, val: bool) {
            let mask = 4194304u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 22usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasMixedActiveContentLoaded(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 8388608u64 as u64;
            let val = (unit_field_val & mask) >> 23usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasMixedActiveContentLoaded(&mut self, val: bool) {
            let mask = 8388608u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 23usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasMixedActiveContentBlocked(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 16777216u64 as u64;
            let val = (unit_field_val & mask) >> 24usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasMixedActiveContentBlocked(&mut self, val: bool) {
            let mask = 16777216u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 24usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasMixedDisplayContentLoaded(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 33554432u64 as u64;
            let val = (unit_field_val & mask) >> 25usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasMixedDisplayContentLoaded(&mut self, val: bool) {
            let mask = 33554432u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 25usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasMixedDisplayContentBlocked(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 67108864u64 as u64;
            let val = (unit_field_val & mask) >> 26usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasMixedDisplayContentBlocked(&mut self, val: bool) {
            let mask = 67108864u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 26usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasMixedContentObjectSubrequest(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 134217728u64 as u64;
            let val = (unit_field_val & mask) >> 27usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasMixedContentObjectSubrequest(&mut self, val: bool) {
            let mask = 134217728u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 27usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasCSP(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 268435456u64 as u64;
            let val = (unit_field_val & mask) >> 28usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasCSP(&mut self, val: bool) {
            let mask = 268435456u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 28usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasUnsafeEvalCSP(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 536870912u64 as u64;
            let val = (unit_field_val & mask) >> 29usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasUnsafeEvalCSP(&mut self, val: bool) {
            let mask = 536870912u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 29usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasUnsafeInlineCSP(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 1073741824u64 as u64;
            let val = (unit_field_val & mask) >> 30usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasUnsafeInlineCSP(&mut self, val: bool) {
            let mask = 1073741824u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 30usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasTrackingContentBlocked(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 2147483648u64 as u64;
            let val = (unit_field_val & mask) >> 31usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasTrackingContentBlocked(&mut self, val: bool) {
            let mask = 2147483648u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 31usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasTrackingContentLoaded(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 4294967296u64 as u64;
            let val = (unit_field_val & mask) >> 32usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasTrackingContentLoaded(&mut self, val: bool) {
            let mask = 4294967296u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 32usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mBFCacheDisallowed(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 8589934592u64 as u64;
            let val = (unit_field_val & mask) >> 33usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mBFCacheDisallowed(&mut self, val: bool) {
            let mask = 8589934592u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 33usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasHadDefaultView(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 17179869184u64 as u64;
            let val = (unit_field_val & mask) >> 34usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasHadDefaultView(&mut self, val: bool) {
            let mask = 17179869184u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 34usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mStyleSheetChangeEventsEnabled(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 34359738368u64 as u64;
            let val = (unit_field_val & mask) >> 35usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mStyleSheetChangeEventsEnabled(&mut self, val: bool) {
            let mask = 34359738368u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 35usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsSrcdocDocument(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 68719476736u64 as u64;
            let val = (unit_field_val & mask) >> 36usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsSrcdocDocument(&mut self, val: bool) {
            let mask = 68719476736u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 36usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mDidDocumentOpen(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 137438953472u64 as u64;
            let val = (unit_field_val & mask) >> 37usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mDidDocumentOpen(&mut self, val: bool) {
            let mask = 137438953472u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 37usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasDisplayDocument(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 274877906944u64 as u64;
            let val = (unit_field_val & mask) >> 38usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasDisplayDocument(&mut self, val: bool) {
            let mask = 274877906944u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 38usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mFontFaceSetDirty(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 549755813888u64 as u64;
            let val = (unit_field_val & mask) >> 39usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mFontFaceSetDirty(&mut self, val: bool) {
            let mask = 549755813888u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 39usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mGetUserFontSetCalled(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 1099511627776u64 as u64;
            let val = (unit_field_val & mask) >> 40usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mGetUserFontSetCalled(&mut self, val: bool) {
            let mask = 1099511627776u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 40usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPostedFlushUserFontSet(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 2199023255552u64 as u64;
            let val = (unit_field_val & mask) >> 41usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mPostedFlushUserFontSet(&mut self, val: bool) {
            let mask = 2199023255552u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 41usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mDidFireDOMContentLoaded(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 4398046511104u64 as u64;
            let val = (unit_field_val & mask) >> 42usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mDidFireDOMContentLoaded(&mut self, val: bool) {
            let mask = 4398046511104u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 42usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasScrollLinkedEffect(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 8796093022208u64 as u64;
            let val = (unit_field_val & mask) >> 43usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHasScrollLinkedEffect(&mut self, val: bool) {
            let mask = 8796093022208u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 43usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mFrameRequestCallbacksScheduled(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 17592186044416u64 as u64;
            let val = (unit_field_val & mask) >> 44usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mFrameRequestCallbacksScheduled(&mut self, val: bool) {
            let mask = 17592186044416u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 44usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsTopLevelContentDocument(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 35184372088832u64 as u64;
            let val = (unit_field_val & mask) >> 45usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsTopLevelContentDocument(&mut self, val: bool) {
            let mask = 35184372088832u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 45usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsContentDocument(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 70368744177664u64 as u64;
            let val = (unit_field_val & mask) >> 46usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsContentDocument(&mut self, val: bool) {
            let mask = 70368744177664u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 46usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mMightHaveStaleServoData(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 140737488355328u64 as u64;
            let val = (unit_field_val & mask) >> 47usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mMightHaveStaleServoData(&mut self, val: bool) {
            let mask = 140737488355328u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 47usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mDidCallBeginLoad(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 281474976710656u64 as u64;
            let val = (unit_field_val & mask) >> 48usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mDidCallBeginLoad(&mut self, val: bool) {
            let mask = 281474976710656u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 48usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mBufferingCSPViolations(&self) -> bool {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 562949953421312u64 as u64;
            let val = (unit_field_val & mask) >> 49usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mBufferingCSPViolations(&mut self, val: bool) {
            let mask = 562949953421312u64 as u64;
            let val = val as u8 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 49usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsScopedStyleEnabled(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 3377699720527872u64 as u64;
            let val = (unit_field_val & mask) >> 50usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mIsScopedStyleEnabled(&mut self,
                                         val: ::std::os::raw::c_uint) {
            let mask = 3377699720527872u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 50usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn new_bitfield_1(mBidiEnabled: bool, mMathMLEnabled: bool,
                              mIsInitialDocumentInWindow: bool,
                              mIgnoreDocGroupMismatches: bool,
                              mLoadedAsData: bool,
                              mLoadedAsInteractiveData: bool,
                              mMayStartLayout: bool,
                              mHaveFiredTitleChange: bool, mIsShowing: bool,
                              mVisible: bool, mHasReferrerPolicyCSP: bool,
                              mRemovedFromDocShell: bool,
                              mAllowDNSPrefetch: bool,
                              mIsStaticDocument: bool,
                              mCreatingStaticClone: bool,
                              mInUnlinkOrDeletion: bool,
                              mHasHadScriptHandlingObject: bool,
                              mIsBeingUsedAsImage: bool,
                              mIsSyntheticDocument: bool,
                              mHasLinksToUpdate: bool,
                              mHasLinksToUpdateRunnable: bool,
                              mMayHaveDOMMutationObservers: bool,
                              mMayHaveAnimationObservers: bool,
                              mHasMixedActiveContentLoaded: bool,
                              mHasMixedActiveContentBlocked: bool,
                              mHasMixedDisplayContentLoaded: bool,
                              mHasMixedDisplayContentBlocked: bool,
                              mHasMixedContentObjectSubrequest: bool,
                              mHasCSP: bool, mHasUnsafeEvalCSP: bool,
                              mHasUnsafeInlineCSP: bool,
                              mHasTrackingContentBlocked: bool,
                              mHasTrackingContentLoaded: bool,
                              mBFCacheDisallowed: bool,
                              mHasHadDefaultView: bool,
                              mStyleSheetChangeEventsEnabled: bool,
                              mIsSrcdocDocument: bool, mDidDocumentOpen: bool,
                              mHasDisplayDocument: bool,
                              mFontFaceSetDirty: bool,
                              mGetUserFontSetCalled: bool,
                              mPostedFlushUserFontSet: bool,
                              mDidFireDOMContentLoaded: bool,
                              mHasScrollLinkedEffect: bool,
                              mFrameRequestCallbacksScheduled: bool,
                              mIsTopLevelContentDocument: bool,
                              mIsContentDocument: bool,
                              mMightHaveStaleServoData: bool,
                              mDidCallBeginLoad: bool,
                              mBufferingCSPViolations: bool,
                              mIsScopedStyleEnabled: ::std::os::raw::c_uint)
         -> u64 {
            ({
                 ({
                      ({
                           ({
                                ({
                                     ({
                                          ({
                                               ({
                                                    ({
                                                         ({
                                                              ({
                                                                   ({
                                                                        ({
                                                                             ({
                                                                                  ({
                                                                                       ({
                                                                                            ({
                                                                                                 ({
                                                                                                      ({
                                                                                                           ({
                                                                                                                ({
                                                                                                                     ({
                                                                                                                          ({
                                                                                                                               ({
                                                                                                                                    ({
                                                                                                                                         ({
                                                                                                                                              ({
                                                                                                                                                   ({
                                                                                                                                                        ({
                                                                                                                                                             ({
                                                                                                                                                                  ({
                                                                                                                                                                       ({
                                                                                                                                                                            ({
                                                                                                                                                                                 ({
                                                                                                                                                                                      ({
                                                                                                                                                                                           ({
                                                                                                                                                                                                ({
                                                                                                                                                                                                     ({
                                                                                                                                                                                                          ({
                                                                                                                                                                                                               ({
                                                                                                                                                                                                                    ({
                                                                                                                                                                                                                         ({
                                                                                                                                                                                                                              ({
                                                                                                                                                                                                                                   ({
                                                                                                                                                                                                                                        ({
                                                                                                                                                                                                                                             ({
                                                                                                                                                                                                                                                  ({
                                                                                                                                                                                                                                                       ({
                                                                                                                                                                                                                                                            ({
                                                                                                                                                                                                                                                                 ({
                                                                                                                                                                                                                                                                      ({
                                                                                                                                                                                                                                                                           0
                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                           |
                                                                                                                                                                                                                                                                           ((mBidiEnabled
                                                                                                                                                                                                                                                                                 as
                                                                                                                                                                                                                                                                                 u8
                                                                                                                                                                                                                                                                                 as
                                                                                                                                                                                                                                                                                 u64)
                                                                                                                                                                                                                                                                                <<
                                                                                                                                                                                                                                                                                0usize)
                                                                                                                                                                                                                                                                               &
                                                                                                                                                                                                                                                                               (1u64
                                                                                                                                                                                                                                                                                    as
                                                                                                                                                                                                                                                                                    u64))
                                                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                                                      |
                                                                                                                                                                                                                                                                      ((mMathMLEnabled
                                                                                                                                                                                                                                                                            as
                                                                                                                                                                                                                                                                            u8
                                                                                                                                                                                                                                                                            as
                                                                                                                                                                                                                                                                            u64)
                                                                                                                                                                                                                                                                           <<
                                                                                                                                                                                                                                                                           1usize)
                                                                                                                                                                                                                                                                          &
                                                                                                                                                                                                                                                                          (2u64
                                                                                                                                                                                                                                                                               as
                                                                                                                                                                                                                                                                               u64))
                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                 |
                                                                                                                                                                                                                                                                 ((mIsInitialDocumentInWindow
                                                                                                                                                                                                                                                                       as
                                                                                                                                                                                                                                                                       u8
                                                                                                                                                                                                                                                                       as
                                                                                                                                                                                                                                                                       u64)
                                                                                                                                                                                                                                                                      <<
                                                                                                                                                                                                                                                                      2usize)
                                                                                                                                                                                                                                                                     &
                                                                                                                                                                                                                                                                     (4u64
                                                                                                                                                                                                                                                                          as
                                                                                                                                                                                                                                                                          u64))
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                            |
                                                                                                                                                                                                                                                            ((mIgnoreDocGroupMismatches
                                                                                                                                                                                                                                                                  as
                                                                                                                                                                                                                                                                  u8
                                                                                                                                                                                                                                                                  as
                                                                                                                                                                                                                                                                  u64)
                                                                                                                                                                                                                                                                 <<
                                                                                                                                                                                                                                                                 3usize)
                                                                                                                                                                                                                                                                &
                                                                                                                                                                                                                                                                (8u64
                                                                                                                                                                                                                                                                     as
                                                                                                                                                                                                                                                                     u64))
                                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                                                       |
                                                                                                                                                                                                                                                       ((mLoadedAsData
                                                                                                                                                                                                                                                             as
                                                                                                                                                                                                                                                             u8
                                                                                                                                                                                                                                                             as
                                                                                                                                                                                                                                                             u64)
                                                                                                                                                                                                                                                            <<
                                                                                                                                                                                                                                                            4usize)
                                                                                                                                                                                                                                                           &
                                                                                                                                                                                                                                                           (16u64
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                u64))
                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                                  |
                                                                                                                                                                                                                                                  ((mLoadedAsInteractiveData
                                                                                                                                                                                                                                                        as
                                                                                                                                                                                                                                                        u8
                                                                                                                                                                                                                                                        as
                                                                                                                                                                                                                                                        u64)
                                                                                                                                                                                                                                                       <<
                                                                                                                                                                                                                                                       5usize)
                                                                                                                                                                                                                                                      &
                                                                                                                                                                                                                                                      (32u64
                                                                                                                                                                                                                                                           as
                                                                                                                                                                                                                                                           u64))
                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                             |
                                                                                                                                                                                                                                             ((mMayStartLayout
                                                                                                                                                                                                                                                   as
                                                                                                                                                                                                                                                   u8
                                                                                                                                                                                                                                                   as
                                                                                                                                                                                                                                                   u64)
                                                                                                                                                                                                                                                  <<
                                                                                                                                                                                                                                                  6usize)
                                                                                                                                                                                                                                                 &
                                                                                                                                                                                                                                                 (64u64
                                                                                                                                                                                                                                                      as
                                                                                                                                                                                                                                                      u64))
                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                        |
                                                                                                                                                                                                                                        ((mHaveFiredTitleChange
                                                                                                                                                                                                                                              as
                                                                                                                                                                                                                                              u8
                                                                                                                                                                                                                                              as
                                                                                                                                                                                                                                              u64)
                                                                                                                                                                                                                                             <<
                                                                                                                                                                                                                                             7usize)
                                                                                                                                                                                                                                            &
                                                                                                                                                                                                                                            (128u64
                                                                                                                                                                                                                                                 as
                                                                                                                                                                                                                                                 u64))
                                                                                                                                                                                                                               }
                                                                                                                                                                                                                                   |
                                                                                                                                                                                                                                   ((mIsShowing
                                                                                                                                                                                                                                         as
                                                                                                                                                                                                                                         u8
                                                                                                                                                                                                                                         as
                                                                                                                                                                                                                                         u64)
                                                                                                                                                                                                                                        <<
                                                                                                                                                                                                                                        8usize)
                                                                                                                                                                                                                                       &
                                                                                                                                                                                                                                       (256u64
                                                                                                                                                                                                                                            as
                                                                                                                                                                                                                                            u64))
                                                                                                                                                                                                                          }
                                                                                                                                                                                                                              |
                                                                                                                                                                                                                              ((mVisible
                                                                                                                                                                                                                                    as
                                                                                                                                                                                                                                    u8
                                                                                                                                                                                                                                    as
                                                                                                                                                                                                                                    u64)
                                                                                                                                                                                                                                   <<
                                                                                                                                                                                                                                   9usize)
                                                                                                                                                                                                                                  &
                                                                                                                                                                                                                                  (512u64
                                                                                                                                                                                                                                       as
                                                                                                                                                                                                                                       u64))
                                                                                                                                                                                                                     }
                                                                                                                                                                                                                         |
                                                                                                                                                                                                                         ((mHasReferrerPolicyCSP
                                                                                                                                                                                                                               as
                                                                                                                                                                                                                               u8
                                                                                                                                                                                                                               as
                                                                                                                                                                                                                               u64)
                                                                                                                                                                                                                              <<
                                                                                                                                                                                                                              10usize)
                                                                                                                                                                                                                             &
                                                                                                                                                                                                                             (1024u64
                                                                                                                                                                                                                                  as
                                                                                                                                                                                                                                  u64))
                                                                                                                                                                                                                }
                                                                                                                                                                                                                    |
                                                                                                                                                                                                                    ((mRemovedFromDocShell
                                                                                                                                                                                                                          as
                                                                                                                                                                                                                          u8
                                                                                                                                                                                                                          as
                                                                                                                                                                                                                          u64)
                                                                                                                                                                                                                         <<
                                                                                                                                                                                                                         11usize)
                                                                                                                                                                                                                        &
                                                                                                                                                                                                                        (2048u64
                                                                                                                                                                                                                             as
                                                                                                                                                                                                                             u64))
                                                                                                                                                                                                           }
                                                                                                                                                                                                               |
                                                                                                                                                                                                               ((mAllowDNSPrefetch
                                                                                                                                                                                                                     as
                                                                                                                                                                                                                     u8
                                                                                                                                                                                                                     as
                                                                                                                                                                                                                     u64)
                                                                                                                                                                                                                    <<
                                                                                                                                                                                                                    12usize)
                                                                                                                                                                                                                   &
                                                                                                                                                                                                                   (4096u64
                                                                                                                                                                                                                        as
                                                                                                                                                                                                                        u64))
                                                                                                                                                                                                      }
                                                                                                                                                                                                          |
                                                                                                                                                                                                          ((mIsStaticDocument
                                                                                                                                                                                                                as
                                                                                                                                                                                                                u8
                                                                                                                                                                                                                as
                                                                                                                                                                                                                u64)
                                                                                                                                                                                                               <<
                                                                                                                                                                                                               13usize)
                                                                                                                                                                                                              &
                                                                                                                                                                                                              (8192u64
                                                                                                                                                                                                                   as
                                                                                                                                                                                                                   u64))
                                                                                                                                                                                                 }
                                                                                                                                                                                                     |
                                                                                                                                                                                                     ((mCreatingStaticClone
                                                                                                                                                                                                           as
                                                                                                                                                                                                           u8
                                                                                                                                                                                                           as
                                                                                                                                                                                                           u64)
                                                                                                                                                                                                          <<
                                                                                                                                                                                                          14usize)
                                                                                                                                                                                                         &
                                                                                                                                                                                                         (16384u64
                                                                                                                                                                                                              as
                                                                                                                                                                                                              u64))
                                                                                                                                                                                            }
                                                                                                                                                                                                |
                                                                                                                                                                                                ((mInUnlinkOrDeletion
                                                                                                                                                                                                      as
                                                                                                                                                                                                      u8
                                                                                                                                                                                                      as
                                                                                                                                                                                                      u64)
                                                                                                                                                                                                     <<
                                                                                                                                                                                                     15usize)
                                                                                                                                                                                                    &
                                                                                                                                                                                                    (32768u64
                                                                                                                                                                                                         as
                                                                                                                                                                                                         u64))
                                                                                                                                                                                       }
                                                                                                                                                                                           |
                                                                                                                                                                                           ((mHasHadScriptHandlingObject
                                                                                                                                                                                                 as
                                                                                                                                                                                                 u8
                                                                                                                                                                                                 as
                                                                                                                                                                                                 u64)
                                                                                                                                                                                                <<
                                                                                                                                                                                                16usize)
                                                                                                                                                                                               &
                                                                                                                                                                                               (65536u64
                                                                                                                                                                                                    as
                                                                                                                                                                                                    u64))
                                                                                                                                                                                  }
                                                                                                                                                                                      |
                                                                                                                                                                                      ((mIsBeingUsedAsImage
                                                                                                                                                                                            as
                                                                                                                                                                                            u8
                                                                                                                                                                                            as
                                                                                                                                                                                            u64)
                                                                                                                                                                                           <<
                                                                                                                                                                                           17usize)
                                                                                                                                                                                          &
                                                                                                                                                                                          (131072u64
                                                                                                                                                                                               as
                                                                                                                                                                                               u64))
                                                                                                                                                                             }
                                                                                                                                                                                 |
                                                                                                                                                                                 ((mIsSyntheticDocument
                                                                                                                                                                                       as
                                                                                                                                                                                       u8
                                                                                                                                                                                       as
                                                                                                                                                                                       u64)
                                                                                                                                                                                      <<
                                                                                                                                                                                      18usize)
                                                                                                                                                                                     &
                                                                                                                                                                                     (262144u64
                                                                                                                                                                                          as
                                                                                                                                                                                          u64))
                                                                                                                                                                        }
                                                                                                                                                                            |
                                                                                                                                                                            ((mHasLinksToUpdate
                                                                                                                                                                                  as
                                                                                                                                                                                  u8
                                                                                                                                                                                  as
                                                                                                                                                                                  u64)
                                                                                                                                                                                 <<
                                                                                                                                                                                 19usize)
                                                                                                                                                                                &
                                                                                                                                                                                (524288u64
                                                                                                                                                                                     as
                                                                                                                                                                                     u64))
                                                                                                                                                                   }
                                                                                                                                                                       |
                                                                                                                                                                       ((mHasLinksToUpdateRunnable
                                                                                                                                                                             as
                                                                                                                                                                             u8
                                                                                                                                                                             as
                                                                                                                                                                             u64)
                                                                                                                                                                            <<
                                                                                                                                                                            20usize)
                                                                                                                                                                           &
                                                                                                                                                                           (1048576u64
                                                                                                                                                                                as
                                                                                                                                                                                u64))
                                                                                                                                                              }
                                                                                                                                                                  |
                                                                                                                                                                  ((mMayHaveDOMMutationObservers
                                                                                                                                                                        as
                                                                                                                                                                        u8
                                                                                                                                                                        as
                                                                                                                                                                        u64)
                                                                                                                                                                       <<
                                                                                                                                                                       21usize)
                                                                                                                                                                      &
                                                                                                                                                                      (2097152u64
                                                                                                                                                                           as
                                                                                                                                                                           u64))
                                                                                                                                                         }
                                                                                                                                                             |
                                                                                                                                                             ((mMayHaveAnimationObservers
                                                                                                                                                                   as
                                                                                                                                                                   u8
                                                                                                                                                                   as
                                                                                                                                                                   u64)
                                                                                                                                                                  <<
                                                                                                                                                                  22usize)
                                                                                                                                                                 &
                                                                                                                                                                 (4194304u64
                                                                                                                                                                      as
                                                                                                                                                                      u64))
                                                                                                                                                    }
                                                                                                                                                        |
                                                                                                                                                        ((mHasMixedActiveContentLoaded
                                                                                                                                                              as
                                                                                                                                                              u8
                                                                                                                                                              as
                                                                                                                                                              u64)
                                                                                                                                                             <<
                                                                                                                                                             23usize)
                                                                                                                                                            &
                                                                                                                                                            (8388608u64
                                                                                                                                                                 as
                                                                                                                                                                 u64))
                                                                                                                                               }
                                                                                                                                                   |
                                                                                                                                                   ((mHasMixedActiveContentBlocked
                                                                                                                                                         as
                                                                                                                                                         u8
                                                                                                                                                         as
                                                                                                                                                         u64)
                                                                                                                                                        <<
                                                                                                                                                        24usize)
                                                                                                                                                       &
                                                                                                                                                       (16777216u64
                                                                                                                                                            as
                                                                                                                                                            u64))
                                                                                                                                          }
                                                                                                                                              |
                                                                                                                                              ((mHasMixedDisplayContentLoaded
                                                                                                                                                    as
                                                                                                                                                    u8
                                                                                                                                                    as
                                                                                                                                                    u64)
                                                                                                                                                   <<
                                                                                                                                                   25usize)
                                                                                                                                                  &
                                                                                                                                                  (33554432u64
                                                                                                                                                       as
                                                                                                                                                       u64))
                                                                                                                                     }
                                                                                                                                         |
                                                                                                                                         ((mHasMixedDisplayContentBlocked
                                                                                                                                               as
                                                                                                                                               u8
                                                                                                                                               as
                                                                                                                                               u64)
                                                                                                                                              <<
                                                                                                                                              26usize)
                                                                                                                                             &
                                                                                                                                             (67108864u64
                                                                                                                                                  as
                                                                                                                                                  u64))
                                                                                                                                }
                                                                                                                                    |
                                                                                                                                    ((mHasMixedContentObjectSubrequest
                                                                                                                                          as
                                                                                                                                          u8
                                                                                                                                          as
                                                                                                                                          u64)
                                                                                                                                         <<
                                                                                                                                         27usize)
                                                                                                                                        &
                                                                                                                                        (134217728u64
                                                                                                                                             as
                                                                                                                                             u64))
                                                                                                                           }
                                                                                                                               |
                                                                                                                               ((mHasCSP
                                                                                                                                     as
                                                                                                                                     u8
                                                                                                                                     as
                                                                                                                                     u64)
                                                                                                                                    <<
                                                                                                                                    28usize)
                                                                                                                                   &
                                                                                                                                   (268435456u64
                                                                                                                                        as
                                                                                                                                        u64))
                                                                                                                      }
                                                                                                                          |
                                                                                                                          ((mHasUnsafeEvalCSP
                                                                                                                                as
                                                                                                                                u8
                                                                                                                                as
                                                                                                                                u64)
                                                                                                                               <<
                                                                                                                               29usize)
                                                                                                                              &
                                                                                                                              (536870912u64
                                                                                                                                   as
                                                                                                                                   u64))
                                                                                                                 }
                                                                                                                     |
                                                                                                                     ((mHasUnsafeInlineCSP
                                                                                                                           as
                                                                                                                           u8
                                                                                                                           as
                                                                                                                           u64)
                                                                                                                          <<
                                                                                                                          30usize)
                                                                                                                         &
                                                                                                                         (1073741824u64
                                                                                                                              as
                                                                                                                              u64))
                                                                                                            }
                                                                                                                |
                                                                                                                ((mHasTrackingContentBlocked
                                                                                                                      as
                                                                                                                      u8
                                                                                                                      as
                                                                                                                      u64)
                                                                                                                     <<
                                                                                                                     31usize)
                                                                                                                    &
                                                                                                                    (2147483648u64
                                                                                                                         as
                                                                                                                         u64))
                                                                                                       }
                                                                                                           |
                                                                                                           ((mHasTrackingContentLoaded
                                                                                                                 as
                                                                                                                 u8
                                                                                                                 as
                                                                                                                 u64)
                                                                                                                <<
                                                                                                                32usize)
                                                                                                               &
                                                                                                               (4294967296u64
                                                                                                                    as
                                                                                                                    u64))
                                                                                                  }
                                                                                                      |
                                                                                                      ((mBFCacheDisallowed
                                                                                                            as
                                                                                                            u8
                                                                                                            as
                                                                                                            u64)
                                                                                                           <<
                                                                                                           33usize)
                                                                                                          &
                                                                                                          (8589934592u64
                                                                                                               as
                                                                                                               u64))
                                                                                             }
                                                                                                 |
                                                                                                 ((mHasHadDefaultView
                                                                                                       as
                                                                                                       u8
                                                                                                       as
                                                                                                       u64)
                                                                                                      <<
                                                                                                      34usize)
                                                                                                     &
                                                                                                     (17179869184u64
                                                                                                          as
                                                                                                          u64))
                                                                                        }
                                                                                            |
                                                                                            ((mStyleSheetChangeEventsEnabled
                                                                                                  as
                                                                                                  u8
                                                                                                  as
                                                                                                  u64)
                                                                                                 <<
                                                                                                 35usize)
                                                                                                &
                                                                                                (34359738368u64
                                                                                                     as
                                                                                                     u64))
                                                                                   }
                                                                                       |
                                                                                       ((mIsSrcdocDocument
                                                                                             as
                                                                                             u8
                                                                                             as
                                                                                             u64)
                                                                                            <<
                                                                                            36usize)
                                                                                           &
                                                                                           (68719476736u64
                                                                                                as
                                                                                                u64))
                                                                              }
                                                                                  |
                                                                                  ((mDidDocumentOpen
                                                                                        as
                                                                                        u8
                                                                                        as
                                                                                        u64)
                                                                                       <<
                                                                                       37usize)
                                                                                      &
                                                                                      (137438953472u64
                                                                                           as
                                                                                           u64))
                                                                         } |
                                                                             ((mHasDisplayDocument
                                                                                   as
                                                                                   u8
                                                                                   as
                                                                                   u64)
                                                                                  <<
                                                                                  38usize)
                                                                                 &
                                                                                 (274877906944u64
                                                                                      as
                                                                                      u64))
                                                                    } |
                                                                        ((mFontFaceSetDirty
                                                                              as
                                                                              u8
                                                                              as
                                                                              u64)
                                                                             <<
                                                                             39usize)
                                                                            &
                                                                            (549755813888u64
                                                                                 as
                                                                                 u64))
                                                               } |
                                                                   ((mGetUserFontSetCalled
                                                                         as u8
                                                                         as
                                                                         u64)
                                                                        <<
                                                                        40usize)
                                                                       &
                                                                       (1099511627776u64
                                                                            as
                                                                            u64))
                                                          } |
                                                              ((mPostedFlushUserFontSet
                                                                    as u8 as
                                                                    u64) <<
                                                                   41usize) &
                                                                  (2199023255552u64
                                                                       as
                                                                       u64))
                                                     } |
                                                         ((mDidFireDOMContentLoaded
                                                               as u8 as u64)
                                                              << 42usize) &
                                                             (4398046511104u64
                                                                  as u64))
                                                } |
                                                    ((mHasScrollLinkedEffect
                                                          as u8 as u64) <<
                                                         43usize) &
                                                        (8796093022208u64 as
                                                             u64))
                                           } |
                                               ((mFrameRequestCallbacksScheduled
                                                     as u8 as u64) << 44usize)
                                                   &
                                                   (17592186044416u64 as u64))
                                      } |
                                          ((mIsTopLevelContentDocument as u8
                                                as u64) << 45usize) &
                                              (35184372088832u64 as u64))
                                 } |
                                     ((mIsContentDocument as u8 as u64) <<
                                          46usize) &
                                         (70368744177664u64 as u64))
                            } |
                                ((mMightHaveStaleServoData as u8 as u64) <<
                                     47usize) & (140737488355328u64 as u64))
                       } |
                           ((mDidCallBeginLoad as u8 as u64) << 48usize) &
                               (281474976710656u64 as u64))
                  } |
                      ((mBufferingCSPViolations as u8 as u64) << 49usize) &
                          (562949953421312u64 as u64))
             } |
                 ((mIsScopedStyleEnabled as u32 as u64) << 50usize) &
                     (3377699720527872u64 as u64))
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsCSSRuleProcessor {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsBindingManager {
        pub _base: root::nsStubMutationObserver,
        pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
        pub _mOwningThread: root::nsAutoOwningThread,
        pub mBoundContentSet: u64,
        pub mWrapperTable: root::nsAutoPtr<root::nsBindingManager_WrapperHashtable>,
        pub mDocumentTable: u64,
        pub mLoadingDocTable: u64,
        pub mAttachedStack: root::nsBindingList,
        pub mProcessingAttachedStack: bool,
        pub mDestroyed: bool,
        pub mAttachedStackSizeOnOutermost: u32,
        pub mProcessAttachedQueueEvent: u64,
        pub mDocument: *mut root::nsIDocument,
    }
    pub type nsBindingManager_HasThreadSafeRefCnt = root::mozilla::FalseType;
    #[repr(u32)]
    /// Notify the binding manager that an element
    /// has been removed from its document,
    /// so that it can update any bindings or
    /// nsIAnonymousContentCreator-created anonymous
    /// content that may depend on the document.
    /// @param aContent the element that's being moved
    /// @param aOldDocument the old document in which the
    /// content resided.
    /// @param aDestructorHandling whether or not to run the possible XBL
    /// destructor.
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsBindingManager_DestructorHandling {
        eRunDtor = 0,
        eDoNotRunDtor = 1,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsBindingManager_cycleCollection {
        pub _base: root::nsXPCOMCycleCollectionParticipant,
    }
    #[test]
    fn bindgen_test_layout_nsBindingManager_cycleCollection() {
        assert_eq!(::std::mem::size_of::<nsBindingManager_cycleCollection>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsBindingManager_cycleCollection ) ));
        assert_eq! (::std::mem::align_of::<nsBindingManager_cycleCollection>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsBindingManager_cycleCollection ) ));
    }
    impl Clone for nsBindingManager_cycleCollection {
        fn clone(&self) -> Self { *self }
    }
    pub type nsBindingManager_BoundContentBindingCallback =
        root::std::function;
    pub type nsBindingManager_WrapperHashtable = u8;
    extern "C" {
        #[link_name = "_ZN16nsBindingManager21_cycleCollectorGlobalE"]
        pub static mut nsBindingManager__cycleCollectorGlobal:
                   root::nsBindingManager_cycleCollection;
    }
    #[test]
    fn bindgen_test_layout_nsBindingManager() {
        assert_eq!(::std::mem::size_of::<nsBindingManager>() , 88usize ,
                   concat ! ( "Size of: " , stringify ! ( nsBindingManager )
                   ));
        assert_eq! (::std::mem::align_of::<nsBindingManager>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsBindingManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsBindingManager ) ) . mRefCnt as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsBindingManager )
                    , "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsBindingManager ) ) . _mOwningThread
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsBindingManager )
                    , "::" , stringify ! ( _mOwningThread ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsBindingManager ) ) .
                    mBoundContentSet as * const _ as usize } , 24usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsBindingManager )
                    , "::" , stringify ! ( mBoundContentSet ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsBindingManager ) ) . mWrapperTable
                    as * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsBindingManager )
                    , "::" , stringify ! ( mWrapperTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsBindingManager ) ) . mDocumentTable
                    as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsBindingManager )
                    , "::" , stringify ! ( mDocumentTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsBindingManager ) ) .
                    mLoadingDocTable as * const _ as usize } , 48usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsBindingManager )
                    , "::" , stringify ! ( mLoadingDocTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsBindingManager ) ) . mAttachedStack
                    as * const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsBindingManager )
                    , "::" , stringify ! ( mAttachedStack ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsBindingManager ) ) .
                    mProcessingAttachedStack as * const _ as usize } , 64usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsBindingManager )
                    , "::" , stringify ! ( mProcessingAttachedStack ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsBindingManager ) ) . mDestroyed as
                    * const _ as usize } , 65usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsBindingManager )
                    , "::" , stringify ! ( mDestroyed ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsBindingManager ) ) .
                    mAttachedStackSizeOnOutermost as * const _ as usize } ,
                    68usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsBindingManager )
                    , "::" , stringify ! ( mAttachedStackSizeOnOutermost ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsBindingManager ) ) .
                    mProcessAttachedQueueEvent as * const _ as usize } ,
                    72usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsBindingManager )
                    , "::" , stringify ! ( mProcessAttachedQueueEvent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsBindingManager ) ) . mDocument as *
                    const _ as usize } , 80usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsBindingManager )
                    , "::" , stringify ! ( mDocument ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSCounterStyleRule {
        pub _base: root::mozilla::css::Rule,
        pub _base_1: root::nsIDOMCSSCounterStyleRule,
        pub mName: root::nsCOMPtr<root::nsIAtom>,
        pub mValues: [root::nsCSSValue; 10usize],
        pub mGeneration: u32,
    }
    pub type nsCSSCounterStyleRule_Getter =
        ::std::option::Option<unsafe extern "C" fn() -> root::nsresult>;
    extern "C" {
        #[link_name = "_ZN21nsCSSCounterStyleRule8kGettersE"]
        pub static mut nsCSSCounterStyleRule_kGetters:
                   [root::nsCSSCounterStyleRule_Getter; 0usize];
    }
    #[test]
    fn bindgen_test_layout_nsCSSCounterStyleRule() {
        assert_eq!(::std::mem::size_of::<nsCSSCounterStyleRule>() , 256usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSCounterStyleRule ) ));
        assert_eq! (::std::mem::align_of::<nsCSSCounterStyleRule>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSCounterStyleRule )
                    ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsFontFaceRuleContainer {
        pub mRule: root::RefPtr<root::nsCSSFontFaceRule>,
        pub mSheetType: root::mozilla::SheetType,
    }
    #[test]
    fn bindgen_test_layout_nsFontFaceRuleContainer() {
        assert_eq!(::std::mem::size_of::<nsFontFaceRuleContainer>() , 16usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsFontFaceRuleContainer ) ));
        assert_eq! (::std::mem::align_of::<nsFontFaceRuleContainer>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsFontFaceRuleContainer )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFontFaceRuleContainer ) ) . mRule
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsFontFaceRuleContainer ) , "::" , stringify ! ( mRule )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFontFaceRuleContainer ) ) .
                    mSheetType as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsFontFaceRuleContainer ) , "::" , stringify ! (
                    mSheetType ) ));
    }
    /// A node of content in a document's content model. This interface
    /// is supported by all content objects.
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIContent {
        pub _base: root::nsINode,
    }
    pub type nsIContent_IMEState = root::mozilla::widget::IMEState;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIContent_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsIContent_eAllChildren: root::nsIContent__bindgen_ty_1 =
        nsIContent__bindgen_ty_1::eAllChildren;
    pub const nsIContent_eAllButXBL: root::nsIContent__bindgen_ty_1 =
        nsIContent__bindgen_ty_1::eAllButXBL;
    pub const nsIContent_eSkipPlaceholderContent:
              root::nsIContent__bindgen_ty_1 =
        nsIContent__bindgen_ty_1::eSkipPlaceholderContent;
    pub const nsIContent_eSkipDocumentLevelNativeAnonymousContent:
              root::nsIContent__bindgen_ty_1 =
        nsIContent__bindgen_ty_1::eSkipDocumentLevelNativeAnonymousContent;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIContent__bindgen_ty_1 {
        eAllChildren = 0,
        eAllButXBL = 1,
        eSkipPlaceholderContent = 2,
        eSkipDocumentLevelNativeAnonymousContent = 4,
    }
    pub const nsIContent_ATTR_MISSING: root::nsIContent__bindgen_ty_2 =
        nsIContent__bindgen_ty_2::ATTR_MISSING;
    pub const nsIContent_ATTR_VALUE_NO_MATCH: root::nsIContent__bindgen_ty_2 =
        nsIContent__bindgen_ty_2::ATTR_VALUE_NO_MATCH;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIContent__bindgen_ty_2 {
        ATTR_MISSING = -1,
        ATTR_VALUE_NO_MATCH = -2,
    }
    /// Check whether this content node's given attribute has one of a given
    /// list of values. If there is a match, we return the index in the list
    /// of the first matching value. If there was no attribute at all, then
    /// we return ATTR_MISSING. If there was an attribute but it didn't
    /// match, we return ATTR_VALUE_NO_MATCH. A non-negative result always
    /// indicates a match.
    ///
    /// @param aNameSpaceID The namespace ID of the attribute.  Must not
    /// be kNameSpaceID_Unknown.
    /// @param aName The name atom of the attribute.  Must not be null.
    /// @param aValues a nullptr-terminated array of pointers to atom values to test
    /// against.
    /// @param aCaseSensitive Whether to do a case-sensitive compare on the values.
    /// @return ATTR_MISSING, ATTR_VALUE_NO_MATCH or the non-negative index
    /// indicating the first value of aValues that matched
    pub type nsIContent_AttrValuesArray = *const *const root::nsIAtom;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIContent_FlattenedParentType {
        eNotForStyle = 0,
        eForStyle = 1,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIContent_ETabFocusType {
        eTabFocus_textControlsMask = 1,
        eTabFocus_formElementsMask = 2,
        eTabFocus_linksMask = 4,
        eTabFocus_any = 7,
    }
    extern "C" {
        #[link_name = "_ZN10nsIContent14sTabFocusModelE"]
        pub static mut nsIContent_sTabFocusModel: i32;
    }
    extern "C" {
        #[link_name = "_ZN10nsIContent26sTabFocusModelAppliesToXULE"]
        pub static mut nsIContent_sTabFocusModelAppliesToXUL: bool;
    }
    #[test]
    fn bindgen_test_layout_nsIContent() {
        assert_eq!(::std::mem::size_of::<nsIContent>() , 88usize , concat ! (
                   "Size of: " , stringify ! ( nsIContent ) ));
        assert_eq! (::std::mem::align_of::<nsIContent>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIContent ) ));
    }
    /// An nsStyleContext represents the computed style data for an element.
    /// The computed style data are stored in a set of structs (see
    /// nsStyleStruct.h) that are cached either on the style context or in
    /// the rule tree (see nsRuleNode.h for a description of this caching and
    /// how the cached structs are shared).
    ///
    /// Since the data in |nsIStyleRule|s and |nsRuleNode|s are immutable
    /// (with a few exceptions, like system color changes), the data in an
    /// nsStyleContext are also immutable (with the additional exception of
    /// GetUniqueStyleData).  When style data change,
    /// ElementRestyler::Restyle creates a new style context.
    ///
    /// Style contexts are reference counted.  References are generally held
    /// by:
    /// 1. the |nsIFrame|s that are using the style context and
    /// 2. any *child* style contexts (this might be the reverse of
    /// expectation, but it makes sense in this case)
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleContext {
        pub mPseudoTag: root::nsCOMPtr<root::nsIAtom>,
        pub mBits: u64,
        pub mFrameRefCnt: u32,
    }
    pub const nsStyleContext_kAllResolvedStructs:
              root::nsStyleContext__bindgen_ty_1 =
        nsStyleContext__bindgen_ty_1::kAllResolvedStructs;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleContext__bindgen_ty_1 {
        kAllResolvedStructs = 4294967295,
    }
    extern "C" {
        #[link_name = "_ZN14nsStyleContext16sDependencyTableE"]
        pub static mut nsStyleContext_sDependencyTable: [u32; 0usize];
    }
    #[test]
    fn bindgen_test_layout_nsStyleContext() {
        assert_eq!(::std::mem::size_of::<nsStyleContext>() , 24usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleContext ) ));
        assert_eq! (::std::mem::align_of::<nsStyleContext>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleContext ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContext ) ) . mPseudoTag as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleContext ) ,
                    "::" , stringify ! ( mPseudoTag ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContext ) ) . mBits as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleContext ) ,
                    "::" , stringify ! ( mBits ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContext ) ) . mFrameRefCnt as
                    * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleContext ) ,
                    "::" , stringify ! ( mFrameRefCnt ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPresContext {
        pub _base: root::nsIObserver,
        pub _base_1: u64,
        pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
        pub _mOwningThread: root::nsAutoOwningThread,
        pub mType: root::nsPresContext_nsPresContextType,
        pub mShell: *mut root::nsIPresShell,
        pub mDocument: root::nsCOMPtr<root::nsIDocument>,
        pub mDeviceContext: root::RefPtr<root::nsDeviceContext>,
        pub mEventManager: root::RefPtr<root::mozilla::EventStateManager>,
        pub mRefreshDriver: root::RefPtr<root::nsRefreshDriver>,
        pub mEffectCompositor: root::RefPtr<root::mozilla::EffectCompositor>,
        pub mTransitionManager: root::RefPtr<root::nsTransitionManager>,
        pub mAnimationManager: root::RefPtr<root::nsAnimationManager>,
        pub mRestyleManager: root::RefPtr<root::mozilla::RestyleManager>,
        pub mCounterStyleManager: root::RefPtr<root::mozilla::CounterStyleManager>,
        pub mMedium: *mut root::nsIAtom,
        pub mMediaEmulated: root::nsCOMPtr<root::nsIAtom>,
        pub mFontFeatureValuesLookup: root::RefPtr<root::gfxFontFeatureValueSet>,
        pub mLinkHandler: *mut root::nsILinkHandler,
        pub mLanguage: root::nsCOMPtr<root::nsIAtom>,
        pub mInflationDisabledForShrinkWrap: bool,
        pub mContainer: u64,
        pub mBaseMinFontSize: i32,
        pub mSystemFontScale: f32,
        pub mTextZoom: f32,
        pub mEffectiveTextZoom: f32,
        pub mFullZoom: f32,
        pub mOverrideDPPX: f32,
        pub mLastFontInflationScreenSize: root::gfxSize,
        pub mCurAppUnitsPerDevPixel: i32,
        pub mAutoQualityMinFontSizePixelsPref: i32,
        pub mTheme: root::nsCOMPtr<root::nsITheme>,
        pub mLangService: *mut root::nsLanguageAtomService,
        pub mPrintSettings: root::nsCOMPtr<root::nsIPrintSettings>,
        pub mPrefChangedTimer: root::nsCOMPtr<root::nsITimer>,
        pub mBidiEngine: root::mozilla::UniquePtr<root::nsBidi>,
        pub mTransactions: [u64; 10usize],
        pub mTextPerf: root::nsAutoPtr<root::gfxTextPerfMetrics>,
        pub mMissingFonts: root::nsAutoPtr<root::gfxMissingFontRecorder>,
        pub mVisibleArea: root::nsRect,
        pub mPageSize: root::nsSize,
        pub mPageScale: f32,
        pub mPPScale: f32,
        pub mDefaultColor: root::nscolor,
        pub mBackgroundColor: root::nscolor,
        pub mLinkColor: root::nscolor,
        pub mActiveLinkColor: root::nscolor,
        pub mVisitedLinkColor: root::nscolor,
        pub mFocusBackgroundColor: root::nscolor,
        pub mFocusTextColor: root::nscolor,
        pub mBodyTextColor: root::nscolor,
        pub mViewportScrollbarOverrideNode: *mut root::nsIContent,
        pub mViewportStyleScrollbar: root::nsPresContext_ScrollbarStyles,
        pub mFocusRingWidth: u8,
        pub mExistThrottledUpdates: bool,
        pub mImageAnimationMode: u16,
        pub mImageAnimationModePref: u16,
        pub mLangGroupFontPrefs: root::nsPresContext_LangGroupFontPrefs,
        pub mFontGroupCacheDirty: bool,
        pub mLanguagesUsed: [u64; 6usize],
        pub mBorderWidthTable: [root::nscoord; 3usize],
        pub mInterruptChecksToSkip: u32,
        pub mElementsRestyled: u64,
        pub mFramesConstructed: u64,
        pub mFramesReflowed: u64,
        pub mReflowStartTime: root::mozilla::TimeStamp,
        pub mFirstNonBlankPaintTime: root::mozilla::TimeStamp,
        pub mFirstClickTime: root::mozilla::TimeStamp,
        pub mFirstKeyTime: root::mozilla::TimeStamp,
        pub mFirstMouseMoveTime: root::mozilla::TimeStamp,
        pub mFirstScrollTime: root::mozilla::TimeStamp,
        pub mInteractionTimeEnabled: bool,
        pub mLastStyleUpdateForAllAnimations: root::mozilla::TimeStamp,
        pub mTelemetryScrollLastY: root::nscoord,
        pub mTelemetryScrollMaxY: root::nscoord,
        pub mTelemetryScrollTotalY: root::nscoord,
        pub _bitfield_1: [u8; 7usize],
        pub mLayoutPhaseCount: [u32; 3usize],
    }
    pub type nsPresContext_Encoding = root::mozilla::Encoding;
    pub type nsPresContext_NotNull<T> = root::mozilla::NotNull<T>;
    pub type nsPresContext_LangGroupFontPrefs =
        root::mozilla::LangGroupFontPrefs;
    pub type nsPresContext_ScrollbarStyles = root::mozilla::ScrollbarStyles;
    pub type nsPresContext_StaticPresData = root::mozilla::StaticPresData;
    pub type nsPresContext_HasThreadSafeRefCnt = root::mozilla::FalseType;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsPresContext_cycleCollection {
        pub _base: root::nsXPCOMCycleCollectionParticipant,
    }
    #[test]
    fn bindgen_test_layout_nsPresContext_cycleCollection() {
        assert_eq!(::std::mem::size_of::<nsPresContext_cycleCollection>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( nsPresContext_cycleCollection )
                   ));
        assert_eq! (::std::mem::align_of::<nsPresContext_cycleCollection>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsPresContext_cycleCollection ) ));
    }
    impl Clone for nsPresContext_cycleCollection {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsPresContext_nsPresContextType {
        eContext_Galley = 0,
        eContext_PrintPreview = 1,
        eContext_Print = 2,
        eContext_PageLayout = 3,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsPresContext_InteractionType {
        eClickInteraction = 0,
        eKeyInteraction = 1,
        eMouseMoveInteraction = 2,
        eScrollInteraction = 3,
    }
    /// A class that can be used to temporarily disable reflow interruption.
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPresContext_InterruptPreventer {
        pub mCtx: *mut root::nsPresContext,
        pub mInterruptsEnabled: bool,
        pub mHasPendingInterrupt: bool,
    }
    #[test]
    fn bindgen_test_layout_nsPresContext_InterruptPreventer() {
        assert_eq!(::std::mem::size_of::<nsPresContext_InterruptPreventer>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsPresContext_InterruptPreventer ) ));
        assert_eq! (::std::mem::align_of::<nsPresContext_InterruptPreventer>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsPresContext_InterruptPreventer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext_InterruptPreventer ) )
                    . mCtx as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresContext_InterruptPreventer ) , "::" , stringify ! (
                    mCtx ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext_InterruptPreventer ) )
                    . mInterruptsEnabled as * const _ as usize } , 8usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresContext_InterruptPreventer ) , "::" , stringify ! (
                    mInterruptsEnabled ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext_InterruptPreventer ) )
                    . mHasPendingInterrupt as * const _ as usize } , 9usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresContext_InterruptPreventer ) , "::" , stringify ! (
                    mHasPendingInterrupt ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPresContext_TransactionInvalidations {
        pub mTransactionId: u64,
        pub mInvalidations: root::nsTArray<root::nsRect>,
    }
    #[test]
    fn bindgen_test_layout_nsPresContext_TransactionInvalidations() {
        assert_eq!(::std::mem::size_of::<nsPresContext_TransactionInvalidations>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsPresContext_TransactionInvalidations ) ));
        assert_eq! (::std::mem::align_of::<nsPresContext_TransactionInvalidations>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsPresContext_TransactionInvalidations ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsPresContext_TransactionInvalidations )
                    ) . mTransactionId as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresContext_TransactionInvalidations ) , "::" ,
                    stringify ! ( mTransactionId ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsPresContext_TransactionInvalidations )
                    ) . mInvalidations as * const _ as usize } , 8usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresContext_TransactionInvalidations ) , "::" ,
                    stringify ! ( mInvalidations ) ));
    }
    extern "C" {
        #[link_name = "_ZN13nsPresContext21_cycleCollectorGlobalE"]
        pub static mut nsPresContext__cycleCollectorGlobal:
                   root::nsPresContext_cycleCollection;
    }
    #[test]
    fn bindgen_test_layout_nsPresContext() {
        assert_eq!(::std::mem::size_of::<nsPresContext>() , 1336usize , concat
                   ! ( "Size of: " , stringify ! ( nsPresContext ) ));
        assert_eq! (::std::mem::align_of::<nsPresContext>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsPresContext ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mRefCnt as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . _mOwningThread as
                    * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( _mOwningThread ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mType as * const
                    _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mShell as * const
                    _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mShell ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mDocument as *
                    const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mDocument ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mDeviceContext as
                    * const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mDeviceContext ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mEventManager as
                    * const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mEventManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mRefreshDriver as
                    * const _ as usize } , 72usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mRefreshDriver ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mEffectCompositor
                    as * const _ as usize } , 80usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mEffectCompositor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mTransitionManager as * const _ as usize } , 88usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mTransitionManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mAnimationManager
                    as * const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mAnimationManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mRestyleManager
                    as * const _ as usize } , 104usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mRestyleManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mCounterStyleManager as * const _ as usize } , 112usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mCounterStyleManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mMedium as *
                    const _ as usize } , 120usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mMedium ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mMediaEmulated as
                    * const _ as usize } , 128usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mMediaEmulated ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mFontFeatureValuesLookup as * const _ as usize } ,
                    136usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFontFeatureValuesLookup ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mLinkHandler as *
                    const _ as usize } , 144usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLinkHandler ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mLanguage as *
                    const _ as usize } , 152usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLanguage ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mInflationDisabledForShrinkWrap as * const _ as usize } ,
                    160usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mInflationDisabledForShrinkWrap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mContainer as *
                    const _ as usize } , 168usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mContainer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mBaseMinFontSize
                    as * const _ as usize } , 176usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mBaseMinFontSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mSystemFontScale
                    as * const _ as usize } , 180usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mSystemFontScale ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mTextZoom as *
                    const _ as usize } , 184usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mTextZoom ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mEffectiveTextZoom as * const _ as usize } , 188usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mEffectiveTextZoom ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mFullZoom as *
                    const _ as usize } , 192usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFullZoom ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mOverrideDPPX as
                    * const _ as usize } , 196usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mOverrideDPPX ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mLastFontInflationScreenSize as * const _ as usize } ,
                    200usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLastFontInflationScreenSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mCurAppUnitsPerDevPixel as * const _ as usize } , 216usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mCurAppUnitsPerDevPixel ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mAutoQualityMinFontSizePixelsPref as * const _ as usize }
                    , 220usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mAutoQualityMinFontSizePixelsPref )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mTheme as * const
                    _ as usize } , 224usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mTheme ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mLangService as *
                    const _ as usize } , 232usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLangService ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mPrintSettings as
                    * const _ as usize } , 240usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mPrintSettings ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mPrefChangedTimer
                    as * const _ as usize } , 248usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mPrefChangedTimer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mBidiEngine as *
                    const _ as usize } , 256usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mBidiEngine ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mTransactions as
                    * const _ as usize } , 264usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mTransactions ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mTextPerf as *
                    const _ as usize } , 344usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mTextPerf ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mMissingFonts as
                    * const _ as usize } , 352usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mMissingFonts ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mVisibleArea as *
                    const _ as usize } , 360usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mVisibleArea ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mPageSize as *
                    const _ as usize } , 376usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mPageSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mPageScale as *
                    const _ as usize } , 384usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mPageScale ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mPPScale as *
                    const _ as usize } , 388usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mPPScale ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mDefaultColor as
                    * const _ as usize } , 392usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mDefaultColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mBackgroundColor
                    as * const _ as usize } , 396usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mBackgroundColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mLinkColor as *
                    const _ as usize } , 400usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLinkColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mActiveLinkColor
                    as * const _ as usize } , 404usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mActiveLinkColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mVisitedLinkColor
                    as * const _ as usize } , 408usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mVisitedLinkColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mFocusBackgroundColor as * const _ as usize } , 412usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFocusBackgroundColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mFocusTextColor
                    as * const _ as usize } , 416usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFocusTextColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mBodyTextColor as
                    * const _ as usize } , 420usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mBodyTextColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mViewportScrollbarOverrideNode as * const _ as usize } ,
                    424usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mViewportScrollbarOverrideNode ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mViewportStyleScrollbar as * const _ as usize } , 432usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mViewportStyleScrollbar ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mFocusRingWidth
                    as * const _ as usize } , 496usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFocusRingWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mExistThrottledUpdates as * const _ as usize } , 497usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mExistThrottledUpdates ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mImageAnimationMode as * const _ as usize } , 498usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mImageAnimationMode ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mImageAnimationModePref as * const _ as usize } , 500usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mImageAnimationModePref ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mLangGroupFontPrefs as * const _ as usize } , 504usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLangGroupFontPrefs ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mFontGroupCacheDirty as * const _ as usize } , 1144usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFontGroupCacheDirty ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mLanguagesUsed as
                    * const _ as usize } , 1152usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLanguagesUsed ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mBorderWidthTable
                    as * const _ as usize } , 1200usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mBorderWidthTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mInterruptChecksToSkip as * const _ as usize } , 1212usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mInterruptChecksToSkip ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mElementsRestyled
                    as * const _ as usize } , 1216usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mElementsRestyled ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mFramesConstructed as * const _ as usize } , 1224usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFramesConstructed ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mFramesReflowed
                    as * const _ as usize } , 1232usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFramesReflowed ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mReflowStartTime
                    as * const _ as usize } , 1240usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mReflowStartTime ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mFirstNonBlankPaintTime as * const _ as usize } ,
                    1248usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFirstNonBlankPaintTime ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mFirstClickTime
                    as * const _ as usize } , 1256usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFirstClickTime ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mFirstKeyTime as
                    * const _ as usize } , 1264usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFirstKeyTime ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mFirstMouseMoveTime as * const _ as usize } , 1272usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFirstMouseMoveTime ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mFirstScrollTime
                    as * const _ as usize } , 1280usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFirstScrollTime ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mInteractionTimeEnabled as * const _ as usize } ,
                    1288usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mInteractionTimeEnabled ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mLastStyleUpdateForAllAnimations as * const _ as usize } ,
                    1296usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLastStyleUpdateForAllAnimations )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mTelemetryScrollLastY as * const _ as usize } , 1304usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mTelemetryScrollLastY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mTelemetryScrollMaxY as * const _ as usize } , 1308usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mTelemetryScrollMaxY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mTelemetryScrollTotalY as * const _ as usize } , 1312usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mTelemetryScrollTotalY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mLayoutPhaseCount
                    as * const _ as usize } , 1324usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLayoutPhaseCount ) ));
    }
    impl nsPresContext {
        #[inline]
        pub fn mHasPendingInterrupt(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 1u64 as u64;
            let val = (unit_field_val & mask) >> 0usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mHasPendingInterrupt(&mut self,
                                        val: ::std::os::raw::c_uint) {
            let mask = 1u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 0usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPendingInterruptFromTest(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 2u64 as u64;
            let val = (unit_field_val & mask) >> 1usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPendingInterruptFromTest(&mut self,
                                             val: ::std::os::raw::c_uint) {
            let mask = 2u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 1usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mInterruptsEnabled(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 4u64 as u64;
            let val = (unit_field_val & mask) >> 2usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mInterruptsEnabled(&mut self,
                                      val: ::std::os::raw::c_uint) {
            let mask = 4u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 2usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mUseDocumentFonts(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 8u64 as u64;
            let val = (unit_field_val & mask) >> 3usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mUseDocumentFonts(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 8u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 3usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mUseDocumentColors(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 16u64 as u64;
            let val = (unit_field_val & mask) >> 4usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mUseDocumentColors(&mut self,
                                      val: ::std::os::raw::c_uint) {
            let mask = 16u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 4usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mUnderlineLinks(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 32u64 as u64;
            let val = (unit_field_val & mask) >> 5usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mUnderlineLinks(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 32u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 5usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mSendAfterPaintToContent(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 64u64 as u64;
            let val = (unit_field_val & mask) >> 6usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mSendAfterPaintToContent(&mut self,
                                            val: ::std::os::raw::c_uint) {
            let mask = 64u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 6usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mUseFocusColors(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 128u64 as u64;
            let val = (unit_field_val & mask) >> 7usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mUseFocusColors(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 128u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 7usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mFocusRingOnAnything(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 256u64 as u64;
            let val = (unit_field_val & mask) >> 8usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mFocusRingOnAnything(&mut self,
                                        val: ::std::os::raw::c_uint) {
            let mask = 256u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 8usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mFocusRingStyle(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 512u64 as u64;
            let val = (unit_field_val & mask) >> 9usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mFocusRingStyle(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 512u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 9usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mDrawImageBackground(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 1024u64 as u64;
            let val = (unit_field_val & mask) >> 10usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mDrawImageBackground(&mut self,
                                        val: ::std::os::raw::c_uint) {
            let mask = 1024u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 10usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mDrawColorBackground(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 2048u64 as u64;
            let val = (unit_field_val & mask) >> 11usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mDrawColorBackground(&mut self,
                                        val: ::std::os::raw::c_uint) {
            let mask = 2048u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 11usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mNeverAnimate(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 4096u64 as u64;
            let val = (unit_field_val & mask) >> 12usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mNeverAnimate(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 4096u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 12usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsRenderingOnlySelection(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 8192u64 as u64;
            let val = (unit_field_val & mask) >> 13usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mIsRenderingOnlySelection(&mut self,
                                             val: ::std::os::raw::c_uint) {
            let mask = 8192u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 13usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPaginated(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 16384u64 as u64;
            let val = (unit_field_val & mask) >> 14usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPaginated(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 16384u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 14usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mCanPaginatedScroll(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 32768u64 as u64;
            let val = (unit_field_val & mask) >> 15usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mCanPaginatedScroll(&mut self,
                                       val: ::std::os::raw::c_uint) {
            let mask = 32768u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 15usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mDoScaledTwips(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 65536u64 as u64;
            let val = (unit_field_val & mask) >> 16usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mDoScaledTwips(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 65536u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 16usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsRootPaginatedDocument(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 131072u64 as u64;
            let val = (unit_field_val & mask) >> 17usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mIsRootPaginatedDocument(&mut self,
                                            val: ::std::os::raw::c_uint) {
            let mask = 131072u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 17usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPrefBidiDirection(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 262144u64 as u64;
            let val = (unit_field_val & mask) >> 18usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPrefBidiDirection(&mut self,
                                      val: ::std::os::raw::c_uint) {
            let mask = 262144u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 18usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPrefScrollbarSide(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 1572864u64 as u64;
            let val = (unit_field_val & mask) >> 19usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPrefScrollbarSide(&mut self,
                                      val: ::std::os::raw::c_uint) {
            let mask = 1572864u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 19usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPendingSysColorChanged(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 2097152u64 as u64;
            let val = (unit_field_val & mask) >> 21usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPendingSysColorChanged(&mut self,
                                           val: ::std::os::raw::c_uint) {
            let mask = 2097152u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 21usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPendingThemeChanged(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 4194304u64 as u64;
            let val = (unit_field_val & mask) >> 22usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPendingThemeChanged(&mut self,
                                        val: ::std::os::raw::c_uint) {
            let mask = 4194304u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 22usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPendingUIResolutionChanged(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 8388608u64 as u64;
            let val = (unit_field_val & mask) >> 23usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPendingUIResolutionChanged(&mut self,
                                               val: ::std::os::raw::c_uint) {
            let mask = 8388608u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 23usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPendingMediaFeatureValuesChanged(&self)
         -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 16777216u64 as u64;
            let val = (unit_field_val & mask) >> 24usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPendingMediaFeatureValuesChanged(&mut self,
                                                     val:
                                                         ::std::os::raw::c_uint) {
            let mask = 16777216u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 24usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPrefChangePendingNeedsReflow(&self)
         -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 33554432u64 as u64;
            let val = (unit_field_val & mask) >> 25usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPrefChangePendingNeedsReflow(&mut self,
                                                 val:
                                                     ::std::os::raw::c_uint) {
            let mask = 33554432u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 25usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsEmulatingMedia(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 67108864u64 as u64;
            let val = (unit_field_val & mask) >> 26usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mIsEmulatingMedia(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 67108864u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 26usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsGlyph(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 134217728u64 as u64;
            let val = (unit_field_val & mask) >> 27usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mIsGlyph(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 134217728u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 27usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mUsesRootEMUnits(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 268435456u64 as u64;
            let val = (unit_field_val & mask) >> 28usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mUsesRootEMUnits(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 268435456u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 28usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mUsesExChUnits(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 536870912u64 as u64;
            let val = (unit_field_val & mask) >> 29usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mUsesExChUnits(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 536870912u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 29usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPendingViewportChange(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 1073741824u64 as u64;
            let val = (unit_field_val & mask) >> 30usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPendingViewportChange(&mut self,
                                          val: ::std::os::raw::c_uint) {
            let mask = 1073741824u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 30usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mCounterStylesDirty(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 2147483648u64 as u64;
            let val = (unit_field_val & mask) >> 31usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mCounterStylesDirty(&mut self,
                                       val: ::std::os::raw::c_uint) {
            let mask = 2147483648u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 31usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPostedFlushCounterStyles(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 4294967296u64 as u64;
            let val = (unit_field_val & mask) >> 32usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPostedFlushCounterStyles(&mut self,
                                             val: ::std::os::raw::c_uint) {
            let mask = 4294967296u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 32usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mFontFeatureValuesDirty(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 8589934592u64 as u64;
            let val = (unit_field_val & mask) >> 33usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mFontFeatureValuesDirty(&mut self,
                                           val: ::std::os::raw::c_uint) {
            let mask = 8589934592u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 33usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPostedFlushFontFeatureValues(&self)
         -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 17179869184u64 as u64;
            let val = (unit_field_val & mask) >> 34usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPostedFlushFontFeatureValues(&mut self,
                                                 val:
                                                     ::std::os::raw::c_uint) {
            let mask = 17179869184u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 34usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mSuppressResizeReflow(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 34359738368u64 as u64;
            let val = (unit_field_val & mask) >> 35usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mSuppressResizeReflow(&mut self,
                                         val: ::std::os::raw::c_uint) {
            let mask = 34359738368u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 35usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsVisual(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 68719476736u64 as u64;
            let val = (unit_field_val & mask) >> 36usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mIsVisual(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 68719476736u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 36usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mFireAfterPaintEvents(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 137438953472u64 as u64;
            let val = (unit_field_val & mask) >> 37usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mFireAfterPaintEvents(&mut self,
                                         val: ::std::os::raw::c_uint) {
            let mask = 137438953472u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 37usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsChrome(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 274877906944u64 as u64;
            let val = (unit_field_val & mask) >> 38usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mIsChrome(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 274877906944u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 38usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mIsChromeOriginImage(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 549755813888u64 as u64;
            let val = (unit_field_val & mask) >> 39usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mIsChromeOriginImage(&mut self,
                                        val: ::std::os::raw::c_uint) {
            let mask = 549755813888u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 39usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPaintFlashing(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 1099511627776u64 as u64;
            let val = (unit_field_val & mask) >> 40usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPaintFlashing(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 1099511627776u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 40usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mPaintFlashingInitialized(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 2199023255552u64 as u64;
            let val = (unit_field_val & mask) >> 41usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mPaintFlashingInitialized(&mut self,
                                             val: ::std::os::raw::c_uint) {
            let mask = 2199023255552u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 41usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasWarnedAboutPositionedTableParts(&self)
         -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 4398046511104u64 as u64;
            let val = (unit_field_val & mask) >> 42usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mHasWarnedAboutPositionedTableParts(&mut self,
                                                       val:
                                                           ::std::os::raw::c_uint) {
            let mask = 4398046511104u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 42usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHasWarnedAboutTooLargeDashedOrDottedRadius(&self)
         -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 8796093022208u64 as u64;
            let val = (unit_field_val & mask) >> 43usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mHasWarnedAboutTooLargeDashedOrDottedRadius(&mut self,
                                                               val:
                                                                   ::std::os::raw::c_uint) {
            let mask = 8796093022208u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 43usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mQuirkSheetAdded(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 17592186044416u64 as u64;
            let val = (unit_field_val & mask) >> 44usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mQuirkSheetAdded(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 17592186044416u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 44usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mNeedsPrefUpdate(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 35184372088832u64 as u64;
            let val = (unit_field_val & mask) >> 45usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mNeedsPrefUpdate(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 35184372088832u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 45usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mHadNonBlankPaint(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 70368744177664u64 as u64;
            let val = (unit_field_val & mask) >> 46usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mHadNonBlankPaint(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 70368744177664u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 46usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mRestyleLoggingEnabled(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 140737488355328u64 as u64;
            let val = (unit_field_val & mask) >> 47usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mRestyleLoggingEnabled(&mut self,
                                          val: ::std::os::raw::c_uint) {
            let mask = 140737488355328u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 47usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn mInitialized(&self) -> ::std::os::raw::c_uint {
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            let mask = 281474976710656u64 as u64;
            let val = (unit_field_val & mask) >> 48usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mInitialized(&mut self, val: ::std::os::raw::c_uint) {
            let mask = 281474976710656u64 as u64;
            let val = val as u32 as u64;
            let mut unit_field_val: u64 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u64 as *mut u8,
                                                ::std::mem::size_of::<u64>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 48usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u64>());
            }
        }
        #[inline]
        pub fn new_bitfield_1(mHasPendingInterrupt: ::std::os::raw::c_uint,
                              mPendingInterruptFromTest:
                                  ::std::os::raw::c_uint,
                              mInterruptsEnabled: ::std::os::raw::c_uint,
                              mUseDocumentFonts: ::std::os::raw::c_uint,
                              mUseDocumentColors: ::std::os::raw::c_uint,
                              mUnderlineLinks: ::std::os::raw::c_uint,
                              mSendAfterPaintToContent:
                                  ::std::os::raw::c_uint,
                              mUseFocusColors: ::std::os::raw::c_uint,
                              mFocusRingOnAnything: ::std::os::raw::c_uint,
                              mFocusRingStyle: ::std::os::raw::c_uint,
                              mDrawImageBackground: ::std::os::raw::c_uint,
                              mDrawColorBackground: ::std::os::raw::c_uint,
                              mNeverAnimate: ::std::os::raw::c_uint,
                              mIsRenderingOnlySelection:
                                  ::std::os::raw::c_uint,
                              mPaginated: ::std::os::raw::c_uint,
                              mCanPaginatedScroll: ::std::os::raw::c_uint,
                              mDoScaledTwips: ::std::os::raw::c_uint,
                              mIsRootPaginatedDocument:
                                  ::std::os::raw::c_uint,
                              mPrefBidiDirection: ::std::os::raw::c_uint,
                              mPrefScrollbarSide: ::std::os::raw::c_uint,
                              mPendingSysColorChanged: ::std::os::raw::c_uint,
                              mPendingThemeChanged: ::std::os::raw::c_uint,
                              mPendingUIResolutionChanged:
                                  ::std::os::raw::c_uint,
                              mPendingMediaFeatureValuesChanged:
                                  ::std::os::raw::c_uint,
                              mPrefChangePendingNeedsReflow:
                                  ::std::os::raw::c_uint,
                              mIsEmulatingMedia: ::std::os::raw::c_uint,
                              mIsGlyph: ::std::os::raw::c_uint,
                              mUsesRootEMUnits: ::std::os::raw::c_uint,
                              mUsesExChUnits: ::std::os::raw::c_uint,
                              mPendingViewportChange: ::std::os::raw::c_uint,
                              mCounterStylesDirty: ::std::os::raw::c_uint,
                              mPostedFlushCounterStyles:
                                  ::std::os::raw::c_uint,
                              mFontFeatureValuesDirty: ::std::os::raw::c_uint,
                              mPostedFlushFontFeatureValues:
                                  ::std::os::raw::c_uint,
                              mSuppressResizeReflow: ::std::os::raw::c_uint,
                              mIsVisual: ::std::os::raw::c_uint,
                              mFireAfterPaintEvents: ::std::os::raw::c_uint,
                              mIsChrome: ::std::os::raw::c_uint,
                              mIsChromeOriginImage: ::std::os::raw::c_uint,
                              mPaintFlashing: ::std::os::raw::c_uint,
                              mPaintFlashingInitialized:
                                  ::std::os::raw::c_uint,
                              mHasWarnedAboutPositionedTableParts:
                                  ::std::os::raw::c_uint,
                              mHasWarnedAboutTooLargeDashedOrDottedRadius:
                                  ::std::os::raw::c_uint,
                              mQuirkSheetAdded: ::std::os::raw::c_uint,
                              mNeedsPrefUpdate: ::std::os::raw::c_uint,
                              mHadNonBlankPaint: ::std::os::raw::c_uint,
                              mRestyleLoggingEnabled: ::std::os::raw::c_uint,
                              mInitialized: ::std::os::raw::c_uint) -> u64 {
            ({
                 ({
                      ({
                           ({
                                ({
                                     ({
                                          ({
                                               ({
                                                    ({
                                                         ({
                                                              ({
                                                                   ({
                                                                        ({
                                                                             ({
                                                                                  ({
                                                                                       ({
                                                                                            ({
                                                                                                 ({
                                                                                                      ({
                                                                                                           ({
                                                                                                                ({
                                                                                                                     ({
                                                                                                                          ({
                                                                                                                               ({
                                                                                                                                    ({
                                                                                                                                         ({
                                                                                                                                              ({
                                                                                                                                                   ({
                                                                                                                                                        ({
                                                                                                                                                             ({
                                                                                                                                                                  ({
                                                                                                                                                                       ({
                                                                                                                                                                            ({
                                                                                                                                                                                 ({
                                                                                                                                                                                      ({
                                                                                                                                                                                           ({
                                                                                                                                                                                                ({
                                                                                                                                                                                                     ({
                                                                                                                                                                                                          ({
                                                                                                                                                                                                               ({
                                                                                                                                                                                                                    ({
                                                                                                                                                                                                                         ({
                                                                                                                                                                                                                              ({
                                                                                                                                                                                                                                   ({
                                                                                                                                                                                                                                        ({
                                                                                                                                                                                                                                             ({
                                                                                                                                                                                                                                                  ({
                                                                                                                                                                                                                                                       ({
                                                                                                                                                                                                                                                            0
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                            |
                                                                                                                                                                                                                                                            ((mHasPendingInterrupt
                                                                                                                                                                                                                                                                  as
                                                                                                                                                                                                                                                                  u32
                                                                                                                                                                                                                                                                  as
                                                                                                                                                                                                                                                                  u64)
                                                                                                                                                                                                                                                                 <<
                                                                                                                                                                                                                                                                 0usize)
                                                                                                                                                                                                                                                                &
                                                                                                                                                                                                                                                                (1u64
                                                                                                                                                                                                                                                                     as
                                                                                                                                                                                                                                                                     u64))
                                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                                                       |
                                                                                                                                                                                                                                                       ((mPendingInterruptFromTest
                                                                                                                                                                                                                                                             as
                                                                                                                                                                                                                                                             u32
                                                                                                                                                                                                                                                             as
                                                                                                                                                                                                                                                             u64)
                                                                                                                                                                                                                                                            <<
                                                                                                                                                                                                                                                            1usize)
                                                                                                                                                                                                                                                           &
                                                                                                                                                                                                                                                           (2u64
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                u64))
                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                                  |
                                                                                                                                                                                                                                                  ((mInterruptsEnabled
                                                                                                                                                                                                                                                        as
                                                                                                                                                                                                                                                        u32
                                                                                                                                                                                                                                                        as
                                                                                                                                                                                                                                                        u64)
                                                                                                                                                                                                                                                       <<
                                                                                                                                                                                                                                                       2usize)
                                                                                                                                                                                                                                                      &
                                                                                                                                                                                                                                                      (4u64
                                                                                                                                                                                                                                                           as
                                                                                                                                                                                                                                                           u64))
                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                             |
                                                                                                                                                                                                                                             ((mUseDocumentFonts
                                                                                                                                                                                                                                                   as
                                                                                                                                                                                                                                                   u32
                                                                                                                                                                                                                                                   as
                                                                                                                                                                                                                                                   u64)
                                                                                                                                                                                                                                                  <<
                                                                                                                                                                                                                                                  3usize)
                                                                                                                                                                                                                                                 &
                                                                                                                                                                                                                                                 (8u64
                                                                                                                                                                                                                                                      as
                                                                                                                                                                                                                                                      u64))
                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                        |
                                                                                                                                                                                                                                        ((mUseDocumentColors
                                                                                                                                                                                                                                              as
                                                                                                                                                                                                                                              u32
                                                                                                                                                                                                                                              as
                                                                                                                                                                                                                                              u64)
                                                                                                                                                                                                                                             <<
                                                                                                                                                                                                                                             4usize)
                                                                                                                                                                                                                                            &
                                                                                                                                                                                                                                            (16u64
                                                                                                                                                                                                                                                 as
                                                                                                                                                                                                                                                 u64))
                                                                                                                                                                                                                               }
                                                                                                                                                                                                                                   |
                                                                                                                                                                                                                                   ((mUnderlineLinks
                                                                                                                                                                                                                                         as
                                                                                                                                                                                                                                         u32
                                                                                                                                                                                                                                         as
                                                                                                                                                                                                                                         u64)
                                                                                                                                                                                                                                        <<
                                                                                                                                                                                                                                        5usize)
                                                                                                                                                                                                                                       &
                                                                                                                                                                                                                                       (32u64
                                                                                                                                                                                                                                            as
                                                                                                                                                                                                                                            u64))
                                                                                                                                                                                                                          }
                                                                                                                                                                                                                              |
                                                                                                                                                                                                                              ((mSendAfterPaintToContent
                                                                                                                                                                                                                                    as
                                                                                                                                                                                                                                    u32
                                                                                                                                                                                                                                    as
                                                                                                                                                                                                                                    u64)
                                                                                                                                                                                                                                   <<
                                                                                                                                                                                                                                   6usize)
                                                                                                                                                                                                                                  &
                                                                                                                                                                                                                                  (64u64
                                                                                                                                                                                                                                       as
                                                                                                                                                                                                                                       u64))
                                                                                                                                                                                                                     }
                                                                                                                                                                                                                         |
                                                                                                                                                                                                                         ((mUseFocusColors
                                                                                                                                                                                                                               as
                                                                                                                                                                                                                               u32
                                                                                                                                                                                                                               as
                                                                                                                                                                                                                               u64)
                                                                                                                                                                                                                              <<
                                                                                                                                                                                                                              7usize)
                                                                                                                                                                                                                             &
                                                                                                                                                                                                                             (128u64
                                                                                                                                                                                                                                  as
                                                                                                                                                                                                                                  u64))
                                                                                                                                                                                                                }
                                                                                                                                                                                                                    |
                                                                                                                                                                                                                    ((mFocusRingOnAnything
                                                                                                                                                                                                                          as
                                                                                                                                                                                                                          u32
                                                                                                                                                                                                                          as
                                                                                                                                                                                                                          u64)
                                                                                                                                                                                                                         <<
                                                                                                                                                                                                                         8usize)
                                                                                                                                                                                                                        &
                                                                                                                                                                                                                        (256u64
                                                                                                                                                                                                                             as
                                                                                                                                                                                                                             u64))
                                                                                                                                                                                                           }
                                                                                                                                                                                                               |
                                                                                                                                                                                                               ((mFocusRingStyle
                                                                                                                                                                                                                     as
                                                                                                                                                                                                                     u32
                                                                                                                                                                                                                     as
                                                                                                                                                                                                                     u64)
                                                                                                                                                                                                                    <<
                                                                                                                                                                                                                    9usize)
                                                                                                                                                                                                                   &
                                                                                                                                                                                                                   (512u64
                                                                                                                                                                                                                        as
                                                                                                                                                                                                                        u64))
                                                                                                                                                                                                      }
                                                                                                                                                                                                          |
                                                                                                                                                                                                          ((mDrawImageBackground
                                                                                                                                                                                                                as
                                                                                                                                                                                                                u32
                                                                                                                                                                                                                as
                                                                                                                                                                                                                u64)
                                                                                                                                                                                                               <<
                                                                                                                                                                                                               10usize)
                                                                                                                                                                                                              &
                                                                                                                                                                                                              (1024u64
                                                                                                                                                                                                                   as
                                                                                                                                                                                                                   u64))
                                                                                                                                                                                                 }
                                                                                                                                                                                                     |
                                                                                                                                                                                                     ((mDrawColorBackground
                                                                                                                                                                                                           as
                                                                                                                                                                                                           u32
                                                                                                                                                                                                           as
                                                                                                                                                                                                           u64)
                                                                                                                                                                                                          <<
                                                                                                                                                                                                          11usize)
                                                                                                                                                                                                         &
                                                                                                                                                                                                         (2048u64
                                                                                                                                                                                                              as
                                                                                                                                                                                                              u64))
                                                                                                                                                                                            }
                                                                                                                                                                                                |
                                                                                                                                                                                                ((mNeverAnimate
                                                                                                                                                                                                      as
                                                                                                                                                                                                      u32
                                                                                                                                                                                                      as
                                                                                                                                                                                                      u64)
                                                                                                                                                                                                     <<
                                                                                                                                                                                                     12usize)
                                                                                                                                                                                                    &
                                                                                                                                                                                                    (4096u64
                                                                                                                                                                                                         as
                                                                                                                                                                                                         u64))
                                                                                                                                                                                       }
                                                                                                                                                                                           |
                                                                                                                                                                                           ((mIsRenderingOnlySelection
                                                                                                                                                                                                 as
                                                                                                                                                                                                 u32
                                                                                                                                                                                                 as
                                                                                                                                                                                                 u64)
                                                                                                                                                                                                <<
                                                                                                                                                                                                13usize)
                                                                                                                                                                                               &
                                                                                                                                                                                               (8192u64
                                                                                                                                                                                                    as
                                                                                                                                                                                                    u64))
                                                                                                                                                                                  }
                                                                                                                                                                                      |
                                                                                                                                                                                      ((mPaginated
                                                                                                                                                                                            as
                                                                                                                                                                                            u32
                                                                                                                                                                                            as
                                                                                                                                                                                            u64)
                                                                                                                                                                                           <<
                                                                                                                                                                                           14usize)
                                                                                                                                                                                          &
                                                                                                                                                                                          (16384u64
                                                                                                                                                                                               as
                                                                                                                                                                                               u64))
                                                                                                                                                                             }
                                                                                                                                                                                 |
                                                                                                                                                                                 ((mCanPaginatedScroll
                                                                                                                                                                                       as
                                                                                                                                                                                       u32
                                                                                                                                                                                       as
                                                                                                                                                                                       u64)
                                                                                                                                                                                      <<
                                                                                                                                                                                      15usize)
                                                                                                                                                                                     &
                                                                                                                                                                                     (32768u64
                                                                                                                                                                                          as
                                                                                                                                                                                          u64))
                                                                                                                                                                        }
                                                                                                                                                                            |
                                                                                                                                                                            ((mDoScaledTwips
                                                                                                                                                                                  as
                                                                                                                                                                                  u32
                                                                                                                                                                                  as
                                                                                                                                                                                  u64)
                                                                                                                                                                                 <<
                                                                                                                                                                                 16usize)
                                                                                                                                                                                &
                                                                                                                                                                                (65536u64
                                                                                                                                                                                     as
                                                                                                                                                                                     u64))
                                                                                                                                                                   }
                                                                                                                                                                       |
                                                                                                                                                                       ((mIsRootPaginatedDocument
                                                                                                                                                                             as
                                                                                                                                                                             u32
                                                                                                                                                                             as
                                                                                                                                                                             u64)
                                                                                                                                                                            <<
                                                                                                                                                                            17usize)
                                                                                                                                                                           &
                                                                                                                                                                           (131072u64
                                                                                                                                                                                as
                                                                                                                                                                                u64))
                                                                                                                                                              }
                                                                                                                                                                  |
                                                                                                                                                                  ((mPrefBidiDirection
                                                                                                                                                                        as
                                                                                                                                                                        u32
                                                                                                                                                                        as
                                                                                                                                                                        u64)
                                                                                                                                                                       <<
                                                                                                                                                                       18usize)
                                                                                                                                                                      &
                                                                                                                                                                      (262144u64
                                                                                                                                                                           as
                                                                                                                                                                           u64))
                                                                                                                                                         }
                                                                                                                                                             |
                                                                                                                                                             ((mPrefScrollbarSide
                                                                                                                                                                   as
                                                                                                                                                                   u32
                                                                                                                                                                   as
                                                                                                                                                                   u64)
                                                                                                                                                                  <<
                                                                                                                                                                  19usize)
                                                                                                                                                                 &
                                                                                                                                                                 (1572864u64
                                                                                                                                                                      as
                                                                                                                                                                      u64))
                                                                                                                                                    }
                                                                                                                                                        |
                                                                                                                                                        ((mPendingSysColorChanged
                                                                                                                                                              as
                                                                                                                                                              u32
                                                                                                                                                              as
                                                                                                                                                              u64)
                                                                                                                                                             <<
                                                                                                                                                             21usize)
                                                                                                                                                            &
                                                                                                                                                            (2097152u64
                                                                                                                                                                 as
                                                                                                                                                                 u64))
                                                                                                                                               }
                                                                                                                                                   |
                                                                                                                                                   ((mPendingThemeChanged
                                                                                                                                                         as
                                                                                                                                                         u32
                                                                                                                                                         as
                                                                                                                                                         u64)
                                                                                                                                                        <<
                                                                                                                                                        22usize)
                                                                                                                                                       &
                                                                                                                                                       (4194304u64
                                                                                                                                                            as
                                                                                                                                                            u64))
                                                                                                                                          }
                                                                                                                                              |
                                                                                                                                              ((mPendingUIResolutionChanged
                                                                                                                                                    as
                                                                                                                                                    u32
                                                                                                                                                    as
                                                                                                                                                    u64)
                                                                                                                                                   <<
                                                                                                                                                   23usize)
                                                                                                                                                  &
                                                                                                                                                  (8388608u64
                                                                                                                                                       as
                                                                                                                                                       u64))
                                                                                                                                     }
                                                                                                                                         |
                                                                                                                                         ((mPendingMediaFeatureValuesChanged
                                                                                                                                               as
                                                                                                                                               u32
                                                                                                                                               as
                                                                                                                                               u64)
                                                                                                                                              <<
                                                                                                                                              24usize)
                                                                                                                                             &
                                                                                                                                             (16777216u64
                                                                                                                                                  as
                                                                                                                                                  u64))
                                                                                                                                }
                                                                                                                                    |
                                                                                                                                    ((mPrefChangePendingNeedsReflow
                                                                                                                                          as
                                                                                                                                          u32
                                                                                                                                          as
                                                                                                                                          u64)
                                                                                                                                         <<
                                                                                                                                         25usize)
                                                                                                                                        &
                                                                                                                                        (33554432u64
                                                                                                                                             as
                                                                                                                                             u64))
                                                                                                                           }
                                                                                                                               |
                                                                                                                               ((mIsEmulatingMedia
                                                                                                                                     as
                                                                                                                                     u32
                                                                                                                                     as
                                                                                                                                     u64)
                                                                                                                                    <<
                                                                                                                                    26usize)
                                                                                                                                   &
                                                                                                                                   (67108864u64
                                                                                                                                        as
                                                                                                                                        u64))
                                                                                                                      }
                                                                                                                          |
                                                                                                                          ((mIsGlyph
                                                                                                                                as
                                                                                                                                u32
                                                                                                                                as
                                                                                                                                u64)
                                                                                                                               <<
                                                                                                                               27usize)
                                                                                                                              &
                                                                                                                              (134217728u64
                                                                                                                                   as
                                                                                                                                   u64))
                                                                                                                 }
                                                                                                                     |
                                                                                                                     ((mUsesRootEMUnits
                                                                                                                           as
                                                                                                                           u32
                                                                                                                           as
                                                                                                                           u64)
                                                                                                                          <<
                                                                                                                          28usize)
                                                                                                                         &
                                                                                                                         (268435456u64
                                                                                                                              as
                                                                                                                              u64))
                                                                                                            }
                                                                                                                |
                                                                                                                ((mUsesExChUnits
                                                                                                                      as
                                                                                                                      u32
                                                                                                                      as
                                                                                                                      u64)
                                                                                                                     <<
                                                                                                                     29usize)
                                                                                                                    &
                                                                                                                    (536870912u64
                                                                                                                         as
                                                                                                                         u64))
                                                                                                       }
                                                                                                           |
                                                                                                           ((mPendingViewportChange
                                                                                                                 as
                                                                                                                 u32
                                                                                                                 as
                                                                                                                 u64)
                                                                                                                <<
                                                                                                                30usize)
                                                                                                               &
                                                                                                               (1073741824u64
                                                                                                                    as
                                                                                                                    u64))
                                                                                                  }
                                                                                                      |
                                                                                                      ((mCounterStylesDirty
                                                                                                            as
                                                                                                            u32
                                                                                                            as
                                                                                                            u64)
                                                                                                           <<
                                                                                                           31usize)
                                                                                                          &
                                                                                                          (2147483648u64
                                                                                                               as
                                                                                                               u64))
                                                                                             }
                                                                                                 |
                                                                                                 ((mPostedFlushCounterStyles
                                                                                                       as
                                                                                                       u32
                                                                                                       as
                                                                                                       u64)
                                                                                                      <<
                                                                                                      32usize)
                                                                                                     &
                                                                                                     (4294967296u64
                                                                                                          as
                                                                                                          u64))
                                                                                        }
                                                                                            |
                                                                                            ((mFontFeatureValuesDirty
                                                                                                  as
                                                                                                  u32
                                                                                                  as
                                                                                                  u64)
                                                                                                 <<
                                                                                                 33usize)
                                                                                                &
                                                                                                (8589934592u64
                                                                                                     as
                                                                                                     u64))
                                                                                   }
                                                                                       |
                                                                                       ((mPostedFlushFontFeatureValues
                                                                                             as
                                                                                             u32
                                                                                             as
                                                                                             u64)
                                                                                            <<
                                                                                            34usize)
                                                                                           &
                                                                                           (17179869184u64
                                                                                                as
                                                                                                u64))
                                                                              }
                                                                                  |
                                                                                  ((mSuppressResizeReflow
                                                                                        as
                                                                                        u32
                                                                                        as
                                                                                        u64)
                                                                                       <<
                                                                                       35usize)
                                                                                      &
                                                                                      (34359738368u64
                                                                                           as
                                                                                           u64))
                                                                         } |
                                                                             ((mIsVisual
                                                                                   as
                                                                                   u32
                                                                                   as
                                                                                   u64)
                                                                                  <<
                                                                                  36usize)
                                                                                 &
                                                                                 (68719476736u64
                                                                                      as
                                                                                      u64))
                                                                    } |
                                                                        ((mFireAfterPaintEvents
                                                                              as
                                                                              u32
                                                                              as
                                                                              u64)
                                                                             <<
                                                                             37usize)
                                                                            &
                                                                            (137438953472u64
                                                                                 as
                                                                                 u64))
                                                               } |
                                                                   ((mIsChrome
                                                                         as
                                                                         u32
                                                                         as
                                                                         u64)
                                                                        <<
                                                                        38usize)
                                                                       &
                                                                       (274877906944u64
                                                                            as
                                                                            u64))
                                                          } |
                                                              ((mIsChromeOriginImage
                                                                    as u32 as
                                                                    u64) <<
                                                                   39usize) &
                                                                  (549755813888u64
                                                                       as
                                                                       u64))
                                                     } |
                                                         ((mPaintFlashing as
                                                               u32 as u64) <<
                                                              40usize) &
                                                             (1099511627776u64
                                                                  as u64))
                                                } |
                                                    ((mPaintFlashingInitialized
                                                          as u32 as u64) <<
                                                         41usize) &
                                                        (2199023255552u64 as
                                                             u64))
                                           } |
                                               ((mHasWarnedAboutPositionedTableParts
                                                     as u32 as u64) <<
                                                    42usize) &
                                                   (4398046511104u64 as u64))
                                      } |
                                          ((mHasWarnedAboutTooLargeDashedOrDottedRadius
                                                as u32 as u64) << 43usize) &
                                              (8796093022208u64 as u64))
                                 } |
                                     ((mQuirkSheetAdded as u32 as u64) <<
                                          44usize) &
                                         (17592186044416u64 as u64))
                            } |
                                ((mNeedsPrefUpdate as u32 as u64) << 45usize)
                                    & (35184372088832u64 as u64))
                       } |
                           ((mHadNonBlankPaint as u32 as u64) << 46usize) &
                               (70368744177664u64 as u64))
                  } |
                      ((mRestyleLoggingEnabled as u32 as u64) << 47usize) &
                          (140737488355328u64 as u64))
             } |
                 ((mInitialized as u32 as u64) << 48usize) &
                     (281474976710656u64 as u64))
        }
    }
    pub type gfxSize = [u64; 2usize];
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAttrName {
        pub mBits: usize,
    }
    #[test]
    fn bindgen_test_layout_nsAttrName() {
        assert_eq!(::std::mem::size_of::<nsAttrName>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsAttrName ) ));
        assert_eq! (::std::mem::align_of::<nsAttrName>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsAttrName ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrName ) ) . mBits as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAttrName ) , "::"
                    , stringify ! ( mBits ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAttrValue {
        pub mBits: usize,
    }
    pub type nsAttrValue_AtomArray =
        root::nsTArray<root::nsCOMPtr<root::nsIAtom>>;
    pub const nsAttrValue_ValueType_eSVGTypesBegin:
              root::nsAttrValue_ValueType =
        nsAttrValue_ValueType::eSVGAngle;
    pub const nsAttrValue_ValueType_eSVGTypesEnd: root::nsAttrValue_ValueType
              =
        nsAttrValue_ValueType::eSVGViewBox;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsAttrValue_ValueType {
        eString = 0,
        eAtom = 2,
        eInteger = 3,
        eColor = 7,
        eEnum = 11,
        ePercent = 15,
        eCSSDeclaration = 16,
        eURL = 17,
        eImage = 18,
        eAtomArray = 19,
        eDoubleValue = 20,
        eIntMarginValue = 21,
        eSVGAngle = 22,
        eSVGIntegerPair = 23,
        eSVGLength = 24,
        eSVGLengthList = 25,
        eSVGNumberList = 26,
        eSVGNumberPair = 27,
        eSVGPathData = 28,
        eSVGPointList = 29,
        eSVGPreserveAspectRatio = 30,
        eSVGStringList = 31,
        eSVGTransformList = 32,
        eSVGViewBox = 33,
    }
    /// Structure for a mapping from int (enum) values to strings.  When you use
    /// it you generally create an array of them.
    /// Instantiate like this:
    /// EnumTable myTable[] = {
    /// { "string1", 1 },
    /// { "string2", 2 },
    /// { nullptr, 0 }
    /// }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsAttrValue_EnumTable {
        /// The string the value maps to
        pub tag: *const ::std::os::raw::c_char,
        /// The enum value that maps to this string
        pub value: i16,
    }
    #[test]
    fn bindgen_test_layout_nsAttrValue_EnumTable() {
        assert_eq!(::std::mem::size_of::<nsAttrValue_EnumTable>() , 16usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsAttrValue_EnumTable ) ));
        assert_eq! (::std::mem::align_of::<nsAttrValue_EnumTable>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsAttrValue_EnumTable )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrValue_EnumTable ) ) . tag as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrValue_EnumTable ) , "::" , stringify ! ( tag ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrValue_EnumTable ) ) . value as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrValue_EnumTable ) , "::" , stringify ! ( value ) ));
    }
    impl Clone for nsAttrValue_EnumTable {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsAttrValue_ValueBaseType {
        eStringBase = 0,
        eOtherBase = 1,
        eAtomBase = 2,
        eIntegerBase = 3,
    }
    extern "C" {
        #[link_name = "_ZN11nsAttrValue15sEnumTableArrayE"]
        pub static mut nsAttrValue_sEnumTableArray:
                   *mut root::nsTArray<*const root::nsAttrValue_EnumTable>;
    }
    #[test]
    fn bindgen_test_layout_nsAttrValue() {
        assert_eq!(::std::mem::size_of::<nsAttrValue>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsAttrValue ) ));
        assert_eq! (::std::mem::align_of::<nsAttrValue>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsAttrValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrValue ) ) . mBits as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAttrValue ) ,
                    "::" , stringify ! ( mBits ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIVariant {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIVariant_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIVariant() {
        assert_eq!(::std::mem::size_of::<nsIVariant>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIVariant ) ));
        assert_eq! (::std::mem::align_of::<nsIVariant>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIVariant ) ));
    }
    impl Clone for nsIVariant {
        fn clone(&self) -> Self { *self }
    }
    pub const kNameSpaceID_None: i32 = 0;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsNodeInfoManager {
        pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
        pub _mOwningThread: root::nsAutoOwningThread,
        pub mNodeInfoHash: *mut root::PLHashTable,
        pub mDocument: *mut root::nsIDocument,
        pub mNonDocumentNodeInfos: u32,
        pub mPrincipal: root::nsCOMPtr<root::nsIPrincipal>,
        pub mDefaultPrincipal: root::nsCOMPtr<root::nsIPrincipal>,
        pub mTextNodeInfo: *mut root::mozilla::dom::NodeInfo,
        pub mCommentNodeInfo: *mut root::mozilla::dom::NodeInfo,
        pub mDocumentNodeInfo: *mut root::mozilla::dom::NodeInfo,
        pub mBindingManager: root::RefPtr<root::nsBindingManager>,
        pub mRecentlyUsedNodeInfos: [*mut root::mozilla::dom::NodeInfo; 31usize],
        pub mSVGEnabled: root::nsNodeInfoManager_Tri,
        pub mMathMLEnabled: root::nsNodeInfoManager_Tri,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsNodeInfoManager_cycleCollection {
        pub _base: root::nsCycleCollectionParticipant,
    }
    #[test]
    fn bindgen_test_layout_nsNodeInfoManager_cycleCollection() {
        assert_eq!(::std::mem::size_of::<nsNodeInfoManager_cycleCollection>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsNodeInfoManager_cycleCollection ) ));
        assert_eq! (::std::mem::align_of::<nsNodeInfoManager_cycleCollection>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsNodeInfoManager_cycleCollection ) ));
    }
    impl Clone for nsNodeInfoManager_cycleCollection {
        fn clone(&self) -> Self { *self }
    }
    pub type nsNodeInfoManager_HasThreadSafeRefCnt = root::mozilla::FalseType;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsNodeInfoManager_Tri {
        eTriUnset = 0,
        eTriFalse = 1,
        eTriTrue = 2,
    }
    extern "C" {
        #[link_name = "_ZN17nsNodeInfoManager21_cycleCollectorGlobalE"]
        pub static mut nsNodeInfoManager__cycleCollectorGlobal:
                   root::nsNodeInfoManager_cycleCollection;
    }
    #[test]
    fn bindgen_test_layout_nsNodeInfoManager() {
        assert_eq!(::std::mem::size_of::<nsNodeInfoManager>() , 344usize ,
                   concat ! ( "Size of: " , stringify ! ( nsNodeInfoManager )
                   ));
        assert_eq! (::std::mem::align_of::<nsNodeInfoManager>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsNodeInfoManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) . mRefCnt as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) .
                    _mOwningThread as * const _ as usize } , 8usize , concat !
                    (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( _mOwningThread ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) . mNodeInfoHash
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mNodeInfoHash ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) . mDocument as
                    * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mDocument ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) .
                    mNonDocumentNodeInfos as * const _ as usize } , 32usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mNonDocumentNodeInfos ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) . mPrincipal as
                    * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mPrincipal ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) .
                    mDefaultPrincipal as * const _ as usize } , 48usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mDefaultPrincipal ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) . mTextNodeInfo
                    as * const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mTextNodeInfo ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) .
                    mCommentNodeInfo as * const _ as usize } , 64usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mCommentNodeInfo ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) .
                    mDocumentNodeInfo as * const _ as usize } , 72usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mDocumentNodeInfo ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) .
                    mBindingManager as * const _ as usize } , 80usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mBindingManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) .
                    mRecentlyUsedNodeInfos as * const _ as usize } , 88usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mRecentlyUsedNodeInfos ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) . mSVGEnabled
                    as * const _ as usize } , 336usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mSVGEnabled ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) .
                    mMathMLEnabled as * const _ as usize } , 340usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mMathMLEnabled ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIFrame {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPropertyTable {
        pub mPropertyList: *mut root::nsPropertyTable_PropertyList,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsPropertyTable_PropertyList {
        _unused: [u8; 0],
    }
    #[test]
    fn bindgen_test_layout_nsPropertyTable() {
        assert_eq!(::std::mem::size_of::<nsPropertyTable>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsPropertyTable ) ));
        assert_eq! (::std::mem::align_of::<nsPropertyTable>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsPropertyTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPropertyTable ) ) . mPropertyList
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPropertyTable ) ,
                    "::" , stringify ! ( mPropertyList ) ));
    }
    pub type nsTObserverArray_base_index_type = usize;
    pub type nsTObserverArray_base_size_type = usize;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTObserverArray_base_Iterator_base {
        pub mPosition: root::nsTObserverArray_base_index_type,
        pub mNext: *mut root::nsTObserverArray_base_Iterator_base,
    }
    #[test]
    fn bindgen_test_layout_nsTObserverArray_base_Iterator_base() {
        assert_eq!(::std::mem::size_of::<nsTObserverArray_base_Iterator_base>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsTObserverArray_base_Iterator_base ) ));
        assert_eq! (::std::mem::align_of::<nsTObserverArray_base_Iterator_base>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsTObserverArray_base_Iterator_base ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsTObserverArray_base_Iterator_base )
                    ) . mPosition as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsTObserverArray_base_Iterator_base ) , "::" , stringify !
                    ( mPosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsTObserverArray_base_Iterator_base )
                    ) . mNext as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTObserverArray_base_Iterator_base ) , "::" , stringify !
                    ( mNext ) ));
    }
    impl Clone for nsTObserverArray_base_Iterator_base {
        fn clone(&self) -> Self { *self }
    }
    pub type nsAutoTObserverArray_elem_type<T> = T;
    pub type nsAutoTObserverArray_array_type<T> = root::nsTArray<T>;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAutoTObserverArray_Iterator {
        pub _base: root::nsTObserverArray_base_Iterator_base,
        pub mArray: *mut root::nsAutoTObserverArray_Iterator_array_type,
    }
    pub type nsAutoTObserverArray_Iterator_array_type = u8;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAutoTObserverArray_ForwardIterator {
        pub _base: root::nsAutoTObserverArray_Iterator,
    }
    pub type nsAutoTObserverArray_ForwardIterator_array_type = u8;
    pub type nsAutoTObserverArray_ForwardIterator_base_type =
        root::nsAutoTObserverArray_Iterator;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAutoTObserverArray_EndLimitedIterator {
        pub _base: root::nsAutoTObserverArray_ForwardIterator,
        pub mEnd: root::nsAutoTObserverArray_ForwardIterator,
    }
    pub type nsAutoTObserverArray_EndLimitedIterator_array_type = u8;
    pub type nsAutoTObserverArray_EndLimitedIterator_base_type =
        root::nsAutoTObserverArray_Iterator;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAutoTObserverArray_BackwardIterator {
        pub _base: root::nsAutoTObserverArray_Iterator,
    }
    pub type nsAutoTObserverArray_BackwardIterator_array_type = u8;
    pub type nsAutoTObserverArray_BackwardIterator_base_type =
        root::nsAutoTObserverArray_Iterator;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsTObserverArray {
    }
    pub type nsTObserverArray_base_type = u8;
    pub type nsTObserverArray_size_type =
        root::nsTObserverArray_base_size_type;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIGlobalObject {
        pub _base: root::nsISupports,
        pub _base_1: root::mozilla::dom::DispatcherTrait,
        pub mHostObjectURIs: root::nsTArray<root::nsCString>,
        pub mIsDying: bool,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIGlobalObject_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIGlobalObject() {
        assert_eq!(::std::mem::size_of::<nsIGlobalObject>() , 32usize , concat
                   ! ( "Size of: " , stringify ! ( nsIGlobalObject ) ));
        assert_eq! (::std::mem::align_of::<nsIGlobalObject>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIGlobalObject ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAttrAndChildArray {
        pub mImpl: *mut root::nsAttrAndChildArray_Impl,
    }
    pub type nsAttrAndChildArray_BorrowedAttrInfo =
        root::mozilla::dom::BorrowedAttrInfo;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAttrAndChildArray_InternalAttr {
        pub mName: root::nsAttrName,
        pub mValue: root::nsAttrValue,
    }
    #[test]
    fn bindgen_test_layout_nsAttrAndChildArray_InternalAttr() {
        assert_eq!(::std::mem::size_of::<nsAttrAndChildArray_InternalAttr>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsAttrAndChildArray_InternalAttr ) ));
        assert_eq! (::std::mem::align_of::<nsAttrAndChildArray_InternalAttr>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsAttrAndChildArray_InternalAttr ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrAndChildArray_InternalAttr ) )
                    . mName as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrAndChildArray_InternalAttr ) , "::" , stringify ! (
                    mName ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrAndChildArray_InternalAttr ) )
                    . mValue as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrAndChildArray_InternalAttr ) , "::" , stringify ! (
                    mValue ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsAttrAndChildArray_Impl {
        pub mAttrAndChildCount: u32,
        pub mBufferSize: u32,
        pub mMappedAttrs: *mut root::nsMappedAttributes,
        pub mBuffer: [*mut ::std::os::raw::c_void; 1usize],
    }
    #[test]
    fn bindgen_test_layout_nsAttrAndChildArray_Impl() {
        assert_eq!(::std::mem::size_of::<nsAttrAndChildArray_Impl>() , 24usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsAttrAndChildArray_Impl ) ));
        assert_eq! (::std::mem::align_of::<nsAttrAndChildArray_Impl>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsAttrAndChildArray_Impl )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrAndChildArray_Impl ) ) .
                    mAttrAndChildCount as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrAndChildArray_Impl ) , "::" , stringify ! (
                    mAttrAndChildCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrAndChildArray_Impl ) ) .
                    mBufferSize as * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrAndChildArray_Impl ) , "::" , stringify ! (
                    mBufferSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrAndChildArray_Impl ) ) .
                    mMappedAttrs as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrAndChildArray_Impl ) , "::" , stringify ! (
                    mMappedAttrs ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrAndChildArray_Impl ) ) .
                    mBuffer as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrAndChildArray_Impl ) , "::" , stringify ! ( mBuffer
                    ) ));
    }
    impl Clone for nsAttrAndChildArray_Impl {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsAttrAndChildArray() {
        assert_eq!(::std::mem::size_of::<nsAttrAndChildArray>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsAttrAndChildArray ) ));
        assert_eq! (::std::mem::align_of::<nsAttrAndChildArray>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsAttrAndChildArray ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrAndChildArray ) ) . mImpl as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAttrAndChildArray
                    ) , "::" , stringify ! ( mImpl ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsAttrChildContentList {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsDOMAttributeMap {
        pub _base: root::nsIDOMMozNamedAttrMap,
        pub _base_1: root::nsWrapperCache,
        pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
        pub _mOwningThread: root::nsAutoOwningThread,
        pub mContent: root::nsCOMPtr<root::nsDOMAttributeMap_Element>,
        /// Cache of Attrs.
        pub mAttributeCache: root::nsDOMAttributeMap_AttrCache,
    }
    pub type nsDOMAttributeMap_Attr = root::mozilla::dom::Attr;
    pub type nsDOMAttributeMap_Element = root::mozilla::dom::Element;
    pub type nsDOMAttributeMap_ErrorResult = root::mozilla::ErrorResult;
    pub type nsDOMAttributeMap_HasThreadSafeRefCnt = root::mozilla::FalseType;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsDOMAttributeMap_cycleCollection {
        pub _base: root::nsXPCOMCycleCollectionParticipant,
    }
    #[test]
    fn bindgen_test_layout_nsDOMAttributeMap_cycleCollection() {
        assert_eq!(::std::mem::size_of::<nsDOMAttributeMap_cycleCollection>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsDOMAttributeMap_cycleCollection ) ));
        assert_eq! (::std::mem::align_of::<nsDOMAttributeMap_cycleCollection>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsDOMAttributeMap_cycleCollection ) ));
    }
    impl Clone for nsDOMAttributeMap_cycleCollection {
        fn clone(&self) -> Self { *self }
    }
    pub type nsDOMAttributeMap_AttrCache = [u64; 6usize];
    extern "C" {
        #[link_name = "_ZN17nsDOMAttributeMap21_cycleCollectorGlobalE"]
        pub static mut nsDOMAttributeMap__cycleCollectorGlobal:
                   root::nsDOMAttributeMap_cycleCollection;
    }
    #[test]
    fn bindgen_test_layout_nsDOMAttributeMap() {
        assert_eq!(::std::mem::size_of::<nsDOMAttributeMap>() , 104usize ,
                   concat ! ( "Size of: " , stringify ! ( nsDOMAttributeMap )
                   ));
        assert_eq! (::std::mem::align_of::<nsDOMAttributeMap>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsDOMAttributeMap ) ));
    }
    /// Mutation observer interface
    ///
    /// See nsINode::AddMutationObserver, nsINode::RemoveMutationObserver for how to
    /// attach or remove your observers.
    ///
    /// WARNING: During these notifications, you are not allowed to perform
    /// any mutations to the current or any other document, or start a
    /// network load.  If you need to perform such operations do that
    /// during the _last_ nsIDocumentObserver::EndUpdate notification.  The
    /// expection for this is ParentChainChanged, where mutations should be
    /// done from an async event, as the notification might not be
    /// surrounded by BeginUpdate/EndUpdate calls.
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIMutationObserver {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIMutationObserver_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIMutationObserver() {
        assert_eq!(::std::mem::size_of::<nsIMutationObserver>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIMutationObserver ) ));
        assert_eq! (::std::mem::align_of::<nsIMutationObserver>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIMutationObserver ) ));
    }
    impl Clone for nsIMutationObserver {
        fn clone(&self) -> Self { *self }
    }
    /// Presentation shell interface. Presentation shells are the
    /// controlling point for managing the presentation of a document. The
    /// presentation shell holds a live reference to the document, the
    /// presentation context, the style manager, the style set and the root
    /// frame. <p>
    ///
    /// When this object is Release'd, it will release the document, the
    /// presentation context, the style manager, the style set and the root
    /// frame.
    #[repr(C)]
    pub struct nsIPresShell {
        pub _base: root::nsISupports,
        pub mDocument: root::nsCOMPtr<root::nsIDocument>,
        pub mPresContext: root::RefPtr<root::nsPresContext>,
        pub mStyleSet: root::mozilla::StyleSetHandle,
        pub mFrameConstructor: *mut root::nsCSSFrameConstructor,
        pub mViewManager: *mut root::nsViewManager,
        pub mFrameArena: root::nsPresArena,
        pub mSelection: root::RefPtr<root::nsFrameSelection>,
        pub mFrameManager: *mut root::nsFrameManagerBase,
        pub mForwardingContainer: u64,
        pub mDocAccessible: *mut root::mozilla::a11y::DocAccessible,
        pub mReflowContinueTimer: root::nsCOMPtr<root::nsITimer>,
        pub mDrawEventTargetFrame: *mut root::nsIFrame,
        pub mAllocatedPointers: [u64; 6usize],
        pub mPaintCount: u64,
        pub mScrollPositionClampingScrollPortSize: root::nsSize,
        pub mAutoWeakFrames: *mut root::AutoWeakFrame,
        pub mWeakFrames: [u64; 6usize],
        pub mCanvasBackgroundColor: root::nscolor,
        pub mResolution: [u32; 2usize],
        pub mSelectionFlags: i16,
        pub mRenderFlags: root::nsIPresShell_RenderFlags,
        pub _bitfield_1: [u8; 2usize],
        pub mPresShellId: u32,
        pub mFontSizeInflationEmPerLine: u32,
        pub mFontSizeInflationMinTwips: u32,
        pub mFontSizeInflationLineThreshold: u32,
        pub mFontSizeInflationForceEnabled: bool,
        pub mFontSizeInflationDisabledInMasterProcess: bool,
        pub mFontSizeInflationEnabled: bool,
        pub mFontSizeInflationEnabledIsDirty: bool,
        pub mPaintingIsFrozen: bool,
        pub mIsNeverPainting: bool,
        pub mInFlush: bool,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIPresShell_COMTypeInfo {
        pub _address: u8,
    }
    pub type nsIPresShell_LayerManager = root::mozilla::layers::LayerManager;
    pub type nsIPresShell_SourceSurface = root::mozilla::gfx::SourceSurface;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_eRenderFlag {
        STATE_IGNORING_VIEWPORT_SCROLLING = 1,
        STATE_DRAWWINDOW_NOT_FLUSHING = 2,
    }
    pub type nsIPresShell_RenderFlags = u8;
    #[repr(u32)]
    /// Gets nearest scrollable frame from the specified content node. The frame
    /// is scrollable with overflow:scroll or overflow:auto in some direction when
    /// aDirection is eEither.  Otherwise, this returns a nearest frame that is
    /// scrollable in the specified direction.
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_ScrollDirection {
        eHorizontal = 0,
        eVertical = 1,
        eEither = 2,
    }
    #[repr(u32)]
    /// Tell the pres shell that a frame needs to be marked dirty and needs
    /// Reflow.  It's OK if this is an ancestor of the frame needing reflow as
    /// long as the ancestor chain between them doesn't cross a reflow root.
    ///
    /// The bit to add should be NS_FRAME_IS_DIRTY, NS_FRAME_HAS_DIRTY_CHILDREN
    /// or nsFrameState(0); passing 0 means that dirty bits won't be set on the
    /// frame or its ancestors/descendants, but that intrinsic widths will still
    /// be marked dirty.  Passing aIntrinsicDirty = eResize and aBitToAdd = 0
    /// would result in no work being done, so don't do that.
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_IntrinsicDirty {
        eResize = 0,
        eTreeChange = 1,
        eStyleChange = 2,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_ReflowRootHandling {
        ePositionOrSizeChange = 0,
        eNoPositionOrSizeChange = 1,
        eInferFromBitToAdd = 2,
    }
    pub const nsIPresShell_SCROLL_TOP: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_TOP;
    pub const nsIPresShell_SCROLL_BOTTOM: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_BOTTOM;
    pub const nsIPresShell_SCROLL_LEFT: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_TOP;
    pub const nsIPresShell_SCROLL_RIGHT: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_BOTTOM;
    pub const nsIPresShell_SCROLL_CENTER: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_CENTER;
    pub const nsIPresShell_SCROLL_MINIMUM: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_MINIMUM;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell__bindgen_ty_1 {
        SCROLL_TOP = 0,
        SCROLL_BOTTOM = 100,
        SCROLL_CENTER = 50,
        SCROLL_MINIMUM = -1,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_WhenToScroll {
        SCROLL_ALWAYS = 0,
        SCROLL_IF_NOT_VISIBLE = 1,
        SCROLL_IF_NOT_FULLY_VISIBLE = 2,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIPresShell_ScrollAxis {
        pub _bindgen_opaque_blob: u32,
    }
    #[test]
    fn bindgen_test_layout_nsIPresShell_ScrollAxis() {
        assert_eq!(::std::mem::size_of::<nsIPresShell_ScrollAxis>() , 4usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIPresShell_ScrollAxis ) ));
        assert_eq! (::std::mem::align_of::<nsIPresShell_ScrollAxis>() , 4usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsIPresShell_ScrollAxis )
                    ));
    }
    impl Clone for nsIPresShell_ScrollAxis {
        fn clone(&self) -> Self { *self }
    }
    pub const nsIPresShell_SCROLL_FIRST_ANCESTOR_ONLY:
              root::nsIPresShell__bindgen_ty_2 =
        nsIPresShell__bindgen_ty_2::SCROLL_FIRST_ANCESTOR_ONLY;
    pub const nsIPresShell_SCROLL_OVERFLOW_HIDDEN:
              root::nsIPresShell__bindgen_ty_2 =
        nsIPresShell__bindgen_ty_2::SCROLL_OVERFLOW_HIDDEN;
    pub const nsIPresShell_SCROLL_NO_PARENT_FRAMES:
              root::nsIPresShell__bindgen_ty_2 =
        nsIPresShell__bindgen_ty_2::SCROLL_NO_PARENT_FRAMES;
    pub const nsIPresShell_SCROLL_SMOOTH: root::nsIPresShell__bindgen_ty_2 =
        nsIPresShell__bindgen_ty_2::SCROLL_SMOOTH;
    pub const nsIPresShell_SCROLL_SMOOTH_AUTO:
              root::nsIPresShell__bindgen_ty_2 =
        nsIPresShell__bindgen_ty_2::SCROLL_SMOOTH_AUTO;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell__bindgen_ty_2 {
        SCROLL_FIRST_ANCESTOR_ONLY = 1,
        SCROLL_OVERFLOW_HIDDEN = 2,
        SCROLL_NO_PARENT_FRAMES = 4,
        SCROLL_SMOOTH = 8,
        SCROLL_SMOOTH_AUTO = 16,
    }
    pub const nsIPresShell_RENDER_IS_UNTRUSTED:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_IS_UNTRUSTED;
    pub const nsIPresShell_RENDER_IGNORE_VIEWPORT_SCROLLING:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_IGNORE_VIEWPORT_SCROLLING;
    pub const nsIPresShell_RENDER_CARET: root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_CARET;
    pub const nsIPresShell_RENDER_USE_WIDGET_LAYERS:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_USE_WIDGET_LAYERS;
    pub const nsIPresShell_RENDER_ASYNC_DECODE_IMAGES:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_ASYNC_DECODE_IMAGES;
    pub const nsIPresShell_RENDER_DOCUMENT_RELATIVE:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_DOCUMENT_RELATIVE;
    pub const nsIPresShell_RENDER_DRAWWINDOW_NOT_FLUSHING:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_DRAWWINDOW_NOT_FLUSHING;
    #[repr(u32)]
    /// Render the document into an arbitrary gfxContext
    /// Designed for getting a picture of a document or a piece of a document
    /// Note that callers will generally want to call FlushPendingNotifications
    /// to get an up-to-date view of the document
    /// @param aRect is the region to capture into the offscreen buffer, in the
    /// root frame's coordinate system (if aIgnoreViewportScrolling is false)
    /// or in the root scrolled frame's coordinate system
    /// (if aIgnoreViewportScrolling is true). The coordinates are in appunits.
    /// @param aFlags see below;
    /// set RENDER_IS_UNTRUSTED if the contents may be passed to malicious
    /// agents. E.g. we might choose not to paint the contents of sensitive widgets
    /// such as the file name in a file upload widget, and we might choose not
    /// to paint themes.
    /// set RENDER_IGNORE_VIEWPORT_SCROLLING to ignore
    /// clipping and scrollbar painting due to scrolling in the viewport
    /// set RENDER_CARET to draw the caret if one would be visible
    /// (by default the caret is never drawn)
    /// set RENDER_USE_LAYER_MANAGER to force rendering to go through
    /// the layer manager for the window. This may be unexpectedly slow
    /// (if the layer manager must read back data from the GPU) or low-quality
    /// (if the layer manager reads back pixel data and scales it
    /// instead of rendering using the appropriate scaling). It may also
    /// slow everything down if the area rendered does not correspond to the
    /// normal visible area of the window.
    /// set RENDER_ASYNC_DECODE_IMAGES to avoid having images synchronously
    /// decoded during rendering.
    /// (by default images decode synchronously with RenderDocument)
    /// set RENDER_DOCUMENT_RELATIVE to render the document as if there has been
    /// no scrolling and interpret |aRect| relative to the document instead of the
    /// CSS viewport. Only considered if RENDER_IGNORE_VIEWPORT_SCROLLING is set
    /// or the document is in ignore viewport scrolling mode
    /// (nsIPresShell::SetIgnoreViewportScrolling/IgnoringViewportScrolling).
    /// @param aBackgroundColor a background color to render onto
    /// @param aRenderedContext the gfxContext to render to. We render so that
    /// one CSS pixel in the source document is rendered to one unit in the current
    /// transform.
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell__bindgen_ty_3 {
        RENDER_IS_UNTRUSTED = 1,
        RENDER_IGNORE_VIEWPORT_SCROLLING = 2,
        RENDER_CARET = 4,
        RENDER_USE_WIDGET_LAYERS = 8,
        RENDER_ASYNC_DECODE_IMAGES = 16,
        RENDER_DOCUMENT_RELATIVE = 32,
        RENDER_DRAWWINDOW_NOT_FLUSHING = 64,
    }
    pub const nsIPresShell_RENDER_IS_IMAGE: root::nsIPresShell__bindgen_ty_4 =
        nsIPresShell__bindgen_ty_4::RENDER_IS_IMAGE;
    pub const nsIPresShell_RENDER_AUTO_SCALE: root::nsIPresShell__bindgen_ty_4
              =
        nsIPresShell__bindgen_ty_4::RENDER_AUTO_SCALE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell__bindgen_ty_4 {
        RENDER_IS_IMAGE = 256,
        RENDER_AUTO_SCALE = 128,
    }
    pub const nsIPresShell_FORCE_DRAW: root::nsIPresShell__bindgen_ty_5 =
        nsIPresShell__bindgen_ty_5::FORCE_DRAW;
    pub const nsIPresShell_ADD_FOR_SUBDOC: root::nsIPresShell__bindgen_ty_5 =
        nsIPresShell__bindgen_ty_5::ADD_FOR_SUBDOC;
    pub const nsIPresShell_APPEND_UNSCROLLED_ONLY:
              root::nsIPresShell__bindgen_ty_5 =
        nsIPresShell__bindgen_ty_5::APPEND_UNSCROLLED_ONLY;
    #[repr(u32)]
    /// Add a solid color item to the bottom of aList with frame aFrame and bounds
    /// aBounds. Checks first if this needs to be done by checking if aFrame is a
    /// canvas frame (if the FORCE_DRAW flag is passed then this check is skipped).
    /// aBackstopColor is composed behind the background color of the canvas, it is
    /// transparent by default.
    /// We attempt to make the background color part of the scrolled canvas (to reduce
    /// transparent layers), and if async scrolling is enabled (and the background
    /// is opaque) then we add a second, unscrolled item to handle the checkerboarding
    /// case.
    /// ADD_FOR_SUBDOC shoud be specified when calling this for a subdocument, and
    /// LayoutUseContainersForRootFrame might cause the whole list to be scrolled. In
    /// that case the second unscrolled item will be elided.
    /// APPEND_UNSCROLLED_ONLY only attempts to add the unscrolled item, so that we
    /// can add it manually after LayoutUseContainersForRootFrame has built the
    /// scrolling ContainerLayer.
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell__bindgen_ty_5 {
        FORCE_DRAW = 1,
        ADD_FOR_SUBDOC = 2,
        APPEND_UNSCROLLED_ONLY = 4,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIPresShell_PointerCaptureInfo {
        pub mPendingContent: root::nsCOMPtr<root::nsIContent>,
        pub mOverrideContent: root::nsCOMPtr<root::nsIContent>,
    }
    #[test]
    fn bindgen_test_layout_nsIPresShell_PointerCaptureInfo() {
        assert_eq!(::std::mem::size_of::<nsIPresShell_PointerCaptureInfo>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( nsIPresShell_PointerCaptureInfo
                   ) ));
        assert_eq! (::std::mem::align_of::<nsIPresShell_PointerCaptureInfo>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsIPresShell_PointerCaptureInfo ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell_PointerCaptureInfo ) ) .
                    mPendingContent as * const _ as usize } , 0usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsIPresShell_PointerCaptureInfo ) , "::" , stringify ! (
                    mPendingContent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell_PointerCaptureInfo ) ) .
                    mOverrideContent as * const _ as usize } , 8usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsIPresShell_PointerCaptureInfo ) , "::" , stringify ! (
                    mOverrideContent ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIPresShell_PointerInfo {
        pub mPointerType: u16,
        pub mActiveState: bool,
        pub mPrimaryState: bool,
        pub mPreventMouseEventByContent: bool,
    }
    #[test]
    fn bindgen_test_layout_nsIPresShell_PointerInfo() {
        assert_eq!(::std::mem::size_of::<nsIPresShell_PointerInfo>() , 6usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsIPresShell_PointerInfo ) ));
        assert_eq! (::std::mem::align_of::<nsIPresShell_PointerInfo>() ,
                    2usize , concat ! (
                    "Alignment of " , stringify ! ( nsIPresShell_PointerInfo )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell_PointerInfo ) ) .
                    mPointerType as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsIPresShell_PointerInfo ) , "::" , stringify ! (
                    mPointerType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell_PointerInfo ) ) .
                    mActiveState as * const _ as usize } , 2usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsIPresShell_PointerInfo ) , "::" , stringify ! (
                    mActiveState ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell_PointerInfo ) ) .
                    mPrimaryState as * const _ as usize } , 3usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsIPresShell_PointerInfo ) , "::" , stringify ! (
                    mPrimaryState ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell_PointerInfo ) ) .
                    mPreventMouseEventByContent as * const _ as usize } ,
                    4usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsIPresShell_PointerInfo ) , "::" , stringify ! (
                    mPreventMouseEventByContent ) ));
    }
    impl Clone for nsIPresShell_PointerInfo {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_PaintFlags {
        PAINT_LAYERS = 1,
        PAINT_COMPOSITE = 2,
        PAINT_SYNC_DECODE_IMAGES = 4,
    }
    #[repr(u32)]
    /// Ensures that the refresh driver is running, and schedules a view
    /// manager flush on the next tick.
    ///
    /// @param aType PAINT_DELAYED_COMPRESS : Schedule a paint to be executed after a delay, and
    /// put FrameLayerBuilder in 'compressed' mode that avoids short cut optimizations.
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_PaintType {
        PAINT_DEFAULT = 0,
        PAINT_DELAYED_COMPRESS = 1,
    }
    extern "C" {
        #[link_name = "_ZN12nsIPresShell12gCaptureInfoE"]
        pub static mut nsIPresShell_gCaptureInfo: root::CapturingContentInfo;
    }
    extern "C" {
        #[link_name = "_ZN12nsIPresShell14gKeyDownTargetE"]
        pub static mut nsIPresShell_gKeyDownTarget: *mut root::nsIContent;
    }
    #[test]
    fn bindgen_test_layout_nsIPresShell() {
        assert_eq!(::std::mem::size_of::<nsIPresShell>() , 5456usize , concat
                   ! ( "Size of: " , stringify ! ( nsIPresShell ) ));
        assert_eq! (::std::mem::align_of::<nsIPresShell>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsIPresShell ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mDocument as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mDocument ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mPresContext as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mPresContext ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mStyleSet as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mStyleSet ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mFrameConstructor
                    as * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFrameConstructor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mViewManager as *
                    const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mViewManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mFrameArena as *
                    const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFrameArena ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mSelection as *
                    const _ as usize } , 5240usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mSelection ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mFrameManager as *
                    const _ as usize } , 5248usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFrameManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mForwardingContainer as * const _ as usize } , 5256usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mForwardingContainer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mDocAccessible as
                    * const _ as usize } , 5264usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mDocAccessible ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mReflowContinueTimer as * const _ as usize } , 5272usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mReflowContinueTimer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mDrawEventTargetFrame as * const _ as usize } , 5280usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mDrawEventTargetFrame ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mAllocatedPointers
                    as * const _ as usize } , 5288usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mAllocatedPointers ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mPaintCount as *
                    const _ as usize } , 5336usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mPaintCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mScrollPositionClampingScrollPortSize as * const _ as
                    usize } , 5344usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mScrollPositionClampingScrollPortSize
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mAutoWeakFrames as
                    * const _ as usize } , 5352usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mAutoWeakFrames ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mWeakFrames as *
                    const _ as usize } , 5360usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mWeakFrames ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mCanvasBackgroundColor as * const _ as usize } , 5408usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mCanvasBackgroundColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mResolution as *
                    const _ as usize } , 5412usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mResolution ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mSelectionFlags as
                    * const _ as usize } , 5420usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mSelectionFlags ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mRenderFlags as *
                    const _ as usize } , 5422usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mRenderFlags ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mPresShellId as *
                    const _ as usize } , 5428usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mPresShellId ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mFontSizeInflationEmPerLine as * const _ as usize } ,
                    5432usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFontSizeInflationEmPerLine ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mFontSizeInflationMinTwips as * const _ as usize } ,
                    5436usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFontSizeInflationMinTwips ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mFontSizeInflationLineThreshold as * const _ as usize } ,
                    5440usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFontSizeInflationLineThreshold ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mFontSizeInflationForceEnabled as * const _ as usize } ,
                    5444usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFontSizeInflationForceEnabled ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mFontSizeInflationDisabledInMasterProcess as * const _ as
                    usize } , 5445usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! (
                    mFontSizeInflationDisabledInMasterProcess ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mFontSizeInflationEnabled as * const _ as usize } ,
                    5446usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFontSizeInflationEnabled ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mFontSizeInflationEnabledIsDirty as * const _ as usize } ,
                    5447usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFontSizeInflationEnabledIsDirty )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mPaintingIsFrozen
                    as * const _ as usize } , 5448usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mPaintingIsFrozen ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mIsNeverPainting
                    as * const _ as usize } , 5449usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mIsNeverPainting ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mInFlush as *
                    const _ as usize } , 5450usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mInFlush ) ));
    }
    impl nsIPresShell {
        #[inline]
        pub fn mDidInitialize(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 1u64 as u16;
            let val = (unit_field_val & mask) >> 0usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mDidInitialize(&mut self, val: bool) {
            let mask = 1u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 0usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mIsDestroying(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 2u64 as u16;
            let val = (unit_field_val & mask) >> 1usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsDestroying(&mut self, val: bool) {
            let mask = 2u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 1usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mIsReflowing(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 4u64 as u16;
            let val = (unit_field_val & mask) >> 2usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsReflowing(&mut self, val: bool) {
            let mask = 4u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 2usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mPaintingSuppressed(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 8u64 as u16;
            let val = (unit_field_val & mask) >> 3usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mPaintingSuppressed(&mut self, val: bool) {
            let mask = 8u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 3usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mIsActive(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 16u64 as u16;
            let val = (unit_field_val & mask) >> 4usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsActive(&mut self, val: bool) {
            let mask = 16u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 4usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mFrozen(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 32u64 as u16;
            let val = (unit_field_val & mask) >> 5usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mFrozen(&mut self, val: bool) {
            let mask = 32u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 5usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mIsFirstPaint(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 64u64 as u16;
            let val = (unit_field_val & mask) >> 6usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsFirstPaint(&mut self, val: bool) {
            let mask = 64u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 6usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mObservesMutationsForPrint(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 128u64 as u16;
            let val = (unit_field_val & mask) >> 7usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mObservesMutationsForPrint(&mut self, val: bool) {
            let mask = 128u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 7usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mSuppressInterruptibleReflows(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 256u64 as u16;
            let val = (unit_field_val & mask) >> 8usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mSuppressInterruptibleReflows(&mut self, val: bool) {
            let mask = 256u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 8usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mScrollPositionClampingScrollPortSizeSet(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 512u64 as u16;
            let val = (unit_field_val & mask) >> 9usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mScrollPositionClampingScrollPortSizeSet(&mut self,
                                                            val: bool) {
            let mask = 512u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 9usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mNeedLayoutFlush(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 1024u64 as u16;
            let val = (unit_field_val & mask) >> 10usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mNeedLayoutFlush(&mut self, val: bool) {
            let mask = 1024u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 10usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mNeedStyleFlush(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 2048u64 as u16;
            let val = (unit_field_val & mask) >> 11usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mNeedStyleFlush(&mut self, val: bool) {
            let mask = 2048u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 11usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mObservingStyleFlushes(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 4096u64 as u16;
            let val = (unit_field_val & mask) >> 12usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mObservingStyleFlushes(&mut self, val: bool) {
            let mask = 4096u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 12usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mObservingLayoutFlushes(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 8192u64 as u16;
            let val = (unit_field_val & mask) >> 13usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mObservingLayoutFlushes(&mut self, val: bool) {
            let mask = 8192u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 13usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn mNeedThrottledAnimationFlush(&self) -> bool {
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            let mask = 16384u64 as u16;
            let val = (unit_field_val & mask) >> 14usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mNeedThrottledAnimationFlush(&mut self, val: bool) {
            let mask = 16384u64 as u16;
            let val = val as u8 as u16;
            let mut unit_field_val: u16 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u16 as *mut u8,
                                                ::std::mem::size_of::<u16>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 14usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u16>());
            }
        }
        #[inline]
        pub fn new_bitfield_1(mDidInitialize: bool, mIsDestroying: bool,
                              mIsReflowing: bool, mPaintingSuppressed: bool,
                              mIsActive: bool, mFrozen: bool,
                              mIsFirstPaint: bool,
                              mObservesMutationsForPrint: bool,
                              mSuppressInterruptibleReflows: bool,
                              mScrollPositionClampingScrollPortSizeSet: bool,
                              mNeedLayoutFlush: bool, mNeedStyleFlush: bool,
                              mObservingStyleFlushes: bool,
                              mObservingLayoutFlushes: bool,
                              mNeedThrottledAnimationFlush: bool) -> u16 {
            ({
                 ({
                      ({
                           ({
                                ({
                                     ({
                                          ({
                                               ({
                                                    ({
                                                         ({
                                                              ({
                                                                   ({
                                                                        ({
                                                                             ({
                                                                                  ({
                                                                                       0
                                                                                   }
                                                                                       |
                                                                                       ((mDidInitialize
                                                                                             as
                                                                                             u8
                                                                                             as
                                                                                             u16)
                                                                                            <<
                                                                                            0usize)
                                                                                           &
                                                                                           (1u64
                                                                                                as
                                                                                                u16))
                                                                              }
                                                                                  |
                                                                                  ((mIsDestroying
                                                                                        as
                                                                                        u8
                                                                                        as
                                                                                        u16)
                                                                                       <<
                                                                                       1usize)
                                                                                      &
                                                                                      (2u64
                                                                                           as
                                                                                           u16))
                                                                         } |
                                                                             ((mIsReflowing
                                                                                   as
                                                                                   u8
                                                                                   as
                                                                                   u16)
                                                                                  <<
                                                                                  2usize)
                                                                                 &
                                                                                 (4u64
                                                                                      as
                                                                                      u16))
                                                                    } |
                                                                        ((mPaintingSuppressed
                                                                              as
                                                                              u8
                                                                              as
                                                                              u16)
                                                                             <<
                                                                             3usize)
                                                                            &
                                                                            (8u64
                                                                                 as
                                                                                 u16))
                                                               } |
                                                                   ((mIsActive
                                                                         as u8
                                                                         as
                                                                         u16)
                                                                        <<
                                                                        4usize)
                                                                       &
                                                                       (16u64
                                                                            as
                                                                            u16))
                                                          } |
                                                              ((mFrozen as u8
                                                                    as u16) <<
                                                                   5usize) &
                                                                  (32u64 as
                                                                       u16))
                                                     } |
                                                         ((mIsFirstPaint as u8
                                                               as u16) <<
                                                              6usize) &
                                                             (64u64 as u16))
                                                } |
                                                    ((mObservesMutationsForPrint
                                                          as u8 as u16) <<
                                                         7usize) &
                                                        (128u64 as u16))
                                           } |
                                               ((mSuppressInterruptibleReflows
                                                     as u8 as u16) << 8usize)
                                                   & (256u64 as u16))
                                      } |
                                          ((mScrollPositionClampingScrollPortSizeSet
                                                as u8 as u16) << 9usize) &
                                              (512u64 as u16))
                                 } |
                                     ((mNeedLayoutFlush as u8 as u16) <<
                                          10usize) & (1024u64 as u16))
                            } |
                                ((mNeedStyleFlush as u8 as u16) << 11usize) &
                                    (2048u64 as u16))
                       } |
                           ((mObservingStyleFlushes as u8 as u16) << 12usize)
                               & (4096u64 as u16))
                  } |
                      ((mObservingLayoutFlushes as u8 as u16) << 13usize) &
                          (8192u64 as u16))
             } |
                 ((mNeedThrottledAnimationFlush as u8 as u16) << 14usize) &
                     (16384u64 as u16))
        }
    }
    /// A class that implements nsIWeakReference
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsNodeWeakReference {
        pub _base: root::nsIWeakReference,
        pub mRefCnt: root::nsAutoRefCnt,
        pub _mOwningThread: root::nsAutoOwningThread,
    }
    pub type nsNodeWeakReference_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsNodeWeakReference() {
        assert_eq!(::std::mem::size_of::<nsNodeWeakReference>() , 40usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsNodeWeakReference ) ));
        assert_eq! (::std::mem::align_of::<nsNodeWeakReference>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsNodeWeakReference ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeWeakReference ) ) . mRefCnt as
                    * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeWeakReference
                    ) , "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeWeakReference ) ) .
                    _mOwningThread as * const _ as usize } , 32usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsNodeWeakReference
                    ) , "::" , stringify ! ( _mOwningThread ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDOMMutationObserver {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsRange {
        _unused: [u8; 0],
    }
    pub const NODE_HAS_LISTENERMANAGER: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_HAS_LISTENERMANAGER;
    pub const NODE_HAS_PROPERTIES: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_HAS_PROPERTIES;
    pub const NODE_IS_ANONYMOUS_ROOT: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_IS_ANONYMOUS_ROOT;
    pub const NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE;
    pub const NODE_IS_NATIVE_ANONYMOUS_ROOT: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_IS_NATIVE_ANONYMOUS_ROOT;
    pub const NODE_FORCE_XBL_BINDINGS: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_FORCE_XBL_BINDINGS;
    pub const NODE_MAY_BE_IN_BINDING_MNGR: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_MAY_BE_IN_BINDING_MNGR;
    pub const NODE_IS_EDITABLE: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_IS_EDITABLE;
    pub const NODE_IS_NATIVE_ANONYMOUS: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_IS_NATIVE_ANONYMOUS;
    pub const NODE_IS_IN_SHADOW_TREE: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_IS_IN_SHADOW_TREE;
    pub const NODE_HAS_EMPTY_SELECTOR: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_HAS_EMPTY_SELECTOR;
    pub const NODE_HAS_SLOW_SELECTOR: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_HAS_SLOW_SELECTOR;
    pub const NODE_HAS_EDGE_CHILD_SELECTOR: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_HAS_EDGE_CHILD_SELECTOR;
    pub const NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS;
    pub const NODE_ALL_SELECTOR_FLAGS: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_ALL_SELECTOR_FLAGS;
    pub const NODE_NEEDS_FRAME: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_NEEDS_FRAME;
    pub const NODE_DESCENDANTS_NEED_FRAMES: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_DESCENDANTS_NEED_FRAMES;
    pub const NODE_HAS_ACCESSKEY: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_HAS_ACCESSKEY;
    pub const NODE_HAS_DIRECTION_RTL: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_HAS_DIRECTION_RTL;
    pub const NODE_HAS_DIRECTION_LTR: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_HAS_DIRECTION_LTR;
    pub const NODE_ALL_DIRECTION_FLAGS: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_ALL_DIRECTION_FLAGS;
    pub const NODE_CHROME_ONLY_ACCESS: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_CHROME_ONLY_ACCESS;
    pub const NODE_IS_ROOT_OF_CHROME_ONLY_ACCESS: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_IS_ROOT_OF_CHROME_ONLY_ACCESS;
    pub const NODE_TYPE_SPECIFIC_BITS_OFFSET: root::_bindgen_ty_18 =
        _bindgen_ty_18::NODE_TYPE_SPECIFIC_BITS_OFFSET;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum _bindgen_ty_18 {
        NODE_HAS_LISTENERMANAGER = 4,
        NODE_HAS_PROPERTIES = 8,
        NODE_IS_ANONYMOUS_ROOT = 16,
        NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE = 32,
        NODE_IS_NATIVE_ANONYMOUS_ROOT = 64,
        NODE_FORCE_XBL_BINDINGS = 128,
        NODE_MAY_BE_IN_BINDING_MNGR = 256,
        NODE_IS_EDITABLE = 512,
        NODE_IS_NATIVE_ANONYMOUS = 1024,
        NODE_IS_IN_SHADOW_TREE = 2048,
        NODE_HAS_EMPTY_SELECTOR = 4096,
        NODE_HAS_SLOW_SELECTOR = 8192,
        NODE_HAS_EDGE_CHILD_SELECTOR = 16384,
        NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS = 32768,
        NODE_ALL_SELECTOR_FLAGS = 61440,
        NODE_NEEDS_FRAME = 65536,
        NODE_DESCENDANTS_NEED_FRAMES = 131072,
        NODE_HAS_ACCESSKEY = 262144,
        NODE_HAS_DIRECTION_RTL = 524288,
        NODE_HAS_DIRECTION_LTR = 1048576,
        NODE_ALL_DIRECTION_FLAGS = 1572864,
        NODE_CHROME_ONLY_ACCESS = 2097152,
        NODE_IS_ROOT_OF_CHROME_ONLY_ACCESS = 4194304,
        NODE_TYPE_SPECIFIC_BITS_OFFSET = 21,
    }
    /// Class used to detect unexpected mutations. To use the class create an
    /// nsMutationGuard on the stack before unexpected mutations could occur.
    /// You can then at any time call Mutated to check if any unexpected mutations
    /// have occurred.
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsMutationGuard {
        pub mStartingGeneration: u64,
    }
    extern "C" {
        #[link_name = "_ZN15nsMutationGuard11sGenerationE"]
        pub static mut nsMutationGuard_sGeneration: u64;
    }
    #[test]
    fn bindgen_test_layout_nsMutationGuard() {
        assert_eq!(::std::mem::size_of::<nsMutationGuard>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsMutationGuard ) ));
        assert_eq! (::std::mem::align_of::<nsMutationGuard>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsMutationGuard ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMutationGuard ) ) .
                    mStartingGeneration as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsMutationGuard ) ,
                    "::" , stringify ! ( mStartingGeneration ) ));
    }
    impl Clone for nsMutationGuard {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsXBLBinding {
        pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
        pub _mOwningThread: root::nsAutoOwningThread,
        pub mMarkedForDeath: bool,
        pub mUsingContentXBLScope: bool,
        pub mIsShadowRootBinding: bool,
        pub mPrototypeBinding: *mut root::nsXBLPrototypeBinding,
        pub mContent: root::nsCOMPtr<root::nsIContent>,
        pub mNextBinding: root::RefPtr<root::nsXBLBinding>,
        pub mBoundElement: *mut root::nsIContent,
        pub mDefaultInsertionPoint: root::RefPtr<root::mozilla::dom::XBLChildrenElement>,
        pub mInsertionPoints: root::nsTArray<root::RefPtr<root::mozilla::dom::XBLChildrenElement>>,
        pub mAnonymousContentList: root::RefPtr<root::nsAnonymousContentList>,
    }
    pub type nsXBLBinding_HasThreadSafeRefCnt = root::mozilla::FalseType;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsXBLBinding_cycleCollection {
        pub _base: root::nsCycleCollectionParticipant,
    }
    #[test]
    fn bindgen_test_layout_nsXBLBinding_cycleCollection() {
        assert_eq!(::std::mem::size_of::<nsXBLBinding_cycleCollection>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( nsXBLBinding_cycleCollection )
                   ));
        assert_eq! (::std::mem::align_of::<nsXBLBinding_cycleCollection>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsXBLBinding_cycleCollection ) ));
    }
    impl Clone for nsXBLBinding_cycleCollection {
        fn clone(&self) -> Self { *self }
    }
    extern "C" {
        #[link_name = "_ZN12nsXBLBinding21_cycleCollectorGlobalE"]
        pub static mut nsXBLBinding__cycleCollectorGlobal:
                   root::nsXBLBinding_cycleCollection;
    }
    #[test]
    fn bindgen_test_layout_nsXBLBinding() {
        assert_eq!(::std::mem::size_of::<nsXBLBinding>() , 80usize , concat !
                   ( "Size of: " , stringify ! ( nsXBLBinding ) ));
        assert_eq! (::std::mem::align_of::<nsXBLBinding>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsXBLBinding ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) . mRefCnt as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) . _mOwningThread as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( _mOwningThread ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) . mMarkedForDeath as
                    * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( mMarkedForDeath ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) .
                    mUsingContentXBLScope as * const _ as usize } , 17usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( mUsingContentXBLScope ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) .
                    mIsShadowRootBinding as * const _ as usize } , 18usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( mIsShadowRootBinding ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) . mPrototypeBinding
                    as * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( mPrototypeBinding ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) . mContent as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( mContent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) . mNextBinding as *
                    const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( mNextBinding ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) . mBoundElement as *
                    const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( mBoundElement ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) .
                    mDefaultInsertionPoint as * const _ as usize } , 56usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( mDefaultInsertionPoint ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) . mInsertionPoints
                    as * const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( mInsertionPoints ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsXBLBinding ) ) .
                    mAnonymousContentList as * const _ as usize } , 72usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsXBLBinding ) ,
                    "::" , stringify ! ( mAnonymousContentList ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsFrameManagerBase {
        pub mPresShell: *mut root::nsIPresShell,
        pub mRootFrame: *mut root::nsIFrame,
        pub mDisplayNoneMap: *mut root::nsFrameManagerBase_UndisplayedMap,
        pub mDisplayContentsMap: *mut root::nsFrameManagerBase_UndisplayedMap,
        pub mIsDestroyingFrames: bool,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsFrameManagerBase_UndisplayedMap {
        _unused: [u8; 0],
    }
    #[test]
    fn bindgen_test_layout_nsFrameManagerBase() {
        assert_eq!(::std::mem::size_of::<nsFrameManagerBase>() , 40usize ,
                   concat ! ( "Size of: " , stringify ! ( nsFrameManagerBase )
                   ));
        assert_eq! (::std::mem::align_of::<nsFrameManagerBase>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsFrameManagerBase ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFrameManagerBase ) ) . mPresShell
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFrameManagerBase
                    ) , "::" , stringify ! ( mPresShell ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFrameManagerBase ) ) . mRootFrame
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFrameManagerBase
                    ) , "::" , stringify ! ( mRootFrame ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFrameManagerBase ) ) .
                    mDisplayNoneMap as * const _ as usize } , 16usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsFrameManagerBase
                    ) , "::" , stringify ! ( mDisplayNoneMap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFrameManagerBase ) ) .
                    mDisplayContentsMap as * const _ as usize } , 24usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsFrameManagerBase
                    ) , "::" , stringify ! ( mDisplayContentsMap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFrameManagerBase ) ) .
                    mIsDestroyingFrames as * const _ as usize } , 32usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsFrameManagerBase
                    ) , "::" , stringify ! ( mIsDestroyingFrames ) ));
    }
    impl Clone for nsFrameManagerBase {
        fn clone(&self) -> Self { *self }
    }
    pub type nsWeakPtr = root::nsCOMPtr<root::nsIWeakReference>;
    /// templated hashtable class maps keys to reference pointers.
    /// See nsBaseHashtable for complete declaration.
    /// @param KeyClass a wrapper-class for the hashtable key, see nsHashKeys.h
    /// for a complete specification.
    /// @param PtrType the reference-type being wrapped
    /// @see nsDataHashtable, nsClassHashtable
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsRefPtrHashtable {
    }
    pub type nsRefPtrHashtable_KeyType = [u8; 0usize];
    pub type nsRefPtrHashtable_UserDataType<PtrType> = *mut PtrType;
    pub type nsRefPtrHashtable_base_type = u8;
    /// templated hashtable class maps keys to C++ object pointers.
    /// See nsBaseHashtable for complete declaration.
    /// @param KeyClass a wrapper-class for the hashtable key, see nsHashKeys.h
    /// for a complete specification.
    /// @param Class the class-type being wrapped
    /// @see nsInterfaceHashtable, nsClassHashtable
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsClassHashtable {
    }
    pub type nsClassHashtable_KeyType = [u8; 0usize];
    pub type nsClassHashtable_UserDataType<T> = *mut T;
    pub type nsClassHashtable_base_type = u8;
    #[repr(C)]
    pub struct nsPresArena {
        pub mFreeLists: [root::nsPresArena_FreeList; 213usize],
        pub mPool: [u64; 4usize],
        pub mArenaRefPtrs: [u64; 6usize],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPresArena_FreeList {
        pub mEntries: root::nsTArray<*mut ::std::os::raw::c_void>,
        pub mEntrySize: usize,
        pub mEntriesEverAllocated: usize,
    }
    #[test]
    fn bindgen_test_layout_nsPresArena_FreeList() {
        assert_eq!(::std::mem::size_of::<nsPresArena_FreeList>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsPresArena_FreeList ) ));
        assert_eq! (::std::mem::align_of::<nsPresArena_FreeList>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsPresArena_FreeList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresArena_FreeList ) ) . mEntries
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresArena_FreeList ) , "::" , stringify ! ( mEntries )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresArena_FreeList ) ) . mEntrySize
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresArena_FreeList ) , "::" , stringify ! ( mEntrySize )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresArena_FreeList ) ) .
                    mEntriesEverAllocated as * const _ as usize } , 16usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresArena_FreeList ) , "::" , stringify ! (
                    mEntriesEverAllocated ) ));
    }
    #[test]
    fn bindgen_test_layout_nsPresArena() {
        assert_eq!(::std::mem::size_of::<nsPresArena>() , 5192usize , concat !
                   ( "Size of: " , stringify ! ( nsPresArena ) ));
        assert_eq! (::std::mem::align_of::<nsPresArena>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsPresArena ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresArena ) ) . mFreeLists as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresArena ) ,
                    "::" , stringify ! ( mFreeLists ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresArena ) ) . mPool as * const _
                    as usize } , 5112usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresArena ) ,
                    "::" , stringify ! ( mPool ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresArena ) ) . mArenaRefPtrs as *
                    const _ as usize } , 5144usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresArena ) ,
                    "::" , stringify ! ( mArenaRefPtrs ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct imgIRequest {
        pub _base: root::nsIRequest,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct imgIRequest_COMTypeInfo {
        pub _address: u8,
    }
    pub const imgIRequest_STATUS_NONE: root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_NONE;
    pub const imgIRequest_STATUS_SIZE_AVAILABLE:
              root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_SIZE_AVAILABLE;
    pub const imgIRequest_STATUS_LOAD_COMPLETE:
              root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_LOAD_COMPLETE;
    pub const imgIRequest_STATUS_ERROR: root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_ERROR;
    pub const imgIRequest_STATUS_FRAME_COMPLETE:
              root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_FRAME_COMPLETE;
    pub const imgIRequest_STATUS_DECODE_COMPLETE:
              root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_DECODE_COMPLETE;
    pub const imgIRequest_STATUS_IS_ANIMATED: root::imgIRequest__bindgen_ty_1
              =
        imgIRequest__bindgen_ty_1::STATUS_IS_ANIMATED;
    pub const imgIRequest_STATUS_HAS_TRANSPARENCY:
              root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_HAS_TRANSPARENCY;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum imgIRequest__bindgen_ty_1 {
        STATUS_NONE = 0,
        STATUS_SIZE_AVAILABLE = 1,
        STATUS_LOAD_COMPLETE = 2,
        STATUS_ERROR = 4,
        STATUS_FRAME_COMPLETE = 8,
        STATUS_DECODE_COMPLETE = 16,
        STATUS_IS_ANIMATED = 32,
        STATUS_HAS_TRANSPARENCY = 64,
    }
    pub const imgIRequest_CORS_NONE: root::imgIRequest__bindgen_ty_2 =
        imgIRequest__bindgen_ty_2::CORS_NONE;
    pub const imgIRequest_CORS_ANONYMOUS: root::imgIRequest__bindgen_ty_2 =
        imgIRequest__bindgen_ty_2::CORS_ANONYMOUS;
    pub const imgIRequest_CORS_USE_CREDENTIALS:
              root::imgIRequest__bindgen_ty_2 =
        imgIRequest__bindgen_ty_2::CORS_USE_CREDENTIALS;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum imgIRequest__bindgen_ty_2 {
        CORS_NONE = 1,
        CORS_ANONYMOUS = 2,
        CORS_USE_CREDENTIALS = 3,
    }
    pub const imgIRequest_CATEGORY_FRAME_INIT: root::imgIRequest__bindgen_ty_3
              =
        imgIRequest__bindgen_ty_3::CATEGORY_FRAME_INIT;
    pub const imgIRequest_CATEGORY_SIZE_QUERY: root::imgIRequest__bindgen_ty_3
              =
        imgIRequest__bindgen_ty_3::CATEGORY_SIZE_QUERY;
    pub const imgIRequest_CATEGORY_DISPLAY: root::imgIRequest__bindgen_ty_3 =
        imgIRequest__bindgen_ty_3::CATEGORY_DISPLAY;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum imgIRequest__bindgen_ty_3 {
        CATEGORY_FRAME_INIT = 1,
        CATEGORY_SIZE_QUERY = 2,
        CATEGORY_DISPLAY = 4,
    }
    #[test]
    fn bindgen_test_layout_imgIRequest() {
        assert_eq!(::std::mem::size_of::<imgIRequest>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( imgIRequest ) ));
        assert_eq! (::std::mem::align_of::<imgIRequest>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( imgIRequest ) ));
    }
    impl Clone for imgIRequest {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct imgINotificationObserver {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct imgINotificationObserver_COMTypeInfo {
        pub _address: u8,
    }
    pub const imgINotificationObserver_SIZE_AVAILABLE:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::SIZE_AVAILABLE;
    pub const imgINotificationObserver_FRAME_UPDATE:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::FRAME_UPDATE;
    pub const imgINotificationObserver_FRAME_COMPLETE:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::FRAME_COMPLETE;
    pub const imgINotificationObserver_LOAD_COMPLETE:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::LOAD_COMPLETE;
    pub const imgINotificationObserver_DECODE_COMPLETE:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::DECODE_COMPLETE;
    pub const imgINotificationObserver_DISCARD:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::DISCARD;
    pub const imgINotificationObserver_UNLOCKED_DRAW:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::UNLOCKED_DRAW;
    pub const imgINotificationObserver_IS_ANIMATED:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::IS_ANIMATED;
    pub const imgINotificationObserver_HAS_TRANSPARENCY:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::HAS_TRANSPARENCY;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum imgINotificationObserver__bindgen_ty_1 {
        SIZE_AVAILABLE = 1,
        FRAME_UPDATE = 2,
        FRAME_COMPLETE = 3,
        LOAD_COMPLETE = 4,
        DECODE_COMPLETE = 5,
        DISCARD = 6,
        UNLOCKED_DRAW = 7,
        IS_ANIMATED = 8,
        HAS_TRANSPARENCY = 9,
    }
    #[test]
    fn bindgen_test_layout_imgINotificationObserver() {
        assert_eq!(::std::mem::size_of::<imgINotificationObserver>() , 8usize
                   , concat ! (
                   "Size of: " , stringify ! ( imgINotificationObserver ) ));
        assert_eq! (::std::mem::align_of::<imgINotificationObserver>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( imgINotificationObserver )
                    ));
    }
    impl Clone for imgINotificationObserver {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDocShell {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsViewManager {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsFrameSelection {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsCSSFrameConstructor {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AutoWeakFrame {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct WeakFrame {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsRefreshDriver {
        _unused: [u8; 0],
    }
    /// The signature of the timer callback function passed to initWithFuncCallback.
    /// This is the function that will get called when the timer expires if the
    /// timer is initialized via initWithFuncCallback.
    ///
    /// @param aTimer the timer which has expired
    /// @param aClosure opaque parameter passed to initWithFuncCallback
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsITimer {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsITimer_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsITimer_TYPE_ONE_SHOT: root::nsITimer__bindgen_ty_1 =
        nsITimer__bindgen_ty_1::TYPE_ONE_SHOT;
    pub const nsITimer_TYPE_REPEATING_SLACK: root::nsITimer__bindgen_ty_1 =
        nsITimer__bindgen_ty_1::TYPE_REPEATING_SLACK;
    pub const nsITimer_TYPE_REPEATING_PRECISE: root::nsITimer__bindgen_ty_1 =
        nsITimer__bindgen_ty_1::TYPE_REPEATING_PRECISE;
    pub const nsITimer_TYPE_REPEATING_PRECISE_CAN_SKIP:
              root::nsITimer__bindgen_ty_1 =
        nsITimer__bindgen_ty_1::TYPE_REPEATING_PRECISE_CAN_SKIP;
    pub const nsITimer_TYPE_REPEATING_SLACK_LOW_PRIORITY:
              root::nsITimer__bindgen_ty_1 =
        nsITimer__bindgen_ty_1::TYPE_REPEATING_SLACK_LOW_PRIORITY;
    pub const nsITimer_TYPE_ONE_SHOT_LOW_PRIORITY:
              root::nsITimer__bindgen_ty_1 =
        nsITimer__bindgen_ty_1::TYPE_ONE_SHOT_LOW_PRIORITY;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsITimer__bindgen_ty_1 {
        TYPE_ONE_SHOT = 0,
        TYPE_REPEATING_SLACK = 1,
        TYPE_REPEATING_PRECISE = 2,
        TYPE_REPEATING_PRECISE_CAN_SKIP = 3,
        TYPE_REPEATING_SLACK_LOW_PRIORITY = 4,
        TYPE_ONE_SHOT_LOW_PRIORITY = 5,
    }
    #[test]
    fn bindgen_test_layout_nsITimer() {
        assert_eq!(::std::mem::size_of::<nsITimer>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsITimer ) ));
        assert_eq! (::std::mem::align_of::<nsITimer>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsITimer ) ));
    }
    impl Clone for nsITimer {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct CapturingContentInfo {
        pub mAllowed: bool,
        pub mPointerLock: bool,
        pub mRetargetToElement: bool,
        pub mPreventDrag: bool,
        pub mContent: root::mozilla::StaticRefPtr<root::nsIContent>,
    }
    #[test]
    fn bindgen_test_layout_CapturingContentInfo() {
        assert_eq!(::std::mem::size_of::<CapturingContentInfo>() , 16usize ,
                   concat ! (
                   "Size of: " , stringify ! ( CapturingContentInfo ) ));
        assert_eq! (::std::mem::align_of::<CapturingContentInfo>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( CapturingContentInfo ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CapturingContentInfo ) ) . mAllowed
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CapturingContentInfo ) , "::" , stringify ! ( mAllowed )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CapturingContentInfo ) ) .
                    mPointerLock as * const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CapturingContentInfo ) , "::" , stringify ! ( mPointerLock
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CapturingContentInfo ) ) .
                    mRetargetToElement as * const _ as usize } , 2usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    CapturingContentInfo ) , "::" , stringify ! (
                    mRetargetToElement ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CapturingContentInfo ) ) .
                    mPreventDrag as * const _ as usize } , 3usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CapturingContentInfo ) , "::" , stringify ! ( mPreventDrag
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CapturingContentInfo ) ) . mContent
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CapturingContentInfo ) , "::" , stringify ! ( mContent )
                    ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIObserver {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIObserver_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIObserver() {
        assert_eq!(::std::mem::size_of::<nsIObserver>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIObserver ) ));
        assert_eq! (::std::mem::align_of::<nsIObserver>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsIObserver ) ));
    }
    impl Clone for nsIObserver {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIEventTarget {
        pub _base: root::nsISupports,
        pub mVirtualThread: *mut root::PRThread,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIEventTarget_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsIEventTarget_DISPATCH_NORMAL:
              root::nsIEventTarget__bindgen_ty_1 =
        nsIEventTarget__bindgen_ty_1::DISPATCH_NORMAL;
    pub const nsIEventTarget_DISPATCH_SYNC: root::nsIEventTarget__bindgen_ty_1
              =
        nsIEventTarget__bindgen_ty_1::DISPATCH_SYNC;
    pub const nsIEventTarget_DISPATCH_AT_END:
              root::nsIEventTarget__bindgen_ty_1 =
        nsIEventTarget__bindgen_ty_1::DISPATCH_AT_END;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIEventTarget__bindgen_ty_1 {
        DISPATCH_NORMAL = 0,
        DISPATCH_SYNC = 1,
        DISPATCH_AT_END = 2,
    }
    #[test]
    fn bindgen_test_layout_nsIEventTarget() {
        assert_eq!(::std::mem::size_of::<nsIEventTarget>() , 16usize , concat
                   ! ( "Size of: " , stringify ! ( nsIEventTarget ) ));
        assert_eq! (::std::mem::align_of::<nsIEventTarget>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsIEventTarget ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIEventTarget ) ) . mVirtualThread
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIEventTarget ) ,
                    "::" , stringify ! ( mVirtualThread ) ));
    }
    impl Clone for nsIEventTarget {
        fn clone(&self) -> Self { *self }
    }
    /// templated hashtable class maps keys to interface pointers.
    /// See nsBaseHashtable for complete declaration.
    /// @param KeyClass a wrapper-class for the hashtable key, see nsHashKeys.h
    /// for a complete specification.
    /// @param Interface the interface-type being wrapped
    /// @see nsDataHashtable, nsClassHashtable
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsInterfaceHashtable {
    }
    pub type nsInterfaceHashtable_KeyType = [u8; 0usize];
    pub type nsInterfaceHashtable_UserDataType<Interface> = *mut Interface;
    pub type nsInterfaceHashtable_base_type = u8;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsLanguageAtomService {
        pub mLangToGroup: [u64; 6usize],
        pub mLocaleLanguage: root::nsCOMPtr<root::nsIAtom>,
    }
    pub type nsLanguageAtomService_Encoding = root::mozilla::Encoding;
    pub type nsLanguageAtomService_NotNull<T> = root::mozilla::NotNull<T>;
    #[test]
    fn bindgen_test_layout_nsLanguageAtomService() {
        assert_eq!(::std::mem::size_of::<nsLanguageAtomService>() , 56usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsLanguageAtomService ) ));
        assert_eq! (::std::mem::align_of::<nsLanguageAtomService>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsLanguageAtomService )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsLanguageAtomService ) ) .
                    mLangToGroup as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsLanguageAtomService ) , "::" , stringify ! (
                    mLangToGroup ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsLanguageAtomService ) ) .
                    mLocaleLanguage as * const _ as usize } , 48usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsLanguageAtomService ) , "::" , stringify ! (
                    mLocaleLanguage ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsINamed {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsINamed_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsINamed() {
        assert_eq!(::std::mem::size_of::<nsINamed>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsINamed ) ));
        assert_eq! (::std::mem::align_of::<nsINamed>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsINamed ) ));
    }
    impl Clone for nsINamed {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIRunnable {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIRunnable_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIRunnable() {
        assert_eq!(::std::mem::size_of::<nsIRunnable>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIRunnable ) ));
        assert_eq! (::std::mem::align_of::<nsIRunnable>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsIRunnable ) ));
    }
    impl Clone for nsIRunnable {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIRunnablePriority {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIRunnablePriority_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsIRunnablePriority_PRIORITY_NORMAL:
              root::nsIRunnablePriority__bindgen_ty_1 =
        nsIRunnablePriority__bindgen_ty_1::PRIORITY_NORMAL;
    pub const nsIRunnablePriority_PRIORITY_INPUT:
              root::nsIRunnablePriority__bindgen_ty_1 =
        nsIRunnablePriority__bindgen_ty_1::PRIORITY_INPUT;
    pub const nsIRunnablePriority_PRIORITY_HIGH:
              root::nsIRunnablePriority__bindgen_ty_1 =
        nsIRunnablePriority__bindgen_ty_1::PRIORITY_HIGH;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIRunnablePriority__bindgen_ty_1 {
        PRIORITY_NORMAL = 0,
        PRIORITY_INPUT = 1,
        PRIORITY_HIGH = 2,
    }
    #[test]
    fn bindgen_test_layout_nsIRunnablePriority() {
        assert_eq!(::std::mem::size_of::<nsIRunnablePriority>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIRunnablePriority ) ));
        assert_eq! (::std::mem::align_of::<nsIRunnablePriority>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIRunnablePriority ) ));
    }
    impl Clone for nsIRunnablePriority {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsISerialEventTarget {
        pub _base: root::nsIEventTarget,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISerialEventTarget_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsISerialEventTarget() {
        assert_eq!(::std::mem::size_of::<nsISerialEventTarget>() , 16usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsISerialEventTarget ) ));
        assert_eq! (::std::mem::align_of::<nsISerialEventTarget>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsISerialEventTarget ) ));
    }
    impl Clone for nsISerialEventTarget {
        fn clone(&self) -> Self { *self }
    }
    pub type nsRunnableMethod_BaseType = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsRunnableMethod_ReturnTypeEnforcer {
        pub _address: u8,
    }
    pub type nsRunnableMethod_ReturnTypeEnforcer_ReturnTypeIsSafe =
        ::std::os::raw::c_int;
    pub type nsRunnableMethod_check =
        root::nsRunnableMethod_ReturnTypeEnforcer;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPIDOMWindowInner {
        pub _base: [u64; 32usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsPIDOMWindowInner_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsPIDOMWindowInner() {
        assert_eq!(::std::mem::size_of::<nsPIDOMWindowInner>() , 256usize ,
                   concat ! ( "Size of: " , stringify ! ( nsPIDOMWindowInner )
                   ));
        assert_eq! (::std::mem::align_of::<nsPIDOMWindowInner>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsPIDOMWindowInner ) ));
    }
    /// The global object which keeps a script context for each supported script
    /// language. This often used to store per-window global state.
    /// This is a heavyweight interface implemented only by DOM globals, and
    /// it might go away some time in the future.
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIScriptGlobalObject {
        pub _base: root::nsIGlobalObject,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIScriptGlobalObject_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIScriptGlobalObject() {
        assert_eq!(::std::mem::size_of::<nsIScriptGlobalObject>() , 32usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIScriptGlobalObject ) ));
        assert_eq! (::std::mem::align_of::<nsIScriptGlobalObject>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIScriptGlobalObject )
                    ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIXPConnectJSObjectHolder {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIXPConnectJSObjectHolder_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIXPConnectJSObjectHolder() {
        assert_eq!(::std::mem::size_of::<nsIXPConnectJSObjectHolder>() ,
                   8usize , concat ! (
                   "Size of: " , stringify ! ( nsIXPConnectJSObjectHolder )
                   ));
        assert_eq! (::std::mem::align_of::<nsIXPConnectJSObjectHolder>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIXPConnectJSObjectHolder
                    ) ));
    }
    impl Clone for nsIXPConnectJSObjectHolder {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIXPConnectWrappedJS {
        pub _base: root::nsIXPConnectJSObjectHolder,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIXPConnectWrappedJS_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIXPConnectWrappedJS() {
        assert_eq!(::std::mem::size_of::<nsIXPConnectWrappedJS>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIXPConnectWrappedJS ) ));
        assert_eq! (::std::mem::align_of::<nsIXPConnectWrappedJS>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIXPConnectWrappedJS )
                    ));
    }
    impl Clone for nsIXPConnectWrappedJS {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIControllers {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct mozIDOMWindow {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mozIDOMWindow_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_mozIDOMWindow() {
        assert_eq!(::std::mem::size_of::<mozIDOMWindow>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( mozIDOMWindow ) ));
        assert_eq! (::std::mem::align_of::<mozIDOMWindow>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( mozIDOMWindow ) ));
    }
    impl Clone for mozIDOMWindow {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsICSSDeclaration {
        pub _base: root::nsIDOMCSSStyleDeclaration,
        pub _base_1: root::nsWrapperCache,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsICSSDeclaration_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsICSSDeclaration() {
        assert_eq!(::std::mem::size_of::<nsICSSDeclaration>() , 32usize ,
                   concat ! ( "Size of: " , stringify ! ( nsICSSDeclaration )
                   ));
        assert_eq! (::std::mem::align_of::<nsICSSDeclaration>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsICSSDeclaration ) ));
    }
    #[repr(C)]
    pub struct nsPIDOMWindow__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsPIDOMWindow {
    }
    pub type nsPIDOMWindow_ServiceWorkerRegistrationTable = [u64; 6usize];
    pub mod xpc {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug)]
        pub struct ErrorBase {
            pub mErrorMsg: ::nsstring::nsStringRepr,
            pub mFileName: ::nsstring::nsStringRepr,
            pub mLineNumber: u32,
            pub mColumn: u32,
        }
        #[test]
        fn bindgen_test_layout_ErrorBase() {
            assert_eq!(::std::mem::size_of::<ErrorBase>() , 40usize , concat !
                       ( "Size of: " , stringify ! ( ErrorBase ) ));
            assert_eq! (::std::mem::align_of::<ErrorBase>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( ErrorBase ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ErrorBase ) ) . mErrorMsg as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( ErrorBase ) ,
                        "::" , stringify ! ( mErrorMsg ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ErrorBase ) ) . mFileName as *
                        const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! ( ErrorBase ) ,
                        "::" , stringify ! ( mFileName ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ErrorBase ) ) . mLineNumber as *
                        const _ as usize } , 32usize , concat ! (
                        "Alignment of field: " , stringify ! ( ErrorBase ) ,
                        "::" , stringify ! ( mLineNumber ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ErrorBase ) ) . mColumn as *
                        const _ as usize } , 36usize , concat ! (
                        "Alignment of field: " , stringify ! ( ErrorBase ) ,
                        "::" , stringify ! ( mColumn ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ErrorNote {
            pub _base: root::xpc::ErrorBase,
        }
        #[test]
        fn bindgen_test_layout_ErrorNote() {
            assert_eq!(::std::mem::size_of::<ErrorNote>() , 40usize , concat !
                       ( "Size of: " , stringify ! ( ErrorNote ) ));
            assert_eq! (::std::mem::align_of::<ErrorNote>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( ErrorNote ) ));
        }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCompatibility {
        eCompatibility_FullStandards = 1,
        eCompatibility_AlmostStandards = 2,
        eCompatibility_NavQuirks = 3,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIRequestObserver {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIRequestObserver_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIRequestObserver() {
        assert_eq!(::std::mem::size_of::<nsIRequestObserver>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsIRequestObserver )
                   ));
        assert_eq! (::std::mem::align_of::<nsIRequestObserver>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIRequestObserver ) ));
    }
    impl Clone for nsIRequestObserver {
        fn clone(&self) -> Self { *self }
    }
    /// Hashtable key class to use with nsTHashtable/nsBaseHashtable
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsURIHashKey {
        pub _base: root::PLDHashEntryHdr,
        pub mKey: root::nsCOMPtr<root::nsIURI>,
    }
    pub type nsURIHashKey_KeyType = *mut root::nsIURI;
    pub type nsURIHashKey_KeyTypePointer = *const root::nsIURI;
    pub const nsURIHashKey_ALLOW_MEMMOVE: root::nsURIHashKey__bindgen_ty_1 =
        nsURIHashKey__bindgen_ty_1::ALLOW_MEMMOVE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsURIHashKey__bindgen_ty_1 { ALLOW_MEMMOVE = 1, }
    #[test]
    fn bindgen_test_layout_nsURIHashKey() {
        assert_eq!(::std::mem::size_of::<nsURIHashKey>() , 16usize , concat !
                   ( "Size of: " , stringify ! ( nsURIHashKey ) ));
        assert_eq! (::std::mem::align_of::<nsURIHashKey>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsURIHashKey ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsURIHashKey ) ) . mKey as * const _
                    as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsURIHashKey ) ,
                    "::" , stringify ! ( mKey ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsContentList {
        _unused: [u8; 0],
    }
    /// Data used to track the expiration state of an object. We promise that this
    /// is 32 bits so that objects that includes this as a field can pad and align
    /// efficiently.
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsExpirationState {
        pub _bitfield_1: u32,
        pub __bindgen_align: [u32; 0usize],
    }
    pub const nsExpirationState_NOT_TRACKED:
              root::nsExpirationState__bindgen_ty_1 =
        nsExpirationState__bindgen_ty_1::NOT_TRACKED;
    pub const nsExpirationState_MAX_INDEX_IN_GENERATION:
              root::nsExpirationState__bindgen_ty_1 =
        nsExpirationState__bindgen_ty_1::MAX_INDEX_IN_GENERATION;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsExpirationState__bindgen_ty_1 {
        NOT_TRACKED = 15,
        MAX_INDEX_IN_GENERATION = 268435455,
    }
    #[test]
    fn bindgen_test_layout_nsExpirationState() {
        assert_eq!(::std::mem::size_of::<nsExpirationState>() , 4usize ,
                   concat ! ( "Size of: " , stringify ! ( nsExpirationState )
                   ));
        assert_eq! (::std::mem::align_of::<nsExpirationState>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsExpirationState ) ));
    }
    impl Clone for nsExpirationState {
        fn clone(&self) -> Self { *self }
    }
    impl nsExpirationState {
        #[inline]
        pub fn mGeneration(&self) -> u32 {
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            let mask = 15u64 as u32;
            let val = (unit_field_val & mask) >> 0usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mGeneration(&mut self, val: u32) {
            let mask = 15u64 as u32;
            let val = val as u32 as u32;
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 0usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u32>());
            }
        }
        #[inline]
        pub fn mIndexInGeneration(&self) -> u32 {
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            let mask = 4294967280u64 as u32;
            let val = (unit_field_val & mask) >> 4usize;
            unsafe { ::std::mem::transmute(val as u32) }
        }
        #[inline]
        pub fn set_mIndexInGeneration(&mut self, val: u32) {
            let mask = 4294967280u64 as u32;
            let val = val as u32 as u32;
            let mut unit_field_val: u32 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as
                                                    *mut u32 as *mut u8,
                                                ::std::mem::size_of::<u32>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 4usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u32>());
            }
        }
        #[inline]
        pub fn new_bitfield_1(mGeneration: u32, mIndexInGeneration: u32)
         -> u32 {
            ({
                 ({ 0 } |
                      ((mGeneration as u32 as u32) << 0usize) &
                          (15u64 as u32))
             } |
                 ((mIndexInGeneration as u32 as u32) << 4usize) &
                     (4294967280u64 as u32))
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsHTMLCSSStyleSheet {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsHTMLStyleSheet {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIBFCacheEntry {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDocumentEncoder {
        _unused: [u8; 0],
    }
    /// An internal interface
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIHTMLCollection {
        pub _base: root::nsIDOMHTMLCollection,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIHTMLCollection_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIHTMLCollection() {
        assert_eq!(::std::mem::size_of::<nsIHTMLCollection>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsIHTMLCollection )
                   ));
        assert_eq! (::std::mem::align_of::<nsIHTMLCollection>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIHTMLCollection ) ));
    }
    impl Clone for nsIHTMLCollection {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIObjectLoadingContent {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIStructuredCloneContainer {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsSMILAnimationController {
        _unused: [u8; 0],
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum HSTSPrimingState {
        eNO_HSTS_PRIMING = 0,
        eHSTS_PRIMING_ALLOW = 1,
        eHSTS_PRIMING_BLOCK = 2,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ProfilerBacktrace {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ProfilerMarkerPayload {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct ProfilerBacktraceDestructor {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_ProfilerBacktraceDestructor() {
        assert_eq!(::std::mem::size_of::<ProfilerBacktraceDestructor>() ,
                   1usize , concat ! (
                   "Size of: " , stringify ! ( ProfilerBacktraceDestructor )
                   ));
        assert_eq! (::std::mem::align_of::<ProfilerBacktraceDestructor>() ,
                    1usize , concat ! (
                    "Alignment of " , stringify ! (
                    ProfilerBacktraceDestructor ) ));
    }
    impl Clone for ProfilerBacktraceDestructor {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsBidi {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIPrintSettings {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsITheme {
        _unused: [u8; 0],
    }
    /// Interface used for handling clicks on links
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsILinkHandler {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsILinkHandler_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsILinkHandler() {
        assert_eq!(::std::mem::size_of::<nsILinkHandler>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( nsILinkHandler ) ));
        assert_eq! (::std::mem::align_of::<nsILinkHandler>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsILinkHandler ) ));
    }
    impl Clone for nsILinkHandler {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct gfxTextPerfMetrics {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsCSSFontFeatureValuesRule {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsTransitionManager {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsAnimationManager {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDeviceContext {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct gfxMissingFontRecorder {
        _unused: [u8; 0],
    }
    pub const kPresContext_DefaultVariableFont_ID: u8 = 0;
    pub const kPresContext_DefaultFixedFont_ID: u8 = 1;
    #[repr(i16)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSKeyword {
        eCSSKeyword_UNKNOWN = -1,
        eCSSKeyword__moz_activehyperlinktext = 0,
        eCSSKeyword__moz_all = 1,
        eCSSKeyword__moz_alt_content = 2,
        eCSSKeyword__moz_available = 3,
        eCSSKeyword__moz_box = 4,
        eCSSKeyword__moz_button = 5,
        eCSSKeyword__moz_buttondefault = 6,
        eCSSKeyword__moz_buttonhoverface = 7,
        eCSSKeyword__moz_buttonhovertext = 8,
        eCSSKeyword__moz_cellhighlight = 9,
        eCSSKeyword__moz_cellhighlighttext = 10,
        eCSSKeyword__moz_center = 11,
        eCSSKeyword__moz_combobox = 12,
        eCSSKeyword__moz_comboboxtext = 13,
        eCSSKeyword__moz_context_properties = 14,
        eCSSKeyword__moz_block_height = 15,
        eCSSKeyword__moz_deck = 16,
        eCSSKeyword__moz_default_background_color = 17,
        eCSSKeyword__moz_default_color = 18,
        eCSSKeyword__moz_desktop = 19,
        eCSSKeyword__moz_dialog = 20,
        eCSSKeyword__moz_dialogtext = 21,
        eCSSKeyword__moz_document = 22,
        eCSSKeyword__moz_dragtargetzone = 23,
        eCSSKeyword__moz_element = 24,
        eCSSKeyword__moz_eventreerow = 25,
        eCSSKeyword__moz_field = 26,
        eCSSKeyword__moz_fieldtext = 27,
        eCSSKeyword__moz_fit_content = 28,
        eCSSKeyword__moz_fixed = 29,
        eCSSKeyword__moz_grabbing = 30,
        eCSSKeyword__moz_grab = 31,
        eCSSKeyword__moz_grid_group = 32,
        eCSSKeyword__moz_grid_line = 33,
        eCSSKeyword__moz_grid = 34,
        eCSSKeyword__moz_groupbox = 35,
        eCSSKeyword__moz_gtk_info_bar = 36,
        eCSSKeyword__moz_gtk_info_bar_text = 37,
        eCSSKeyword__moz_hidden_unscrollable = 38,
        eCSSKeyword__moz_hyperlinktext = 39,
        eCSSKeyword__moz_html_cellhighlight = 40,
        eCSSKeyword__moz_html_cellhighlighttext = 41,
        eCSSKeyword__moz_image_rect = 42,
        eCSSKeyword__moz_info = 43,
        eCSSKeyword__moz_inline_box = 44,
        eCSSKeyword__moz_inline_grid = 45,
        eCSSKeyword__moz_inline_stack = 46,
        eCSSKeyword__moz_left = 47,
        eCSSKeyword__moz_list = 48,
        eCSSKeyword__moz_mac_buttonactivetext = 49,
        eCSSKeyword__moz_mac_chrome_active = 50,
        eCSSKeyword__moz_mac_chrome_inactive = 51,
        eCSSKeyword__moz_mac_defaultbuttontext = 52,
        eCSSKeyword__moz_mac_focusring = 53,
        eCSSKeyword__moz_mac_fullscreen_button = 54,
        eCSSKeyword__moz_mac_menuselect = 55,
        eCSSKeyword__moz_mac_menushadow = 56,
        eCSSKeyword__moz_mac_menutextdisable = 57,
        eCSSKeyword__moz_mac_menutextselect = 58,
        eCSSKeyword__moz_mac_disabledtoolbartext = 59,
        eCSSKeyword__moz_mac_secondaryhighlight = 60,
        eCSSKeyword__moz_max_content = 61,
        eCSSKeyword__moz_menuhover = 62,
        eCSSKeyword__moz_menuhovertext = 63,
        eCSSKeyword__moz_menubartext = 64,
        eCSSKeyword__moz_menubarhovertext = 65,
        eCSSKeyword__moz_middle_with_baseline = 66,
        eCSSKeyword__moz_min_content = 67,
        eCSSKeyword__moz_nativehyperlinktext = 68,
        eCSSKeyword__moz_none = 69,
        eCSSKeyword__moz_oddtreerow = 70,
        eCSSKeyword__moz_popup = 71,
        eCSSKeyword__moz_pre_space = 72,
        eCSSKeyword__moz_pull_down_menu = 73,
        eCSSKeyword__moz_right = 74,
        eCSSKeyword__moz_scrollbars_horizontal = 75,
        eCSSKeyword__moz_scrollbars_none = 76,
        eCSSKeyword__moz_scrollbars_vertical = 77,
        eCSSKeyword__moz_stack = 78,
        eCSSKeyword__moz_text = 79,
        eCSSKeyword__moz_use_system_font = 80,
        eCSSKeyword__moz_visitedhyperlinktext = 81,
        eCSSKeyword__moz_window = 82,
        eCSSKeyword__moz_workspace = 83,
        eCSSKeyword__moz_zoom_in = 84,
        eCSSKeyword__moz_zoom_out = 85,
        eCSSKeyword__webkit_box = 86,
        eCSSKeyword__webkit_flex = 87,
        eCSSKeyword__webkit_inline_box = 88,
        eCSSKeyword__webkit_inline_flex = 89,
        eCSSKeyword_absolute = 90,
        eCSSKeyword_active = 91,
        eCSSKeyword_activeborder = 92,
        eCSSKeyword_activecaption = 93,
        eCSSKeyword_add = 94,
        eCSSKeyword_additive = 95,
        eCSSKeyword_alias = 96,
        eCSSKeyword_all = 97,
        eCSSKeyword_all_petite_caps = 98,
        eCSSKeyword_all_scroll = 99,
        eCSSKeyword_all_small_caps = 100,
        eCSSKeyword_alpha = 101,
        eCSSKeyword_alternate = 102,
        eCSSKeyword_alternate_reverse = 103,
        eCSSKeyword_always = 104,
        eCSSKeyword_annotation = 105,
        eCSSKeyword_appworkspace = 106,
        eCSSKeyword_auto = 107,
        eCSSKeyword_auto_fill = 108,
        eCSSKeyword_auto_fit = 109,
        eCSSKeyword_auto_flow = 110,
        eCSSKeyword_avoid = 111,
        eCSSKeyword_background = 112,
        eCSSKeyword_backwards = 113,
        eCSSKeyword_balance = 114,
        eCSSKeyword_baseline = 115,
        eCSSKeyword_bidi_override = 116,
        eCSSKeyword_blink = 117,
        eCSSKeyword_block = 118,
        eCSSKeyword_block_axis = 119,
        eCSSKeyword_blur = 120,
        eCSSKeyword_bold = 121,
        eCSSKeyword_bold_fraktur = 122,
        eCSSKeyword_bold_italic = 123,
        eCSSKeyword_bold_sans_serif = 124,
        eCSSKeyword_bold_script = 125,
        eCSSKeyword_bolder = 126,
        eCSSKeyword_border_box = 127,
        eCSSKeyword_both = 128,
        eCSSKeyword_bottom = 129,
        eCSSKeyword_bottom_outside = 130,
        eCSSKeyword_break_all = 131,
        eCSSKeyword_break_word = 132,
        eCSSKeyword_brightness = 133,
        eCSSKeyword_browser = 134,
        eCSSKeyword_bullets = 135,
        eCSSKeyword_button = 136,
        eCSSKeyword_buttonface = 137,
        eCSSKeyword_buttonhighlight = 138,
        eCSSKeyword_buttonshadow = 139,
        eCSSKeyword_buttontext = 140,
        eCSSKeyword_capitalize = 141,
        eCSSKeyword_caption = 142,
        eCSSKeyword_captiontext = 143,
        eCSSKeyword_cell = 144,
        eCSSKeyword_center = 145,
        eCSSKeyword_ch = 146,
        eCSSKeyword_character_variant = 147,
        eCSSKeyword_circle = 148,
        eCSSKeyword_cjk_decimal = 149,
        eCSSKeyword_clip = 150,
        eCSSKeyword_clone = 151,
        eCSSKeyword_close_quote = 152,
        eCSSKeyword_closest_corner = 153,
        eCSSKeyword_closest_side = 154,
        eCSSKeyword_cm = 155,
        eCSSKeyword_col_resize = 156,
        eCSSKeyword_collapse = 157,
        eCSSKeyword_color = 158,
        eCSSKeyword_color_burn = 159,
        eCSSKeyword_color_dodge = 160,
        eCSSKeyword_common_ligatures = 161,
        eCSSKeyword_column = 162,
        eCSSKeyword_column_reverse = 163,
        eCSSKeyword_condensed = 164,
        eCSSKeyword_contain = 165,
        eCSSKeyword_content_box = 166,
        eCSSKeyword_contents = 167,
        eCSSKeyword_context_fill = 168,
        eCSSKeyword_context_fill_opacity = 169,
        eCSSKeyword_context_menu = 170,
        eCSSKeyword_context_stroke = 171,
        eCSSKeyword_context_stroke_opacity = 172,
        eCSSKeyword_context_value = 173,
        eCSSKeyword_continuous = 174,
        eCSSKeyword_contrast = 175,
        eCSSKeyword_copy = 176,
        eCSSKeyword_contextual = 177,
        eCSSKeyword_cover = 178,
        eCSSKeyword_crop = 179,
        eCSSKeyword_cross = 180,
        eCSSKeyword_crosshair = 181,
        eCSSKeyword_currentcolor = 182,
        eCSSKeyword_cursive = 183,
        eCSSKeyword_cyclic = 184,
        eCSSKeyword_darken = 185,
        eCSSKeyword_dashed = 186,
        eCSSKeyword_dense = 187,
        eCSSKeyword_decimal = 188,
        eCSSKeyword_default = 189,
        eCSSKeyword_deg = 190,
        eCSSKeyword_diagonal_fractions = 191,
        eCSSKeyword_dialog = 192,
        eCSSKeyword_difference = 193,
        eCSSKeyword_digits = 194,
        eCSSKeyword_disabled = 195,
        eCSSKeyword_disc = 196,
        eCSSKeyword_discretionary_ligatures = 197,
        eCSSKeyword_distribute = 198,
        eCSSKeyword_dot = 199,
        eCSSKeyword_dotted = 200,
        eCSSKeyword_double = 201,
        eCSSKeyword_double_circle = 202,
        eCSSKeyword_double_struck = 203,
        eCSSKeyword_drag = 204,
        eCSSKeyword_drop_shadow = 205,
        eCSSKeyword_e_resize = 206,
        eCSSKeyword_ease = 207,
        eCSSKeyword_ease_in = 208,
        eCSSKeyword_ease_in_out = 209,
        eCSSKeyword_ease_out = 210,
        eCSSKeyword_economy = 211,
        eCSSKeyword_element = 212,
        eCSSKeyword_elements = 213,
        eCSSKeyword_ellipse = 214,
        eCSSKeyword_ellipsis = 215,
        eCSSKeyword_em = 216,
        eCSSKeyword_embed = 217,
        eCSSKeyword_enabled = 218,
        eCSSKeyword_end = 219,
        eCSSKeyword_ex = 220,
        eCSSKeyword_exact = 221,
        eCSSKeyword_exclude = 222,
        eCSSKeyword_exclusion = 223,
        eCSSKeyword_expanded = 224,
        eCSSKeyword_extends = 225,
        eCSSKeyword_extra_condensed = 226,
        eCSSKeyword_extra_expanded = 227,
        eCSSKeyword_ew_resize = 228,
        eCSSKeyword_fallback = 229,
        eCSSKeyword_fantasy = 230,
        eCSSKeyword_farthest_side = 231,
        eCSSKeyword_farthest_corner = 232,
        eCSSKeyword_fill = 233,
        eCSSKeyword_filled = 234,
        eCSSKeyword_fill_box = 235,
        eCSSKeyword_first = 236,
        eCSSKeyword_fit_content = 237,
        eCSSKeyword_fixed = 238,
        eCSSKeyword_flat = 239,
        eCSSKeyword_flex = 240,
        eCSSKeyword_flex_end = 241,
        eCSSKeyword_flex_start = 242,
        eCSSKeyword_flip = 243,
        eCSSKeyword_flow_root = 244,
        eCSSKeyword_forwards = 245,
        eCSSKeyword_fraktur = 246,
        eCSSKeyword_frames = 247,
        eCSSKeyword_from_image = 248,
        eCSSKeyword_full_width = 249,
        eCSSKeyword_fullscreen = 250,
        eCSSKeyword_grab = 251,
        eCSSKeyword_grabbing = 252,
        eCSSKeyword_grad = 253,
        eCSSKeyword_grayscale = 254,
        eCSSKeyword_graytext = 255,
        eCSSKeyword_grid = 256,
        eCSSKeyword_groove = 257,
        eCSSKeyword_hard_light = 258,
        eCSSKeyword_help = 259,
        eCSSKeyword_hidden = 260,
        eCSSKeyword_hide = 261,
        eCSSKeyword_highlight = 262,
        eCSSKeyword_highlighttext = 263,
        eCSSKeyword_historical_forms = 264,
        eCSSKeyword_historical_ligatures = 265,
        eCSSKeyword_horizontal = 266,
        eCSSKeyword_horizontal_tb = 267,
        eCSSKeyword_hue = 268,
        eCSSKeyword_hue_rotate = 269,
        eCSSKeyword_hz = 270,
        eCSSKeyword_icon = 271,
        eCSSKeyword_ignore = 272,
        eCSSKeyword_ignore_horizontal = 273,
        eCSSKeyword_ignore_vertical = 274,
        eCSSKeyword_in = 275,
        eCSSKeyword_interlace = 276,
        eCSSKeyword_inactive = 277,
        eCSSKeyword_inactiveborder = 278,
        eCSSKeyword_inactivecaption = 279,
        eCSSKeyword_inactivecaptiontext = 280,
        eCSSKeyword_infinite = 281,
        eCSSKeyword_infobackground = 282,
        eCSSKeyword_infotext = 283,
        eCSSKeyword_inherit = 284,
        eCSSKeyword_initial = 285,
        eCSSKeyword_inline = 286,
        eCSSKeyword_inline_axis = 287,
        eCSSKeyword_inline_block = 288,
        eCSSKeyword_inline_end = 289,
        eCSSKeyword_inline_flex = 290,
        eCSSKeyword_inline_grid = 291,
        eCSSKeyword_inline_start = 292,
        eCSSKeyword_inline_table = 293,
        eCSSKeyword_inset = 294,
        eCSSKeyword_inside = 295,
        eCSSKeyword_inter_character = 296,
        eCSSKeyword_inter_word = 297,
        eCSSKeyword_interpolatematrix = 298,
        eCSSKeyword_accumulatematrix = 299,
        eCSSKeyword_intersect = 300,
        eCSSKeyword_isolate = 301,
        eCSSKeyword_isolate_override = 302,
        eCSSKeyword_invert = 303,
        eCSSKeyword_italic = 304,
        eCSSKeyword_jis78 = 305,
        eCSSKeyword_jis83 = 306,
        eCSSKeyword_jis90 = 307,
        eCSSKeyword_jis04 = 308,
        eCSSKeyword_justify = 309,
        eCSSKeyword_keep_all = 310,
        eCSSKeyword_khz = 311,
        eCSSKeyword_landscape = 312,
        eCSSKeyword_large = 313,
        eCSSKeyword_larger = 314,
        eCSSKeyword_last = 315,
        eCSSKeyword_last_baseline = 316,
        eCSSKeyword_layout = 317,
        eCSSKeyword_left = 318,
        eCSSKeyword_legacy = 319,
        eCSSKeyword_lighten = 320,
        eCSSKeyword_lighter = 321,
        eCSSKeyword_line_through = 322,
        eCSSKeyword_linear = 323,
        eCSSKeyword_lining_nums = 324,
        eCSSKeyword_list_item = 325,
        eCSSKeyword_local = 326,
        eCSSKeyword_logical = 327,
        eCSSKeyword_looped = 328,
        eCSSKeyword_lowercase = 329,
        eCSSKeyword_lr = 330,
        eCSSKeyword_lr_tb = 331,
        eCSSKeyword_ltr = 332,
        eCSSKeyword_luminance = 333,
        eCSSKeyword_luminosity = 334,
        eCSSKeyword_mandatory = 335,
        eCSSKeyword_manipulation = 336,
        eCSSKeyword_manual = 337,
        eCSSKeyword_margin_box = 338,
        eCSSKeyword_markers = 339,
        eCSSKeyword_match_parent = 340,
        eCSSKeyword_match_source = 341,
        eCSSKeyword_matrix = 342,
        eCSSKeyword_matrix3d = 343,
        eCSSKeyword_max_content = 344,
        eCSSKeyword_medium = 345,
        eCSSKeyword_menu = 346,
        eCSSKeyword_menutext = 347,
        eCSSKeyword_message_box = 348,
        eCSSKeyword_middle = 349,
        eCSSKeyword_min_content = 350,
        eCSSKeyword_minmax = 351,
        eCSSKeyword_mix = 352,
        eCSSKeyword_mixed = 353,
        eCSSKeyword_mm = 354,
        eCSSKeyword_monospace = 355,
        eCSSKeyword_move = 356,
        eCSSKeyword_ms = 357,
        eCSSKeyword_multiply = 358,
        eCSSKeyword_n_resize = 359,
        eCSSKeyword_narrower = 360,
        eCSSKeyword_ne_resize = 361,
        eCSSKeyword_nesw_resize = 362,
        eCSSKeyword_no_clip = 363,
        eCSSKeyword_no_close_quote = 364,
        eCSSKeyword_no_common_ligatures = 365,
        eCSSKeyword_no_contextual = 366,
        eCSSKeyword_no_discretionary_ligatures = 367,
        eCSSKeyword_no_drag = 368,
        eCSSKeyword_no_drop = 369,
        eCSSKeyword_no_historical_ligatures = 370,
        eCSSKeyword_no_open_quote = 371,
        eCSSKeyword_no_repeat = 372,
        eCSSKeyword_none = 373,
        eCSSKeyword_normal = 374,
        eCSSKeyword_not_allowed = 375,
        eCSSKeyword_nowrap = 376,
        eCSSKeyword_numeric = 377,
        eCSSKeyword_ns_resize = 378,
        eCSSKeyword_nw_resize = 379,
        eCSSKeyword_nwse_resize = 380,
        eCSSKeyword_oblique = 381,
        eCSSKeyword_oldstyle_nums = 382,
        eCSSKeyword_opacity = 383,
        eCSSKeyword_open = 384,
        eCSSKeyword_open_quote = 385,
        eCSSKeyword_optional = 386,
        eCSSKeyword_ordinal = 387,
        eCSSKeyword_ornaments = 388,
        eCSSKeyword_outset = 389,
        eCSSKeyword_outside = 390,
        eCSSKeyword_over = 391,
        eCSSKeyword_overlay = 392,
        eCSSKeyword_overline = 393,
        eCSSKeyword_paint = 394,
        eCSSKeyword_padding_box = 395,
        eCSSKeyword_painted = 396,
        eCSSKeyword_pan_x = 397,
        eCSSKeyword_pan_y = 398,
        eCSSKeyword_paused = 399,
        eCSSKeyword_pc = 400,
        eCSSKeyword_perspective = 401,
        eCSSKeyword_petite_caps = 402,
        eCSSKeyword_physical = 403,
        eCSSKeyword_plaintext = 404,
        eCSSKeyword_pointer = 405,
        eCSSKeyword_polygon = 406,
        eCSSKeyword_portrait = 407,
        eCSSKeyword_pre = 408,
        eCSSKeyword_pre_wrap = 409,
        eCSSKeyword_pre_line = 410,
        eCSSKeyword_preserve_3d = 411,
        eCSSKeyword_progress = 412,
        eCSSKeyword_progressive = 413,
        eCSSKeyword_proportional_nums = 414,
        eCSSKeyword_proportional_width = 415,
        eCSSKeyword_proximity = 416,
        eCSSKeyword_pt = 417,
        eCSSKeyword_px = 418,
        eCSSKeyword_rad = 419,
        eCSSKeyword_read_only = 420,
        eCSSKeyword_read_write = 421,
        eCSSKeyword_relative = 422,
        eCSSKeyword_repeat = 423,
        eCSSKeyword_repeat_x = 424,
        eCSSKeyword_repeat_y = 425,
        eCSSKeyword_reverse = 426,
        eCSSKeyword_ridge = 427,
        eCSSKeyword_right = 428,
        eCSSKeyword_rl = 429,
        eCSSKeyword_rl_tb = 430,
        eCSSKeyword_rotate = 431,
        eCSSKeyword_rotate3d = 432,
        eCSSKeyword_rotatex = 433,
        eCSSKeyword_rotatey = 434,
        eCSSKeyword_rotatez = 435,
        eCSSKeyword_round = 436,
        eCSSKeyword_row = 437,
        eCSSKeyword_row_resize = 438,
        eCSSKeyword_row_reverse = 439,
        eCSSKeyword_rtl = 440,
        eCSSKeyword_ruby = 441,
        eCSSKeyword_ruby_base = 442,
        eCSSKeyword_ruby_base_container = 443,
        eCSSKeyword_ruby_text = 444,
        eCSSKeyword_ruby_text_container = 445,
        eCSSKeyword_running = 446,
        eCSSKeyword_s = 447,
        eCSSKeyword_s_resize = 448,
        eCSSKeyword_safe = 449,
        eCSSKeyword_saturate = 450,
        eCSSKeyword_saturation = 451,
        eCSSKeyword_scale = 452,
        eCSSKeyword_scale_down = 453,
        eCSSKeyword_scale3d = 454,
        eCSSKeyword_scalex = 455,
        eCSSKeyword_scaley = 456,
        eCSSKeyword_scalez = 457,
        eCSSKeyword_screen = 458,
        eCSSKeyword_script = 459,
        eCSSKeyword_scroll = 460,
        eCSSKeyword_scrollbar = 461,
        eCSSKeyword_scrollbar_small = 462,
        eCSSKeyword_scrollbar_horizontal = 463,
        eCSSKeyword_scrollbar_vertical = 464,
        eCSSKeyword_se_resize = 465,
        eCSSKeyword_select_after = 466,
        eCSSKeyword_select_all = 467,
        eCSSKeyword_select_before = 468,
        eCSSKeyword_select_menu = 469,
        eCSSKeyword_select_same = 470,
        eCSSKeyword_self_end = 471,
        eCSSKeyword_self_start = 472,
        eCSSKeyword_semi_condensed = 473,
        eCSSKeyword_semi_expanded = 474,
        eCSSKeyword_separate = 475,
        eCSSKeyword_sepia = 476,
        eCSSKeyword_serif = 477,
        eCSSKeyword_sesame = 478,
        eCSSKeyword_show = 479,
        eCSSKeyword_sideways = 480,
        eCSSKeyword_sideways_lr = 481,
        eCSSKeyword_sideways_right = 482,
        eCSSKeyword_sideways_rl = 483,
        eCSSKeyword_simplified = 484,
        eCSSKeyword_skew = 485,
        eCSSKeyword_skewx = 486,
        eCSSKeyword_skewy = 487,
        eCSSKeyword_slashed_zero = 488,
        eCSSKeyword_slice = 489,
        eCSSKeyword_small = 490,
        eCSSKeyword_small_caps = 491,
        eCSSKeyword_small_caption = 492,
        eCSSKeyword_smaller = 493,
        eCSSKeyword_smooth = 494,
        eCSSKeyword_soft = 495,
        eCSSKeyword_soft_light = 496,
        eCSSKeyword_solid = 497,
        eCSSKeyword_space_around = 498,
        eCSSKeyword_space_between = 499,
        eCSSKeyword_space_evenly = 500,
        eCSSKeyword_span = 501,
        eCSSKeyword_spell_out = 502,
        eCSSKeyword_square = 503,
        eCSSKeyword_stacked_fractions = 504,
        eCSSKeyword_start = 505,
        eCSSKeyword_static = 506,
        eCSSKeyword_standalone = 507,
        eCSSKeyword_status_bar = 508,
        eCSSKeyword_step_end = 509,
        eCSSKeyword_step_start = 510,
        eCSSKeyword_sticky = 511,
        eCSSKeyword_stretch = 512,
        eCSSKeyword_stretch_to_fit = 513,
        eCSSKeyword_stretched = 514,
        eCSSKeyword_strict = 515,
        eCSSKeyword_stroke = 516,
        eCSSKeyword_stroke_box = 517,
        eCSSKeyword_style = 518,
        eCSSKeyword_styleset = 519,
        eCSSKeyword_stylistic = 520,
        eCSSKeyword_sub = 521,
        eCSSKeyword_subgrid = 522,
        eCSSKeyword_subtract = 523,
        eCSSKeyword_super = 524,
        eCSSKeyword_sw_resize = 525,
        eCSSKeyword_swash = 526,
        eCSSKeyword_swap = 527,
        eCSSKeyword_table = 528,
        eCSSKeyword_table_caption = 529,
        eCSSKeyword_table_cell = 530,
        eCSSKeyword_table_column = 531,
        eCSSKeyword_table_column_group = 532,
        eCSSKeyword_table_footer_group = 533,
        eCSSKeyword_table_header_group = 534,
        eCSSKeyword_table_row = 535,
        eCSSKeyword_table_row_group = 536,
        eCSSKeyword_tabular_nums = 537,
        eCSSKeyword_tailed = 538,
        eCSSKeyword_tb = 539,
        eCSSKeyword_tb_rl = 540,
        eCSSKeyword_text = 541,
        eCSSKeyword_text_bottom = 542,
        eCSSKeyword_text_top = 543,
        eCSSKeyword_thick = 544,
        eCSSKeyword_thin = 545,
        eCSSKeyword_threeddarkshadow = 546,
        eCSSKeyword_threedface = 547,
        eCSSKeyword_threedhighlight = 548,
        eCSSKeyword_threedlightshadow = 549,
        eCSSKeyword_threedshadow = 550,
        eCSSKeyword_titling_caps = 551,
        eCSSKeyword_toggle = 552,
        eCSSKeyword_top = 553,
        eCSSKeyword_top_outside = 554,
        eCSSKeyword_traditional = 555,
        eCSSKeyword_translate = 556,
        eCSSKeyword_translate3d = 557,
        eCSSKeyword_translatex = 558,
        eCSSKeyword_translatey = 559,
        eCSSKeyword_translatez = 560,
        eCSSKeyword_transparent = 561,
        eCSSKeyword_triangle = 562,
        eCSSKeyword_tri_state = 563,
        eCSSKeyword_ultra_condensed = 564,
        eCSSKeyword_ultra_expanded = 565,
        eCSSKeyword_under = 566,
        eCSSKeyword_underline = 567,
        eCSSKeyword_unicase = 568,
        eCSSKeyword_unsafe = 569,
        eCSSKeyword_unset = 570,
        eCSSKeyword_uppercase = 571,
        eCSSKeyword_upright = 572,
        eCSSKeyword_vertical = 573,
        eCSSKeyword_vertical_lr = 574,
        eCSSKeyword_vertical_rl = 575,
        eCSSKeyword_vertical_text = 576,
        eCSSKeyword_view_box = 577,
        eCSSKeyword_visible = 578,
        eCSSKeyword_visiblefill = 579,
        eCSSKeyword_visiblepainted = 580,
        eCSSKeyword_visiblestroke = 581,
        eCSSKeyword_w_resize = 582,
        eCSSKeyword_wait = 583,
        eCSSKeyword_wavy = 584,
        eCSSKeyword_weight = 585,
        eCSSKeyword_wider = 586,
        eCSSKeyword_window = 587,
        eCSSKeyword_windowframe = 588,
        eCSSKeyword_windowtext = 589,
        eCSSKeyword_words = 590,
        eCSSKeyword_wrap = 591,
        eCSSKeyword_wrap_reverse = 592,
        eCSSKeyword_write_only = 593,
        eCSSKeyword_x_large = 594,
        eCSSKeyword_x_small = 595,
        eCSSKeyword_xx_large = 596,
        eCSSKeyword_xx_small = 597,
        eCSSKeyword_zoom_in = 598,
        eCSSKeyword_zoom_out = 599,
        eCSSKeyword_radio = 600,
        eCSSKeyword_checkbox = 601,
        eCSSKeyword_button_bevel = 602,
        eCSSKeyword_toolbox = 603,
        eCSSKeyword_toolbar = 604,
        eCSSKeyword_toolbarbutton = 605,
        eCSSKeyword_toolbargripper = 606,
        eCSSKeyword_dualbutton = 607,
        eCSSKeyword_toolbarbutton_dropdown = 608,
        eCSSKeyword_button_arrow_up = 609,
        eCSSKeyword_button_arrow_down = 610,
        eCSSKeyword_button_arrow_next = 611,
        eCSSKeyword_button_arrow_previous = 612,
        eCSSKeyword_separator = 613,
        eCSSKeyword_splitter = 614,
        eCSSKeyword_statusbar = 615,
        eCSSKeyword_statusbarpanel = 616,
        eCSSKeyword_resizerpanel = 617,
        eCSSKeyword_resizer = 618,
        eCSSKeyword_listbox = 619,
        eCSSKeyword_listitem = 620,
        eCSSKeyword_numbers = 621,
        eCSSKeyword_number_input = 622,
        eCSSKeyword_treeview = 623,
        eCSSKeyword_treeitem = 624,
        eCSSKeyword_treetwisty = 625,
        eCSSKeyword_treetwistyopen = 626,
        eCSSKeyword_treeline = 627,
        eCSSKeyword_treeheader = 628,
        eCSSKeyword_treeheadercell = 629,
        eCSSKeyword_treeheadersortarrow = 630,
        eCSSKeyword_progressbar = 631,
        eCSSKeyword_progressbar_vertical = 632,
        eCSSKeyword_progresschunk = 633,
        eCSSKeyword_progresschunk_vertical = 634,
        eCSSKeyword_tab = 635,
        eCSSKeyword_tabpanels = 636,
        eCSSKeyword_tabpanel = 637,
        eCSSKeyword_tab_scroll_arrow_back = 638,
        eCSSKeyword_tab_scroll_arrow_forward = 639,
        eCSSKeyword_tooltip = 640,
        eCSSKeyword_spinner = 641,
        eCSSKeyword_spinner_upbutton = 642,
        eCSSKeyword_spinner_downbutton = 643,
        eCSSKeyword_spinner_textfield = 644,
        eCSSKeyword_scrollbarbutton_up = 645,
        eCSSKeyword_scrollbarbutton_down = 646,
        eCSSKeyword_scrollbarbutton_left = 647,
        eCSSKeyword_scrollbarbutton_right = 648,
        eCSSKeyword_scrollbartrack_horizontal = 649,
        eCSSKeyword_scrollbartrack_vertical = 650,
        eCSSKeyword_scrollbarthumb_horizontal = 651,
        eCSSKeyword_scrollbarthumb_vertical = 652,
        eCSSKeyword_sheet = 653,
        eCSSKeyword_textfield = 654,
        eCSSKeyword_textfield_multiline = 655,
        eCSSKeyword_caret = 656,
        eCSSKeyword_searchfield = 657,
        eCSSKeyword_menubar = 658,
        eCSSKeyword_menupopup = 659,
        eCSSKeyword_menuitem = 660,
        eCSSKeyword_checkmenuitem = 661,
        eCSSKeyword_radiomenuitem = 662,
        eCSSKeyword_menucheckbox = 663,
        eCSSKeyword_menuradio = 664,
        eCSSKeyword_menuseparator = 665,
        eCSSKeyword_menuarrow = 666,
        eCSSKeyword_menuimage = 667,
        eCSSKeyword_menuitemtext = 668,
        eCSSKeyword_menulist = 669,
        eCSSKeyword_menulist_button = 670,
        eCSSKeyword_menulist_text = 671,
        eCSSKeyword_menulist_textfield = 672,
        eCSSKeyword_meterbar = 673,
        eCSSKeyword_meterchunk = 674,
        eCSSKeyword_minimal_ui = 675,
        eCSSKeyword_range = 676,
        eCSSKeyword_range_thumb = 677,
        eCSSKeyword_sans_serif = 678,
        eCSSKeyword_sans_serif_bold_italic = 679,
        eCSSKeyword_sans_serif_italic = 680,
        eCSSKeyword_scale_horizontal = 681,
        eCSSKeyword_scale_vertical = 682,
        eCSSKeyword_scalethumb_horizontal = 683,
        eCSSKeyword_scalethumb_vertical = 684,
        eCSSKeyword_scalethumbstart = 685,
        eCSSKeyword_scalethumbend = 686,
        eCSSKeyword_scalethumbtick = 687,
        eCSSKeyword_groupbox = 688,
        eCSSKeyword_checkbox_container = 689,
        eCSSKeyword_radio_container = 690,
        eCSSKeyword_checkbox_label = 691,
        eCSSKeyword_radio_label = 692,
        eCSSKeyword_button_focus = 693,
        eCSSKeyword__moz_win_media_toolbox = 694,
        eCSSKeyword__moz_win_communications_toolbox = 695,
        eCSSKeyword__moz_win_browsertabbar_toolbox = 696,
        eCSSKeyword__moz_win_accentcolor = 697,
        eCSSKeyword__moz_win_accentcolortext = 698,
        eCSSKeyword__moz_win_mediatext = 699,
        eCSSKeyword__moz_win_communicationstext = 700,
        eCSSKeyword__moz_win_glass = 701,
        eCSSKeyword__moz_win_borderless_glass = 702,
        eCSSKeyword__moz_window_titlebar = 703,
        eCSSKeyword__moz_window_titlebar_maximized = 704,
        eCSSKeyword__moz_window_frame_left = 705,
        eCSSKeyword__moz_window_frame_right = 706,
        eCSSKeyword__moz_window_frame_bottom = 707,
        eCSSKeyword__moz_window_button_close = 708,
        eCSSKeyword__moz_window_button_minimize = 709,
        eCSSKeyword__moz_window_button_maximize = 710,
        eCSSKeyword__moz_window_button_restore = 711,
        eCSSKeyword__moz_window_button_box = 712,
        eCSSKeyword__moz_window_button_box_maximized = 713,
        eCSSKeyword__moz_mac_help_button = 714,
        eCSSKeyword__moz_win_exclude_glass = 715,
        eCSSKeyword__moz_mac_vibrancy_light = 716,
        eCSSKeyword__moz_mac_vibrancy_dark = 717,
        eCSSKeyword__moz_mac_disclosure_button_closed = 718,
        eCSSKeyword__moz_mac_disclosure_button_open = 719,
        eCSSKeyword__moz_mac_source_list = 720,
        eCSSKeyword__moz_mac_source_list_selection = 721,
        eCSSKeyword__moz_mac_active_source_list_selection = 722,
        eCSSKeyword_alphabetic = 723,
        eCSSKeyword_bevel = 724,
        eCSSKeyword_butt = 725,
        eCSSKeyword_central = 726,
        eCSSKeyword_crispedges = 727,
        eCSSKeyword_evenodd = 728,
        eCSSKeyword_geometricprecision = 729,
        eCSSKeyword_hanging = 730,
        eCSSKeyword_ideographic = 731,
        eCSSKeyword_linearrgb = 732,
        eCSSKeyword_mathematical = 733,
        eCSSKeyword_miter = 734,
        eCSSKeyword_no_change = 735,
        eCSSKeyword_non_scaling_stroke = 736,
        eCSSKeyword_nonzero = 737,
        eCSSKeyword_optimizelegibility = 738,
        eCSSKeyword_optimizequality = 739,
        eCSSKeyword_optimizespeed = 740,
        eCSSKeyword_reset_size = 741,
        eCSSKeyword_srgb = 742,
        eCSSKeyword_symbolic = 743,
        eCSSKeyword_symbols = 744,
        eCSSKeyword_text_after_edge = 745,
        eCSSKeyword_text_before_edge = 746,
        eCSSKeyword_use_script = 747,
        eCSSKeyword__moz_crisp_edges = 748,
        eCSSKeyword_space = 749,
        eCSSKeyword_COUNT = 750,
    }
    pub const nsCSSPropertyID_eCSSProperty_COUNT_no_shorthands:
              root::nsCSSPropertyID =
        nsCSSPropertyID::eCSSProperty_all;
    pub const nsCSSPropertyID_eCSSProperty_COUNT_DUMMY: root::nsCSSPropertyID
              =
        nsCSSPropertyID::eCSSProperty_z_index;
    pub const nsCSSPropertyID_eCSSProperty_COUNT: root::nsCSSPropertyID =
        nsCSSPropertyID::eCSSPropertyAlias_WordWrap;
    pub const nsCSSPropertyID_eCSSProperty_COUNT_DUMMY2: root::nsCSSPropertyID
              =
        nsCSSPropertyID::eCSSProperty_transition;
    pub const nsCSSPropertyID_eCSSProperty_COUNT_with_aliases:
              root::nsCSSPropertyID =
        nsCSSPropertyID::eCSSPropertyExtra_no_properties;
    pub const nsCSSPropertyID_eCSSProperty_COUNT_DUMMY3: root::nsCSSPropertyID
              =
        nsCSSPropertyID::eCSSPropertyAlias_WebkitMaskSize;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSPropertyID {
        eCSSProperty_UNKNOWN = -1,
        eCSSProperty_align_content = 0,
        eCSSProperty_align_items = 1,
        eCSSProperty_align_self = 2,
        eCSSProperty_animation_delay = 3,
        eCSSProperty_animation_direction = 4,
        eCSSProperty_animation_duration = 5,
        eCSSProperty_animation_fill_mode = 6,
        eCSSProperty_animation_iteration_count = 7,
        eCSSProperty_animation_name = 8,
        eCSSProperty_animation_play_state = 9,
        eCSSProperty_animation_timing_function = 10,
        eCSSProperty__moz_appearance = 11,
        eCSSProperty_backface_visibility = 12,
        eCSSProperty_background_attachment = 13,
        eCSSProperty_background_blend_mode = 14,
        eCSSProperty_background_clip = 15,
        eCSSProperty_background_color = 16,
        eCSSProperty_background_image = 17,
        eCSSProperty_background_origin = 18,
        eCSSProperty_background_position_x = 19,
        eCSSProperty_background_position_y = 20,
        eCSSProperty_background_repeat = 21,
        eCSSProperty_background_size = 22,
        eCSSProperty__moz_binding = 23,
        eCSSProperty_block_size = 24,
        eCSSProperty_border_block_end_color = 25,
        eCSSProperty_border_block_end_style = 26,
        eCSSProperty_border_block_end_width = 27,
        eCSSProperty_border_block_start_color = 28,
        eCSSProperty_border_block_start_style = 29,
        eCSSProperty_border_block_start_width = 30,
        eCSSProperty_border_bottom_color = 31,
        eCSSProperty__moz_border_bottom_colors = 32,
        eCSSProperty_border_bottom_left_radius = 33,
        eCSSProperty_border_bottom_right_radius = 34,
        eCSSProperty_border_bottom_style = 35,
        eCSSProperty_border_bottom_width = 36,
        eCSSProperty_border_collapse = 37,
        eCSSProperty_border_image_outset = 38,
        eCSSProperty_border_image_repeat = 39,
        eCSSProperty_border_image_slice = 40,
        eCSSProperty_border_image_source = 41,
        eCSSProperty_border_image_width = 42,
        eCSSProperty_border_inline_end_color = 43,
        eCSSProperty_border_inline_end_style = 44,
        eCSSProperty_border_inline_end_width = 45,
        eCSSProperty_border_inline_start_color = 46,
        eCSSProperty_border_inline_start_style = 47,
        eCSSProperty_border_inline_start_width = 48,
        eCSSProperty_border_left_color = 49,
        eCSSProperty__moz_border_left_colors = 50,
        eCSSProperty_border_left_style = 51,
        eCSSProperty_border_left_width = 52,
        eCSSProperty_border_right_color = 53,
        eCSSProperty__moz_border_right_colors = 54,
        eCSSProperty_border_right_style = 55,
        eCSSProperty_border_right_width = 56,
        eCSSProperty_border_spacing = 57,
        eCSSProperty_border_top_color = 58,
        eCSSProperty__moz_border_top_colors = 59,
        eCSSProperty_border_top_left_radius = 60,
        eCSSProperty_border_top_right_radius = 61,
        eCSSProperty_border_top_style = 62,
        eCSSProperty_border_top_width = 63,
        eCSSProperty_bottom = 64,
        eCSSProperty__moz_box_align = 65,
        eCSSProperty_box_decoration_break = 66,
        eCSSProperty__moz_box_direction = 67,
        eCSSProperty__moz_box_flex = 68,
        eCSSProperty__moz_box_ordinal_group = 69,
        eCSSProperty__moz_box_orient = 70,
        eCSSProperty__moz_box_pack = 71,
        eCSSProperty_box_shadow = 72,
        eCSSProperty_box_sizing = 73,
        eCSSProperty_caption_side = 74,
        eCSSProperty_caret_color = 75,
        eCSSProperty_clear = 76,
        eCSSProperty_clip = 77,
        eCSSProperty_clip_path = 78,
        eCSSProperty_clip_rule = 79,
        eCSSProperty_color = 80,
        eCSSProperty_color_adjust = 81,
        eCSSProperty_color_interpolation = 82,
        eCSSProperty_color_interpolation_filters = 83,
        eCSSProperty_column_count = 84,
        eCSSProperty_column_fill = 85,
        eCSSProperty_column_gap = 86,
        eCSSProperty_column_rule_color = 87,
        eCSSProperty_column_rule_style = 88,
        eCSSProperty_column_rule_width = 89,
        eCSSProperty_column_span = 90,
        eCSSProperty_column_width = 91,
        eCSSProperty_contain = 92,
        eCSSProperty_content = 93,
        eCSSProperty__moz_context_properties = 94,
        eCSSProperty__moz_control_character_visibility = 95,
        eCSSProperty_counter_increment = 96,
        eCSSProperty_counter_reset = 97,
        eCSSProperty_cursor = 98,
        eCSSProperty_direction = 99,
        eCSSProperty_display = 100,
        eCSSProperty_dominant_baseline = 101,
        eCSSProperty_empty_cells = 102,
        eCSSProperty_fill = 103,
        eCSSProperty_fill_opacity = 104,
        eCSSProperty_fill_rule = 105,
        eCSSProperty_filter = 106,
        eCSSProperty_flex_basis = 107,
        eCSSProperty_flex_direction = 108,
        eCSSProperty_flex_grow = 109,
        eCSSProperty_flex_shrink = 110,
        eCSSProperty_flex_wrap = 111,
        eCSSProperty_float_ = 112,
        eCSSProperty__moz_float_edge = 113,
        eCSSProperty_flood_color = 114,
        eCSSProperty_flood_opacity = 115,
        eCSSProperty_font_family = 116,
        eCSSProperty_font_feature_settings = 117,
        eCSSProperty_font_kerning = 118,
        eCSSProperty_font_language_override = 119,
        eCSSProperty_font_size = 120,
        eCSSProperty_font_size_adjust = 121,
        eCSSProperty_font_stretch = 122,
        eCSSProperty_font_style = 123,
        eCSSProperty_font_synthesis = 124,
        eCSSProperty_font_variant_alternates = 125,
        eCSSProperty_font_variant_caps = 126,
        eCSSProperty_font_variant_east_asian = 127,
        eCSSProperty_font_variant_ligatures = 128,
        eCSSProperty_font_variant_numeric = 129,
        eCSSProperty_font_variant_position = 130,
        eCSSProperty_font_variation_settings = 131,
        eCSSProperty_font_weight = 132,
        eCSSProperty__moz_force_broken_image_icon = 133,
        eCSSProperty_grid_auto_columns = 134,
        eCSSProperty_grid_auto_flow = 135,
        eCSSProperty_grid_auto_rows = 136,
        eCSSProperty_grid_column_end = 137,
        eCSSProperty_grid_column_gap = 138,
        eCSSProperty_grid_column_start = 139,
        eCSSProperty_grid_row_end = 140,
        eCSSProperty_grid_row_gap = 141,
        eCSSProperty_grid_row_start = 142,
        eCSSProperty_grid_template_areas = 143,
        eCSSProperty_grid_template_columns = 144,
        eCSSProperty_grid_template_rows = 145,
        eCSSProperty_height = 146,
        eCSSProperty_hyphens = 147,
        eCSSProperty_initial_letter = 148,
        eCSSProperty_image_orientation = 149,
        eCSSProperty__moz_image_region = 150,
        eCSSProperty_image_rendering = 151,
        eCSSProperty_ime_mode = 152,
        eCSSProperty_inline_size = 153,
        eCSSProperty_isolation = 154,
        eCSSProperty_justify_content = 155,
        eCSSProperty_justify_items = 156,
        eCSSProperty_justify_self = 157,
        eCSSProperty__x_lang = 158,
        eCSSProperty_left = 159,
        eCSSProperty_letter_spacing = 160,
        eCSSProperty_lighting_color = 161,
        eCSSProperty_line_height = 162,
        eCSSProperty_list_style_image = 163,
        eCSSProperty_list_style_position = 164,
        eCSSProperty_list_style_type = 165,
        eCSSProperty_margin_block_end = 166,
        eCSSProperty_margin_block_start = 167,
        eCSSProperty_margin_bottom = 168,
        eCSSProperty_margin_inline_end = 169,
        eCSSProperty_margin_inline_start = 170,
        eCSSProperty_margin_left = 171,
        eCSSProperty_margin_right = 172,
        eCSSProperty_margin_top = 173,
        eCSSProperty_marker_end = 174,
        eCSSProperty_marker_mid = 175,
        eCSSProperty_marker_start = 176,
        eCSSProperty_mask_clip = 177,
        eCSSProperty_mask_composite = 178,
        eCSSProperty_mask_image = 179,
        eCSSProperty_mask_mode = 180,
        eCSSProperty_mask_origin = 181,
        eCSSProperty_mask_position_x = 182,
        eCSSProperty_mask_position_y = 183,
        eCSSProperty_mask_repeat = 184,
        eCSSProperty_mask_size = 185,
        eCSSProperty_mask_type = 186,
        eCSSProperty__moz_math_display = 187,
        eCSSProperty__moz_math_variant = 188,
        eCSSProperty_max_block_size = 189,
        eCSSProperty_max_height = 190,
        eCSSProperty_max_inline_size = 191,
        eCSSProperty_max_width = 192,
        eCSSProperty_min_block_size = 193,
        eCSSProperty__moz_min_font_size_ratio = 194,
        eCSSProperty_min_height = 195,
        eCSSProperty_min_inline_size = 196,
        eCSSProperty_min_width = 197,
        eCSSProperty_mix_blend_mode = 198,
        eCSSProperty_object_fit = 199,
        eCSSProperty_object_position = 200,
        eCSSProperty_offset_block_end = 201,
        eCSSProperty_offset_block_start = 202,
        eCSSProperty_offset_inline_end = 203,
        eCSSProperty_offset_inline_start = 204,
        eCSSProperty_opacity = 205,
        eCSSProperty_order = 206,
        eCSSProperty__moz_orient = 207,
        eCSSProperty__moz_osx_font_smoothing = 208,
        eCSSProperty_outline_color = 209,
        eCSSProperty_outline_offset = 210,
        eCSSProperty__moz_outline_radius_bottomleft = 211,
        eCSSProperty__moz_outline_radius_bottomright = 212,
        eCSSProperty__moz_outline_radius_topleft = 213,
        eCSSProperty__moz_outline_radius_topright = 214,
        eCSSProperty_outline_style = 215,
        eCSSProperty_outline_width = 216,
        eCSSProperty_overflow_clip_box = 217,
        eCSSProperty_overflow_x = 218,
        eCSSProperty_overflow_y = 219,
        eCSSProperty_padding_block_end = 220,
        eCSSProperty_padding_block_start = 221,
        eCSSProperty_padding_bottom = 222,
        eCSSProperty_padding_inline_end = 223,
        eCSSProperty_padding_inline_start = 224,
        eCSSProperty_padding_left = 225,
        eCSSProperty_padding_right = 226,
        eCSSProperty_padding_top = 227,
        eCSSProperty_page_break_after = 228,
        eCSSProperty_page_break_before = 229,
        eCSSProperty_page_break_inside = 230,
        eCSSProperty_paint_order = 231,
        eCSSProperty_perspective = 232,
        eCSSProperty_perspective_origin = 233,
        eCSSProperty_pointer_events = 234,
        eCSSProperty_position = 235,
        eCSSProperty_quotes = 236,
        eCSSProperty_resize = 237,
        eCSSProperty_right = 238,
        eCSSProperty_ruby_align = 239,
        eCSSProperty_ruby_position = 240,
        eCSSProperty__moz_script_level = 241,
        eCSSProperty__moz_script_min_size = 242,
        eCSSProperty__moz_script_size_multiplier = 243,
        eCSSProperty_scroll_behavior = 244,
        eCSSProperty_scroll_snap_coordinate = 245,
        eCSSProperty_scroll_snap_destination = 246,
        eCSSProperty_scroll_snap_points_x = 247,
        eCSSProperty_scroll_snap_points_y = 248,
        eCSSProperty_scroll_snap_type_x = 249,
        eCSSProperty_scroll_snap_type_y = 250,
        eCSSProperty_shape_outside = 251,
        eCSSProperty_shape_rendering = 252,
        eCSSProperty__x_span = 253,
        eCSSProperty__moz_stack_sizing = 254,
        eCSSProperty_stop_color = 255,
        eCSSProperty_stop_opacity = 256,
        eCSSProperty_stroke = 257,
        eCSSProperty_stroke_dasharray = 258,
        eCSSProperty_stroke_dashoffset = 259,
        eCSSProperty_stroke_linecap = 260,
        eCSSProperty_stroke_linejoin = 261,
        eCSSProperty_stroke_miterlimit = 262,
        eCSSProperty_stroke_opacity = 263,
        eCSSProperty_stroke_width = 264,
        eCSSProperty__x_system_font = 265,
        eCSSProperty__moz_tab_size = 266,
        eCSSProperty_table_layout = 267,
        eCSSProperty_text_align = 268,
        eCSSProperty_text_align_last = 269,
        eCSSProperty_text_anchor = 270,
        eCSSProperty_text_combine_upright = 271,
        eCSSProperty_text_decoration_color = 272,
        eCSSProperty_text_decoration_line = 273,
        eCSSProperty_text_decoration_style = 274,
        eCSSProperty_text_emphasis_color = 275,
        eCSSProperty_text_emphasis_position = 276,
        eCSSProperty_text_emphasis_style = 277,
        eCSSProperty__webkit_text_fill_color = 278,
        eCSSProperty_text_indent = 279,
        eCSSProperty_text_justify = 280,
        eCSSProperty_text_orientation = 281,
        eCSSProperty_text_overflow = 282,
        eCSSProperty_text_rendering = 283,
        eCSSProperty_text_shadow = 284,
        eCSSProperty__moz_text_size_adjust = 285,
        eCSSProperty__webkit_text_stroke_color = 286,
        eCSSProperty__webkit_text_stroke_width = 287,
        eCSSProperty_text_transform = 288,
        eCSSProperty__x_text_zoom = 289,
        eCSSProperty_top = 290,
        eCSSProperty__moz_top_layer = 291,
        eCSSProperty_touch_action = 292,
        eCSSProperty_transform = 293,
        eCSSProperty_transform_box = 294,
        eCSSProperty_transform_origin = 295,
        eCSSProperty_transform_style = 296,
        eCSSProperty_transition_delay = 297,
        eCSSProperty_transition_duration = 298,
        eCSSProperty_transition_property = 299,
        eCSSProperty_transition_timing_function = 300,
        eCSSProperty_unicode_bidi = 301,
        eCSSProperty__moz_user_focus = 302,
        eCSSProperty__moz_user_input = 303,
        eCSSProperty__moz_user_modify = 304,
        eCSSProperty__moz_user_select = 305,
        eCSSProperty_vector_effect = 306,
        eCSSProperty_vertical_align = 307,
        eCSSProperty_visibility = 308,
        eCSSProperty_white_space = 309,
        eCSSProperty_width = 310,
        eCSSProperty_will_change = 311,
        eCSSProperty__moz_window_dragging = 312,
        eCSSProperty__moz_window_shadow = 313,
        eCSSProperty__moz_window_opacity = 314,
        eCSSProperty__moz_window_transform = 315,
        eCSSProperty__moz_window_transform_origin = 316,
        eCSSProperty_word_break = 317,
        eCSSProperty_word_spacing = 318,
        eCSSProperty_overflow_wrap = 319,
        eCSSProperty_writing_mode = 320,
        eCSSProperty_z_index = 321,
        eCSSProperty_all = 322,
        eCSSProperty_animation = 323,
        eCSSProperty_background = 324,
        eCSSProperty_background_position = 325,
        eCSSProperty_border = 326,
        eCSSProperty_border_block_end = 327,
        eCSSProperty_border_block_start = 328,
        eCSSProperty_border_bottom = 329,
        eCSSProperty_border_color = 330,
        eCSSProperty_border_image = 331,
        eCSSProperty_border_inline_end = 332,
        eCSSProperty_border_inline_start = 333,
        eCSSProperty_border_left = 334,
        eCSSProperty_border_radius = 335,
        eCSSProperty_border_right = 336,
        eCSSProperty_border_style = 337,
        eCSSProperty_border_top = 338,
        eCSSProperty_border_width = 339,
        eCSSProperty_column_rule = 340,
        eCSSProperty_columns = 341,
        eCSSProperty_flex = 342,
        eCSSProperty_flex_flow = 343,
        eCSSProperty_font = 344,
        eCSSProperty_font_variant = 345,
        eCSSProperty_grid = 346,
        eCSSProperty_grid_area = 347,
        eCSSProperty_grid_column = 348,
        eCSSProperty_grid_gap = 349,
        eCSSProperty_grid_row = 350,
        eCSSProperty_grid_template = 351,
        eCSSProperty_list_style = 352,
        eCSSProperty_margin = 353,
        eCSSProperty_marker = 354,
        eCSSProperty_mask = 355,
        eCSSProperty_mask_position = 356,
        eCSSProperty_outline = 357,
        eCSSProperty__moz_outline_radius = 358,
        eCSSProperty_overflow = 359,
        eCSSProperty_padding = 360,
        eCSSProperty_place_content = 361,
        eCSSProperty_place_items = 362,
        eCSSProperty_place_self = 363,
        eCSSProperty_scroll_snap_type = 364,
        eCSSProperty_text_decoration = 365,
        eCSSProperty_text_emphasis = 366,
        eCSSProperty__webkit_text_stroke = 367,
        eCSSProperty__moz_transform = 368,
        eCSSProperty_transition = 369,
        eCSSPropertyAlias_WordWrap = 370,
        eCSSPropertyAlias_MozTransformOrigin = 371,
        eCSSPropertyAlias_MozPerspectiveOrigin = 372,
        eCSSPropertyAlias_MozPerspective = 373,
        eCSSPropertyAlias_MozTransformStyle = 374,
        eCSSPropertyAlias_MozBackfaceVisibility = 375,
        eCSSPropertyAlias_MozBorderImage = 376,
        eCSSPropertyAlias_MozTransition = 377,
        eCSSPropertyAlias_MozTransitionDelay = 378,
        eCSSPropertyAlias_MozTransitionDuration = 379,
        eCSSPropertyAlias_MozTransitionProperty = 380,
        eCSSPropertyAlias_MozTransitionTimingFunction = 381,
        eCSSPropertyAlias_MozAnimation = 382,
        eCSSPropertyAlias_MozAnimationDelay = 383,
        eCSSPropertyAlias_MozAnimationDirection = 384,
        eCSSPropertyAlias_MozAnimationDuration = 385,
        eCSSPropertyAlias_MozAnimationFillMode = 386,
        eCSSPropertyAlias_MozAnimationIterationCount = 387,
        eCSSPropertyAlias_MozAnimationName = 388,
        eCSSPropertyAlias_MozAnimationPlayState = 389,
        eCSSPropertyAlias_MozAnimationTimingFunction = 390,
        eCSSPropertyAlias_MozBoxSizing = 391,
        eCSSPropertyAlias_MozFontFeatureSettings = 392,
        eCSSPropertyAlias_MozFontLanguageOverride = 393,
        eCSSPropertyAlias_MozPaddingEnd = 394,
        eCSSPropertyAlias_MozPaddingStart = 395,
        eCSSPropertyAlias_MozMarginEnd = 396,
        eCSSPropertyAlias_MozMarginStart = 397,
        eCSSPropertyAlias_MozBorderEnd = 398,
        eCSSPropertyAlias_MozBorderEndColor = 399,
        eCSSPropertyAlias_MozBorderEndStyle = 400,
        eCSSPropertyAlias_MozBorderEndWidth = 401,
        eCSSPropertyAlias_MozBorderStart = 402,
        eCSSPropertyAlias_MozBorderStartColor = 403,
        eCSSPropertyAlias_MozBorderStartStyle = 404,
        eCSSPropertyAlias_MozBorderStartWidth = 405,
        eCSSPropertyAlias_MozHyphens = 406,
        eCSSPropertyAlias_MozColumnCount = 407,
        eCSSPropertyAlias_MozColumnFill = 408,
        eCSSPropertyAlias_MozColumnGap = 409,
        eCSSPropertyAlias_MozColumnRule = 410,
        eCSSPropertyAlias_MozColumnRuleColor = 411,
        eCSSPropertyAlias_MozColumnRuleStyle = 412,
        eCSSPropertyAlias_MozColumnRuleWidth = 413,
        eCSSPropertyAlias_MozColumnWidth = 414,
        eCSSPropertyAlias_MozColumns = 415,
        eCSSPropertyAlias_WebkitAnimation = 416,
        eCSSPropertyAlias_WebkitAnimationDelay = 417,
        eCSSPropertyAlias_WebkitAnimationDirection = 418,
        eCSSPropertyAlias_WebkitAnimationDuration = 419,
        eCSSPropertyAlias_WebkitAnimationFillMode = 420,
        eCSSPropertyAlias_WebkitAnimationIterationCount = 421,
        eCSSPropertyAlias_WebkitAnimationName = 422,
        eCSSPropertyAlias_WebkitAnimationPlayState = 423,
        eCSSPropertyAlias_WebkitAnimationTimingFunction = 424,
        eCSSPropertyAlias_WebkitFilter = 425,
        eCSSPropertyAlias_WebkitTextSizeAdjust = 426,
        eCSSPropertyAlias_WebkitTransform = 427,
        eCSSPropertyAlias_WebkitTransformOrigin = 428,
        eCSSPropertyAlias_WebkitTransformStyle = 429,
        eCSSPropertyAlias_WebkitBackfaceVisibility = 430,
        eCSSPropertyAlias_WebkitPerspective = 431,
        eCSSPropertyAlias_WebkitPerspectiveOrigin = 432,
        eCSSPropertyAlias_WebkitTransition = 433,
        eCSSPropertyAlias_WebkitTransitionDelay = 434,
        eCSSPropertyAlias_WebkitTransitionDuration = 435,
        eCSSPropertyAlias_WebkitTransitionProperty = 436,
        eCSSPropertyAlias_WebkitTransitionTimingFunction = 437,
        eCSSPropertyAlias_WebkitBorderRadius = 438,
        eCSSPropertyAlias_WebkitBorderTopLeftRadius = 439,
        eCSSPropertyAlias_WebkitBorderTopRightRadius = 440,
        eCSSPropertyAlias_WebkitBorderBottomLeftRadius = 441,
        eCSSPropertyAlias_WebkitBorderBottomRightRadius = 442,
        eCSSPropertyAlias_WebkitBackgroundClip = 443,
        eCSSPropertyAlias_WebkitBackgroundOrigin = 444,
        eCSSPropertyAlias_WebkitBackgroundSize = 445,
        eCSSPropertyAlias_WebkitBorderImage = 446,
        eCSSPropertyAlias_WebkitBoxShadow = 447,
        eCSSPropertyAlias_WebkitBoxSizing = 448,
        eCSSPropertyAlias_WebkitBoxFlex = 449,
        eCSSPropertyAlias_WebkitBoxOrdinalGroup = 450,
        eCSSPropertyAlias_WebkitBoxOrient = 451,
        eCSSPropertyAlias_WebkitBoxDirection = 452,
        eCSSPropertyAlias_WebkitBoxAlign = 453,
        eCSSPropertyAlias_WebkitBoxPack = 454,
        eCSSPropertyAlias_WebkitFlexDirection = 455,
        eCSSPropertyAlias_WebkitFlexWrap = 456,
        eCSSPropertyAlias_WebkitFlexFlow = 457,
        eCSSPropertyAlias_WebkitOrder = 458,
        eCSSPropertyAlias_WebkitFlex = 459,
        eCSSPropertyAlias_WebkitFlexGrow = 460,
        eCSSPropertyAlias_WebkitFlexShrink = 461,
        eCSSPropertyAlias_WebkitFlexBasis = 462,
        eCSSPropertyAlias_WebkitJustifyContent = 463,
        eCSSPropertyAlias_WebkitAlignItems = 464,
        eCSSPropertyAlias_WebkitAlignSelf = 465,
        eCSSPropertyAlias_WebkitAlignContent = 466,
        eCSSPropertyAlias_WebkitUserSelect = 467,
        eCSSPropertyAlias_WebkitMask = 468,
        eCSSPropertyAlias_WebkitMaskClip = 469,
        eCSSPropertyAlias_WebkitMaskComposite = 470,
        eCSSPropertyAlias_WebkitMaskImage = 471,
        eCSSPropertyAlias_WebkitMaskOrigin = 472,
        eCSSPropertyAlias_WebkitMaskPosition = 473,
        eCSSPropertyAlias_WebkitMaskPositionX = 474,
        eCSSPropertyAlias_WebkitMaskPositionY = 475,
        eCSSPropertyAlias_WebkitMaskRepeat = 476,
        eCSSPropertyAlias_WebkitMaskSize = 477,
        eCSSPropertyExtra_no_properties = 478,
        eCSSPropertyExtra_all_properties = 479,
        eCSSPropertyExtra_x_none_value = 480,
        eCSSPropertyExtra_x_auto_value = 481,
        eCSSPropertyExtra_variable = 482,
        eCSSProperty_DOM = 483,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSCounterDesc {
        eCSSCounterDesc_UNKNOWN = -1,
        eCSSCounterDesc_System = 0,
        eCSSCounterDesc_Symbols = 1,
        eCSSCounterDesc_AdditiveSymbols = 2,
        eCSSCounterDesc_Negative = 3,
        eCSSCounterDesc_Prefix = 4,
        eCSSCounterDesc_Suffix = 5,
        eCSSCounterDesc_Range = 6,
        eCSSCounterDesc_Pad = 7,
        eCSSCounterDesc_Fallback = 8,
        eCSSCounterDesc_SpeakAs = 9,
        eCSSCounterDesc_COUNT = 10,
    }
    pub const nsStyleStructID_nsStyleStructID_DUMMY1: root::nsStyleStructID =
        nsStyleStructID::nsStyleStructID_None;
    pub const nsStyleStructID_eStyleStruct_Font: root::nsStyleStructID =
        nsStyleStructID::nsStyleStructID_Inherited_Start;
    pub const nsStyleStructID_nsStyleStructID_DUMMY2: root::nsStyleStructID =
        nsStyleStructID::eStyleStruct_Variables;
    pub const nsStyleStructID_eStyleStruct_Background: root::nsStyleStructID =
        nsStyleStructID::nsStyleStructID_Reset_Start;
    pub const nsStyleStructID_nsStyleStructID_Inherited_Count:
              root::nsStyleStructID =
        nsStyleStructID::nsStyleStructID_Reset_Start;
    pub const nsStyleStructID_nsStyleStructID_Reset_Count:
              root::nsStyleStructID =
        nsStyleStructID::eStyleStruct_Table;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleStructID {
        nsStyleStructID_None = -1,
        nsStyleStructID_Inherited_Start = 0,
        eStyleStruct_Color = 1,
        eStyleStruct_List = 2,
        eStyleStruct_Text = 3,
        eStyleStruct_Visibility = 4,
        eStyleStruct_UserInterface = 5,
        eStyleStruct_TableBorder = 6,
        eStyleStruct_SVG = 7,
        eStyleStruct_Variables = 8,
        nsStyleStructID_Reset_Start = 9,
        eStyleStruct_Position = 10,
        eStyleStruct_TextReset = 11,
        eStyleStruct_Display = 12,
        eStyleStruct_Content = 13,
        eStyleStruct_UIReset = 14,
        eStyleStruct_Table = 15,
        eStyleStruct_Margin = 16,
        eStyleStruct_Padding = 17,
        eStyleStruct_Border = 18,
        eStyleStruct_Outline = 19,
        eStyleStruct_XUL = 20,
        eStyleStruct_SVGReset = 21,
        eStyleStruct_Column = 22,
        eStyleStruct_Effects = 23,
        nsStyleStructID_Length = 24,
    }
    #[repr(u32)]
    /// Types of animatable values.
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleAnimType {
        eStyleAnimType_Custom = 0,
        eStyleAnimType_Coord = 1,
        eStyleAnimType_Sides_Top = 2,
        eStyleAnimType_Sides_Right = 3,
        eStyleAnimType_Sides_Bottom = 4,
        eStyleAnimType_Sides_Left = 5,
        eStyleAnimType_Corner_TopLeft = 6,
        eStyleAnimType_Corner_TopRight = 7,
        eStyleAnimType_Corner_BottomRight = 8,
        eStyleAnimType_Corner_BottomLeft = 9,
        eStyleAnimType_nscoord = 10,
        eStyleAnimType_float = 11,
        eStyleAnimType_Color = 12,
        eStyleAnimType_ComplexColor = 13,
        eStyleAnimType_PaintServer = 14,
        eStyleAnimType_Shadow = 15,
        eStyleAnimType_Discrete = 16,
        eStyleAnimType_None = 17,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCSSProps {
        pub _address: u8,
    }
    pub use self::super::root::mozilla::CSSEnabledState as
            nsCSSProps_EnabledState;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCSSProps_KTableEntry {
        pub mKeyword: root::nsCSSKeyword,
        pub mValue: i16,
    }
    #[test]
    fn bindgen_test_layout_nsCSSProps_KTableEntry() {
        assert_eq!(::std::mem::size_of::<nsCSSProps_KTableEntry>() , 4usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSProps_KTableEntry ) ));
        assert_eq! (::std::mem::align_of::<nsCSSProps_KTableEntry>() , 2usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsCSSProps_KTableEntry )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSProps_KTableEntry ) ) . mKeyword
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSProps_KTableEntry ) , "::" , stringify ! ( mKeyword )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSProps_KTableEntry ) ) . mValue
                    as * const _ as usize } , 2usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSProps_KTableEntry ) , "::" , stringify ! ( mValue )
                    ));
    }
    impl Clone for nsCSSProps_KTableEntry {
        fn clone(&self) -> Self { *self }
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps9kSIDTableE"]
        pub static mut nsCSSProps_kSIDTable:
                   [root::nsStyleStructID; 322usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kKeywordTableTableE"]
        pub static mut nsCSSProps_kKeywordTableTable:
                   [*const root::nsCSSProps_KTableEntry; 322usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kAnimTypeTableE"]
        pub static mut nsCSSProps_kAnimTypeTable:
                   [root::nsStyleAnimType; 322usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kStyleStructOffsetTableE"]
        pub static mut nsCSSProps_kStyleStructOffsetTable: [isize; 322usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps11kFlagsTableE"]
        pub static mut nsCSSProps_kFlagsTable: [u32; 370usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kParserVariantTableE"]
        pub static mut nsCSSProps_kParserVariantTable: [u32; 322usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kSubpropertyTableE"]
        pub static mut nsCSSProps_kSubpropertyTable:
                   [*const root::nsCSSPropertyID; 48usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps26gShorthandsContainingTableE"]
        pub static mut nsCSSProps_gShorthandsContainingTable:
                   [*mut root::nsCSSPropertyID; 322usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25gShorthandsContainingPoolE"]
        pub static mut nsCSSProps_gShorthandsContainingPool:
                   *mut root::nsCSSPropertyID;
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps22gPropertyCountInStructE"]
        pub static mut nsCSSProps_gPropertyCountInStruct: [usize; 24usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps22gPropertyIndexInStructE"]
        pub static mut nsCSSProps_gPropertyIndexInStruct: [usize; 322usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kLogicalGroupTableE"]
        pub static mut nsCSSProps_kLogicalGroupTable:
                   [*const root::nsCSSPropertyID; 9usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16gPropertyEnabledE"]
        pub static mut nsCSSProps_gPropertyEnabled: [bool; 478usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps13kIDLNameTableE"]
        pub static mut nsCSSProps_kIDLNameTable:
                   [*const ::std::os::raw::c_char; 370usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kIDLNameSortPositionTableE"]
        pub static mut nsCSSProps_kIDLNameSortPositionTable: [i32; 370usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19gPropertyUseCounterE"]
        pub static mut nsCSSProps_gPropertyUseCounter:
                   [root::mozilla::UseCounter; 322usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kAnimationDirectionKTableE"]
        pub static mut nsCSSProps_kAnimationDirectionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps24kAnimationFillModeKTableE"]
        pub static mut nsCSSProps_kAnimationFillModeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps30kAnimationIterationCountKTableE"]
        pub static mut nsCSSProps_kAnimationIterationCountKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kAnimationPlayStateKTableE"]
        pub static mut nsCSSProps_kAnimationPlayStateKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps30kAnimationTimingFunctionKTableE"]
        pub static mut nsCSSProps_kAnimationTimingFunctionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kAppearanceKTableE"]
        pub static mut nsCSSProps_kAppearanceKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kAzimuthKTableE"]
        pub static mut nsCSSProps_kAzimuthKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kBackfaceVisibilityKTableE"]
        pub static mut nsCSSProps_kBackfaceVisibilityKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kTransformStyleKTableE"]
        pub static mut nsCSSProps_kTransformStyleKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kImageLayerAttachmentKTableE"]
        pub static mut nsCSSProps_kImageLayerAttachmentKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kBackgroundOriginKTableE"]
        pub static mut nsCSSProps_kBackgroundOriginKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kMaskOriginKTableE"]
        pub static mut nsCSSProps_kMaskOriginKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kImageLayerPositionKTableE"]
        pub static mut nsCSSProps_kImageLayerPositionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kImageLayerRepeatKTableE"]
        pub static mut nsCSSProps_kImageLayerRepeatKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kImageLayerRepeatPartKTableE"]
        pub static mut nsCSSProps_kImageLayerRepeatPartKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kImageLayerSizeKTableE"]
        pub static mut nsCSSProps_kImageLayerSizeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps26kImageLayerCompositeKTableE"]
        pub static mut nsCSSProps_kImageLayerCompositeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kImageLayerModeKTableE"]
        pub static mut nsCSSProps_kImageLayerModeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kBackgroundClipKTableE"]
        pub static mut nsCSSProps_kBackgroundClipKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kMaskClipKTableE"]
        pub static mut nsCSSProps_kMaskClipKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kBlendModeKTableE"]
        pub static mut nsCSSProps_kBlendModeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kBorderCollapseKTableE"]
        pub static mut nsCSSProps_kBorderCollapseKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps24kBorderImageRepeatKTableE"]
        pub static mut nsCSSProps_kBorderImageRepeatKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kBorderImageSliceKTableE"]
        pub static mut nsCSSProps_kBorderImageSliceKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kBorderStyleKTableE"]
        pub static mut nsCSSProps_kBorderStyleKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kBorderWidthKTableE"]
        pub static mut nsCSSProps_kBorderWidthKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kBoxAlignKTableE"]
        pub static mut nsCSSProps_kBoxAlignKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kBoxDecorationBreakKTableE"]
        pub static mut nsCSSProps_kBoxDecorationBreakKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kBoxDirectionKTableE"]
        pub static mut nsCSSProps_kBoxDirectionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kBoxOrientKTableE"]
        pub static mut nsCSSProps_kBoxOrientKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kBoxPackKTableE"]
        pub static mut nsCSSProps_kBoxPackKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps26kClipPathGeometryBoxKTableE"]
        pub static mut nsCSSProps_kClipPathGeometryBoxKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kCounterRangeKTableE"]
        pub static mut nsCSSProps_kCounterRangeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kCounterSpeakAsKTableE"]
        pub static mut nsCSSProps_kCounterSpeakAsKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kCounterSymbolsSystemKTableE"]
        pub static mut nsCSSProps_kCounterSymbolsSystemKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kCounterSystemKTableE"]
        pub static mut nsCSSProps_kCounterSystemKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kDominantBaselineKTableE"]
        pub static mut nsCSSProps_kDominantBaselineKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kShapeRadiusKTableE"]
        pub static mut nsCSSProps_kShapeRadiusKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kFillRuleKTableE"]
        pub static mut nsCSSProps_kFillRuleKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kFilterFunctionKTableE"]
        pub static mut nsCSSProps_kFilterFunctionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kImageRenderingKTableE"]
        pub static mut nsCSSProps_kImageRenderingKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kShapeOutsideShapeBoxKTableE"]
        pub static mut nsCSSProps_kShapeOutsideShapeBoxKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kShapeRenderingKTableE"]
        pub static mut nsCSSProps_kShapeRenderingKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kStrokeLinecapKTableE"]
        pub static mut nsCSSProps_kStrokeLinecapKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kStrokeLinejoinKTableE"]
        pub static mut nsCSSProps_kStrokeLinejoinKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kStrokeContextValueKTableE"]
        pub static mut nsCSSProps_kStrokeContextValueKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kVectorEffectKTableE"]
        pub static mut nsCSSProps_kVectorEffectKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kTextAnchorKTableE"]
        pub static mut nsCSSProps_kTextAnchorKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kTextRenderingKTableE"]
        pub static mut nsCSSProps_kTextRenderingKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kColorAdjustKTableE"]
        pub static mut nsCSSProps_kColorAdjustKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kColorInterpolationKTableE"]
        pub static mut nsCSSProps_kColorInterpolationKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kColumnFillKTableE"]
        pub static mut nsCSSProps_kColumnFillKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kColumnSpanKTableE"]
        pub static mut nsCSSProps_kColumnSpanKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kBoxPropSourceKTableE"]
        pub static mut nsCSSProps_kBoxPropSourceKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kBoxShadowTypeKTableE"]
        pub static mut nsCSSProps_kBoxShadowTypeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kBoxSizingKTableE"]
        pub static mut nsCSSProps_kBoxSizingKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kCaptionSideKTableE"]
        pub static mut nsCSSProps_kCaptionSideKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps12kClearKTableE"]
        pub static mut nsCSSProps_kClearKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps12kColorKTableE"]
        pub static mut nsCSSProps_kColorKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kContentKTableE"]
        pub static mut nsCSSProps_kContentKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps33kControlCharacterVisibilityKTableE"]
        pub static mut nsCSSProps_kControlCharacterVisibilityKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps13kCursorKTableE"]
        pub static mut nsCSSProps_kCursorKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kDirectionKTableE"]
        pub static mut nsCSSProps_kDirectionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kDisplayKTableE"]
        pub static mut nsCSSProps_kDisplayKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kElevationKTableE"]
        pub static mut nsCSSProps_kElevationKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kEmptyCellsKTableE"]
        pub static mut nsCSSProps_kEmptyCellsKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kAlignAllKeywordsE"]
        pub static mut nsCSSProps_kAlignAllKeywords:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps22kAlignOverflowPositionE"]
        pub static mut nsCSSProps_kAlignOverflowPosition:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kAlignSelfPositionE"]
        pub static mut nsCSSProps_kAlignSelfPosition:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps12kAlignLegacyE"]
        pub static mut nsCSSProps_kAlignLegacy:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kAlignLegacyPositionE"]
        pub static mut nsCSSProps_kAlignLegacyPosition:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps31kAlignAutoNormalStretchBaselineE"]
        pub static mut nsCSSProps_kAlignAutoNormalStretchBaseline:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kAlignNormalStretchBaselineE"]
        pub static mut nsCSSProps_kAlignNormalStretchBaseline:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kAlignNormalBaselineE"]
        pub static mut nsCSSProps_kAlignNormalBaseline:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kAlignContentDistributionE"]
        pub static mut nsCSSProps_kAlignContentDistribution:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kAlignContentPositionE"]
        pub static mut nsCSSProps_kAlignContentPosition:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps31kAutoCompletionAlignJustifySelfE"]
        pub static mut nsCSSProps_kAutoCompletionAlignJustifySelf:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kAutoCompletionAlignItemsE"]
        pub static mut nsCSSProps_kAutoCompletionAlignItems:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps34kAutoCompletionAlignJustifyContentE"]
        pub static mut nsCSSProps_kAutoCompletionAlignJustifyContent:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kFlexDirectionKTableE"]
        pub static mut nsCSSProps_kFlexDirectionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kFlexWrapKTableE"]
        pub static mut nsCSSProps_kFlexWrapKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps12kFloatKTableE"]
        pub static mut nsCSSProps_kFloatKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kFloatEdgeKTableE"]
        pub static mut nsCSSProps_kFloatEdgeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kFontDisplayKTableE"]
        pub static mut nsCSSProps_kFontDisplayKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps11kFontKTableE"]
        pub static mut nsCSSProps_kFontKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kFontKerningKTableE"]
        pub static mut nsCSSProps_kFontKerningKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kFontSizeKTableE"]
        pub static mut nsCSSProps_kFontSizeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kFontSmoothingKTableE"]
        pub static mut nsCSSProps_kFontSmoothingKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kFontStretchKTableE"]
        pub static mut nsCSSProps_kFontStretchKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kFontStyleKTableE"]
        pub static mut nsCSSProps_kFontStyleKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kFontSynthesisKTableE"]
        pub static mut nsCSSProps_kFontSynthesisKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kFontVariantKTableE"]
        pub static mut nsCSSProps_kFontVariantKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps28kFontVariantAlternatesKTableE"]
        pub static mut nsCSSProps_kFontVariantAlternatesKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps33kFontVariantAlternatesFuncsKTableE"]
        pub static mut nsCSSProps_kFontVariantAlternatesFuncsKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps22kFontVariantCapsKTableE"]
        pub static mut nsCSSProps_kFontVariantCapsKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kFontVariantEastAsianKTableE"]
        pub static mut nsCSSProps_kFontVariantEastAsianKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kFontVariantLigaturesKTableE"]
        pub static mut nsCSSProps_kFontVariantLigaturesKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kFontVariantNumericKTableE"]
        pub static mut nsCSSProps_kFontVariantNumericKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps26kFontVariantPositionKTableE"]
        pub static mut nsCSSProps_kFontVariantPositionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kFontWeightKTableE"]
        pub static mut nsCSSProps_kFontWeightKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kGridAutoFlowKTableE"]
        pub static mut nsCSSProps_kGridAutoFlowKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kGridTrackBreadthKTableE"]
        pub static mut nsCSSProps_kGridTrackBreadthKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kHyphensKTableE"]
        pub static mut nsCSSProps_kHyphensKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kImageOrientationKTableE"]
        pub static mut nsCSSProps_kImageOrientationKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kImageOrientationFlipKTableE"]
        pub static mut nsCSSProps_kImageOrientationFlipKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kIsolationKTableE"]
        pub static mut nsCSSProps_kIsolationKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kIMEModeKTableE"]
        pub static mut nsCSSProps_kIMEModeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kLineHeightKTableE"]
        pub static mut nsCSSProps_kLineHeightKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps24kListStylePositionKTableE"]
        pub static mut nsCSSProps_kListStylePositionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kMaskTypeKTableE"]
        pub static mut nsCSSProps_kMaskTypeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kMathVariantKTableE"]
        pub static mut nsCSSProps_kMathVariantKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kMathDisplayKTableE"]
        pub static mut nsCSSProps_kMathDisplayKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kContainKTableE"]
        pub static mut nsCSSProps_kContainKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kContextOpacityKTableE"]
        pub static mut nsCSSProps_kContextOpacityKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kContextPatternKTableE"]
        pub static mut nsCSSProps_kContextPatternKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kObjectFitKTableE"]
        pub static mut nsCSSProps_kObjectFitKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps13kOrientKTableE"]
        pub static mut nsCSSProps_kOrientKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kOutlineStyleKTableE"]
        pub static mut nsCSSProps_kOutlineStyleKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kOverflowKTableE"]
        pub static mut nsCSSProps_kOverflowKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kOverflowSubKTableE"]
        pub static mut nsCSSProps_kOverflowSubKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps22kOverflowClipBoxKTableE"]
        pub static mut nsCSSProps_kOverflowClipBoxKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kOverflowWrapKTableE"]
        pub static mut nsCSSProps_kOverflowWrapKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kPageBreakKTableE"]
        pub static mut nsCSSProps_kPageBreakKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps22kPageBreakInsideKTableE"]
        pub static mut nsCSSProps_kPageBreakInsideKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kPageMarksKTableE"]
        pub static mut nsCSSProps_kPageMarksKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kPageSizeKTableE"]
        pub static mut nsCSSProps_kPageSizeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps12kPitchKTableE"]
        pub static mut nsCSSProps_kPitchKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kPointerEventsKTableE"]
        pub static mut nsCSSProps_kPointerEventsKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kPositionKTableE"]
        pub static mut nsCSSProps_kPositionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps26kRadialGradientShapeKTableE"]
        pub static mut nsCSSProps_kRadialGradientShapeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kRadialGradientSizeKTableE"]
        pub static mut nsCSSProps_kRadialGradientSizeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps31kRadialGradientLegacySizeKTableE"]
        pub static mut nsCSSProps_kRadialGradientLegacySizeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps13kResizeKTableE"]
        pub static mut nsCSSProps_kResizeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kRubyAlignKTableE"]
        pub static mut nsCSSProps_kRubyAlignKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kRubyPositionKTableE"]
        pub static mut nsCSSProps_kRubyPositionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kScrollBehaviorKTableE"]
        pub static mut nsCSSProps_kScrollBehaviorKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kScrollSnapTypeKTableE"]
        pub static mut nsCSSProps_kScrollSnapTypeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps12kSpeakKTableE"]
        pub static mut nsCSSProps_kSpeakKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kSpeakHeaderKTableE"]
        pub static mut nsCSSProps_kSpeakHeaderKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kSpeakNumeralKTableE"]
        pub static mut nsCSSProps_kSpeakNumeralKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kSpeakPunctuationKTableE"]
        pub static mut nsCSSProps_kSpeakPunctuationKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kSpeechRateKTableE"]
        pub static mut nsCSSProps_kSpeechRateKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kStackSizingKTableE"]
        pub static mut nsCSSProps_kStackSizingKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kTableLayoutKTableE"]
        pub static mut nsCSSProps_kTableLayoutKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kTextAlignKTableE"]
        pub static mut nsCSSProps_kTextAlignKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kTextAlignLastKTableE"]
        pub static mut nsCSSProps_kTextAlignLastKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kTextCombineUprightKTableE"]
        pub static mut nsCSSProps_kTextCombineUprightKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kTextDecorationLineKTableE"]
        pub static mut nsCSSProps_kTextDecorationLineKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps26kTextDecorationStyleKTableE"]
        pub static mut nsCSSProps_kTextDecorationStyleKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kTextEmphasisPositionKTableE"]
        pub static mut nsCSSProps_kTextEmphasisPositionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps28kTextEmphasisStyleFillKTableE"]
        pub static mut nsCSSProps_kTextEmphasisStyleFillKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps29kTextEmphasisStyleShapeKTableE"]
        pub static mut nsCSSProps_kTextEmphasisStyleShapeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kTextJustifyKTableE"]
        pub static mut nsCSSProps_kTextJustifyKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps22kTextOrientationKTableE"]
        pub static mut nsCSSProps_kTextOrientationKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kTextOverflowKTableE"]
        pub static mut nsCSSProps_kTextOverflowKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kTextSizeAdjustKTableE"]
        pub static mut nsCSSProps_kTextSizeAdjustKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kTextTransformKTableE"]
        pub static mut nsCSSProps_kTextTransformKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kTouchActionKTableE"]
        pub static mut nsCSSProps_kTouchActionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kTopLayerKTableE"]
        pub static mut nsCSSProps_kTopLayerKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kTransformBoxKTableE"]
        pub static mut nsCSSProps_kTransformBoxKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps31kTransitionTimingFunctionKTableE"]
        pub static mut nsCSSProps_kTransitionTimingFunctionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kUnicodeBidiKTableE"]
        pub static mut nsCSSProps_kUnicodeBidiKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kUserFocusKTableE"]
        pub static mut nsCSSProps_kUserFocusKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kUserInputKTableE"]
        pub static mut nsCSSProps_kUserInputKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kUserModifyKTableE"]
        pub static mut nsCSSProps_kUserModifyKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kUserSelectKTableE"]
        pub static mut nsCSSProps_kUserSelectKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kVerticalAlignKTableE"]
        pub static mut nsCSSProps_kVerticalAlignKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kVisibilityKTableE"]
        pub static mut nsCSSProps_kVisibilityKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps13kVolumeKTableE"]
        pub static mut nsCSSProps_kVolumeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kWhitespaceKTableE"]
        pub static mut nsCSSProps_kWhitespaceKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps12kWidthKTableE"]
        pub static mut nsCSSProps_kWidthKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kWindowDraggingKTableE"]
        pub static mut nsCSSProps_kWindowDraggingKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kWindowShadowKTableE"]
        pub static mut nsCSSProps_kWindowShadowKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kWordBreakKTableE"]
        pub static mut nsCSSProps_kWordBreakKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kWritingModeKTableE"]
        pub static mut nsCSSProps_kWritingModeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    #[test]
    fn bindgen_test_layout_nsCSSProps() {
        assert_eq!(::std::mem::size_of::<nsCSSProps>() , 1usize , concat ! (
                   "Size of: " , stringify ! ( nsCSSProps ) ));
        assert_eq! (::std::mem::align_of::<nsCSSProps>() , 1usize , concat ! (
                    "Alignment of " , stringify ! ( nsCSSProps ) ));
    }
    impl Clone for nsCSSProps {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsILabelableRunnable {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsILabelableRunnable_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsILabelableRunnable() {
        assert_eq!(::std::mem::size_of::<nsILabelableRunnable>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsILabelableRunnable ) ));
        assert_eq! (::std::mem::align_of::<nsILabelableRunnable>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsILabelableRunnable ) ));
    }
    impl Clone for nsILabelableRunnable {
        fn clone(&self) -> Self { *self }
    }
    /// Class to safely handle main-thread-only pointers off the main thread.
    ///
    /// Classes like XPCWrappedJS are main-thread-only, which means that it is
    /// forbidden to call methods on instances of these classes off the main thread.
    /// For various reasons (see bug 771074), this restriction recently began to
    /// apply to AddRef/Release as well.
    ///
    /// This presents a problem for consumers that wish to hold a callback alive
    /// on non-main-thread code. A common example of this is the proxy callback
    /// pattern, where non-main-thread code holds a strong-reference to the callback
    /// object, and dispatches new Runnables (also with a strong reference) to the
    /// main thread in order to execute the callback. This involves several AddRef
    /// and Release calls on the other thread, which is (now) verboten.
    ///
    /// The basic idea of this class is to introduce a layer of indirection.
    /// nsMainThreadPtrHolder is a threadsafe reference-counted class that internally
    /// maintains one strong reference to the main-thread-only object. It must be
    /// instantiated on the main thread (so that the AddRef of the underlying object
    /// happens on the main thread), but consumers may subsequently pass references
    /// to the holder anywhere they please. These references are meant to be opaque
    /// when accessed off-main-thread (assertions enforce this).
    ///
    /// The semantics of RefPtr<nsMainThreadPtrHolder<T> > would be cumbersome, so
    /// we also introduce nsMainThreadPtrHandle<T>, which is conceptually identical
    /// to the above (though it includes various convenience methods). The basic
    /// pattern is as follows.
    ///
    /// // On the main thread:
    /// nsCOMPtr<nsIFooCallback> callback = ...;
    /// nsMainThreadPtrHandle<nsIFooCallback> callbackHandle =
    /// new nsMainThreadPtrHolder<nsIFooCallback>(callback);
    /// // Pass callbackHandle to structs/classes that might be accessed on other
    /// // threads.
    ///
    /// All structs and classes that might be accessed on other threads should store
    /// an nsMainThreadPtrHandle<T> rather than an nsCOMPtr<T>.
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMainThreadPtrHolder<T> {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mRawPtr: *mut T,
        pub mStrict: bool,
        pub mMainThreadEventTarget: root::nsCOMPtr<root::nsIEventTarget>,
        pub mName: *const ::std::os::raw::c_char,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    pub type nsMainThreadPtrHolder_HasThreadSafeRefCnt =
        root::mozilla::TrueType;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMainThreadPtrHandle<T> {
        pub mPtr: root::RefPtr<root::nsMainThreadPtrHolder<T>>,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct imgRequestProxy {
        pub _base: root::imgIRequest,
        pub _base_1: root::mozilla::image::IProgressObserver,
        pub _base_2: root::nsISupportsPriority,
        pub _base_3: root::nsISecurityInfoProvider,
        pub _base_4: root::nsITimedChannel,
        pub mRefCnt: root::nsAutoRefCnt,
        pub _mOwningThread: root::nsAutoOwningThread,
        pub mBehaviour: root::mozilla::UniquePtr<root::ProxyBehaviour>,
        pub mURI: root::RefPtr<root::imgRequestProxy_ImageURL>,
        pub mListener: *mut root::imgINotificationObserver,
        pub mLoadGroup: root::nsCOMPtr<root::nsILoadGroup>,
        pub mTabGroup: root::RefPtr<root::mozilla::dom::TabGroup>,
        pub mEventTarget: root::nsCOMPtr<root::nsIEventTarget>,
        pub mLoadFlags: root::nsLoadFlags,
        pub mLockCount: u32,
        pub mAnimationConsumers: u32,
        pub _bitfield_1: u8,
        pub __bindgen_padding_0: [u8; 3usize],
    }
    pub type imgRequestProxy_Image = root::mozilla::image::Image;
    pub type imgRequestProxy_ImageURL = root::mozilla::image::ImageURL;
    pub type imgRequestProxy_ProgressTracker =
        root::mozilla::image::ProgressTracker;
    pub type imgRequestProxy_HasThreadSafeRefCnt = root::mozilla::FalseType;
    #[repr(C)]
    #[derive(Debug)]
    pub struct imgRequestProxy_imgCancelRunnable {
        pub _base: root::mozilla::Runnable,
        pub mOwner: root::RefPtr<root::imgRequestProxy>,
        pub mStatus: root::nsresult,
    }
    #[test]
    fn bindgen_test_layout_imgRequestProxy_imgCancelRunnable() {
        assert_eq!(::std::mem::size_of::<imgRequestProxy_imgCancelRunnable>()
                   , 56usize , concat ! (
                   "Size of: " , stringify ! (
                   imgRequestProxy_imgCancelRunnable ) ));
        assert_eq! (::std::mem::align_of::<imgRequestProxy_imgCancelRunnable>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    imgRequestProxy_imgCancelRunnable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const imgRequestProxy_imgCancelRunnable ) )
                    . mOwner as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    imgRequestProxy_imgCancelRunnable ) , "::" , stringify ! (
                    mOwner ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const imgRequestProxy_imgCancelRunnable ) )
                    . mStatus as * const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    imgRequestProxy_imgCancelRunnable ) , "::" , stringify ! (
                    mStatus ) ));
    }
    #[test]
    fn bindgen_test_layout_imgRequestProxy() {
        assert_eq!(::std::mem::size_of::<imgRequestProxy>() , 128usize ,
                   concat ! ( "Size of: " , stringify ! ( imgRequestProxy )
                   ));
        assert_eq! (::std::mem::align_of::<imgRequestProxy>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( imgRequestProxy ) ));
    }
    impl imgRequestProxy {
        #[inline]
        pub fn mCanceled(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 1u64 as u8;
            let val = (unit_field_val & mask) >> 0usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mCanceled(&mut self, val: bool) {
            let mask = 1u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 0usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn mIsInLoadGroup(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 2u64 as u8;
            let val = (unit_field_val & mask) >> 1usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsInLoadGroup(&mut self, val: bool) {
            let mask = 2u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 1usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn mListenerIsStrongRef(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 4u64 as u8;
            let val = (unit_field_val & mask) >> 2usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mListenerIsStrongRef(&mut self, val: bool) {
            let mask = 4u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 2usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn mDecodeRequested(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 8u64 as u8;
            let val = (unit_field_val & mask) >> 3usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mDecodeRequested(&mut self, val: bool) {
            let mask = 8u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 3usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn mDeferNotifications(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 16u64 as u8;
            let val = (unit_field_val & mask) >> 4usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mDeferNotifications(&mut self, val: bool) {
            let mask = 16u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 4usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn mHadListener(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 32u64 as u8;
            let val = (unit_field_val & mask) >> 5usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHadListener(&mut self, val: bool) {
            let mask = 32u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 5usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn mHadDispatch(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 64u64 as u8;
            let val = (unit_field_val & mask) >> 6usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mHadDispatch(&mut self, val: bool) {
            let mask = 64u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 6usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn new_bitfield_1(mCanceled: bool, mIsInLoadGroup: bool,
                              mListenerIsStrongRef: bool,
                              mDecodeRequested: bool,
                              mDeferNotifications: bool, mHadListener: bool,
                              mHadDispatch: bool) -> u8 {
            ({
                 ({
                      ({
                           ({
                                ({
                                     ({
                                          ({ 0 } |
                                               ((mCanceled as u8 as u8) <<
                                                    0usize) & (1u64 as u8))
                                      } |
                                          ((mIsInLoadGroup as u8 as u8) <<
                                               1usize) & (2u64 as u8))
                                 } |
                                     ((mListenerIsStrongRef as u8 as u8) <<
                                          2usize) & (4u64 as u8))
                            } |
                                ((mDecodeRequested as u8 as u8) << 3usize) &
                                    (8u64 as u8))
                       } |
                           ((mDeferNotifications as u8 as u8) << 4usize) &
                               (16u64 as u8))
                  } | ((mHadListener as u8 as u8) << 5usize) & (32u64 as u8))
             } | ((mHadDispatch as u8 as u8) << 6usize) & (64u64 as u8))
        }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSUnit {
        eCSSUnit_Null = 0,
        eCSSUnit_Auto = 1,
        eCSSUnit_Inherit = 2,
        eCSSUnit_Initial = 3,
        eCSSUnit_Unset = 4,
        eCSSUnit_None = 5,
        eCSSUnit_Normal = 6,
        eCSSUnit_System_Font = 7,
        eCSSUnit_All = 8,
        eCSSUnit_Dummy = 9,
        eCSSUnit_DummyInherit = 10,
        eCSSUnit_String = 11,
        eCSSUnit_Ident = 12,
        eCSSUnit_Attr = 14,
        eCSSUnit_Local_Font = 15,
        eCSSUnit_Font_Format = 16,
        eCSSUnit_Element = 17,
        eCSSUnit_Array = 20,
        eCSSUnit_Counter = 21,
        eCSSUnit_Counters = 22,
        eCSSUnit_Cubic_Bezier = 23,
        eCSSUnit_Steps = 24,
        eCSSUnit_Symbols = 25,
        eCSSUnit_Function = 26,
        eCSSUnit_Calc = 30,
        eCSSUnit_Calc_Plus = 31,
        eCSSUnit_Calc_Minus = 32,
        eCSSUnit_Calc_Times_L = 33,
        eCSSUnit_Calc_Times_R = 34,
        eCSSUnit_Calc_Divided = 35,
        eCSSUnit_URL = 40,
        eCSSUnit_Image = 41,
        eCSSUnit_Gradient = 42,
        eCSSUnit_TokenStream = 43,
        eCSSUnit_GridTemplateAreas = 44,
        eCSSUnit_Pair = 50,
        eCSSUnit_Triplet = 51,
        eCSSUnit_Rect = 52,
        eCSSUnit_List = 53,
        eCSSUnit_ListDep = 54,
        eCSSUnit_SharedList = 55,
        eCSSUnit_PairList = 56,
        eCSSUnit_PairListDep = 57,
        eCSSUnit_FontFamilyList = 58,
        eCSSUnit_AtomIdent = 60,
        eCSSUnit_Integer = 70,
        eCSSUnit_Enumerated = 71,
        eCSSUnit_EnumColor = 80,
        eCSSUnit_RGBColor = 81,
        eCSSUnit_RGBAColor = 82,
        eCSSUnit_HexColor = 83,
        eCSSUnit_ShortHexColor = 84,
        eCSSUnit_HexColorAlpha = 85,
        eCSSUnit_ShortHexColorAlpha = 86,
        eCSSUnit_PercentageRGBColor = 87,
        eCSSUnit_PercentageRGBAColor = 88,
        eCSSUnit_HSLColor = 89,
        eCSSUnit_HSLAColor = 90,
        eCSSUnit_ComplexColor = 91,
        eCSSUnit_Percent = 100,
        eCSSUnit_Number = 101,
        eCSSUnit_PhysicalMillimeter = 200,
        eCSSUnit_ViewportWidth = 700,
        eCSSUnit_ViewportHeight = 701,
        eCSSUnit_ViewportMin = 702,
        eCSSUnit_ViewportMax = 703,
        eCSSUnit_EM = 800,
        eCSSUnit_XHeight = 801,
        eCSSUnit_Char = 802,
        eCSSUnit_RootEM = 803,
        eCSSUnit_Point = 900,
        eCSSUnit_Inch = 901,
        eCSSUnit_Millimeter = 902,
        eCSSUnit_Centimeter = 903,
        eCSSUnit_Pica = 904,
        eCSSUnit_Quarter = 905,
        eCSSUnit_Pixel = 906,
        eCSSUnit_Degree = 1000,
        eCSSUnit_Grad = 1001,
        eCSSUnit_Radian = 1002,
        eCSSUnit_Turn = 1003,
        eCSSUnit_Hertz = 2000,
        eCSSUnit_Kilohertz = 2001,
        eCSSUnit_Seconds = 3000,
        eCSSUnit_Milliseconds = 3001,
        eCSSUnit_FlexFraction = 4000,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueGradient {
        pub mIsRadial: bool,
        pub mIsRepeating: bool,
        pub mIsLegacySyntax: bool,
        pub mIsMozLegacySyntax: bool,
        pub mIsExplicitSize: bool,
        pub mBgPos: root::nsCSSValuePair,
        pub mAngle: root::nsCSSValue,
        pub mRadialValues: [root::nsCSSValue; 2usize],
        pub mStops: root::nsTArray<root::nsCSSValueGradientStop>,
        pub mRefCnt: root::nsAutoRefCnt,
        pub _mOwningThread: root::nsAutoOwningThread,
    }
    pub type nsCSSValueGradient_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValueGradient() {
        assert_eq!(::std::mem::size_of::<nsCSSValueGradient>() , 112usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCSSValueGradient )
                   ));
        assert_eq! (::std::mem::align_of::<nsCSSValueGradient>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueGradient ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) . mIsRadial as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mIsRadial ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) . mIsRepeating
                    as * const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mIsRepeating ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) .
                    mIsLegacySyntax as * const _ as usize } , 2usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mIsLegacySyntax ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) .
                    mIsMozLegacySyntax as * const _ as usize } , 3usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mIsMozLegacySyntax ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) .
                    mIsExplicitSize as * const _ as usize } , 4usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mIsExplicitSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) . mBgPos as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mBgPos ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) . mAngle as *
                    const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mAngle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) .
                    mRadialValues as * const _ as usize } , 56usize , concat !
                    (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mRadialValues ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) . mStops as *
                    const _ as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mStops ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) . mRefCnt as *
                    const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) .
                    _mOwningThread as * const _ as usize } , 104usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( _mOwningThread ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValuePair {
        pub mXValue: root::nsCSSValue,
        pub mYValue: root::nsCSSValue,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValuePair() {
        assert_eq!(::std::mem::size_of::<nsCSSValuePair>() , 32usize , concat
                   ! ( "Size of: " , stringify ! ( nsCSSValuePair ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValuePair>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsCSSValuePair ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePair ) ) . mXValue as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValuePair ) ,
                    "::" , stringify ! ( mXValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePair ) ) . mYValue as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValuePair ) ,
                    "::" , stringify ! ( mYValue ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValuePair_heap {
        pub _base: root::nsCSSValuePair,
        pub mRefCnt: root::nsAutoRefCnt,
        pub _mOwningThread: root::nsAutoOwningThread,
    }
    pub type nsCSSValuePair_heap_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValuePair_heap() {
        assert_eq!(::std::mem::size_of::<nsCSSValuePair_heap>() , 48usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSValuePair_heap ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValuePair_heap>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValuePair_heap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePair_heap ) ) . mRefCnt as
                    * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValuePair_heap
                    ) , "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePair_heap ) ) .
                    _mOwningThread as * const _ as usize } , 40usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsCSSValuePair_heap
                    ) , "::" , stringify ! ( _mOwningThread ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueTokenStream {
        pub mRefCnt: root::nsAutoRefCnt,
        pub _mOwningThread: root::nsAutoOwningThread,
        pub mPropertyID: root::nsCSSPropertyID,
        pub mShorthandPropertyID: root::nsCSSPropertyID,
        pub mTokenStream: ::nsstring::nsStringRepr,
        pub mBaseURI: root::nsCOMPtr<root::nsIURI>,
        pub mSheetURI: root::nsCOMPtr<root::nsIURI>,
        pub mSheetPrincipal: root::nsCOMPtr<root::nsIPrincipal>,
        pub mLineNumber: u32,
        pub mLineOffset: u32,
        pub mLevel: root::mozilla::SheetType,
    }
    pub type nsCSSValueTokenStream_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValueTokenStream() {
        assert_eq!(::std::mem::size_of::<nsCSSValueTokenStream>() , 80usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSValueTokenStream ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValueTokenStream>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueTokenStream )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) . mRefCnt
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! ( mRefCnt )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) .
                    _mOwningThread as * const _ as usize } , 8usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! (
                    _mOwningThread ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) .
                    mPropertyID as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! ( mPropertyID
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) .
                    mShorthandPropertyID as * const _ as usize } , 20usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! (
                    mShorthandPropertyID ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) .
                    mTokenStream as * const _ as usize } , 24usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! (
                    mTokenStream ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) . mBaseURI
                    as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! ( mBaseURI )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) . mSheetURI
                    as * const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! ( mSheetURI )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) .
                    mSheetPrincipal as * const _ as usize } , 56usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! (
                    mSheetPrincipal ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) .
                    mLineNumber as * const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! ( mLineNumber
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) .
                    mLineOffset as * const _ as usize } , 68usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! ( mLineOffset
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) . mLevel as
                    * const _ as usize } , 72usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! ( mLevel )
                    ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSRect {
        pub mTop: root::nsCSSValue,
        pub mRight: root::nsCSSValue,
        pub mBottom: root::nsCSSValue,
        pub mLeft: root::nsCSSValue,
    }
    pub type nsCSSRect_side_type = *mut root::nsCSSValue;
    extern "C" {
        #[link_name = "_ZN9nsCSSRect5sidesE"]
        pub static mut nsCSSRect_sides: [root::nsCSSRect_side_type; 4usize];
    }
    #[test]
    fn bindgen_test_layout_nsCSSRect() {
        assert_eq!(::std::mem::size_of::<nsCSSRect>() , 64usize , concat ! (
                   "Size of: " , stringify ! ( nsCSSRect ) ));
        assert_eq! (::std::mem::align_of::<nsCSSRect>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsCSSRect ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSRect ) ) . mTop as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSRect ) , "::"
                    , stringify ! ( mTop ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSRect ) ) . mRight as * const _
                    as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSRect ) , "::"
                    , stringify ! ( mRight ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSRect ) ) . mBottom as * const _
                    as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSRect ) , "::"
                    , stringify ! ( mBottom ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSRect ) ) . mLeft as * const _ as
                    usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSRect ) , "::"
                    , stringify ! ( mLeft ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSRect_heap {
        pub _base: root::nsCSSRect,
        pub mRefCnt: root::nsAutoRefCnt,
        pub _mOwningThread: root::nsAutoOwningThread,
    }
    pub type nsCSSRect_heap_HasThreadSafeRefCnt = root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSRect_heap() {
        assert_eq!(::std::mem::size_of::<nsCSSRect_heap>() , 80usize , concat
                   ! ( "Size of: " , stringify ! ( nsCSSRect_heap ) ));
        assert_eq! (::std::mem::align_of::<nsCSSRect_heap>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsCSSRect_heap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSRect_heap ) ) . mRefCnt as *
                    const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSRect_heap ) ,
                    "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSRect_heap ) ) . _mOwningThread
                    as * const _ as usize } , 72usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSRect_heap ) ,
                    "::" , stringify ! ( _mOwningThread ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueList {
        pub mValue: root::nsCSSValue,
        pub mNext: *mut root::nsCSSValueList,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValueList() {
        assert_eq!(::std::mem::size_of::<nsCSSValueList>() , 24usize , concat
                   ! ( "Size of: " , stringify ! ( nsCSSValueList ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValueList>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsCSSValueList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueList ) ) . mValue as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueList ) ,
                    "::" , stringify ! ( mValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueList ) ) . mNext as * const
                    _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueList ) ,
                    "::" , stringify ! ( mNext ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueList_heap {
        pub _base: root::nsCSSValueList,
        pub mRefCnt: root::nsAutoRefCnt,
        pub _mOwningThread: root::nsAutoOwningThread,
    }
    pub type nsCSSValueList_heap_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValueList_heap() {
        assert_eq!(::std::mem::size_of::<nsCSSValueList_heap>() , 40usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSValueList_heap ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValueList_heap>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueList_heap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueList_heap ) ) . mRefCnt as
                    * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueList_heap
                    ) , "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueList_heap ) ) .
                    _mOwningThread as * const _ as usize } , 32usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueList_heap
                    ) , "::" , stringify ! ( _mOwningThread ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueSharedList {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mHead: *mut root::nsCSSValueList,
    }
    pub type nsCSSValueSharedList_HasThreadSafeRefCnt =
        root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsCSSValueSharedList() {
        assert_eq!(::std::mem::size_of::<nsCSSValueSharedList>() , 16usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSValueSharedList ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValueSharedList>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueSharedList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueSharedList ) ) . mRefCnt as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueSharedList ) , "::" , stringify ! ( mRefCnt )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueSharedList ) ) . mHead as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueSharedList ) , "::" , stringify ! ( mHead ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValuePairList {
        pub mXValue: root::nsCSSValue,
        pub mYValue: root::nsCSSValue,
        pub mNext: *mut root::nsCSSValuePairList,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValuePairList() {
        assert_eq!(::std::mem::size_of::<nsCSSValuePairList>() , 40usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCSSValuePairList )
                   ));
        assert_eq! (::std::mem::align_of::<nsCSSValuePairList>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValuePairList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePairList ) ) . mXValue as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValuePairList
                    ) , "::" , stringify ! ( mXValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePairList ) ) . mYValue as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValuePairList
                    ) , "::" , stringify ! ( mYValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePairList ) ) . mNext as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValuePairList
                    ) , "::" , stringify ! ( mNext ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValuePairList_heap {
        pub _base: root::nsCSSValuePairList,
        pub mRefCnt: root::nsAutoRefCnt,
        pub _mOwningThread: root::nsAutoOwningThread,
    }
    pub type nsCSSValuePairList_heap_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValuePairList_heap() {
        assert_eq!(::std::mem::size_of::<nsCSSValuePairList_heap>() , 56usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsCSSValuePairList_heap ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValuePairList_heap>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsCSSValuePairList_heap )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePairList_heap ) ) . mRefCnt
                    as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValuePairList_heap ) , "::" , stringify ! ( mRefCnt )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePairList_heap ) ) .
                    _mOwningThread as * const _ as usize } , 48usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValuePairList_heap ) , "::" , stringify ! (
                    _mOwningThread ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueTriplet {
        pub mXValue: root::nsCSSValue,
        pub mYValue: root::nsCSSValue,
        pub mZValue: root::nsCSSValue,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValueTriplet() {
        assert_eq!(::std::mem::size_of::<nsCSSValueTriplet>() , 48usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCSSValueTriplet )
                   ));
        assert_eq! (::std::mem::align_of::<nsCSSValueTriplet>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueTriplet ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTriplet ) ) . mXValue as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueTriplet )
                    , "::" , stringify ! ( mXValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTriplet ) ) . mYValue as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueTriplet )
                    , "::" , stringify ! ( mYValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTriplet ) ) . mZValue as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueTriplet )
                    , "::" , stringify ! ( mZValue ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueTriplet_heap {
        pub _base: root::nsCSSValueTriplet,
        pub mRefCnt: root::nsAutoRefCnt,
        pub _mOwningThread: root::nsAutoOwningThread,
    }
    pub type nsCSSValueTriplet_heap_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValueTriplet_heap() {
        assert_eq!(::std::mem::size_of::<nsCSSValueTriplet_heap>() , 64usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSValueTriplet_heap ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValueTriplet_heap>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueTriplet_heap )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTriplet_heap ) ) . mRefCnt
                    as * const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTriplet_heap ) , "::" , stringify ! ( mRefCnt )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTriplet_heap ) ) .
                    _mOwningThread as * const _ as usize } , 56usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTriplet_heap ) , "::" , stringify ! (
                    _mOwningThread ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueFloatColor {
        pub mRefCnt: root::nsAutoRefCnt,
        pub _mOwningThread: root::nsAutoOwningThread,
        pub mComponent1: f32,
        pub mComponent2: f32,
        pub mComponent3: f32,
        pub mAlpha: f32,
    }
    pub type nsCSSValueFloatColor_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValueFloatColor() {
        assert_eq!(::std::mem::size_of::<nsCSSValueFloatColor>() , 32usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSValueFloatColor ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValueFloatColor>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueFloatColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueFloatColor ) ) . mRefCnt as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueFloatColor ) , "::" , stringify ! ( mRefCnt )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueFloatColor ) ) .
                    _mOwningThread as * const _ as usize } , 8usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueFloatColor ) , "::" , stringify ! (
                    _mOwningThread ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueFloatColor ) ) .
                    mComponent1 as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueFloatColor ) , "::" , stringify ! ( mComponent1
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueFloatColor ) ) .
                    mComponent2 as * const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueFloatColor ) , "::" , stringify ! ( mComponent2
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueFloatColor ) ) .
                    mComponent3 as * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueFloatColor ) , "::" , stringify ! ( mComponent3
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueFloatColor ) ) . mAlpha as
                    * const _ as usize } , 28usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueFloatColor ) , "::" , stringify ! ( mAlpha ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValue {
        pub mUnit: root::nsCSSUnit,
        pub mValue: root::nsCSSValue__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValue_Array {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mCount: usize,
        pub mArray: [root::nsCSSValue; 1usize],
    }
    pub type nsCSSValue_Array_HasThreadSafeRefCnt = root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsCSSValue_Array() {
        assert_eq!(::std::mem::size_of::<nsCSSValue_Array>() , 32usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCSSValue_Array )
                   ));
        assert_eq! (::std::mem::align_of::<nsCSSValue_Array>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValue_Array ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue_Array ) ) . mRefCnt as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValue_Array )
                    , "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue_Array ) ) . mCount as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValue_Array )
                    , "::" , stringify ! ( mCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue_Array ) ) . mArray as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValue_Array )
                    , "::" , stringify ! ( mArray ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCSSValue__bindgen_ty_1 {
        pub mInt: root::__BindgenUnionField<i32>,
        pub mFloat: root::__BindgenUnionField<f32>,
        pub mString: root::__BindgenUnionField<*mut root::nsStringBuffer>,
        pub mColor: root::__BindgenUnionField<root::nscolor>,
        pub mAtom: root::__BindgenUnionField<*mut root::nsIAtom>,
        pub mArray: root::__BindgenUnionField<*mut root::nsCSSValue_Array>,
        pub mURL: root::__BindgenUnionField<*mut root::mozilla::css::URLValue>,
        pub mImage: root::__BindgenUnionField<*mut root::mozilla::css::ImageValue>,
        pub mGridTemplateAreas: root::__BindgenUnionField<*mut root::mozilla::css::GridTemplateAreasValue>,
        pub mGradient: root::__BindgenUnionField<*mut root::nsCSSValueGradient>,
        pub mTokenStream: root::__BindgenUnionField<*mut root::nsCSSValueTokenStream>,
        pub mPair: root::__BindgenUnionField<*mut root::nsCSSValuePair_heap>,
        pub mRect: root::__BindgenUnionField<*mut root::nsCSSRect_heap>,
        pub mTriplet: root::__BindgenUnionField<*mut root::nsCSSValueTriplet_heap>,
        pub mList: root::__BindgenUnionField<*mut root::nsCSSValueList_heap>,
        pub mListDependent: root::__BindgenUnionField<*mut root::nsCSSValueList>,
        pub mSharedList: root::__BindgenUnionField<*mut root::nsCSSValueSharedList>,
        pub mPairList: root::__BindgenUnionField<*mut root::nsCSSValuePairList_heap>,
        pub mPairListDependent: root::__BindgenUnionField<*mut root::nsCSSValuePairList>,
        pub mFloatColor: root::__BindgenUnionField<*mut root::nsCSSValueFloatColor>,
        pub mFontFamilyList: root::__BindgenUnionField<*mut root::mozilla::css::FontFamilyListRefCnt>,
        pub mComplexColor: root::__BindgenUnionField<*mut root::mozilla::css::ComplexColorValue>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValue__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsCSSValue__bindgen_ty_1>() , 8usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValue__bindgen_ty_1>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsCSSValue__bindgen_ty_1 )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mInt
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mInt )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mFloat
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mFloat )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mString as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mString
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mColor
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mColor )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mAtom
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mAtom )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mArray
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mArray )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mURL
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mURL )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mImage
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mImage )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mGridTemplateAreas as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mGridTemplateAreas ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mGradient as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mGradient ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mTokenStream as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mTokenStream ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mPair
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mPair )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mRect
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mRect )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mTriplet as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mTriplet
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mList
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mList )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mListDependent as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mListDependent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mSharedList as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mSharedList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mPairList as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mPairList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mPairListDependent as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mPairListDependent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mFloatColor as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mFloatColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mFontFamilyList as * const _ as usize } , 0usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mFontFamilyList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mComplexColor as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mComplexColor ) ));
    }
    impl Clone for nsCSSValue__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsCSSValue() {
        assert_eq!(::std::mem::size_of::<nsCSSValue>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsCSSValue ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValue>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsCSSValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue ) ) . mUnit as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValue ) , "::"
                    , stringify ! ( mUnit ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue ) ) . mValue as * const _
                    as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValue ) , "::"
                    , stringify ! ( mValue ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueGradientStop {
        pub mLocation: root::nsCSSValue,
        pub mColor: root::nsCSSValue,
        pub mIsInterpolationHint: bool,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValueGradientStop() {
        assert_eq!(::std::mem::size_of::<nsCSSValueGradientStop>() , 40usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSValueGradientStop ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValueGradientStop>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueGradientStop )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradientStop ) ) .
                    mLocation as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueGradientStop ) , "::" , stringify ! ( mLocation
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradientStop ) ) . mColor
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueGradientStop ) , "::" , stringify ! ( mColor )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradientStop ) ) .
                    mIsInterpolationHint as * const _ as usize } , 32usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueGradientStop ) , "::" , stringify ! (
                    mIsInterpolationHint ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct imgIContainer {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsISecurityInfoProvider {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISecurityInfoProvider_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsISecurityInfoProvider() {
        assert_eq!(::std::mem::size_of::<nsISecurityInfoProvider>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsISecurityInfoProvider ) ));
        assert_eq! (::std::mem::align_of::<nsISecurityInfoProvider>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsISecurityInfoProvider )
                    ));
    }
    impl Clone for nsISecurityInfoProvider {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsISupportsPriority {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISupportsPriority_COMTypeInfo {
        pub _address: u8,
    }
    pub const nsISupportsPriority_PRIORITY_HIGHEST:
              root::nsISupportsPriority__bindgen_ty_1 =
        nsISupportsPriority__bindgen_ty_1::PRIORITY_HIGHEST;
    pub const nsISupportsPriority_PRIORITY_HIGH:
              root::nsISupportsPriority__bindgen_ty_1 =
        nsISupportsPriority__bindgen_ty_1::PRIORITY_HIGH;
    pub const nsISupportsPriority_PRIORITY_NORMAL:
              root::nsISupportsPriority__bindgen_ty_1 =
        nsISupportsPriority__bindgen_ty_1::PRIORITY_NORMAL;
    pub const nsISupportsPriority_PRIORITY_LOW:
              root::nsISupportsPriority__bindgen_ty_1 =
        nsISupportsPriority__bindgen_ty_1::PRIORITY_LOW;
    pub const nsISupportsPriority_PRIORITY_LOWEST:
              root::nsISupportsPriority__bindgen_ty_1 =
        nsISupportsPriority__bindgen_ty_1::PRIORITY_LOWEST;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsISupportsPriority__bindgen_ty_1 {
        PRIORITY_HIGHEST = -20,
        PRIORITY_HIGH = -10,
        PRIORITY_NORMAL = 0,
        PRIORITY_LOW = 10,
        PRIORITY_LOWEST = 20,
    }
    #[test]
    fn bindgen_test_layout_nsISupportsPriority() {
        assert_eq!(::std::mem::size_of::<nsISupportsPriority>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsISupportsPriority ) ));
        assert_eq! (::std::mem::align_of::<nsISupportsPriority>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsISupportsPriority ) ));
    }
    impl Clone for nsISupportsPriority {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsITimedChannel {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsITimedChannel_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsITimedChannel() {
        assert_eq!(::std::mem::size_of::<nsITimedChannel>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsITimedChannel ) ));
        assert_eq! (::std::mem::align_of::<nsITimedChannel>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsITimedChannel ) ));
    }
    impl Clone for nsITimedChannel {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ProxyBehaviour {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleGradientStop {
        pub mLocation: root::nsStyleCoord,
        pub mColor: root::nscolor,
        pub mIsInterpolationHint: bool,
    }
    #[test]
    fn bindgen_test_layout_nsStyleGradientStop() {
        assert_eq!(::std::mem::size_of::<nsStyleGradientStop>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsStyleGradientStop ) ));
        assert_eq! (::std::mem::align_of::<nsStyleGradientStop>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleGradientStop ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradientStop ) ) . mLocation
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradientStop
                    ) , "::" , stringify ! ( mLocation ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradientStop ) ) . mColor as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradientStop
                    ) , "::" , stringify ! ( mColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradientStop ) ) .
                    mIsInterpolationHint as * const _ as usize } , 20usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradientStop
                    ) , "::" , stringify ! ( mIsInterpolationHint ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleGradient {
        pub mShape: u8,
        pub mSize: u8,
        pub mRepeating: bool,
        pub mLegacySyntax: bool,
        pub mMozLegacySyntax: bool,
        pub mBgPosX: root::nsStyleCoord,
        pub mBgPosY: root::nsStyleCoord,
        pub mAngle: root::nsStyleCoord,
        pub mRadiusX: root::nsStyleCoord,
        pub mRadiusY: root::nsStyleCoord,
        pub mStops: root::nsTArray<root::nsStyleGradientStop>,
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
    }
    pub type nsStyleGradient_HasThreadSafeRefCnt = root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsStyleGradient() {
        assert_eq!(::std::mem::size_of::<nsStyleGradient>() , 104usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleGradient )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleGradient>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleGradient ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mShape as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mShape ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mSize as *
                    const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mRepeating as *
                    const _ as usize } , 2usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mRepeating ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mLegacySyntax
                    as * const _ as usize } , 3usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mLegacySyntax ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) .
                    mMozLegacySyntax as * const _ as usize } , 4usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mMozLegacySyntax ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mBgPosX as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mBgPosX ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mBgPosY as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mBgPosY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mAngle as *
                    const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mAngle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mRadiusX as *
                    const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mRadiusX ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mRadiusY as *
                    const _ as usize } , 72usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mRadiusY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mStops as *
                    const _ as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mStops ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mRefCnt as *
                    const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mRefCnt ) ));
    }
    /// A wrapper for an imgRequestProxy that supports off-main-thread creation
    /// and equality comparison.
    ///
    /// An nsStyleImageRequest can be created in two ways:
    ///
    /// 1. Using the constructor that takes an imgRequestProxy.  This must
    /// be called from the main thread.  The nsStyleImageRequest is
    /// immediately considered "resolved", and the get() method that
    /// returns the imgRequestProxy can be called.
    ///
    /// 2. Using the constructor that takes the URL, base URI, referrer
    /// and principal that can be used to inititiate an image load and
    /// produce an imgRequestProxy later.  This can be called from
    /// any thread.  The nsStyleImageRequest is not considered "resolved"
    /// at this point, and the Resolve() method must be called later
    /// to initiate the image load and make calls to get() valid.
    ///
    /// Calls to TrackImage(), UntrackImage(), LockImage(), UnlockImage() and
    /// RequestDiscard() are made to the imgRequestProxy and ImageTracker as
    /// appropriate, according to the mode flags passed in to the constructor.
    ///
    /// The main thread constructor takes a pointer to the css::ImageValue that
    /// is the specified url() value, while the off-main-thread constructor
    /// creates a new css::ImageValue to represent the url() information passed
    /// to the constructor.  This ImageValue is held on to for the comparisons done
    /// in DefinitelyEquals(), so that we don't need to call into the non-OMT-safe
    /// Equals() on the nsIURI objects returned from imgRequestProxy::GetURI().
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleImageRequest {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mRequestProxy: root::RefPtr<root::imgRequestProxy>,
        pub mImageValue: root::RefPtr<root::mozilla::css::ImageValue>,
        pub mImageTracker: root::RefPtr<root::mozilla::dom::ImageTracker>,
        pub mDocGroup: root::RefPtr<root::mozilla::dom::DocGroup>,
        pub mModeFlags: root::nsStyleImageRequest_Mode,
        pub mResolved: bool,
    }
    pub type nsStyleImageRequest_URLValueData =
        root::mozilla::css::URLValueData;
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageRequest_Mode { Track = 1, Discard = 2, }
    pub type nsStyleImageRequest_HasThreadSafeRefCnt =
        root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsStyleImageRequest() {
        assert_eq!(::std::mem::size_of::<nsStyleImageRequest>() , 48usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsStyleImageRequest ) ));
        assert_eq! (::std::mem::align_of::<nsStyleImageRequest>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleImageRequest ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageRequest ) ) . mRefCnt as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageRequest
                    ) , "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageRequest ) ) .
                    mRequestProxy as * const _ as usize } , 8usize , concat !
                    (
                    "Alignment of field: " , stringify ! ( nsStyleImageRequest
                    ) , "::" , stringify ! ( mRequestProxy ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageRequest ) ) . mImageValue
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageRequest
                    ) , "::" , stringify ! ( mImageValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageRequest ) ) .
                    mImageTracker as * const _ as usize } , 24usize , concat !
                    (
                    "Alignment of field: " , stringify ! ( nsStyleImageRequest
                    ) , "::" , stringify ! ( mImageTracker ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageRequest ) ) . mDocGroup
                    as * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageRequest
                    ) , "::" , stringify ! ( mDocGroup ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageRequest ) ) . mModeFlags
                    as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageRequest
                    ) , "::" , stringify ! ( mModeFlags ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageRequest ) ) . mResolved
                    as * const _ as usize } , 41usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageRequest
                    ) , "::" , stringify ! ( mResolved ) ));
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageType {
        eStyleImageType_Null = 0,
        eStyleImageType_Image = 1,
        eStyleImageType_Gradient = 2,
        eStyleImageType_Element = 3,
        eStyleImageType_URL = 4,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct CachedBorderImageData {
        pub mCachedSVGViewportSize: [u32; 3usize],
        pub mSubImages: root::nsCOMArray,
    }
    #[test]
    fn bindgen_test_layout_CachedBorderImageData() {
        assert_eq!(::std::mem::size_of::<CachedBorderImageData>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( CachedBorderImageData ) ));
        assert_eq! (::std::mem::align_of::<CachedBorderImageData>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( CachedBorderImageData )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CachedBorderImageData ) ) .
                    mCachedSVGViewportSize as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    CachedBorderImageData ) , "::" , stringify ! (
                    mCachedSVGViewportSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CachedBorderImageData ) ) .
                    mSubImages as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CachedBorderImageData ) , "::" , stringify ! ( mSubImages
                    ) ));
    }
    /// Represents a paintable image of one of the following types.
    /// (1) A real image loaded from an external source.
    /// (2) A CSS linear or radial gradient.
    /// (3) An element within a document, or an <img>, <video>, or <canvas> element
    /// not in a document.
    /// (*) Optionally a crop rect can be set to paint a partial (rectangular)
    /// region of an image. (Currently, this feature is only supported with an
    /// image of type (1)).
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleImage {
        pub mCachedBIData: root::mozilla::UniquePtr<root::CachedBorderImageData>,
        pub mType: root::nsStyleImageType,
        pub __bindgen_anon_1: root::nsStyleImage__bindgen_ty_1,
        pub mCropRect: root::mozilla::UniquePtr<root::nsStyleSides>,
    }
    pub type nsStyleImage_URLValue = root::mozilla::css::URLValue;
    pub type nsStyleImage_URLValueData = root::mozilla::css::URLValueData;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleImage__bindgen_ty_1 {
        pub mImage: root::__BindgenUnionField<*mut root::nsStyleImageRequest>,
        pub mGradient: root::__BindgenUnionField<*mut root::nsStyleGradient>,
        pub mURLValue: root::__BindgenUnionField<*mut root::nsStyleImage_URLValue>,
        pub mElementId: root::__BindgenUnionField<*mut root::nsIAtom>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsStyleImage__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleImage__bindgen_ty_1>() ,
                   8usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleImage__bindgen_ty_1 )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleImage__bindgen_ty_1>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsStyleImage__bindgen_ty_1
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImage__bindgen_ty_1 ) ) .
                    mImage as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImage__bindgen_ty_1 ) , "::" , stringify ! ( mImage
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImage__bindgen_ty_1 ) ) .
                    mGradient as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImage__bindgen_ty_1 ) , "::" , stringify ! (
                    mGradient ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImage__bindgen_ty_1 ) ) .
                    mURLValue as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImage__bindgen_ty_1 ) , "::" , stringify ! (
                    mURLValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImage__bindgen_ty_1 ) ) .
                    mElementId as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImage__bindgen_ty_1 ) , "::" , stringify ! (
                    mElementId ) ));
    }
    impl Clone for nsStyleImage__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsStyleImage() {
        assert_eq!(::std::mem::size_of::<nsStyleImage>() , 32usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleImage ) ));
        assert_eq! (::std::mem::align_of::<nsStyleImage>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleImage ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImage ) ) . mCachedBIData as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImage ) ,
                    "::" , stringify ! ( mCachedBIData ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImage ) ) . mType as * const _
                    as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImage ) ,
                    "::" , stringify ! ( mType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImage ) ) . mCropRect as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImage ) ,
                    "::" , stringify ! ( mCropRect ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleImageLayers {
        pub mAttachmentCount: u32,
        pub mClipCount: u32,
        pub mOriginCount: u32,
        pub mRepeatCount: u32,
        pub mPositionXCount: u32,
        pub mPositionYCount: u32,
        pub mImageCount: u32,
        pub mSizeCount: u32,
        pub mMaskModeCount: u32,
        pub mBlendModeCount: u32,
        pub mCompositeCount: u32,
        pub mLayers: root::nsStyleAutoArray<root::nsStyleImageLayers_Layer>,
    }
    pub const nsStyleImageLayers_shorthand:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::shorthand;
    pub const nsStyleImageLayers_color: root::nsStyleImageLayers__bindgen_ty_1
              =
        nsStyleImageLayers__bindgen_ty_1::color;
    pub const nsStyleImageLayers_image: root::nsStyleImageLayers__bindgen_ty_1
              =
        nsStyleImageLayers__bindgen_ty_1::image;
    pub const nsStyleImageLayers_repeat:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::repeat;
    pub const nsStyleImageLayers_positionX:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::positionX;
    pub const nsStyleImageLayers_positionY:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::positionY;
    pub const nsStyleImageLayers_clip: root::nsStyleImageLayers__bindgen_ty_1
              =
        nsStyleImageLayers__bindgen_ty_1::clip;
    pub const nsStyleImageLayers_origin:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::origin;
    pub const nsStyleImageLayers_size: root::nsStyleImageLayers__bindgen_ty_1
              =
        nsStyleImageLayers__bindgen_ty_1::size;
    pub const nsStyleImageLayers_attachment:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::attachment;
    pub const nsStyleImageLayers_maskMode:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::maskMode;
    pub const nsStyleImageLayers_composite:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::composite;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageLayers__bindgen_ty_1 {
        shorthand = 0,
        color = 1,
        image = 2,
        repeat = 3,
        positionX = 4,
        positionY = 5,
        clip = 6,
        origin = 7,
        size = 8,
        attachment = 9,
        maskMode = 10,
        composite = 11,
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageLayers_LayerType { Background = 0, Mask = 1, }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleImageLayers_Size {
        pub mWidth: root::nsStyleImageLayers_Size_Dimension,
        pub mHeight: root::nsStyleImageLayers_Size_Dimension,
        pub mWidthType: u8,
        pub mHeightType: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleImageLayers_Size_Dimension {
        pub _base: root::nsStyleCoord_CalcValue,
    }
    #[test]
    fn bindgen_test_layout_nsStyleImageLayers_Size_Dimension() {
        assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Size_Dimension>()
                   , 12usize , concat ! (
                   "Size of: " , stringify ! (
                   nsStyleImageLayers_Size_Dimension ) ));
        assert_eq! (::std::mem::align_of::<nsStyleImageLayers_Size_Dimension>()
                    , 4usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsStyleImageLayers_Size_Dimension ) ));
    }
    impl Clone for nsStyleImageLayers_Size_Dimension {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageLayers_Size_DimensionType {
        eContain = 0,
        eCover = 1,
        eAuto = 2,
        eLengthPercentage = 3,
        eDimensionType_COUNT = 4,
    }
    #[test]
    fn bindgen_test_layout_nsStyleImageLayers_Size() {
        assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Size>() , 28usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsStyleImageLayers_Size ) ));
        assert_eq! (::std::mem::align_of::<nsStyleImageLayers_Size>() , 4usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsStyleImageLayers_Size )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Size ) ) . mWidth
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Size ) , "::" , stringify ! ( mWidth )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Size ) ) . mHeight
                    as * const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Size ) , "::" , stringify ! ( mHeight )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Size ) ) .
                    mWidthType as * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Size ) , "::" , stringify ! (
                    mWidthType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Size ) ) .
                    mHeightType as * const _ as usize } , 25usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Size ) , "::" , stringify ! (
                    mHeightType ) ));
    }
    impl Clone for nsStyleImageLayers_Size {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleImageLayers_Repeat {
        pub mXRepeat: root::mozilla::StyleImageLayerRepeat,
        pub mYRepeat: root::mozilla::StyleImageLayerRepeat,
    }
    #[test]
    fn bindgen_test_layout_nsStyleImageLayers_Repeat() {
        assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Repeat>() , 2usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsStyleImageLayers_Repeat ) ));
        assert_eq! (::std::mem::align_of::<nsStyleImageLayers_Repeat>() ,
                    1usize , concat ! (
                    "Alignment of " , stringify ! ( nsStyleImageLayers_Repeat
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Repeat ) ) .
                    mXRepeat as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Repeat ) , "::" , stringify ! (
                    mXRepeat ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Repeat ) ) .
                    mYRepeat as * const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Repeat ) , "::" , stringify ! (
                    mYRepeat ) ));
    }
    impl Clone for nsStyleImageLayers_Repeat {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleImageLayers_Layer {
        pub mImage: root::nsStyleImage,
        pub mPosition: root::mozilla::Position,
        pub mSize: root::nsStyleImageLayers_Size,
        pub mClip: root::nsStyleImageLayers_Layer_StyleGeometryBox,
        pub mOrigin: root::nsStyleImageLayers_Layer_StyleGeometryBox,
        pub mAttachment: u8,
        pub mBlendMode: u8,
        pub mComposite: u8,
        pub mMaskMode: u8,
        pub mRepeat: root::nsStyleImageLayers_Repeat,
    }
    pub use self::super::root::mozilla::StyleGeometryBox as
            nsStyleImageLayers_Layer_StyleGeometryBox;
    #[test]
    fn bindgen_test_layout_nsStyleImageLayers_Layer() {
        assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Layer>() , 96usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsStyleImageLayers_Layer ) ));
        assert_eq! (::std::mem::align_of::<nsStyleImageLayers_Layer>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsStyleImageLayers_Layer )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) . mImage
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! ( mImage )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) .
                    mPosition as * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! (
                    mPosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) . mSize
                    as * const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! ( mSize )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) . mClip
                    as * const _ as usize } , 84usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! ( mClip )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) .
                    mOrigin as * const _ as usize } , 85usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! ( mOrigin
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) .
                    mAttachment as * const _ as usize } , 86usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! (
                    mAttachment ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) .
                    mBlendMode as * const _ as usize } , 87usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! (
                    mBlendMode ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) .
                    mComposite as * const _ as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! (
                    mComposite ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) .
                    mMaskMode as * const _ as usize } , 89usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! (
                    mMaskMode ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) .
                    mRepeat as * const _ as usize } , 90usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! ( mRepeat
                    ) ));
    }
    extern "C" {
        #[link_name = "_ZN18nsStyleImageLayers21kBackgroundLayerTableE"]
        pub static mut nsStyleImageLayers_kBackgroundLayerTable:
                   [root::nsCSSPropertyID; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN18nsStyleImageLayers15kMaskLayerTableE"]
        pub static mut nsStyleImageLayers_kMaskLayerTable:
                   [root::nsCSSPropertyID; 0usize];
    }
    #[test]
    fn bindgen_test_layout_nsStyleImageLayers() {
        assert_eq!(::std::mem::size_of::<nsStyleImageLayers>() , 152usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleImageLayers )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleImageLayers>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleImageLayers ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) .
                    mAttachmentCount as * const _ as usize } , 0usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mAttachmentCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) . mClipCount
                    as * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mClipCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) . mOriginCount
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mOriginCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) . mRepeatCount
                    as * const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mRepeatCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) .
                    mPositionXCount as * const _ as usize } , 16usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mPositionXCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) .
                    mPositionYCount as * const _ as usize } , 20usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mPositionYCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) . mImageCount
                    as * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mImageCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) . mSizeCount
                    as * const _ as usize } , 28usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mSizeCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) .
                    mMaskModeCount as * const _ as usize } , 32usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mMaskModeCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) .
                    mBlendModeCount as * const _ as usize } , 36usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mBlendModeCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) .
                    mCompositeCount as * const _ as usize } , 40usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mCompositeCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) . mLayers as *
                    const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mLayers ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsBorderColors {
        pub mNext: *mut root::nsBorderColors,
        pub mColor: root::nscolor,
    }
    #[test]
    fn bindgen_test_layout_nsBorderColors() {
        assert_eq!(::std::mem::size_of::<nsBorderColors>() , 16usize , concat
                   ! ( "Size of: " , stringify ! ( nsBorderColors ) ));
        assert_eq! (::std::mem::align_of::<nsBorderColors>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsBorderColors ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsBorderColors ) ) . mNext as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsBorderColors ) ,
                    "::" , stringify ! ( mNext ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsBorderColors ) ) . mColor as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsBorderColors ) ,
                    "::" , stringify ! ( mColor ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSShadowItem {
        pub mXOffset: root::nscoord,
        pub mYOffset: root::nscoord,
        pub mRadius: root::nscoord,
        pub mSpread: root::nscoord,
        pub mColor: root::nscolor,
        pub mHasColor: bool,
        pub mInset: bool,
    }
    #[test]
    fn bindgen_test_layout_nsCSSShadowItem() {
        assert_eq!(::std::mem::size_of::<nsCSSShadowItem>() , 24usize , concat
                   ! ( "Size of: " , stringify ! ( nsCSSShadowItem ) ));
        assert_eq! (::std::mem::align_of::<nsCSSShadowItem>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSShadowItem ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowItem ) ) . mXOffset as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowItem ) ,
                    "::" , stringify ! ( mXOffset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowItem ) ) . mYOffset as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowItem ) ,
                    "::" , stringify ! ( mYOffset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowItem ) ) . mRadius as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowItem ) ,
                    "::" , stringify ! ( mRadius ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowItem ) ) . mSpread as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowItem ) ,
                    "::" , stringify ! ( mSpread ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowItem ) ) . mColor as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowItem ) ,
                    "::" , stringify ! ( mColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowItem ) ) . mHasColor as *
                    const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowItem ) ,
                    "::" , stringify ! ( mHasColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowItem ) ) . mInset as *
                    const _ as usize } , 21usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowItem ) ,
                    "::" , stringify ! ( mInset ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSShadowArray {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mLength: u32,
        pub mArray: [root::nsCSSShadowItem; 1usize],
    }
    pub type nsCSSShadowArray_HasThreadSafeRefCnt = root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsCSSShadowArray() {
        assert_eq!(::std::mem::size_of::<nsCSSShadowArray>() , 40usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCSSShadowArray )
                   ));
        assert_eq! (::std::mem::align_of::<nsCSSShadowArray>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSShadowArray ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowArray ) ) . mRefCnt as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowArray )
                    , "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowArray ) ) . mLength as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowArray )
                    , "::" , stringify ! ( mLength ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowArray ) ) . mArray as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowArray )
                    , "::" , stringify ! ( mArray ) ));
    }
    /// An object that allows sharing of arrays that store 'quotes' property
    /// values.  This is particularly important for inheritance, where we want
    /// to share the same 'quotes' value with a parent style context.
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleQuoteValues {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mQuotePairs: root::nsStyleQuoteValues_QuotePairArray,
    }
    pub type nsStyleQuoteValues_QuotePairArray =
        root::nsTArray<root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr>>;
    pub type nsStyleQuoteValues_HasThreadSafeRefCnt = root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsStyleQuoteValues() {
        assert_eq!(::std::mem::size_of::<nsStyleQuoteValues>() , 16usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleQuoteValues )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleQuoteValues>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleQuoteValues ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleQuoteValues ) ) . mRefCnt as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleQuoteValues
                    ) , "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleQuoteValues ) ) . mQuotePairs
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleQuoteValues
                    ) , "::" , stringify ! ( mQuotePairs ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleGridLine {
        pub mHasSpan: bool,
        pub mInteger: i32,
        pub mLineName: ::nsstring::nsStringRepr,
    }
    pub const nsStyleGridLine_kMinLine: i32 = -10000;
    pub const nsStyleGridLine_kMaxLine: i32 = 10000;
    #[test]
    fn bindgen_test_layout_nsStyleGridLine() {
        assert_eq!(::std::mem::size_of::<nsStyleGridLine>() , 24usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleGridLine ) ));
        assert_eq! (::std::mem::align_of::<nsStyleGridLine>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleGridLine ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridLine ) ) . mHasSpan as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridLine ) ,
                    "::" , stringify ! ( mHasSpan ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridLine ) ) . mInteger as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridLine ) ,
                    "::" , stringify ! ( mInteger ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridLine ) ) . mLineName as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridLine ) ,
                    "::" , stringify ! ( mLineName ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleGridTemplate {
        pub mLineNameLists: root::nsTArray<root::nsTArray<::nsstring::nsStringRepr>>,
        pub mMinTrackSizingFunctions: root::nsTArray<root::nsStyleCoord>,
        pub mMaxTrackSizingFunctions: root::nsTArray<root::nsStyleCoord>,
        pub mRepeatAutoLineNameListBefore: root::nsTArray<::nsstring::nsStringRepr>,
        pub mRepeatAutoLineNameListAfter: root::nsTArray<::nsstring::nsStringRepr>,
        pub mRepeatAutoIndex: i16,
        pub _bitfield_1: u8,
        pub __bindgen_padding_0: [u8; 5usize],
    }
    #[test]
    fn bindgen_test_layout_nsStyleGridTemplate() {
        assert_eq!(::std::mem::size_of::<nsStyleGridTemplate>() , 48usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsStyleGridTemplate ) ));
        assert_eq! (::std::mem::align_of::<nsStyleGridTemplate>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleGridTemplate ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridTemplate ) ) .
                    mLineNameLists as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! ( nsStyleGridTemplate
                    ) , "::" , stringify ! ( mLineNameLists ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridTemplate ) ) .
                    mMinTrackSizingFunctions as * const _ as usize } , 8usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridTemplate
                    ) , "::" , stringify ! ( mMinTrackSizingFunctions ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridTemplate ) ) .
                    mMaxTrackSizingFunctions as * const _ as usize } , 16usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridTemplate
                    ) , "::" , stringify ! ( mMaxTrackSizingFunctions ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridTemplate ) ) .
                    mRepeatAutoLineNameListBefore as * const _ as usize } ,
                    24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridTemplate
                    ) , "::" , stringify ! ( mRepeatAutoLineNameListBefore )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridTemplate ) ) .
                    mRepeatAutoLineNameListAfter as * const _ as usize } ,
                    32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridTemplate
                    ) , "::" , stringify ! ( mRepeatAutoLineNameListAfter )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridTemplate ) ) .
                    mRepeatAutoIndex as * const _ as usize } , 40usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridTemplate
                    ) , "::" , stringify ! ( mRepeatAutoIndex ) ));
    }
    impl nsStyleGridTemplate {
        #[inline]
        pub fn mIsAutoFill(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 1u64 as u8;
            let val = (unit_field_val & mask) >> 0usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsAutoFill(&mut self, val: bool) {
            let mask = 1u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 0usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn mIsSubgrid(&self) -> bool {
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            let mask = 2u64 as u8;
            let val = (unit_field_val & mask) >> 1usize;
            unsafe { ::std::mem::transmute(val as u8) }
        }
        #[inline]
        pub fn set_mIsSubgrid(&mut self, val: bool) {
            let mask = 2u64 as u8;
            let val = val as u8 as u8;
            let mut unit_field_val: u8 =
                unsafe { ::std::mem::uninitialized() };
            unsafe {
                ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _
                                                    as *const u8,
                                                &mut unit_field_val as *mut u8
                                                    as *mut u8,
                                                ::std::mem::size_of::<u8>())
            };
            unit_field_val &= !mask;
            unit_field_val |= (val << 1usize) & mask;
            unsafe {
                ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                    *const u8,
                                                &mut self._bitfield_1 as
                                                    *mut _ as *mut u8,
                                                ::std::mem::size_of::<u8>());
            }
        }
        #[inline]
        pub fn new_bitfield_1(mIsAutoFill: bool, mIsSubgrid: bool) -> u8 {
            ({
                 ({ 0 } |
                      ((mIsAutoFill as u8 as u8) << 0usize) & (1u64 as u8))
             } | ((mIsSubgrid as u8 as u8) << 1usize) & (2u64 as u8))
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleTextOverflowSide {
        pub mString: ::nsstring::nsStringRepr,
        pub mType: u8,
    }
    #[test]
    fn bindgen_test_layout_nsStyleTextOverflowSide() {
        assert_eq!(::std::mem::size_of::<nsStyleTextOverflowSide>() , 24usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsStyleTextOverflowSide ) ));
        assert_eq! (::std::mem::align_of::<nsStyleTextOverflowSide>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsStyleTextOverflowSide )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextOverflowSide ) ) . mString
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleTextOverflowSide ) , "::" , stringify ! ( mString )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextOverflowSide ) ) . mType
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleTextOverflowSide ) , "::" , stringify ! ( mType )
                    ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleTextOverflow {
        pub mLeft: root::nsStyleTextOverflowSide,
        pub mRight: root::nsStyleTextOverflowSide,
        pub mLogicalDirections: bool,
    }
    #[test]
    fn bindgen_test_layout_nsStyleTextOverflow() {
        assert_eq!(::std::mem::size_of::<nsStyleTextOverflow>() , 56usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsStyleTextOverflow ) ));
        assert_eq! (::std::mem::align_of::<nsStyleTextOverflow>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleTextOverflow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextOverflow ) ) . mLeft as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextOverflow
                    ) , "::" , stringify ! ( mLeft ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextOverflow ) ) . mRight as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextOverflow
                    ) , "::" , stringify ! ( mRight ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextOverflow ) ) .
                    mLogicalDirections as * const _ as usize } , 48usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextOverflow
                    ) , "::" , stringify ! ( mLogicalDirections ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleImageOrientation {
        pub mOrientation: u8,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageOrientation_Bits {
        ORIENTATION_MASK = 3,
        FLIP_MASK = 4,
        FROM_IMAGE_MASK = 8,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageOrientation_Angles {
        ANGLE_0 = 0,
        ANGLE_90 = 1,
        ANGLE_180 = 2,
        ANGLE_270 = 3,
    }
    #[test]
    fn bindgen_test_layout_nsStyleImageOrientation() {
        assert_eq!(::std::mem::size_of::<nsStyleImageOrientation>() , 1usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsStyleImageOrientation ) ));
        assert_eq! (::std::mem::align_of::<nsStyleImageOrientation>() , 1usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsStyleImageOrientation )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageOrientation ) ) .
                    mOrientation as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageOrientation ) , "::" , stringify ! (
                    mOrientation ) ));
    }
    impl Clone for nsStyleImageOrientation {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTimingFunction {
        pub mType: root::nsTimingFunction_Type,
        pub __bindgen_anon_1: root::nsTimingFunction__bindgen_ty_1,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsTimingFunction_Type {
        Ease = 0,
        Linear = 1,
        EaseIn = 2,
        EaseOut = 3,
        EaseInOut = 4,
        StepStart = 5,
        StepEnd = 6,
        CubicBezier = 7,
        Frames = 8,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsTimingFunction_Keyword { Implicit = 0, Explicit = 1, }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTimingFunction__bindgen_ty_1 {
        pub mFunc: root::__BindgenUnionField<root::nsTimingFunction__bindgen_ty_1__bindgen_ty_1>,
        pub __bindgen_anon_1: root::__BindgenUnionField<root::nsTimingFunction__bindgen_ty_1__bindgen_ty_2>,
        pub bindgen_union_field: [u32; 4usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTimingFunction__bindgen_ty_1__bindgen_ty_1 {
        pub mX1: f32,
        pub mY1: f32,
        pub mX2: f32,
        pub mY2: f32,
    }
    #[test]
    fn bindgen_test_layout_nsTimingFunction__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsTimingFunction__bindgen_ty_1__bindgen_ty_1>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) ));
        assert_eq! (::std::mem::align_of::<nsTimingFunction__bindgen_ty_1__bindgen_ty_1>()
                    , 4usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsTimingFunction__bindgen_ty_1__bindgen_ty_1
                    ) ) . mX1 as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mX1 ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsTimingFunction__bindgen_ty_1__bindgen_ty_1
                    ) ) . mY1 as * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mY1 ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsTimingFunction__bindgen_ty_1__bindgen_ty_1
                    ) ) . mX2 as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mX2 ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsTimingFunction__bindgen_ty_1__bindgen_ty_1
                    ) ) . mY2 as * const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mY2 ) ));
    }
    impl Clone for nsTimingFunction__bindgen_ty_1__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTimingFunction__bindgen_ty_1__bindgen_ty_2 {
        pub mStepsOrFrames: u32,
    }
    #[test]
    fn bindgen_test_layout_nsTimingFunction__bindgen_ty_1__bindgen_ty_2() {
        assert_eq!(::std::mem::size_of::<nsTimingFunction__bindgen_ty_1__bindgen_ty_2>()
                   , 4usize , concat ! (
                   "Size of: " , stringify ! (
                   nsTimingFunction__bindgen_ty_1__bindgen_ty_2 ) ));
        assert_eq! (::std::mem::align_of::<nsTimingFunction__bindgen_ty_1__bindgen_ty_2>()
                    , 4usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsTimingFunction__bindgen_ty_1__bindgen_ty_2 ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsTimingFunction__bindgen_ty_1__bindgen_ty_2
                    ) ) . mStepsOrFrames as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTimingFunction__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                    stringify ! ( mStepsOrFrames ) ));
    }
    impl Clone for nsTimingFunction__bindgen_ty_1__bindgen_ty_2 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsTimingFunction__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsTimingFunction__bindgen_ty_1>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( nsTimingFunction__bindgen_ty_1
                   ) ));
        assert_eq! (::std::mem::align_of::<nsTimingFunction__bindgen_ty_1>() ,
                    4usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsTimingFunction__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsTimingFunction__bindgen_ty_1 ) ) .
                    mFunc as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTimingFunction__bindgen_ty_1 ) , "::" , stringify ! (
                    mFunc ) ));
    }
    impl Clone for nsTimingFunction__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsTimingFunction() {
        assert_eq!(::std::mem::size_of::<nsTimingFunction>() , 20usize ,
                   concat ! ( "Size of: " , stringify ! ( nsTimingFunction )
                   ));
        assert_eq! (::std::mem::align_of::<nsTimingFunction>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsTimingFunction ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsTimingFunction ) ) . mType as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsTimingFunction )
                    , "::" , stringify ! ( mType ) ));
    }
    impl Clone for nsTimingFunction {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct BindingHolder {
        pub mPtr: root::RefPtr<root::mozilla::css::URLValue>,
    }
    #[test]
    fn bindgen_test_layout_BindingHolder() {
        assert_eq!(::std::mem::size_of::<BindingHolder>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( BindingHolder ) ));
        assert_eq! (::std::mem::align_of::<BindingHolder>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( BindingHolder ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const BindingHolder ) ) . mPtr as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( BindingHolder ) ,
                    "::" , stringify ! ( mPtr ) ));
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleContentType {
        eStyleContentType_String = 1,
        eStyleContentType_Image = 10,
        eStyleContentType_Attr = 20,
        eStyleContentType_Counter = 30,
        eStyleContentType_Counters = 31,
        eStyleContentType_OpenQuote = 40,
        eStyleContentType_CloseQuote = 41,
        eStyleContentType_NoOpenQuote = 42,
        eStyleContentType_NoCloseQuote = 43,
        eStyleContentType_AltContent = 50,
        eStyleContentType_Uninitialized = 51,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleContentData {
        pub mType: root::nsStyleContentType,
        pub mContent: root::nsStyleContentData__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleContentData_CounterFunction {
        pub mIdent: ::nsstring::nsStringRepr,
        pub mSeparator: ::nsstring::nsStringRepr,
        pub mCounterStyle: root::mozilla::CounterStylePtr,
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
    }
    pub type nsStyleContentData_CounterFunction_HasThreadSafeRefCnt =
        root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsStyleContentData_CounterFunction() {
        assert_eq!(::std::mem::size_of::<nsStyleContentData_CounterFunction>()
                   , 48usize , concat ! (
                   "Size of: " , stringify ! (
                   nsStyleContentData_CounterFunction ) ));
        assert_eq! (::std::mem::align_of::<nsStyleContentData_CounterFunction>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsStyleContentData_CounterFunction ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData_CounterFunction )
                    ) . mIdent as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleContentData_CounterFunction ) , "::" , stringify !
                    ( mIdent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData_CounterFunction )
                    ) . mSeparator as * const _ as usize } , 16usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleContentData_CounterFunction ) , "::" , stringify !
                    ( mSeparator ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData_CounterFunction )
                    ) . mCounterStyle as * const _ as usize } , 32usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleContentData_CounterFunction ) , "::" , stringify !
                    ( mCounterStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData_CounterFunction )
                    ) . mRefCnt as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleContentData_CounterFunction ) , "::" , stringify !
                    ( mRefCnt ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleContentData__bindgen_ty_1 {
        pub mString: root::__BindgenUnionField<*mut u16>,
        pub mImage: root::__BindgenUnionField<*mut root::nsStyleImageRequest>,
        pub mCounters: root::__BindgenUnionField<*mut root::nsStyleContentData_CounterFunction>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsStyleContentData__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleContentData__bindgen_ty_1>() ,
                   8usize , concat ! (
                   "Size of: " , stringify ! (
                   nsStyleContentData__bindgen_ty_1 ) ));
        assert_eq! (::std::mem::align_of::<nsStyleContentData__bindgen_ty_1>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsStyleContentData__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData__bindgen_ty_1 ) )
                    . mString as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleContentData__bindgen_ty_1 ) , "::" , stringify ! (
                    mString ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData__bindgen_ty_1 ) )
                    . mImage as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleContentData__bindgen_ty_1 ) , "::" , stringify ! (
                    mImage ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData__bindgen_ty_1 ) )
                    . mCounters as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleContentData__bindgen_ty_1 ) , "::" , stringify ! (
                    mCounters ) ));
    }
    impl Clone for nsStyleContentData__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsStyleContentData() {
        assert_eq!(::std::mem::size_of::<nsStyleContentData>() , 16usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleContentData )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleContentData>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleContentData ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData ) ) . mType as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleContentData
                    ) , "::" , stringify ! ( mType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData ) ) . mContent as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleContentData
                    ) , "::" , stringify ! ( mContent ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleCounterData {
        pub mCounter: ::nsstring::nsStringRepr,
        pub mValue: i32,
    }
    #[test]
    fn bindgen_test_layout_nsStyleCounterData() {
        assert_eq!(::std::mem::size_of::<nsStyleCounterData>() , 24usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleCounterData )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleCounterData>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleCounterData ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCounterData ) ) . mCounter as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleCounterData
                    ) , "::" , stringify ! ( mCounter ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCounterData ) ) . mValue as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleCounterData
                    ) , "::" , stringify ! ( mValue ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCursorImage {
        pub mHaveHotspot: bool,
        pub mHotspotX: f32,
        pub mHotspotY: f32,
        pub mImage: root::RefPtr<root::nsStyleImageRequest>,
    }
    #[test]
    fn bindgen_test_layout_nsCursorImage() {
        assert_eq!(::std::mem::size_of::<nsCursorImage>() , 24usize , concat !
                   ( "Size of: " , stringify ! ( nsCursorImage ) ));
        assert_eq! (::std::mem::align_of::<nsCursorImage>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsCursorImage ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCursorImage ) ) . mHaveHotspot as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCursorImage ) ,
                    "::" , stringify ! ( mHaveHotspot ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCursorImage ) ) . mHotspotX as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCursorImage ) ,
                    "::" , stringify ! ( mHotspotX ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCursorImage ) ) . mHotspotY as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCursorImage ) ,
                    "::" , stringify ! ( mHotspotY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCursorImage ) ) . mImage as * const
                    _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCursorImage ) ,
                    "::" , stringify ! ( mImage ) ));
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleSVGPaintType {
        eStyleSVGPaintType_None = 1,
        eStyleSVGPaintType_Color = 2,
        eStyleSVGPaintType_Server = 3,
        eStyleSVGPaintType_ContextFill = 4,
        eStyleSVGPaintType_ContextStroke = 5,
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleSVGFallbackType {
        eStyleSVGFallbackType_NotSet = 0,
        eStyleSVGFallbackType_None = 1,
        eStyleSVGFallbackType_Color = 2,
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleSVGOpacitySource {
        eStyleSVGOpacitySource_Normal = 0,
        eStyleSVGOpacitySource_ContextFillOpacity = 1,
        eStyleSVGOpacitySource_ContextStrokeOpacity = 2,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleSVGPaint {
        pub mPaint: root::nsStyleSVGPaint__bindgen_ty_1,
        pub mType: root::nsStyleSVGPaintType,
        pub mFallbackType: root::nsStyleSVGFallbackType,
        pub mFallbackColor: root::nscolor,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleSVGPaint__bindgen_ty_1 {
        pub mColor: root::__BindgenUnionField<root::nscolor>,
        pub mPaintServer: root::__BindgenUnionField<*mut root::mozilla::css::URLValue>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsStyleSVGPaint__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleSVGPaint__bindgen_ty_1>() ,
                   8usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleSVGPaint__bindgen_ty_1 )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleSVGPaint__bindgen_ty_1>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsStyleSVGPaint__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGPaint__bindgen_ty_1 ) ) .
                    mColor as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleSVGPaint__bindgen_ty_1 ) , "::" , stringify ! (
                    mColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGPaint__bindgen_ty_1 ) ) .
                    mPaintServer as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleSVGPaint__bindgen_ty_1 ) , "::" , stringify ! (
                    mPaintServer ) ));
    }
    impl Clone for nsStyleSVGPaint__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsStyleSVGPaint() {
        assert_eq!(::std::mem::size_of::<nsStyleSVGPaint>() , 16usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleSVGPaint ) ));
        assert_eq! (::std::mem::align_of::<nsStyleSVGPaint>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleSVGPaint ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGPaint ) ) . mPaint as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGPaint ) ,
                    "::" , stringify ! ( mPaint ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGPaint ) ) . mType as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGPaint ) ,
                    "::" , stringify ! ( mType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGPaint ) ) . mFallbackType
                    as * const _ as usize } , 9usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGPaint ) ,
                    "::" , stringify ! ( mFallbackType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGPaint ) ) . mFallbackColor
                    as * const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGPaint ) ,
                    "::" , stringify ! ( mFallbackColor ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleFilter {
        pub mType: u32,
        pub mFilterParameter: root::nsStyleCoord,
        pub __bindgen_anon_1: root::nsStyleFilter__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleFilter__bindgen_ty_1 {
        pub mURL: root::__BindgenUnionField<*mut root::mozilla::css::URLValue>,
        pub mDropShadow: root::__BindgenUnionField<*mut root::nsCSSShadowArray>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsStyleFilter__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleFilter__bindgen_ty_1>() ,
                   8usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleFilter__bindgen_ty_1 )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleFilter__bindgen_ty_1>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsStyleFilter__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFilter__bindgen_ty_1 ) ) .
                    mURL as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleFilter__bindgen_ty_1 ) , "::" , stringify ! ( mURL
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFilter__bindgen_ty_1 ) ) .
                    mDropShadow as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleFilter__bindgen_ty_1 ) , "::" , stringify ! (
                    mDropShadow ) ));
    }
    impl Clone for nsStyleFilter__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    pub const nsStyleFilter_kHasFinishStyle: bool = false;
    #[test]
    fn bindgen_test_layout_nsStyleFilter() {
        assert_eq!(::std::mem::size_of::<nsStyleFilter>() , 32usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleFilter ) ));
        assert_eq! (::std::mem::align_of::<nsStyleFilter>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleFilter ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFilter ) ) . mType as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFilter ) ,
                    "::" , stringify ! ( mType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFilter ) ) . mFilterParameter
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFilter ) ,
                    "::" , stringify ! ( mFilterParameter ) ));
    }
    /// These *_Simple types are used to map Gecko types to layout-equivalent but
    /// simpler Rust types, to aid Rust binding generation.
    ///
    /// If something in this types or the assertions below needs to change, ask
    /// bholley, heycam or emilio before!
    ///
    /// <div rustbindgen="true" replaces="nsPoint">
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsPoint {
        pub x: root::nscoord,
        pub y: root::nscoord,
    }
    #[test]
    fn bindgen_test_layout_nsPoint() {
        assert_eq!(::std::mem::size_of::<nsPoint>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsPoint ) ));
        assert_eq! (::std::mem::align_of::<nsPoint>() , 4usize , concat ! (
                    "Alignment of " , stringify ! ( nsPoint ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPoint ) ) . x as * const _ as usize
                    } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPoint ) , "::" ,
                    stringify ! ( x ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPoint ) ) . y as * const _ as usize
                    } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPoint ) , "::" ,
                    stringify ! ( y ) ));
    }
    impl Clone for nsPoint {
        fn clone(&self) -> Self { *self }
    }
    /// <div rustbindgen="true" replaces="nsMargin">
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsMargin {
        pub top: root::nscoord,
        pub right: root::nscoord,
        pub bottom: root::nscoord,
        pub left: root::nscoord,
    }
    #[test]
    fn bindgen_test_layout_nsMargin() {
        assert_eq!(::std::mem::size_of::<nsMargin>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsMargin ) ));
        assert_eq! (::std::mem::align_of::<nsMargin>() , 4usize , concat ! (
                    "Alignment of " , stringify ! ( nsMargin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMargin ) ) . top as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMargin ) , "::" ,
                    stringify ! ( top ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMargin ) ) . right as * const _ as
                    usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMargin ) , "::" ,
                    stringify ! ( right ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMargin ) ) . bottom as * const _ as
                    usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMargin ) , "::" ,
                    stringify ! ( bottom ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMargin ) ) . left as * const _ as
                    usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMargin ) , "::" ,
                    stringify ! ( left ) ));
    }
    impl Clone for nsMargin {
        fn clone(&self) -> Self { *self }
    }
    /// <div rustbindgen="true" replaces="nsRect">
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsRect {
        pub x: root::nscoord,
        pub y: root::nscoord,
        pub width: root::nscoord,
        pub height: root::nscoord,
    }
    #[test]
    fn bindgen_test_layout_nsRect() {
        assert_eq!(::std::mem::size_of::<nsRect>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsRect ) ));
        assert_eq! (::std::mem::align_of::<nsRect>() , 4usize , concat ! (
                    "Alignment of " , stringify ! ( nsRect ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRect ) ) . x as * const _ as usize
                    } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsRect ) , "::" ,
                    stringify ! ( x ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRect ) ) . y as * const _ as usize
                    } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsRect ) , "::" ,
                    stringify ! ( y ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRect ) ) . width as * const _ as
                    usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsRect ) , "::" ,
                    stringify ! ( width ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRect ) ) . height as * const _ as
                    usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsRect ) , "::" ,
                    stringify ! ( height ) ));
    }
    impl Clone for nsRect {
        fn clone(&self) -> Self { *self }
    }
    /// <div rustbindgen="true" replaces="nsSize">
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsSize {
        pub width: root::nscoord,
        pub height: root::nscoord,
    }
    #[test]
    fn bindgen_test_layout_nsSize() {
        assert_eq!(::std::mem::size_of::<nsSize>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsSize ) ));
        assert_eq! (::std::mem::align_of::<nsSize>() , 4usize , concat ! (
                    "Alignment of " , stringify ! ( nsSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSize ) ) . width as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSize ) , "::" ,
                    stringify ! ( width ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSize ) ) . height as * const _ as
                    usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSize ) , "::" ,
                    stringify ! ( height ) ));
    }
    impl Clone for nsSize {
        fn clone(&self) -> Self { *self }
    }
    /// <div rustbindgen replaces="nsTArray"></div>
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsTArray<T> {
        pub mBuffer: *mut T,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    /// <div rustbindgen replaces="nsCOMArray"></div>
    ///
    /// mozilla::ArrayIterator doesn't work well with bindgen.
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCOMArray {
        pub mBuffer: root::nsTArray<*mut root::nsISupports>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RawServoStyleSet {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RawServoStyleSheetContents {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RawServoDeclarationBlock {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RawServoStyleRule {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RawServoAnimationValue {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RawServoMediaList {
        _unused: [u8; 0],
    }
    pub mod nsStyleTransformMatrix {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum MatrixTransformOperator { Interpolate = 0, Accumulate = 1, }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsCSSPropertyIDSet {
        _unused: [u8; 0],
    }
    pub type RawGeckoNode = root::nsINode;
    pub type RawGeckoElement = root::mozilla::dom::Element;
    pub type RawGeckoDocument = root::nsIDocument;
    pub type RawGeckoPresContext = root::nsPresContext;
    pub type RawGeckoXBLBinding = root::nsXBLBinding;
    pub type RawGeckoURLExtraData = root::mozilla::URLExtraData;
    pub type RawGeckoServoAnimationValueList =
        root::nsTArray<root::RefPtr<root::RawServoAnimationValue>>;
    pub type RawGeckoKeyframeList = root::nsTArray<root::mozilla::Keyframe>;
    pub type RawGeckoPropertyValuePairList =
        root::nsTArray<root::mozilla::PropertyValuePair>;
    pub type RawGeckoComputedKeyframeValuesList =
        root::nsTArray<root::mozilla::ComputedKeyframeValues>;
    pub type RawGeckoStyleAnimationList =
        root::nsStyleAutoArray<root::mozilla::StyleAnimation>;
    pub type RawGeckoFontFaceRuleList =
        root::nsTArray<root::nsFontFaceRuleContainer>;
    pub type RawGeckoAnimationPropertySegment =
        root::mozilla::AnimationPropertySegment;
    pub type RawGeckoComputedTiming = root::mozilla::ComputedTiming;
    pub type RawGeckoServoStyleRuleList =
        root::nsTArray<*const root::RawServoStyleRule>;
    pub type RawGeckoCSSPropertyIDList =
        root::nsTArray<root::nsCSSPropertyID>;
    pub type RawGeckoGfxMatrix4x4 = [root::mozilla::gfx::Float; 16usize];
    pub type RawGeckoStyleChildrenIterator =
        root::mozilla::dom::StyleChildrenIterator;
    pub type ServoStyleContextBorrowed =
        *const root::mozilla::ServoStyleContext;
    pub type ServoStyleContextBorrowedOrNull =
        *const root::mozilla::ServoStyleContext;
    pub type ServoComputedDataBorrowed = *const root::ServoComputedData;
    pub type RawGeckoNodeBorrowed = *const root::RawGeckoNode;
    pub type RawGeckoNodeBorrowedOrNull = *const root::RawGeckoNode;
    pub type RawGeckoElementBorrowed = *const root::RawGeckoElement;
    pub type RawGeckoElementBorrowedOrNull = *const root::RawGeckoElement;
    pub type RawGeckoDocumentBorrowed = *const root::RawGeckoDocument;
    pub type RawGeckoDocumentBorrowedOrNull = *const root::RawGeckoDocument;
    pub type RawGeckoXBLBindingBorrowed = *const root::RawGeckoXBLBinding;
    pub type RawGeckoXBLBindingBorrowedOrNull =
        *const root::RawGeckoXBLBinding;
    pub type RawGeckoPresContextOwned = *mut root::RawGeckoPresContext;
    pub type RawGeckoPresContextBorrowed = *const root::RawGeckoPresContext;
    pub type RawGeckoPresContextBorrowedMut = *mut root::RawGeckoPresContext;
    pub type RawGeckoServoAnimationValueListBorrowedMut =
        *mut root::RawGeckoServoAnimationValueList;
    pub type RawGeckoServoAnimationValueListBorrowed =
        *const root::RawGeckoServoAnimationValueList;
    pub type RawGeckoKeyframeListBorrowedMut =
        *mut root::RawGeckoKeyframeList;
    pub type RawGeckoKeyframeListBorrowed = *const root::RawGeckoKeyframeList;
    pub type RawGeckoPropertyValuePairListBorrowedMut =
        *mut root::RawGeckoPropertyValuePairList;
    pub type RawGeckoPropertyValuePairListBorrowed =
        *const root::RawGeckoPropertyValuePairList;
    pub type RawGeckoComputedKeyframeValuesListBorrowedMut =
        *mut root::RawGeckoComputedKeyframeValuesList;
    pub type RawGeckoStyleAnimationListBorrowed =
        *const root::RawGeckoStyleAnimationList;
    pub type RawGeckoFontFaceRuleListBorrowedMut =
        *mut root::RawGeckoFontFaceRuleList;
    pub type RawGeckoAnimationPropertySegmentBorrowed =
        *const root::RawGeckoAnimationPropertySegment;
    pub type RawGeckoComputedTimingBorrowed =
        *const root::RawGeckoComputedTiming;
    pub type RawGeckoServoStyleRuleListBorrowedMut =
        *mut root::RawGeckoServoStyleRuleList;
    pub type RawGeckoCSSPropertyIDListBorrowed =
        *const root::RawGeckoCSSPropertyIDList;
    pub type RawGeckoStyleChildrenIteratorBorrowedMut =
        *mut root::RawGeckoStyleChildrenIterator;
    pub const ThemeWidgetType_NS_THEME_NONE: root::ThemeWidgetType = 0;
    pub const ThemeWidgetType_NS_THEME_BUTTON: root::ThemeWidgetType = 1;
    pub const ThemeWidgetType_NS_THEME_RADIO: root::ThemeWidgetType = 2;
    pub const ThemeWidgetType_NS_THEME_CHECKBOX: root::ThemeWidgetType = 3;
    pub const ThemeWidgetType_NS_THEME_BUTTON_BEVEL: root::ThemeWidgetType =
        4;
    pub const ThemeWidgetType_NS_THEME_FOCUS_OUTLINE: root::ThemeWidgetType =
        5;
    pub const ThemeWidgetType_NS_THEME_TOOLBOX: root::ThemeWidgetType = 6;
    pub const ThemeWidgetType_NS_THEME_TOOLBAR: root::ThemeWidgetType = 7;
    pub const ThemeWidgetType_NS_THEME_TOOLBARBUTTON: root::ThemeWidgetType =
        8;
    pub const ThemeWidgetType_NS_THEME_DUALBUTTON: root::ThemeWidgetType = 9;
    pub const ThemeWidgetType_NS_THEME_TOOLBARBUTTON_DROPDOWN:
              root::ThemeWidgetType =
        10;
    pub const ThemeWidgetType_NS_THEME_BUTTON_ARROW_UP: root::ThemeWidgetType
              =
        11;
    pub const ThemeWidgetType_NS_THEME_BUTTON_ARROW_DOWN:
              root::ThemeWidgetType =
        12;
    pub const ThemeWidgetType_NS_THEME_BUTTON_ARROW_NEXT:
              root::ThemeWidgetType =
        13;
    pub const ThemeWidgetType_NS_THEME_BUTTON_ARROW_PREVIOUS:
              root::ThemeWidgetType =
        14;
    pub const ThemeWidgetType_NS_THEME_SEPARATOR: root::ThemeWidgetType = 15;
    pub const ThemeWidgetType_NS_THEME_TOOLBARGRIPPER: root::ThemeWidgetType =
        16;
    pub const ThemeWidgetType_NS_THEME_SPLITTER: root::ThemeWidgetType = 17;
    pub const ThemeWidgetType_NS_THEME_STATUSBAR: root::ThemeWidgetType = 18;
    pub const ThemeWidgetType_NS_THEME_STATUSBARPANEL: root::ThemeWidgetType =
        19;
    pub const ThemeWidgetType_NS_THEME_RESIZERPANEL: root::ThemeWidgetType =
        20;
    pub const ThemeWidgetType_NS_THEME_RESIZER: root::ThemeWidgetType = 21;
    pub const ThemeWidgetType_NS_THEME_LISTBOX: root::ThemeWidgetType = 22;
    pub const ThemeWidgetType_NS_THEME_LISTITEM: root::ThemeWidgetType = 23;
    pub const ThemeWidgetType_NS_THEME_TREEVIEW: root::ThemeWidgetType = 24;
    pub const ThemeWidgetType_NS_THEME_TREEITEM: root::ThemeWidgetType = 25;
    pub const ThemeWidgetType_NS_THEME_TREETWISTY: root::ThemeWidgetType = 26;
    pub const ThemeWidgetType_NS_THEME_TREELINE: root::ThemeWidgetType = 27;
    pub const ThemeWidgetType_NS_THEME_TREEHEADER: root::ThemeWidgetType = 28;
    pub const ThemeWidgetType_NS_THEME_TREEHEADERCELL: root::ThemeWidgetType =
        29;
    pub const ThemeWidgetType_NS_THEME_TREEHEADERSORTARROW:
              root::ThemeWidgetType =
        30;
    pub const ThemeWidgetType_NS_THEME_TREETWISTYOPEN: root::ThemeWidgetType =
        31;
    pub const ThemeWidgetType_NS_THEME_PROGRESSBAR: root::ThemeWidgetType =
        32;
    pub const ThemeWidgetType_NS_THEME_PROGRESSCHUNK: root::ThemeWidgetType =
        33;
    pub const ThemeWidgetType_NS_THEME_PROGRESSBAR_VERTICAL:
              root::ThemeWidgetType =
        34;
    pub const ThemeWidgetType_NS_THEME_PROGRESSCHUNK_VERTICAL:
              root::ThemeWidgetType =
        35;
    pub const ThemeWidgetType_NS_THEME_METERBAR: root::ThemeWidgetType = 36;
    pub const ThemeWidgetType_NS_THEME_METERCHUNK: root::ThemeWidgetType = 37;
    pub const ThemeWidgetType_NS_THEME_TAB: root::ThemeWidgetType = 38;
    pub const ThemeWidgetType_NS_THEME_TABPANEL: root::ThemeWidgetType = 39;
    pub const ThemeWidgetType_NS_THEME_TABPANELS: root::ThemeWidgetType = 40;
    pub const ThemeWidgetType_NS_THEME_TAB_SCROLL_ARROW_BACK:
              root::ThemeWidgetType =
        41;
    pub const ThemeWidgetType_NS_THEME_TAB_SCROLL_ARROW_FORWARD:
              root::ThemeWidgetType =
        42;
    pub const ThemeWidgetType_NS_THEME_TOOLTIP: root::ThemeWidgetType = 43;
    pub const ThemeWidgetType_NS_THEME_SPINNER: root::ThemeWidgetType = 44;
    pub const ThemeWidgetType_NS_THEME_SPINNER_UPBUTTON: root::ThemeWidgetType
              =
        45;
    pub const ThemeWidgetType_NS_THEME_SPINNER_DOWNBUTTON:
              root::ThemeWidgetType =
        46;
    pub const ThemeWidgetType_NS_THEME_SPINNER_TEXTFIELD:
              root::ThemeWidgetType =
        47;
    pub const ThemeWidgetType_NS_THEME_NUMBER_INPUT: root::ThemeWidgetType =
        48;
    pub const ThemeWidgetType_NS_THEME_SCROLLBAR: root::ThemeWidgetType = 49;
    pub const ThemeWidgetType_NS_THEME_SCROLLBAR_SMALL: root::ThemeWidgetType
              =
        50;
    pub const ThemeWidgetType_NS_THEME_SCROLLBAR_HORIZONTAL:
              root::ThemeWidgetType =
        51;
    pub const ThemeWidgetType_NS_THEME_SCROLLBAR_VERTICAL:
              root::ThemeWidgetType =
        52;
    pub const ThemeWidgetType_NS_THEME_SCROLLBARBUTTON_UP:
              root::ThemeWidgetType =
        53;
    pub const ThemeWidgetType_NS_THEME_SCROLLBARBUTTON_DOWN:
              root::ThemeWidgetType =
        54;
    pub const ThemeWidgetType_NS_THEME_SCROLLBARBUTTON_LEFT:
              root::ThemeWidgetType =
        55;
    pub const ThemeWidgetType_NS_THEME_SCROLLBARBUTTON_RIGHT:
              root::ThemeWidgetType =
        56;
    pub const ThemeWidgetType_NS_THEME_SCROLLBARTRACK_HORIZONTAL:
              root::ThemeWidgetType =
        57;
    pub const ThemeWidgetType_NS_THEME_SCROLLBARTRACK_VERTICAL:
              root::ThemeWidgetType =
        58;
    pub const ThemeWidgetType_NS_THEME_SCROLLBARTHUMB_HORIZONTAL:
              root::ThemeWidgetType =
        59;
    pub const ThemeWidgetType_NS_THEME_SCROLLBARTHUMB_VERTICAL:
              root::ThemeWidgetType =
        60;
    pub const ThemeWidgetType_NS_THEME_SCROLLBAR_NON_DISAPPEARING:
              root::ThemeWidgetType =
        61;
    pub const ThemeWidgetType_NS_THEME_TEXTFIELD: root::ThemeWidgetType = 62;
    pub const ThemeWidgetType_NS_THEME_CARET: root::ThemeWidgetType = 63;
    pub const ThemeWidgetType_NS_THEME_TEXTFIELD_MULTILINE:
              root::ThemeWidgetType =
        64;
    pub const ThemeWidgetType_NS_THEME_SEARCHFIELD: root::ThemeWidgetType =
        65;
    pub const ThemeWidgetType_NS_THEME_MENULIST: root::ThemeWidgetType = 66;
    pub const ThemeWidgetType_NS_THEME_MENULIST_BUTTON: root::ThemeWidgetType
              =
        67;
    pub const ThemeWidgetType_NS_THEME_MENULIST_TEXT: root::ThemeWidgetType =
        68;
    pub const ThemeWidgetType_NS_THEME_MENULIST_TEXTFIELD:
              root::ThemeWidgetType =
        69;
    pub const ThemeWidgetType_NS_THEME_SCALE_HORIZONTAL: root::ThemeWidgetType
              =
        70;
    pub const ThemeWidgetType_NS_THEME_SCALE_VERTICAL: root::ThemeWidgetType =
        71;
    pub const ThemeWidgetType_NS_THEME_SCALETHUMB_HORIZONTAL:
              root::ThemeWidgetType =
        72;
    pub const ThemeWidgetType_NS_THEME_SCALETHUMB_VERTICAL:
              root::ThemeWidgetType =
        73;
    pub const ThemeWidgetType_NS_THEME_SCALETHUMBSTART: root::ThemeWidgetType
              =
        74;
    pub const ThemeWidgetType_NS_THEME_SCALETHUMBEND: root::ThemeWidgetType =
        75;
    pub const ThemeWidgetType_NS_THEME_SCALETHUMBTICK: root::ThemeWidgetType =
        76;
    pub const ThemeWidgetType_NS_THEME_RANGE: root::ThemeWidgetType = 77;
    pub const ThemeWidgetType_NS_THEME_RANGE_THUMB: root::ThemeWidgetType =
        78;
    pub const ThemeWidgetType_NS_THEME_GROUPBOX: root::ThemeWidgetType = 79;
    pub const ThemeWidgetType_NS_THEME_CHECKBOX_CONTAINER:
              root::ThemeWidgetType =
        80;
    pub const ThemeWidgetType_NS_THEME_RADIO_CONTAINER: root::ThemeWidgetType
              =
        81;
    pub const ThemeWidgetType_NS_THEME_CHECKBOX_LABEL: root::ThemeWidgetType =
        82;
    pub const ThemeWidgetType_NS_THEME_RADIO_LABEL: root::ThemeWidgetType =
        83;
    pub const ThemeWidgetType_NS_THEME_BUTTON_FOCUS: root::ThemeWidgetType =
        84;
    pub const ThemeWidgetType_NS_THEME_WINDOW: root::ThemeWidgetType = 85;
    pub const ThemeWidgetType_NS_THEME_DIALOG: root::ThemeWidgetType = 86;
    pub const ThemeWidgetType_NS_THEME_MENUBAR: root::ThemeWidgetType = 87;
    pub const ThemeWidgetType_NS_THEME_MENUPOPUP: root::ThemeWidgetType = 88;
    pub const ThemeWidgetType_NS_THEME_MENUITEM: root::ThemeWidgetType = 89;
    pub const ThemeWidgetType_NS_THEME_CHECKMENUITEM: root::ThemeWidgetType =
        90;
    pub const ThemeWidgetType_NS_THEME_RADIOMENUITEM: root::ThemeWidgetType =
        91;
    pub const ThemeWidgetType_NS_THEME_MENUCHECKBOX: root::ThemeWidgetType =
        92;
    pub const ThemeWidgetType_NS_THEME_MENURADIO: root::ThemeWidgetType = 93;
    pub const ThemeWidgetType_NS_THEME_MENUSEPARATOR: root::ThemeWidgetType =
        94;
    pub const ThemeWidgetType_NS_THEME_MENUARROW: root::ThemeWidgetType = 95;
    pub const ThemeWidgetType_NS_THEME_MENUIMAGE: root::ThemeWidgetType = 96;
    pub const ThemeWidgetType_NS_THEME_MENUITEMTEXT: root::ThemeWidgetType =
        97;
    pub const ThemeWidgetType_NS_THEME_WIN_COMMUNICATIONS_TOOLBOX:
              root::ThemeWidgetType =
        98;
    pub const ThemeWidgetType_NS_THEME_WIN_MEDIA_TOOLBOX:
              root::ThemeWidgetType =
        99;
    pub const ThemeWidgetType_NS_THEME_WIN_BROWSERTABBAR_TOOLBOX:
              root::ThemeWidgetType =
        100;
    pub const ThemeWidgetType_NS_THEME_MAC_FULLSCREEN_BUTTON:
              root::ThemeWidgetType =
        101;
    pub const ThemeWidgetType_NS_THEME_MAC_HELP_BUTTON: root::ThemeWidgetType
              =
        102;
    pub const ThemeWidgetType_NS_THEME_WIN_BORDERLESS_GLASS:
              root::ThemeWidgetType =
        103;
    pub const ThemeWidgetType_NS_THEME_WIN_GLASS: root::ThemeWidgetType = 104;
    pub const ThemeWidgetType_NS_THEME_WINDOW_TITLEBAR: root::ThemeWidgetType
              =
        105;
    pub const ThemeWidgetType_NS_THEME_WINDOW_TITLEBAR_MAXIMIZED:
              root::ThemeWidgetType =
        106;
    pub const ThemeWidgetType_NS_THEME_WINDOW_FRAME_LEFT:
              root::ThemeWidgetType =
        107;
    pub const ThemeWidgetType_NS_THEME_WINDOW_FRAME_RIGHT:
              root::ThemeWidgetType =
        108;
    pub const ThemeWidgetType_NS_THEME_WINDOW_FRAME_BOTTOM:
              root::ThemeWidgetType =
        109;
    pub const ThemeWidgetType_NS_THEME_WINDOW_BUTTON_CLOSE:
              root::ThemeWidgetType =
        110;
    pub const ThemeWidgetType_NS_THEME_WINDOW_BUTTON_MINIMIZE:
              root::ThemeWidgetType =
        111;
    pub const ThemeWidgetType_NS_THEME_WINDOW_BUTTON_MAXIMIZE:
              root::ThemeWidgetType =
        112;
    pub const ThemeWidgetType_NS_THEME_WINDOW_BUTTON_RESTORE:
              root::ThemeWidgetType =
        113;
    pub const ThemeWidgetType_NS_THEME_WINDOW_BUTTON_BOX:
              root::ThemeWidgetType =
        114;
    pub const ThemeWidgetType_NS_THEME_WINDOW_BUTTON_BOX_MAXIMIZED:
              root::ThemeWidgetType =
        115;
    pub const ThemeWidgetType_NS_THEME_WIN_EXCLUDE_GLASS:
              root::ThemeWidgetType =
        116;
    pub const ThemeWidgetType_NS_THEME_MAC_VIBRANCY_LIGHT:
              root::ThemeWidgetType =
        117;
    pub const ThemeWidgetType_NS_THEME_MAC_VIBRANCY_DARK:
              root::ThemeWidgetType =
        118;
    pub const ThemeWidgetType_NS_THEME_MAC_DISCLOSURE_BUTTON_OPEN:
              root::ThemeWidgetType =
        119;
    pub const ThemeWidgetType_NS_THEME_MAC_DISCLOSURE_BUTTON_CLOSED:
              root::ThemeWidgetType =
        120;
    pub const ThemeWidgetType_NS_THEME_GTK_INFO_BAR: root::ThemeWidgetType =
        121;
    pub const ThemeWidgetType_NS_THEME_MAC_SOURCE_LIST: root::ThemeWidgetType
              =
        122;
    pub const ThemeWidgetType_NS_THEME_MAC_SOURCE_LIST_SELECTION:
              root::ThemeWidgetType =
        123;
    pub const ThemeWidgetType_NS_THEME_MAC_ACTIVE_SOURCE_LIST_SELECTION:
              root::ThemeWidgetType =
        124;
    pub const ThemeWidgetType_ThemeWidgetType_COUNT: root::ThemeWidgetType =
        125;
    pub type ThemeWidgetType = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIConsoleReportCollector {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct CSSRuleListImpl {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMediaQueryResultCacheKey_ExpressionEntry {
        pub mExpression: root::nsMediaExpression,
        pub mExpressionMatches: bool,
    }
    #[test]
    fn bindgen_test_layout_nsMediaQueryResultCacheKey_ExpressionEntry() {
        assert_eq!(::std::mem::size_of::<nsMediaQueryResultCacheKey_ExpressionEntry>()
                   , 40usize , concat ! (
                   "Size of: " , stringify ! (
                   nsMediaQueryResultCacheKey_ExpressionEntry ) ));
        assert_eq! (::std::mem::align_of::<nsMediaQueryResultCacheKey_ExpressionEntry>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsMediaQueryResultCacheKey_ExpressionEntry ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsMediaQueryResultCacheKey_ExpressionEntry )
                    ) . mExpression as * const _ as usize } , 0usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsMediaQueryResultCacheKey_ExpressionEntry ) , "::" ,
                    stringify ! ( mExpression ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsMediaQueryResultCacheKey_ExpressionEntry )
                    ) . mExpressionMatches as * const _ as usize } , 32usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsMediaQueryResultCacheKey_ExpressionEntry ) , "::" ,
                    stringify ! ( mExpressionMatches ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMediaQueryResultCacheKey_FeatureEntry {
        pub mFeature: *const root::nsMediaFeature,
        pub mExpressions: root::nsTArray<root::nsMediaQueryResultCacheKey_ExpressionEntry>,
    }
    #[test]
    fn bindgen_test_layout_nsMediaQueryResultCacheKey_FeatureEntry() {
        assert_eq!(::std::mem::size_of::<nsMediaQueryResultCacheKey_FeatureEntry>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsMediaQueryResultCacheKey_FeatureEntry ) ));
        assert_eq! (::std::mem::align_of::<nsMediaQueryResultCacheKey_FeatureEntry>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsMediaQueryResultCacheKey_FeatureEntry ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsMediaQueryResultCacheKey_FeatureEntry )
                    ) . mFeature as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsMediaQueryResultCacheKey_FeatureEntry ) , "::" ,
                    stringify ! ( mFeature ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsMediaQueryResultCacheKey_FeatureEntry )
                    ) . mExpressions as * const _ as usize } , 8usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsMediaQueryResultCacheKey_FeatureEntry ) , "::" ,
                    stringify ! ( mExpressions ) ));
    }
    /// Utility class to provide scaling defined in a keySplines element.
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsSMILKeySpline {
        pub mX1: f64,
        pub mY1: f64,
        pub mX2: f64,
        pub mY2: f64,
        pub mSampleValues: [f64; 11usize],
    }
    pub const nsSMILKeySpline_kSplineTableSize:
              root::nsSMILKeySpline__bindgen_ty_1 =
        nsSMILKeySpline__bindgen_ty_1::kSplineTableSize;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsSMILKeySpline__bindgen_ty_1 { kSplineTableSize = 11, }
    extern "C" {
        #[link_name = "_ZN15nsSMILKeySpline15kSampleStepSizeE"]
        pub static nsSMILKeySpline_kSampleStepSize: f64;
    }
    #[test]
    fn bindgen_test_layout_nsSMILKeySpline() {
        assert_eq!(::std::mem::size_of::<nsSMILKeySpline>() , 120usize ,
                   concat ! ( "Size of: " , stringify ! ( nsSMILKeySpline )
                   ));
        assert_eq! (::std::mem::align_of::<nsSMILKeySpline>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsSMILKeySpline ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSMILKeySpline ) ) . mX1 as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSMILKeySpline ) ,
                    "::" , stringify ! ( mX1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSMILKeySpline ) ) . mY1 as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSMILKeySpline ) ,
                    "::" , stringify ! ( mY1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSMILKeySpline ) ) . mX2 as * const
                    _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSMILKeySpline ) ,
                    "::" , stringify ! ( mX2 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSMILKeySpline ) ) . mY2 as * const
                    _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSMILKeySpline ) ,
                    "::" , stringify ! ( mY2 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSMILKeySpline ) ) . mSampleValues
                    as * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSMILKeySpline ) ,
                    "::" , stringify ! ( mSampleValues ) ));
    }
    impl Clone for nsSMILKeySpline {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsMappedAttributes {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsXBLDocumentInfo {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIStyleRuleProcessor {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIStyleRuleProcessor_COMTypeInfo {
        pub _address: u8,
    }
    pub type nsIStyleRuleProcessor_EnumFunc =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::nsIStyleRuleProcessor,
                                                   arg2:
                                                       *mut ::std::os::raw::c_void)
                                  -> bool>;
    #[test]
    fn bindgen_test_layout_nsIStyleRuleProcessor() {
        assert_eq!(::std::mem::size_of::<nsIStyleRuleProcessor>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIStyleRuleProcessor ) ));
        assert_eq! (::std::mem::align_of::<nsIStyleRuleProcessor>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIStyleRuleProcessor )
                    ));
    }
    impl Clone for nsIStyleRuleProcessor {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsXBLPrototypeBinding {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsAnonymousContentList {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsLabelsNodeList {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDOMTokenList {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDOMStringMap {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMMozNamedAttrMap {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMMozNamedAttrMap_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMMozNamedAttrMap() {
        assert_eq!(::std::mem::size_of::<nsIDOMMozNamedAttrMap>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIDOMMozNamedAttrMap ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMMozNamedAttrMap>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMMozNamedAttrMap )
                    ));
    }
    impl Clone for nsIDOMMozNamedAttrMap {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIAttribute {
        pub _base: root::nsINode,
        pub mAttrMap: root::RefPtr<root::nsDOMAttributeMap>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIAttribute_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIAttribute() {
        assert_eq!(::std::mem::size_of::<nsIAttribute>() , 96usize , concat !
                   ( "Size of: " , stringify ! ( nsIAttribute ) ));
        assert_eq! (::std::mem::align_of::<nsIAttribute>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsIAttribute ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIAttribute ) ) . mAttrMap as *
                    const _ as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIAttribute ) ,
                    "::" , stringify ! ( mAttrMap ) ));
    }
    /// There are two advantages to inheriting from nsStubMutationObserver
    /// rather than directly from nsIMutationObserver:
    /// 1. smaller compiled code size (since there's no need for the code
    /// for the empty virtual function implementations for every
    /// nsIMutationObserver implementation)
    /// 2. the performance of document's loop over observers benefits from
    /// the fact that more of the functions called are the same (which
    /// can reduce instruction cache misses and perhaps improve branch
    /// prediction)
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStubMutationObserver {
        pub _base: root::nsIMutationObserver,
    }
    #[test]
    fn bindgen_test_layout_nsStubMutationObserver() {
        assert_eq!(::std::mem::size_of::<nsStubMutationObserver>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsStubMutationObserver ) ));
        assert_eq! (::std::mem::align_of::<nsStubMutationObserver>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsStubMutationObserver )
                    ));
    }
    impl Clone for nsStubMutationObserver {
        fn clone(&self) -> Self { *self }
    }
    /// Structure used as a key for caching Attrs in nsDOMAttributeMap's mAttributeCache.
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsAttrKey {
        /// The namespace of the attribute
        pub mNamespaceID: i32,
        /// The atom for attribute, stored as void*, to make sure that we only use it
        /// for the hashcode, and we can never dereference it.
        pub mLocalName: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_nsAttrKey() {
        assert_eq!(::std::mem::size_of::<nsAttrKey>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsAttrKey ) ));
        assert_eq! (::std::mem::align_of::<nsAttrKey>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsAttrKey ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrKey ) ) . mNamespaceID as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAttrKey ) , "::"
                    , stringify ! ( mNamespaceID ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrKey ) ) . mLocalName as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAttrKey ) , "::"
                    , stringify ! ( mLocalName ) ));
    }
    impl Clone for nsAttrKey {
        fn clone(&self) -> Self { *self }
    }
    /// PLDHashEntryHdr implementation for nsAttrKey.
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAttrHashKey {
        pub _base: root::PLDHashEntryHdr,
        pub mKey: root::nsAttrKey,
    }
    pub type nsAttrHashKey_KeyType = *const root::nsAttrKey;
    pub type nsAttrHashKey_KeyTypePointer = *const root::nsAttrKey;
    pub const nsAttrHashKey_ALLOW_MEMMOVE: root::nsAttrHashKey__bindgen_ty_1 =
        nsAttrHashKey__bindgen_ty_1::ALLOW_MEMMOVE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsAttrHashKey__bindgen_ty_1 { ALLOW_MEMMOVE = 1, }
    #[test]
    fn bindgen_test_layout_nsAttrHashKey() {
        assert_eq!(::std::mem::size_of::<nsAttrHashKey>() , 24usize , concat !
                   ( "Size of: " , stringify ! ( nsAttrHashKey ) ));
        assert_eq! (::std::mem::align_of::<nsAttrHashKey>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsAttrHashKey ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrHashKey ) ) . mKey as * const _
                    as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAttrHashKey ) ,
                    "::" , stringify ! ( mKey ) ));
    }
    #[repr(C)]
    pub struct nsISMILAttr__bindgen_vtable(::std::os::raw::c_void);
    ///
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsISMILAttr {
        pub vtable_: *const nsISMILAttr__bindgen_vtable,
    }
    #[test]
    fn bindgen_test_layout_nsISMILAttr() {
        assert_eq!(::std::mem::size_of::<nsISMILAttr>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsISMILAttr ) ));
        assert_eq! (::std::mem::align_of::<nsISMILAttr>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsISMILAttr ) ));
    }
    pub const ELEMENT_SHARED_RESTYLE_BIT_1: root::_bindgen_ty_20 =
        _bindgen_ty_20::ELEMENT_SHARED_RESTYLE_BIT_1;
    pub const ELEMENT_SHARED_RESTYLE_BIT_2: root::_bindgen_ty_20 =
        _bindgen_ty_20::ELEMENT_SHARED_RESTYLE_BIT_2;
    pub const ELEMENT_SHARED_RESTYLE_BIT_3: root::_bindgen_ty_20 =
        _bindgen_ty_20::ELEMENT_SHARED_RESTYLE_BIT_3;
    pub const ELEMENT_SHARED_RESTYLE_BIT_4: root::_bindgen_ty_20 =
        _bindgen_ty_20::ELEMENT_SHARED_RESTYLE_BIT_4;
    pub const ELEMENT_HAS_DIRTY_DESCENDANTS_FOR_SERVO: root::_bindgen_ty_20 =
        _bindgen_ty_20::ELEMENT_SHARED_RESTYLE_BIT_1;
    pub const ELEMENT_HAS_ANIMATION_ONLY_DIRTY_DESCENDANTS_FOR_SERVO:
              root::_bindgen_ty_20 =
        _bindgen_ty_20::ELEMENT_SHARED_RESTYLE_BIT_2;
    pub const ELEMENT_HAS_SNAPSHOT: root::_bindgen_ty_20 =
        _bindgen_ty_20::ELEMENT_SHARED_RESTYLE_BIT_3;
    pub const ELEMENT_HANDLED_SNAPSHOT: root::_bindgen_ty_20 =
        _bindgen_ty_20::ELEMENT_SHARED_RESTYLE_BIT_4;
    pub const ELEMENT_HAS_PENDING_RESTYLE: root::_bindgen_ty_20 =
        _bindgen_ty_20::ELEMENT_SHARED_RESTYLE_BIT_1;
    pub const ELEMENT_IS_POTENTIAL_RESTYLE_ROOT: root::_bindgen_ty_20 =
        _bindgen_ty_20::ELEMENT_SHARED_RESTYLE_BIT_2;
    pub const ELEMENT_HAS_PENDING_ANIMATION_ONLY_RESTYLE: root::_bindgen_ty_20
              =
        _bindgen_ty_20::ELEMENT_SHARED_RESTYLE_BIT_3;
    pub const ELEMENT_IS_POTENTIAL_ANIMATION_ONLY_RESTYLE_ROOT:
              root::_bindgen_ty_20 =
        _bindgen_ty_20::ELEMENT_SHARED_RESTYLE_BIT_4;
    pub const ELEMENT_IS_CONDITIONAL_RESTYLE_ANCESTOR: root::_bindgen_ty_20 =
        _bindgen_ty_20::ELEMENT_IS_CONDITIONAL_RESTYLE_ANCESTOR;
    pub const ELEMENT_PENDING_RESTYLE_FLAGS: root::_bindgen_ty_20 =
        _bindgen_ty_20::ELEMENT_PENDING_RESTYLE_FLAGS;
    pub const ELEMENT_POTENTIAL_RESTYLE_ROOT_FLAGS: root::_bindgen_ty_20 =
        _bindgen_ty_20::ELEMENT_POTENTIAL_RESTYLE_ROOT_FLAGS;
    pub const ELEMENT_ALL_RESTYLE_FLAGS: root::_bindgen_ty_20 =
        _bindgen_ty_20::ELEMENT_ALL_RESTYLE_FLAGS;
    pub const ELEMENT_TYPE_SPECIFIC_BITS_OFFSET: root::_bindgen_ty_20 =
        _bindgen_ty_20::ELEMENT_TYPE_SPECIFIC_BITS_OFFSET;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum _bindgen_ty_20 {
        ELEMENT_SHARED_RESTYLE_BIT_1 = 8388608,
        ELEMENT_SHARED_RESTYLE_BIT_2 = 16777216,
        ELEMENT_SHARED_RESTYLE_BIT_3 = 33554432,
        ELEMENT_SHARED_RESTYLE_BIT_4 = 67108864,
        ELEMENT_IS_CONDITIONAL_RESTYLE_ANCESTOR = 134217728,
        ELEMENT_PENDING_RESTYLE_FLAGS = 41943040,
        ELEMENT_POTENTIAL_RESTYLE_ROOT_FLAGS = 83886080,
        ELEMENT_ALL_RESTYLE_FLAGS = 260046848,
        ELEMENT_TYPE_SPECIFIC_BITS_OFFSET = 27,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct LookAndFeelInt {
        pub id: i32,
        pub value: i32,
    }
    #[test]
    fn bindgen_test_layout_LookAndFeelInt() {
        assert_eq!(::std::mem::size_of::<LookAndFeelInt>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( LookAndFeelInt ) ));
        assert_eq! (::std::mem::align_of::<LookAndFeelInt>() , 4usize , concat
                    ! ( "Alignment of " , stringify ! ( LookAndFeelInt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const LookAndFeelInt ) ) . id as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( LookAndFeelInt ) ,
                    "::" , stringify ! ( id ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const LookAndFeelInt ) ) . value as * const
                    _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( LookAndFeelInt ) ,
                    "::" , stringify ! ( value ) ));
    }
    impl Clone for LookAndFeelInt {
        fn clone(&self) -> Self { *self }
    }
    /// An object implementing |nsIStyleRule| (henceforth, a rule) represents
    /// immutable stylistic information that either applies or does not apply
    /// to a given element.  It belongs to an object or group of objects that
    /// implement |nsIStyleSheet| and |nsIStyleRuleProcessor| (henceforth, a
    /// sheet).
    ///
    /// A rule becomes relevant to the computation of style data when
    /// |nsIStyleRuleProcessor::RulesMatching| creates a rule node that
    /// points to the rule.  (A rule node, |nsRuleNode|, is a node in the
    /// rule tree, which is a lexicographic tree indexed by rules.  The path
    /// from the root of the rule tree to the |nsRuleNode| for a given
    /// |nsStyleContext| contains exactly the rules that match the element
    /// that the style context is for, in priority (weight, origin,
    /// specificity) order.)
    ///
    /// The computation of style data uses the rule tree, which calls
    /// |nsIStyleRule::MapRuleInfoInto| below.
    ///
    /// It is worth emphasizing that the data represented by a rule
    /// implementation are immutable.  When the data need to be changed, a
    /// new rule object must be created.  Failing to do this will lead to
    /// bugs in the handling of dynamic style changes, since the rule tree
    /// caches the results of |MapRuleInfoInto|.
    ///
    /// |nsIStyleRule| objects are owned by |nsRuleNode| objects (in addition
    /// to typically being owned by their sheet), which are in turn garbage
    /// collected (with the garbage collection roots being style contexts).
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIStyleRule {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIStyleRule_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIStyleRule() {
        assert_eq!(::std::mem::size_of::<nsIStyleRule>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIStyleRule ) ));
        assert_eq! (::std::mem::align_of::<nsIStyleRule>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsIStyleRule ) ));
    }
    impl Clone for nsIStyleRule {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSFontFaceRule {
        pub _base: root::mozilla::css::Rule,
        pub _base_1: root::nsIDOMCSSFontFaceRule,
        pub mDecl: root::nsCSSFontFaceStyleDecl,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCSSFontFaceRule_cycleCollection {
        pub _base: root::mozilla::css::Rule_cycleCollection,
    }
    #[test]
    fn bindgen_test_layout_nsCSSFontFaceRule_cycleCollection() {
        assert_eq!(::std::mem::size_of::<nsCSSFontFaceRule_cycleCollection>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsCSSFontFaceRule_cycleCollection ) ));
        assert_eq! (::std::mem::align_of::<nsCSSFontFaceRule_cycleCollection>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsCSSFontFaceRule_cycleCollection ) ));
    }
    impl Clone for nsCSSFontFaceRule_cycleCollection {
        fn clone(&self) -> Self { *self }
    }
    extern "C" {
        #[link_name = "_ZN17nsCSSFontFaceRule21_cycleCollectorGlobalE"]
        pub static mut nsCSSFontFaceRule__cycleCollectorGlobal:
                   root::nsCSSFontFaceRule_cycleCollection;
    }
    #[test]
    fn bindgen_test_layout_nsCSSFontFaceRule() {
        assert_eq!(::std::mem::size_of::<nsCSSFontFaceRule>() , 256usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCSSFontFaceRule )
                   ));
        assert_eq! (::std::mem::align_of::<nsCSSFontFaceRule>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSFontFaceRule ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsMediaFeature {
        pub mName: *mut *mut root::nsIAtom,
        pub mRangeType: root::nsMediaFeature_RangeType,
        pub mValueType: root::nsMediaFeature_ValueType,
        pub mReqFlags: u8,
        pub mData: root::nsMediaFeature__bindgen_ty_1,
        pub mGetter: root::nsMediaFeatureValueGetter,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsMediaFeature_RangeType {
        eMinMaxAllowed = 0,
        eMinMaxNotAllowed = 1,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsMediaFeature_ValueType {
        eLength = 0,
        eInteger = 1,
        eFloat = 2,
        eBoolInteger = 3,
        eIntRatio = 4,
        eResolution = 5,
        eEnumerated = 6,
        eIdent = 7,
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsMediaFeature_RequirementFlags {
        eNoRequirements = 0,
        eHasWebkitPrefix = 1,
        eWebkitDevicePixelRatioPrefEnabled = 2,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsMediaFeature__bindgen_ty_1 {
        pub mInitializer_: root::__BindgenUnionField<*const ::std::os::raw::c_void>,
        pub mKeywordTable: root::__BindgenUnionField<*const root::nsCSSProps_KTableEntry>,
        pub mMetric: root::__BindgenUnionField<*const *const root::nsIAtom>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsMediaFeature__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsMediaFeature__bindgen_ty_1>() ,
                   8usize , concat ! (
                   "Size of: " , stringify ! ( nsMediaFeature__bindgen_ty_1 )
                   ));
        assert_eq! (::std::mem::align_of::<nsMediaFeature__bindgen_ty_1>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsMediaFeature__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature__bindgen_ty_1 ) ) .
                    mInitializer_ as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsMediaFeature__bindgen_ty_1 ) , "::" , stringify ! (
                    mInitializer_ ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature__bindgen_ty_1 ) ) .
                    mKeywordTable as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsMediaFeature__bindgen_ty_1 ) , "::" , stringify ! (
                    mKeywordTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature__bindgen_ty_1 ) ) .
                    mMetric as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsMediaFeature__bindgen_ty_1 ) , "::" , stringify ! (
                    mMetric ) ));
    }
    impl Clone for nsMediaFeature__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsMediaFeature() {
        assert_eq!(::std::mem::size_of::<nsMediaFeature>() , 40usize , concat
                   ! ( "Size of: " , stringify ! ( nsMediaFeature ) ));
        assert_eq! (::std::mem::align_of::<nsMediaFeature>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsMediaFeature ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature ) ) . mName as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaFeature ) ,
                    "::" , stringify ! ( mName ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature ) ) . mRangeType as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaFeature ) ,
                    "::" , stringify ! ( mRangeType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature ) ) . mValueType as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaFeature ) ,
                    "::" , stringify ! ( mValueType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature ) ) . mReqFlags as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaFeature ) ,
                    "::" , stringify ! ( mReqFlags ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature ) ) . mData as * const
                    _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaFeature ) ,
                    "::" , stringify ! ( mData ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature ) ) . mGetter as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaFeature ) ,
                    "::" , stringify ! ( mGetter ) ));
    }
    impl Clone for nsMediaFeature {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct ServoBundledURI {
        pub mURLString: *const u8,
        pub mURLStringLength: u32,
        pub mExtraData: *mut root::mozilla::URLExtraData,
    }
    #[test]
    fn bindgen_test_layout_ServoBundledURI() {
        assert_eq!(::std::mem::size_of::<ServoBundledURI>() , 24usize , concat
                   ! ( "Size of: " , stringify ! ( ServoBundledURI ) ));
        assert_eq! (::std::mem::align_of::<ServoBundledURI>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( ServoBundledURI ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoBundledURI ) ) . mURLString as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoBundledURI ) ,
                    "::" , stringify ! ( mURLString ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoBundledURI ) ) .
                    mURLStringLength as * const _ as usize } , 8usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( ServoBundledURI ) ,
                    "::" , stringify ! ( mURLStringLength ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoBundledURI ) ) . mExtraData as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoBundledURI ) ,
                    "::" , stringify ! ( mExtraData ) ));
    }
    impl Clone for ServoBundledURI {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct FontSizePrefs {
        pub mDefaultVariableSize: root::nscoord,
        pub mDefaultFixedSize: root::nscoord,
        pub mDefaultSerifSize: root::nscoord,
        pub mDefaultSansSerifSize: root::nscoord,
        pub mDefaultMonospaceSize: root::nscoord,
        pub mDefaultCursiveSize: root::nscoord,
        pub mDefaultFantasySize: root::nscoord,
    }
    #[test]
    fn bindgen_test_layout_FontSizePrefs() {
        assert_eq!(::std::mem::size_of::<FontSizePrefs>() , 28usize , concat !
                   ( "Size of: " , stringify ! ( FontSizePrefs ) ));
        assert_eq! (::std::mem::align_of::<FontSizePrefs>() , 4usize , concat
                    ! ( "Alignment of " , stringify ! ( FontSizePrefs ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const FontSizePrefs ) ) .
                    mDefaultVariableSize as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( FontSizePrefs ) ,
                    "::" , stringify ! ( mDefaultVariableSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const FontSizePrefs ) ) . mDefaultFixedSize
                    as * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( FontSizePrefs ) ,
                    "::" , stringify ! ( mDefaultFixedSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const FontSizePrefs ) ) . mDefaultSerifSize
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( FontSizePrefs ) ,
                    "::" , stringify ! ( mDefaultSerifSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const FontSizePrefs ) ) .
                    mDefaultSansSerifSize as * const _ as usize } , 12usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( FontSizePrefs ) ,
                    "::" , stringify ! ( mDefaultSansSerifSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const FontSizePrefs ) ) .
                    mDefaultMonospaceSize as * const _ as usize } , 16usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( FontSizePrefs ) ,
                    "::" , stringify ! ( mDefaultMonospaceSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const FontSizePrefs ) ) .
                    mDefaultCursiveSize as * const _ as usize } , 20usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( FontSizePrefs ) ,
                    "::" , stringify ! ( mDefaultCursiveSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const FontSizePrefs ) ) .
                    mDefaultFantasySize as * const _ as usize } , 24usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( FontSizePrefs ) ,
                    "::" , stringify ! ( mDefaultFantasySize ) ));
    }
    impl Clone for FontSizePrefs {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct GeckoFontMetrics {
        pub mChSize: root::nscoord,
        pub mXSize: root::nscoord,
    }
    #[test]
    fn bindgen_test_layout_GeckoFontMetrics() {
        assert_eq!(::std::mem::size_of::<GeckoFontMetrics>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( GeckoFontMetrics ) ));
        assert_eq! (::std::mem::align_of::<GeckoFontMetrics>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( GeckoFontMetrics ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const GeckoFontMetrics ) ) . mChSize as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( GeckoFontMetrics )
                    , "::" , stringify ! ( mChSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const GeckoFontMetrics ) ) . mXSize as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( GeckoFontMetrics )
                    , "::" , stringify ! ( mXSize ) ));
    }
    impl Clone for GeckoFontMetrics {
        fn clone(&self) -> Self { *self }
    }
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_after: u32 = 65;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_before: u32 = 65;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_backdrop: u32 = 0;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_cue: u32 = 36;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_firstLetter: u32 = 3;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_firstLine: u32 = 3;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozSelection: u32 = 2;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozFocusInner: u32 = 0;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozFocusOuter: u32 = 0;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozListBullet: u32 = 0;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozListNumber: u32 = 0;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozMathAnonymous: u32 = 0;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozNumberWrapper: u32 = 24;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozNumberText: u32 = 24;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozNumberSpinBox: u32 = 24;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozNumberSpinUp: u32 = 24;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozNumberSpinDown: u32 = 24;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozProgressBar: u32 = 8;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozRangeTrack: u32 = 8;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozRangeProgress: u32 = 8;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozRangeThumb: u32 = 8;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozMeterBar: u32 = 8;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozPlaceholder: u32 = 8;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_placeholder: u32 = 8;
    pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozColorSwatch: u32 = 12;
    pub type nsBindingList = root::nsTArray<root::RefPtr<root::nsXBLBinding>>;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsCSSPageRule {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMCSSCounterStyleRule {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMCSSCounterStyleRule_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMCSSCounterStyleRule() {
        assert_eq!(::std::mem::size_of::<nsIDOMCSSCounterStyleRule>() , 8usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsIDOMCSSCounterStyleRule ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMCSSCounterStyleRule>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIDOMCSSCounterStyleRule
                    ) ));
    }
    impl Clone for nsIDOMCSSCounterStyleRule {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMCSSFontFaceRule {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMCSSFontFaceRule_COMTypeInfo {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMCSSFontFaceRule() {
        assert_eq!(::std::mem::size_of::<nsIDOMCSSFontFaceRule>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIDOMCSSFontFaceRule ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMCSSFontFaceRule>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMCSSFontFaceRule )
                    ));
    }
    impl Clone for nsIDOMCSSFontFaceRule {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSFontFaceStyleDecl {
        pub _base: root::nsICSSDeclaration,
        pub mDescriptors: root::mozilla::CSSFontFaceDescriptors,
    }
    #[test]
    fn bindgen_test_layout_nsCSSFontFaceStyleDecl() {
        assert_eq!(::std::mem::size_of::<nsCSSFontFaceStyleDecl>() , 176usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsCSSFontFaceStyleDecl ) ));
        assert_eq! (::std::mem::align_of::<nsCSSFontFaceStyleDecl>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsCSSFontFaceStyleDecl )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSFontFaceStyleDecl ) ) .
                    mDescriptors as * const _ as usize } , 32usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsCSSFontFaceStyleDecl ) , "::" , stringify ! (
                    mDescriptors ) ));
    }
    pub type nsMediaFeatureValueGetter =
        ::std::option::Option<unsafe extern "C" fn(aPresContext:
                                                       *mut root::nsPresContext,
                                                   aFeature:
                                                       *const root::nsMediaFeature,
                                                   aResult:
                                                       *mut root::nsCSSValue)>;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsMediaFeatures {
        pub _address: u8,
    }
    extern "C" {
        #[link_name = "_ZN15nsMediaFeatures8featuresE"]
        pub static mut nsMediaFeatures_features:
                   [root::nsMediaFeature; 0usize];
    }
    #[test]
    fn bindgen_test_layout_nsMediaFeatures() {
        assert_eq!(::std::mem::size_of::<nsMediaFeatures>() , 1usize , concat
                   ! ( "Size of: " , stringify ! ( nsMediaFeatures ) ));
        assert_eq! (::std::mem::align_of::<nsMediaFeatures>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsMediaFeatures ) ));
    }
    impl Clone for nsMediaFeatures {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMediaExpression {
        pub mFeature: *const root::nsMediaFeature,
        pub mRange: root::nsMediaExpression_Range,
        pub mValue: root::nsCSSValue,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsMediaExpression_Range { eMin = 0, eMax = 1, eEqual = 2, }
    #[test]
    fn bindgen_test_layout_nsMediaExpression() {
        assert_eq!(::std::mem::size_of::<nsMediaExpression>() , 32usize ,
                   concat ! ( "Size of: " , stringify ! ( nsMediaExpression )
                   ));
        assert_eq! (::std::mem::align_of::<nsMediaExpression>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsMediaExpression ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaExpression ) ) . mFeature as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaExpression )
                    , "::" , stringify ! ( mFeature ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaExpression ) ) . mRange as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaExpression )
                    , "::" , stringify ! ( mRange ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaExpression ) ) . mValue as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaExpression )
                    , "::" , stringify ! ( mValue ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMediaQuery {
        pub mNegated: bool,
        pub mHasOnly: bool,
        pub mTypeOmitted: bool,
        pub mHadUnknownExpression: bool,
        pub mMediaType: root::nsCOMPtr<root::nsIAtom>,
        pub mExpressions: root::nsTArray<root::nsMediaExpression>,
    }
    #[test]
    fn bindgen_test_layout_nsMediaQuery() {
        assert_eq!(::std::mem::size_of::<nsMediaQuery>() , 24usize , concat !
                   ( "Size of: " , stringify ! ( nsMediaQuery ) ));
        assert_eq! (::std::mem::align_of::<nsMediaQuery>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsMediaQuery ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaQuery ) ) . mNegated as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaQuery ) ,
                    "::" , stringify ! ( mNegated ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaQuery ) ) . mHasOnly as *
                    const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaQuery ) ,
                    "::" , stringify ! ( mHasOnly ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaQuery ) ) . mTypeOmitted as *
                    const _ as usize } , 2usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaQuery ) ,
                    "::" , stringify ! ( mTypeOmitted ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaQuery ) ) .
                    mHadUnknownExpression as * const _ as usize } , 3usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaQuery ) ,
                    "::" , stringify ! ( mHadUnknownExpression ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaQuery ) ) . mMediaType as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaQuery ) ,
                    "::" , stringify ! ( mMediaType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaQuery ) ) . mExpressions as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaQuery ) ,
                    "::" , stringify ! ( mExpressions ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMediaList {
        pub _base: root::mozilla::dom::MediaList,
        pub mArray: root::nsTArray<root::nsAutoPtr<root::nsMediaQuery>>,
    }
    #[test]
    fn bindgen_test_layout_nsMediaList() {
        assert_eq!(::std::mem::size_of::<nsMediaList>() , 64usize , concat ! (
                   "Size of: " , stringify ! ( nsMediaList ) ));
        assert_eq! (::std::mem::align_of::<nsMediaList>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsMediaList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaList ) ) . mArray as * const _
                    as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaList ) ,
                    "::" , stringify ! ( mArray ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCharTraits_open0_nsStringRepr_char_type_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCharTraits>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCharTraits ) ));
        assert_eq!(::std::mem::align_of::<root::nsCharTraits>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCharTraits ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsReadingIterator_open0_nsStringRepr_char_type_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsReadingIterator<root::mozilla::detail::nsStringRepr_char_type>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsReadingIterator<root::mozilla::detail::nsStringRepr_char_type>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsReadingIterator<root::mozilla::detail::nsStringRepr_char_type>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsReadingIterator<root::mozilla::detail::nsStringRepr_char_type>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsWritingIterator_open0_nsStringRepr_char_type_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsWritingIterator<root::mozilla::detail::nsStringRepr_char_type>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsWritingIterator<root::mozilla::detail::nsStringRepr_char_type>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsWritingIterator<root::mozilla::detail::nsStringRepr_char_type>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsWritingIterator<root::mozilla::detail::nsStringRepr_char_type>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCharTraits_open0_nsCStringRepr_char_type_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCharTraits>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCharTraits ) ));
        assert_eq!(::std::mem::align_of::<root::nsCharTraits>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCharTraits ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsReadingIterator_open0_nsCStringRepr_char_type_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsReadingIterator<root::mozilla::detail::nsCStringRepr_char_type>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsReadingIterator<root::mozilla::detail::nsCStringRepr_char_type>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsReadingIterator<root::mozilla::detail::nsCStringRepr_char_type>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsReadingIterator<root::mozilla::detail::nsCStringRepr_char_type>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsWritingIterator_open0_nsCStringRepr_char_type_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsWritingIterator<root::mozilla::detail::nsCStringRepr_char_type>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsWritingIterator<root::mozilla::detail::nsCStringRepr_char_type>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsWritingIterator<root::mozilla::detail::nsCStringRepr_char_type>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsWritingIterator<root::mozilla::detail::nsCStringRepr_char_type>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCharTraits_open0_nsSubstringTuple_char_type_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCharTraits>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCharTraits ) ));
        assert_eq!(::std::mem::align_of::<root::nsCharTraits>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCharTraits ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCharTraits_open0_nsCSubstringTuple_char_type_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCharTraits>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCharTraits ) ));
        assert_eq!(::std::mem::align_of::<root::nsCharTraits>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCharTraits ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsCString_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCString>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCString> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCString>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCString> ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_JSErrorNotes_DeletePolicy_open1_JSErrorNotes_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::JSErrorNotes>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::JSErrorNotes>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
        assert_eq!(::std::mem::align_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsISupports_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsISupports>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsISupports> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsISupports>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsISupports> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_CSSVariableValues_Variable_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::mozilla::CSSVariableValues_Variable>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::CSSVariableValues_Variable> )
                   ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::mozilla::CSSVariableValues_Variable>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::CSSVariableValues_Variable> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsString_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_FontFamilyName_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::mozilla::FontFamilyName>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::FontFamilyName> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::mozilla::FontFamilyName>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::FontFamilyName> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_FontFamilyName_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::mozilla::FontFamilyName>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::FontFamilyName> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::mozilla::FontFamilyName>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::FontFamilyName> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_uint32_t_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<u32>>() , 8usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<u32> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<u32>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<u32> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_uint32_t_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<u32>>() , 8usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<u32> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<u32>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<u32> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_gfxFontFeatureValueSet_ValueList_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::gfxFontFeatureValueSet_ValueList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::gfxFontFeatureValueSet_ValueList> )
                   ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::gfxFontFeatureValueSet_ValueList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::gfxFontFeatureValueSet_ValueList> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_uint32_t_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<u32>>() , 8usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<u32> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<u32>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<u32> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_uint32_t_close0_instantiation_3() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<u32>>() , 8usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<u32> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<u32>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<u32> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_uint32_t_close0_instantiation_4() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<u32>>() , 8usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<u32> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<u32>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<u32> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_gfxAlternateValue_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::gfxAlternateValue>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::gfxAlternateValue> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::gfxAlternateValue>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::gfxAlternateValue> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_gfxFontFeatureValueSet_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::gfxFontFeatureValueSet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::gfxFontFeatureValueSet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::gfxFontFeatureValueSet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::gfxFontFeatureValueSet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_gfxFontFeature_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::gfxFontFeature>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::gfxFontFeature> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::gfxFontFeature>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::gfxFontFeature> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_gfxFontVariation_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::gfxFontVariation>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::gfxFontVariation> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::gfxFontVariation>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::gfxFontVariation> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_212850_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::nsCSSSelector>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsCSSSelector> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::nsCSSSelector>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsCSSSelector> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIAtom_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIAtom>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIAtom>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsStyleImageRequest_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsStyleImageRequest>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsStyleImageRequest> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsStyleImageRequest>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsStyleImageRequest> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsStyleQuoteValues_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsStyleQuoteValues>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsStyleQuoteValues> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsStyleQuoteValues>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsStyleQuoteValues> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsCSSShadowArray_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsCSSShadowArray>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsCSSShadowArray> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsCSSShadowArray>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsCSSShadowArray> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsCursorImage_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCursorImage>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCursorImage> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCursorImage>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCursorImage> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_URLValue_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::css::URLValue>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::css::URLValue> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::css::URLValue>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::css::URLValue> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_URLValue_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::css::URLValue>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::css::URLValue> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::css::URLValue>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::css::URLValue> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_URLValue_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::css::URLValue>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::css::URLValue> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::css::URLValue>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::css::URLValue> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsStyleCoord_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsStyleCoord>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleCoord> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsStyleCoord>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleCoord> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsCOMPtr_open1_nsIAtom_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCOMPtr<root::nsIAtom>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr<root::nsIAtom>> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCOMPtr<root::nsIAtom>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr<root::nsIAtom>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIAtom_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIAtom>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIAtom>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_nsStyleGridTemplate_DefaultDelete_open1_nsStyleGridTemplate_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsStyleGridTemplate>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsStyleGridTemplate> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsStyleGridTemplate>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsStyleGridTemplate> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_open0_nsStyleGridTemplate_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_nsStyleGridTemplate_DefaultDelete_open1_nsStyleGridTemplate_close1_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsStyleGridTemplate>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsStyleGridTemplate> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsStyleGridTemplate>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsStyleGridTemplate> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_open0_nsStyleGridTemplate_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_GridTemplateAreasValue_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::css::GridTemplateAreasValue>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::css::GridTemplateAreasValue> )
                   ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::css::GridTemplateAreasValue>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::css::GridTemplateAreasValue> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMArray_open0_nsIAtom_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMArray>() , 8usize , concat
                   ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMArray ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMArray>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMArray ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_Position_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::mozilla::Position>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::Position> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::mozilla::Position>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::Position> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsCSSValueSharedList_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsCSSValueSharedList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsCSSValueSharedList> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsCSSValueSharedList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsCSSValueSharedList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsStyleAutoArray_open0_StyleTransition_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsStyleAutoArray<root::mozilla::StyleTransition>>()
                   , 48usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsStyleAutoArray<root::mozilla::StyleTransition> )
                   ));
        assert_eq!(::std::mem::align_of::<root::nsStyleAutoArray<root::mozilla::StyleTransition>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsStyleAutoArray<root::mozilla::StyleTransition> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_nsStyleAutoArray_open0_StyleAnimation_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsStyleAutoArray<root::mozilla::StyleAnimation>>()
                   , 64usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsStyleAutoArray<root::mozilla::StyleAnimation> ) ));
        assert_eq!(::std::mem::align_of::<root::nsStyleAutoArray<root::mozilla::StyleAnimation>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsStyleAutoArray<root::mozilla::StyleAnimation> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsStyleContentData_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsStyleContentData>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleContentData> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsStyleContentData>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleContentData> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsStyleCounterData_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsStyleCounterData>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleCounterData> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsStyleCounterData>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleCounterData> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsStyleCounterData_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsStyleCounterData>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleCounterData> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsStyleCounterData>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleCounterData> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsCSSValueSharedList_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsCSSValueSharedList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsCSSValueSharedList> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsCSSValueSharedList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsCSSValueSharedList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsStyleFilter_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsStyleFilter>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleFilter> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsStyleFilter>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleFilter> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsCSSShadowArray_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsCSSShadowArray>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsCSSShadowArray> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsCSSShadowArray>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsCSSShadowArray> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_ServoStyleContext_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::ServoStyleContext>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::ServoStyleContext> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::ServoStyleContext>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::ServoStyleContext> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_ServoStyleContext_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::ServoStyleContext>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::ServoStyleContext> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::ServoStyleContext>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::ServoStyleContext> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsString_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_TErrorResult_open0_AssertAndSuppressCleanupPolicy_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::binding_danger::TErrorResult>()
                   , 32usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::binding_danger::TErrorResult ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::binding_danger::TErrorResult>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::binding_danger::TErrorResult ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_214679_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_StyleSheet_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_MediaList_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::MediaList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::MediaList> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::MediaList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::MediaList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_StyleSheet_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_StyleSetHandle_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::mozilla::StyleSetHandle>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::StyleSetHandle> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::mozilla::StyleSetHandle>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::StyleSetHandle> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsAttrChildContentList_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsAttrChildContentList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsAttrChildContentList> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsAttrChildContentList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsAttrChildContentList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_LinkedList_open1_nsRange_close1_DefaultDelete_open1_LinkedList_open2_nsRange_close2_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::mozilla::LinkedList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::mozilla::LinkedList> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::mozilla::LinkedList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::mozilla::LinkedList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_open0_LinkedList_open1_nsRange_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_LinkedList_open1_nsRange_close1_DefaultDelete_open1_LinkedList_open2_nsRange_close2_close1_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::mozilla::LinkedList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::mozilla::LinkedList> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::mozilla::LinkedList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::mozilla::LinkedList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_open0_LinkedList_open1_nsRange_close1_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_NodeInfo_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::NodeInfo>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::NodeInfo> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::NodeInfo>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::NodeInfo> ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_JSErrorNotes_Note_DeletePolicy_open1_JSErrorNotes_Note_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_Note_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
        assert_eq!(::std::mem::align_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_JSErrorNotes_DeletePolicy_open1_JSErrorNotes_close1_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::JSErrorNotes>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::JSErrorNotes>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
        assert_eq!(::std::mem::align_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
    }
    #[test]
    fn __bindgen_test_layout_iterator_open0_input_iterator_tag_UniquePtr_open1_JSErrorNotes_Note_DeletePolicy_open2_JSErrorNotes_Note_close2_close1_long__bindgen_ty_id_220268__bindgen_ty_id_220275_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::std::iterator>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::iterator ) ));
        assert_eq!(::std::mem::align_of::<root::std::iterator>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::iterator ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_JSErrorNotes_Note_DeletePolicy_open1_JSErrorNotes_Note_close1_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_Note_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
        assert_eq!(::std::mem::align_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_JSErrorNotes_Note_DeletePolicy_open1_JSErrorNotes_Note_close1_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_Note_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
        assert_eq!(::std::mem::align_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_JSErrorNotes_Note_DeletePolicy_open1_JSErrorNotes_Note_close1_close0_instantiation_3() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_Note_close0_instantiation_3() {
        assert_eq!(::std::mem::size_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
        assert_eq!(::std::mem::align_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_JSErrorNotes_Note_DeletePolicy_open1_JSErrorNotes_Note_close1_close0_instantiation_4() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_Note_close0_instantiation_4() {
        assert_eq!(::std::mem::size_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
        assert_eq!(::std::mem::align_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_JSErrorNotes_Note_DeletePolicy_open1_JSErrorNotes_Note_close1_close0_instantiation_5() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_Note_close0_instantiation_5() {
        assert_eq!(::std::mem::size_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
        assert_eq!(::std::mem::align_of::<root::JS::DeletePolicy>() , 1usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::DeletePolicy ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIPrincipal_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIPrincipal>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIPrincipal> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIPrincipal>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIPrincipal> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsCString_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCString>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCString> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCString>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCString> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsCString_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCString>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCString> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCString>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCString> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIDocument_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIDocument>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIDocument> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIDocument>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIDocument> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsCOMPtr_open1_nsIRunnable_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCOMPtr<root::nsIRunnable>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr<root::nsIRunnable>> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCOMPtr<root::nsIRunnable>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr<root::nsIRunnable>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIRunnable_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIRunnable> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIRunnable> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_AnonymousContent_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::AnonymousContent>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::AnonymousContent>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::AnonymousContent>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::AnonymousContent>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_StyleSheet_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_StyleSheet_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_StyleSheet_close1_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_StyleSheet_close0_instantiation_3() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_222771_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::nsIDocument_Element>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIDocument_Element> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::nsIDocument_Element>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIDocument_Element> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_Element_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::Element>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::Element>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::Element>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::Element>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_Element_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::Element> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::Element> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsCOMPtr_open1_nsIObserver_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCOMPtr<root::nsIObserver>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr<root::nsIObserver>> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCOMPtr<root::nsIObserver>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr<root::nsIObserver>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIObserver_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIObserver>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIObserver> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIObserver>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIObserver> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIObserver_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIObserver>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIObserver> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIObserver>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIObserver> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_223076_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::nsIDocument_Element>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIDocument_Element> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::nsIDocument_Element>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIDocument_Element> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_Element_close1_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::Element>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::Element>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::Element>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::Element>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_Element_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::Element> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::Element> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsAutoPtr_open0_nsIDocument_SelectorCache_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsAutoPtr<root::nsIDocument_SelectorCache>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsAutoPtr<root::nsIDocument_SelectorCache> ) ));
        assert_eq!(::std::mem::align_of::<root::nsAutoPtr<root::nsIDocument_SelectorCache>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsAutoPtr<root::nsIDocument_SelectorCache> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_3() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_4() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_URLExtraData_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::URLExtraData>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::URLExtraData> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::URLExtraData>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::URLExtraData> ) ));
    }
    #[test]
    fn __bindgen_test_layout_NotNull_open0__bindgen_ty_id_223625_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::NotNull<*const root::nsIDocument_Encoding>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::NotNull<*const root::nsIDocument_Encoding> )
                   ));
        assert_eq!(::std::mem::align_of::<root::mozilla::NotNull<*const root::nsIDocument_Encoding>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::NotNull<*const root::nsIDocument_Encoding> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_Loader_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::css::Loader>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::css::Loader> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::css::Loader>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::css::Loader> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_ImageLoader_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::css::ImageLoader>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::css::ImageLoader> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::css::ImageLoader>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::css::ImageLoader> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsHTMLStyleSheet_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsHTMLStyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsHTMLStyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsHTMLStyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsHTMLStyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsHTMLCSSStyleSheet_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsHTMLCSSStyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsHTMLCSSStyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsHTMLCSSStyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsHTMLCSSStyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_ImageTracker_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::ImageTracker>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::ImageTracker> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::ImageTracker>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::ImageTracker> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsAutoPtr_open0_nsTHashtable_open1_nsPtrHashKey_open2_nsISupports_close2_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<u64>() , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! ( u64 )
                   ));
        assert_eq!(::std::mem::align_of::<u64>() , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   u64 ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_Link_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::mozilla::dom::Link>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::mozilla::dom::Link> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::mozilla::dom::Link>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::mozilla::dom::Link> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsSMILAnimationController_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsSMILAnimationController>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsSMILAnimationController> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsSMILAnimationController>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsSMILAnimationController> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsAutoPtr_open1_nsPropertyTable_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsAutoPtr<root::nsPropertyTable>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsAutoPtr<root::nsPropertyTable>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsAutoPtr<root::nsPropertyTable>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsAutoPtr<root::nsPropertyTable>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIHTMLCollection_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIHTMLCollection>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIHTMLCollection> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIHTMLCollection>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIHTMLCollection> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_FontFaceSet_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::FontFaceSet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::FontFaceSet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::FontFaceSet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::FontFaceSet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIScriptGlobalObject_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIScriptGlobalObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIScriptGlobalObject> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIScriptGlobalObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIScriptGlobalObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIDocument_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIDocument>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIDocument> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIDocument>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIDocument> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIChannel_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIChannel>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIChannel> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIChannel>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIChannel> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsISupports_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsISupports>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsISupports> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsISupports>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsISupports> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIChannel_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIChannel>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIChannel> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIChannel>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIChannel> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMArray_open0_nsINode_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMArray>() , 8usize , concat
                   ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMArray ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMArray>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMArray ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIDocument_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIDocument>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIDocument> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIDocument>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIDocument> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsWeakPtr_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsWeakPtr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsWeakPtr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsWeakPtr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsWeakPtr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIDocumentEncoder_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIDocumentEncoder>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIDocumentEncoder> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIDocumentEncoder>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIDocumentEncoder> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsIDocument_FrameRequest_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsIDocument_FrameRequest>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsIDocument_FrameRequest> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsIDocument_FrameRequest>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsIDocument_FrameRequest> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIStructuredCloneContainer_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIStructuredCloneContainer>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIStructuredCloneContainer> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIStructuredCloneContainer>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIStructuredCloneContainer> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIVariant_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIVariant>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIVariant> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIVariant>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIVariant> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_XPathEvaluator_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::XPathEvaluator>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::XPathEvaluator> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::XPathEvaluator>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::XPathEvaluator> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_AnonymousContent_close1_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::AnonymousContent>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::AnonymousContent>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::AnonymousContent>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::AnonymousContent>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_LinkedList_open0_MediaQueryList_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::LinkedList>() ,
                   24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::LinkedList ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::LinkedList>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::LinkedList ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_DocGroup_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::DocGroup>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DocGroup> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::DocGroup>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DocGroup> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsCOMPtr_open1_nsIRunnable_close1_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCOMPtr<root::nsIRunnable>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr<root::nsIRunnable>> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCOMPtr<root::nsIRunnable>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr<root::nsIRunnable>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIRunnable_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIRunnable> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIRunnable> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsINode_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsINode>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsINode> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsINode>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsINode> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_CSSRuleListImpl_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::CSSRuleListImpl>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::CSSRuleListImpl> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::CSSRuleListImpl>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::CSSRuleListImpl> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_Element_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::Element> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::Element> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_ServoCSSRuleList_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::ServoCSSRuleList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::ServoCSSRuleList> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::ServoCSSRuleList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::ServoCSSRuleList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_StyleSheet_close1_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_StyleSheet_close0_instantiation_4() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_224047_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_5() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_6() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_7() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIPrincipal_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIPrincipal>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIPrincipal> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIPrincipal>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIPrincipal> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_StyleSheet_close0_instantiation_5() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsCString_close0_instantiation_3() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCString>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCString> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCString>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCString> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_ServoStyleSheet_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::ServoStyleSheet>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::ServoStyleSheet>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::ServoStyleSheet>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::ServoStyleSheet>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_224455_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_RawServoAnimationValue_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::RawServoAnimationValue>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::RawServoAnimationValue> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::RawServoAnimationValue>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::RawServoAnimationValue> ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_RawServoStyleSet_DefaultDelete_open1_RawServoStyleSet_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::RawServoStyleSet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::RawServoStyleSet> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::RawServoStyleSet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::RawServoStyleSet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_open0_RawServoStyleSet_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_ServoStyleSheet_close1_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::ServoStyleSheet>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::ServoStyleSheet>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::ServoStyleSheet>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::ServoStyleSheet>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_PostTraversalTask_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::mozilla::PostTraversalTask>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::PostTraversalTask> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::mozilla::PostTraversalTask>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::PostTraversalTask> ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_nsISMILAttr_DefaultDelete_open1_nsISMILAttr_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsISMILAttr>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsISMILAttr> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsISMILAttr>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsISMILAttr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_open0_nsISMILAttr_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsString_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_225430_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsAutoPtr_open0_nsTHashtable_open1_nsRefPtrHashKey_open2_nsIContent_close2_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<u64>() , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! ( u64 )
                   ));
        assert_eq!(::std::mem::align_of::<u64>() , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   u64 ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsRefPtrHashKey_open0_nsIContent_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsRefPtrHashKey<root::nsIContent>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsRefPtrHashKey<root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::nsRefPtrHashKey<root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsRefPtrHashKey<root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsAutoPtr_open0_nsBindingManager_WrapperHashtable_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsAutoPtr<root::nsBindingManager_WrapperHashtable>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsAutoPtr<root::nsBindingManager_WrapperHashtable> )
                   ));
        assert_eq!(::std::mem::align_of::<root::nsAutoPtr<root::nsBindingManager_WrapperHashtable>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsAutoPtr<root::nsBindingManager_WrapperHashtable> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_nsAutoPtr_open0_nsRefPtrHashtable_open1_nsURIHashKey_nsXBLDocumentInfo_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<u64>() , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! ( u64 )
                   ));
        assert_eq!(::std::mem::align_of::<u64>() , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   u64 ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsAutoPtr_open0_nsInterfaceHashtable_open1_nsURIHashKey_nsIStreamListener_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<u64>() , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! ( u64 )
                   ));
        assert_eq!(::std::mem::align_of::<u64>() , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   u64 ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsRunnableMethod_open1_nsBindingManager_void_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<u64>() , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! ( u64 )
                   ));
        assert_eq!(::std::mem::align_of::<u64>() , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   u64 ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIAtom_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIAtom>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIAtom>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsCSSFontFaceRule_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsCSSFontFaceRule>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsCSSFontFaceRule> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsCSSFontFaceRule>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsCSSFontFaceRule> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_225739_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_225744_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIAtom_close0_instantiation_3() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIAtom>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIAtom>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIStyleRule_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIStyleRule>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIStyleRule> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIStyleRule>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIStyleRule> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_CSSStyleSheet_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::CSSStyleSheet>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::CSSStyleSheet>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::CSSStyleSheet>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::CSSStyleSheet>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_CSSStyleSheet_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::CSSStyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::CSSStyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::CSSStyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::CSSStyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_226237_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_CSSStyleSheet_close1_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::CSSStyleSheet>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::CSSStyleSheet>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::CSSStyleSheet>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::CSSStyleSheet>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_CSSStyleSheet_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::CSSStyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::CSSStyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::CSSStyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::CSSStyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsCOMPtr_open1_nsIStyleRuleProcessor_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCOMPtr<root::nsIStyleRuleProcessor>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr<root::nsIStyleRuleProcessor>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCOMPtr<root::nsIStyleRuleProcessor>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr<root::nsIStyleRuleProcessor>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIStyleRuleProcessor_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIStyleRuleProcessor>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIStyleRuleProcessor> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIStyleRuleProcessor>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIStyleRuleProcessor> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsRect_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsRect>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsRect> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsRect>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsRect> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIDocument_close0_instantiation_3() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIDocument>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIDocument> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIDocument>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIDocument> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsDeviceContext_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsDeviceContext>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsDeviceContext> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsDeviceContext>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsDeviceContext> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_EventStateManager_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::EventStateManager>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::EventStateManager> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::EventStateManager>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::EventStateManager> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsRefreshDriver_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsRefreshDriver>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsRefreshDriver> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsRefreshDriver>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsRefreshDriver> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_EffectCompositor_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::EffectCompositor>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::EffectCompositor> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::EffectCompositor>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::EffectCompositor> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsTransitionManager_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsTransitionManager>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsTransitionManager> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsTransitionManager>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsTransitionManager> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsAnimationManager_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsAnimationManager>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsAnimationManager> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsAnimationManager>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsAnimationManager> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_RestyleManager_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::RestyleManager>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::RestyleManager> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::RestyleManager>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::RestyleManager> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_CounterStyleManager_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::CounterStyleManager>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::CounterStyleManager> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::CounterStyleManager>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::CounterStyleManager> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIAtom_close0_instantiation_4() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIAtom>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIAtom>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_gfxFontFeatureValueSet_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::gfxFontFeatureValueSet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::gfxFontFeatureValueSet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::gfxFontFeatureValueSet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::gfxFontFeatureValueSet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIAtom_close0_instantiation_5() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIAtom>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIAtom>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsITheme_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsITheme>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsITheme> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsITheme>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsITheme> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIPrintSettings_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIPrintSettings>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIPrintSettings> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIPrintSettings>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIPrintSettings> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsITimer_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsITimer>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsITimer> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsITimer>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsITimer> ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_nsBidi_DefaultDelete_open1_nsBidi_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsBidi>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsBidi> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsBidi>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsBidi> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_open0_nsBidi_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsRect_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsRect>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsRect> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsRect>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsRect> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsAutoPtr_open0_gfxTextPerfMetrics_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsAutoPtr<root::gfxTextPerfMetrics>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsAutoPtr<root::gfxTextPerfMetrics> ) ));
        assert_eq!(::std::mem::align_of::<root::nsAutoPtr<root::gfxTextPerfMetrics>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsAutoPtr<root::gfxTextPerfMetrics> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsAutoPtr_open0_gfxMissingFontRecorder_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsAutoPtr<root::gfxMissingFontRecorder>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsAutoPtr<root::gfxMissingFontRecorder> ) ));
        assert_eq!(::std::mem::align_of::<root::nsAutoPtr<root::gfxMissingFontRecorder>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsAutoPtr<root::gfxMissingFontRecorder> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsRefPtrHashKey_open0_nsIAtom_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsRefPtrHashKey<root::nsIAtom>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsRefPtrHashKey<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::nsRefPtrHashKey<root::nsIAtom>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsRefPtrHashKey<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsCOMPtr_open1_nsIAtom_close1_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCOMPtr<root::nsIAtom>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr<root::nsIAtom>> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCOMPtr<root::nsIAtom>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr<root::nsIAtom>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIAtom_close0_instantiation_6() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIAtom>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIAtom>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIPrincipal_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIPrincipal>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIPrincipal> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIPrincipal>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIPrincipal> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIPrincipal_close0_instantiation_3() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIPrincipal>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIPrincipal> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIPrincipal>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIPrincipal> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsBindingManager_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsBindingManager>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsBindingManager> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsBindingManager>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsBindingManager> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsNodeInfoManager_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsNodeInfoManager>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsNodeInfoManager> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsNodeInfoManager>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsNodeInfoManager> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsCString_close0_instantiation_4() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCString>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCString> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCString>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCString> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsString_close0_instantiation_3() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsDOMAttributeMap_Element_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsDOMAttributeMap_Element>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsDOMAttributeMap_Element> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsDOMAttributeMap_Element>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsDOMAttributeMap_Element> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_StyleSheet_close1_close0_instantiation_3() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_StyleSheet_close0_instantiation_6() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_StyleSheet_close1_close0_instantiation_4() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_StyleSheet_close0_instantiation_7() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIContent_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIContent>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIContent_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIContent>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIDocument_close0_instantiation_4() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIDocument>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIDocument> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIDocument>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIDocument> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsPresContext_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsPresContext>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsPresContext> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsPresContext>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsPresContext> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsFrameSelection_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsFrameSelection>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsFrameSelection> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsFrameSelection>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsFrameSelection> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsITimer_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsITimer>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsITimer> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsITimer>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsITimer> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsPtrHashKey_open0_void_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsPtrHashKey<::std::os::raw::c_void>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsPtrHashKey<::std::os::raw::c_void> ) ));
        assert_eq!(::std::mem::align_of::<root::nsPtrHashKey<::std::os::raw::c_void>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsPtrHashKey<::std::os::raw::c_void> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsPtrHashKey_open0_WeakFrame_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsPtrHashKey<root::WeakFrame>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsPtrHashKey<root::WeakFrame> ) ));
        assert_eq!(::std::mem::align_of::<root::nsPtrHashKey<root::WeakFrame>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsPtrHashKey<root::WeakFrame> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsISupports_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsISupports>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsISupports> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsISupports>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsISupports> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIContent_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIContent>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsXBLBinding_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsXBLBinding>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsXBLBinding> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsXBLBinding>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsXBLBinding> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_XBLChildrenElement_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::XBLChildrenElement>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::XBLChildrenElement> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::XBLChildrenElement>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::XBLChildrenElement> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_XBLChildrenElement_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::XBLChildrenElement>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::XBLChildrenElement>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::XBLChildrenElement>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::XBLChildrenElement>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_XBLChildrenElement_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::XBLChildrenElement>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::XBLChildrenElement> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::XBLChildrenElement>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::XBLChildrenElement> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsAnonymousContentList_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsAnonymousContentList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsAnonymousContentList> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsAnonymousContentList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsAnonymousContentList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_8() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_9() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIPrincipal_close0_instantiation_4() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIPrincipal>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIPrincipal> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIPrincipal>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIPrincipal> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIWeakReference_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIWeakReference>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIWeakReference> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIWeakReference>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIWeakReference> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_229067_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut ::std::os::raw::c_void>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut ::std::os::raw::c_void> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut ::std::os::raw::c_void>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut ::std::os::raw::c_void> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsPtrHashKey_open0_void_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsPtrHashKey<::std::os::raw::c_void>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsPtrHashKey<::std::os::raw::c_void> ) ));
        assert_eq!(::std::mem::align_of::<root::nsPtrHashKey<::std::os::raw::c_void>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsPtrHashKey<::std::os::raw::c_void> ) ));
    }
    #[test]
    fn __bindgen_test_layout_StaticRefPtr_open0_nsIContent_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::StaticRefPtr<root::nsIContent>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::StaticRefPtr<root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::StaticRefPtr<root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::StaticRefPtr<root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIAtom_close0_instantiation_7() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIAtom>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIAtom>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIGlobalObject_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIGlobalObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIGlobalObject> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIGlobalObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIGlobalObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_TimeoutManager_DefaultDelete_open1_TimeoutManager_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::mozilla::dom::TimeoutManager>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::mozilla::dom::TimeoutManager>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::mozilla::dom::TimeoutManager>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::mozilla::dom::TimeoutManager>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_open0_TimeoutManager_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_235293_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::mozilla::dom::AudioContext>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::dom::AudioContext> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::mozilla::dom::AudioContext>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::dom::AudioContext> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_ErrorNote_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::xpc::ErrorNote>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::xpc::ErrorNote> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::xpc::ErrorNote>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::xpc::ErrorNote> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_CallbackObject_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::CallbackObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::CallbackObject> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::CallbackObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::CallbackObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Heap_open0__bindgen_ty_id_236462_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::JS::Heap<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Heap<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Heap<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Heap<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_Heap_open0__bindgen_ty_id_236466_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::JS::Heap<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Heap<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Heap<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Heap<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIGlobalObject_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIGlobalObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIGlobalObject> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIGlobalObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIGlobalObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_TenuredHeap_open0__bindgen_ty_id_236473_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::JS::TenuredHeap>() , 8usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::TenuredHeap ) ));
        assert_eq!(::std::mem::align_of::<root::JS::TenuredHeap>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::TenuredHeap ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsCOMPtr_open1_nsISupports_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCOMPtr<root::nsISupports>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr<root::nsISupports>> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCOMPtr<root::nsISupports>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr<root::nsISupports>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsISupports_close0_instantiation_3() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsISupports>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsISupports> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsISupports>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsISupports> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIRunnable_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIRunnable> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIRunnable> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsCOMPtr_open1_nsIRunnable_close1_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCOMPtr<root::nsIRunnable>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr<root::nsIRunnable>> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCOMPtr<root::nsIRunnable>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr<root::nsIRunnable>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIRunnable_close0_instantiation_3() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIRunnable> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIRunnable> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_CycleCollectedJSContext_RunInMetastableStateData_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::mozilla::CycleCollectedJSContext_RunInMetastableStateData>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::CycleCollectedJSContext_RunInMetastableStateData>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::mozilla::CycleCollectedJSContext_RunInMetastableStateData>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::CycleCollectedJSContext_RunInMetastableStateData>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_237926_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::nsISupports>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsISupports> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::nsISupports>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsISupports> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsString_close0_instantiation_4() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_10() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsString_close0_instantiation_5() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_SheetLoadData_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::css::SheetLoadData>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::css::SheetLoadData>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::css::SheetLoadData>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::css::SheetLoadData>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_StyleSheet_close0_instantiation_8() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsAutoPtr_open0_Loader_Sheets_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsAutoPtr<root::mozilla::css::Loader_Sheets>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsAutoPtr<root::mozilla::css::Loader_Sheets> ) ));
        assert_eq!(::std::mem::align_of::<root::nsAutoPtr<root::mozilla::css::Loader_Sheets>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsAutoPtr<root::mozilla::css::Loader_Sheets> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_DocGroup_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::DocGroup>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DocGroup> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::DocGroup>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DocGroup> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIConsoleReportCollector_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIConsoleReportCollector>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIConsoleReportCollector> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIConsoleReportCollector>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIConsoleReportCollector> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_double_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<f64>>() , 8usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<f64> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<f64>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<f64> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_DOMIntersectionObserverEntry_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_DOMIntersectionObserverEntry_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsPIDOMWindowInner_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsPIDOMWindowInner>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsPIDOMWindowInner> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsPIDOMWindowInner>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsPIDOMWindowInner> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsIDocument_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsIDocument>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsIDocument> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsIDocument>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsIDocument> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_IntersectionCallback_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::IntersectionCallback>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::IntersectionCallback> )
                   ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::IntersectionCallback>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::IntersectionCallback> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_Element_close0_instantiation_3() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::Element> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::Element> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_double_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<f64>>() , 8usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<f64> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<f64>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<f64> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_239297_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::dom::Element> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::dom::Element> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_DOMIntersectionObserverEntry_close1_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_DOMIntersectionObserverEntry_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_ProfilerBacktrace_ProfilerBacktraceDestructor_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::ProfilerBacktrace>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::ProfilerBacktrace> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::ProfilerBacktrace>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::ProfilerBacktrace> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsString_close0_instantiation_6() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIAtom_close0_instantiation_8() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIAtom>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIAtom>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsAutoPtr_open0_LangGroupFontPrefs_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsAutoPtr<root::mozilla::LangGroupFontPrefs>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsAutoPtr<root::mozilla::LangGroupFontPrefs> ) ));
        assert_eq!(::std::mem::align_of::<root::nsAutoPtr<root::mozilla::LangGroupFontPrefs>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsAutoPtr<root::mozilla::LangGroupFontPrefs> ) ));
    }
    #[test]
    fn __bindgen_test_layout_OwningNonNull_open0_EffectCompositor_AnimationStyleRuleProcessor_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::OwningNonNull<root::mozilla::EffectCompositor_AnimationStyleRuleProcessor>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::OwningNonNull<root::mozilla::EffectCompositor_AnimationStyleRuleProcessor>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::OwningNonNull<root::mozilla::EffectCompositor_AnimationStyleRuleProcessor>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::OwningNonNull<root::mozilla::EffectCompositor_AnimationStyleRuleProcessor>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsRefPtrHashKey_open0_nsIAtom_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsRefPtrHashKey<root::nsIAtom>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsRefPtrHashKey<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::nsRefPtrHashKey<root::nsIAtom>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsRefPtrHashKey<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_241701_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::mozilla::CounterStyle>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::CounterStyle> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::mozilla::CounterStyle>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::CounterStyle> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsCOMPtr_open1_nsIRunnable_close1_close0_instantiation_3() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCOMPtr<root::nsIRunnable>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr<root::nsIRunnable>> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCOMPtr<root::nsIRunnable>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr<root::nsIRunnable>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIRunnable_close0_instantiation_4() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIRunnable> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIRunnable> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsString_close0_instantiation_7() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_URLParams_DefaultDelete_open1_URLParams_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::mozilla::dom::URLParams>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::mozilla::dom::URLParams> )
                   ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::mozilla::dom::URLParams>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::mozilla::dom::URLParams> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_open0_URLParams_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsString_close0_instantiation_8() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_URLParams_Param_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::mozilla::dom::URLParams_Param>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::dom::URLParams_Param> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::mozilla::dom::URLParams_Param>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::dom::URLParams_Param> ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_const_char_XREAppData_NSFreePolicy_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<::std::os::raw::c_char>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<::std::os::raw::c_char> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<::std::os::raw::c_char>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<::std::os::raw::c_char> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_SchedulerGroup_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::SchedulerGroup>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::SchedulerGroup> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::SchedulerGroup>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::SchedulerGroup> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIRunnable_close0_instantiation_5() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIRunnable> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIRunnable> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_SchedulerGroup_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::SchedulerGroup>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::SchedulerGroup> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::SchedulerGroup>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::SchedulerGroup> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsISerialEventTarget_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsISerialEventTarget>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsISerialEventTarget> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsISerialEventTarget>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsISerialEventTarget> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_AbstractThread_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::AbstractThread>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::AbstractThread> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::AbstractThread>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::AbstractThread> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_SchedulerGroup_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::SchedulerGroup>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::SchedulerGroup> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::SchedulerGroup>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::SchedulerGroup> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIEventTarget_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIEventTarget>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIEventTarget> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIEventTarget>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIEventTarget> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_imgRequestProxy_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::imgRequestProxy>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::imgRequestProxy> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::imgRequestProxy>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::imgRequestProxy> ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_ProxyBehaviour_DefaultDelete_open1_ProxyBehaviour_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::ProxyBehaviour>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::ProxyBehaviour> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::ProxyBehaviour>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::ProxyBehaviour> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_open0_ProxyBehaviour_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_imgRequestProxy_ImageURL_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::imgRequestProxy_ImageURL>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::imgRequestProxy_ImageURL> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::imgRequestProxy_ImageURL>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::imgRequestProxy_ImageURL> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsILoadGroup_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsILoadGroup>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsILoadGroup> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsILoadGroup>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsILoadGroup> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_TabGroup_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::TabGroup>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::TabGroup> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::TabGroup>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::TabGroup> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIEventTarget_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIEventTarget>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIEventTarget> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIEventTarget>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIEventTarget> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsMainThreadPtrHolder_open0_nsIURI_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsMainThreadPtrHolder<root::nsIURI>>()
                   , 40usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsMainThreadPtrHolder<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::nsMainThreadPtrHolder<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsMainThreadPtrHolder<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsMainThreadPtrHandle_open0_nsIURI_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsMainThreadPtrHandle<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsMainThreadPtrHandle<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::nsMainThreadPtrHandle<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsMainThreadPtrHandle<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_URLExtraData_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::URLExtraData>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::URLExtraData> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::URLExtraData>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::URLExtraData> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsPtrHashKey_open0_nsIDocument_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsPtrHashKey<root::nsIDocument>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsPtrHashKey<root::nsIDocument> ) ));
        assert_eq!(::std::mem::align_of::<root::nsPtrHashKey<root::nsIDocument>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsPtrHashKey<root::nsIDocument> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_GridNamedArea_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::mozilla::css::GridNamedArea>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::css::GridNamedArea> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::mozilla::css::GridNamedArea>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::css::GridNamedArea> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsString_close0_instantiation_9() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsCSSValueGradientStop_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCSSValueGradientStop>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCSSValueGradientStop> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCSSValueGradientStop>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCSSValueGradientStop> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_11() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_12() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIPrincipal_close0_instantiation_5() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIPrincipal>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIPrincipal> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIPrincipal>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIPrincipal> ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_nsCSSValueList_DefaultDelete_open1_nsCSSValueList_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsCSSValueList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsCSSValueList> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsCSSValueList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsCSSValueList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_open0_nsCSSValueList_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_nsCSSValuePairList_DefaultDelete_open1_nsCSSValuePairList_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsCSSValuePairList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsCSSValuePairList> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsCSSValuePairList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsCSSValuePairList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_open0_nsCSSValuePairList_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsString_close0_instantiation_10() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsString_close0_instantiation_11() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsString_close0_instantiation_12() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsStyleGradientStop_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsStyleGradientStop>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleGradientStop> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsStyleGradientStop>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleGradientStop> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_imgRequestProxy_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::imgRequestProxy>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::imgRequestProxy> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::imgRequestProxy>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::imgRequestProxy> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_ImageValue_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::css::ImageValue>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::css::ImageValue> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::css::ImageValue>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::css::ImageValue> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_ImageTracker_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::ImageTracker>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::ImageTracker> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::ImageTracker>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::ImageTracker> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_DocGroup_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::DocGroup>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DocGroup> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::DocGroup>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DocGroup> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMArray_open0_imgIContainer_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMArray>() , 8usize , concat
                   ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMArray ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMArray>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMArray ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_nsStyleSides_DefaultDelete_open1_nsStyleSides_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsStyleSides>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsStyleSides> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsStyleSides>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsStyleSides> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_open0_nsStyleSides_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_nsStyleSides_DefaultDelete_open1_nsStyleSides_close1_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsStyleSides>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsStyleSides> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsStyleSides>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsStyleSides> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_open0_nsStyleSides_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_CachedBorderImageData_DefaultDelete_open1_CachedBorderImageData_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::CachedBorderImageData>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::CachedBorderImageData> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::CachedBorderImageData>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::CachedBorderImageData> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_open0_CachedBorderImageData_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_nsStyleSides_DefaultDelete_open1_nsStyleSides_close1_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsStyleSides>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsStyleSides> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsStyleSides>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsStyleSides> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_open0_nsStyleSides_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsStyleAutoArray_open0_nsStyleImageLayers_Layer_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsStyleAutoArray<root::nsStyleImageLayers_Layer>>()
                   , 104usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsStyleAutoArray<root::nsStyleImageLayers_Layer> )
                   ));
        assert_eq!(::std::mem::align_of::<root::nsStyleAutoArray<root::nsStyleImageLayers_Layer>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsStyleAutoArray<root::nsStyleImageLayers_Layer> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_pair_open1_nsString_nsString_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::std::pair<::nsstring::nsStringRepr,
                                                     ::nsstring::nsStringRepr>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::std::pair<::nsstring::nsStringRepr,
                                                      ::nsstring::nsStringRepr>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_pair_open0_nsString_nsString_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr>>()
                   , 32usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsTArray_open1_nsString_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsTArray<::nsstring::nsStringRepr>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsTArray<::nsstring::nsStringRepr>> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsTArray<::nsstring::nsStringRepr>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsTArray<::nsstring::nsStringRepr>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsString_close0_instantiation_13() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsStyleCoord_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsStyleCoord>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleCoord> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsStyleCoord>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleCoord> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsStyleCoord_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsStyleCoord>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleCoord> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsStyleCoord>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleCoord> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsString_close0_instantiation_14() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsString_close0_instantiation_15() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIAtom_close0_instantiation_9() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIAtom>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIAtom>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsStyleCoord_close0_instantiation_3() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsStyleCoord>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleCoord> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsStyleCoord>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleCoord> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsStyleCoord_close0_instantiation_4() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsStyleCoord>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleCoord> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsStyleCoord>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleCoord> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsStyleCoord_close0_instantiation_5() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsStyleCoord>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleCoord> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsStyleCoord>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsStyleCoord> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_URLValue_close0_instantiation_3() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::css::URLValue>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::css::URLValue> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::css::URLValue>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::css::URLValue> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsStyleImageRequest_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsStyleImageRequest>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsStyleImageRequest> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsStyleImageRequest>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsStyleImageRequest> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_244267_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::nsISupports>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsISupports> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::nsISupports>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsISupports> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_ServoAttrSnapshot_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::mozilla::ServoAttrSnapshot>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::ServoAttrSnapshot> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::mozilla::ServoAttrSnapshot>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::ServoAttrSnapshot> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_PropertyValuePair_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::mozilla::PropertyValuePair>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::PropertyValuePair> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::mozilla::PropertyValuePair>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::PropertyValuePair> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_RawServoDeclarationBlock_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::RawServoDeclarationBlock>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::RawServoDeclarationBlock> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::RawServoDeclarationBlock>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::RawServoDeclarationBlock> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_RawServoAnimationValue_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::RawServoAnimationValue>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::RawServoAnimationValue> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::RawServoAnimationValue>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::RawServoAnimationValue> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_PropertyValuePair_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::mozilla::PropertyValuePair>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::PropertyValuePair> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::mozilla::PropertyValuePair>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::PropertyValuePair> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsStyleAutoArray_open0_StyleAnimation_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsStyleAutoArray<root::mozilla::StyleAnimation>>()
                   , 64usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsStyleAutoArray<root::mozilla::StyleAnimation> ) ));
        assert_eq!(::std::mem::align_of::<root::nsStyleAutoArray<root::mozilla::StyleAnimation>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsStyleAutoArray<root::mozilla::StyleAnimation> ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_nsCSSValueList_DefaultDelete_open1_nsCSSValueList_close1_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsCSSValueList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsCSSValueList> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsCSSValueList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsCSSValueList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_open0_nsCSSValueList_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_nsCSSValuePairList_DefaultDelete_open1_nsCSSValuePairList_close1_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsCSSValuePairList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsCSSValuePairList> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsCSSValuePairList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsCSSValuePairList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_open0_nsCSSValuePairList_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_RawServoAnimationValue_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::RawServoAnimationValue>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::RawServoAnimationValue> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::RawServoAnimationValue>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::RawServoAnimationValue> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_StyleSheet_close1_close0_instantiation_5() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::StyleSheet>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_StyleSheet_close0_instantiation_9() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_RawServoStyleSheetContents_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::RawServoStyleSheetContents>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::RawServoStyleSheetContents> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::RawServoStyleSheetContents>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::RawServoStyleSheetContents> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_URLExtraData_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::URLExtraData>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::URLExtraData> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::URLExtraData>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::URLExtraData> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsMediaQueryResultCacheKey_ExpressionEntry_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsMediaQueryResultCacheKey_ExpressionEntry>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsMediaQueryResultCacheKey_ExpressionEntry>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsMediaQueryResultCacheKey_ExpressionEntry>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsMediaQueryResultCacheKey_ExpressionEntry>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsMediaQueryResultCacheKey_FeatureEntry_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsMediaQueryResultCacheKey_FeatureEntry>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsMediaQueryResultCacheKey_FeatureEntry>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsMediaQueryResultCacheKey_FeatureEntry>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsMediaQueryResultCacheKey_FeatureEntry>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIPrincipal_close0_instantiation_6() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIPrincipal>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIPrincipal> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIPrincipal>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIPrincipal> ) ));
    }
    #[test]
    fn __bindgen_test_layout_BaseTimeDuration_open0_StickyTimeDurationValueCalculator_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::BaseTimeDuration>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::BaseTimeDuration ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::BaseTimeDuration>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::BaseTimeDuration ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_13() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIURI>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_251963_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_251968_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIContent_close0_instantiation_3() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIContent>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsICSSDeclaration_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsICSSDeclaration>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsICSSDeclaration> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsICSSDeclaration>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsICSSDeclaration> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_DeclarationBlock_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::DeclarationBlock>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::DeclarationBlock> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::DeclarationBlock>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::DeclarationBlock> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIControllers_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIControllers>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIControllers> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIControllers>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIControllers> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsLabelsNodeList_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsLabelsNodeList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsLabelsNodeList> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsLabelsNodeList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsLabelsNodeList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_ShadowRoot_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::ShadowRoot>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::ShadowRoot> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::ShadowRoot>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::ShadowRoot> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_ShadowRoot_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::ShadowRoot>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::ShadowRoot> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::ShadowRoot>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::ShadowRoot> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_252081_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsXBLBinding_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsXBLBinding>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsXBLBinding> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsXBLBinding>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsXBLBinding> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIContent_close0_instantiation_4() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIContent>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_CustomElementData_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::CustomElementData>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::CustomElementData> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::CustomElementData>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::CustomElementData> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsRefPtrHashKey_open0_DOMIntersectionObserver_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsRefPtrHashKey<root::mozilla::dom::DOMIntersectionObserver>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsRefPtrHashKey<root::mozilla::dom::DOMIntersectionObserver>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsRefPtrHashKey<root::mozilla::dom::DOMIntersectionObserver>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsRefPtrHashKey<root::mozilla::dom::DOMIntersectionObserver>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsISupports_close0_instantiation_4() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsISupports>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsISupports> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsISupports>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsISupports> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsICSSDeclaration_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsICSSDeclaration>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsICSSDeclaration> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsICSSDeclaration>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsICSSDeclaration> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsDOMAttributeMap_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsDOMAttributeMap>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsDOMAttributeMap> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsDOMAttributeMap>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsDOMAttributeMap> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsContentList_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsContentList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsContentList> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsContentList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsContentList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsDOMTokenList_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsDOMTokenList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsDOMTokenList> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsDOMTokenList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsDOMTokenList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_FragmentOrElement_nsExtendedDOMSlots_DefaultDelete_open1_FragmentOrElement_nsExtendedDOMSlots_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::mozilla::dom::FragmentOrElement_nsExtendedDOMSlots>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::mozilla::dom::FragmentOrElement_nsExtendedDOMSlots>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::mozilla::dom::FragmentOrElement_nsExtendedDOMSlots>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::mozilla::dom::FragmentOrElement_nsExtendedDOMSlots>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_open0_FragmentOrElement_nsExtendedDOMSlots_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsDOMAttributeMap_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsDOMAttributeMap>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsDOMAttributeMap> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsDOMAttributeMap>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsDOMAttributeMap> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_DisplayItemClip_RoundedRect_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::mozilla::DisplayItemClip_RoundedRect>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::DisplayItemClip_RoundedRect>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::mozilla::DisplayItemClip_RoundedRect>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::DisplayItemClip_RoundedRect>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_DisplayItemClip_RoundedRect_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::mozilla::DisplayItemClip_RoundedRect>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::DisplayItemClip_RoundedRect>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::mozilla::DisplayItemClip_RoundedRect>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::DisplayItemClip_RoundedRect>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsPoint_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsPoint>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsPoint> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsPoint>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsPoint> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_DOMRect_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::DOMRect>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::DOMRect>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::DOMRect>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::DOMRect>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_DOMRect_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::DOMRect>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DOMRect> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::DOMRect>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DOMRect> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsISupports_close0_instantiation_5() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsISupports>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsISupports> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsISupports>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsISupports> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_DOMRect_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::DOMRect>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DOMRect> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::DOMRect>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DOMRect> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_DOMRect_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::DOMRect>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DOMRect> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::DOMRect>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DOMRect> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_DOMRect_close0_instantiation_3() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::DOMRect>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DOMRect> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::DOMRect>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DOMRect> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_Element_close0_instantiation_4() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::Element> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::Element> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsRefPtrHashKey_open0_Element_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsRefPtrHashKey<root::mozilla::dom::Element>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsRefPtrHashKey<root::mozilla::dom::Element> ) ));
        assert_eq!(::std::mem::align_of::<root::nsRefPtrHashKey<root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsRefPtrHashKey<root::mozilla::dom::Element> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsAutoPtr_open0_ExplicitChildIterator_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsAutoPtr<root::mozilla::dom::ExplicitChildIterator>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsAutoPtr<root::mozilla::dom::ExplicitChildIterator>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsAutoPtr<root::mozilla::dom::ExplicitChildIterator>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsAutoPtr<root::mozilla::dom::ExplicitChildIterator>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_253688_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_Element_close0_instantiation_5() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::Element> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::Element> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_253848_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_253853_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_unsigned_int_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::std::os::raw::c_uint>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::std::os::raw::c_uint> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::std::os::raw::c_uint>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::std::os::raw::c_uint> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsString_close0_instantiation_16() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_nsStyleGridTemplate_DefaultDelete_open1_nsStyleGridTemplate_close1_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsStyleGridTemplate>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsStyleGridTemplate> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsStyleGridTemplate>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsStyleGridTemplate> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_open0_nsStyleGridTemplate_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_UniquePtr_open0_nsStyleGridTemplate_DefaultDelete_open1_nsStyleGridTemplate_close1_close0_instantiation_3() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsStyleGridTemplate>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsStyleGridTemplate> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsStyleGridTemplate>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsStyleGridTemplate> ) ));
    }
    #[test]
    fn __bindgen_test_layout_DefaultDelete_open0_nsStyleGridTemplate_close0_instantiation_3() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete>() ,
                   1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_RawServoMediaList_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::RawServoMediaList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::RawServoMediaList> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::RawServoMediaList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::RawServoMediaList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_nsXBLBinding_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::nsXBLBinding>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::nsXBLBinding>> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::nsXBLBinding>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::nsXBLBinding>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_RefPtr_open0_nsXBLBinding_close0_instantiation_2() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::nsXBLBinding>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::nsXBLBinding> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::nsXBLBinding>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::nsXBLBinding> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_gfxFontFeature_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::gfxFontFeature>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::gfxFontFeature> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::gfxFontFeature>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::gfxFontFeature> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_gfxFontVariation_close0_instantiation_1() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::gfxFontVariation>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::gfxFontVariation> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::gfxFontVariation>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::gfxFontVariation> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_256860_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::mozilla::css::DocumentRule>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::css::DocumentRule> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::mozilla::css::DocumentRule>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::css::DocumentRule> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0__bindgen_ty_id_256868_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::mozilla::css::DocumentRule>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::css::DocumentRule> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::mozilla::css::DocumentRule>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::css::DocumentRule> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsCOMPtr_open0_nsIAtom_close0_instantiation_10() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIAtom>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIAtom>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsMediaExpression_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsMediaExpression>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsMediaExpression> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsMediaExpression>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsMediaExpression> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsTArray_open0_nsAutoPtr_open1_nsMediaQuery_close1_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsAutoPtr<root::nsMediaQuery>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsAutoPtr<root::nsMediaQuery>> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsAutoPtr<root::nsMediaQuery>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsAutoPtr<root::nsMediaQuery>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_nsAutoPtr_open0_nsMediaQuery_close0_instantiation() {
        assert_eq!(::std::mem::size_of::<root::nsAutoPtr<root::nsMediaQuery>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsAutoPtr<root::nsMediaQuery> ) ));
        assert_eq!(::std::mem::align_of::<root::nsAutoPtr<root::nsMediaQuery>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsAutoPtr<root::nsMediaQuery> ) ));
    }
}
