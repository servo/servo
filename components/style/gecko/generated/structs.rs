/* automatically generated by rust-bindgen */

pub use self::root::*;
pub use self::root::mozilla::*;
pub use self::root::mozilla::css::*;
pub use self::root::mozilla::dom::*;
use atomic_refcell::AtomicRefCell;
use data::ElementData;
pub type ServoUnsafeCell<T> = ::std::cell::UnsafeCell<T>;
pub type ServoCell<T> = ::std::cell::Cell<T>;
pub type ServoNodeData = AtomicRefCell<ElementData>;
pub type ServoWritingMode = ::logical_geometry::WritingMode;
pub type ServoCustomPropertiesMap = Option<::servo_arc::Arc<::custom_properties::CustomPropertiesMap>>;
pub type ServoRuleNode = Option<::rule_tree::StrongRuleNode>;
pub type ServoVisitedStyle = Option<::servo_arc::RawOffsetArc<::properties::ComputedValues>>;
pub type ServoComputedValueFlags = ::properties::computed_value_flags::ComputedValueFlags;
pub type ServoRawOffsetArc<T> = ::servo_arc::RawOffsetArc<T>;
pub type ServoStyleContextStrong = ::gecko_bindings::sugar::ownership::Strong<::properties::ComputedValues>;

# [ allow ( non_snake_case , non_camel_case_types , non_upper_case_globals ) ] pub mod root { # [ repr ( C ) ] pub struct __BindgenUnionField < T > ( :: std :: marker :: PhantomData < T > ) ; impl < T > __BindgenUnionField < T > { # [ inline ] pub fn new ( ) -> Self { __BindgenUnionField ( :: std :: marker :: PhantomData ) } # [ inline ] pub unsafe fn as_ref ( & self ) -> & T { :: std :: mem :: transmute ( self ) } # [ inline ] pub unsafe fn as_mut ( & mut self ) -> & mut T { :: std :: mem :: transmute ( self ) } } impl < T > :: std :: default :: Default for __BindgenUnionField < T > { # [ inline ] fn default ( ) -> Self { Self :: new ( ) } } impl < T > :: std :: clone :: Clone for __BindgenUnionField < T > { # [ inline ] fn clone ( & self ) -> Self { Self :: new ( ) } } impl < T > :: std :: marker :: Copy for __BindgenUnionField < T > { } impl < T > :: std :: fmt :: Debug for __BindgenUnionField < T > { fn fmt ( & self , fmt : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { fmt . write_str ( "__BindgenUnionField" ) } } impl < T > :: std :: hash :: Hash for __BindgenUnionField < T > { fn hash < H : :: std :: hash :: Hasher > ( & self , _state : & mut H ) { } } impl < T > :: std :: cmp :: PartialEq for __BindgenUnionField < T > { fn eq ( & self , _other : & __BindgenUnionField < T > ) -> bool { true } } impl < T > :: std :: cmp :: Eq for __BindgenUnionField < T > { } # [ allow ( unused_imports ) ] use self :: super :: root ; pub const NS_FONT_STYLE_NORMAL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_FONT_STYLE_ITALIC : :: std :: os :: raw :: c_uint = 1 ; pub const NS_FONT_STYLE_OBLIQUE : :: std :: os :: raw :: c_uint = 2 ; pub const NS_FONT_WEIGHT_NORMAL : :: std :: os :: raw :: c_uint = 400 ; pub const NS_FONT_WEIGHT_BOLD : :: std :: os :: raw :: c_uint = 700 ; pub const NS_FONT_WEIGHT_THIN : :: std :: os :: raw :: c_uint = 100 ; pub const NS_FONT_STRETCH_ULTRA_CONDENSED : :: std :: os :: raw :: c_int = -4 ; pub const NS_FONT_STRETCH_EXTRA_CONDENSED : :: std :: os :: raw :: c_int = -3 ; pub const NS_FONT_STRETCH_CONDENSED : :: std :: os :: raw :: c_int = -2 ; pub const NS_FONT_STRETCH_SEMI_CONDENSED : :: std :: os :: raw :: c_int = -1 ; pub const NS_FONT_STRETCH_NORMAL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_FONT_STRETCH_SEMI_EXPANDED : :: std :: os :: raw :: c_uint = 1 ; pub const NS_FONT_STRETCH_EXPANDED : :: std :: os :: raw :: c_uint = 2 ; pub const NS_FONT_STRETCH_EXTRA_EXPANDED : :: std :: os :: raw :: c_uint = 3 ; pub const NS_FONT_STRETCH_ULTRA_EXPANDED : :: std :: os :: raw :: c_uint = 4 ; pub const NS_FONT_SMOOTHING_AUTO : :: std :: os :: raw :: c_uint = 0 ; pub const NS_FONT_SMOOTHING_GRAYSCALE : :: std :: os :: raw :: c_uint = 1 ; pub const NS_FONT_KERNING_AUTO : :: std :: os :: raw :: c_uint = 0 ; pub const NS_FONT_KERNING_NONE : :: std :: os :: raw :: c_uint = 1 ; pub const NS_FONT_KERNING_NORMAL : :: std :: os :: raw :: c_uint = 2 ; pub const NS_FONT_SYNTHESIS_WEIGHT : :: std :: os :: raw :: c_uint = 1 ; pub const NS_FONT_SYNTHESIS_STYLE : :: std :: os :: raw :: c_uint = 2 ; pub const NS_FONT_DISPLAY_AUTO : :: std :: os :: raw :: c_uint = 0 ; pub const NS_FONT_DISPLAY_BLOCK : :: std :: os :: raw :: c_uint = 1 ; pub const NS_FONT_DISPLAY_SWAP : :: std :: os :: raw :: c_uint = 2 ; pub const NS_FONT_DISPLAY_FALLBACK : :: std :: os :: raw :: c_uint = 3 ; pub const NS_FONT_DISPLAY_OPTIONAL : :: std :: os :: raw :: c_uint = 4 ; pub const NS_FONT_VARIANT_ALTERNATES_NORMAL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_FONT_VARIANT_ALTERNATES_HISTORICAL : :: std :: os :: raw :: c_uint = 1 ; pub const NS_FONT_VARIANT_ALTERNATES_STYLISTIC : :: std :: os :: raw :: c_uint = 2 ; pub const NS_FONT_VARIANT_ALTERNATES_STYLESET : :: std :: os :: raw :: c_uint = 4 ; pub const NS_FONT_VARIANT_ALTERNATES_CHARACTER_VARIANT : :: std :: os :: raw :: c_uint = 8 ; pub const NS_FONT_VARIANT_ALTERNATES_SWASH : :: std :: os :: raw :: c_uint = 16 ; pub const NS_FONT_VARIANT_ALTERNATES_ORNAMENTS : :: std :: os :: raw :: c_uint = 32 ; pub const NS_FONT_VARIANT_ALTERNATES_ANNOTATION : :: std :: os :: raw :: c_uint = 64 ; pub const NS_FONT_VARIANT_ALTERNATES_COUNT : :: std :: os :: raw :: c_uint = 7 ; pub const NS_FONT_VARIANT_ALTERNATES_ENUMERATED_MASK : :: std :: os :: raw :: c_uint = 1 ; pub const NS_FONT_VARIANT_ALTERNATES_FUNCTIONAL_MASK : :: std :: os :: raw :: c_uint = 126 ; pub const NS_FONT_VARIANT_CAPS_NORMAL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_FONT_VARIANT_CAPS_SMALLCAPS : :: std :: os :: raw :: c_uint = 1 ; pub const NS_FONT_VARIANT_CAPS_ALLSMALL : :: std :: os :: raw :: c_uint = 2 ; pub const NS_FONT_VARIANT_CAPS_PETITECAPS : :: std :: os :: raw :: c_uint = 3 ; pub const NS_FONT_VARIANT_CAPS_ALLPETITE : :: std :: os :: raw :: c_uint = 4 ; pub const NS_FONT_VARIANT_CAPS_TITLING : :: std :: os :: raw :: c_uint = 5 ; pub const NS_FONT_VARIANT_CAPS_UNICASE : :: std :: os :: raw :: c_uint = 6 ; pub const NS_FONT_VARIANT_EAST_ASIAN_NORMAL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_FONT_VARIANT_EAST_ASIAN_JIS78 : :: std :: os :: raw :: c_uint = 1 ; pub const NS_FONT_VARIANT_EAST_ASIAN_JIS83 : :: std :: os :: raw :: c_uint = 2 ; pub const NS_FONT_VARIANT_EAST_ASIAN_JIS90 : :: std :: os :: raw :: c_uint = 4 ; pub const NS_FONT_VARIANT_EAST_ASIAN_JIS04 : :: std :: os :: raw :: c_uint = 8 ; pub const NS_FONT_VARIANT_EAST_ASIAN_SIMPLIFIED : :: std :: os :: raw :: c_uint = 16 ; pub const NS_FONT_VARIANT_EAST_ASIAN_TRADITIONAL : :: std :: os :: raw :: c_uint = 32 ; pub const NS_FONT_VARIANT_EAST_ASIAN_FULL_WIDTH : :: std :: os :: raw :: c_uint = 64 ; pub const NS_FONT_VARIANT_EAST_ASIAN_PROP_WIDTH : :: std :: os :: raw :: c_uint = 128 ; pub const NS_FONT_VARIANT_EAST_ASIAN_RUBY : :: std :: os :: raw :: c_uint = 256 ; pub const NS_FONT_VARIANT_EAST_ASIAN_COUNT : :: std :: os :: raw :: c_uint = 9 ; pub const NS_FONT_VARIANT_EAST_ASIAN_VARIANT_MASK : :: std :: os :: raw :: c_uint = 63 ; pub const NS_FONT_VARIANT_EAST_ASIAN_WIDTH_MASK : :: std :: os :: raw :: c_uint = 192 ; pub const NS_FONT_VARIANT_LIGATURES_NORMAL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_FONT_VARIANT_LIGATURES_NONE : :: std :: os :: raw :: c_uint = 1 ; pub const NS_FONT_VARIANT_LIGATURES_COMMON : :: std :: os :: raw :: c_uint = 2 ; pub const NS_FONT_VARIANT_LIGATURES_NO_COMMON : :: std :: os :: raw :: c_uint = 4 ; pub const NS_FONT_VARIANT_LIGATURES_DISCRETIONARY : :: std :: os :: raw :: c_uint = 8 ; pub const NS_FONT_VARIANT_LIGATURES_NO_DISCRETIONARY : :: std :: os :: raw :: c_uint = 16 ; pub const NS_FONT_VARIANT_LIGATURES_HISTORICAL : :: std :: os :: raw :: c_uint = 32 ; pub const NS_FONT_VARIANT_LIGATURES_NO_HISTORICAL : :: std :: os :: raw :: c_uint = 64 ; pub const NS_FONT_VARIANT_LIGATURES_CONTEXTUAL : :: std :: os :: raw :: c_uint = 128 ; pub const NS_FONT_VARIANT_LIGATURES_NO_CONTEXTUAL : :: std :: os :: raw :: c_uint = 256 ; pub const NS_FONT_VARIANT_LIGATURES_COUNT : :: std :: os :: raw :: c_uint = 9 ; pub const NS_FONT_VARIANT_LIGATURES_COMMON_MASK : :: std :: os :: raw :: c_uint = 6 ; pub const NS_FONT_VARIANT_LIGATURES_DISCRETIONARY_MASK : :: std :: os :: raw :: c_uint = 24 ; pub const NS_FONT_VARIANT_LIGATURES_HISTORICAL_MASK : :: std :: os :: raw :: c_uint = 96 ; pub const NS_FONT_VARIANT_LIGATURES_CONTEXTUAL_MASK : :: std :: os :: raw :: c_uint = 384 ; pub const NS_FONT_VARIANT_NUMERIC_NORMAL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_FONT_VARIANT_NUMERIC_LINING : :: std :: os :: raw :: c_uint = 1 ; pub const NS_FONT_VARIANT_NUMERIC_OLDSTYLE : :: std :: os :: raw :: c_uint = 2 ; pub const NS_FONT_VARIANT_NUMERIC_PROPORTIONAL : :: std :: os :: raw :: c_uint = 4 ; pub const NS_FONT_VARIANT_NUMERIC_TABULAR : :: std :: os :: raw :: c_uint = 8 ; pub const NS_FONT_VARIANT_NUMERIC_DIAGONAL_FRACTIONS : :: std :: os :: raw :: c_uint = 16 ; pub const NS_FONT_VARIANT_NUMERIC_STACKED_FRACTIONS : :: std :: os :: raw :: c_uint = 32 ; pub const NS_FONT_VARIANT_NUMERIC_SLASHZERO : :: std :: os :: raw :: c_uint = 64 ; pub const NS_FONT_VARIANT_NUMERIC_ORDINAL : :: std :: os :: raw :: c_uint = 128 ; pub const NS_FONT_VARIANT_NUMERIC_COUNT : :: std :: os :: raw :: c_uint = 8 ; pub const NS_FONT_VARIANT_NUMERIC_FIGURE_MASK : :: std :: os :: raw :: c_uint = 3 ; pub const NS_FONT_VARIANT_NUMERIC_SPACING_MASK : :: std :: os :: raw :: c_uint = 12 ; pub const NS_FONT_VARIANT_NUMERIC_FRACTION_MASK : :: std :: os :: raw :: c_uint = 48 ; pub const NS_FONT_VARIANT_POSITION_NORMAL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_FONT_VARIANT_POSITION_SUPER : :: std :: os :: raw :: c_uint = 1 ; pub const NS_FONT_VARIANT_POSITION_SUB : :: std :: os :: raw :: c_uint = 2 ; pub const NS_FONT_VARIANT_WIDTH_NORMAL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_FONT_VARIANT_WIDTH_FULL : :: std :: os :: raw :: c_uint = 1 ; pub const NS_FONT_VARIANT_WIDTH_HALF : :: std :: os :: raw :: c_uint = 2 ; pub const NS_FONT_VARIANT_WIDTH_THIRD : :: std :: os :: raw :: c_uint = 3 ; pub const NS_FONT_VARIANT_WIDTH_QUARTER : :: std :: os :: raw :: c_uint = 4 ; pub const NS_FONT_SUBSCRIPT_OFFSET_RATIO : f64 = 0.2 ; pub const NS_FONT_SUPERSCRIPT_OFFSET_RATIO : f64 = 0.34 ; pub const NS_FONT_SUB_SUPER_SIZE_RATIO_SMALL : f64 = 0.82 ; pub const NS_FONT_SUB_SUPER_SIZE_RATIO_LARGE : f64 = 0.667 ; pub const NS_FONT_SUB_SUPER_SMALL_SIZE : f64 = 20. ; pub const NS_FONT_SUB_SUPER_LARGE_SIZE : f64 = 45. ; pub const NS_FONT_VARIANT_NORMAL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_FONT_VARIANT_SMALL_CAPS : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_COLOR_INHERIT_FROM_BODY : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_WILL_CHANGE_STACKING_CONTEXT : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_WILL_CHANGE_TRANSFORM : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_WILL_CHANGE_SCROLL : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_WILL_CHANGE_OPACITY : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_WILL_CHANGE_FIXPOS_CB : :: std :: os :: raw :: c_uint = 16 ; pub const NS_STYLE_WILL_CHANGE_ABSPOS_CB : :: std :: os :: raw :: c_uint = 32 ; pub const NS_STYLE_ANIMATION_ITERATION_COUNT_INFINITE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_ANIMATION_PLAY_STATE_RUNNING : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_ANIMATION_PLAY_STATE_PAUSED : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_IMAGELAYER_ATTACHMENT_SCROLL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_IMAGELAYER_ATTACHMENT_FIXED : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_IMAGELAYER_ATTACHMENT_LOCAL : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_IMAGELAYER_CLIP_MOZ_ALMOST_PADDING : :: std :: os :: raw :: c_uint = 127 ; pub const NS_STYLE_IMAGELAYER_POSITION_CENTER : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_IMAGELAYER_POSITION_TOP : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_IMAGELAYER_POSITION_BOTTOM : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_IMAGELAYER_POSITION_LEFT : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_IMAGELAYER_POSITION_RIGHT : :: std :: os :: raw :: c_uint = 16 ; pub const NS_STYLE_IMAGELAYER_SIZE_CONTAIN : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_IMAGELAYER_SIZE_COVER : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_MASK_MODE_ALPHA : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_MASK_MODE_LUMINANCE : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_MASK_MODE_MATCH_SOURCE : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_BG_INLINE_POLICY_EACH_BOX : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_BG_INLINE_POLICY_CONTINUOUS : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_BG_INLINE_POLICY_BOUNDING_BOX : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_BORDER_COLLAPSE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_BORDER_SEPARATE : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_BORDER_WIDTH_THIN : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_BORDER_WIDTH_MEDIUM : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_BORDER_WIDTH_THICK : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_BORDER_STYLE_NONE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_BORDER_STYLE_GROOVE : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_BORDER_STYLE_RIDGE : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_BORDER_STYLE_DOTTED : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_BORDER_STYLE_DASHED : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_BORDER_STYLE_SOLID : :: std :: os :: raw :: c_uint = 5 ; pub const NS_STYLE_BORDER_STYLE_DOUBLE : :: std :: os :: raw :: c_uint = 6 ; pub const NS_STYLE_BORDER_STYLE_INSET : :: std :: os :: raw :: c_uint = 7 ; pub const NS_STYLE_BORDER_STYLE_OUTSET : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_BORDER_STYLE_HIDDEN : :: std :: os :: raw :: c_uint = 9 ; pub const NS_STYLE_BORDER_STYLE_AUTO : :: std :: os :: raw :: c_uint = 10 ; pub const NS_STYLE_BORDER_IMAGE_SLICE_NOFILL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_BORDER_IMAGE_SLICE_FILL : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_CURSOR_AUTO : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_CURSOR_CROSSHAIR : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_CURSOR_DEFAULT : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_CURSOR_POINTER : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_CURSOR_MOVE : :: std :: os :: raw :: c_uint = 5 ; pub const NS_STYLE_CURSOR_E_RESIZE : :: std :: os :: raw :: c_uint = 6 ; pub const NS_STYLE_CURSOR_NE_RESIZE : :: std :: os :: raw :: c_uint = 7 ; pub const NS_STYLE_CURSOR_NW_RESIZE : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_CURSOR_N_RESIZE : :: std :: os :: raw :: c_uint = 9 ; pub const NS_STYLE_CURSOR_SE_RESIZE : :: std :: os :: raw :: c_uint = 10 ; pub const NS_STYLE_CURSOR_SW_RESIZE : :: std :: os :: raw :: c_uint = 11 ; pub const NS_STYLE_CURSOR_S_RESIZE : :: std :: os :: raw :: c_uint = 12 ; pub const NS_STYLE_CURSOR_W_RESIZE : :: std :: os :: raw :: c_uint = 13 ; pub const NS_STYLE_CURSOR_TEXT : :: std :: os :: raw :: c_uint = 14 ; pub const NS_STYLE_CURSOR_WAIT : :: std :: os :: raw :: c_uint = 15 ; pub const NS_STYLE_CURSOR_HELP : :: std :: os :: raw :: c_uint = 16 ; pub const NS_STYLE_CURSOR_COPY : :: std :: os :: raw :: c_uint = 17 ; pub const NS_STYLE_CURSOR_ALIAS : :: std :: os :: raw :: c_uint = 18 ; pub const NS_STYLE_CURSOR_CONTEXT_MENU : :: std :: os :: raw :: c_uint = 19 ; pub const NS_STYLE_CURSOR_CELL : :: std :: os :: raw :: c_uint = 20 ; pub const NS_STYLE_CURSOR_GRAB : :: std :: os :: raw :: c_uint = 21 ; pub const NS_STYLE_CURSOR_GRABBING : :: std :: os :: raw :: c_uint = 22 ; pub const NS_STYLE_CURSOR_SPINNING : :: std :: os :: raw :: c_uint = 23 ; pub const NS_STYLE_CURSOR_ZOOM_IN : :: std :: os :: raw :: c_uint = 24 ; pub const NS_STYLE_CURSOR_ZOOM_OUT : :: std :: os :: raw :: c_uint = 25 ; pub const NS_STYLE_CURSOR_NOT_ALLOWED : :: std :: os :: raw :: c_uint = 26 ; pub const NS_STYLE_CURSOR_COL_RESIZE : :: std :: os :: raw :: c_uint = 27 ; pub const NS_STYLE_CURSOR_ROW_RESIZE : :: std :: os :: raw :: c_uint = 28 ; pub const NS_STYLE_CURSOR_NO_DROP : :: std :: os :: raw :: c_uint = 29 ; pub const NS_STYLE_CURSOR_VERTICAL_TEXT : :: std :: os :: raw :: c_uint = 30 ; pub const NS_STYLE_CURSOR_ALL_SCROLL : :: std :: os :: raw :: c_uint = 31 ; pub const NS_STYLE_CURSOR_NESW_RESIZE : :: std :: os :: raw :: c_uint = 32 ; pub const NS_STYLE_CURSOR_NWSE_RESIZE : :: std :: os :: raw :: c_uint = 33 ; pub const NS_STYLE_CURSOR_NS_RESIZE : :: std :: os :: raw :: c_uint = 34 ; pub const NS_STYLE_CURSOR_EW_RESIZE : :: std :: os :: raw :: c_uint = 35 ; pub const NS_STYLE_CURSOR_NONE : :: std :: os :: raw :: c_uint = 36 ; pub const NS_STYLE_DIRECTION_LTR : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_DIRECTION_RTL : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_WRITING_MODE_HORIZONTAL_TB : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_WRITING_MODE_VERTICAL_RL : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_WRITING_MODE_VERTICAL_LR : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_WRITING_MODE_SIDEWAYS_MASK : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_WRITING_MODE_SIDEWAYS_RL : :: std :: os :: raw :: c_uint = 5 ; pub const NS_STYLE_WRITING_MODE_SIDEWAYS_LR : :: std :: os :: raw :: c_uint = 7 ; pub const NS_STYLE_CONTAIN_NONE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_CONTAIN_STRICT : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_CONTAIN_LAYOUT : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_CONTAIN_STYLE : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_CONTAIN_PAINT : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_CONTAIN_ALL_BITS : :: std :: os :: raw :: c_uint = 14 ; pub const NS_STYLE_ALIGN_AUTO : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_ALIGN_NORMAL : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_ALIGN_START : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_ALIGN_END : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_ALIGN_FLEX_START : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_ALIGN_FLEX_END : :: std :: os :: raw :: c_uint = 5 ; pub const NS_STYLE_ALIGN_CENTER : :: std :: os :: raw :: c_uint = 6 ; pub const NS_STYLE_ALIGN_LEFT : :: std :: os :: raw :: c_uint = 7 ; pub const NS_STYLE_ALIGN_RIGHT : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_ALIGN_BASELINE : :: std :: os :: raw :: c_uint = 9 ; pub const NS_STYLE_ALIGN_LAST_BASELINE : :: std :: os :: raw :: c_uint = 10 ; pub const NS_STYLE_ALIGN_STRETCH : :: std :: os :: raw :: c_uint = 11 ; pub const NS_STYLE_ALIGN_SELF_START : :: std :: os :: raw :: c_uint = 12 ; pub const NS_STYLE_ALIGN_SELF_END : :: std :: os :: raw :: c_uint = 13 ; pub const NS_STYLE_ALIGN_SPACE_BETWEEN : :: std :: os :: raw :: c_uint = 14 ; pub const NS_STYLE_ALIGN_SPACE_AROUND : :: std :: os :: raw :: c_uint = 15 ; pub const NS_STYLE_ALIGN_SPACE_EVENLY : :: std :: os :: raw :: c_uint = 16 ; pub const NS_STYLE_ALIGN_LEGACY : :: std :: os :: raw :: c_uint = 32 ; pub const NS_STYLE_ALIGN_SAFE : :: std :: os :: raw :: c_uint = 64 ; pub const NS_STYLE_ALIGN_UNSAFE : :: std :: os :: raw :: c_uint = 128 ; pub const NS_STYLE_ALIGN_FLAG_BITS : :: std :: os :: raw :: c_uint = 224 ; pub const NS_STYLE_ALIGN_ALL_BITS : :: std :: os :: raw :: c_uint = 255 ; pub const NS_STYLE_ALIGN_ALL_SHIFT : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_JUSTIFY_AUTO : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_JUSTIFY_NORMAL : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_JUSTIFY_START : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_JUSTIFY_END : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_JUSTIFY_FLEX_START : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_JUSTIFY_FLEX_END : :: std :: os :: raw :: c_uint = 5 ; pub const NS_STYLE_JUSTIFY_CENTER : :: std :: os :: raw :: c_uint = 6 ; pub const NS_STYLE_JUSTIFY_LEFT : :: std :: os :: raw :: c_uint = 7 ; pub const NS_STYLE_JUSTIFY_RIGHT : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_JUSTIFY_BASELINE : :: std :: os :: raw :: c_uint = 9 ; pub const NS_STYLE_JUSTIFY_LAST_BASELINE : :: std :: os :: raw :: c_uint = 10 ; pub const NS_STYLE_JUSTIFY_STRETCH : :: std :: os :: raw :: c_uint = 11 ; pub const NS_STYLE_JUSTIFY_SELF_START : :: std :: os :: raw :: c_uint = 12 ; pub const NS_STYLE_JUSTIFY_SELF_END : :: std :: os :: raw :: c_uint = 13 ; pub const NS_STYLE_JUSTIFY_SPACE_BETWEEN : :: std :: os :: raw :: c_uint = 14 ; pub const NS_STYLE_JUSTIFY_SPACE_AROUND : :: std :: os :: raw :: c_uint = 15 ; pub const NS_STYLE_JUSTIFY_SPACE_EVENLY : :: std :: os :: raw :: c_uint = 16 ; pub const NS_STYLE_JUSTIFY_LEGACY : :: std :: os :: raw :: c_uint = 32 ; pub const NS_STYLE_JUSTIFY_SAFE : :: std :: os :: raw :: c_uint = 64 ; pub const NS_STYLE_JUSTIFY_UNSAFE : :: std :: os :: raw :: c_uint = 128 ; pub const NS_STYLE_JUSTIFY_FLAG_BITS : :: std :: os :: raw :: c_uint = 224 ; pub const NS_STYLE_JUSTIFY_ALL_BITS : :: std :: os :: raw :: c_uint = 255 ; pub const NS_STYLE_JUSTIFY_ALL_SHIFT : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_FLEX_DIRECTION_ROW : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_FLEX_DIRECTION_ROW_REVERSE : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_FLEX_DIRECTION_COLUMN : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_FLEX_DIRECTION_COLUMN_REVERSE : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_FLEX_WRAP_NOWRAP : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_FLEX_WRAP_WRAP : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_FLEX_WRAP_WRAP_REVERSE : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_ORDER_INITIAL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_JUSTIFY_CONTENT_FLEX_START : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_JUSTIFY_CONTENT_FLEX_END : :: std :: os :: raw :: c_uint = 5 ; pub const NS_STYLE_JUSTIFY_CONTENT_CENTER : :: std :: os :: raw :: c_uint = 6 ; pub const NS_STYLE_JUSTIFY_CONTENT_SPACE_BETWEEN : :: std :: os :: raw :: c_uint = 14 ; pub const NS_STYLE_JUSTIFY_CONTENT_SPACE_AROUND : :: std :: os :: raw :: c_uint = 15 ; pub const NS_STYLE_FILTER_NONE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_FILTER_URL : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_FILTER_BLUR : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_FILTER_BRIGHTNESS : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_FILTER_CONTRAST : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_FILTER_GRAYSCALE : :: std :: os :: raw :: c_uint = 5 ; pub const NS_STYLE_FILTER_INVERT : :: std :: os :: raw :: c_uint = 6 ; pub const NS_STYLE_FILTER_OPACITY : :: std :: os :: raw :: c_uint = 7 ; pub const NS_STYLE_FILTER_SATURATE : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_FILTER_SEPIA : :: std :: os :: raw :: c_uint = 9 ; pub const NS_STYLE_FILTER_HUE_ROTATE : :: std :: os :: raw :: c_uint = 10 ; pub const NS_STYLE_FILTER_DROP_SHADOW : :: std :: os :: raw :: c_uint = 11 ; pub const NS_STYLE_FONT_STYLE_NORMAL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_FONT_STYLE_ITALIC : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_FONT_STYLE_OBLIQUE : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_FONT_WEIGHT_NORMAL : :: std :: os :: raw :: c_uint = 400 ; pub const NS_STYLE_FONT_WEIGHT_BOLD : :: std :: os :: raw :: c_uint = 700 ; pub const NS_STYLE_FONT_WEIGHT_BOLDER : :: std :: os :: raw :: c_int = -1 ; pub const NS_STYLE_FONT_WEIGHT_LIGHTER : :: std :: os :: raw :: c_int = -2 ; pub const NS_STYLE_FONT_SIZE_XXSMALL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_FONT_SIZE_XSMALL : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_FONT_SIZE_SMALL : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_FONT_SIZE_MEDIUM : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_FONT_SIZE_LARGE : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_FONT_SIZE_XLARGE : :: std :: os :: raw :: c_uint = 5 ; pub const NS_STYLE_FONT_SIZE_XXLARGE : :: std :: os :: raw :: c_uint = 6 ; pub const NS_STYLE_FONT_SIZE_XXXLARGE : :: std :: os :: raw :: c_uint = 7 ; pub const NS_STYLE_FONT_SIZE_LARGER : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_FONT_SIZE_SMALLER : :: std :: os :: raw :: c_uint = 9 ; pub const NS_STYLE_FONT_SIZE_NO_KEYWORD : :: std :: os :: raw :: c_uint = 10 ; pub const NS_STYLE_FONT_STRETCH_ULTRA_CONDENSED : :: std :: os :: raw :: c_int = -4 ; pub const NS_STYLE_FONT_STRETCH_EXTRA_CONDENSED : :: std :: os :: raw :: c_int = -3 ; pub const NS_STYLE_FONT_STRETCH_CONDENSED : :: std :: os :: raw :: c_int = -2 ; pub const NS_STYLE_FONT_STRETCH_SEMI_CONDENSED : :: std :: os :: raw :: c_int = -1 ; pub const NS_STYLE_FONT_STRETCH_NORMAL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_FONT_STRETCH_SEMI_EXPANDED : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_FONT_STRETCH_EXPANDED : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_FONT_STRETCH_EXTRA_EXPANDED : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_FONT_STRETCH_ULTRA_EXPANDED : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_FONT_CAPTION : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_FONT_ICON : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_FONT_MENU : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_FONT_MESSAGE_BOX : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_FONT_SMALL_CAPTION : :: std :: os :: raw :: c_uint = 5 ; pub const NS_STYLE_FONT_STATUS_BAR : :: std :: os :: raw :: c_uint = 6 ; pub const NS_STYLE_FONT_WINDOW : :: std :: os :: raw :: c_uint = 7 ; pub const NS_STYLE_FONT_DOCUMENT : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_FONT_WORKSPACE : :: std :: os :: raw :: c_uint = 9 ; pub const NS_STYLE_FONT_DESKTOP : :: std :: os :: raw :: c_uint = 10 ; pub const NS_STYLE_FONT_INFO : :: std :: os :: raw :: c_uint = 11 ; pub const NS_STYLE_FONT_DIALOG : :: std :: os :: raw :: c_uint = 12 ; pub const NS_STYLE_FONT_BUTTON : :: std :: os :: raw :: c_uint = 13 ; pub const NS_STYLE_FONT_PULL_DOWN_MENU : :: std :: os :: raw :: c_uint = 14 ; pub const NS_STYLE_FONT_LIST : :: std :: os :: raw :: c_uint = 15 ; pub const NS_STYLE_FONT_FIELD : :: std :: os :: raw :: c_uint = 16 ; pub const NS_STYLE_GRID_AUTO_FLOW_ROW : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_GRID_AUTO_FLOW_COLUMN : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_GRID_AUTO_FLOW_DENSE : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_GRID_TEMPLATE_SUBGRID : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_GRID_REPEAT_AUTO_FILL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_GRID_REPEAT_AUTO_FIT : :: std :: os :: raw :: c_uint = 1 ; pub const NS_MATHML_DEFAULT_SCRIPT_SIZE_MULTIPLIER : f64 = 0.71 ; pub const NS_MATHML_DEFAULT_SCRIPT_MIN_SIZE_PT : :: std :: os :: raw :: c_uint = 8 ; pub const NS_MATHML_MATHVARIANT_NONE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_MATHML_MATHVARIANT_NORMAL : :: std :: os :: raw :: c_uint = 1 ; pub const NS_MATHML_MATHVARIANT_BOLD : :: std :: os :: raw :: c_uint = 2 ; pub const NS_MATHML_MATHVARIANT_ITALIC : :: std :: os :: raw :: c_uint = 3 ; pub const NS_MATHML_MATHVARIANT_BOLD_ITALIC : :: std :: os :: raw :: c_uint = 4 ; pub const NS_MATHML_MATHVARIANT_SCRIPT : :: std :: os :: raw :: c_uint = 5 ; pub const NS_MATHML_MATHVARIANT_BOLD_SCRIPT : :: std :: os :: raw :: c_uint = 6 ; pub const NS_MATHML_MATHVARIANT_FRAKTUR : :: std :: os :: raw :: c_uint = 7 ; pub const NS_MATHML_MATHVARIANT_DOUBLE_STRUCK : :: std :: os :: raw :: c_uint = 8 ; pub const NS_MATHML_MATHVARIANT_BOLD_FRAKTUR : :: std :: os :: raw :: c_uint = 9 ; pub const NS_MATHML_MATHVARIANT_SANS_SERIF : :: std :: os :: raw :: c_uint = 10 ; pub const NS_MATHML_MATHVARIANT_BOLD_SANS_SERIF : :: std :: os :: raw :: c_uint = 11 ; pub const NS_MATHML_MATHVARIANT_SANS_SERIF_ITALIC : :: std :: os :: raw :: c_uint = 12 ; pub const NS_MATHML_MATHVARIANT_SANS_SERIF_BOLD_ITALIC : :: std :: os :: raw :: c_uint = 13 ; pub const NS_MATHML_MATHVARIANT_MONOSPACE : :: std :: os :: raw :: c_uint = 14 ; pub const NS_MATHML_MATHVARIANT_INITIAL : :: std :: os :: raw :: c_uint = 15 ; pub const NS_MATHML_MATHVARIANT_TAILED : :: std :: os :: raw :: c_uint = 16 ; pub const NS_MATHML_MATHVARIANT_LOOPED : :: std :: os :: raw :: c_uint = 17 ; pub const NS_MATHML_MATHVARIANT_STRETCHED : :: std :: os :: raw :: c_uint = 18 ; pub const NS_MATHML_DISPLAYSTYLE_INLINE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_MATHML_DISPLAYSTYLE_BLOCK : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_WIDTH_MAX_CONTENT : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_WIDTH_MIN_CONTENT : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_WIDTH_FIT_CONTENT : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_WIDTH_AVAILABLE : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_POSITION_STATIC : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_POSITION_RELATIVE : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_POSITION_ABSOLUTE : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_POSITION_FIXED : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_POSITION_STICKY : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_CLIP_AUTO : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_CLIP_RECT : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_CLIP_TYPE_MASK : :: std :: os :: raw :: c_uint = 15 ; pub const NS_STYLE_CLIP_LEFT_AUTO : :: std :: os :: raw :: c_uint = 16 ; pub const NS_STYLE_CLIP_TOP_AUTO : :: std :: os :: raw :: c_uint = 32 ; pub const NS_STYLE_CLIP_RIGHT_AUTO : :: std :: os :: raw :: c_uint = 64 ; pub const NS_STYLE_CLIP_BOTTOM_AUTO : :: std :: os :: raw :: c_uint = 128 ; pub const NS_STYLE_FRAME_YES : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_FRAME_NO : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_FRAME_0 : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_FRAME_1 : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_FRAME_ON : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_FRAME_OFF : :: std :: os :: raw :: c_uint = 5 ; pub const NS_STYLE_FRAME_AUTO : :: std :: os :: raw :: c_uint = 6 ; pub const NS_STYLE_FRAME_SCROLL : :: std :: os :: raw :: c_uint = 7 ; pub const NS_STYLE_FRAME_NOSCROLL : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_OVERFLOW_VISIBLE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_OVERFLOW_HIDDEN : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_OVERFLOW_SCROLL : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_OVERFLOW_AUTO : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_OVERFLOW_CLIP : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_OVERFLOW_SCROLLBARS_HORIZONTAL : :: std :: os :: raw :: c_uint = 5 ; pub const NS_STYLE_OVERFLOW_SCROLLBARS_VERTICAL : :: std :: os :: raw :: c_uint = 6 ; pub const NS_STYLE_OVERFLOW_CLIP_BOX_PADDING_BOX : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_OVERFLOW_CLIP_BOX_CONTENT_BOX : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_LIST_STYLE_CUSTOM : :: std :: os :: raw :: c_int = -1 ; pub const NS_STYLE_LIST_STYLE_NONE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_LIST_STYLE_DECIMAL : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_LIST_STYLE_DISC : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_LIST_STYLE_CIRCLE : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_LIST_STYLE_SQUARE : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_LIST_STYLE_DISCLOSURE_CLOSED : :: std :: os :: raw :: c_uint = 5 ; pub const NS_STYLE_LIST_STYLE_DISCLOSURE_OPEN : :: std :: os :: raw :: c_uint = 6 ; pub const NS_STYLE_LIST_STYLE_HEBREW : :: std :: os :: raw :: c_uint = 7 ; pub const NS_STYLE_LIST_STYLE_JAPANESE_INFORMAL : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_LIST_STYLE_JAPANESE_FORMAL : :: std :: os :: raw :: c_uint = 9 ; pub const NS_STYLE_LIST_STYLE_KOREAN_HANGUL_FORMAL : :: std :: os :: raw :: c_uint = 10 ; pub const NS_STYLE_LIST_STYLE_KOREAN_HANJA_INFORMAL : :: std :: os :: raw :: c_uint = 11 ; pub const NS_STYLE_LIST_STYLE_KOREAN_HANJA_FORMAL : :: std :: os :: raw :: c_uint = 12 ; pub const NS_STYLE_LIST_STYLE_SIMP_CHINESE_INFORMAL : :: std :: os :: raw :: c_uint = 13 ; pub const NS_STYLE_LIST_STYLE_SIMP_CHINESE_FORMAL : :: std :: os :: raw :: c_uint = 14 ; pub const NS_STYLE_LIST_STYLE_TRAD_CHINESE_INFORMAL : :: std :: os :: raw :: c_uint = 15 ; pub const NS_STYLE_LIST_STYLE_TRAD_CHINESE_FORMAL : :: std :: os :: raw :: c_uint = 16 ; pub const NS_STYLE_LIST_STYLE_ETHIOPIC_NUMERIC : :: std :: os :: raw :: c_uint = 17 ; pub const NS_STYLE_LIST_STYLE_LOWER_ROMAN : :: std :: os :: raw :: c_uint = 100 ; pub const NS_STYLE_LIST_STYLE_UPPER_ROMAN : :: std :: os :: raw :: c_uint = 101 ; pub const NS_STYLE_LIST_STYLE_LOWER_ALPHA : :: std :: os :: raw :: c_uint = 102 ; pub const NS_STYLE_LIST_STYLE_UPPER_ALPHA : :: std :: os :: raw :: c_uint = 103 ; pub const NS_STYLE_LIST_STYLE_POSITION_INSIDE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_LIST_STYLE_POSITION_OUTSIDE : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_MARGIN_SIZE_AUTO : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_POINTER_EVENTS_NONE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_POINTER_EVENTS_VISIBLEPAINTED : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_POINTER_EVENTS_VISIBLEFILL : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_POINTER_EVENTS_VISIBLESTROKE : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_POINTER_EVENTS_VISIBLE : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_POINTER_EVENTS_PAINTED : :: std :: os :: raw :: c_uint = 5 ; pub const NS_STYLE_POINTER_EVENTS_FILL : :: std :: os :: raw :: c_uint = 6 ; pub const NS_STYLE_POINTER_EVENTS_STROKE : :: std :: os :: raw :: c_uint = 7 ; pub const NS_STYLE_POINTER_EVENTS_ALL : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_POINTER_EVENTS_AUTO : :: std :: os :: raw :: c_uint = 9 ; pub const NS_STYLE_IMAGE_ORIENTATION_FLIP : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_IMAGE_ORIENTATION_FROM_IMAGE : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_ISOLATION_AUTO : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_ISOLATION_ISOLATE : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_OBJECT_FIT_FILL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_OBJECT_FIT_CONTAIN : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_OBJECT_FIT_COVER : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_OBJECT_FIT_NONE : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_OBJECT_FIT_SCALE_DOWN : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_RESIZE_NONE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_RESIZE_BOTH : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_RESIZE_HORIZONTAL : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_RESIZE_VERTICAL : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_TEXT_ALIGN_START : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_TEXT_ALIGN_LEFT : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_TEXT_ALIGN_RIGHT : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_TEXT_ALIGN_CENTER : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_TEXT_ALIGN_JUSTIFY : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_TEXT_ALIGN_CHAR : :: std :: os :: raw :: c_uint = 5 ; pub const NS_STYLE_TEXT_ALIGN_END : :: std :: os :: raw :: c_uint = 6 ; pub const NS_STYLE_TEXT_ALIGN_AUTO : :: std :: os :: raw :: c_uint = 7 ; pub const NS_STYLE_TEXT_ALIGN_MOZ_CENTER : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_TEXT_ALIGN_MOZ_RIGHT : :: std :: os :: raw :: c_uint = 9 ; pub const NS_STYLE_TEXT_ALIGN_MOZ_LEFT : :: std :: os :: raw :: c_uint = 10 ; pub const NS_STYLE_TEXT_ALIGN_MOZ_CENTER_OR_INHERIT : :: std :: os :: raw :: c_uint = 11 ; pub const NS_STYLE_TEXT_ALIGN_UNSAFE : :: std :: os :: raw :: c_uint = 12 ; pub const NS_STYLE_TEXT_ALIGN_MATCH_PARENT : :: std :: os :: raw :: c_uint = 13 ; pub const NS_STYLE_TEXT_DECORATION_LINE_NONE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_TEXT_DECORATION_LINE_OVERLINE : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_TEXT_DECORATION_LINE_BLINK : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_TEXT_DECORATION_LINE_OVERRIDE_ALL : :: std :: os :: raw :: c_uint = 16 ; pub const NS_STYLE_TEXT_DECORATION_LINE_LINES_MASK : :: std :: os :: raw :: c_uint = 7 ; pub const NS_STYLE_TEXT_DECORATION_STYLE_NONE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_TEXT_DECORATION_STYLE_DOTTED : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_TEXT_DECORATION_STYLE_DASHED : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_TEXT_DECORATION_STYLE_SOLID : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_TEXT_DECORATION_STYLE_DOUBLE : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_TEXT_DECORATION_STYLE_WAVY : :: std :: os :: raw :: c_uint = 5 ; pub const NS_STYLE_TEXT_DECORATION_STYLE_MAX : :: std :: os :: raw :: c_uint = 5 ; pub const NS_STYLE_TEXT_OVERFLOW_CLIP : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_TEXT_OVERFLOW_ELLIPSIS : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_TEXT_OVERFLOW_STRING : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_TEXT_TRANSFORM_NONE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_TEXT_TRANSFORM_CAPITALIZE : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_TEXT_TRANSFORM_LOWERCASE : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_TEXT_TRANSFORM_UPPERCASE : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_TEXT_TRANSFORM_FULL_WIDTH : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_TOUCH_ACTION_NONE : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_TOUCH_ACTION_AUTO : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_TOUCH_ACTION_PAN_X : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_TOUCH_ACTION_PAN_Y : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_TOUCH_ACTION_MANIPULATION : :: std :: os :: raw :: c_uint = 16 ; pub const NS_STYLE_TOP_LAYER_NONE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_TOP_LAYER_TOP : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_LINEAR : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_OUT : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN_OUT : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_STEP_START : :: std :: os :: raw :: c_uint = 5 ; pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_STEP_END : :: std :: os :: raw :: c_uint = 6 ; pub const NS_STYLE_VERTICAL_ALIGN_BASELINE : :: std :: os :: raw :: c_uint = 14 ; pub const NS_STYLE_VERTICAL_ALIGN_SUB : :: std :: os :: raw :: c_uint = 15 ; pub const NS_STYLE_VERTICAL_ALIGN_SUPER : :: std :: os :: raw :: c_uint = 16 ; pub const NS_STYLE_VERTICAL_ALIGN_TOP : :: std :: os :: raw :: c_uint = 17 ; pub const NS_STYLE_VERTICAL_ALIGN_TEXT_TOP : :: std :: os :: raw :: c_uint = 18 ; pub const NS_STYLE_VERTICAL_ALIGN_MIDDLE : :: std :: os :: raw :: c_uint = 19 ; pub const NS_STYLE_VERTICAL_ALIGN_TEXT_BOTTOM : :: std :: os :: raw :: c_uint = 20 ; pub const NS_STYLE_VERTICAL_ALIGN_BOTTOM : :: std :: os :: raw :: c_uint = 21 ; pub const NS_STYLE_VERTICAL_ALIGN_MIDDLE_WITH_BASELINE : :: std :: os :: raw :: c_uint = 22 ; pub const NS_STYLE_VISIBILITY_HIDDEN : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_VISIBILITY_VISIBLE : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_VISIBILITY_COLLAPSE : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_TABSIZE_INITIAL : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_WORDBREAK_NORMAL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_WORDBREAK_BREAK_ALL : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_WORDBREAK_KEEP_ALL : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_OVERFLOWWRAP_NORMAL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_OVERFLOWWRAP_BREAK_WORD : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_RUBY_ALIGN_START : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_RUBY_ALIGN_CENTER : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_RUBY_ALIGN_SPACE_BETWEEN : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_RUBY_ALIGN_SPACE_AROUND : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_RUBY_POSITION_OVER : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_RUBY_POSITION_UNDER : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_RUBY_POSITION_INTER_CHARACTER : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_TEXT_SIZE_ADJUST_NONE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_TEXT_SIZE_ADJUST_AUTO : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_TEXT_ORIENTATION_MIXED : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_TEXT_ORIENTATION_UPRIGHT : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_TEXT_ORIENTATION_SIDEWAYS : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_NONE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_ALL : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_DIGITS_2 : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_DIGITS_3 : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_DIGITS_4 : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_LINE_HEIGHT_BLOCK_HEIGHT : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_UNICODE_BIDI_NORMAL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_UNICODE_BIDI_EMBED : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_UNICODE_BIDI_ISOLATE : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_UNICODE_BIDI_BIDI_OVERRIDE : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_UNICODE_BIDI_ISOLATE_OVERRIDE : :: std :: os :: raw :: c_uint = 6 ; pub const NS_STYLE_UNICODE_BIDI_PLAINTEXT : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_TABLE_LAYOUT_AUTO : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_TABLE_LAYOUT_FIXED : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_TABLE_EMPTY_CELLS_HIDE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_TABLE_EMPTY_CELLS_SHOW : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_CAPTION_SIDE_TOP : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_CAPTION_SIDE_RIGHT : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_CAPTION_SIDE_BOTTOM : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_CAPTION_SIDE_LEFT : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE : :: std :: os :: raw :: c_uint = 5 ; pub const NS_STYLE_CELL_SCOPE_ROW : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_CELL_SCOPE_COL : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_CELL_SCOPE_ROWGROUP : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_CELL_SCOPE_COLGROUP : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_PAGE_MARKS_NONE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_PAGE_MARKS_CROP : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_PAGE_MARKS_REGISTER : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_PAGE_SIZE_AUTO : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_PAGE_SIZE_PORTRAIT : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_PAGE_SIZE_LANDSCAPE : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_PAGE_BREAK_AUTO : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_PAGE_BREAK_ALWAYS : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_PAGE_BREAK_AVOID : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_PAGE_BREAK_LEFT : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_PAGE_BREAK_RIGHT : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_COLUMN_COUNT_AUTO : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_COLUMN_COUNT_UNLIMITED : :: std :: os :: raw :: c_int = -1 ; pub const NS_STYLE_COLUMN_FILL_AUTO : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_COLUMN_FILL_BALANCE : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_COLUMN_SPAN_NONE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_COLUMN_SPAN_ALL : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_IME_MODE_AUTO : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_IME_MODE_NORMAL : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_IME_MODE_ACTIVE : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_IME_MODE_DISABLED : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_IME_MODE_INACTIVE : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_GRADIENT_SHAPE_LINEAR : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_GRADIENT_SHAPE_ELLIPTICAL : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_GRADIENT_SHAPE_CIRCULAR : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_GRADIENT_SIZE_CLOSEST_SIDE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_GRADIENT_SIZE_CLOSEST_CORNER : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_GRADIENT_SIZE_FARTHEST_SIDE : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_GRADIENT_SIZE_FARTHEST_CORNER : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_GRADIENT_SIZE_EXPLICIT_SIZE : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_CONTEXT_PROPERTY_FILL : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_CONTEXT_PROPERTY_STROKE : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_CONTEXT_PROPERTY_FILL_OPACITY : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_CONTEXT_PROPERTY_STROKE_OPACITY : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_WINDOW_SHADOW_NONE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_WINDOW_SHADOW_DEFAULT : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_WINDOW_SHADOW_MENU : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_WINDOW_SHADOW_TOOLTIP : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_WINDOW_SHADOW_SHEET : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_DOMINANT_BASELINE_AUTO : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_DOMINANT_BASELINE_USE_SCRIPT : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_DOMINANT_BASELINE_NO_CHANGE : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_DOMINANT_BASELINE_RESET_SIZE : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_DOMINANT_BASELINE_IDEOGRAPHIC : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_DOMINANT_BASELINE_ALPHABETIC : :: std :: os :: raw :: c_uint = 5 ; pub const NS_STYLE_DOMINANT_BASELINE_HANGING : :: std :: os :: raw :: c_uint = 6 ; pub const NS_STYLE_DOMINANT_BASELINE_MATHEMATICAL : :: std :: os :: raw :: c_uint = 7 ; pub const NS_STYLE_DOMINANT_BASELINE_CENTRAL : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_DOMINANT_BASELINE_MIDDLE : :: std :: os :: raw :: c_uint = 9 ; pub const NS_STYLE_DOMINANT_BASELINE_TEXT_AFTER_EDGE : :: std :: os :: raw :: c_uint = 10 ; pub const NS_STYLE_DOMINANT_BASELINE_TEXT_BEFORE_EDGE : :: std :: os :: raw :: c_uint = 11 ; pub const NS_STYLE_IMAGE_RENDERING_AUTO : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_IMAGE_RENDERING_OPTIMIZESPEED : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_IMAGE_RENDERING_OPTIMIZEQUALITY : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_IMAGE_RENDERING_CRISPEDGES : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_MASK_TYPE_LUMINANCE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_MASK_TYPE_ALPHA : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_PAINT_ORDER_NORMAL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_PAINT_ORDER_FILL : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_PAINT_ORDER_STROKE : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_PAINT_ORDER_MARKERS : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_PAINT_ORDER_LAST_VALUE : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_PAINT_ORDER_BITWIDTH : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_SHAPE_RENDERING_AUTO : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_SHAPE_RENDERING_OPTIMIZESPEED : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_SHAPE_RENDERING_CRISPEDGES : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_SHAPE_RENDERING_GEOMETRICPRECISION : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_STROKE_LINECAP_BUTT : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_STROKE_LINECAP_ROUND : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_STROKE_LINECAP_SQUARE : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_STROKE_LINEJOIN_MITER : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_STROKE_LINEJOIN_ROUND : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_STROKE_LINEJOIN_BEVEL : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_STROKE_PROP_CONTEXT_VALUE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_TEXT_ANCHOR_START : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_TEXT_ANCHOR_MIDDLE : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_TEXT_ANCHOR_END : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_TEXT_EMPHASIS_POSITION_OVER : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_TEXT_EMPHASIS_POSITION_UNDER : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_TEXT_EMPHASIS_POSITION_LEFT : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_TEXT_EMPHASIS_POSITION_RIGHT : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_TEXT_EMPHASIS_POSITION_DEFAULT : :: std :: os :: raw :: c_uint = 9 ; pub const NS_STYLE_TEXT_EMPHASIS_POSITION_DEFAULT_ZH : :: std :: os :: raw :: c_uint = 10 ; pub const NS_STYLE_TEXT_EMPHASIS_STYLE_NONE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_TEXT_EMPHASIS_STYLE_FILL_MASK : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_TEXT_EMPHASIS_STYLE_FILLED : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_TEXT_EMPHASIS_STYLE_OPEN : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_TEXT_EMPHASIS_STYLE_SHAPE_MASK : :: std :: os :: raw :: c_uint = 7 ; pub const NS_STYLE_TEXT_EMPHASIS_STYLE_DOT : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_TEXT_EMPHASIS_STYLE_CIRCLE : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_TEXT_EMPHASIS_STYLE_DOUBLE_CIRCLE : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_TEXT_EMPHASIS_STYLE_TRIANGLE : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_TEXT_EMPHASIS_STYLE_SESAME : :: std :: os :: raw :: c_uint = 5 ; pub const NS_STYLE_TEXT_EMPHASIS_STYLE_STRING : :: std :: os :: raw :: c_uint = 255 ; pub const NS_STYLE_TEXT_RENDERING_AUTO : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_TEXT_RENDERING_OPTIMIZESPEED : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_TEXT_RENDERING_OPTIMIZELEGIBILITY : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_TEXT_RENDERING_GEOMETRICPRECISION : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_COLOR_ADJUST_ECONOMY : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_COLOR_ADJUST_EXACT : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_COLOR_INTERPOLATION_AUTO : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_COLOR_INTERPOLATION_SRGB : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_COLOR_INTERPOLATION_LINEARRGB : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_VECTOR_EFFECT_NONE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_VECTOR_EFFECT_NON_SCALING_STROKE : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_BACKFACE_VISIBILITY_VISIBLE : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_BACKFACE_VISIBILITY_HIDDEN : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_TRANSFORM_STYLE_FLAT : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_TRANSFORM_STYLE_PRESERVE_3D : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_CONTEXT_FILL_OPACITY : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_CONTEXT_STROKE_OPACITY : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_BLEND_NORMAL : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_BLEND_MULTIPLY : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_BLEND_SCREEN : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_BLEND_OVERLAY : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_BLEND_DARKEN : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_BLEND_LIGHTEN : :: std :: os :: raw :: c_uint = 5 ; pub const NS_STYLE_BLEND_COLOR_DODGE : :: std :: os :: raw :: c_uint = 6 ; pub const NS_STYLE_BLEND_COLOR_BURN : :: std :: os :: raw :: c_uint = 7 ; pub const NS_STYLE_BLEND_HARD_LIGHT : :: std :: os :: raw :: c_uint = 8 ; pub const NS_STYLE_BLEND_SOFT_LIGHT : :: std :: os :: raw :: c_uint = 9 ; pub const NS_STYLE_BLEND_DIFFERENCE : :: std :: os :: raw :: c_uint = 10 ; pub const NS_STYLE_BLEND_EXCLUSION : :: std :: os :: raw :: c_uint = 11 ; pub const NS_STYLE_BLEND_HUE : :: std :: os :: raw :: c_uint = 12 ; pub const NS_STYLE_BLEND_SATURATION : :: std :: os :: raw :: c_uint = 13 ; pub const NS_STYLE_BLEND_COLOR : :: std :: os :: raw :: c_uint = 14 ; pub const NS_STYLE_BLEND_LUMINOSITY : :: std :: os :: raw :: c_uint = 15 ; pub const NS_STYLE_MASK_COMPOSITE_ADD : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_MASK_COMPOSITE_SUBTRACT : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_MASK_COMPOSITE_INTERSECT : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_MASK_COMPOSITE_EXCLUDE : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_CONTROL_CHARACTER_VISIBILITY_HIDDEN : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_CONTROL_CHARACTER_VISIBILITY_VISIBLE : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_COUNTER_SYSTEM_CYCLIC : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_COUNTER_SYSTEM_NUMERIC : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_COUNTER_SYSTEM_ALPHABETIC : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_COUNTER_SYSTEM_SYMBOLIC : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_COUNTER_SYSTEM_ADDITIVE : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_COUNTER_SYSTEM_FIXED : :: std :: os :: raw :: c_uint = 5 ; pub const NS_STYLE_COUNTER_SYSTEM_EXTENDS : :: std :: os :: raw :: c_uint = 6 ; pub const NS_STYLE_COUNTER_RANGE_INFINITE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_COUNTER_SPEAKAS_BULLETS : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_COUNTER_SPEAKAS_NUMBERS : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_COUNTER_SPEAKAS_WORDS : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_COUNTER_SPEAKAS_SPELL_OUT : :: std :: os :: raw :: c_uint = 3 ; pub const NS_STYLE_COUNTER_SPEAKAS_OTHER : :: std :: os :: raw :: c_uint = 255 ; pub const NS_STYLE_SCROLL_BEHAVIOR_AUTO : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_SCROLL_BEHAVIOR_SMOOTH : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_SCROLL_SNAP_TYPE_NONE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_SCROLL_SNAP_TYPE_MANDATORY : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_SCROLL_SNAP_TYPE_PROXIMITY : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_ORIENTATION_PORTRAIT : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_ORIENTATION_LANDSCAPE : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_SCAN_PROGRESSIVE : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_SCAN_INTERLACE : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_DISPLAY_MODE_BROWSER : :: std :: os :: raw :: c_uint = 0 ; pub const NS_STYLE_DISPLAY_MODE_MINIMAL_UI : :: std :: os :: raw :: c_uint = 1 ; pub const NS_STYLE_DISPLAY_MODE_STANDALONE : :: std :: os :: raw :: c_uint = 2 ; pub const NS_STYLE_DISPLAY_MODE_FULLSCREEN : :: std :: os :: raw :: c_uint = 3 ; pub const CSS_PSEUDO_ELEMENT_IS_CSS2 : :: std :: os :: raw :: c_uint = 1 ; pub const CSS_PSEUDO_ELEMENT_CONTAINS_ELEMENTS : :: std :: os :: raw :: c_uint = 2 ; pub const CSS_PSEUDO_ELEMENT_SUPPORTS_STYLE_ATTRIBUTE : :: std :: os :: raw :: c_uint = 4 ; pub const CSS_PSEUDO_ELEMENT_SUPPORTS_USER_ACTION_STATE : :: std :: os :: raw :: c_uint = 8 ; pub const CSS_PSEUDO_ELEMENT_UA_SHEET_ONLY : :: std :: os :: raw :: c_uint = 16 ; pub const CSS_PSEUDO_ELEMENT_IS_JS_CREATED_NAC : :: std :: os :: raw :: c_uint = 32 ; pub const CSS_PSEUDO_ELEMENT_IS_FLEX_OR_GRID_ITEM : :: std :: os :: raw :: c_uint = 64 ; pub const kNameSpaceID_Unknown : :: std :: os :: raw :: c_int = -1 ; pub const kNameSpaceID_XMLNS : :: std :: os :: raw :: c_uint = 1 ; pub const kNameSpaceID_XML : :: std :: os :: raw :: c_uint = 2 ; pub const kNameSpaceID_XHTML : :: std :: os :: raw :: c_uint = 3 ; pub const kNameSpaceID_XLink : :: std :: os :: raw :: c_uint = 4 ; pub const kNameSpaceID_XSLT : :: std :: os :: raw :: c_uint = 5 ; pub const kNameSpaceID_XBL : :: std :: os :: raw :: c_uint = 6 ; pub const kNameSpaceID_MathML : :: std :: os :: raw :: c_uint = 7 ; pub const kNameSpaceID_RDF : :: std :: os :: raw :: c_uint = 8 ; pub const kNameSpaceID_XUL : :: std :: os :: raw :: c_uint = 9 ; pub const kNameSpaceID_SVG : :: std :: os :: raw :: c_uint = 10 ; pub const kNameSpaceID_disabled_MathML : :: std :: os :: raw :: c_uint = 11 ; pub const kNameSpaceID_disabled_SVG : :: std :: os :: raw :: c_uint = 12 ; pub const kNameSpaceID_LastBuiltin : :: std :: os :: raw :: c_uint = 12 ; pub const kNameSpaceID_Wildcard : :: std :: os :: raw :: c_int = -2147483648 ; pub const NS_AUTHOR_SPECIFIED_BACKGROUND : :: std :: os :: raw :: c_uint = 1 ; pub const NS_AUTHOR_SPECIFIED_BORDER : :: std :: os :: raw :: c_uint = 2 ; pub const NS_AUTHOR_SPECIFIED_PADDING : :: std :: os :: raw :: c_uint = 4 ; pub const NS_STYLE_INHERIT_MASK : :: std :: os :: raw :: c_uint = 16777215 ; pub const NS_STYLE_HAS_TEXT_DECORATION_LINES : :: std :: os :: raw :: c_uint = 16777216 ; pub const NS_STYLE_HAS_PSEUDO_ELEMENT_DATA : :: std :: os :: raw :: c_uint = 33554432 ; pub const NS_STYLE_RELEVANT_LINK_VISITED : :: std :: os :: raw :: c_uint = 67108864 ; pub const NS_STYLE_IS_STYLE_IF_VISITED : :: std :: os :: raw :: c_uint = 134217728 ; pub const NS_STYLE_CHILD_USES_GRANDANCESTOR_STYLE : :: std :: os :: raw :: c_uint = 268435456 ; pub const NS_STYLE_IS_SHARED : :: std :: os :: raw :: c_uint = 536870912 ; pub const NS_STYLE_IS_GOING_AWAY : :: std :: os :: raw :: c_uint = 1073741824 ; pub const NS_STYLE_SUPPRESS_LINEBREAK : :: std :: os :: raw :: c_uint = 2147483648 ; pub const NS_STYLE_IN_DISPLAY_NONE_SUBTREE : :: std :: os :: raw :: c_ulonglong = 4294967296 ; pub const NS_STYLE_INELIGIBLE_FOR_SHARING : :: std :: os :: raw :: c_ulonglong = 8589934592 ; pub const NS_STYLE_HAS_CHILD_THAT_USES_RESET_STYLE : :: std :: os :: raw :: c_ulonglong = 17179869184 ; pub const NS_STYLE_IS_TEXT_COMBINED : :: std :: os :: raw :: c_ulonglong = 34359738368 ; pub const NS_STYLE_CONTEXT_IS_GECKO : :: std :: os :: raw :: c_ulonglong = 68719476736 ; pub const NS_STYLE_CONTEXT_TYPE_SHIFT : :: std :: os :: raw :: c_uint = 37 ; pub mod std { # [ allow ( unused_imports ) ] use self :: super :: super :: root ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nothrow_t { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nothrow_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nothrow_t > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( nothrow_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nothrow_t > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( nothrow_t ) ) ) ; } impl Clone for nothrow_t { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct pair < _T1 , _T2 > { pub first : _T1 , pub second : _T2 , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _T1 > > , pub _phantom_1 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _T2 > > , } pub type pair_first_type < _T1 > = _T1 ; pub type pair_second_type < _T2 > = _T2 ; pub type pair__PCCP = u8 ; pub type pair__PCCFP = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct input_iterator_tag { pub _address : u8 , } # [ test ] fn bindgen_test_layout_input_iterator_tag ( ) { assert_eq ! ( :: std :: mem :: size_of :: < input_iterator_tag > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( input_iterator_tag ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < input_iterator_tag > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( input_iterator_tag ) ) ) ; } impl Clone for input_iterator_tag { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct iterator { pub _address : u8 , } pub type iterator_iterator_category < _Category > = _Category ; pub type iterator_value_type < _Tp > = _Tp ; pub type iterator_difference_type < _Distance > = _Distance ; pub type iterator_pointer < _Pointer > = _Pointer ; pub type iterator_reference < _Reference > = _Reference ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct atomic { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct function { pub _address : u8 , } pub type _Base_bitset__WordT = :: std :: os :: raw :: c_ulong ; pub type bitset__Base = u8 ; pub type bitset__WordT = :: std :: os :: raw :: c_ulong ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct bitset_reference { pub _M_wp : * mut root :: std :: bitset__WordT , pub _M_bpos : usize , } } pub mod __gnu_cxx { # [ allow ( unused_imports ) ] use self :: super :: super :: root ; } pub type __int8_t = :: std :: os :: raw :: c_schar ; pub type __uint8_t = :: std :: os :: raw :: c_uchar ; pub type __int16_t = :: std :: os :: raw :: c_short ; pub type __uint16_t = :: std :: os :: raw :: c_ushort ; pub type __int32_t = :: std :: os :: raw :: c_int ; pub type __uint32_t = :: std :: os :: raw :: c_uint ; pub type __int64_t = :: std :: os :: raw :: c_long ; pub type __uint64_t = :: std :: os :: raw :: c_ulong ; pub mod mozilla { # [ allow ( unused_imports ) ] use self :: super :: super :: root ; pub type fallible_t = root :: std :: nothrow_t ; pub type IntegralConstant_ValueType < T > = T ; pub type IntegralConstant_Type = u8 ; 
 /// Convenient aliases. 
 pub type TrueType = u8 ; pub type FalseType = u8 ; pub mod detail { # [ allow ( unused_imports ) ] use self :: super :: super :: super :: root ; pub const StringDataFlags_TERMINATED : root :: mozilla :: detail :: StringDataFlags = 1 ; pub const StringDataFlags_VOIDED : root :: mozilla :: detail :: StringDataFlags = 2 ; pub const StringDataFlags_SHARED : root :: mozilla :: detail :: StringDataFlags = 4 ; pub const StringDataFlags_OWNED : root :: mozilla :: detail :: StringDataFlags = 8 ; pub const StringDataFlags_INLINE : root :: mozilla :: detail :: StringDataFlags = 16 ; pub const StringDataFlags_LITERAL : root :: mozilla :: detail :: StringDataFlags = 32 ; pub type StringDataFlags = u16 ; pub const StringClassFlags_INLINE : root :: mozilla :: detail :: StringClassFlags = 1 ; pub const StringClassFlags_NULL_TERMINATED : root :: mozilla :: detail :: StringClassFlags = 2 ; pub type StringClassFlags = u16 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsTStringRepr < T > { pub mData : * mut root :: mozilla :: detail :: nsTStringRepr_char_type < T > , pub mLength : root :: mozilla :: detail :: nsTStringRepr_size_type , pub mDataFlags : root :: mozilla :: detail :: nsTStringRepr_DataFlags , pub mClassFlags : root :: mozilla :: detail :: nsTStringRepr_ClassFlags , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , } pub type nsTStringRepr_fallible_t = root :: mozilla :: fallible_t ; pub type nsTStringRepr_char_type < T > = T ; pub type nsTStringRepr_self_type < T > = root :: mozilla :: detail :: nsTStringRepr < T > ; pub type nsTStringRepr_base_string_type < T > = root :: mozilla :: detail :: nsTStringRepr_self_type < T > ; pub type nsTStringRepr_substring_type < T > = root :: nsTSubstring < T > ; pub type nsTStringRepr_substring_tuple_type < T > = root :: nsTSubstringTuple < T > ; pub type nsTStringRepr_literalstring_type < T > = root :: nsTLiteralString < T > ; pub type nsTStringRepr_const_iterator < T > = root :: nsReadingIterator < root :: mozilla :: detail :: nsTStringRepr_char_type < T > > ; pub type nsTStringRepr_iterator < T > = root :: nsWritingIterator < root :: mozilla :: detail :: nsTStringRepr_char_type < T > > ; pub type nsTStringRepr_comparator_type = root :: nsTStringComparator ; pub type nsTStringRepr_char_iterator < T > = * mut root :: mozilla :: detail :: nsTStringRepr_char_type < T > ; pub type nsTStringRepr_const_char_iterator < T > = * const root :: mozilla :: detail :: nsTStringRepr_char_type < T > ; pub type nsTStringRepr_index_type = u32 ; pub type nsTStringRepr_size_type = u32 ; pub use self :: super :: super :: super :: root :: mozilla :: detail :: StringDataFlags as nsTStringRepr_DataFlags ; pub use self :: super :: super :: super :: root :: mozilla :: detail :: StringClassFlags as nsTStringRepr_ClassFlags ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsTStringRepr_raw_type { pub _address : u8 , } pub type nsTStringRepr_raw_type_type < U > = * mut U ; 
 /// LinkedList supports refcounted elements using this adapter class. Clients
            /// using LinkedList<RefPtr<T>> will get a data structure that holds a strong
            /// reference to T as long as T is in the list. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct LinkedListElementTraits { pub _address : u8 , } pub type LinkedListElementTraits_RawType < T > = * mut T ; pub type LinkedListElementTraits_ConstRawType < T > = * mut T ; pub type LinkedListElementTraits_ClientType < T > = * mut T ; pub type LinkedListElementTraits_ConstClientType < T > = * mut T ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct WeakReference { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct FreePolicy { pub _address : u8 , } } pub type Conditional_Type < A > = A ; pub const ArenaObjectID_eArenaObjectID_DummyBeforeFirstObjectID : root :: mozilla :: ArenaObjectID = 171 ; pub const ArenaObjectID_eArenaObjectID_GeckoStyleContext : root :: mozilla :: ArenaObjectID = 172 ; pub const ArenaObjectID_eArenaObjectID_nsLineBox : root :: mozilla :: ArenaObjectID = 173 ; pub const ArenaObjectID_eArenaObjectID_nsRuleNode : root :: mozilla :: ArenaObjectID = 174 ; pub const ArenaObjectID_eArenaObjectID_DisplayItemData : root :: mozilla :: ArenaObjectID = 175 ; pub const ArenaObjectID_eArenaObjectID_nsInheritedStyleData : root :: mozilla :: ArenaObjectID = 176 ; pub const ArenaObjectID_eArenaObjectID_nsResetStyleData : root :: mozilla :: ArenaObjectID = 177 ; pub const ArenaObjectID_eArenaObjectID_nsConditionalResetStyleData : root :: mozilla :: ArenaObjectID = 178 ; pub const ArenaObjectID_eArenaObjectID_nsConditionalResetStyleDataEntry : root :: mozilla :: ArenaObjectID = 179 ; pub const ArenaObjectID_eArenaObjectID_nsFrameList : root :: mozilla :: ArenaObjectID = 180 ; pub const ArenaObjectID_eArenaObjectID_CustomCounterStyle : root :: mozilla :: ArenaObjectID = 181 ; pub const ArenaObjectID_eArenaObjectID_DependentBuiltinCounterStyle : root :: mozilla :: ArenaObjectID = 182 ; pub const ArenaObjectID_eArenaObjectID_nsCallbackEventRequest : root :: mozilla :: ArenaObjectID = 183 ; pub const ArenaObjectID_eArenaObjectID_nsIntervalSet_Interval : root :: mozilla :: ArenaObjectID = 184 ; pub const ArenaObjectID_eArenaObjectID_CellData : root :: mozilla :: ArenaObjectID = 185 ; pub const ArenaObjectID_eArenaObjectID_BCCellData : root :: mozilla :: ArenaObjectID = 186 ; pub const ArenaObjectID_eArenaObjectID_nsStyleFont : root :: mozilla :: ArenaObjectID = 187 ; pub const ArenaObjectID_eArenaObjectID_nsStyleColor : root :: mozilla :: ArenaObjectID = 188 ; pub const ArenaObjectID_eArenaObjectID_nsStyleList : root :: mozilla :: ArenaObjectID = 189 ; pub const ArenaObjectID_eArenaObjectID_nsStyleText : root :: mozilla :: ArenaObjectID = 190 ; pub const ArenaObjectID_eArenaObjectID_nsStyleVisibility : root :: mozilla :: ArenaObjectID = 191 ; pub const ArenaObjectID_eArenaObjectID_nsStyleUserInterface : root :: mozilla :: ArenaObjectID = 192 ; pub const ArenaObjectID_eArenaObjectID_nsStyleTableBorder : root :: mozilla :: ArenaObjectID = 193 ; pub const ArenaObjectID_eArenaObjectID_nsStyleSVG : root :: mozilla :: ArenaObjectID = 194 ; pub const ArenaObjectID_eArenaObjectID_nsStyleVariables : root :: mozilla :: ArenaObjectID = 195 ; pub const ArenaObjectID_eArenaObjectID_nsStyleBackground : root :: mozilla :: ArenaObjectID = 196 ; pub const ArenaObjectID_eArenaObjectID_nsStylePosition : root :: mozilla :: ArenaObjectID = 197 ; pub const ArenaObjectID_eArenaObjectID_nsStyleTextReset : root :: mozilla :: ArenaObjectID = 198 ; pub const ArenaObjectID_eArenaObjectID_nsStyleDisplay : root :: mozilla :: ArenaObjectID = 199 ; pub const ArenaObjectID_eArenaObjectID_nsStyleContent : root :: mozilla :: ArenaObjectID = 200 ; pub const ArenaObjectID_eArenaObjectID_nsStyleUIReset : root :: mozilla :: ArenaObjectID = 201 ; pub const ArenaObjectID_eArenaObjectID_nsStyleTable : root :: mozilla :: ArenaObjectID = 202 ; pub const ArenaObjectID_eArenaObjectID_nsStyleMargin : root :: mozilla :: ArenaObjectID = 203 ; pub const ArenaObjectID_eArenaObjectID_nsStylePadding : root :: mozilla :: ArenaObjectID = 204 ; pub const ArenaObjectID_eArenaObjectID_nsStyleBorder : root :: mozilla :: ArenaObjectID = 205 ; pub const ArenaObjectID_eArenaObjectID_nsStyleOutline : root :: mozilla :: ArenaObjectID = 206 ; pub const ArenaObjectID_eArenaObjectID_nsStyleXUL : root :: mozilla :: ArenaObjectID = 207 ; pub const ArenaObjectID_eArenaObjectID_nsStyleSVGReset : root :: mozilla :: ArenaObjectID = 208 ; pub const ArenaObjectID_eArenaObjectID_nsStyleColumn : root :: mozilla :: ArenaObjectID = 209 ; pub const ArenaObjectID_eArenaObjectID_nsStyleEffects : root :: mozilla :: ArenaObjectID = 210 ; pub const ArenaObjectID_eArenaObjectID_COUNT : root :: mozilla :: ArenaObjectID = 211 ; pub type ArenaObjectID = :: std :: os :: raw :: c_uint ; 
 /// A default deletion policy using plain old operator delete.
        ///
        /// Note that this type can be specialized, but authors should beware of the risk
        /// that the specialization may at some point cease to match (either because it
        /// gets moved to a different compilation unit or the signature changes). If the
        /// non-specialized (|delete|-based) version compiles for that type but does the
        /// wrong thing, bad things could happen.
        ///
        /// This is a non-issue for types which are always incomplete (i.e. opaque handle
        /// types), since |delete|-ing such a type will always trigger a compilation
        /// error. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct DefaultDelete { pub _address : u8 , } pub type MallocSizeOf = :: std :: option :: Option < unsafe extern "C" fn ( p : * const :: std :: os :: raw :: c_void ) -> usize > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ReverseIterator < IteratorT > { pub mCurrent : IteratorT , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < IteratorT > > , } pub type Array_iterator < T > = * mut T ; pub type Array_const_iterator < T > = * mut T ; pub type Array_reverse_iterator < T > = root :: mozilla :: ReverseIterator < T > ; pub type Array_const_reverse_iterator < T > = root :: mozilla :: ReverseIterator < T > ; pub mod css { # [ allow ( unused_imports ) ] use self :: super :: super :: super :: root ; # [ repr ( u8 ) ] 
 /// Enum defining the mode in which a sheet is to be parsed.  This is
            /// usually, but not always, the same as the cascade level at which the
            /// sheet will apply (see nsStyleSet.h).  Most of the Loader APIs only
            /// support loading of author sheets.
            ///
            /// Author sheets are the normal case: styles embedded in or linked
            /// from HTML pages.  They are also the most restricted.
            ///
            /// User sheets can do anything author sheets can do, and also get
            /// access to a few CSS extensions that are not yet suitable for
            /// exposure on the public Web, but are very useful for expressing
            /// user style overrides, such as @-moz-document rules.
            ///
            /// XXX: eUserSheetFeatures was added in bug 1035091, but some patches in
            /// that bug never landed to use this enum value. Currently, all the features
            /// in user sheet are also available in author sheet.
            ///
            /// Agent sheets have access to all author- and user-sheet features
            /// plus more extensions that are necessary for internal use but,
            /// again, not yet suitable for exposure on the public Web.  Some of
            /// these are outright unsafe to expose; in particular, incorrect
            /// styling of anonymous box pseudo-elements can violate layout
            /// invariants.
            ///
            /// Agent sheets that do not use any unsafe rules could use
            /// eSafeAgentSheetFeatures when creating the sheet. This enum value allows
            /// Servo backend to recognize the sheets as the agent level, but Gecko
            /// backend will parse it under _author_ level. 
 # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SheetParsingMode { eAuthorSheetFeatures = 0 , eUserSheetFeatures = 1 , eAgentSheetFeatures = 2 , eSafeAgentSheetFeatures = 3 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GroupRule { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ImageLoader { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] pub struct URLValueData__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct URLValueData { pub vtable_ : * const URLValueData__bindgen_vtable , pub mRefCnt : root :: mozilla :: ThreadSafeAutoRefCnt , pub mURI : root :: nsMainThreadPtrHandle < root :: nsIURI > , pub mExtraData : root :: RefPtr < root :: mozilla :: URLExtraData > , pub mURIResolved : bool , pub mIsLocalRef : [ u8 ; 2usize ] , pub mMightHaveRef : [ u8 ; 2usize ] , pub mStrings : root :: mozilla :: css :: URLValueData_RustOrGeckoString , pub mUsingRustString : bool , pub mLoadedImage : bool , } pub type URLValueData_HasThreadSafeRefCnt = root :: mozilla :: TrueType ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct URLValueData_RustOrGeckoString { pub mString : root :: __BindgenUnionField < ::nsstring::nsStringRepr > , pub mRustString : root :: __BindgenUnionField < ::gecko_bindings::structs::ServoRawOffsetArc < root :: RustString > > , pub bindgen_union_field : [ u64 ; 2usize ] , } # [ test ] fn bindgen_test_layout_URLValueData_RustOrGeckoString ( ) { assert_eq ! ( :: std :: mem :: size_of :: < URLValueData_RustOrGeckoString > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( URLValueData_RustOrGeckoString ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < URLValueData_RustOrGeckoString > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( URLValueData_RustOrGeckoString ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const URLValueData_RustOrGeckoString ) ) . mString as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( URLValueData_RustOrGeckoString ) , "::" , stringify ! ( mString ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const URLValueData_RustOrGeckoString ) ) . mRustString as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( URLValueData_RustOrGeckoString ) , "::" , stringify ! ( mRustString ) ) ) ; } # [ test ] fn bindgen_test_layout_URLValueData ( ) { assert_eq ! ( :: std :: mem :: size_of :: < URLValueData > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( URLValueData ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < URLValueData > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( URLValueData ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const URLValueData ) ) . mRefCnt as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( URLValueData ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const URLValueData ) ) . mURI as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( URLValueData ) , "::" , stringify ! ( mURI ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const URLValueData ) ) . mExtraData as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( URLValueData ) , "::" , stringify ! ( mExtraData ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const URLValueData ) ) . mURIResolved as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( URLValueData ) , "::" , stringify ! ( mURIResolved ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const URLValueData ) ) . mIsLocalRef as * const _ as usize } , 33usize , concat ! ( "Alignment of field: " , stringify ! ( URLValueData ) , "::" , stringify ! ( mIsLocalRef ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const URLValueData ) ) . mMightHaveRef as * const _ as usize } , 35usize , concat ! ( "Alignment of field: " , stringify ! ( URLValueData ) , "::" , stringify ! ( mMightHaveRef ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const URLValueData ) ) . mStrings as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( URLValueData ) , "::" , stringify ! ( mStrings ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const URLValueData ) ) . mUsingRustString as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( URLValueData ) , "::" , stringify ! ( mUsingRustString ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const URLValueData ) ) . mLoadedImage as * const _ as usize } , 57usize , concat ! ( "Alignment of field: " , stringify ! ( URLValueData ) , "::" , stringify ! ( mLoadedImage ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct URLValue { pub _base : root :: mozilla :: css :: URLValueData , } # [ test ] fn bindgen_test_layout_URLValue ( ) { assert_eq ! ( :: std :: mem :: size_of :: < URLValue > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( URLValue ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < URLValue > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( URLValue ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct ImageValue { pub _base : root :: mozilla :: css :: URLValueData , pub mRequests : [ u64 ; 4usize ] , } # [ test ] fn bindgen_test_layout_ImageValue ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ImageValue > ( ) , 96usize , concat ! ( "Size of: " , stringify ! ( ImageValue ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ImageValue > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ImageValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ImageValue ) ) . mRequests as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( ImageValue ) , "::" , stringify ! ( mRequests ) ) ) ; } # [ repr ( C ) ] pub struct GridNamedArea { pub mName : ::nsstring::nsStringRepr , pub mColumnStart : u32 , pub mColumnEnd : u32 , pub mRowStart : u32 , pub mRowEnd : u32 , } # [ test ] fn bindgen_test_layout_GridNamedArea ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GridNamedArea > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( GridNamedArea ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GridNamedArea > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GridNamedArea ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GridNamedArea ) ) . mName as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GridNamedArea ) , "::" , stringify ! ( mName ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GridNamedArea ) ) . mColumnStart as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( GridNamedArea ) , "::" , stringify ! ( mColumnStart ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GridNamedArea ) ) . mColumnEnd as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( GridNamedArea ) , "::" , stringify ! ( mColumnEnd ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GridNamedArea ) ) . mRowStart as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( GridNamedArea ) , "::" , stringify ! ( mRowStart ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GridNamedArea ) ) . mRowEnd as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( GridNamedArea ) , "::" , stringify ! ( mRowEnd ) ) ) ; } # [ repr ( C ) ] pub struct GridTemplateAreasValue { pub mNamedAreas : root :: nsTArray < root :: mozilla :: css :: GridNamedArea > , pub mTemplates : root :: nsTArray < ::nsstring::nsStringRepr > , pub mNColumns : u32 , pub mRefCnt : root :: mozilla :: ThreadSafeAutoRefCnt , } pub type GridTemplateAreasValue_HasThreadSafeRefCnt = root :: mozilla :: TrueType ; # [ test ] fn bindgen_test_layout_GridTemplateAreasValue ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GridTemplateAreasValue > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( GridTemplateAreasValue ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GridTemplateAreasValue > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GridTemplateAreasValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GridTemplateAreasValue ) ) . mNamedAreas as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GridTemplateAreasValue ) , "::" , stringify ! ( mNamedAreas ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GridTemplateAreasValue ) ) . mTemplates as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( GridTemplateAreasValue ) , "::" , stringify ! ( mTemplates ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GridTemplateAreasValue ) ) . mNColumns as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( GridTemplateAreasValue ) , "::" , stringify ! ( mNColumns ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GridTemplateAreasValue ) ) . mRefCnt as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( GridTemplateAreasValue ) , "::" , stringify ! ( mRefCnt ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct RGBAColorData { pub mR : f32 , pub mG : f32 , pub mB : f32 , pub mA : f32 , } # [ test ] fn bindgen_test_layout_RGBAColorData ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RGBAColorData > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( RGBAColorData ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RGBAColorData > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( RGBAColorData ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const RGBAColorData ) ) . mR as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( RGBAColorData ) , "::" , stringify ! ( mR ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const RGBAColorData ) ) . mG as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( RGBAColorData ) , "::" , stringify ! ( mG ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const RGBAColorData ) ) . mB as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( RGBAColorData ) , "::" , stringify ! ( mB ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const RGBAColorData ) ) . mA as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( RGBAColorData ) , "::" , stringify ! ( mA ) ) ) ; } impl Clone for RGBAColorData { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct ComplexColorData { pub mColor : root :: mozilla :: css :: RGBAColorData , pub mForegroundRatio : f32 , } # [ test ] fn bindgen_test_layout_ComplexColorData ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ComplexColorData > ( ) , 20usize , concat ! ( "Size of: " , stringify ! ( ComplexColorData ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ComplexColorData > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ComplexColorData ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ComplexColorData ) ) . mColor as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ComplexColorData ) , "::" , stringify ! ( mColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ComplexColorData ) ) . mForegroundRatio as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( ComplexColorData ) , "::" , stringify ! ( mForegroundRatio ) ) ) ; } impl Clone for ComplexColorData { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct ComplexColorValue { pub _base : root :: mozilla :: css :: ComplexColorData , pub mRefCnt : root :: nsAutoRefCnt , } pub type ComplexColorValue_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ test ] fn bindgen_test_layout_ComplexColorValue ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ComplexColorValue > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( ComplexColorValue ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ComplexColorValue > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ComplexColorValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ComplexColorValue ) ) . mRefCnt as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( ComplexColorValue ) , "::" , stringify ! ( mRefCnt ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SheetLoadData { _unused : [ u8 ; 0 ] } 
 /// Style sheet reuse * 
 # [ repr ( C ) ] pub struct LoaderReusableStyleSheets { pub mReusableSheets : root :: nsTArray < root :: RefPtr < root :: mozilla :: StyleSheet > > , } # [ test ] fn bindgen_test_layout_LoaderReusableStyleSheets ( ) { assert_eq ! ( :: std :: mem :: size_of :: < LoaderReusableStyleSheets > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( LoaderReusableStyleSheets ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < LoaderReusableStyleSheets > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( LoaderReusableStyleSheets ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const LoaderReusableStyleSheets ) ) . mReusableSheets as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( LoaderReusableStyleSheets ) , "::" , stringify ! ( mReusableSheets ) ) ) ; } # [ repr ( C ) ] pub struct Loader { pub mRefCnt : root :: nsCycleCollectingAutoRefCnt , pub mSheets : root :: nsAutoPtr < root :: mozilla :: css :: Loader_Sheets > , pub mParsingDatas : [ u64 ; 10usize ] , pub mPostedEvents : root :: mozilla :: css :: Loader_LoadDataArray , pub mObservers : [ u64 ; 2usize ] , pub mDocument : * mut root :: nsIDocument , pub mDocGroup : root :: RefPtr < root :: mozilla :: dom :: DocGroup > , pub mDatasToNotifyOn : u32 , pub mCompatMode : root :: nsCompatibility , pub mPreferredSheet : ::nsstring::nsStringRepr , pub mStyleBackendType : [ u8 ; 2usize ] , pub mEnabled : bool , pub mReporter : root :: nsCOMPtr , } pub use self :: super :: super :: super :: root :: mozilla :: net :: ReferrerPolicy as Loader_ReferrerPolicy ; pub type Loader_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct Loader_cycleCollection { pub _base : root :: nsCycleCollectionParticipant , } # [ test ] fn bindgen_test_layout_Loader_cycleCollection ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Loader_cycleCollection > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( Loader_cycleCollection ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Loader_cycleCollection > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Loader_cycleCollection ) ) ) ; } impl Clone for Loader_cycleCollection { fn clone ( & self ) -> Self { * self } } pub type Loader_LoadDataArray = root :: nsTArray < root :: RefPtr < root :: mozilla :: css :: SheetLoadData > > ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct Loader_Sheets { pub mCompleteSheets : [ u64 ; 4usize ] , pub mLoadingDatas : [ u64 ; 4usize ] , pub mPendingDatas : [ u64 ; 4usize ] , } # [ test ] fn bindgen_test_layout_Loader_Sheets ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Loader_Sheets > ( ) , 96usize , concat ! ( "Size of: " , stringify ! ( Loader_Sheets ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Loader_Sheets > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Loader_Sheets ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Loader_Sheets ) ) . mCompleteSheets as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( Loader_Sheets ) , "::" , stringify ! ( mCompleteSheets ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Loader_Sheets ) ) . mLoadingDatas as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( Loader_Sheets ) , "::" , stringify ! ( mLoadingDatas ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Loader_Sheets ) ) . mPendingDatas as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( Loader_Sheets ) , "::" , stringify ! ( mPendingDatas ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla3css6Loader21_cycleCollectorGlobalE" ] 
 pub static mut  Loader__cycleCollectorGlobal  :  root :: mozilla :: css :: Loader_cycleCollection ;
} # [ test ] fn bindgen_test_layout_Loader ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Loader > ( ) , 176usize , concat ! ( "Size of: " , stringify ! ( Loader ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Loader > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Loader ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Loader ) ) . mRefCnt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( Loader ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Loader ) ) . mSheets as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( Loader ) , "::" , stringify ! ( mSheets ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Loader ) ) . mParsingDatas as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( Loader ) , "::" , stringify ! ( mParsingDatas ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Loader ) ) . mPostedEvents as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( Loader ) , "::" , stringify ! ( mPostedEvents ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Loader ) ) . mObservers as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( Loader ) , "::" , stringify ! ( mObservers ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Loader ) ) . mDocument as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( Loader ) , "::" , stringify ! ( mDocument ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Loader ) ) . mDocGroup as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( Loader ) , "::" , stringify ! ( mDocGroup ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Loader ) ) . mDatasToNotifyOn as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( Loader ) , "::" , stringify ! ( mDatasToNotifyOn ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Loader ) ) . mCompatMode as * const _ as usize } , 140usize , concat ! ( "Alignment of field: " , stringify ! ( Loader ) , "::" , stringify ! ( mCompatMode ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Loader ) ) . mPreferredSheet as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( Loader ) , "::" , stringify ! ( mPreferredSheet ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Loader ) ) . mStyleBackendType as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( Loader ) , "::" , stringify ! ( mStyleBackendType ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Loader ) ) . mEnabled as * const _ as usize } , 162usize , concat ! ( "Alignment of field: " , stringify ! ( Loader ) , "::" , stringify ! ( mEnabled ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Loader ) ) . mReporter as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( Loader ) , "::" , stringify ! ( mReporter ) ) ) ; } # [ repr ( C ) ] pub struct ErrorReporter { pub mError : root :: nsAutoString , pub mErrorLine : ::nsstring::nsStringRepr , pub mFileName : ::nsstring::nsStringRepr , pub mScanner : * const root :: nsCSSScanner , pub mSheet : * const root :: mozilla :: StyleSheet , pub mLoader : * const root :: mozilla :: css :: Loader , pub mURI : * mut root :: nsIURI , pub mInnerWindowID : u64 , pub mErrorLineNumber : u32 , pub mPrevErrorLineNumber : u32 , pub mErrorColNumber : u32 , } # [ test ] fn bindgen_test_layout_ErrorReporter ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ErrorReporter > ( ) , 240usize , concat ! ( "Size of: " , stringify ! ( ErrorReporter ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ErrorReporter > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ErrorReporter ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ErrorReporter ) ) . mError as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ErrorReporter ) , "::" , stringify ! ( mError ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ErrorReporter ) ) . mErrorLine as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( ErrorReporter ) , "::" , stringify ! ( mErrorLine ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ErrorReporter ) ) . mFileName as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( ErrorReporter ) , "::" , stringify ! ( mFileName ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ErrorReporter ) ) . mScanner as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( ErrorReporter ) , "::" , stringify ! ( mScanner ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ErrorReporter ) ) . mSheet as * const _ as usize } , 192usize , concat ! ( "Alignment of field: " , stringify ! ( ErrorReporter ) , "::" , stringify ! ( mSheet ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ErrorReporter ) ) . mLoader as * const _ as usize } , 200usize , concat ! ( "Alignment of field: " , stringify ! ( ErrorReporter ) , "::" , stringify ! ( mLoader ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ErrorReporter ) ) . mURI as * const _ as usize } , 208usize , concat ! ( "Alignment of field: " , stringify ! ( ErrorReporter ) , "::" , stringify ! ( mURI ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ErrorReporter ) ) . mInnerWindowID as * const _ as usize } , 216usize , concat ! ( "Alignment of field: " , stringify ! ( ErrorReporter ) , "::" , stringify ! ( mInnerWindowID ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ErrorReporter ) ) . mErrorLineNumber as * const _ as usize } , 224usize , concat ! ( "Alignment of field: " , stringify ! ( ErrorReporter ) , "::" , stringify ! ( mErrorLineNumber ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ErrorReporter ) ) . mPrevErrorLineNumber as * const _ as usize } , 228usize , concat ! ( "Alignment of field: " , stringify ! ( ErrorReporter ) , "::" , stringify ! ( mPrevErrorLineNumber ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ErrorReporter ) ) . mErrorColNumber as * const _ as usize } , 232usize , concat ! ( "Alignment of field: " , stringify ! ( ErrorReporter ) , "::" , stringify ! ( mErrorColNumber ) ) ) ; } # [ repr ( i32 ) ] 
 /// Enum defining the type of URL matching function for a @-moz-document rule
            /// condition. 
 # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum URLMatchingFunction { eURL = 0 , eURLPrefix = 1 , eDomain = 2 , eRegExp = 3 , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct Rule { pub _base : root :: nsIDOMCSSRule , pub _base_1 : root :: nsWrapperCache , pub mRefCnt : root :: nsCycleCollectingAutoRefCnt , pub mSheet : * mut root :: mozilla :: StyleSheet , pub mParentRule : * mut root :: mozilla :: css :: GroupRule , pub mLineNumber : u32 , pub mColumnNumber : u32 , } pub type Rule_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct Rule_cycleCollection { pub _base : root :: nsXPCOMCycleCollectionParticipant , } # [ test ] fn bindgen_test_layout_Rule_cycleCollection ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Rule_cycleCollection > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( Rule_cycleCollection ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Rule_cycleCollection > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Rule_cycleCollection ) ) ) ; } impl Clone for Rule_cycleCollection { fn clone ( & self ) -> Self { * self } } pub const Rule_UNKNOWN_RULE : root :: mozilla :: css :: Rule__bindgen_ty_1 = 0 ; pub const Rule_CHARSET_RULE : root :: mozilla :: css :: Rule__bindgen_ty_1 = 1 ; pub const Rule_IMPORT_RULE : root :: mozilla :: css :: Rule__bindgen_ty_1 = 2 ; pub const Rule_NAMESPACE_RULE : root :: mozilla :: css :: Rule__bindgen_ty_1 = 3 ; pub const Rule_STYLE_RULE : root :: mozilla :: css :: Rule__bindgen_ty_1 = 4 ; pub const Rule_MEDIA_RULE : root :: mozilla :: css :: Rule__bindgen_ty_1 = 5 ; pub const Rule_FONT_FACE_RULE : root :: mozilla :: css :: Rule__bindgen_ty_1 = 6 ; pub const Rule_PAGE_RULE : root :: mozilla :: css :: Rule__bindgen_ty_1 = 7 ; pub const Rule_KEYFRAME_RULE : root :: mozilla :: css :: Rule__bindgen_ty_1 = 8 ; pub const Rule_KEYFRAMES_RULE : root :: mozilla :: css :: Rule__bindgen_ty_1 = 9 ; pub const Rule_DOCUMENT_RULE : root :: mozilla :: css :: Rule__bindgen_ty_1 = 10 ; pub const Rule_SUPPORTS_RULE : root :: mozilla :: css :: Rule__bindgen_ty_1 = 11 ; pub const Rule_FONT_FEATURE_VALUES_RULE : root :: mozilla :: css :: Rule__bindgen_ty_1 = 12 ; pub const Rule_COUNTER_STYLE_RULE : root :: mozilla :: css :: Rule__bindgen_ty_1 = 13 ; pub type Rule__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla3css4Rule21_cycleCollectorGlobalE" ] 
 pub static mut  Rule__cycleCollectorGlobal  :  root :: mozilla :: css :: Rule_cycleCollection ;
} # [ test ] fn bindgen_test_layout_Rule ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Rule > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( Rule ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Rule > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Rule ) ) ) ; } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct ThreadSafeAutoRefCnt { pub mValue : u64 , } pub const ThreadSafeAutoRefCnt_isThreadSafe : bool = true ; # [ test ] fn bindgen_test_layout_ThreadSafeAutoRefCnt ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ThreadSafeAutoRefCnt > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( ThreadSafeAutoRefCnt ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ThreadSafeAutoRefCnt > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ThreadSafeAutoRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ThreadSafeAutoRefCnt ) ) . mValue as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ThreadSafeAutoRefCnt ) , "::" , stringify ! ( mValue ) ) ) ; } pub type EnumeratedArray_ArrayType = u8 ; pub type EnumeratedArray_iterator = root :: mozilla :: EnumeratedArray_ArrayType ; pub type EnumeratedArray_const_iterator = root :: mozilla :: EnumeratedArray_ArrayType ; pub type EnumeratedArray_reverse_iterator = root :: mozilla :: EnumeratedArray_ArrayType ; pub type EnumeratedArray_const_reverse_iterator = root :: mozilla :: EnumeratedArray_ArrayType ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct LinkedListElement { pub mNext : * mut root :: mozilla :: LinkedListElement , pub mPrev : * mut root :: mozilla :: LinkedListElement , pub mIsSentinel : bool , } pub type LinkedListElement_Traits = root :: mozilla :: detail :: LinkedListElementTraits ; pub type LinkedListElement_RawType = root :: mozilla :: LinkedListElement_Traits ; pub type LinkedListElement_ConstRawType = root :: mozilla :: LinkedListElement_Traits ; pub type LinkedListElement_ClientType = root :: mozilla :: LinkedListElement_Traits ; pub type LinkedListElement_ConstClientType = root :: mozilla :: LinkedListElement_Traits ; pub const LinkedListElement_NodeKind_Normal : root :: mozilla :: LinkedListElement_NodeKind = 0 ; pub const LinkedListElement_NodeKind_Sentinel : root :: mozilla :: LinkedListElement_NodeKind = 0 ; pub type LinkedListElement_NodeKind = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct LinkedList { pub sentinel : root :: mozilla :: LinkedListElement , } pub type LinkedList_Traits = root :: mozilla :: detail :: LinkedListElementTraits ; pub type LinkedList_RawType = root :: mozilla :: LinkedList_Traits ; pub type LinkedList_ConstRawType = root :: mozilla :: LinkedList_Traits ; pub type LinkedList_ClientType = root :: mozilla :: LinkedList_Traits ; pub type LinkedList_ConstClientType = root :: mozilla :: LinkedList_Traits ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct LinkedList_Iterator { pub mCurrent : root :: mozilla :: LinkedList_RawType , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Maybe { pub _address : u8 , } pub type Maybe_ValueType < T > = T ; pub mod gfx { # [ allow ( unused_imports ) ] use self :: super :: super :: super :: root ; pub type Float = f32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct IntPointTyped { pub _address : u8 , } pub type IntPointTyped_ToInt = u32 ; pub type IntPointTyped_Coord = u8 ; pub type IntPointTyped_Super = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct FontVariation { pub mTag : u32 , pub mValue : f32 , } # [ test ] fn bindgen_test_layout_FontVariation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < FontVariation > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( FontVariation ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < FontVariation > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( FontVariation ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FontVariation ) ) . mTag as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( FontVariation ) , "::" , stringify ! ( mTag ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FontVariation ) ) . mValue as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( FontVariation ) , "::" , stringify ! ( mValue ) ) ) ; } impl Clone for FontVariation { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SourceSurface { _unused : [ u8 ; 0 ] } } pub mod layers { # [ allow ( unused_imports ) ] use self :: super :: super :: super :: root ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct LayerManager { _unused : [ u8 ; 0 ] } } pub mod dom { # [ allow ( unused_imports ) ] use self :: super :: super :: super :: root ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AllOwningUnionBase { pub _address : u8 , } # [ test ] fn bindgen_test_layout_AllOwningUnionBase ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AllOwningUnionBase > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( AllOwningUnionBase ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AllOwningUnionBase > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( AllOwningUnionBase ) ) ) ; } impl Clone for AllOwningUnionBase { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GlobalObject { pub mGlobalJSObject : [ u64 ; 3usize ] , pub mCx : * mut root :: JSContext , pub mGlobalObject : * mut root :: nsISupports , } # [ test ] fn bindgen_test_layout_GlobalObject ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GlobalObject > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( GlobalObject ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GlobalObject > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GlobalObject ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GlobalObject ) ) . mGlobalJSObject as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GlobalObject ) , "::" , stringify ! ( mGlobalJSObject ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GlobalObject ) ) . mCx as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( GlobalObject ) , "::" , stringify ! ( mCx ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GlobalObject ) ) . mGlobalObject as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( GlobalObject ) , "::" , stringify ! ( mGlobalObject ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Sequence { pub _address : u8 , } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum CallerType { System = 0 , NonSystem = 1 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Nullable { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ClientSource { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct CSSImportRule { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ShadowRoot { _unused : [ u8 ; 0 ] } 
 /// Struct that stores info on an attribute. The name and value must either both
            /// be null or both be non-null.
            ///
            /// Note that, just as the pointers returned by GetAttrNameAt, the pointers that
            /// this struct hold are only valid until the element or its attributes are
            /// mutated (directly or via script). 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct BorrowedAttrInfo { pub mName : * const root :: nsAttrName , pub mValue : * const root :: nsAttrValue , } # [ test ] fn bindgen_test_layout_BorrowedAttrInfo ( ) { assert_eq ! ( :: std :: mem :: size_of :: < BorrowedAttrInfo > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( BorrowedAttrInfo ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < BorrowedAttrInfo > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( BorrowedAttrInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const BorrowedAttrInfo ) ) . mName as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( BorrowedAttrInfo ) , "::" , stringify ! ( mName ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const BorrowedAttrInfo ) ) . mValue as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( BorrowedAttrInfo ) , "::" , stringify ! ( mValue ) ) ) ; } impl Clone for BorrowedAttrInfo { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] pub struct NodeInfo { pub mRefCnt : root :: nsCycleCollectingAutoRefCnt , pub mDocument : * mut root :: nsIDocument , pub mInner : root :: mozilla :: dom :: NodeInfo_NodeInfoInner , pub mOwnerManager : root :: RefPtr < root :: nsNodeInfoManager > , pub mQualifiedName : ::nsstring::nsStringRepr , pub mNodeName : ::nsstring::nsStringRepr , pub mLocalName : ::nsstring::nsStringRepr , } pub type NodeInfo_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct NodeInfo_cycleCollection { pub _base : root :: nsCycleCollectionParticipant , } # [ test ] fn bindgen_test_layout_NodeInfo_cycleCollection ( ) { assert_eq ! ( :: std :: mem :: size_of :: < NodeInfo_cycleCollection > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( NodeInfo_cycleCollection ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < NodeInfo_cycleCollection > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( NodeInfo_cycleCollection ) ) ) ; } impl Clone for NodeInfo_cycleCollection { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct NodeInfo_NodeInfoInner { pub mName : * const root :: nsAtom , pub mPrefix : * mut root :: nsAtom , pub mNamespaceID : i32 , pub mNodeType : u16 , pub mNameString : * const root :: nsAString , pub mExtraName : * mut root :: nsAtom , pub mHash : root :: PLHashNumber , pub mHashInitialized : bool , } # [ test ] fn bindgen_test_layout_NodeInfo_NodeInfoInner ( ) { assert_eq ! ( :: std :: mem :: size_of :: < NodeInfo_NodeInfoInner > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( NodeInfo_NodeInfoInner ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < NodeInfo_NodeInfoInner > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( NodeInfo_NodeInfoInner ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) . mName as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( NodeInfo_NodeInfoInner ) , "::" , stringify ! ( mName ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) . mPrefix as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( NodeInfo_NodeInfoInner ) , "::" , stringify ! ( mPrefix ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) . mNamespaceID as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( NodeInfo_NodeInfoInner ) , "::" , stringify ! ( mNamespaceID ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) . mNodeType as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( NodeInfo_NodeInfoInner ) , "::" , stringify ! ( mNodeType ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) . mNameString as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( NodeInfo_NodeInfoInner ) , "::" , stringify ! ( mNameString ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) . mExtraName as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( NodeInfo_NodeInfoInner ) , "::" , stringify ! ( mExtraName ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) . mHash as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( NodeInfo_NodeInfoInner ) , "::" , stringify ! ( mHash ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) . mHashInitialized as * const _ as usize } , 44usize , concat ! ( "Alignment of field: " , stringify ! ( NodeInfo_NodeInfoInner ) , "::" , stringify ! ( mHashInitialized ) ) ) ; } impl Clone for NodeInfo_NodeInfoInner { fn clone ( & self ) -> Self { * self } } extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla3dom8NodeInfo21_cycleCollectorGlobalE" ] 
 pub static mut  NodeInfo__cycleCollectorGlobal  :  root :: mozilla :: dom :: NodeInfo_cycleCollection ;
} # [ test ] fn bindgen_test_layout_NodeInfo ( ) { assert_eq ! ( :: std :: mem :: size_of :: < NodeInfo > ( ) , 120usize , concat ! ( "Size of: " , stringify ! ( NodeInfo ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < NodeInfo > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( NodeInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const NodeInfo ) ) . mRefCnt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( NodeInfo ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const NodeInfo ) ) . mDocument as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( NodeInfo ) , "::" , stringify ! ( mDocument ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const NodeInfo ) ) . mInner as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( NodeInfo ) , "::" , stringify ! ( mInner ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const NodeInfo ) ) . mOwnerManager as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( NodeInfo ) , "::" , stringify ! ( mOwnerManager ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const NodeInfo ) ) . mQualifiedName as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( NodeInfo ) , "::" , stringify ! ( mQualifiedName ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const NodeInfo ) ) . mNodeName as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( NodeInfo ) , "::" , stringify ! ( mNodeName ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const NodeInfo ) ) . mLocalName as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( NodeInfo ) , "::" , stringify ! ( mLocalName ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct EventTarget { pub _base : root :: nsIDOMEventTarget , pub _base_1 : root :: nsWrapperCache , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct EventTarget_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_EventTarget ( ) { assert_eq ! ( :: std :: mem :: size_of :: < EventTarget > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( EventTarget ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < EventTarget > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( EventTarget ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct BoxQuadOptions { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ConvertCoordinateOptions { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct DocGroup { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct DOMPoint { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct DOMQuad { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct TextOrElementOrDocument { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct DOMPointInit { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct HTMLSlotElement { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct TabGroup { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] pub struct DispatcherTrait__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct DispatcherTrait { pub vtable_ : * const DispatcherTrait__bindgen_vtable , } # [ test ] fn bindgen_test_layout_DispatcherTrait ( ) { assert_eq ! ( :: std :: mem :: size_of :: < DispatcherTrait > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( DispatcherTrait ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < DispatcherTrait > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( DispatcherTrait ) ) ) ; } impl Clone for DispatcherTrait { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct AudioContext { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Performance { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ServiceWorkerRegistration { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct TimeoutManager { _unused : [ u8 ; 0 ] } pub const LargeAllocStatus_NONE : root :: mozilla :: dom :: LargeAllocStatus = 0 ; pub const LargeAllocStatus_SUCCESS : root :: mozilla :: dom :: LargeAllocStatus = 1 ; pub const LargeAllocStatus_NON_GET : root :: mozilla :: dom :: LargeAllocStatus = 2 ; pub const LargeAllocStatus_NON_E10S : root :: mozilla :: dom :: LargeAllocStatus = 3 ; pub const LargeAllocStatus_NOT_ONLY_TOPLEVEL_IN_TABGROUP : root :: mozilla :: dom :: LargeAllocStatus = 4 ; pub const LargeAllocStatus_NON_WIN32 : root :: mozilla :: dom :: LargeAllocStatus = 5 ; pub type LargeAllocStatus = u8 ; pub mod prototypes { # [ allow ( unused_imports ) ] use self :: super :: super :: super :: super :: root ; } pub mod constructors { # [ allow ( unused_imports ) ] use self :: super :: super :: super :: super :: root ; } pub mod namedpropertiesobjects { # [ allow ( unused_imports ) ] use self :: super :: super :: super :: super :: root ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct StyleSheetList { _unused : [ u8 ; 0 ] } 
 /// A class meant to be shared by ShadowRoot and Document, that holds a list of
            /// stylesheets.
            ///
            /// TODO(emilio, bug 1418159): In the future this should hold most of the
            /// relevant style state, this should allow us to fix bug 548397. 
 # [ repr ( C ) ] pub struct DocumentOrShadowRoot { pub mStyleSheets : root :: nsTArray < root :: RefPtr < root :: mozilla :: StyleSheet > > , pub mDOMStyleSheets : root :: RefPtr < root :: mozilla :: dom :: StyleSheetList > , pub mIdentifierMap : [ u64 ; 4usize ] , pub mAsNode : * mut root :: nsINode , pub mKind : root :: mozilla :: dom :: DocumentOrShadowRoot_Kind , } pub const DocumentOrShadowRoot_Kind_Document : root :: mozilla :: dom :: DocumentOrShadowRoot_Kind = 0 ; pub const DocumentOrShadowRoot_Kind_ShadowRoot : root :: mozilla :: dom :: DocumentOrShadowRoot_Kind = 1 ; pub type DocumentOrShadowRoot_Kind = :: std :: os :: raw :: c_int ; # [ test ] fn bindgen_test_layout_DocumentOrShadowRoot ( ) { assert_eq ! ( :: std :: mem :: size_of :: < DocumentOrShadowRoot > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( DocumentOrShadowRoot ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < DocumentOrShadowRoot > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( DocumentOrShadowRoot ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const DocumentOrShadowRoot ) ) . mStyleSheets as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( DocumentOrShadowRoot ) , "::" , stringify ! ( mStyleSheets ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const DocumentOrShadowRoot ) ) . mDOMStyleSheets as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( DocumentOrShadowRoot ) , "::" , stringify ! ( mDOMStyleSheets ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const DocumentOrShadowRoot ) ) . mIdentifierMap as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( DocumentOrShadowRoot ) , "::" , stringify ! ( mIdentifierMap ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const DocumentOrShadowRoot ) ) . mAsNode as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( DocumentOrShadowRoot ) , "::" , stringify ! ( mAsNode ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const DocumentOrShadowRoot ) ) . mKind as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( DocumentOrShadowRoot ) , "::" , stringify ! ( mKind ) ) ) ; } pub const VisibilityState_Hidden : root :: mozilla :: dom :: VisibilityState = 0 ; pub const VisibilityState_Visible : root :: mozilla :: dom :: VisibilityState = 1 ; pub const VisibilityState_Prerender : root :: mozilla :: dom :: VisibilityState = 2 ; pub const VisibilityState_EndGuard_ : root :: mozilla :: dom :: VisibilityState = 3 ; pub type VisibilityState = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct AnonymousContent { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct FontFaceSet { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct FullscreenRequest { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ImageTracker { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Link { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MediaQueryList { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct XPathEvaluator { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct FrameRequestCallback { pub _bindgen_opaque_blob : [ u64 ; 6usize ] , } # [ test ] fn bindgen_test_layout_FrameRequestCallback ( ) { assert_eq ! ( :: std :: mem :: size_of :: < FrameRequestCallback > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( FrameRequestCallback ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < FrameRequestCallback > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( FrameRequestCallback ) ) ) ; } impl Clone for FrameRequestCallback { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] pub struct URLParams { pub mParams : root :: nsTArray < root :: mozilla :: dom :: URLParams_Param > , } # [ repr ( C ) ] pub struct URLParams_ForEachIterator__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct URLParams_ForEachIterator { pub vtable_ : * const URLParams_ForEachIterator__bindgen_vtable , } # [ test ] fn bindgen_test_layout_URLParams_ForEachIterator ( ) { assert_eq ! ( :: std :: mem :: size_of :: < URLParams_ForEachIterator > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( URLParams_ForEachIterator ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < URLParams_ForEachIterator > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( URLParams_ForEachIterator ) ) ) ; } impl Clone for URLParams_ForEachIterator { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] pub struct URLParams_Param { pub mKey : ::nsstring::nsStringRepr , pub mValue : ::nsstring::nsStringRepr , } # [ test ] fn bindgen_test_layout_URLParams_Param ( ) { assert_eq ! ( :: std :: mem :: size_of :: < URLParams_Param > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( URLParams_Param ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < URLParams_Param > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( URLParams_Param ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const URLParams_Param ) ) . mKey as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( URLParams_Param ) , "::" , stringify ! ( mKey ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const URLParams_Param ) ) . mValue as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( URLParams_Param ) , "::" , stringify ! ( mValue ) ) ) ; } # [ test ] fn bindgen_test_layout_URLParams ( ) { assert_eq ! ( :: std :: mem :: size_of :: < URLParams > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( URLParams ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < URLParams > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( URLParams ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const URLParams ) ) . mParams as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( URLParams ) , "::" , stringify ! ( mParams ) ) ) ; } # [ repr ( C ) ] pub struct SRIMetadata { pub mHashes : root :: nsTArray < root :: nsCString > , pub mIntegrityString : ::nsstring::nsStringRepr , pub mAlgorithm : root :: nsCString , pub mAlgorithmType : i8 , pub mEmpty : bool , } pub const SRIMetadata_MAX_ALTERNATE_HASHES : u32 = 256 ; pub const SRIMetadata_UNKNOWN_ALGORITHM : i8 = -1 ; # [ test ] fn bindgen_test_layout_SRIMetadata ( ) { assert_eq ! ( :: std :: mem :: size_of :: < SRIMetadata > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( SRIMetadata ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < SRIMetadata > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SRIMetadata ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const SRIMetadata ) ) . mHashes as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( SRIMetadata ) , "::" , stringify ! ( mHashes ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const SRIMetadata ) ) . mIntegrityString as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( SRIMetadata ) , "::" , stringify ! ( mIntegrityString ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const SRIMetadata ) ) . mAlgorithm as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( SRIMetadata ) , "::" , stringify ! ( mAlgorithm ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const SRIMetadata ) ) . mAlgorithmType as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( SRIMetadata ) , "::" , stringify ! ( mAlgorithmType ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const SRIMetadata ) ) . mEmpty as * const _ as usize } , 41usize , concat ! ( "Alignment of field: " , stringify ! ( SRIMetadata ) , "::" , stringify ! ( mEmpty ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct OwningNodeOrString { pub mType : root :: mozilla :: dom :: OwningNodeOrString_Type , pub mValue : root :: mozilla :: dom :: OwningNodeOrString_Value , } pub const OwningNodeOrString_Type_eUninitialized : root :: mozilla :: dom :: OwningNodeOrString_Type = 0 ; pub const OwningNodeOrString_Type_eNode : root :: mozilla :: dom :: OwningNodeOrString_Type = 1 ; pub const OwningNodeOrString_Type_eString : root :: mozilla :: dom :: OwningNodeOrString_Type = 2 ; pub type OwningNodeOrString_Type = :: std :: os :: raw :: c_uint ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct OwningNodeOrString_Value { pub _bindgen_opaque_blob : [ u64 ; 2usize ] , } # [ test ] fn bindgen_test_layout_OwningNodeOrString_Value ( ) { assert_eq ! ( :: std :: mem :: size_of :: < OwningNodeOrString_Value > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( OwningNodeOrString_Value ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < OwningNodeOrString_Value > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( OwningNodeOrString_Value ) ) ) ; } impl Clone for OwningNodeOrString_Value { fn clone ( & self ) -> Self { * self } } # [ test ] fn bindgen_test_layout_OwningNodeOrString ( ) { assert_eq ! ( :: std :: mem :: size_of :: < OwningNodeOrString > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( OwningNodeOrString ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < OwningNodeOrString > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( OwningNodeOrString ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const OwningNodeOrString ) ) . mType as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( OwningNodeOrString ) , "::" , stringify ! ( mType ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const OwningNodeOrString ) ) . mValue as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( OwningNodeOrString ) , "::" , stringify ! ( mValue ) ) ) ; } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum FillMode { None = 0 , Forwards = 1 , Backwards = 2 , Both = 3 , Auto = 4 , EndGuard_ = 5 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum PlaybackDirection { Normal = 0 , Reverse = 1 , Alternate = 2 , Alternate_reverse = 3 , EndGuard_ = 4 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum CompositeOperation { Replace = 0 , Add = 1 , Accumulate = 2 , EndGuard_ = 3 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum IterationCompositeOperation { Replace = 0 , Accumulate = 1 , EndGuard_ = 2 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct XBLChildrenElement { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct CustomElementData { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] pub struct FragmentOrElement { pub _base : root :: nsIContent , pub mRefCnt : root :: nsCycleCollectingAutoRefCnt , 
 /// Array containing all attributes and children for this element 
 pub mAttrsAndChildren : root :: nsAttrAndChildArray , } pub type FragmentOrElement_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct FragmentOrElement_cycleCollection { pub _base : root :: nsXPCOMCycleCollectionParticipant , } # [ test ] fn bindgen_test_layout_FragmentOrElement_cycleCollection ( ) { assert_eq ! ( :: std :: mem :: size_of :: < FragmentOrElement_cycleCollection > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( FragmentOrElement_cycleCollection ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < FragmentOrElement_cycleCollection > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( FragmentOrElement_cycleCollection ) ) ) ; } impl Clone for FragmentOrElement_cycleCollection { fn clone ( & self ) -> Self { * self } } 
 /// There are a set of DOM- and scripting-specific instance variables
            /// that may only be instantiated when a content object is accessed
            /// through the DOM. Rather than burn actual slots in the content
            /// objects for each of these instance variables, we put them off
            /// in a side structure that's only allocated when the content is
            /// accessed through the DOM. 
 # [ repr ( C ) ] pub struct FragmentOrElement_nsExtendedDOMSlots { pub _base : root :: nsIContent_nsExtendedContentSlots , 
 /// SMIL Overridde style rules (for SMIL animation of CSS properties)
                /// @see Element::GetSMILOverrideStyle 
 pub mSMILOverrideStyle : root :: nsCOMPtr , 
 /// Holds any SMIL override style declaration for this element. 
 pub mSMILOverrideStyleDeclaration : root :: RefPtr < root :: mozilla :: DeclarationBlock > , 
 /// The controllers of the XUL Element. 
 pub mControllers : root :: nsCOMPtr , 
 /// An object implementing the .labels property for this element. 
 pub mLabelsList : root :: RefPtr < root :: nsLabelsNodeList > , 
 /// ShadowRoot bound to the element. 
 pub mShadowRoot : root :: RefPtr < root :: mozilla :: dom :: ShadowRoot > , 
 /// XBL binding installed on the element. 
 pub mXBLBinding : root :: RefPtr < root :: nsXBLBinding > , 
 /// Web components custom element data. 
 pub mCustomElementData : root :: RefPtr < root :: mozilla :: dom :: CustomElementData > , 
 /// For XUL to hold either frameloader or opener. 
 pub mFrameLoaderOrOpener : root :: nsCOMPtr , } # [ test ] fn bindgen_test_layout_FragmentOrElement_nsExtendedDOMSlots ( ) { assert_eq ! ( :: std :: mem :: size_of :: < FragmentOrElement_nsExtendedDOMSlots > ( ) , 104usize , concat ! ( "Size of: " , stringify ! ( FragmentOrElement_nsExtendedDOMSlots ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < FragmentOrElement_nsExtendedDOMSlots > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( FragmentOrElement_nsExtendedDOMSlots ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FragmentOrElement_nsExtendedDOMSlots ) ) . mSMILOverrideStyle as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( FragmentOrElement_nsExtendedDOMSlots ) , "::" , stringify ! ( mSMILOverrideStyle ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FragmentOrElement_nsExtendedDOMSlots ) ) . mSMILOverrideStyleDeclaration as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( FragmentOrElement_nsExtendedDOMSlots ) , "::" , stringify ! ( mSMILOverrideStyleDeclaration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FragmentOrElement_nsExtendedDOMSlots ) ) . mControllers as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( FragmentOrElement_nsExtendedDOMSlots ) , "::" , stringify ! ( mControllers ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FragmentOrElement_nsExtendedDOMSlots ) ) . mLabelsList as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( FragmentOrElement_nsExtendedDOMSlots ) , "::" , stringify ! ( mLabelsList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FragmentOrElement_nsExtendedDOMSlots ) ) . mShadowRoot as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( FragmentOrElement_nsExtendedDOMSlots ) , "::" , stringify ! ( mShadowRoot ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FragmentOrElement_nsExtendedDOMSlots ) ) . mXBLBinding as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( FragmentOrElement_nsExtendedDOMSlots ) , "::" , stringify ! ( mXBLBinding ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FragmentOrElement_nsExtendedDOMSlots ) ) . mCustomElementData as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( FragmentOrElement_nsExtendedDOMSlots ) , "::" , stringify ! ( mCustomElementData ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FragmentOrElement_nsExtendedDOMSlots ) ) . mFrameLoaderOrOpener as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( FragmentOrElement_nsExtendedDOMSlots ) , "::" , stringify ! ( mFrameLoaderOrOpener ) ) ) ; } # [ repr ( C ) ] pub struct FragmentOrElement_nsDOMSlots { pub _base : root :: nsIContent_nsContentSlots , 
 /// The .style attribute (an interface that forwards to the actual
                /// style rules)
                /// @see nsGenericHTMLElement::GetStyle 
 pub mStyle : root :: nsCOMPtr , 
 /// The .dataset attribute.
                /// @see nsGenericHTMLElement::GetDataset 
 pub mDataset : * mut root :: nsDOMStringMap , 
 /// An object implementing nsIDOMMozNamedAttrMap for this content (attributes)
                /// @see FragmentOrElement::GetAttributes 
 pub mAttributeMap : root :: RefPtr < root :: nsDOMAttributeMap > , 
 /// An object implementing the .children property for this element. 
 pub mChildrenList : root :: RefPtr < root :: nsContentList > , 
 /// An object implementing the .classList property for this element. 
 pub mClassList : root :: RefPtr < root :: nsDOMTokenList > , } # [ test ] fn bindgen_test_layout_FragmentOrElement_nsDOMSlots ( ) { assert_eq ! ( :: std :: mem :: size_of :: < FragmentOrElement_nsDOMSlots > ( ) , 120usize , concat ! ( "Size of: " , stringify ! ( FragmentOrElement_nsDOMSlots ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < FragmentOrElement_nsDOMSlots > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( FragmentOrElement_nsDOMSlots ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FragmentOrElement_nsDOMSlots ) ) . mStyle as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( FragmentOrElement_nsDOMSlots ) , "::" , stringify ! ( mStyle ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FragmentOrElement_nsDOMSlots ) ) . mDataset as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( FragmentOrElement_nsDOMSlots ) , "::" , stringify ! ( mDataset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FragmentOrElement_nsDOMSlots ) ) . mAttributeMap as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( FragmentOrElement_nsDOMSlots ) , "::" , stringify ! ( mAttributeMap ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FragmentOrElement_nsDOMSlots ) ) . mChildrenList as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( FragmentOrElement_nsDOMSlots ) , "::" , stringify ! ( mChildrenList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FragmentOrElement_nsDOMSlots ) ) . mClassList as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( FragmentOrElement_nsDOMSlots ) , "::" , stringify ! ( mClassList ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla3dom17FragmentOrElement21_cycleCollectorGlobalE" ] 
 pub static mut  FragmentOrElement__cycleCollectorGlobal  :  root :: mozilla :: dom :: FragmentOrElement_cycleCollection ;
} # [ test ] fn bindgen_test_layout_FragmentOrElement ( ) { assert_eq ! ( :: std :: mem :: size_of :: < FragmentOrElement > ( ) , 104usize , concat ! ( "Size of: " , stringify ! ( FragmentOrElement ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < FragmentOrElement > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( FragmentOrElement ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FragmentOrElement ) ) . mRefCnt as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( FragmentOrElement ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FragmentOrElement ) ) . mAttrsAndChildren as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( FragmentOrElement ) , "::" , stringify ! ( mAttrsAndChildren ) ) ) ; } # [ repr ( C ) ] pub struct Attr { pub _base : root :: nsIAttribute , pub _base_1 : root :: nsIDOMAttr , pub mRefCnt : root :: nsCycleCollectingAutoRefCnt , pub mValue : ::nsstring::nsStringRepr , } pub type Attr_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct Attr_cycleCollection { pub _base : root :: nsXPCOMCycleCollectionParticipant , } # [ test ] fn bindgen_test_layout_Attr_cycleCollection ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Attr_cycleCollection > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( Attr_cycleCollection ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Attr_cycleCollection > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Attr_cycleCollection ) ) ) ; } impl Clone for Attr_cycleCollection { fn clone ( & self ) -> Self { * self } } extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla3dom4Attr21_cycleCollectorGlobalE" ] 
 pub static mut  Attr__cycleCollectorGlobal  :  root :: mozilla :: dom :: Attr_cycleCollection ;
} extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla3dom4Attr12sInitializedE" ] 
 pub static mut  Attr_sInitialized  :  bool ;
} # [ test ] fn bindgen_test_layout_Attr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Attr > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( Attr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Attr > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Attr ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct DOMRectReadOnly { pub _base : root :: nsISupports , pub _base_1 : root :: nsWrapperCache , pub mRefCnt : root :: nsCycleCollectingAutoRefCnt , pub mParent : root :: nsCOMPtr , } pub type DOMRectReadOnly_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct DOMRectReadOnly_cycleCollection { pub _base : root :: nsXPCOMCycleCollectionParticipant , } # [ test ] fn bindgen_test_layout_DOMRectReadOnly_cycleCollection ( ) { assert_eq ! ( :: std :: mem :: size_of :: < DOMRectReadOnly_cycleCollection > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( DOMRectReadOnly_cycleCollection ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < DOMRectReadOnly_cycleCollection > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( DOMRectReadOnly_cycleCollection ) ) ) ; } impl Clone for DOMRectReadOnly_cycleCollection { fn clone ( & self ) -> Self { * self } } extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla3dom15DOMRectReadOnly21_cycleCollectorGlobalE" ] 
 pub static mut  DOMRectReadOnly__cycleCollectorGlobal  :  root :: mozilla :: dom :: DOMRectReadOnly_cycleCollection ;
} # [ test ] fn bindgen_test_layout_DOMRectReadOnly ( ) { assert_eq ! ( :: std :: mem :: size_of :: < DOMRectReadOnly > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( DOMRectReadOnly ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < DOMRectReadOnly > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( DOMRectReadOnly ) ) ) ; } # [ repr ( C ) ] pub struct Element { pub _base : root :: mozilla :: dom :: FragmentOrElement , pub mState : root :: mozilla :: EventStates , pub mServoData : ::gecko_bindings::structs::ServoCell < * mut ::gecko_bindings::structs::ServoNodeData > , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Element_COMTypeInfo { pub _address : u8 , } 
 /// StyleStateLocks is used to specify which event states should be locked,
            /// and whether they should be locked to on or off. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct Element_StyleStateLocks { pub mLocks : root :: mozilla :: EventStates , pub mValues : root :: mozilla :: EventStates , } # [ test ] fn bindgen_test_layout_Element_StyleStateLocks ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Element_StyleStateLocks > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( Element_StyleStateLocks ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Element_StyleStateLocks > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Element_StyleStateLocks ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Element_StyleStateLocks ) ) . mLocks as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( Element_StyleStateLocks ) , "::" , stringify ! ( mLocks ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Element_StyleStateLocks ) ) . mValues as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( Element_StyleStateLocks ) , "::" , stringify ! ( mValues ) ) ) ; } impl Clone for Element_StyleStateLocks { fn clone ( & self ) -> Self { * self } } pub const Element_ATTR_MISSING : root :: mozilla :: dom :: Element__bindgen_ty_1 = -1 ; pub const Element_ATTR_VALUE_NO_MATCH : root :: mozilla :: dom :: Element__bindgen_ty_1 = -2 ; pub type Element__bindgen_ty_1 = :: std :: os :: raw :: c_int ; 
 /// Check whether this Element's given attribute has one of a given list of
            /// values. If there is a match, we return the index in the list of the first
            /// matching value. If there was no attribute at all, then we return
            /// ATTR_MISSING. If there was an attribute but it didn't match, we return
            /// ATTR_VALUE_NO_MATCH. A non-negative result always indicates a match.
            ///
            /// @param aNameSpaceID The namespace ID of the attribute.  Must not
            /// be kNameSpaceID_Unknown.
            /// @param aName The name atom of the attribute.  Must not be null.
            /// @param aValues a nullptr-terminated array of pointers to atom values to test
            /// against.
            /// @param aCaseSensitive Whether to do a case-sensitive compare on the values.
            /// @return ATTR_MISSING, ATTR_VALUE_NO_MATCH or the non-negative index
            /// indicating the first value of aValues that matched 
 pub type Element_AttrValuesArray = * const * const root :: nsStaticAtom ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct Element_MappedAttributeEntry { pub attribute : * mut * mut root :: nsStaticAtom , } # [ test ] fn bindgen_test_layout_Element_MappedAttributeEntry ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Element_MappedAttributeEntry > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( Element_MappedAttributeEntry ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Element_MappedAttributeEntry > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Element_MappedAttributeEntry ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Element_MappedAttributeEntry ) ) . attribute as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( Element_MappedAttributeEntry ) , "::" , stringify ! ( attribute ) ) ) ; } impl Clone for Element_MappedAttributeEntry { fn clone ( & self ) -> Self { * self } } 
 /// Define a general matching function that can be passed to
            /// GetElementsByMatching(). Each Element being considered is
            /// passed in. 
 pub type Element_nsElementMatchFunc = :: std :: option :: Option < unsafe extern "C" fn ( aElement : * mut root :: mozilla :: dom :: Element ) -> bool > ; pub const Element_kAllServoDescendantBits : u32 = 25296896 ; pub const Element_kFireMutationEvent : bool = true ; pub const Element_kDontFireMutationEvent : bool = false ; pub const Element_kNotifyDocumentObservers : bool = true ; pub const Element_kDontNotifyDocumentObservers : bool = false ; pub const Element_kCallAfterSetAttr : bool = true ; pub const Element_kDontCallAfterSetAttr : bool = false ; # [ test ] fn bindgen_test_layout_Element ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Element > ( ) , 120usize , concat ! ( "Size of: " , stringify ! ( Element ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Element > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Element ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Element ) ) . mState as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( Element ) , "::" , stringify ! ( mState ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Element ) ) . mServoData as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( Element ) , "::" , stringify ! ( mServoData ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct ExplicitChildIterator { pub mParent : * const root :: nsIContent , pub mParentAsSlot : * const root :: mozilla :: dom :: HTMLSlotElement , pub mChild : * mut root :: nsIContent , pub mDefaultChild : * mut root :: nsIContent , pub mIsFirst : bool , pub mIndexInInserted : u32 , } # [ test ] fn bindgen_test_layout_ExplicitChildIterator ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ExplicitChildIterator > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( ExplicitChildIterator ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ExplicitChildIterator > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ExplicitChildIterator ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ExplicitChildIterator ) ) . mParent as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ExplicitChildIterator ) , "::" , stringify ! ( mParent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ExplicitChildIterator ) ) . mParentAsSlot as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ExplicitChildIterator ) , "::" , stringify ! ( mParentAsSlot ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ExplicitChildIterator ) ) . mChild as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( ExplicitChildIterator ) , "::" , stringify ! ( mChild ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ExplicitChildIterator ) ) . mDefaultChild as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( ExplicitChildIterator ) , "::" , stringify ! ( mDefaultChild ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ExplicitChildIterator ) ) . mIsFirst as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( ExplicitChildIterator ) , "::" , stringify ! ( mIsFirst ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ExplicitChildIterator ) ) . mIndexInInserted as * const _ as usize } , 36usize , concat ! ( "Alignment of field: " , stringify ! ( ExplicitChildIterator ) , "::" , stringify ! ( mIndexInInserted ) ) ) ; } impl Clone for ExplicitChildIterator { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct FlattenedChildIterator { pub _base : root :: mozilla :: dom :: ExplicitChildIterator , pub mXBLInvolved : bool , pub mOriginalContent : * const root :: nsIContent , } # [ test ] fn bindgen_test_layout_FlattenedChildIterator ( ) { assert_eq ! ( :: std :: mem :: size_of :: < FlattenedChildIterator > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( FlattenedChildIterator ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < FlattenedChildIterator > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( FlattenedChildIterator ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FlattenedChildIterator ) ) . mXBLInvolved as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( FlattenedChildIterator ) , "::" , stringify ! ( mXBLInvolved ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FlattenedChildIterator ) ) . mOriginalContent as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( FlattenedChildIterator ) , "::" , stringify ! ( mOriginalContent ) ) ) ; } impl Clone for FlattenedChildIterator { fn clone ( & self ) -> Self { * self } } 
 /// AllChildrenIterator traverses the children of an element including before /
            /// after content and optionally XBL children.  The iterator can be initialized
            /// to start at the end by providing false for aStartAtBeginning in order to
            /// start iterating in reverse from the last child.
            ///
            /// Note: it assumes that no mutation of the DOM or frame tree takes place during
            /// iteration, and will break horribly if that is not true. 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct AllChildrenIterator { pub _base : root :: mozilla :: dom :: FlattenedChildIterator , pub mAnonKids : root :: nsTArray < * mut root :: nsIContent > , pub mAnonKidsIdx : u32 , pub mFlags : u32 , pub mPhase : root :: mozilla :: dom :: AllChildrenIterator_IteratorPhase , } pub const AllChildrenIterator_IteratorPhase_eAtBegin : root :: mozilla :: dom :: AllChildrenIterator_IteratorPhase = 0 ; pub const AllChildrenIterator_IteratorPhase_eAtBeforeKid : root :: mozilla :: dom :: AllChildrenIterator_IteratorPhase = 1 ; pub const AllChildrenIterator_IteratorPhase_eAtExplicitKids : root :: mozilla :: dom :: AllChildrenIterator_IteratorPhase = 2 ; pub const AllChildrenIterator_IteratorPhase_eAtAnonKids : root :: mozilla :: dom :: AllChildrenIterator_IteratorPhase = 3 ; pub const AllChildrenIterator_IteratorPhase_eAtAfterKid : root :: mozilla :: dom :: AllChildrenIterator_IteratorPhase = 4 ; pub const AllChildrenIterator_IteratorPhase_eAtEnd : root :: mozilla :: dom :: AllChildrenIterator_IteratorPhase = 5 ; pub type AllChildrenIterator_IteratorPhase = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_AllChildrenIterator ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AllChildrenIterator > ( ) , 80usize , concat ! ( "Size of: " , stringify ! ( AllChildrenIterator ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AllChildrenIterator > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AllChildrenIterator ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AllChildrenIterator ) ) . mAnonKids as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( AllChildrenIterator ) , "::" , stringify ! ( mAnonKids ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AllChildrenIterator ) ) . mAnonKidsIdx as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( AllChildrenIterator ) , "::" , stringify ! ( mAnonKidsIdx ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AllChildrenIterator ) ) . mFlags as * const _ as usize } , 68usize , concat ! ( "Alignment of field: " , stringify ! ( AllChildrenIterator ) , "::" , stringify ! ( mFlags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AllChildrenIterator ) ) . mPhase as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( AllChildrenIterator ) , "::" , stringify ! ( mPhase ) ) ) ; } 
 /// StyleChildrenIterator traverses the children of the element from the
            /// perspective of the style system, particularly the children we need to
            /// traverse during restyle.
            ///
            /// At present, this is identical to AllChildrenIterator with
            /// (eAllChildren | eSkipDocumentLevelNativeAnonymousContent). We used to have
            /// detect and skip any native anonymous children that are used to implement some
            /// special magic in here that went away, but we keep the separate class so
            /// we can reintroduce special magic back if needed.
            ///
            /// Note: it assumes that no mutation of the DOM or frame tree takes place during
            /// iteration, and will break horribly if that is not true.
            ///
            /// We require this to be memmovable since Rust code can create and move
            /// StyleChildrenIterators. 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct StyleChildrenIterator { pub _base : root :: mozilla :: dom :: AllChildrenIterator , } # [ test ] fn bindgen_test_layout_StyleChildrenIterator ( ) { assert_eq ! ( :: std :: mem :: size_of :: < StyleChildrenIterator > ( ) , 80usize , concat ! ( "Size of: " , stringify ! ( StyleChildrenIterator ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < StyleChildrenIterator > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( StyleChildrenIterator ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct MediaList { pub _base : root :: nsIDOMMediaList , pub _base_1 : root :: nsWrapperCache , pub mRefCnt : root :: nsCycleCollectingAutoRefCnt , pub mStyleSheet : * mut root :: mozilla :: StyleSheet , } pub type MediaList_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct MediaList_cycleCollection { pub _base : root :: nsXPCOMCycleCollectionParticipant , } # [ test ] fn bindgen_test_layout_MediaList_cycleCollection ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MediaList_cycleCollection > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( MediaList_cycleCollection ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MediaList_cycleCollection > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MediaList_cycleCollection ) ) ) ; } impl Clone for MediaList_cycleCollection { fn clone ( & self ) -> Self { * self } } extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla3dom9MediaList21_cycleCollectorGlobalE" ] 
 pub static mut  MediaList__cycleCollectorGlobal  :  root :: mozilla :: dom :: MediaList_cycleCollection ;
} # [ test ] fn bindgen_test_layout_MediaList ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MediaList > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( MediaList ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MediaList > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MediaList ) ) ) ; } } # [ repr ( C ) ] pub struct CSSVariableValues { 
 /// Map of variable names to IDs.  Variable IDs are indexes into
            /// mVariables. 
 pub mVariableIDs : [ u64 ; 4usize ] , 
 /// Array of variables, indexed by variable ID. 
 pub mVariables : root :: nsTArray < root :: mozilla :: CSSVariableValues_Variable > , } # [ repr ( C ) ] pub struct CSSVariableValues_Variable { pub mVariableName : ::nsstring::nsStringRepr , pub mValue : ::nsstring::nsStringRepr , pub mFirstToken : root :: nsCSSTokenSerializationType , pub mLastToken : root :: nsCSSTokenSerializationType , } # [ test ] fn bindgen_test_layout_CSSVariableValues_Variable ( ) { assert_eq ! ( :: std :: mem :: size_of :: < CSSVariableValues_Variable > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( CSSVariableValues_Variable ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < CSSVariableValues_Variable > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( CSSVariableValues_Variable ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CSSVariableValues_Variable ) ) . mVariableName as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( CSSVariableValues_Variable ) , "::" , stringify ! ( mVariableName ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CSSVariableValues_Variable ) ) . mValue as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( CSSVariableValues_Variable ) , "::" , stringify ! ( mValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CSSVariableValues_Variable ) ) . mFirstToken as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( CSSVariableValues_Variable ) , "::" , stringify ! ( mFirstToken ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CSSVariableValues_Variable ) ) . mLastToken as * const _ as usize } , 36usize , concat ! ( "Alignment of field: " , stringify ! ( CSSVariableValues_Variable ) , "::" , stringify ! ( mLastToken ) ) ) ; } # [ test ] fn bindgen_test_layout_CSSVariableValues ( ) { assert_eq ! ( :: std :: mem :: size_of :: < CSSVariableValues > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( CSSVariableValues ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < CSSVariableValues > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( CSSVariableValues ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CSSVariableValues ) ) . mVariableIDs as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( CSSVariableValues ) , "::" , stringify ! ( mVariableIDs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CSSVariableValues ) ) . mVariables as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( CSSVariableValues ) , "::" , stringify ! ( mVariables ) ) ) ; } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SheetType { Agent = 0 , User = 1 , PresHint = 2 , Doc = 3 , ScopedDoc = 4 , StyleAttr = 5 , Override = 6 , Animation = 7 , Transition = 8 , Count = 9 , Unknown = 255 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct StaticRefPtr < T > { pub mRawPtr : * mut T , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , } 
 /// This struct represents a combined color from a numeric color and
        /// the current foreground color (currentcolor keyword).
        /// Conceptually, the formula is "color * (1 - p) + currentcolor * p"
        /// where p is mForegroundRatio. See mozilla::LinearBlendColors for
        /// the actual algorithm. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct StyleComplexColor { pub mColor : root :: nscolor , pub mForegroundRatio : u8 , pub mIsAuto : bool , } # [ test ] fn bindgen_test_layout_StyleComplexColor ( ) { assert_eq ! ( :: std :: mem :: size_of :: < StyleComplexColor > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( StyleComplexColor ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < StyleComplexColor > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( StyleComplexColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleComplexColor ) ) . mColor as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( StyleComplexColor ) , "::" , stringify ! ( mColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleComplexColor ) ) . mForegroundRatio as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( StyleComplexColor ) , "::" , stringify ! ( mForegroundRatio ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleComplexColor ) ) . mIsAuto as * const _ as usize } , 5usize , concat ! ( "Alignment of field: " , stringify ! ( StyleComplexColor ) , "::" , stringify ! ( mIsAuto ) ) ) ; } impl Clone for StyleComplexColor { fn clone ( & self ) -> Self { * self } } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum Side { eSideTop = 0 , eSideRight = 1 , eSideBottom = 2 , eSideLeft = 3 , } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum HalfCorner { eCornerTopLeftX = 0 , eCornerTopLeftY = 1 , eCornerTopRightX = 2 , eCornerTopRightY = 3 , eCornerBottomRightX = 4 , eCornerBottomRightY = 5 , eCornerBottomLeftX = 6 , eCornerBottomLeftY = 7 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct NotNull < T > { pub mBasePtr : T , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , } pub const FontFamilyType_eFamily_generic_first : root :: mozilla :: FontFamilyType = FontFamilyType :: eFamily_serif ; pub const FontFamilyType_eFamily_generic_last : root :: mozilla :: FontFamilyType = FontFamilyType :: eFamily_fantasy ; pub const FontFamilyType_eFamily_generic_count : root :: mozilla :: FontFamilyType = FontFamilyType :: eFamily_monospace ; # [ repr ( u32 ) ] 
 /// type of font family name, either a name (e.g. Helvetica) or a
        /// generic (e.g. serif, sans-serif), with the ability to distinguish
        /// between unquoted and quoted names for serializaiton 
 # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum FontFamilyType { eFamily_none = 0 , eFamily_named = 1 , eFamily_named_quoted = 2 , eFamily_serif = 3 , eFamily_sans_serif = 4 , eFamily_monospace = 5 , eFamily_cursive = 6 , eFamily_fantasy = 7 , eFamily_moz_variable = 8 , eFamily_moz_fixed = 9 , eFamily_moz_emoji = 10 , } 
 /// font family name, a string for the name if not a generic and
        /// a font type indicated named family or which generic family 
 # [ repr ( C ) ] pub struct FontFamilyName { pub mType : root :: mozilla :: FontFamilyType , pub mName : ::nsstring::nsStringRepr , } # [ test ] fn bindgen_test_layout_FontFamilyName ( ) { assert_eq ! ( :: std :: mem :: size_of :: < FontFamilyName > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( FontFamilyName ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < FontFamilyName > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( FontFamilyName ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FontFamilyName ) ) . mType as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( FontFamilyName ) , "::" , stringify ! ( mType ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FontFamilyName ) ) . mName as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( FontFamilyName ) , "::" , stringify ! ( mName ) ) ) ; } 
 /// A refcounted array of FontFamilyNames.  We use this to store the specified
        /// value (in Servo) and the computed value (in both Gecko and Servo) of the
        /// font-family property. 
 # [ repr ( C ) ] pub struct SharedFontList { pub mRefCnt : root :: mozilla :: ThreadSafeAutoRefCnt , pub mNames : root :: nsTArray < root :: mozilla :: FontFamilyName > , } pub type SharedFontList_HasThreadSafeRefCnt = root :: mozilla :: TrueType ; extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla14SharedFontList6sEmptyE" ] 
 pub static mut  SharedFontList_sEmpty  :  root :: mozilla :: StaticRefPtr < root :: mozilla :: SharedFontList > ;
} # [ test ] fn bindgen_test_layout_SharedFontList ( ) { assert_eq ! ( :: std :: mem :: size_of :: < SharedFontList > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SharedFontList ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < SharedFontList > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SharedFontList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const SharedFontList ) ) . mRefCnt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( SharedFontList ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const SharedFontList ) ) . mNames as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( SharedFontList ) , "::" , stringify ! ( mNames ) ) ) ; } # [ test ] fn __bindgen_test_layout_StaticRefPtr_open0_SharedFontList_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: StaticRefPtr < root :: mozilla :: SharedFontList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: StaticRefPtr < root :: mozilla :: SharedFontList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: StaticRefPtr < root :: mozilla :: SharedFontList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: StaticRefPtr < root :: mozilla :: SharedFontList > ) ) ) ; } 
 /// font family list, array of font families and a default font type.
        /// font family names are either named strings or generics. the default
        /// font type is used to preserve the variable font fallback behavior 
 # [ repr ( C ) ] pub struct FontFamilyList { pub mFontlist : root :: mozilla :: NotNull < root :: RefPtr < root :: mozilla :: SharedFontList > > , pub mDefaultFontType : root :: mozilla :: FontFamilyType , } # [ test ] fn bindgen_test_layout_FontFamilyList ( ) { assert_eq ! ( :: std :: mem :: size_of :: < FontFamilyList > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( FontFamilyList ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < FontFamilyList > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( FontFamilyList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FontFamilyList ) ) . mFontlist as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( FontFamilyList ) , "::" , stringify ! ( mFontlist ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FontFamilyList ) ) . mDefaultFontType as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( FontFamilyList ) , "::" , stringify ! ( mDefaultFontType ) ) ) ; } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleBasicShapeType { Polygon = 0 , Circle = 1 , Ellipse = 2 , Inset = 3 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleBoxAlign { Stretch = 0 , Start = 1 , Center = 2 , Baseline = 3 , End = 4 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleBoxDecorationBreak { Slice = 0 , Clone = 1 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleBoxDirection { Normal = 0 , Reverse = 1 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleBoxOrient { Horizontal = 0 , Vertical = 1 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleBoxPack { Start = 0 , Center = 1 , End = 2 , Justify = 3 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleBoxSizing { Content = 0 , Border = 1 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleClear { None = 0 , Left = 1 , Right = 2 , InlineStart = 3 , InlineEnd = 4 , Both = 5 , Line = 8 , Max = 13 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleGeometryBox { ContentBox = 0 , PaddingBox = 1 , BorderBox = 2 , MarginBox = 3 , FillBox = 4 , StrokeBox = 5 , ViewBox = 6 , NoClip = 7 , Text = 8 , NoBox = 9 , MozAlmostPadding = 127 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleFillRule { Nonzero = 0 , Evenodd = 1 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleFloat { None = 0 , Left = 1 , Right = 2 , InlineStart = 3 , InlineEnd = 4 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleFloatEdge { ContentBox = 0 , MarginBox = 1 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleHyphens { None = 0 , Manual = 1 , Auto = 2 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleShapeRadius { ClosestSide = 0 , FarthestSide = 1 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleShapeSourceType { None = 0 , URL = 1 , Image = 2 , Shape = 3 , Box = 4 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleStackSizing { Ignore = 0 , StretchToFit = 1 , IgnoreHorizontal = 2 , IgnoreVertical = 3 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleTextJustify { None = 0 , Auto = 1 , InterWord = 2 , InterCharacter = 3 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleUserFocus { None = 0 , Ignore = 1 , Normal = 2 , SelectAll = 3 , SelectBefore = 4 , SelectAfter = 5 , SelectSame = 6 , SelectMenu = 7 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleUserSelect { None = 0 , Text = 1 , Element = 2 , Elements = 3 , All = 4 , Toggle = 5 , TriState = 6 , Auto = 7 , MozAll = 8 , MozText = 9 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleUserInput { None = 0 , Enabled = 1 , Disabled = 2 , Auto = 3 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleUserModify { ReadOnly = 0 , ReadWrite = 1 , WriteOnly = 2 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleWindowDragging { Default = 0 , Drag = 1 , NoDrag = 2 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleOrient { Inline = 0 , Block = 1 , Horizontal = 2 , Vertical = 3 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleImageLayerRepeat { NoRepeat = 0 , RepeatX = 1 , RepeatY = 2 , Repeat = 3 , Space = 4 , Round = 5 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleBorderImageRepeat { Stretch = 0 , Repeat = 1 , Round = 2 , Space = 3 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleDisplay { None = 0 , Block = 1 , FlowRoot = 2 , Inline = 3 , InlineBlock = 4 , ListItem = 5 , Table = 6 , InlineTable = 7 , TableRowGroup = 8 , TableColumn = 9 , TableColumnGroup = 10 , TableHeaderGroup = 11 , TableFooterGroup = 12 , TableRow = 13 , TableCell = 14 , TableCaption = 15 , Flex = 16 , InlineFlex = 17 , Grid = 18 , InlineGrid = 19 , Ruby = 20 , RubyBase = 21 , RubyBaseContainer = 22 , RubyText = 23 , RubyTextContainer = 24 , Contents = 25 , WebkitBox = 26 , WebkitInlineBox = 27 , MozBox = 28 , MozInlineBox = 29 , MozGrid = 30 , MozInlineGrid = 31 , MozGridGroup = 32 , MozGridLine = 33 , MozStack = 34 , MozInlineStack = 35 , MozDeck = 36 , MozGroupbox = 37 , MozPopup = 38 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleGridTrackBreadth { MaxContent = 1 , MinContent = 2 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleWhiteSpace { Normal = 0 , Pre = 1 , Nowrap = 2 , PreWrap = 3 , PreLine = 4 , PreSpace = 5 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleOverscrollBehavior { Auto = 0 , Contain = 1 , None = 2 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SupportsWeakPtr { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct WeakPtr { pub _address : u8 , } pub type WeakPtr_WeakReference = u8 ; 
 /// Event messages 
 pub type EventMessageType = u16 ; pub const EventMessage_eVoidEvent : root :: mozilla :: EventMessage = 0 ; pub const EventMessage_eAllEvents : root :: mozilla :: EventMessage = 1 ; pub const EventMessage_eWindowClose : root :: mozilla :: EventMessage = 2 ; pub const EventMessage_eKeyPress : root :: mozilla :: EventMessage = 3 ; pub const EventMessage_eKeyUp : root :: mozilla :: EventMessage = 4 ; pub const EventMessage_eKeyDown : root :: mozilla :: EventMessage = 5 ; pub const EventMessage_eKeyDownOnPlugin : root :: mozilla :: EventMessage = 6 ; pub const EventMessage_eKeyUpOnPlugin : root :: mozilla :: EventMessage = 7 ; pub const EventMessage_eAccessKeyNotFound : root :: mozilla :: EventMessage = 8 ; pub const EventMessage_eResize : root :: mozilla :: EventMessage = 9 ; pub const EventMessage_eScroll : root :: mozilla :: EventMessage = 10 ; pub const EventMessage_eInstall : root :: mozilla :: EventMessage = 11 ; pub const EventMessage_eAppInstalled : root :: mozilla :: EventMessage = 12 ; pub const EventMessage_ePluginActivate : root :: mozilla :: EventMessage = 13 ; pub const EventMessage_ePluginFocus : root :: mozilla :: EventMessage = 14 ; pub const EventMessage_eOffline : root :: mozilla :: EventMessage = 15 ; pub const EventMessage_eOnline : root :: mozilla :: EventMessage = 16 ; pub const EventMessage_eLanguageChange : root :: mozilla :: EventMessage = 17 ; pub const EventMessage_eMouseMove : root :: mozilla :: EventMessage = 18 ; pub const EventMessage_eMouseUp : root :: mozilla :: EventMessage = 19 ; pub const EventMessage_eMouseDown : root :: mozilla :: EventMessage = 20 ; pub const EventMessage_eMouseEnterIntoWidget : root :: mozilla :: EventMessage = 21 ; pub const EventMessage_eMouseExitFromWidget : root :: mozilla :: EventMessage = 22 ; pub const EventMessage_eMouseDoubleClick : root :: mozilla :: EventMessage = 23 ; pub const EventMessage_eMouseClick : root :: mozilla :: EventMessage = 24 ; pub const EventMessage_eMouseAuxClick : root :: mozilla :: EventMessage = 25 ; pub const EventMessage_eMouseActivate : root :: mozilla :: EventMessage = 26 ; pub const EventMessage_eMouseOver : root :: mozilla :: EventMessage = 27 ; pub const EventMessage_eMouseOut : root :: mozilla :: EventMessage = 28 ; pub const EventMessage_eMouseHitTest : root :: mozilla :: EventMessage = 29 ; pub const EventMessage_eMouseEnter : root :: mozilla :: EventMessage = 30 ; pub const EventMessage_eMouseLeave : root :: mozilla :: EventMessage = 31 ; pub const EventMessage_eMouseTouchDrag : root :: mozilla :: EventMessage = 32 ; pub const EventMessage_eMouseLongTap : root :: mozilla :: EventMessage = 33 ; pub const EventMessage_eMouseEventFirst : root :: mozilla :: EventMessage = 18 ; pub const EventMessage_eMouseEventLast : root :: mozilla :: EventMessage = 33 ; pub const EventMessage_ePointerMove : root :: mozilla :: EventMessage = 34 ; pub const EventMessage_ePointerUp : root :: mozilla :: EventMessage = 35 ; pub const EventMessage_ePointerDown : root :: mozilla :: EventMessage = 36 ; pub const EventMessage_ePointerOver : root :: mozilla :: EventMessage = 37 ; pub const EventMessage_ePointerOut : root :: mozilla :: EventMessage = 38 ; pub const EventMessage_ePointerEnter : root :: mozilla :: EventMessage = 39 ; pub const EventMessage_ePointerLeave : root :: mozilla :: EventMessage = 40 ; pub const EventMessage_ePointerCancel : root :: mozilla :: EventMessage = 41 ; pub const EventMessage_ePointerGotCapture : root :: mozilla :: EventMessage = 42 ; pub const EventMessage_ePointerLostCapture : root :: mozilla :: EventMessage = 43 ; pub const EventMessage_ePointerEventFirst : root :: mozilla :: EventMessage = 34 ; pub const EventMessage_ePointerEventLast : root :: mozilla :: EventMessage = 43 ; pub const EventMessage_eContextMenu : root :: mozilla :: EventMessage = 44 ; pub const EventMessage_eLoad : root :: mozilla :: EventMessage = 45 ; pub const EventMessage_eUnload : root :: mozilla :: EventMessage = 46 ; pub const EventMessage_eHashChange : root :: mozilla :: EventMessage = 47 ; pub const EventMessage_eImageAbort : root :: mozilla :: EventMessage = 48 ; pub const EventMessage_eLoadError : root :: mozilla :: EventMessage = 49 ; pub const EventMessage_eLoadEnd : root :: mozilla :: EventMessage = 50 ; pub const EventMessage_ePopState : root :: mozilla :: EventMessage = 51 ; pub const EventMessage_eStorage : root :: mozilla :: EventMessage = 52 ; pub const EventMessage_eBeforeUnload : root :: mozilla :: EventMessage = 53 ; pub const EventMessage_eReadyStateChange : root :: mozilla :: EventMessage = 54 ; pub const EventMessage_eFormSubmit : root :: mozilla :: EventMessage = 55 ; pub const EventMessage_eFormReset : root :: mozilla :: EventMessage = 56 ; pub const EventMessage_eFormChange : root :: mozilla :: EventMessage = 57 ; pub const EventMessage_eFormSelect : root :: mozilla :: EventMessage = 58 ; pub const EventMessage_eFormInvalid : root :: mozilla :: EventMessage = 59 ; pub const EventMessage_eFormCheckboxStateChange : root :: mozilla :: EventMessage = 60 ; pub const EventMessage_eFormRadioStateChange : root :: mozilla :: EventMessage = 61 ; pub const EventMessage_eFocus : root :: mozilla :: EventMessage = 62 ; pub const EventMessage_eBlur : root :: mozilla :: EventMessage = 63 ; pub const EventMessage_eFocusIn : root :: mozilla :: EventMessage = 64 ; pub const EventMessage_eFocusOut : root :: mozilla :: EventMessage = 65 ; pub const EventMessage_eDragEnter : root :: mozilla :: EventMessage = 66 ; pub const EventMessage_eDragOver : root :: mozilla :: EventMessage = 67 ; pub const EventMessage_eDragExit : root :: mozilla :: EventMessage = 68 ; pub const EventMessage_eDrag : root :: mozilla :: EventMessage = 69 ; pub const EventMessage_eDragEnd : root :: mozilla :: EventMessage = 70 ; pub const EventMessage_eDragStart : root :: mozilla :: EventMessage = 71 ; pub const EventMessage_eDrop : root :: mozilla :: EventMessage = 72 ; pub const EventMessage_eDragLeave : root :: mozilla :: EventMessage = 73 ; pub const EventMessage_eDragDropEventFirst : root :: mozilla :: EventMessage = 66 ; pub const EventMessage_eDragDropEventLast : root :: mozilla :: EventMessage = 73 ; pub const EventMessage_eXULPopupShowing : root :: mozilla :: EventMessage = 74 ; pub const EventMessage_eXULPopupShown : root :: mozilla :: EventMessage = 75 ; pub const EventMessage_eXULPopupPositioned : root :: mozilla :: EventMessage = 76 ; pub const EventMessage_eXULPopupHiding : root :: mozilla :: EventMessage = 77 ; pub const EventMessage_eXULPopupHidden : root :: mozilla :: EventMessage = 78 ; pub const EventMessage_eXULBroadcast : root :: mozilla :: EventMessage = 79 ; pub const EventMessage_eXULCommandUpdate : root :: mozilla :: EventMessage = 80 ; pub const EventMessage_eLegacyMouseLineOrPageScroll : root :: mozilla :: EventMessage = 81 ; pub const EventMessage_eLegacyMousePixelScroll : root :: mozilla :: EventMessage = 82 ; pub const EventMessage_eScrollPortUnderflow : root :: mozilla :: EventMessage = 83 ; pub const EventMessage_eScrollPortOverflow : root :: mozilla :: EventMessage = 84 ; pub const EventMessage_eLegacySubtreeModified : root :: mozilla :: EventMessage = 85 ; pub const EventMessage_eLegacyNodeInserted : root :: mozilla :: EventMessage = 86 ; pub const EventMessage_eLegacyNodeRemoved : root :: mozilla :: EventMessage = 87 ; pub const EventMessage_eLegacyNodeRemovedFromDocument : root :: mozilla :: EventMessage = 88 ; pub const EventMessage_eLegacyNodeInsertedIntoDocument : root :: mozilla :: EventMessage = 89 ; pub const EventMessage_eLegacyAttrModified : root :: mozilla :: EventMessage = 90 ; pub const EventMessage_eLegacyCharacterDataModified : root :: mozilla :: EventMessage = 91 ; pub const EventMessage_eLegacyMutationEventFirst : root :: mozilla :: EventMessage = 85 ; pub const EventMessage_eLegacyMutationEventLast : root :: mozilla :: EventMessage = 91 ; pub const EventMessage_eUnidentifiedEvent : root :: mozilla :: EventMessage = 92 ; pub const EventMessage_eCompositionStart : root :: mozilla :: EventMessage = 93 ; pub const EventMessage_eCompositionEnd : root :: mozilla :: EventMessage = 94 ; pub const EventMessage_eCompositionUpdate : root :: mozilla :: EventMessage = 95 ; pub const EventMessage_eCompositionChange : root :: mozilla :: EventMessage = 96 ; pub const EventMessage_eCompositionCommitAsIs : root :: mozilla :: EventMessage = 97 ; pub const EventMessage_eCompositionCommit : root :: mozilla :: EventMessage = 98 ; pub const EventMessage_eCompositionCommitRequestHandled : root :: mozilla :: EventMessage = 99 ; pub const EventMessage_eLegacyDOMActivate : root :: mozilla :: EventMessage = 100 ; pub const EventMessage_eLegacyDOMFocusIn : root :: mozilla :: EventMessage = 101 ; pub const EventMessage_eLegacyDOMFocusOut : root :: mozilla :: EventMessage = 102 ; pub const EventMessage_ePageShow : root :: mozilla :: EventMessage = 103 ; pub const EventMessage_ePageHide : root :: mozilla :: EventMessage = 104 ; pub const EventMessage_eSVGLoad : root :: mozilla :: EventMessage = 105 ; pub const EventMessage_eSVGUnload : root :: mozilla :: EventMessage = 106 ; pub const EventMessage_eSVGResize : root :: mozilla :: EventMessage = 107 ; pub const EventMessage_eSVGScroll : root :: mozilla :: EventMessage = 108 ; pub const EventMessage_eSVGZoom : root :: mozilla :: EventMessage = 109 ; pub const EventMessage_eXULCommand : root :: mozilla :: EventMessage = 110 ; pub const EventMessage_eCopy : root :: mozilla :: EventMessage = 111 ; pub const EventMessage_eCut : root :: mozilla :: EventMessage = 112 ; pub const EventMessage_ePaste : root :: mozilla :: EventMessage = 113 ; pub const EventMessage_ePasteNoFormatting : root :: mozilla :: EventMessage = 114 ; pub const EventMessage_eQuerySelectedText : root :: mozilla :: EventMessage = 115 ; pub const EventMessage_eQueryTextContent : root :: mozilla :: EventMessage = 116 ; pub const EventMessage_eQueryCaretRect : root :: mozilla :: EventMessage = 117 ; pub const EventMessage_eQueryTextRect : root :: mozilla :: EventMessage = 118 ; pub const EventMessage_eQueryTextRectArray : root :: mozilla :: EventMessage = 119 ; pub const EventMessage_eQueryEditorRect : root :: mozilla :: EventMessage = 120 ; pub const EventMessage_eQueryContentState : root :: mozilla :: EventMessage = 121 ; pub const EventMessage_eQuerySelectionAsTransferable : root :: mozilla :: EventMessage = 122 ; pub const EventMessage_eQueryCharacterAtPoint : root :: mozilla :: EventMessage = 123 ; pub const EventMessage_eQueryDOMWidgetHittest : root :: mozilla :: EventMessage = 124 ; pub const EventMessage_eLoadStart : root :: mozilla :: EventMessage = 125 ; pub const EventMessage_eProgress : root :: mozilla :: EventMessage = 126 ; pub const EventMessage_eSuspend : root :: mozilla :: EventMessage = 127 ; pub const EventMessage_eEmptied : root :: mozilla :: EventMessage = 128 ; pub const EventMessage_eStalled : root :: mozilla :: EventMessage = 129 ; pub const EventMessage_ePlay : root :: mozilla :: EventMessage = 130 ; pub const EventMessage_ePause : root :: mozilla :: EventMessage = 131 ; pub const EventMessage_eLoadedMetaData : root :: mozilla :: EventMessage = 132 ; pub const EventMessage_eLoadedData : root :: mozilla :: EventMessage = 133 ; pub const EventMessage_eWaiting : root :: mozilla :: EventMessage = 134 ; pub const EventMessage_ePlaying : root :: mozilla :: EventMessage = 135 ; pub const EventMessage_eCanPlay : root :: mozilla :: EventMessage = 136 ; pub const EventMessage_eCanPlayThrough : root :: mozilla :: EventMessage = 137 ; pub const EventMessage_eSeeking : root :: mozilla :: EventMessage = 138 ; pub const EventMessage_eSeeked : root :: mozilla :: EventMessage = 139 ; pub const EventMessage_eTimeUpdate : root :: mozilla :: EventMessage = 140 ; pub const EventMessage_eEnded : root :: mozilla :: EventMessage = 141 ; pub const EventMessage_eRateChange : root :: mozilla :: EventMessage = 142 ; pub const EventMessage_eDurationChange : root :: mozilla :: EventMessage = 143 ; pub const EventMessage_eVolumeChange : root :: mozilla :: EventMessage = 144 ; pub const EventMessage_eAfterPaint : root :: mozilla :: EventMessage = 145 ; pub const EventMessage_eSwipeGestureMayStart : root :: mozilla :: EventMessage = 146 ; pub const EventMessage_eSwipeGestureStart : root :: mozilla :: EventMessage = 147 ; pub const EventMessage_eSwipeGestureUpdate : root :: mozilla :: EventMessage = 148 ; pub const EventMessage_eSwipeGestureEnd : root :: mozilla :: EventMessage = 149 ; pub const EventMessage_eSwipeGesture : root :: mozilla :: EventMessage = 150 ; pub const EventMessage_eMagnifyGestureStart : root :: mozilla :: EventMessage = 151 ; pub const EventMessage_eMagnifyGestureUpdate : root :: mozilla :: EventMessage = 152 ; pub const EventMessage_eMagnifyGesture : root :: mozilla :: EventMessage = 153 ; pub const EventMessage_eRotateGestureStart : root :: mozilla :: EventMessage = 154 ; pub const EventMessage_eRotateGestureUpdate : root :: mozilla :: EventMessage = 155 ; pub const EventMessage_eRotateGesture : root :: mozilla :: EventMessage = 156 ; pub const EventMessage_eTapGesture : root :: mozilla :: EventMessage = 157 ; pub const EventMessage_ePressTapGesture : root :: mozilla :: EventMessage = 158 ; pub const EventMessage_eEdgeUIStarted : root :: mozilla :: EventMessage = 159 ; pub const EventMessage_eEdgeUICanceled : root :: mozilla :: EventMessage = 160 ; pub const EventMessage_eEdgeUICompleted : root :: mozilla :: EventMessage = 161 ; pub const EventMessage_ePluginInputEvent : root :: mozilla :: EventMessage = 162 ; pub const EventMessage_eSetSelection : root :: mozilla :: EventMessage = 163 ; pub const EventMessage_eContentCommandCut : root :: mozilla :: EventMessage = 164 ; pub const EventMessage_eContentCommandCopy : root :: mozilla :: EventMessage = 165 ; pub const EventMessage_eContentCommandPaste : root :: mozilla :: EventMessage = 166 ; pub const EventMessage_eContentCommandDelete : root :: mozilla :: EventMessage = 167 ; pub const EventMessage_eContentCommandUndo : root :: mozilla :: EventMessage = 168 ; pub const EventMessage_eContentCommandRedo : root :: mozilla :: EventMessage = 169 ; pub const EventMessage_eContentCommandPasteTransferable : root :: mozilla :: EventMessage = 170 ; pub const EventMessage_eContentCommandLookUpDictionary : root :: mozilla :: EventMessage = 171 ; pub const EventMessage_eContentCommandScroll : root :: mozilla :: EventMessage = 172 ; pub const EventMessage_eGestureNotify : root :: mozilla :: EventMessage = 173 ; pub const EventMessage_eScrolledAreaChanged : root :: mozilla :: EventMessage = 174 ; pub const EventMessage_eTransitionStart : root :: mozilla :: EventMessage = 175 ; pub const EventMessage_eTransitionRun : root :: mozilla :: EventMessage = 176 ; pub const EventMessage_eTransitionEnd : root :: mozilla :: EventMessage = 177 ; pub const EventMessage_eTransitionCancel : root :: mozilla :: EventMessage = 178 ; pub const EventMessage_eAnimationStart : root :: mozilla :: EventMessage = 179 ; pub const EventMessage_eAnimationEnd : root :: mozilla :: EventMessage = 180 ; pub const EventMessage_eAnimationIteration : root :: mozilla :: EventMessage = 181 ; pub const EventMessage_eAnimationCancel : root :: mozilla :: EventMessage = 182 ; pub const EventMessage_eWebkitTransitionEnd : root :: mozilla :: EventMessage = 183 ; pub const EventMessage_eWebkitAnimationStart : root :: mozilla :: EventMessage = 184 ; pub const EventMessage_eWebkitAnimationEnd : root :: mozilla :: EventMessage = 185 ; pub const EventMessage_eWebkitAnimationIteration : root :: mozilla :: EventMessage = 186 ; pub const EventMessage_eSMILBeginEvent : root :: mozilla :: EventMessage = 187 ; pub const EventMessage_eSMILEndEvent : root :: mozilla :: EventMessage = 188 ; pub const EventMessage_eSMILRepeatEvent : root :: mozilla :: EventMessage = 189 ; pub const EventMessage_eAudioProcess : root :: mozilla :: EventMessage = 190 ; pub const EventMessage_eAudioComplete : root :: mozilla :: EventMessage = 191 ; pub const EventMessage_eBeforeScriptExecute : root :: mozilla :: EventMessage = 192 ; pub const EventMessage_eAfterScriptExecute : root :: mozilla :: EventMessage = 193 ; pub const EventMessage_eBeforePrint : root :: mozilla :: EventMessage = 194 ; pub const EventMessage_eAfterPrint : root :: mozilla :: EventMessage = 195 ; pub const EventMessage_eMessage : root :: mozilla :: EventMessage = 196 ; pub const EventMessage_eMessageError : root :: mozilla :: EventMessage = 197 ; pub const EventMessage_eOpen : root :: mozilla :: EventMessage = 198 ; pub const EventMessage_eDeviceOrientation : root :: mozilla :: EventMessage = 199 ; pub const EventMessage_eAbsoluteDeviceOrientation : root :: mozilla :: EventMessage = 200 ; pub const EventMessage_eDeviceMotion : root :: mozilla :: EventMessage = 201 ; pub const EventMessage_eDeviceProximity : root :: mozilla :: EventMessage = 202 ; pub const EventMessage_eUserProximity : root :: mozilla :: EventMessage = 203 ; pub const EventMessage_eDeviceLight : root :: mozilla :: EventMessage = 204 ; pub const EventMessage_eVRDisplayActivate : root :: mozilla :: EventMessage = 205 ; pub const EventMessage_eVRDisplayDeactivate : root :: mozilla :: EventMessage = 206 ; pub const EventMessage_eVRDisplayConnect : root :: mozilla :: EventMessage = 207 ; pub const EventMessage_eVRDisplayDisconnect : root :: mozilla :: EventMessage = 208 ; pub const EventMessage_eVRDisplayPresentChange : root :: mozilla :: EventMessage = 209 ; pub const EventMessage_eShow : root :: mozilla :: EventMessage = 210 ; pub const EventMessage_eFullscreenChange : root :: mozilla :: EventMessage = 211 ; pub const EventMessage_eFullscreenError : root :: mozilla :: EventMessage = 212 ; pub const EventMessage_eMozFullscreenChange : root :: mozilla :: EventMessage = 213 ; pub const EventMessage_eMozFullscreenError : root :: mozilla :: EventMessage = 214 ; pub const EventMessage_eTouchStart : root :: mozilla :: EventMessage = 215 ; pub const EventMessage_eTouchMove : root :: mozilla :: EventMessage = 216 ; pub const EventMessage_eTouchEnd : root :: mozilla :: EventMessage = 217 ; pub const EventMessage_eTouchCancel : root :: mozilla :: EventMessage = 218 ; pub const EventMessage_eTouchPointerCancel : root :: mozilla :: EventMessage = 219 ; pub const EventMessage_ePointerLockChange : root :: mozilla :: EventMessage = 220 ; pub const EventMessage_ePointerLockError : root :: mozilla :: EventMessage = 221 ; pub const EventMessage_eMozPointerLockChange : root :: mozilla :: EventMessage = 222 ; pub const EventMessage_eMozPointerLockError : root :: mozilla :: EventMessage = 223 ; pub const EventMessage_eWheel : root :: mozilla :: EventMessage = 224 ; pub const EventMessage_eWheelOperationStart : root :: mozilla :: EventMessage = 225 ; pub const EventMessage_eWheelOperationEnd : root :: mozilla :: EventMessage = 226 ; pub const EventMessage_eTimeChange : root :: mozilla :: EventMessage = 227 ; pub const EventMessage_eNetworkUpload : root :: mozilla :: EventMessage = 228 ; pub const EventMessage_eNetworkDownload : root :: mozilla :: EventMessage = 229 ; pub const EventMessage_eMediaRecorderDataAvailable : root :: mozilla :: EventMessage = 230 ; pub const EventMessage_eMediaRecorderWarning : root :: mozilla :: EventMessage = 231 ; pub const EventMessage_eMediaRecorderStop : root :: mozilla :: EventMessage = 232 ; pub const EventMessage_eGamepadButtonDown : root :: mozilla :: EventMessage = 233 ; pub const EventMessage_eGamepadButtonUp : root :: mozilla :: EventMessage = 234 ; pub const EventMessage_eGamepadAxisMove : root :: mozilla :: EventMessage = 235 ; pub const EventMessage_eGamepadConnected : root :: mozilla :: EventMessage = 236 ; pub const EventMessage_eGamepadDisconnected : root :: mozilla :: EventMessage = 237 ; pub const EventMessage_eGamepadEventFirst : root :: mozilla :: EventMessage = 233 ; pub const EventMessage_eGamepadEventLast : root :: mozilla :: EventMessage = 237 ; pub const EventMessage_eEditorInput : root :: mozilla :: EventMessage = 238 ; pub const EventMessage_eSelectStart : root :: mozilla :: EventMessage = 239 ; pub const EventMessage_eSelectionChange : root :: mozilla :: EventMessage = 240 ; pub const EventMessage_eVisibilityChange : root :: mozilla :: EventMessage = 241 ; pub const EventMessage_eToggle : root :: mozilla :: EventMessage = 242 ; pub const EventMessage_eClose : root :: mozilla :: EventMessage = 243 ; pub const EventMessage_eEventMessage_MaxValue : root :: mozilla :: EventMessage = 244 ; pub type EventMessage = root :: mozilla :: EventMessageType ; 
 /// Event class IDs 
 pub type EventClassIDType = u8 ; pub const EventClassID_eBasicEventClass : root :: mozilla :: EventClassID = 0 ; pub const EventClassID_eGUIEventClass : root :: mozilla :: EventClassID = 1 ; pub const EventClassID_eInputEventClass : root :: mozilla :: EventClassID = 2 ; pub const EventClassID_eUIEventClass : root :: mozilla :: EventClassID = 3 ; pub const EventClassID_eKeyboardEventClass : root :: mozilla :: EventClassID = 4 ; pub const EventClassID_eCompositionEventClass : root :: mozilla :: EventClassID = 5 ; pub const EventClassID_eQueryContentEventClass : root :: mozilla :: EventClassID = 6 ; pub const EventClassID_eSelectionEventClass : root :: mozilla :: EventClassID = 7 ; pub const EventClassID_eEditorInputEventClass : root :: mozilla :: EventClassID = 8 ; pub const EventClassID_eMouseEventBaseClass : root :: mozilla :: EventClassID = 9 ; pub const EventClassID_eMouseEventClass : root :: mozilla :: EventClassID = 10 ; pub const EventClassID_eDragEventClass : root :: mozilla :: EventClassID = 11 ; pub const EventClassID_eMouseScrollEventClass : root :: mozilla :: EventClassID = 12 ; pub const EventClassID_eWheelEventClass : root :: mozilla :: EventClassID = 13 ; pub const EventClassID_ePointerEventClass : root :: mozilla :: EventClassID = 14 ; pub const EventClassID_eGestureNotifyEventClass : root :: mozilla :: EventClassID = 15 ; pub const EventClassID_eSimpleGestureEventClass : root :: mozilla :: EventClassID = 16 ; pub const EventClassID_eTouchEventClass : root :: mozilla :: EventClassID = 17 ; pub const EventClassID_eScrollPortEventClass : root :: mozilla :: EventClassID = 18 ; pub const EventClassID_eScrollAreaEventClass : root :: mozilla :: EventClassID = 19 ; pub const EventClassID_eFormEventClass : root :: mozilla :: EventClassID = 20 ; pub const EventClassID_eClipboardEventClass : root :: mozilla :: EventClassID = 21 ; pub const EventClassID_eFocusEventClass : root :: mozilla :: EventClassID = 22 ; pub const EventClassID_eTransitionEventClass : root :: mozilla :: EventClassID = 23 ; pub const EventClassID_eAnimationEventClass : root :: mozilla :: EventClassID = 24 ; pub const EventClassID_eSMILTimeEventClass : root :: mozilla :: EventClassID = 25 ; pub const EventClassID_eCommandEventClass : root :: mozilla :: EventClassID = 26 ; pub const EventClassID_eContentCommandEventClass : root :: mozilla :: EventClassID = 27 ; pub const EventClassID_ePluginEventClass : root :: mozilla :: EventClassID = 28 ; pub const EventClassID_eMutationEventClass : root :: mozilla :: EventClassID = 29 ; pub type EventClassID = root :: mozilla :: EventClassIDType ; pub type AtomArray = root :: nsTArray < root :: RefPtr < root :: nsAtom > > ; 
 /// EventStates is the class used to represent the event states of nsIContent
        /// instances. These states are calculated by IntrinsicState() and
        /// ContentStatesChanged() has to be called when one of them changes thus
        /// informing the layout/style engine of the change.
        /// Event states are associated with pseudo-classes. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct EventStates { pub mStates : root :: mozilla :: EventStates_InternalType , } pub type EventStates_InternalType = u64 ; pub type EventStates_ServoType = u64 ; # [ test ] fn bindgen_test_layout_EventStates ( ) { assert_eq ! ( :: std :: mem :: size_of :: < EventStates > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( EventStates ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < EventStates > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( EventStates ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const EventStates ) ) . mStates as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( EventStates ) , "::" , stringify ! ( mStates ) ) ) ; } impl Clone for EventStates { fn clone ( & self ) -> Self { * self } } pub const ServoTraversalFlags_Empty : root :: mozilla :: ServoTraversalFlags = 0 ; pub const ServoTraversalFlags_AnimationOnly : root :: mozilla :: ServoTraversalFlags = 1 ; pub const ServoTraversalFlags_ForCSSRuleChanges : root :: mozilla :: ServoTraversalFlags = 2 ; pub const ServoTraversalFlags_Forgetful : root :: mozilla :: ServoTraversalFlags = 8 ; pub const ServoTraversalFlags_ClearDirtyBits : root :: mozilla :: ServoTraversalFlags = 32 ; pub const ServoTraversalFlags_ClearAnimationOnlyDirtyDescendants : root :: mozilla :: ServoTraversalFlags = 64 ; pub const ServoTraversalFlags_ParallelTraversal : root :: mozilla :: ServoTraversalFlags = 128 ; pub const ServoTraversalFlags_FlushThrottledAnimations : root :: mozilla :: ServoTraversalFlags = 256 ; pub type ServoTraversalFlags = u32 ; # [ repr ( i32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum StyleRuleInclusion { All = 0 , DefaultOnly = 1 , } pub const UpdateAnimationsTasks_CSSAnimations : root :: mozilla :: UpdateAnimationsTasks = 1 ; pub const UpdateAnimationsTasks_CSSTransitions : root :: mozilla :: UpdateAnimationsTasks = 2 ; pub const UpdateAnimationsTasks_EffectProperties : root :: mozilla :: UpdateAnimationsTasks = 4 ; pub const UpdateAnimationsTasks_CascadeResults : root :: mozilla :: UpdateAnimationsTasks = 8 ; pub type UpdateAnimationsTasks = u8 ; pub const ParsingMode_Default : root :: mozilla :: ParsingMode = 0 ; pub const ParsingMode_AllowUnitlessLength : root :: mozilla :: ParsingMode = 1 ; pub const ParsingMode_AllowAllNumericValues : root :: mozilla :: ParsingMode = 2 ; pub type ParsingMode = u8 ; # [ repr ( i32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum InheritTarget { Text = 0 , FirstLetterContinuation = 1 , PlaceholderFrame = 2 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct ServoStyleSetSizes { pub mRuleTree : usize , pub mPrecomputedPseudos : usize , pub mElementAndPseudosMaps : usize , pub mInvalidationMap : usize , pub mRevalidationSelectors : usize , pub mOther : usize , } # [ test ] fn bindgen_test_layout_ServoStyleSetSizes ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ServoStyleSetSizes > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( ServoStyleSetSizes ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ServoStyleSetSizes > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ServoStyleSetSizes ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSetSizes ) ) . mRuleTree as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSetSizes ) , "::" , stringify ! ( mRuleTree ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSetSizes ) ) . mPrecomputedPseudos as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSetSizes ) , "::" , stringify ! ( mPrecomputedPseudos ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSetSizes ) ) . mElementAndPseudosMaps as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSetSizes ) , "::" , stringify ! ( mElementAndPseudosMaps ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSetSizes ) ) . mInvalidationMap as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSetSizes ) , "::" , stringify ! ( mInvalidationMap ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSetSizes ) ) . mRevalidationSelectors as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSetSizes ) , "::" , stringify ! ( mRevalidationSelectors ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSetSizes ) ) . mOther as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSetSizes ) , "::" , stringify ! ( mOther ) ) ) ; } impl Clone for ServoStyleSetSizes { fn clone ( & self ) -> Self { * self } } pub const StyleBackendType_None : root :: mozilla :: StyleBackendType = 0 ; pub const StyleBackendType_Gecko : root :: mozilla :: StyleBackendType = 1 ; pub const StyleBackendType_Servo : root :: mozilla :: StyleBackendType = 2 ; pub type StyleBackendType = u8 ; pub type TimeStampValue = u64 ; 
 /// Instances of this class represent the length of an interval of time.
        /// Negative durations are allowed, meaning the end is before the start.
        ///
        /// Internally the duration is stored as a int64_t in units of
        /// PR_TicksPerSecond() when building with NSPR interval timers, or a
        /// system-dependent unit when building with system clocks.  The
        /// system-dependent unit must be constant, otherwise the semantics of
        /// this class would be broken.
        ///
        /// The ValueCalculator template parameter determines how arithmetic
        /// operations are performed on the integer count of ticks (mValue). 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct BaseTimeDuration { pub mValue : i64 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct BaseTimeDuration__SomethingVeryRandomHere { pub _address : u8 , } 
 /// Perform arithmetic operations on the value of a BaseTimeDuration without
        /// doing strict checks on the range of values. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct TimeDurationValueCalculator { pub _address : u8 , } # [ test ] fn bindgen_test_layout_TimeDurationValueCalculator ( ) { assert_eq ! ( :: std :: mem :: size_of :: < TimeDurationValueCalculator > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( TimeDurationValueCalculator ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < TimeDurationValueCalculator > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( TimeDurationValueCalculator ) ) ) ; } impl Clone for TimeDurationValueCalculator { fn clone ( & self ) -> Self { * self } } 
 /// Specialization of BaseTimeDuration that uses TimeDurationValueCalculator for
        /// arithmetic on the mValue member.
        ///
        /// Use this class for time durations that are *not* expected to hold values of
        /// Forever (or the negative equivalent) or when such time duration are *not*
        /// expected to be used in arithmetic operations. 
 pub type TimeDuration = root :: mozilla :: BaseTimeDuration ; 
 /// Instances of this class represent moments in time, or a special
        /// "null" moment. We do not use the non-monotonic system clock or
        /// local time, since they can be reset, causing apparent backward
        /// travel in time, which can confuse algorithms. Instead we measure
        /// elapsed time according to the system.  This time can never go
        /// backwards (i.e. it never wraps around, at least not in less than
        /// five million years of system elapsed time). It might not advance
        /// while the system is sleeping. If TimeStamp::SetNow() is not called
        /// at all for hours or days, we might not notice the passage of some
        /// of that time.
        ///
        /// We deliberately do not expose a way to convert TimeStamps to some
        /// particular unit. All you can do is compute a difference between two
        /// TimeStamps to get a TimeDuration. You can also add a TimeDuration
        /// to a TimeStamp to get a new TimeStamp. You can't do something
        /// meaningless like add two TimeStamps.
        ///
        /// Internally this is implemented as either a wrapper around
        /// - high-resolution, monotonic, system clocks if they exist on this
        /// platform
        /// - PRIntervalTime otherwise.  We detect wraparounds of
        /// PRIntervalTime and work around them.
        ///
        /// This class is similar to C++11's time_point, however it is
        /// explicitly nullable and provides an IsNull() method. time_point
        /// is initialized to the clock's epoch and provides a
        /// time_since_epoch() method that functions similiarly. i.e.
        /// t.IsNull() is equivalent to t.time_since_epoch() == decltype(t)::duration::zero(); 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct TimeStamp { 
 /// When built with PRIntervalTime, a value of 0 means this instance
            /// is "null". Otherwise, the low 32 bits represent a PRIntervalTime,
            /// and the high 32 bits represent a counter of the number of
            /// rollovers of PRIntervalTime that we've seen. This counter starts
            /// at 1 to avoid a real time colliding with the "null" value.
            ///
            /// PR_INTERVAL_MAX is set at 100,000 ticks per second. So the minimum
            /// time to wrap around is about 2^64/100000 seconds, i.e. about
            /// 5,849,424 years.
            ///
            /// When using a system clock, a value is system dependent. 
 pub mValue : root :: mozilla :: TimeStampValue , } # [ test ] fn bindgen_test_layout_TimeStamp ( ) { assert_eq ! ( :: std :: mem :: size_of :: < TimeStamp > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( TimeStamp ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < TimeStamp > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( TimeStamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const TimeStamp ) ) . mValue as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( TimeStamp ) , "::" , stringify ! ( mValue ) ) ) ; } impl Clone for TimeStamp { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct MallocAllocPolicy { pub _address : u8 , } # [ test ] fn bindgen_test_layout_MallocAllocPolicy ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MallocAllocPolicy > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( MallocAllocPolicy ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MallocAllocPolicy > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( MallocAllocPolicy ) ) ) ; } impl Clone for MallocAllocPolicy { fn clone ( & self ) -> Self { * self } } pub type Vector_Impl = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Vector_CapacityAndReserved { pub mCapacity : usize , } pub type Vector_ElementType < T > = T ; pub const Vector_InlineLength : root :: mozilla :: Vector__bindgen_ty_1 = 0 ; pub type Vector__bindgen_ty_1 = i32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Vector_Range < T > { pub mCur : * mut T , pub mEnd : * mut T , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Vector_ConstRange < T > { pub mCur : * mut T , pub mEnd : * mut T , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , } pub mod binding_danger { # [ allow ( unused_imports ) ] use self :: super :: super :: super :: root ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AssertAndSuppressCleanupPolicy { pub _address : u8 , } pub const AssertAndSuppressCleanupPolicy_assertHandled : bool = true ; pub const AssertAndSuppressCleanupPolicy_suppress : bool = true ; # [ test ] fn bindgen_test_layout_AssertAndSuppressCleanupPolicy ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AssertAndSuppressCleanupPolicy > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( AssertAndSuppressCleanupPolicy ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AssertAndSuppressCleanupPolicy > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( AssertAndSuppressCleanupPolicy ) ) ) ; } impl Clone for AssertAndSuppressCleanupPolicy { fn clone ( & self ) -> Self { * self } } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct OwningNonNull < T > { pub mPtr : root :: RefPtr < T > , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , } pub mod net { # [ allow ( unused_imports ) ] use self :: super :: super :: super :: root ; pub const ReferrerPolicy_RP_No_Referrer : root :: mozilla :: net :: ReferrerPolicy = 2 ; pub const ReferrerPolicy_RP_Origin : root :: mozilla :: net :: ReferrerPolicy = 3 ; pub const ReferrerPolicy_RP_No_Referrer_When_Downgrade : root :: mozilla :: net :: ReferrerPolicy = 1 ; pub const ReferrerPolicy_RP_Origin_When_Crossorigin : root :: mozilla :: net :: ReferrerPolicy = 4 ; pub const ReferrerPolicy_RP_Unsafe_URL : root :: mozilla :: net :: ReferrerPolicy = 5 ; pub const ReferrerPolicy_RP_Same_Origin : root :: mozilla :: net :: ReferrerPolicy = 6 ; pub const ReferrerPolicy_RP_Strict_Origin : root :: mozilla :: net :: ReferrerPolicy = 7 ; pub const ReferrerPolicy_RP_Strict_Origin_When_Cross_Origin : root :: mozilla :: net :: ReferrerPolicy = 8 ; pub const ReferrerPolicy_RP_Unset : root :: mozilla :: net :: ReferrerPolicy = 0 ; pub type ReferrerPolicy = :: std :: os :: raw :: c_uint ; } pub const CORSMode_CORS_NONE : root :: mozilla :: CORSMode = 0 ; pub const CORSMode_CORS_ANONYMOUS : root :: mozilla :: CORSMode = 1 ; pub const CORSMode_CORS_USE_CREDENTIALS : root :: mozilla :: CORSMode = 2 ; pub type CORSMode = u8 ; 
 /// Superclass for data common to CSSStyleSheet and ServoStyleSheet. 
 # [ repr ( C ) ] pub struct StyleSheet { pub _base : root :: nsIDOMCSSStyleSheet , pub _base_1 : root :: nsICSSLoaderObserver , pub _base_2 : root :: nsWrapperCache , pub mRefCnt : root :: nsCycleCollectingAutoRefCnt , pub mParent : * mut root :: mozilla :: StyleSheet , pub mTitle : ::nsstring::nsStringRepr , pub mDocument : * mut root :: nsIDocument , pub mOwningNode : * mut root :: nsINode , pub mOwnerRule : * mut root :: mozilla :: dom :: CSSImportRule , pub mMedia : root :: RefPtr < root :: mozilla :: dom :: MediaList > , pub mNext : root :: RefPtr < root :: mozilla :: StyleSheet > , pub mParsingMode : root :: mozilla :: css :: SheetParsingMode , pub mType : root :: mozilla :: StyleBackendType , pub mDisabled : bool , pub mDirty : bool , pub mDocumentAssociationMode : root :: mozilla :: StyleSheet_DocumentAssociationMode , pub mInner : * mut root :: mozilla :: StyleSheetInfo , pub mStyleSets : root :: nsTArray < root :: mozilla :: StyleSetHandle > , } pub type StyleSheet_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct StyleSheet_cycleCollection { pub _base : root :: nsXPCOMCycleCollectionParticipant , } # [ test ] fn bindgen_test_layout_StyleSheet_cycleCollection ( ) { assert_eq ! ( :: std :: mem :: size_of :: < StyleSheet_cycleCollection > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( StyleSheet_cycleCollection ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < StyleSheet_cycleCollection > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( StyleSheet_cycleCollection ) ) ) ; } impl Clone for StyleSheet_cycleCollection { fn clone ( & self ) -> Self { * self } } pub const StyleSheet_ChangeType_Added : root :: mozilla :: StyleSheet_ChangeType = 0 ; pub const StyleSheet_ChangeType_Removed : root :: mozilla :: StyleSheet_ChangeType = 1 ; pub const StyleSheet_ChangeType_ApplicableStateChanged : root :: mozilla :: StyleSheet_ChangeType = 2 ; pub const StyleSheet_ChangeType_RuleAdded : root :: mozilla :: StyleSheet_ChangeType = 3 ; pub const StyleSheet_ChangeType_RuleRemoved : root :: mozilla :: StyleSheet_ChangeType = 4 ; pub const StyleSheet_ChangeType_RuleChanged : root :: mozilla :: StyleSheet_ChangeType = 5 ; pub type StyleSheet_ChangeType = :: std :: os :: raw :: c_int ; pub const StyleSheet_DocumentAssociationMode_OwnedByDocument : root :: mozilla :: StyleSheet_DocumentAssociationMode = 0 ; pub const StyleSheet_DocumentAssociationMode_NotOwnedByDocument : root :: mozilla :: StyleSheet_DocumentAssociationMode = 1 ; pub type StyleSheet_DocumentAssociationMode = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct StyleSheet_ChildSheetListBuilder { pub sheetSlot : * mut root :: RefPtr < root :: mozilla :: StyleSheet > , pub parent : * mut root :: mozilla :: StyleSheet , } # [ test ] fn bindgen_test_layout_StyleSheet_ChildSheetListBuilder ( ) { assert_eq ! ( :: std :: mem :: size_of :: < StyleSheet_ChildSheetListBuilder > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( StyleSheet_ChildSheetListBuilder ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < StyleSheet_ChildSheetListBuilder > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( StyleSheet_ChildSheetListBuilder ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleSheet_ChildSheetListBuilder ) ) . sheetSlot as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( StyleSheet_ChildSheetListBuilder ) , "::" , stringify ! ( sheetSlot ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleSheet_ChildSheetListBuilder ) ) . parent as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( StyleSheet_ChildSheetListBuilder ) , "::" , stringify ! ( parent ) ) ) ; } impl Clone for StyleSheet_ChildSheetListBuilder { fn clone ( & self ) -> Self { * self } } extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla10StyleSheet21_cycleCollectorGlobalE" ] 
 pub static mut  StyleSheet__cycleCollectorGlobal  :  root :: mozilla :: StyleSheet_cycleCollection ;
} # [ test ] fn bindgen_test_layout_StyleSheet ( ) { assert_eq ! ( :: std :: mem :: size_of :: < StyleSheet > ( ) , 136usize , concat ! ( "Size of: " , stringify ! ( StyleSheet ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < StyleSheet > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( StyleSheet ) ) ) ; } pub const CSSEnabledState_eForAllContent : root :: mozilla :: CSSEnabledState = 0 ; pub const CSSEnabledState_eInUASheets : root :: mozilla :: CSSEnabledState = 1 ; pub const CSSEnabledState_eInChrome : root :: mozilla :: CSSEnabledState = 2 ; pub const CSSEnabledState_eIgnoreEnabledState : root :: mozilla :: CSSEnabledState = 255 ; pub type CSSEnabledState = :: std :: os :: raw :: c_int ; pub type CSSPseudoElementTypeBase = u8 ; pub const CSSPseudoElementType_InheritingAnonBox : root :: mozilla :: CSSPseudoElementType = CSSPseudoElementType :: Count ; # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum CSSPseudoElementType { after = 0 , before = 1 , backdrop = 2 , cue = 3 , firstLetter = 4 , firstLine = 5 , mozSelection = 6 , mozFocusInner = 7 , mozFocusOuter = 8 , mozListBullet = 9 , mozListNumber = 10 , mozMathAnonymous = 11 , mozNumberWrapper = 12 , mozNumberText = 13 , mozNumberSpinBox = 14 , mozNumberSpinUp = 15 , mozNumberSpinDown = 16 , mozProgressBar = 17 , mozRangeTrack = 18 , mozRangeProgress = 19 , mozRangeThumb = 20 , mozMeterBar = 21 , mozPlaceholder = 22 , placeholder = 23 , mozColorSwatch = 24 , Count = 25 , NonInheritingAnonBox = 26 , XULTree = 27 , NotPseudo = 28 , MAX = 29 , } 
 /// Smart pointer class that can hold a pointer to either an nsStyleSet
        /// or a ServoStyleSet. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct StyleSetHandle { pub mPtr : root :: mozilla :: StyleSetHandle_Ptr , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct StyleSetHandle_Ptr { pub mValue : usize , } # [ test ] fn bindgen_test_layout_StyleSetHandle_Ptr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < StyleSetHandle_Ptr > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( StyleSetHandle_Ptr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < StyleSetHandle_Ptr > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( StyleSetHandle_Ptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleSetHandle_Ptr ) ) . mValue as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( StyleSetHandle_Ptr ) , "::" , stringify ! ( mValue ) ) ) ; } impl Clone for StyleSetHandle_Ptr { fn clone ( & self ) -> Self { * self } } # [ test ] fn bindgen_test_layout_StyleSetHandle ( ) { assert_eq ! ( :: std :: mem :: size_of :: < StyleSetHandle > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( StyleSetHandle ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < StyleSetHandle > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( StyleSetHandle ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleSetHandle ) ) . mPtr as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( StyleSetHandle ) , "::" , stringify ! ( mPtr ) ) ) ; } impl Clone for StyleSetHandle { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct SeenPtrs { pub _bindgen_opaque_blob : [ u64 ; 4usize ] , } # [ test ] fn bindgen_test_layout_SeenPtrs ( ) { assert_eq ! ( :: std :: mem :: size_of :: < SeenPtrs > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( SeenPtrs ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < SeenPtrs > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SeenPtrs ) ) ) ; } impl Clone for SeenPtrs { fn clone ( & self ) -> Self { * self } } pub mod widget { # [ allow ( unused_imports ) ] use self :: super :: super :: super :: root ; 
 /// Contains IMEStatus plus information about the current
            /// input context that the IME can use as hints if desired. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct IMEState { pub mEnabled : root :: mozilla :: widget :: IMEState_Enabled , pub mOpen : root :: mozilla :: widget :: IMEState_Open , } pub const IMEState_Enabled_DISABLED : root :: mozilla :: widget :: IMEState_Enabled = 0 ; pub const IMEState_Enabled_ENABLED : root :: mozilla :: widget :: IMEState_Enabled = 1 ; pub const IMEState_Enabled_PASSWORD : root :: mozilla :: widget :: IMEState_Enabled = 2 ; pub const IMEState_Enabled_PLUGIN : root :: mozilla :: widget :: IMEState_Enabled = 3 ; pub const IMEState_Enabled_UNKNOWN : root :: mozilla :: widget :: IMEState_Enabled = 4 ; pub type IMEState_Enabled = :: std :: os :: raw :: c_uint ; pub const IMEState_Open_OPEN_STATE_NOT_SUPPORTED : root :: mozilla :: widget :: IMEState_Open = 0 ; pub const IMEState_Open_DONT_CHANGE_OPEN_STATE : root :: mozilla :: widget :: IMEState_Open = 0 ; pub const IMEState_Open_OPEN : root :: mozilla :: widget :: IMEState_Open = 1 ; pub const IMEState_Open_CLOSED : root :: mozilla :: widget :: IMEState_Open = 2 ; pub type IMEState_Open = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_IMEState ( ) { assert_eq ! ( :: std :: mem :: size_of :: < IMEState > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( IMEState ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < IMEState > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( IMEState ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const IMEState ) ) . mEnabled as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( IMEState ) , "::" , stringify ! ( mEnabled ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const IMEState ) ) . mOpen as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( IMEState ) , "::" , stringify ! ( mOpen ) ) ) ; } impl Clone for IMEState { fn clone ( & self ) -> Self { * self } } } 
 /// This class is designed to cause crashes when various kinds of memory
        /// corruption are observed. For instance, let's say we have a class C where we
        /// suspect out-of-bounds writes to some members.  We can insert a member of type
        /// Poison near the members we suspect are being corrupted by out-of-bounds
        /// writes.  Or perhaps we have a class K we suspect is subject to use-after-free
        /// violations, in which case it doesn't particularly matter where in the class
        /// we add the member of type Poison.
        ///
        /// In either case, we then insert calls to Check() throughout the code.  Doing
        /// so enables us to narrow down the location where the corruption is occurring.
        /// A pleasant side-effect of these additional Check() calls is that crash
        /// signatures may become more regular, as crashes will ideally occur
        /// consolidated at the point of a Check(), rather than scattered about at
        /// various uses of the corrupted memory. 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct CorruptionCanary { pub mValue : usize , } pub const CorruptionCanary_kCanarySet : usize = 252382987 ; # [ test ] fn bindgen_test_layout_CorruptionCanary ( ) { assert_eq ! ( :: std :: mem :: size_of :: < CorruptionCanary > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( CorruptionCanary ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < CorruptionCanary > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( CorruptionCanary ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CorruptionCanary ) ) . mValue as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( CorruptionCanary ) , "::" , stringify ! ( mValue ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct ArenaAllocator_ArenaHeader { 
 /// The location in memory of the data portion of the arena. 
 pub offset : usize , 
 /// The location in memory of the end of the data portion of the arena. 
 pub tail : usize , } impl Clone for ArenaAllocator_ArenaHeader { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct ArenaAllocator_ArenaChunk { pub canary : root :: mozilla :: CorruptionCanary , pub header : root :: mozilla :: ArenaAllocator_ArenaHeader , pub next : * mut root :: mozilla :: ArenaAllocator_ArenaChunk , } pub type LayoutDeviceIntPoint = [ u32 ; 2usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct LayoutDevicePixel { pub _address : u8 , } # [ test ] fn bindgen_test_layout_LayoutDevicePixel ( ) { assert_eq ! ( :: std :: mem :: size_of :: < LayoutDevicePixel > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( LayoutDevicePixel ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < LayoutDevicePixel > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( LayoutDevicePixel ) ) ) ; } impl Clone for LayoutDevicePixel { fn clone ( & self ) -> Self { * self } } pub mod a11y { # [ allow ( unused_imports ) ] use self :: super :: super :: super :: root ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct DocAccessible { _unused : [ u8 ; 0 ] } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Encoding { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct Runnable { pub _base : root :: nsIRunnable , pub _base_1 : root :: nsINamed , pub mRefCnt : root :: mozilla :: ThreadSafeAutoRefCnt , pub mName : * const :: std :: os :: raw :: c_char , } pub type Runnable_HasThreadSafeRefCnt = root :: mozilla :: TrueType ; # [ test ] fn bindgen_test_layout_Runnable ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Runnable > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( Runnable ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Runnable > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Runnable ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SegmentedVector_SegmentImpl_Storage { pub mBuf : root :: __BindgenUnionField < * mut :: std :: os :: raw :: c_char > , pub mAlign : root :: __BindgenUnionField < u8 > , pub bindgen_union_field : u64 , } pub type SegmentedVector_Segment = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SegmentedVector_IterImpl { pub mSegment : * mut root :: mozilla :: SegmentedVector_Segment , pub mIndex : usize , } pub const UseCounter_eUseCounter_UNKNOWN : root :: mozilla :: UseCounter = -1 ; pub const UseCounter_eUseCounter_SVGSVGElement_getElementById : root :: mozilla :: UseCounter = 0 ; pub const UseCounter_eUseCounter_SVGSVGElement_currentScale_getter : root :: mozilla :: UseCounter = 1 ; pub const UseCounter_eUseCounter_SVGSVGElement_currentScale_setter : root :: mozilla :: UseCounter = 2 ; pub const UseCounter_eUseCounter_property_Fill : root :: mozilla :: UseCounter = 3 ; pub const UseCounter_eUseCounter_property_FillOpacity : root :: mozilla :: UseCounter = 4 ; pub const UseCounter_eUseCounter_XMLDocument_async_getter : root :: mozilla :: UseCounter = 5 ; pub const UseCounter_eUseCounter_XMLDocument_async_setter : root :: mozilla :: UseCounter = 6 ; pub const UseCounter_eUseCounter_DOMError_name_getter : root :: mozilla :: UseCounter = 7 ; pub const UseCounter_eUseCounter_DOMError_name_setter : root :: mozilla :: UseCounter = 8 ; pub const UseCounter_eUseCounter_DOMError_message_getter : root :: mozilla :: UseCounter = 9 ; pub const UseCounter_eUseCounter_DOMError_message_setter : root :: mozilla :: UseCounter = 10 ; pub const UseCounter_eUseCounter_custom_DOMErrorConstructor : root :: mozilla :: UseCounter = 11 ; pub const UseCounter_eUseCounter_PushManager_subscribe : root :: mozilla :: UseCounter = 12 ; pub const UseCounter_eUseCounter_PushSubscription_unsubscribe : root :: mozilla :: UseCounter = 13 ; pub const UseCounter_eUseCounter_Window_sidebar_getter : root :: mozilla :: UseCounter = 14 ; pub const UseCounter_eUseCounter_Window_sidebar_setter : root :: mozilla :: UseCounter = 15 ; pub const UseCounter_eUseCounter_External_addSearchEngine : root :: mozilla :: UseCounter = 16 ; pub const UseCounter_eUseCounter_OfflineResourceList_swapCache : root :: mozilla :: UseCounter = 17 ; pub const UseCounter_eUseCounter_OfflineResourceList_update : root :: mozilla :: UseCounter = 18 ; pub const UseCounter_eUseCounter_OfflineResourceList_status_getter : root :: mozilla :: UseCounter = 19 ; pub const UseCounter_eUseCounter_OfflineResourceList_status_setter : root :: mozilla :: UseCounter = 20 ; pub const UseCounter_eUseCounter_OfflineResourceList_onchecking_getter : root :: mozilla :: UseCounter = 21 ; pub const UseCounter_eUseCounter_OfflineResourceList_onchecking_setter : root :: mozilla :: UseCounter = 22 ; pub const UseCounter_eUseCounter_OfflineResourceList_onerror_getter : root :: mozilla :: UseCounter = 23 ; pub const UseCounter_eUseCounter_OfflineResourceList_onerror_setter : root :: mozilla :: UseCounter = 24 ; pub const UseCounter_eUseCounter_OfflineResourceList_onnoupdate_getter : root :: mozilla :: UseCounter = 25 ; pub const UseCounter_eUseCounter_OfflineResourceList_onnoupdate_setter : root :: mozilla :: UseCounter = 26 ; pub const UseCounter_eUseCounter_OfflineResourceList_ondownloading_getter : root :: mozilla :: UseCounter = 27 ; pub const UseCounter_eUseCounter_OfflineResourceList_ondownloading_setter : root :: mozilla :: UseCounter = 28 ; pub const UseCounter_eUseCounter_OfflineResourceList_onprogress_getter : root :: mozilla :: UseCounter = 29 ; pub const UseCounter_eUseCounter_OfflineResourceList_onprogress_setter : root :: mozilla :: UseCounter = 30 ; pub const UseCounter_eUseCounter_OfflineResourceList_onupdateready_getter : root :: mozilla :: UseCounter = 31 ; pub const UseCounter_eUseCounter_OfflineResourceList_onupdateready_setter : root :: mozilla :: UseCounter = 32 ; pub const UseCounter_eUseCounter_OfflineResourceList_oncached_getter : root :: mozilla :: UseCounter = 33 ; pub const UseCounter_eUseCounter_OfflineResourceList_oncached_setter : root :: mozilla :: UseCounter = 34 ; pub const UseCounter_eUseCounter_OfflineResourceList_onobsolete_getter : root :: mozilla :: UseCounter = 35 ; pub const UseCounter_eUseCounter_OfflineResourceList_onobsolete_setter : root :: mozilla :: UseCounter = 36 ; pub const UseCounter_eUseCounter_IDBDatabase_createMutableFile : root :: mozilla :: UseCounter = 37 ; pub const UseCounter_eUseCounter_IDBDatabase_mozCreateFileHandle : root :: mozilla :: UseCounter = 38 ; pub const UseCounter_eUseCounter_IDBMutableFile_open : root :: mozilla :: UseCounter = 39 ; pub const UseCounter_eUseCounter_IDBMutableFile_getFile : root :: mozilla :: UseCounter = 40 ; pub const UseCounter_eUseCounter_DataTransfer_addElement : root :: mozilla :: UseCounter = 41 ; pub const UseCounter_eUseCounter_DataTransfer_mozItemCount_getter : root :: mozilla :: UseCounter = 42 ; pub const UseCounter_eUseCounter_DataTransfer_mozItemCount_setter : root :: mozilla :: UseCounter = 43 ; pub const UseCounter_eUseCounter_DataTransfer_mozCursor_getter : root :: mozilla :: UseCounter = 44 ; pub const UseCounter_eUseCounter_DataTransfer_mozCursor_setter : root :: mozilla :: UseCounter = 45 ; pub const UseCounter_eUseCounter_DataTransfer_mozTypesAt : root :: mozilla :: UseCounter = 46 ; pub const UseCounter_eUseCounter_DataTransfer_mozClearDataAt : root :: mozilla :: UseCounter = 47 ; pub const UseCounter_eUseCounter_DataTransfer_mozSetDataAt : root :: mozilla :: UseCounter = 48 ; pub const UseCounter_eUseCounter_DataTransfer_mozGetDataAt : root :: mozilla :: UseCounter = 49 ; pub const UseCounter_eUseCounter_DataTransfer_mozUserCancelled_getter : root :: mozilla :: UseCounter = 50 ; pub const UseCounter_eUseCounter_DataTransfer_mozUserCancelled_setter : root :: mozilla :: UseCounter = 51 ; pub const UseCounter_eUseCounter_DataTransfer_mozSourceNode_getter : root :: mozilla :: UseCounter = 52 ; pub const UseCounter_eUseCounter_DataTransfer_mozSourceNode_setter : root :: mozilla :: UseCounter = 53 ; pub const UseCounter_eUseCounter_custom_JS_asmjs : root :: mozilla :: UseCounter = 54 ; pub const UseCounter_eUseCounter_custom_JS_wasm : root :: mozilla :: UseCounter = 55 ; pub const UseCounter_eUseCounter_EnablePrivilege : root :: mozilla :: UseCounter = 56 ; pub const UseCounter_eUseCounter_DOMExceptionCode : root :: mozilla :: UseCounter = 57 ; pub const UseCounter_eUseCounter_MutationEvent : root :: mozilla :: UseCounter = 58 ; pub const UseCounter_eUseCounter_Components : root :: mozilla :: UseCounter = 59 ; pub const UseCounter_eUseCounter_PrefixedVisibilityAPI : root :: mozilla :: UseCounter = 60 ; pub const UseCounter_eUseCounter_NodeIteratorDetach : root :: mozilla :: UseCounter = 61 ; pub const UseCounter_eUseCounter_LenientThis : root :: mozilla :: UseCounter = 62 ; pub const UseCounter_eUseCounter_GetPreventDefault : root :: mozilla :: UseCounter = 63 ; pub const UseCounter_eUseCounter_GetSetUserData : root :: mozilla :: UseCounter = 64 ; pub const UseCounter_eUseCounter_MozGetAsFile : root :: mozilla :: UseCounter = 65 ; pub const UseCounter_eUseCounter_UseOfCaptureEvents : root :: mozilla :: UseCounter = 66 ; pub const UseCounter_eUseCounter_UseOfReleaseEvents : root :: mozilla :: UseCounter = 67 ; pub const UseCounter_eUseCounter_UseOfDOM3LoadMethod : root :: mozilla :: UseCounter = 68 ; pub const UseCounter_eUseCounter_ChromeUseOfDOM3LoadMethod : root :: mozilla :: UseCounter = 69 ; pub const UseCounter_eUseCounter_ShowModalDialog : root :: mozilla :: UseCounter = 70 ; pub const UseCounter_eUseCounter_SyncXMLHttpRequest : root :: mozilla :: UseCounter = 71 ; pub const UseCounter_eUseCounter_Window_Cc_ontrollers : root :: mozilla :: UseCounter = 72 ; pub const UseCounter_eUseCounter_ImportXULIntoContent : root :: mozilla :: UseCounter = 73 ; pub const UseCounter_eUseCounter_PannerNodeDoppler : root :: mozilla :: UseCounter = 74 ; pub const UseCounter_eUseCounter_NavigatorGetUserMedia : root :: mozilla :: UseCounter = 75 ; pub const UseCounter_eUseCounter_WebrtcDeprecatedPrefix : root :: mozilla :: UseCounter = 76 ; pub const UseCounter_eUseCounter_RTCPeerConnectionGetStreams : root :: mozilla :: UseCounter = 77 ; pub const UseCounter_eUseCounter_AppCache : root :: mozilla :: UseCounter = 78 ; pub const UseCounter_eUseCounter_PrefixedImageSmoothingEnabled : root :: mozilla :: UseCounter = 79 ; pub const UseCounter_eUseCounter_PrefixedFullscreenAPI : root :: mozilla :: UseCounter = 80 ; pub const UseCounter_eUseCounter_LenientSetter : root :: mozilla :: UseCounter = 81 ; pub const UseCounter_eUseCounter_FileLastModifiedDate : root :: mozilla :: UseCounter = 82 ; pub const UseCounter_eUseCounter_ImageBitmapRenderingContext_TransferImageBitmap : root :: mozilla :: UseCounter = 83 ; pub const UseCounter_eUseCounter_URLCreateObjectURL_MediaStream : root :: mozilla :: UseCounter = 84 ; pub const UseCounter_eUseCounter_XMLBaseAttribute : root :: mozilla :: UseCounter = 85 ; pub const UseCounter_eUseCounter_WindowContentUntrusted : root :: mozilla :: UseCounter = 86 ; pub const UseCounter_eUseCounter_Count : root :: mozilla :: UseCounter = 87 ; pub type UseCounter = i16 ; pub const LogLevel_Disabled : root :: mozilla :: LogLevel = 0 ; pub const LogLevel_Error : root :: mozilla :: LogLevel = 1 ; pub const LogLevel_Warning : root :: mozilla :: LogLevel = 2 ; pub const LogLevel_Info : root :: mozilla :: LogLevel = 3 ; pub const LogLevel_Debug : root :: mozilla :: LogLevel = 4 ; pub const LogLevel_Verbose : root :: mozilla :: LogLevel = 5 ; pub type LogLevel = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct LogModule { pub mName : * mut :: std :: os :: raw :: c_char , pub mLevel : u32 , } # [ test ] fn bindgen_test_layout_LogModule ( ) { assert_eq ! ( :: std :: mem :: size_of :: < LogModule > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( LogModule ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < LogModule > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( LogModule ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const LogModule ) ) . mName as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( LogModule ) , "::" , stringify ! ( mName ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const LogModule ) ) . mLevel as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( LogModule ) , "::" , stringify ! ( mLevel ) ) ) ; } 
 /// Helper class that lazy loads the given log module. This is safe to use for
        /// declaring static references to log modules and can be used as a replacement
        /// for accessing a LogModule directly.
        ///
        /// Example usage:
        /// static LazyLogModule sLayoutLog("layout");
        ///
        /// void Foo() {
        /// MOZ_LOG(sLayoutLog, LogLevel::Verbose, ("Entering foo"));
        /// } 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct LazyLogModule { pub mLogName : * const :: std :: os :: raw :: c_char , pub mLog : u64 , } # [ test ] fn bindgen_test_layout_LazyLogModule ( ) { assert_eq ! ( :: std :: mem :: size_of :: < LazyLogModule > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( LazyLogModule ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < LazyLogModule > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( LazyLogModule ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const LazyLogModule ) ) . mLogName as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( LazyLogModule ) , "::" , stringify ! ( mLogName ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const LazyLogModule ) ) . mLog as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( LazyLogModule ) , "::" , stringify ! ( mLog ) ) ) ; } impl Clone for LazyLogModule { fn clone ( & self ) -> Self { * self } } pub type ComputedKeyframeValues = root :: nsTArray < root :: mozilla :: PropertyStyleAnimationValuePair > ; # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_RawServoStyleSet_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_RawServoSelectorList_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_RawServoSourceSizeList_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct ScrollbarStyles { pub mHorizontal : u8 , pub mVertical : u8 , pub mScrollBehavior : u8 , pub mOverscrollBehaviorX : root :: mozilla :: StyleOverscrollBehavior , pub mOverscrollBehaviorY : root :: mozilla :: StyleOverscrollBehavior , pub mScrollSnapTypeX : u8 , pub mScrollSnapTypeY : u8 , pub mScrollSnapPointsX : root :: nsStyleCoord , pub mScrollSnapPointsY : root :: nsStyleCoord , pub mScrollSnapDestinationX : root :: nsStyleCoord_CalcValue , pub mScrollSnapDestinationY : root :: nsStyleCoord_CalcValue , } # [ test ] fn bindgen_test_layout_ScrollbarStyles ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ScrollbarStyles > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( ScrollbarStyles ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ScrollbarStyles > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ScrollbarStyles ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ScrollbarStyles ) ) . mHorizontal as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ScrollbarStyles ) , "::" , stringify ! ( mHorizontal ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ScrollbarStyles ) ) . mVertical as * const _ as usize } , 1usize , concat ! ( "Alignment of field: " , stringify ! ( ScrollbarStyles ) , "::" , stringify ! ( mVertical ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ScrollbarStyles ) ) . mScrollBehavior as * const _ as usize } , 2usize , concat ! ( "Alignment of field: " , stringify ! ( ScrollbarStyles ) , "::" , stringify ! ( mScrollBehavior ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ScrollbarStyles ) ) . mOverscrollBehaviorX as * const _ as usize } , 3usize , concat ! ( "Alignment of field: " , stringify ! ( ScrollbarStyles ) , "::" , stringify ! ( mOverscrollBehaviorX ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ScrollbarStyles ) ) . mOverscrollBehaviorY as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( ScrollbarStyles ) , "::" , stringify ! ( mOverscrollBehaviorY ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ScrollbarStyles ) ) . mScrollSnapTypeX as * const _ as usize } , 5usize , concat ! ( "Alignment of field: " , stringify ! ( ScrollbarStyles ) , "::" , stringify ! ( mScrollSnapTypeX ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ScrollbarStyles ) ) . mScrollSnapTypeY as * const _ as usize } , 6usize , concat ! ( "Alignment of field: " , stringify ! ( ScrollbarStyles ) , "::" , stringify ! ( mScrollSnapTypeY ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ScrollbarStyles ) ) . mScrollSnapPointsX as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ScrollbarStyles ) , "::" , stringify ! ( mScrollSnapPointsX ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ScrollbarStyles ) ) . mScrollSnapPointsY as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( ScrollbarStyles ) , "::" , stringify ! ( mScrollSnapPointsY ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ScrollbarStyles ) ) . mScrollSnapDestinationX as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( ScrollbarStyles ) , "::" , stringify ! ( mScrollSnapDestinationX ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ScrollbarStyles ) ) . mScrollSnapDestinationY as * const _ as usize } , 52usize , concat ! ( "Alignment of field: " , stringify ! ( ScrollbarStyles ) , "::" , stringify ! ( mScrollSnapDestinationY ) ) ) ; } # [ repr ( C ) ] pub struct LangGroupFontPrefs { pub mLangGroup : root :: RefPtr < root :: nsAtom > , pub mMinimumFontSize : root :: nscoord , pub mDefaultVariableFont : root :: nsFont , pub mDefaultFixedFont : root :: nsFont , pub mDefaultSerifFont : root :: nsFont , pub mDefaultSansSerifFont : root :: nsFont , pub mDefaultMonospaceFont : root :: nsFont , pub mDefaultCursiveFont : root :: nsFont , pub mDefaultFantasyFont : root :: nsFont , pub mNext : root :: nsAutoPtr < root :: mozilla :: LangGroupFontPrefs > , } # [ test ] fn bindgen_test_layout_LangGroupFontPrefs ( ) { assert_eq ! ( :: std :: mem :: size_of :: < LangGroupFontPrefs > ( ) , 696usize , concat ! ( "Size of: " , stringify ! ( LangGroupFontPrefs ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < LangGroupFontPrefs > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( LangGroupFontPrefs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const LangGroupFontPrefs ) ) . mLangGroup as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( LangGroupFontPrefs ) , "::" , stringify ! ( mLangGroup ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const LangGroupFontPrefs ) ) . mMinimumFontSize as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( LangGroupFontPrefs ) , "::" , stringify ! ( mMinimumFontSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const LangGroupFontPrefs ) ) . mDefaultVariableFont as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( LangGroupFontPrefs ) , "::" , stringify ! ( mDefaultVariableFont ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const LangGroupFontPrefs ) ) . mDefaultFixedFont as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( LangGroupFontPrefs ) , "::" , stringify ! ( mDefaultFixedFont ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const LangGroupFontPrefs ) ) . mDefaultSerifFont as * const _ as usize } , 208usize , concat ! ( "Alignment of field: " , stringify ! ( LangGroupFontPrefs ) , "::" , stringify ! ( mDefaultSerifFont ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const LangGroupFontPrefs ) ) . mDefaultSansSerifFont as * const _ as usize } , 304usize , concat ! ( "Alignment of field: " , stringify ! ( LangGroupFontPrefs ) , "::" , stringify ! ( mDefaultSansSerifFont ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const LangGroupFontPrefs ) ) . mDefaultMonospaceFont as * const _ as usize } , 400usize , concat ! ( "Alignment of field: " , stringify ! ( LangGroupFontPrefs ) , "::" , stringify ! ( mDefaultMonospaceFont ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const LangGroupFontPrefs ) ) . mDefaultCursiveFont as * const _ as usize } , 496usize , concat ! ( "Alignment of field: " , stringify ! ( LangGroupFontPrefs ) , "::" , stringify ! ( mDefaultCursiveFont ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const LangGroupFontPrefs ) ) . mDefaultFantasyFont as * const _ as usize } , 592usize , concat ! ( "Alignment of field: " , stringify ! ( LangGroupFontPrefs ) , "::" , stringify ! ( mDefaultFantasyFont ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const LangGroupFontPrefs ) ) . mNext as * const _ as usize } , 688usize , concat ! ( "Alignment of field: " , stringify ! ( LangGroupFontPrefs ) , "::" , stringify ! ( mNext ) ) ) ; } 
 /// Some functionality that has historically lived on nsPresContext does not
        /// actually need to be per-document. This singleton class serves as a host
        /// for that functionality. We delegate to it from nsPresContext where
        /// appropriate, and use it standalone in some cases as well. 
 # [ repr ( C ) ] pub struct StaticPresData { pub mLangService : * mut root :: nsLanguageAtomService , pub mBorderWidthTable : [ root :: nscoord ; 3usize ] , pub mStaticLangGroupFontPrefs : root :: mozilla :: LangGroupFontPrefs , } # [ test ] fn bindgen_test_layout_StaticPresData ( ) { assert_eq ! ( :: std :: mem :: size_of :: < StaticPresData > ( ) , 720usize , concat ! ( "Size of: " , stringify ! ( StaticPresData ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < StaticPresData > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( StaticPresData ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StaticPresData ) ) . mLangService as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( StaticPresData ) , "::" , stringify ! ( mLangService ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StaticPresData ) ) . mBorderWidthTable as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( StaticPresData ) , "::" , stringify ! ( mBorderWidthTable ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StaticPresData ) ) . mStaticLangGroupFontPrefs as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( StaticPresData ) , "::" , stringify ! ( mStaticLangGroupFontPrefs ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct EventStateManager { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RestyleManager { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct URLExtraData { pub mRefCnt : root :: mozilla :: ThreadSafeAutoRefCnt , pub mBaseURI : root :: nsCOMPtr , pub mReferrer : root :: nsCOMPtr , pub mPrincipal : root :: nsCOMPtr , pub mIsChrome : bool , } pub type URLExtraData_HasThreadSafeRefCnt = root :: mozilla :: TrueType ; extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla12URLExtraData6sDummyE" ] 
 pub static mut  URLExtraData_sDummy  :  root :: mozilla :: StaticRefPtr < root :: mozilla :: URLExtraData > ;
} # [ test ] fn bindgen_test_layout_URLExtraData ( ) { assert_eq ! ( :: std :: mem :: size_of :: < URLExtraData > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( URLExtraData ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < URLExtraData > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( URLExtraData ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const URLExtraData ) ) . mRefCnt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( URLExtraData ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const URLExtraData ) ) . mBaseURI as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( URLExtraData ) , "::" , stringify ! ( mBaseURI ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const URLExtraData ) ) . mReferrer as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( URLExtraData ) , "::" , stringify ! ( mReferrer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const URLExtraData ) ) . mPrincipal as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( URLExtraData ) , "::" , stringify ! ( mPrincipal ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const URLExtraData ) ) . mIsChrome as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( URLExtraData ) , "::" , stringify ! ( mIsChrome ) ) ) ; } # [ test ] fn __bindgen_test_layout_StaticRefPtr_open0_URLExtraData_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: StaticRefPtr < root :: mozilla :: URLExtraData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: StaticRefPtr < root :: mozilla :: URLExtraData > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: StaticRefPtr < root :: mozilla :: URLExtraData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: StaticRefPtr < root :: mozilla :: URLExtraData > ) ) ) ; } pub mod image { # [ allow ( unused_imports ) ] use self :: super :: super :: super :: root ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ImageURL { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Image { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ProgressTracker { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] pub struct IProgressObserver__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; 
 /// An interface for observing changes to image state, as reported by
            /// ProgressTracker.
            ///
            /// This is the ImageLib-internal version of imgINotificationObserver,
            /// essentially, with implementation details that code outside of ImageLib
            /// shouldn't see.
            ///
            /// XXX(seth): It's preferable to avoid adding anything to this interface if
            /// possible.  In the long term, it would be ideal to get to a place where we can
            /// just use the imgINotificationObserver interface internally as well. 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct IProgressObserver { pub vtable_ : * const IProgressObserver__bindgen_vtable , pub _base : u64 , } # [ test ] fn bindgen_test_layout_IProgressObserver ( ) { assert_eq ! ( :: std :: mem :: size_of :: < IProgressObserver > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( IProgressObserver ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < IProgressObserver > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( IProgressObserver ) ) ) ; } } # [ repr ( C ) ] pub struct CounterStyle__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct CounterStyle { pub vtable_ : * const CounterStyle__bindgen_vtable , pub mStyle : i32 , } # [ test ] fn bindgen_test_layout_CounterStyle ( ) { assert_eq ! ( :: std :: mem :: size_of :: < CounterStyle > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( CounterStyle ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < CounterStyle > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( CounterStyle ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CounterStyle ) ) . mStyle as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( CounterStyle ) , "::" , stringify ! ( mStyle ) ) ) ; } impl Clone for CounterStyle { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] pub struct AnonymousCounterStyle { pub _base : root :: mozilla :: CounterStyle , pub mRefCnt : root :: mozilla :: ThreadSafeAutoRefCnt , pub mSingleString : bool , pub mSystem : u8 , pub mSymbols : root :: nsTArray < ::nsstring::nsStringRepr > , } pub type AnonymousCounterStyle_HasThreadSafeRefCnt = root :: mozilla :: TrueType ; # [ test ] fn bindgen_test_layout_AnonymousCounterStyle ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AnonymousCounterStyle > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( AnonymousCounterStyle ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AnonymousCounterStyle > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AnonymousCounterStyle ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AnonymousCounterStyle ) ) . mRefCnt as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AnonymousCounterStyle ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AnonymousCounterStyle ) ) . mSingleString as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AnonymousCounterStyle ) , "::" , stringify ! ( mSingleString ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AnonymousCounterStyle ) ) . mSystem as * const _ as usize } , 25usize , concat ! ( "Alignment of field: " , stringify ! ( AnonymousCounterStyle ) , "::" , stringify ! ( mSystem ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AnonymousCounterStyle ) ) . mSymbols as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( AnonymousCounterStyle ) , "::" , stringify ! ( mSymbols ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct CounterStylePtr { pub mRaw : usize , } pub const CounterStylePtr_Type_eCounterStyle : root :: mozilla :: CounterStylePtr_Type = 0 ; pub const CounterStylePtr_Type_eAnonymousCounterStyle : root :: mozilla :: CounterStylePtr_Type = 1 ; pub const CounterStylePtr_Type_eUnresolvedAtom : root :: mozilla :: CounterStylePtr_Type = 2 ; pub const CounterStylePtr_Type_eMask : root :: mozilla :: CounterStylePtr_Type = 3 ; pub type CounterStylePtr_Type = usize ; # [ test ] fn bindgen_test_layout_CounterStylePtr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < CounterStylePtr > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( CounterStylePtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < CounterStylePtr > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( CounterStylePtr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CounterStylePtr ) ) . mRaw as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( CounterStylePtr ) , "::" , stringify ! ( mRaw ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct CounterStyleManager { pub mRefCnt : root :: nsAutoRefCnt , pub mPresContext : * mut root :: nsPresContext , pub mStyles : [ u64 ; 4usize ] , pub mRetiredStyles : root :: nsTArray < * mut root :: mozilla :: CounterStyle > , } pub type CounterStyleManager_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ test ] fn bindgen_test_layout_CounterStyleManager ( ) { assert_eq ! ( :: std :: mem :: size_of :: < CounterStyleManager > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( CounterStyleManager ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < CounterStyleManager > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( CounterStyleManager ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CounterStyleManager ) ) . mRefCnt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( CounterStyleManager ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CounterStyleManager ) ) . mPresContext as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( CounterStyleManager ) , "::" , stringify ! ( mPresContext ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CounterStyleManager ) ) . mStyles as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( CounterStyleManager ) , "::" , stringify ! ( mStyles ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CounterStyleManager ) ) . mRetiredStyles as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( CounterStyleManager ) , "::" , stringify ! ( mRetiredStyles ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct Position { pub mXPosition : root :: mozilla :: Position_Coord , pub mYPosition : root :: mozilla :: Position_Coord , } pub type Position_Coord = root :: nsStyleCoord_CalcValue ; # [ test ] fn bindgen_test_layout_Position ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Position > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( Position ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Position > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( Position ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Position ) ) . mXPosition as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( Position ) , "::" , stringify ! ( mXPosition ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Position ) ) . mYPosition as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( Position ) , "::" , stringify ! ( mYPosition ) ) ) ; } impl Clone for Position { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct StyleTransition { pub mTimingFunction : root :: nsTimingFunction , pub mDuration : f32 , pub mDelay : f32 , pub mProperty : root :: nsCSSPropertyID , pub mUnknownProperty : root :: RefPtr < root :: nsAtom > , } # [ test ] fn bindgen_test_layout_StyleTransition ( ) { assert_eq ! ( :: std :: mem :: size_of :: < StyleTransition > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( StyleTransition ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < StyleTransition > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( StyleTransition ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleTransition ) ) . mTimingFunction as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( StyleTransition ) , "::" , stringify ! ( mTimingFunction ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleTransition ) ) . mDuration as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( StyleTransition ) , "::" , stringify ! ( mDuration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleTransition ) ) . mDelay as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( StyleTransition ) , "::" , stringify ! ( mDelay ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleTransition ) ) . mProperty as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( StyleTransition ) , "::" , stringify ! ( mProperty ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleTransition ) ) . mUnknownProperty as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( StyleTransition ) , "::" , stringify ! ( mUnknownProperty ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct StyleAnimation { pub mTimingFunction : root :: nsTimingFunction , pub mDuration : f32 , pub mDelay : f32 , pub mName : root :: RefPtr < root :: nsAtom > , pub mDirection : root :: mozilla :: dom :: PlaybackDirection , pub mFillMode : root :: mozilla :: dom :: FillMode , pub mPlayState : u8 , pub mIterationCount : f32 , } # [ test ] fn bindgen_test_layout_StyleAnimation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < StyleAnimation > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( StyleAnimation ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < StyleAnimation > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( StyleAnimation ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleAnimation ) ) . mTimingFunction as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( StyleAnimation ) , "::" , stringify ! ( mTimingFunction ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleAnimation ) ) . mDuration as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( StyleAnimation ) , "::" , stringify ! ( mDuration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleAnimation ) ) . mDelay as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( StyleAnimation ) , "::" , stringify ! ( mDelay ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleAnimation ) ) . mName as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( StyleAnimation ) , "::" , stringify ! ( mName ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleAnimation ) ) . mDirection as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( StyleAnimation ) , "::" , stringify ! ( mDirection ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleAnimation ) ) . mFillMode as * const _ as usize } , 41usize , concat ! ( "Alignment of field: " , stringify ! ( StyleAnimation ) , "::" , stringify ! ( mFillMode ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleAnimation ) ) . mPlayState as * const _ as usize } , 42usize , concat ! ( "Alignment of field: " , stringify ! ( StyleAnimation ) , "::" , stringify ! ( mPlayState ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleAnimation ) ) . mIterationCount as * const _ as usize } , 44usize , concat ! ( "Alignment of field: " , stringify ! ( StyleAnimation ) , "::" , stringify ! ( mIterationCount ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct StyleBasicShape { pub mType : root :: mozilla :: StyleBasicShapeType , pub mFillRule : root :: mozilla :: StyleFillRule , pub mCoordinates : root :: nsTArray < root :: nsStyleCoord > , pub mPosition : root :: mozilla :: Position , pub mRadius : root :: nsStyleCorners , } # [ test ] fn bindgen_test_layout_StyleBasicShape ( ) { assert_eq ! ( :: std :: mem :: size_of :: < StyleBasicShape > ( ) , 112usize , concat ! ( "Size of: " , stringify ! ( StyleBasicShape ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < StyleBasicShape > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( StyleBasicShape ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleBasicShape ) ) . mType as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( StyleBasicShape ) , "::" , stringify ! ( mType ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleBasicShape ) ) . mFillRule as * const _ as usize } , 1usize , concat ! ( "Alignment of field: " , stringify ! ( StyleBasicShape ) , "::" , stringify ! ( mFillRule ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleBasicShape ) ) . mCoordinates as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( StyleBasicShape ) , "::" , stringify ! ( mCoordinates ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleBasicShape ) ) . mPosition as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( StyleBasicShape ) , "::" , stringify ! ( mPosition ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleBasicShape ) ) . mRadius as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( StyleBasicShape ) , "::" , stringify ! ( mRadius ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct StyleShapeSource { pub mBasicShape : root :: mozilla :: UniquePtr < root :: mozilla :: StyleBasicShape > , pub mShapeImage : root :: mozilla :: UniquePtr < root :: nsStyleImage > , pub mType : root :: mozilla :: StyleShapeSourceType , pub mReferenceBox : root :: mozilla :: StyleGeometryBox , } # [ test ] fn bindgen_test_layout_StyleShapeSource ( ) { assert_eq ! ( :: std :: mem :: size_of :: < StyleShapeSource > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( StyleShapeSource ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < StyleShapeSource > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( StyleShapeSource ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleShapeSource ) ) . mBasicShape as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( StyleShapeSource ) , "::" , stringify ! ( mBasicShape ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleShapeSource ) ) . mShapeImage as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( StyleShapeSource ) , "::" , stringify ! ( mShapeImage ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleShapeSource ) ) . mType as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( StyleShapeSource ) , "::" , stringify ! ( mType ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleShapeSource ) ) . mReferenceBox as * const _ as usize } , 17usize , concat ! ( "Alignment of field: " , stringify ! ( StyleShapeSource ) , "::" , stringify ! ( mReferenceBox ) ) ) ; } 
 /// <div rustbindgen="true" replaces="mozilla::UniquePtr">
        ///
        /// TODO(Emilio): This is a workaround and we should be able to get rid of this
        /// one. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct UniquePtr < T > { pub mPtr : * mut T , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , } pub const SERVO_PREF_ENABLED_align_content : bool = false ; pub const SERVO_PREF_ENABLED_align_items : bool = false ; pub const SERVO_PREF_ENABLED_align_self : bool = false ; pub const SERVO_PREF_ENABLED_all : bool = true ; pub const SERVO_PREF_ENABLED_animation : bool = false ; pub const SERVO_PREF_ENABLED_animation_delay : bool = false ; pub const SERVO_PREF_ENABLED_animation_direction : bool = false ; pub const SERVO_PREF_ENABLED_animation_duration : bool = false ; pub const SERVO_PREF_ENABLED_animation_fill_mode : bool = false ; pub const SERVO_PREF_ENABLED_animation_iteration_count : bool = false ; pub const SERVO_PREF_ENABLED_animation_name : bool = false ; pub const SERVO_PREF_ENABLED_animation_play_state : bool = false ; pub const SERVO_PREF_ENABLED_animation_timing_function : bool = false ; pub const SERVO_PREF_ENABLED__moz_appearance : bool = false ; pub const SERVO_PREF_ENABLED_backface_visibility : bool = false ; pub const SERVO_PREF_ENABLED_background : bool = false ; pub const SERVO_PREF_ENABLED_background_attachment : bool = false ; pub const SERVO_PREF_ENABLED_background_blend_mode : bool = true ; pub const SERVO_PREF_ENABLED_background_clip : bool = false ; pub const SERVO_PREF_ENABLED_background_color : bool = false ; pub const SERVO_PREF_ENABLED_background_image : bool = false ; pub const SERVO_PREF_ENABLED_background_origin : bool = false ; pub const SERVO_PREF_ENABLED_background_position : bool = false ; pub const SERVO_PREF_ENABLED_background_position_x : bool = false ; pub const SERVO_PREF_ENABLED_background_position_y : bool = false ; pub const SERVO_PREF_ENABLED_background_repeat : bool = false ; pub const SERVO_PREF_ENABLED_background_size : bool = false ; pub const SERVO_PREF_ENABLED__moz_binding : bool = false ; pub const SERVO_PREF_ENABLED_block_size : bool = false ; pub const SERVO_PREF_ENABLED_border : bool = false ; pub const SERVO_PREF_ENABLED_border_block_end : bool = false ; pub const SERVO_PREF_ENABLED_border_block_end_color : bool = false ; pub const SERVO_PREF_ENABLED_border_block_end_style : bool = false ; pub const SERVO_PREF_ENABLED_border_block_end_width : bool = false ; pub const SERVO_PREF_ENABLED_border_block_start : bool = false ; pub const SERVO_PREF_ENABLED_border_block_start_color : bool = false ; pub const SERVO_PREF_ENABLED_border_block_start_style : bool = false ; pub const SERVO_PREF_ENABLED_border_block_start_width : bool = false ; pub const SERVO_PREF_ENABLED_border_bottom : bool = false ; pub const SERVO_PREF_ENABLED_border_bottom_color : bool = false ; pub const SERVO_PREF_ENABLED__moz_border_bottom_colors : bool = false ; pub const SERVO_PREF_ENABLED_border_bottom_left_radius : bool = false ; pub const SERVO_PREF_ENABLED_border_bottom_right_radius : bool = false ; pub const SERVO_PREF_ENABLED_border_bottom_style : bool = false ; pub const SERVO_PREF_ENABLED_border_bottom_width : bool = false ; pub const SERVO_PREF_ENABLED_border_collapse : bool = false ; pub const SERVO_PREF_ENABLED_border_color : bool = false ; pub const SERVO_PREF_ENABLED_border_image : bool = false ; pub const SERVO_PREF_ENABLED_border_image_outset : bool = false ; pub const SERVO_PREF_ENABLED_border_image_repeat : bool = false ; pub const SERVO_PREF_ENABLED_border_image_slice : bool = false ; pub const SERVO_PREF_ENABLED_border_image_source : bool = false ; pub const SERVO_PREF_ENABLED_border_image_width : bool = false ; pub const SERVO_PREF_ENABLED_border_inline_end : bool = false ; pub const SERVO_PREF_ENABLED_border_inline_end_color : bool = false ; pub const SERVO_PREF_ENABLED_border_inline_end_style : bool = false ; pub const SERVO_PREF_ENABLED_border_inline_end_width : bool = false ; pub const SERVO_PREF_ENABLED_border_inline_start : bool = false ; pub const SERVO_PREF_ENABLED_border_inline_start_color : bool = false ; pub const SERVO_PREF_ENABLED_border_inline_start_style : bool = false ; pub const SERVO_PREF_ENABLED_border_inline_start_width : bool = false ; pub const SERVO_PREF_ENABLED_border_left : bool = false ; pub const SERVO_PREF_ENABLED_border_left_color : bool = false ; pub const SERVO_PREF_ENABLED__moz_border_left_colors : bool = false ; pub const SERVO_PREF_ENABLED_border_left_style : bool = false ; pub const SERVO_PREF_ENABLED_border_left_width : bool = false ; pub const SERVO_PREF_ENABLED_border_radius : bool = false ; pub const SERVO_PREF_ENABLED_border_right : bool = false ; pub const SERVO_PREF_ENABLED_border_right_color : bool = false ; pub const SERVO_PREF_ENABLED__moz_border_right_colors : bool = false ; pub const SERVO_PREF_ENABLED_border_right_style : bool = false ; pub const SERVO_PREF_ENABLED_border_right_width : bool = false ; pub const SERVO_PREF_ENABLED_border_spacing : bool = false ; pub const SERVO_PREF_ENABLED_border_style : bool = false ; pub const SERVO_PREF_ENABLED_border_top : bool = false ; pub const SERVO_PREF_ENABLED_border_top_color : bool = false ; pub const SERVO_PREF_ENABLED__moz_border_top_colors : bool = false ; pub const SERVO_PREF_ENABLED_border_top_left_radius : bool = false ; pub const SERVO_PREF_ENABLED_border_top_right_radius : bool = false ; pub const SERVO_PREF_ENABLED_border_top_style : bool = false ; pub const SERVO_PREF_ENABLED_border_top_width : bool = false ; pub const SERVO_PREF_ENABLED_border_width : bool = false ; pub const SERVO_PREF_ENABLED_bottom : bool = false ; pub const SERVO_PREF_ENABLED__moz_box_align : bool = false ; pub const SERVO_PREF_ENABLED_box_decoration_break : bool = true ; pub const SERVO_PREF_ENABLED__moz_box_direction : bool = false ; pub const SERVO_PREF_ENABLED__moz_box_flex : bool = false ; pub const SERVO_PREF_ENABLED__moz_box_ordinal_group : bool = false ; pub const SERVO_PREF_ENABLED__moz_box_orient : bool = false ; pub const SERVO_PREF_ENABLED__moz_box_pack : bool = false ; pub const SERVO_PREF_ENABLED_box_shadow : bool = false ; pub const SERVO_PREF_ENABLED_box_sizing : bool = false ; pub const SERVO_PREF_ENABLED_caption_side : bool = false ; pub const SERVO_PREF_ENABLED_caret_color : bool = false ; pub const SERVO_PREF_ENABLED_clear : bool = false ; pub const SERVO_PREF_ENABLED_clip : bool = false ; pub const SERVO_PREF_ENABLED_clip_path : bool = false ; pub const SERVO_PREF_ENABLED_clip_rule : bool = false ; pub const SERVO_PREF_ENABLED_color : bool = false ; pub const SERVO_PREF_ENABLED_color_adjust : bool = true ; pub const SERVO_PREF_ENABLED_color_interpolation : bool = false ; pub const SERVO_PREF_ENABLED_color_interpolation_filters : bool = false ; pub const SERVO_PREF_ENABLED_column_count : bool = false ; pub const SERVO_PREF_ENABLED_column_fill : bool = false ; pub const SERVO_PREF_ENABLED_column_gap : bool = false ; pub const SERVO_PREF_ENABLED_column_rule : bool = false ; pub const SERVO_PREF_ENABLED_column_rule_color : bool = false ; pub const SERVO_PREF_ENABLED_column_rule_style : bool = false ; pub const SERVO_PREF_ENABLED_column_rule_width : bool = false ; pub const SERVO_PREF_ENABLED_column_span : bool = true ; pub const SERVO_PREF_ENABLED_column_width : bool = false ; pub const SERVO_PREF_ENABLED_columns : bool = false ; pub const SERVO_PREF_ENABLED_contain : bool = true ; pub const SERVO_PREF_ENABLED_content : bool = false ; pub const SERVO_PREF_ENABLED__moz_context_properties : bool = false ; pub const SERVO_PREF_ENABLED__moz_control_character_visibility : bool = false ; pub const SERVO_PREF_ENABLED_counter_increment : bool = false ; pub const SERVO_PREF_ENABLED_counter_reset : bool = false ; pub const SERVO_PREF_ENABLED_cursor : bool = false ; pub const SERVO_PREF_ENABLED_direction : bool = false ; pub const SERVO_PREF_ENABLED_display : bool = false ; pub const SERVO_PREF_ENABLED_dominant_baseline : bool = false ; pub const SERVO_PREF_ENABLED_empty_cells : bool = false ; pub const SERVO_PREF_ENABLED_fill : bool = false ; pub const SERVO_PREF_ENABLED_fill_opacity : bool = false ; pub const SERVO_PREF_ENABLED_fill_rule : bool = false ; pub const SERVO_PREF_ENABLED_filter : bool = false ; pub const SERVO_PREF_ENABLED_flex : bool = false ; pub const SERVO_PREF_ENABLED_flex_basis : bool = false ; pub const SERVO_PREF_ENABLED_flex_direction : bool = false ; pub const SERVO_PREF_ENABLED_flex_flow : bool = false ; pub const SERVO_PREF_ENABLED_flex_grow : bool = false ; pub const SERVO_PREF_ENABLED_flex_shrink : bool = false ; pub const SERVO_PREF_ENABLED_flex_wrap : bool = false ; pub const SERVO_PREF_ENABLED_float_ : bool = false ; pub const SERVO_PREF_ENABLED__moz_float_edge : bool = false ; pub const SERVO_PREF_ENABLED_flood_color : bool = false ; pub const SERVO_PREF_ENABLED_flood_opacity : bool = false ; pub const SERVO_PREF_ENABLED_font : bool = false ; pub const SERVO_PREF_ENABLED_font_family : bool = false ; pub const SERVO_PREF_ENABLED_font_feature_settings : bool = false ; pub const SERVO_PREF_ENABLED_font_kerning : bool = false ; pub const SERVO_PREF_ENABLED_font_language_override : bool = false ; pub const SERVO_PREF_ENABLED_font_size : bool = false ; pub const SERVO_PREF_ENABLED_font_size_adjust : bool = false ; pub const SERVO_PREF_ENABLED__moz_font_smoothing_background_color : bool = false ; pub const SERVO_PREF_ENABLED_font_stretch : bool = false ; pub const SERVO_PREF_ENABLED_font_style : bool = false ; pub const SERVO_PREF_ENABLED_font_synthesis : bool = false ; pub const SERVO_PREF_ENABLED_font_variant : bool = false ; pub const SERVO_PREF_ENABLED_font_variant_alternates : bool = false ; pub const SERVO_PREF_ENABLED_font_variant_caps : bool = false ; pub const SERVO_PREF_ENABLED_font_variant_east_asian : bool = false ; pub const SERVO_PREF_ENABLED_font_variant_ligatures : bool = false ; pub const SERVO_PREF_ENABLED_font_variant_numeric : bool = false ; pub const SERVO_PREF_ENABLED_font_variant_position : bool = false ; pub const SERVO_PREF_ENABLED_font_variation_settings : bool = true ; pub const SERVO_PREF_ENABLED_font_weight : bool = false ; pub const SERVO_PREF_ENABLED__moz_force_broken_image_icon : bool = false ; pub const SERVO_PREF_ENABLED_grid : bool = false ; pub const SERVO_PREF_ENABLED_grid_area : bool = false ; pub const SERVO_PREF_ENABLED_grid_auto_columns : bool = false ; pub const SERVO_PREF_ENABLED_grid_auto_flow : bool = false ; pub const SERVO_PREF_ENABLED_grid_auto_rows : bool = false ; pub const SERVO_PREF_ENABLED_grid_column : bool = false ; pub const SERVO_PREF_ENABLED_grid_column_end : bool = false ; pub const SERVO_PREF_ENABLED_grid_column_gap : bool = false ; pub const SERVO_PREF_ENABLED_grid_column_start : bool = false ; pub const SERVO_PREF_ENABLED_grid_gap : bool = false ; pub const SERVO_PREF_ENABLED_grid_row : bool = false ; pub const SERVO_PREF_ENABLED_grid_row_end : bool = false ; pub const SERVO_PREF_ENABLED_grid_row_gap : bool = false ; pub const SERVO_PREF_ENABLED_grid_row_start : bool = false ; pub const SERVO_PREF_ENABLED_grid_template : bool = false ; pub const SERVO_PREF_ENABLED_grid_template_areas : bool = false ; pub const SERVO_PREF_ENABLED_grid_template_columns : bool = false ; pub const SERVO_PREF_ENABLED_grid_template_rows : bool = false ; pub const SERVO_PREF_ENABLED_height : bool = false ; pub const SERVO_PREF_ENABLED_hyphens : bool = false ; pub const SERVO_PREF_ENABLED_initial_letter : bool = true ; pub const SERVO_PREF_ENABLED_image_orientation : bool = true ; pub const SERVO_PREF_ENABLED__moz_image_region : bool = false ; pub const SERVO_PREF_ENABLED_image_rendering : bool = false ; pub const SERVO_PREF_ENABLED_ime_mode : bool = false ; pub const SERVO_PREF_ENABLED_inline_size : bool = false ; pub const SERVO_PREF_ENABLED_isolation : bool = true ; pub const SERVO_PREF_ENABLED_justify_content : bool = false ; pub const SERVO_PREF_ENABLED_justify_items : bool = false ; pub const SERVO_PREF_ENABLED_justify_self : bool = false ; pub const SERVO_PREF_ENABLED__x_lang : bool = false ; pub const SERVO_PREF_ENABLED_left : bool = false ; pub const SERVO_PREF_ENABLED_letter_spacing : bool = false ; pub const SERVO_PREF_ENABLED_lighting_color : bool = false ; pub const SERVO_PREF_ENABLED_line_height : bool = false ; pub const SERVO_PREF_ENABLED_list_style : bool = false ; pub const SERVO_PREF_ENABLED_list_style_image : bool = false ; pub const SERVO_PREF_ENABLED_list_style_position : bool = false ; pub const SERVO_PREF_ENABLED_list_style_type : bool = false ; pub const SERVO_PREF_ENABLED_margin : bool = false ; pub const SERVO_PREF_ENABLED_margin_block_end : bool = false ; pub const SERVO_PREF_ENABLED_margin_block_start : bool = false ; pub const SERVO_PREF_ENABLED_margin_bottom : bool = false ; pub const SERVO_PREF_ENABLED_margin_inline_end : bool = false ; pub const SERVO_PREF_ENABLED_margin_inline_start : bool = false ; pub const SERVO_PREF_ENABLED_margin_left : bool = false ; pub const SERVO_PREF_ENABLED_margin_right : bool = false ; pub const SERVO_PREF_ENABLED_margin_top : bool = false ; pub const SERVO_PREF_ENABLED_marker : bool = false ; pub const SERVO_PREF_ENABLED_marker_end : bool = false ; pub const SERVO_PREF_ENABLED_marker_mid : bool = false ; pub const SERVO_PREF_ENABLED_marker_start : bool = false ; pub const SERVO_PREF_ENABLED_mask : bool = false ; pub const SERVO_PREF_ENABLED_mask_clip : bool = false ; pub const SERVO_PREF_ENABLED_mask_composite : bool = false ; pub const SERVO_PREF_ENABLED_mask_image : bool = false ; pub const SERVO_PREF_ENABLED_mask_mode : bool = false ; pub const SERVO_PREF_ENABLED_mask_origin : bool = false ; pub const SERVO_PREF_ENABLED_mask_position : bool = false ; pub const SERVO_PREF_ENABLED_mask_position_x : bool = false ; pub const SERVO_PREF_ENABLED_mask_position_y : bool = false ; pub const SERVO_PREF_ENABLED_mask_repeat : bool = false ; pub const SERVO_PREF_ENABLED_mask_size : bool = false ; pub const SERVO_PREF_ENABLED_mask_type : bool = false ; pub const SERVO_PREF_ENABLED__moz_math_display : bool = false ; pub const SERVO_PREF_ENABLED__moz_math_variant : bool = false ; pub const SERVO_PREF_ENABLED_max_block_size : bool = false ; pub const SERVO_PREF_ENABLED_max_height : bool = false ; pub const SERVO_PREF_ENABLED_max_inline_size : bool = false ; pub const SERVO_PREF_ENABLED_max_width : bool = false ; pub const SERVO_PREF_ENABLED_min_block_size : bool = false ; pub const SERVO_PREF_ENABLED__moz_min_font_size_ratio : bool = false ; pub const SERVO_PREF_ENABLED_min_height : bool = false ; pub const SERVO_PREF_ENABLED_min_inline_size : bool = false ; pub const SERVO_PREF_ENABLED_min_width : bool = false ; pub const SERVO_PREF_ENABLED_mix_blend_mode : bool = true ; pub const SERVO_PREF_ENABLED_object_fit : bool = false ; pub const SERVO_PREF_ENABLED_object_position : bool = false ; pub const SERVO_PREF_ENABLED_offset_block_end : bool = false ; pub const SERVO_PREF_ENABLED_offset_block_start : bool = false ; pub const SERVO_PREF_ENABLED_offset_inline_end : bool = false ; pub const SERVO_PREF_ENABLED_offset_inline_start : bool = false ; pub const SERVO_PREF_ENABLED_opacity : bool = false ; pub const SERVO_PREF_ENABLED_order : bool = false ; pub const SERVO_PREF_ENABLED__moz_orient : bool = false ; pub const SERVO_PREF_ENABLED__moz_osx_font_smoothing : bool = true ; pub const SERVO_PREF_ENABLED_outline : bool = false ; pub const SERVO_PREF_ENABLED_outline_color : bool = false ; pub const SERVO_PREF_ENABLED_outline_offset : bool = false ; pub const SERVO_PREF_ENABLED__moz_outline_radius : bool = false ; pub const SERVO_PREF_ENABLED__moz_outline_radius_bottomleft : bool = false ; pub const SERVO_PREF_ENABLED__moz_outline_radius_bottomright : bool = false ; pub const SERVO_PREF_ENABLED__moz_outline_radius_topleft : bool = false ; pub const SERVO_PREF_ENABLED__moz_outline_radius_topright : bool = false ; pub const SERVO_PREF_ENABLED_outline_style : bool = false ; pub const SERVO_PREF_ENABLED_outline_width : bool = false ; pub const SERVO_PREF_ENABLED_overflow : bool = false ; pub const SERVO_PREF_ENABLED_overflow_clip_box : bool = true ; pub const SERVO_PREF_ENABLED_overflow_clip_box_block : bool = true ; pub const SERVO_PREF_ENABLED_overflow_clip_box_inline : bool = true ; pub const SERVO_PREF_ENABLED_overflow_x : bool = false ; pub const SERVO_PREF_ENABLED_overflow_y : bool = false ; pub const SERVO_PREF_ENABLED_padding : bool = false ; pub const SERVO_PREF_ENABLED_padding_block_end : bool = false ; pub const SERVO_PREF_ENABLED_padding_block_start : bool = false ; pub const SERVO_PREF_ENABLED_padding_bottom : bool = false ; pub const SERVO_PREF_ENABLED_padding_inline_end : bool = false ; pub const SERVO_PREF_ENABLED_padding_inline_start : bool = false ; pub const SERVO_PREF_ENABLED_padding_left : bool = false ; pub const SERVO_PREF_ENABLED_padding_right : bool = false ; pub const SERVO_PREF_ENABLED_padding_top : bool = false ; pub const SERVO_PREF_ENABLED_page_break_after : bool = false ; pub const SERVO_PREF_ENABLED_page_break_before : bool = false ; pub const SERVO_PREF_ENABLED_page_break_inside : bool = false ; pub const SERVO_PREF_ENABLED_paint_order : bool = true ; pub const SERVO_PREF_ENABLED_perspective : bool = false ; pub const SERVO_PREF_ENABLED_perspective_origin : bool = false ; pub const SERVO_PREF_ENABLED_place_content : bool = false ; pub const SERVO_PREF_ENABLED_place_items : bool = false ; pub const SERVO_PREF_ENABLED_place_self : bool = false ; pub const SERVO_PREF_ENABLED_pointer_events : bool = false ; pub const SERVO_PREF_ENABLED_position : bool = false ; pub const SERVO_PREF_ENABLED_quotes : bool = false ; pub const SERVO_PREF_ENABLED_resize : bool = false ; pub const SERVO_PREF_ENABLED_right : bool = false ; pub const SERVO_PREF_ENABLED_ruby_align : bool = false ; pub const SERVO_PREF_ENABLED_ruby_position : bool = false ; pub const SERVO_PREF_ENABLED__moz_script_level : bool = false ; pub const SERVO_PREF_ENABLED__moz_script_min_size : bool = false ; pub const SERVO_PREF_ENABLED__moz_script_size_multiplier : bool = false ; pub const SERVO_PREF_ENABLED_scroll_behavior : bool = true ; pub const SERVO_PREF_ENABLED_overscroll_behavior : bool = true ; pub const SERVO_PREF_ENABLED_overscroll_behavior_x : bool = true ; pub const SERVO_PREF_ENABLED_overscroll_behavior_y : bool = true ; pub const SERVO_PREF_ENABLED_scroll_snap_coordinate : bool = true ; pub const SERVO_PREF_ENABLED_scroll_snap_destination : bool = true ; pub const SERVO_PREF_ENABLED_scroll_snap_points_x : bool = true ; pub const SERVO_PREF_ENABLED_scroll_snap_points_y : bool = true ; pub const SERVO_PREF_ENABLED_scroll_snap_type : bool = true ; pub const SERVO_PREF_ENABLED_scroll_snap_type_x : bool = true ; pub const SERVO_PREF_ENABLED_scroll_snap_type_y : bool = true ; pub const SERVO_PREF_ENABLED_shape_image_threshold : bool = true ; pub const SERVO_PREF_ENABLED_shape_outside : bool = true ; pub const SERVO_PREF_ENABLED_shape_rendering : bool = false ; pub const SERVO_PREF_ENABLED__x_span : bool = false ; pub const SERVO_PREF_ENABLED__moz_stack_sizing : bool = false ; pub const SERVO_PREF_ENABLED_stop_color : bool = false ; pub const SERVO_PREF_ENABLED_stop_opacity : bool = false ; pub const SERVO_PREF_ENABLED_stroke : bool = false ; pub const SERVO_PREF_ENABLED_stroke_dasharray : bool = false ; pub const SERVO_PREF_ENABLED_stroke_dashoffset : bool = false ; pub const SERVO_PREF_ENABLED_stroke_linecap : bool = false ; pub const SERVO_PREF_ENABLED_stroke_linejoin : bool = false ; pub const SERVO_PREF_ENABLED_stroke_miterlimit : bool = false ; pub const SERVO_PREF_ENABLED_stroke_opacity : bool = false ; pub const SERVO_PREF_ENABLED_stroke_width : bool = false ; pub const SERVO_PREF_ENABLED__x_system_font : bool = false ; pub const SERVO_PREF_ENABLED__moz_tab_size : bool = false ; pub const SERVO_PREF_ENABLED_table_layout : bool = false ; pub const SERVO_PREF_ENABLED_text_align : bool = false ; pub const SERVO_PREF_ENABLED_text_align_last : bool = false ; pub const SERVO_PREF_ENABLED_text_anchor : bool = false ; pub const SERVO_PREF_ENABLED_text_combine_upright : bool = true ; pub const SERVO_PREF_ENABLED_text_decoration : bool = false ; pub const SERVO_PREF_ENABLED_text_decoration_color : bool = false ; pub const SERVO_PREF_ENABLED_text_decoration_line : bool = false ; pub const SERVO_PREF_ENABLED_text_decoration_style : bool = false ; pub const SERVO_PREF_ENABLED_text_emphasis : bool = false ; pub const SERVO_PREF_ENABLED_text_emphasis_color : bool = false ; pub const SERVO_PREF_ENABLED_text_emphasis_position : bool = false ; pub const SERVO_PREF_ENABLED_text_emphasis_style : bool = false ; pub const SERVO_PREF_ENABLED__webkit_text_fill_color : bool = true ; pub const SERVO_PREF_ENABLED_text_indent : bool = false ; pub const SERVO_PREF_ENABLED_text_justify : bool = true ; pub const SERVO_PREF_ENABLED_text_orientation : bool = false ; pub const SERVO_PREF_ENABLED_text_overflow : bool = false ; pub const SERVO_PREF_ENABLED_text_rendering : bool = false ; pub const SERVO_PREF_ENABLED_text_shadow : bool = false ; pub const SERVO_PREF_ENABLED__moz_text_size_adjust : bool = false ; pub const SERVO_PREF_ENABLED__webkit_text_stroke : bool = true ; pub const SERVO_PREF_ENABLED__webkit_text_stroke_color : bool = true ; pub const SERVO_PREF_ENABLED__webkit_text_stroke_width : bool = true ; pub const SERVO_PREF_ENABLED_text_transform : bool = false ; pub const SERVO_PREF_ENABLED__x_text_zoom : bool = false ; pub const SERVO_PREF_ENABLED_top : bool = false ; pub const SERVO_PREF_ENABLED__moz_top_layer : bool = false ; pub const SERVO_PREF_ENABLED_touch_action : bool = true ; pub const SERVO_PREF_ENABLED_transform : bool = false ; pub const SERVO_PREF_ENABLED__moz_transform : bool = true ; pub const SERVO_PREF_ENABLED_transform_box : bool = true ; pub const SERVO_PREF_ENABLED_transform_origin : bool = false ; pub const SERVO_PREF_ENABLED_transform_style : bool = false ; pub const SERVO_PREF_ENABLED_transition : bool = false ; pub const SERVO_PREF_ENABLED_transition_delay : bool = false ; pub const SERVO_PREF_ENABLED_transition_duration : bool = false ; pub const SERVO_PREF_ENABLED_transition_property : bool = false ; pub const SERVO_PREF_ENABLED_transition_timing_function : bool = false ; pub const SERVO_PREF_ENABLED_unicode_bidi : bool = false ; pub const SERVO_PREF_ENABLED__moz_user_focus : bool = false ; pub const SERVO_PREF_ENABLED__moz_user_input : bool = false ; pub const SERVO_PREF_ENABLED__moz_user_modify : bool = false ; pub const SERVO_PREF_ENABLED__moz_user_select : bool = false ; pub const SERVO_PREF_ENABLED_vector_effect : bool = false ; pub const SERVO_PREF_ENABLED_vertical_align : bool = false ; pub const SERVO_PREF_ENABLED_visibility : bool = false ; pub const SERVO_PREF_ENABLED_white_space : bool = false ; pub const SERVO_PREF_ENABLED_width : bool = false ; pub const SERVO_PREF_ENABLED_will_change : bool = false ; pub const SERVO_PREF_ENABLED__moz_window_dragging : bool = false ; pub const SERVO_PREF_ENABLED__moz_window_shadow : bool = false ; pub const SERVO_PREF_ENABLED__moz_window_opacity : bool = false ; pub const SERVO_PREF_ENABLED__moz_window_transform : bool = false ; pub const SERVO_PREF_ENABLED__moz_window_transform_origin : bool = false ; pub const SERVO_PREF_ENABLED_word_break : bool = false ; pub const SERVO_PREF_ENABLED_word_spacing : bool = false ; pub const SERVO_PREF_ENABLED_overflow_wrap : bool = false ; pub const SERVO_PREF_ENABLED_writing_mode : bool = false ; pub const SERVO_PREF_ENABLED_z_index : bool = false ; pub const SERVO_PREF_ENABLED_word_wrap : bool = false ; pub const SERVO_PREF_ENABLED__moz_transform_origin : bool = true ; pub const SERVO_PREF_ENABLED__moz_perspective_origin : bool = true ; pub const SERVO_PREF_ENABLED__moz_perspective : bool = true ; pub const SERVO_PREF_ENABLED__moz_transform_style : bool = true ; pub const SERVO_PREF_ENABLED__moz_backface_visibility : bool = true ; pub const SERVO_PREF_ENABLED__moz_border_image : bool = true ; pub const SERVO_PREF_ENABLED__moz_transition : bool = true ; pub const SERVO_PREF_ENABLED__moz_transition_delay : bool = true ; pub const SERVO_PREF_ENABLED__moz_transition_duration : bool = true ; pub const SERVO_PREF_ENABLED__moz_transition_property : bool = true ; pub const SERVO_PREF_ENABLED__moz_transition_timing_function : bool = true ; pub const SERVO_PREF_ENABLED__moz_animation : bool = true ; pub const SERVO_PREF_ENABLED__moz_animation_delay : bool = true ; pub const SERVO_PREF_ENABLED__moz_animation_direction : bool = true ; pub const SERVO_PREF_ENABLED__moz_animation_duration : bool = true ; pub const SERVO_PREF_ENABLED__moz_animation_fill_mode : bool = true ; pub const SERVO_PREF_ENABLED__moz_animation_iteration_count : bool = true ; pub const SERVO_PREF_ENABLED__moz_animation_name : bool = true ; pub const SERVO_PREF_ENABLED__moz_animation_play_state : bool = true ; pub const SERVO_PREF_ENABLED__moz_animation_timing_function : bool = true ; pub const SERVO_PREF_ENABLED__moz_box_sizing : bool = true ; pub const SERVO_PREF_ENABLED__moz_font_feature_settings : bool = true ; pub const SERVO_PREF_ENABLED__moz_font_language_override : bool = true ; pub const SERVO_PREF_ENABLED__moz_padding_end : bool = false ; pub const SERVO_PREF_ENABLED__moz_padding_start : bool = false ; pub const SERVO_PREF_ENABLED__moz_margin_end : bool = false ; pub const SERVO_PREF_ENABLED__moz_margin_start : bool = false ; pub const SERVO_PREF_ENABLED__moz_border_end : bool = false ; pub const SERVO_PREF_ENABLED__moz_border_end_color : bool = false ; pub const SERVO_PREF_ENABLED__moz_border_end_style : bool = false ; pub const SERVO_PREF_ENABLED__moz_border_end_width : bool = false ; pub const SERVO_PREF_ENABLED__moz_border_start : bool = false ; pub const SERVO_PREF_ENABLED__moz_border_start_color : bool = false ; pub const SERVO_PREF_ENABLED__moz_border_start_style : bool = false ; pub const SERVO_PREF_ENABLED__moz_border_start_width : bool = false ; pub const SERVO_PREF_ENABLED__moz_hyphens : bool = false ; pub const SERVO_PREF_ENABLED__moz_column_count : bool = false ; pub const SERVO_PREF_ENABLED__moz_column_fill : bool = false ; pub const SERVO_PREF_ENABLED__moz_column_gap : bool = false ; pub const SERVO_PREF_ENABLED__moz_column_rule : bool = false ; pub const SERVO_PREF_ENABLED__moz_column_rule_color : bool = false ; pub const SERVO_PREF_ENABLED__moz_column_rule_style : bool = false ; pub const SERVO_PREF_ENABLED__moz_column_rule_width : bool = false ; pub const SERVO_PREF_ENABLED__moz_column_span : bool = true ; pub const SERVO_PREF_ENABLED__moz_column_width : bool = false ; pub const SERVO_PREF_ENABLED__moz_columns : bool = false ; pub const SERVO_PREF_ENABLED__webkit_animation : bool = true ; pub const SERVO_PREF_ENABLED__webkit_animation_delay : bool = true ; pub const SERVO_PREF_ENABLED__webkit_animation_direction : bool = true ; pub const SERVO_PREF_ENABLED__webkit_animation_duration : bool = true ; pub const SERVO_PREF_ENABLED__webkit_animation_fill_mode : bool = true ; pub const SERVO_PREF_ENABLED__webkit_animation_iteration_count : bool = true ; pub const SERVO_PREF_ENABLED__webkit_animation_name : bool = true ; pub const SERVO_PREF_ENABLED__webkit_animation_play_state : bool = true ; pub const SERVO_PREF_ENABLED__webkit_animation_timing_function : bool = true ; pub const SERVO_PREF_ENABLED__webkit_filter : bool = true ; pub const SERVO_PREF_ENABLED__webkit_text_size_adjust : bool = true ; pub const SERVO_PREF_ENABLED__webkit_transform : bool = true ; pub const SERVO_PREF_ENABLED__webkit_transform_origin : bool = true ; pub const SERVO_PREF_ENABLED__webkit_transform_style : bool = true ; pub const SERVO_PREF_ENABLED__webkit_backface_visibility : bool = true ; pub const SERVO_PREF_ENABLED__webkit_perspective : bool = true ; pub const SERVO_PREF_ENABLED__webkit_perspective_origin : bool = true ; pub const SERVO_PREF_ENABLED__webkit_transition : bool = true ; pub const SERVO_PREF_ENABLED__webkit_transition_delay : bool = true ; pub const SERVO_PREF_ENABLED__webkit_transition_duration : bool = true ; pub const SERVO_PREF_ENABLED__webkit_transition_property : bool = true ; pub const SERVO_PREF_ENABLED__webkit_transition_timing_function : bool = true ; pub const SERVO_PREF_ENABLED__webkit_border_radius : bool = true ; pub const SERVO_PREF_ENABLED__webkit_border_top_left_radius : bool = true ; pub const SERVO_PREF_ENABLED__webkit_border_top_right_radius : bool = true ; pub const SERVO_PREF_ENABLED__webkit_border_bottom_left_radius : bool = true ; pub const SERVO_PREF_ENABLED__webkit_border_bottom_right_radius : bool = true ; pub const SERVO_PREF_ENABLED__webkit_background_clip : bool = true ; pub const SERVO_PREF_ENABLED__webkit_background_origin : bool = true ; pub const SERVO_PREF_ENABLED__webkit_background_size : bool = true ; pub const SERVO_PREF_ENABLED__webkit_border_image : bool = true ; pub const SERVO_PREF_ENABLED__webkit_box_shadow : bool = true ; pub const SERVO_PREF_ENABLED__webkit_box_sizing : bool = true ; pub const SERVO_PREF_ENABLED__webkit_box_flex : bool = true ; pub const SERVO_PREF_ENABLED__webkit_box_ordinal_group : bool = true ; pub const SERVO_PREF_ENABLED__webkit_box_orient : bool = true ; pub const SERVO_PREF_ENABLED__webkit_box_direction : bool = true ; pub const SERVO_PREF_ENABLED__webkit_box_align : bool = true ; pub const SERVO_PREF_ENABLED__webkit_box_pack : bool = true ; pub const SERVO_PREF_ENABLED__webkit_flex_direction : bool = true ; pub const SERVO_PREF_ENABLED__webkit_flex_wrap : bool = true ; pub const SERVO_PREF_ENABLED__webkit_flex_flow : bool = true ; pub const SERVO_PREF_ENABLED__webkit_order : bool = true ; pub const SERVO_PREF_ENABLED__webkit_flex : bool = true ; pub const SERVO_PREF_ENABLED__webkit_flex_grow : bool = true ; pub const SERVO_PREF_ENABLED__webkit_flex_shrink : bool = true ; pub const SERVO_PREF_ENABLED__webkit_flex_basis : bool = true ; pub const SERVO_PREF_ENABLED__webkit_justify_content : bool = true ; pub const SERVO_PREF_ENABLED__webkit_align_items : bool = true ; pub const SERVO_PREF_ENABLED__webkit_align_self : bool = true ; pub const SERVO_PREF_ENABLED__webkit_align_content : bool = true ; pub const SERVO_PREF_ENABLED__webkit_user_select : bool = true ; pub const SERVO_PREF_ENABLED__webkit_mask : bool = true ; pub const SERVO_PREF_ENABLED__webkit_mask_clip : bool = true ; pub const SERVO_PREF_ENABLED__webkit_mask_composite : bool = true ; pub const SERVO_PREF_ENABLED__webkit_mask_image : bool = true ; pub const SERVO_PREF_ENABLED__webkit_mask_origin : bool = true ; pub const SERVO_PREF_ENABLED__webkit_mask_position : bool = true ; pub const SERVO_PREF_ENABLED__webkit_mask_position_x : bool = true ; pub const SERVO_PREF_ENABLED__webkit_mask_position_y : bool = true ; pub const SERVO_PREF_ENABLED__webkit_mask_repeat : bool = true ; pub const SERVO_PREF_ENABLED__webkit_mask_size : bool = true ; 
 /// Utility class to handle animated style values 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct StyleAnimationValue { pub _bindgen_opaque_blob : [ u64 ; 2usize ] , } pub const StyleAnimationValue_Unit_eUnit_Null : root :: mozilla :: StyleAnimationValue_Unit = 0 ; pub const StyleAnimationValue_Unit_eUnit_Normal : root :: mozilla :: StyleAnimationValue_Unit = 1 ; pub const StyleAnimationValue_Unit_eUnit_Auto : root :: mozilla :: StyleAnimationValue_Unit = 2 ; pub const StyleAnimationValue_Unit_eUnit_None : root :: mozilla :: StyleAnimationValue_Unit = 3 ; pub const StyleAnimationValue_Unit_eUnit_Enumerated : root :: mozilla :: StyleAnimationValue_Unit = 4 ; pub const StyleAnimationValue_Unit_eUnit_Visibility : root :: mozilla :: StyleAnimationValue_Unit = 5 ; pub const StyleAnimationValue_Unit_eUnit_Integer : root :: mozilla :: StyleAnimationValue_Unit = 6 ; pub const StyleAnimationValue_Unit_eUnit_Coord : root :: mozilla :: StyleAnimationValue_Unit = 7 ; pub const StyleAnimationValue_Unit_eUnit_Percent : root :: mozilla :: StyleAnimationValue_Unit = 8 ; pub const StyleAnimationValue_Unit_eUnit_Float : root :: mozilla :: StyleAnimationValue_Unit = 9 ; pub const StyleAnimationValue_Unit_eUnit_Color : root :: mozilla :: StyleAnimationValue_Unit = 10 ; pub const StyleAnimationValue_Unit_eUnit_CurrentColor : root :: mozilla :: StyleAnimationValue_Unit = 11 ; pub const StyleAnimationValue_Unit_eUnit_ComplexColor : root :: mozilla :: StyleAnimationValue_Unit = 12 ; pub const StyleAnimationValue_Unit_eUnit_Calc : root :: mozilla :: StyleAnimationValue_Unit = 13 ; pub const StyleAnimationValue_Unit_eUnit_ObjectPosition : root :: mozilla :: StyleAnimationValue_Unit = 14 ; pub const StyleAnimationValue_Unit_eUnit_URL : root :: mozilla :: StyleAnimationValue_Unit = 15 ; pub const StyleAnimationValue_Unit_eUnit_DiscreteCSSValue : root :: mozilla :: StyleAnimationValue_Unit = 16 ; pub const StyleAnimationValue_Unit_eUnit_CSSValuePair : root :: mozilla :: StyleAnimationValue_Unit = 17 ; pub const StyleAnimationValue_Unit_eUnit_CSSValueTriplet : root :: mozilla :: StyleAnimationValue_Unit = 18 ; pub const StyleAnimationValue_Unit_eUnit_CSSRect : root :: mozilla :: StyleAnimationValue_Unit = 19 ; pub const StyleAnimationValue_Unit_eUnit_Dasharray : root :: mozilla :: StyleAnimationValue_Unit = 20 ; pub const StyleAnimationValue_Unit_eUnit_Shadow : root :: mozilla :: StyleAnimationValue_Unit = 21 ; pub const StyleAnimationValue_Unit_eUnit_Shape : root :: mozilla :: StyleAnimationValue_Unit = 22 ; pub const StyleAnimationValue_Unit_eUnit_Filter : root :: mozilla :: StyleAnimationValue_Unit = 23 ; pub const StyleAnimationValue_Unit_eUnit_Transform : root :: mozilla :: StyleAnimationValue_Unit = 24 ; pub const StyleAnimationValue_Unit_eUnit_BackgroundPositionCoord : root :: mozilla :: StyleAnimationValue_Unit = 25 ; pub const StyleAnimationValue_Unit_eUnit_CSSValuePairList : root :: mozilla :: StyleAnimationValue_Unit = 26 ; pub const StyleAnimationValue_Unit_eUnit_UnparsedString : root :: mozilla :: StyleAnimationValue_Unit = 27 ; pub type StyleAnimationValue_Unit = :: std :: os :: raw :: c_uint ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct StyleAnimationValue__bindgen_ty_1 { pub mInt : root :: __BindgenUnionField < i32 > , pub mCoord : root :: __BindgenUnionField < root :: nscoord > , pub mFloat : root :: __BindgenUnionField < f32 > , pub mCSSValue : root :: __BindgenUnionField < * mut root :: nsCSSValue > , pub mCSSValuePair : root :: __BindgenUnionField < * mut root :: nsCSSValuePair > , pub mCSSValueTriplet : root :: __BindgenUnionField < * mut root :: nsCSSValueTriplet > , pub mCSSRect : root :: __BindgenUnionField < * mut root :: nsCSSRect > , pub mCSSValueArray : root :: __BindgenUnionField < * mut root :: nsCSSValue_Array > , pub mCSSValueList : root :: __BindgenUnionField < * mut root :: nsCSSValueList > , pub mCSSValueSharedList : root :: __BindgenUnionField < * mut root :: nsCSSValueSharedList > , pub mCSSValuePairList : root :: __BindgenUnionField < * mut root :: nsCSSValuePairList > , pub mString : root :: __BindgenUnionField < * mut root :: nsStringBuffer > , pub mComplexColor : root :: __BindgenUnionField < * mut root :: mozilla :: css :: ComplexColorValue > , pub bindgen_union_field : u64 , } # [ test ] fn bindgen_test_layout_StyleAnimationValue__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < StyleAnimationValue__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( StyleAnimationValue__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < StyleAnimationValue__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( StyleAnimationValue__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) ) . mInt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify ! ( mInt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) ) . mCoord as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify ! ( mCoord ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) ) . mFloat as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify ! ( mFloat ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) ) . mCSSValue as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify ! ( mCSSValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) ) . mCSSValuePair as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify ! ( mCSSValuePair ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) ) . mCSSValueTriplet as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify ! ( mCSSValueTriplet ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) ) . mCSSRect as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify ! ( mCSSRect ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) ) . mCSSValueArray as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify ! ( mCSSValueArray ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) ) . mCSSValueList as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify ! ( mCSSValueList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) ) . mCSSValueSharedList as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify ! ( mCSSValueSharedList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) ) . mCSSValuePairList as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify ! ( mCSSValuePairList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) ) . mString as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify ! ( mString ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) ) . mComplexColor as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify ! ( mComplexColor ) ) ) ; } impl Clone for StyleAnimationValue__bindgen_ty_1 { fn clone ( & self ) -> Self { * self } } pub const StyleAnimationValue_IntegerConstructorType_IntegerConstructor : root :: mozilla :: StyleAnimationValue_IntegerConstructorType = 0 ; pub type StyleAnimationValue_IntegerConstructorType = :: std :: os :: raw :: c_uint ; pub const StyleAnimationValue_CoordConstructorType_CoordConstructor : root :: mozilla :: StyleAnimationValue_CoordConstructorType = 0 ; pub type StyleAnimationValue_CoordConstructorType = :: std :: os :: raw :: c_uint ; pub const StyleAnimationValue_PercentConstructorType_PercentConstructor : root :: mozilla :: StyleAnimationValue_PercentConstructorType = 0 ; pub type StyleAnimationValue_PercentConstructorType = :: std :: os :: raw :: c_uint ; pub const StyleAnimationValue_FloatConstructorType_FloatConstructor : root :: mozilla :: StyleAnimationValue_FloatConstructorType = 0 ; pub type StyleAnimationValue_FloatConstructorType = :: std :: os :: raw :: c_uint ; pub const StyleAnimationValue_ColorConstructorType_ColorConstructor : root :: mozilla :: StyleAnimationValue_ColorConstructorType = 0 ; pub type StyleAnimationValue_ColorConstructorType = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_StyleAnimationValue ( ) { assert_eq ! ( :: std :: mem :: size_of :: < StyleAnimationValue > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( StyleAnimationValue ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < StyleAnimationValue > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( StyleAnimationValue ) ) ) ; } impl Clone for StyleAnimationValue { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct AnimationValue { pub mGecko : root :: mozilla :: StyleAnimationValue , pub mServo : root :: RefPtr < root :: RawServoAnimationValue > , } # [ test ] fn bindgen_test_layout_AnimationValue ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AnimationValue > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( AnimationValue ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AnimationValue > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AnimationValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AnimationValue ) ) . mGecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AnimationValue ) , "::" , stringify ! ( mGecko ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AnimationValue ) ) . mServo as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AnimationValue ) , "::" , stringify ! ( mServo ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct PropertyStyleAnimationValuePair { pub mProperty : root :: nsCSSPropertyID , pub mValue : root :: mozilla :: AnimationValue , } # [ test ] fn bindgen_test_layout_PropertyStyleAnimationValuePair ( ) { assert_eq ! ( :: std :: mem :: size_of :: < PropertyStyleAnimationValuePair > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( PropertyStyleAnimationValuePair ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < PropertyStyleAnimationValuePair > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( PropertyStyleAnimationValuePair ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PropertyStyleAnimationValuePair ) ) . mProperty as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( PropertyStyleAnimationValuePair ) , "::" , stringify ! ( mProperty ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PropertyStyleAnimationValuePair ) ) . mValue as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( PropertyStyleAnimationValuePair ) , "::" , stringify ! ( mValue ) ) ) ; } # [ repr ( C ) ] pub struct StyleSheetInfo__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; 
 /// Struct for data common to CSSStyleSheetInner and ServoStyleSheet. 
 # [ repr ( C ) ] pub struct StyleSheetInfo { pub vtable_ : * const StyleSheetInfo__bindgen_vtable , pub mSheetURI : root :: nsCOMPtr , pub mOriginalSheetURI : root :: nsCOMPtr , pub mBaseURI : root :: nsCOMPtr , pub mPrincipal : root :: nsCOMPtr , pub mCORSMode : root :: mozilla :: CORSMode , pub mReferrerPolicy : root :: mozilla :: StyleSheetInfo_ReferrerPolicy , pub mIntegrity : root :: mozilla :: dom :: SRIMetadata , pub mComplete : bool , pub mFirstChild : root :: RefPtr < root :: mozilla :: StyleSheet > , pub mSheets : [ u64 ; 10usize ] , pub mSourceMapURL : ::nsstring::nsStringRepr , pub mSourceMapURLFromComment : ::nsstring::nsStringRepr , pub mSourceURL : ::nsstring::nsStringRepr , } pub use self :: super :: super :: root :: mozilla :: net :: ReferrerPolicy as StyleSheetInfo_ReferrerPolicy ; # [ test ] fn bindgen_test_layout_StyleSheetInfo ( ) { assert_eq ! ( :: std :: mem :: size_of :: < StyleSheetInfo > ( ) , 240usize , concat ! ( "Size of: " , stringify ! ( StyleSheetInfo ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < StyleSheetInfo > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( StyleSheetInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleSheetInfo ) ) . mSheetURI as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( StyleSheetInfo ) , "::" , stringify ! ( mSheetURI ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleSheetInfo ) ) . mOriginalSheetURI as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( StyleSheetInfo ) , "::" , stringify ! ( mOriginalSheetURI ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleSheetInfo ) ) . mBaseURI as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( StyleSheetInfo ) , "::" , stringify ! ( mBaseURI ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleSheetInfo ) ) . mPrincipal as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( StyleSheetInfo ) , "::" , stringify ! ( mPrincipal ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleSheetInfo ) ) . mCORSMode as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( StyleSheetInfo ) , "::" , stringify ! ( mCORSMode ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleSheetInfo ) ) . mReferrerPolicy as * const _ as usize } , 44usize , concat ! ( "Alignment of field: " , stringify ! ( StyleSheetInfo ) , "::" , stringify ! ( mReferrerPolicy ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleSheetInfo ) ) . mIntegrity as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( StyleSheetInfo ) , "::" , stringify ! ( mIntegrity ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleSheetInfo ) ) . mComplete as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( StyleSheetInfo ) , "::" , stringify ! ( mComplete ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleSheetInfo ) ) . mFirstChild as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( StyleSheetInfo ) , "::" , stringify ! ( mFirstChild ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleSheetInfo ) ) . mSheets as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( StyleSheetInfo ) , "::" , stringify ! ( mSheets ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleSheetInfo ) ) . mSourceMapURL as * const _ as usize } , 192usize , concat ! ( "Alignment of field: " , stringify ! ( StyleSheetInfo ) , "::" , stringify ! ( mSourceMapURL ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleSheetInfo ) ) . mSourceMapURLFromComment as * const _ as usize } , 208usize , concat ! ( "Alignment of field: " , stringify ! ( StyleSheetInfo ) , "::" , stringify ! ( mSourceMapURLFromComment ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const StyleSheetInfo ) ) . mSourceURL as * const _ as usize } , 224usize , concat ! ( "Alignment of field: " , stringify ! ( StyleSheetInfo ) , "::" , stringify ! ( mSourceURL ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ServoCSSRuleList { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] pub struct ServoStyleSheetInner { pub _base : root :: mozilla :: StyleSheetInfo , pub mContents : root :: RefPtr < root :: RawServoStyleSheetContents > , pub mURLData : root :: RefPtr < root :: mozilla :: URLExtraData > , } # [ test ] fn bindgen_test_layout_ServoStyleSheetInner ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ServoStyleSheetInner > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( ServoStyleSheetInner ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ServoStyleSheetInner > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ServoStyleSheetInner ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSheetInner ) ) . mContents as * const _ as usize } , 240usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSheetInner ) , "::" , stringify ! ( mContents ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSheetInner ) ) . mURLData as * const _ as usize } , 248usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSheetInner ) , "::" , stringify ! ( mURLData ) ) ) ; } # [ repr ( C ) ] pub struct ServoStyleSheet { pub _base : root :: mozilla :: StyleSheet , pub mRuleList : root :: RefPtr < root :: mozilla :: ServoCSSRuleList > , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct ServoStyleSheet_cycleCollection { pub _base : root :: mozilla :: StyleSheet_cycleCollection , } # [ test ] fn bindgen_test_layout_ServoStyleSheet_cycleCollection ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ServoStyleSheet_cycleCollection > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ServoStyleSheet_cycleCollection ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ServoStyleSheet_cycleCollection > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ServoStyleSheet_cycleCollection ) ) ) ; } impl Clone for ServoStyleSheet_cycleCollection { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ServoStyleSheet_COMTypeInfo { pub _address : u8 , } extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla15ServoStyleSheet21_cycleCollectorGlobalE" ] 
 pub static mut  ServoStyleSheet__cycleCollectorGlobal  :  root :: mozilla :: ServoStyleSheet_cycleCollection ;
} # [ test ] fn bindgen_test_layout_ServoStyleSheet ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ServoStyleSheet > ( ) , 144usize , concat ! ( "Size of: " , stringify ! ( ServoStyleSheet ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ServoStyleSheet > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ServoStyleSheet ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSheet ) ) . mRuleList as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSheet ) , "::" , stringify ! ( mRuleList ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct URIPrincipalReferrerPolicyAndCORSModeHashKey { pub _base : root :: nsURIHashKey , pub mPrincipal : root :: nsCOMPtr , pub mCORSMode : root :: mozilla :: CORSMode , pub mReferrerPolicy : root :: mozilla :: URIPrincipalReferrerPolicyAndCORSModeHashKey_ReferrerPolicy , } pub type URIPrincipalReferrerPolicyAndCORSModeHashKey_KeyType = * mut root :: mozilla :: URIPrincipalReferrerPolicyAndCORSModeHashKey ; pub type URIPrincipalReferrerPolicyAndCORSModeHashKey_KeyTypePointer = * const root :: mozilla :: URIPrincipalReferrerPolicyAndCORSModeHashKey ; pub use self :: super :: super :: root :: mozilla :: net :: ReferrerPolicy as URIPrincipalReferrerPolicyAndCORSModeHashKey_ReferrerPolicy ; pub const URIPrincipalReferrerPolicyAndCORSModeHashKey_ALLOW_MEMMOVE : root :: mozilla :: URIPrincipalReferrerPolicyAndCORSModeHashKey__bindgen_ty_1 = 1 ; pub type URIPrincipalReferrerPolicyAndCORSModeHashKey__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_URIPrincipalReferrerPolicyAndCORSModeHashKey ( ) { assert_eq ! ( :: std :: mem :: size_of :: < URIPrincipalReferrerPolicyAndCORSModeHashKey > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( URIPrincipalReferrerPolicyAndCORSModeHashKey ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < URIPrincipalReferrerPolicyAndCORSModeHashKey > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( URIPrincipalReferrerPolicyAndCORSModeHashKey ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const URIPrincipalReferrerPolicyAndCORSModeHashKey ) ) . mPrincipal as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( URIPrincipalReferrerPolicyAndCORSModeHashKey ) , "::" , stringify ! ( mPrincipal ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const URIPrincipalReferrerPolicyAndCORSModeHashKey ) ) . mCORSMode as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( URIPrincipalReferrerPolicyAndCORSModeHashKey ) , "::" , stringify ! ( mCORSMode ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const URIPrincipalReferrerPolicyAndCORSModeHashKey ) ) . mReferrerPolicy as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( URIPrincipalReferrerPolicyAndCORSModeHashKey ) , "::" , stringify ! ( mReferrerPolicy ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct ComputedTimingFunction { pub mType : root :: nsTimingFunction_Type , pub mTimingFunction : root :: nsSMILKeySpline , pub mStepsOrFrames : u32 , } pub const ComputedTimingFunction_BeforeFlag_Unset : root :: mozilla :: ComputedTimingFunction_BeforeFlag = 0 ; pub const ComputedTimingFunction_BeforeFlag_Set : root :: mozilla :: ComputedTimingFunction_BeforeFlag = 1 ; pub type ComputedTimingFunction_BeforeFlag = :: std :: os :: raw :: c_int ; # [ test ] fn bindgen_test_layout_ComputedTimingFunction ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ComputedTimingFunction > ( ) , 136usize , concat ! ( "Size of: " , stringify ! ( ComputedTimingFunction ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ComputedTimingFunction > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ComputedTimingFunction ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ComputedTimingFunction ) ) . mType as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ComputedTimingFunction ) , "::" , stringify ! ( mType ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ComputedTimingFunction ) ) . mTimingFunction as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ComputedTimingFunction ) , "::" , stringify ! ( mTimingFunction ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ComputedTimingFunction ) ) . mStepsOrFrames as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( ComputedTimingFunction ) , "::" , stringify ! ( mStepsOrFrames ) ) ) ; } impl Clone for ComputedTimingFunction { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct AnimationPropertySegment { pub mFromKey : f32 , pub mToKey : f32 , pub mFromValue : root :: mozilla :: AnimationValue , pub mToValue : root :: mozilla :: AnimationValue , pub mTimingFunction : [ u64 ; 18usize ] , pub mFromComposite : root :: mozilla :: dom :: CompositeOperation , pub mToComposite : root :: mozilla :: dom :: CompositeOperation , } # [ test ] fn bindgen_test_layout_AnimationPropertySegment ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AnimationPropertySegment > ( ) , 208usize , concat ! ( "Size of: " , stringify ! ( AnimationPropertySegment ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AnimationPropertySegment > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AnimationPropertySegment ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AnimationPropertySegment ) ) . mFromKey as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AnimationPropertySegment ) , "::" , stringify ! ( mFromKey ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AnimationPropertySegment ) ) . mToKey as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( AnimationPropertySegment ) , "::" , stringify ! ( mToKey ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AnimationPropertySegment ) ) . mFromValue as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AnimationPropertySegment ) , "::" , stringify ! ( mFromValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AnimationPropertySegment ) ) . mToValue as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( AnimationPropertySegment ) , "::" , stringify ! ( mToValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AnimationPropertySegment ) ) . mTimingFunction as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( AnimationPropertySegment ) , "::" , stringify ! ( mTimingFunction ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AnimationPropertySegment ) ) . mFromComposite as * const _ as usize } , 200usize , concat ! ( "Alignment of field: " , stringify ! ( AnimationPropertySegment ) , "::" , stringify ! ( mFromComposite ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AnimationPropertySegment ) ) . mToComposite as * const _ as usize } , 201usize , concat ! ( "Alignment of field: " , stringify ! ( AnimationPropertySegment ) , "::" , stringify ! ( mToComposite ) ) ) ; } 
 /// A ValueCalculator class that performs additional checks before performing
        /// arithmetic operations such that if either operand is Forever (or the
        /// negative equivalent) the result remains Forever (or the negative equivalent
        /// as appropriate).
        ///
        /// Currently this only checks if either argument to each operation is
        /// Forever/-Forever. However, it is possible that, for example,
        /// aA + aB > INT64_MAX (or < INT64_MIN).
        ///
        /// We currently don't check for that case since we don't expect that to
        /// happen often except under test conditions in which case the wrapping
        /// behavior is probably acceptable. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct StickyTimeDurationValueCalculator { pub _address : u8 , } # [ test ] fn bindgen_test_layout_StickyTimeDurationValueCalculator ( ) { assert_eq ! ( :: std :: mem :: size_of :: < StickyTimeDurationValueCalculator > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( StickyTimeDurationValueCalculator ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < StickyTimeDurationValueCalculator > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( StickyTimeDurationValueCalculator ) ) ) ; } impl Clone for StickyTimeDurationValueCalculator { fn clone ( & self ) -> Self { * self } } 
 /// Specialization of BaseTimeDuration that uses
        /// StickyTimeDurationValueCalculator for arithmetic on the mValue member.
        ///
        /// Use this class when you need a time duration that is expected to hold values
        /// of Forever (or the negative equivalent) *and* when you expect that
        /// time duration to be used in arithmetic operations (and not just value
        /// comparisons). 
 pub type StickyTimeDuration = root :: mozilla :: BaseTimeDuration ; 
 /// Stores the results of calculating the timing properties of an animation
        /// at a given sample time. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct ComputedTiming { pub mActiveDuration : root :: mozilla :: StickyTimeDuration , pub mActiveTime : root :: mozilla :: StickyTimeDuration , pub mEndTime : root :: mozilla :: StickyTimeDuration , pub mProgress : [ u64 ; 2usize ] , pub mCurrentIteration : u64 , pub mIterations : f64 , pub mIterationStart : f64 , pub mDuration : root :: mozilla :: StickyTimeDuration , pub mFill : root :: mozilla :: dom :: FillMode , pub mPhase : root :: mozilla :: ComputedTiming_AnimationPhase , pub mBeforeFlag : root :: mozilla :: ComputedTimingFunction_BeforeFlag , } pub const ComputedTiming_AnimationPhase_Idle : root :: mozilla :: ComputedTiming_AnimationPhase = 0 ; pub const ComputedTiming_AnimationPhase_Before : root :: mozilla :: ComputedTiming_AnimationPhase = 1 ; pub const ComputedTiming_AnimationPhase_Active : root :: mozilla :: ComputedTiming_AnimationPhase = 2 ; pub const ComputedTiming_AnimationPhase_After : root :: mozilla :: ComputedTiming_AnimationPhase = 3 ; pub type ComputedTiming_AnimationPhase = :: std :: os :: raw :: c_int ; # [ test ] fn bindgen_test_layout_ComputedTiming ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ComputedTiming > ( ) , 88usize , concat ! ( "Size of: " , stringify ! ( ComputedTiming ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ComputedTiming > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ComputedTiming ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ComputedTiming ) ) . mActiveDuration as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ComputedTiming ) , "::" , stringify ! ( mActiveDuration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ComputedTiming ) ) . mActiveTime as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ComputedTiming ) , "::" , stringify ! ( mActiveTime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ComputedTiming ) ) . mEndTime as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( ComputedTiming ) , "::" , stringify ! ( mEndTime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ComputedTiming ) ) . mProgress as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( ComputedTiming ) , "::" , stringify ! ( mProgress ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ComputedTiming ) ) . mCurrentIteration as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( ComputedTiming ) , "::" , stringify ! ( mCurrentIteration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ComputedTiming ) ) . mIterations as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( ComputedTiming ) , "::" , stringify ! ( mIterations ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ComputedTiming ) ) . mIterationStart as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( ComputedTiming ) , "::" , stringify ! ( mIterationStart ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ComputedTiming ) ) . mDuration as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( ComputedTiming ) , "::" , stringify ! ( mDuration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ComputedTiming ) ) . mFill as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( ComputedTiming ) , "::" , stringify ! ( mFill ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ComputedTiming ) ) . mPhase as * const _ as usize } , 76usize , concat ! ( "Alignment of field: " , stringify ! ( ComputedTiming ) , "::" , stringify ! ( mPhase ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ComputedTiming ) ) . mBeforeFlag as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( ComputedTiming ) , "::" , stringify ! ( mBeforeFlag ) ) ) ; } impl Clone for ComputedTiming { fn clone ( & self ) -> Self { * self } } 
 /// A property-value pair specified on a keyframe. 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct PropertyValuePair { pub mProperty : root :: nsCSSPropertyID , pub mValue : root :: nsCSSValue , pub mServoDeclarationBlock : root :: RefPtr < root :: RawServoDeclarationBlock > , } # [ test ] fn bindgen_test_layout_PropertyValuePair ( ) { assert_eq ! ( :: std :: mem :: size_of :: < PropertyValuePair > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( PropertyValuePair ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < PropertyValuePair > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( PropertyValuePair ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PropertyValuePair ) ) . mProperty as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( PropertyValuePair ) , "::" , stringify ! ( mProperty ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PropertyValuePair ) ) . mValue as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( PropertyValuePair ) , "::" , stringify ! ( mValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PropertyValuePair ) ) . mServoDeclarationBlock as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( PropertyValuePair ) , "::" , stringify ! ( mServoDeclarationBlock ) ) ) ; } 
 /// A single keyframe.
        ///
        /// This is the canonical form in which keyframe effects are stored and
        /// corresponds closely to the type of objects returned via the getKeyframes()
        /// API.
        ///
        /// Before computing an output animation value, however, we flatten these frames
        /// down to a series of per-property value arrays where we also resolve any
        /// overlapping shorthands/longhands, convert specified CSS values to computed
        /// values, etc.
        ///
        /// When the target element or style context changes, however, we rebuild these
        /// per-property arrays from the original list of keyframes objects. As a result,
        /// these objects represent the master definition of the effect's values. 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct Keyframe { pub mOffset : [ u64 ; 2usize ] , pub mComputedOffset : f64 , pub mTimingFunction : [ u64 ; 18usize ] , pub mComposite : [ u8 ; 2usize ] , pub mPropertyValues : root :: nsTArray < root :: mozilla :: PropertyValuePair > , } pub const Keyframe_kComputedOffsetNotSet : f64 = -1. ; # [ test ] fn bindgen_test_layout_Keyframe ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Keyframe > ( ) , 184usize , concat ! ( "Size of: " , stringify ! ( Keyframe ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Keyframe > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Keyframe ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Keyframe ) ) . mOffset as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( Keyframe ) , "::" , stringify ! ( mOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Keyframe ) ) . mComputedOffset as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( Keyframe ) , "::" , stringify ! ( mComputedOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Keyframe ) ) . mTimingFunction as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( Keyframe ) , "::" , stringify ! ( mTimingFunction ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Keyframe ) ) . mComposite as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( Keyframe ) , "::" , stringify ! ( mComposite ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Keyframe ) ) . mPropertyValues as * const _ as usize } , 176usize , concat ! ( "Alignment of field: " , stringify ! ( Keyframe ) , "::" , stringify ! ( mPropertyValues ) ) ) ; } 
 /// A structure representing a single attribute name and value.
        ///
        /// This is pretty similar to the private nsAttrAndChildArray::InternalAttr. 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct ServoAttrSnapshot { pub mName : root :: nsAttrName , pub mValue : root :: nsAttrValue , } # [ test ] fn bindgen_test_layout_ServoAttrSnapshot ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ServoAttrSnapshot > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ServoAttrSnapshot ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ServoAttrSnapshot > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ServoAttrSnapshot ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoAttrSnapshot ) ) . mName as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ServoAttrSnapshot ) , "::" , stringify ! ( mName ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoAttrSnapshot ) ) . mValue as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ServoAttrSnapshot ) , "::" , stringify ! ( mValue ) ) ) ; } # [ repr ( u8 ) ] 
 /// A bitflags enum class used to determine what data does a ServoElementSnapshot
        /// contains. 
 # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum ServoElementSnapshotFlags { State = 1 , Attributes = 2 , Id = 4 , MaybeClass = 8 , OtherPseudoClassState = 16 , } 
 /// This class holds all non-tree-structural state of an element that might be
        /// used for selector matching eventually.
        ///
        /// This means the attributes, and the element state, such as :hover, :active,
        /// etc... 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct ServoElementSnapshot { pub mAttrs : root :: nsTArray < root :: mozilla :: ServoAttrSnapshot > , pub mClass : root :: nsAttrValue , pub mState : root :: mozilla :: ServoElementSnapshot_ServoStateType , pub mContains : root :: mozilla :: ServoElementSnapshot_Flags , pub _bitfield_1 : u8 , pub __bindgen_padding_0 : [ u16 ; 3usize ] , } pub type ServoElementSnapshot_BorrowedAttrInfo = root :: mozilla :: dom :: BorrowedAttrInfo ; pub type ServoElementSnapshot_Element = root :: mozilla :: dom :: Element ; pub type ServoElementSnapshot_ServoStateType = root :: mozilla :: EventStates_ServoType ; pub use self :: super :: super :: root :: mozilla :: ServoElementSnapshotFlags as ServoElementSnapshot_Flags ; # [ test ] fn bindgen_test_layout_ServoElementSnapshot ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ServoElementSnapshot > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( ServoElementSnapshot ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ServoElementSnapshot > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ServoElementSnapshot ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoElementSnapshot ) ) . mAttrs as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ServoElementSnapshot ) , "::" , stringify ! ( mAttrs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoElementSnapshot ) ) . mClass as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ServoElementSnapshot ) , "::" , stringify ! ( mClass ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoElementSnapshot ) ) . mState as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( ServoElementSnapshot ) , "::" , stringify ! ( mState ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoElementSnapshot ) ) . mContains as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( ServoElementSnapshot ) , "::" , stringify ! ( mContains ) ) ) ; } impl ServoElementSnapshot { # [ inline ] pub fn mIsHTMLElementInHTMLDocument ( & self ) -> bool { let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0x1 as u8 ; let val = ( unit_field_val & mask ) >> 0usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIsHTMLElementInHTMLDocument ( & mut self , val : bool ) { let mask = 0x1 as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 0usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn mIsInChromeDocument ( & self ) -> bool { let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0x2 as u8 ; let val = ( unit_field_val & mask ) >> 1usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIsInChromeDocument ( & mut self , val : bool ) { let mask = 0x2 as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 1usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn mSupportsLangAttr ( & self ) -> bool { let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0x4 as u8 ; let val = ( unit_field_val & mask ) >> 2usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mSupportsLangAttr ( & mut self , val : bool ) { let mask = 0x4 as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 2usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn mIsTableBorderNonzero ( & self ) -> bool { let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0x8 as u8 ; let val = ( unit_field_val & mask ) >> 3usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIsTableBorderNonzero ( & mut self , val : bool ) { let mask = 0x8 as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 3usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn mIsMozBrowserFrame ( & self ) -> bool { let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0x10 as u8 ; let val = ( unit_field_val & mask ) >> 4usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIsMozBrowserFrame ( & mut self , val : bool ) { let mask = 0x10 as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 4usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn mClassAttributeChanged ( & self ) -> bool { let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0x20 as u8 ; let val = ( unit_field_val & mask ) >> 5usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mClassAttributeChanged ( & mut self , val : bool ) { let mask = 0x20 as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 5usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn mIdAttributeChanged ( & self ) -> bool { let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0x40 as u8 ; let val = ( unit_field_val & mask ) >> 6usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIdAttributeChanged ( & mut self , val : bool ) { let mask = 0x40 as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 6usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn mOtherAttributeChanged ( & self ) -> bool { let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0x80 as u8 ; let val = ( unit_field_val & mask ) >> 7usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mOtherAttributeChanged ( & mut self , val : bool ) { let mask = 0x80 as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 7usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn new_bitfield_1 ( mIsHTMLElementInHTMLDocument : bool , mIsInChromeDocument : bool , mSupportsLangAttr : bool , mIsTableBorderNonzero : bool , mIsMozBrowserFrame : bool , mClassAttributeChanged : bool , mIdAttributeChanged : bool , mOtherAttributeChanged : bool ) -> u8 { ( ( ( ( ( ( ( ( 0 | ( ( mIsHTMLElementInHTMLDocument as u8 as u8 ) << 0usize ) & ( 0x1 as u8 ) ) | ( ( mIsInChromeDocument as u8 as u8 ) << 1usize ) & ( 0x2 as u8 ) ) | ( ( mSupportsLangAttr as u8 as u8 ) << 2usize ) & ( 0x4 as u8 ) ) | ( ( mIsTableBorderNonzero as u8 as u8 ) << 3usize ) & ( 0x8 as u8 ) ) | ( ( mIsMozBrowserFrame as u8 as u8 ) << 4usize ) & ( 0x10 as u8 ) ) | ( ( mClassAttributeChanged as u8 as u8 ) << 5usize ) & ( 0x20 as u8 ) ) | ( ( mIdAttributeChanged as u8 as u8 ) << 6usize ) & ( 0x40 as u8 ) ) | ( ( mOtherAttributeChanged as u8 as u8 ) << 7usize ) & ( 0x80 as u8 ) ) } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct ServoElementSnapshotTable { pub _base : [ u64 ; 4usize ] , } # [ test ] fn bindgen_test_layout_ServoElementSnapshotTable ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ServoElementSnapshotTable > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( ServoElementSnapshotTable ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ServoElementSnapshotTable > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ServoElementSnapshotTable ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct LookAndFeel { pub _address : u8 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum LookAndFeel_ColorID { eColorID_WindowBackground = 0 , eColorID_WindowForeground = 1 , eColorID_WidgetBackground = 2 , eColorID_WidgetForeground = 3 , eColorID_WidgetSelectBackground = 4 , eColorID_WidgetSelectForeground = 5 , eColorID_Widget3DHighlight = 6 , eColorID_Widget3DShadow = 7 , eColorID_TextBackground = 8 , eColorID_TextForeground = 9 , eColorID_TextSelectBackground = 10 , eColorID_TextSelectForeground = 11 , eColorID_TextSelectForegroundCustom = 12 , eColorID_TextSelectBackgroundDisabled = 13 , eColorID_TextSelectBackgroundAttention = 14 , eColorID_TextHighlightBackground = 15 , eColorID_TextHighlightForeground = 16 , eColorID_IMERawInputBackground = 17 , eColorID_IMERawInputForeground = 18 , eColorID_IMERawInputUnderline = 19 , eColorID_IMESelectedRawTextBackground = 20 , eColorID_IMESelectedRawTextForeground = 21 , eColorID_IMESelectedRawTextUnderline = 22 , eColorID_IMEConvertedTextBackground = 23 , eColorID_IMEConvertedTextForeground = 24 , eColorID_IMEConvertedTextUnderline = 25 , eColorID_IMESelectedConvertedTextBackground = 26 , eColorID_IMESelectedConvertedTextForeground = 27 , eColorID_IMESelectedConvertedTextUnderline = 28 , eColorID_SpellCheckerUnderline = 29 , eColorID_activeborder = 30 , eColorID_activecaption = 31 , eColorID_appworkspace = 32 , eColorID_background = 33 , eColorID_buttonface = 34 , eColorID_buttonhighlight = 35 , eColorID_buttonshadow = 36 , eColorID_buttontext = 37 , eColorID_captiontext = 38 , eColorID_graytext = 39 , eColorID_highlight = 40 , eColorID_highlighttext = 41 , eColorID_inactiveborder = 42 , eColorID_inactivecaption = 43 , eColorID_inactivecaptiontext = 44 , eColorID_infobackground = 45 , eColorID_infotext = 46 , eColorID_menu = 47 , eColorID_menutext = 48 , eColorID_scrollbar = 49 , eColorID_threeddarkshadow = 50 , eColorID_threedface = 51 , eColorID_threedhighlight = 52 , eColorID_threedlightshadow = 53 , eColorID_threedshadow = 54 , eColorID_window = 55 , eColorID_windowframe = 56 , eColorID_windowtext = 57 , eColorID__moz_buttondefault = 58 , eColorID__moz_field = 59 , eColorID__moz_fieldtext = 60 , eColorID__moz_dialog = 61 , eColorID__moz_dialogtext = 62 , eColorID__moz_dragtargetzone = 63 , eColorID__moz_cellhighlight = 64 , eColorID__moz_cellhighlighttext = 65 , eColorID__moz_html_cellhighlight = 66 , eColorID__moz_html_cellhighlighttext = 67 , eColorID__moz_buttonhoverface = 68 , eColorID__moz_buttonhovertext = 69 , eColorID__moz_menuhover = 70 , eColorID__moz_menuhovertext = 71 , eColorID__moz_menubartext = 72 , eColorID__moz_menubarhovertext = 73 , eColorID__moz_eventreerow = 74 , eColorID__moz_oddtreerow = 75 , eColorID__moz_mac_buttonactivetext = 76 , eColorID__moz_mac_chrome_active = 77 , eColorID__moz_mac_chrome_inactive = 78 , eColorID__moz_mac_defaultbuttontext = 79 , eColorID__moz_mac_focusring = 80 , eColorID__moz_mac_menuselect = 81 , eColorID__moz_mac_menushadow = 82 , eColorID__moz_mac_menutextdisable = 83 , eColorID__moz_mac_menutextselect = 84 , eColorID__moz_mac_disabledtoolbartext = 85 , eColorID__moz_mac_secondaryhighlight = 86 , eColorID__moz_mac_vibrancy_light = 87 , eColorID__moz_mac_vibrancy_dark = 88 , eColorID__moz_mac_vibrant_titlebar_light = 89 , eColorID__moz_mac_vibrant_titlebar_dark = 90 , eColorID__moz_mac_menupopup = 91 , eColorID__moz_mac_menuitem = 92 , eColorID__moz_mac_active_menuitem = 93 , eColorID__moz_mac_source_list = 94 , eColorID__moz_mac_source_list_selection = 95 , eColorID__moz_mac_active_source_list_selection = 96 , eColorID__moz_mac_tooltip = 97 , eColorID__moz_win_accentcolor = 98 , eColorID__moz_win_accentcolortext = 99 , eColorID__moz_win_mediatext = 100 , eColorID__moz_win_communicationstext = 101 , eColorID__moz_nativehyperlinktext = 102 , eColorID__moz_comboboxtext = 103 , eColorID__moz_combobox = 104 , eColorID__moz_gtk_info_bar_text = 105 , eColorID_LAST_COLOR = 106 , } pub const LookAndFeel_IntID_eIntID_CaretBlinkTime : root :: mozilla :: LookAndFeel_IntID = 0 ; pub const LookAndFeel_IntID_eIntID_CaretWidth : root :: mozilla :: LookAndFeel_IntID = 1 ; pub const LookAndFeel_IntID_eIntID_ShowCaretDuringSelection : root :: mozilla :: LookAndFeel_IntID = 2 ; pub const LookAndFeel_IntID_eIntID_SelectTextfieldsOnKeyFocus : root :: mozilla :: LookAndFeel_IntID = 3 ; pub const LookAndFeel_IntID_eIntID_SubmenuDelay : root :: mozilla :: LookAndFeel_IntID = 4 ; pub const LookAndFeel_IntID_eIntID_MenusCanOverlapOSBar : root :: mozilla :: LookAndFeel_IntID = 5 ; pub const LookAndFeel_IntID_eIntID_UseOverlayScrollbars : root :: mozilla :: LookAndFeel_IntID = 6 ; pub const LookAndFeel_IntID_eIntID_AllowOverlayScrollbarsOverlap : root :: mozilla :: LookAndFeel_IntID = 7 ; pub const LookAndFeel_IntID_eIntID_ShowHideScrollbars : root :: mozilla :: LookAndFeel_IntID = 8 ; pub const LookAndFeel_IntID_eIntID_SkipNavigatingDisabledMenuItem : root :: mozilla :: LookAndFeel_IntID = 9 ; pub const LookAndFeel_IntID_eIntID_DragThresholdX : root :: mozilla :: LookAndFeel_IntID = 10 ; pub const LookAndFeel_IntID_eIntID_DragThresholdY : root :: mozilla :: LookAndFeel_IntID = 11 ; pub const LookAndFeel_IntID_eIntID_UseAccessibilityTheme : root :: mozilla :: LookAndFeel_IntID = 12 ; pub const LookAndFeel_IntID_eIntID_ScrollArrowStyle : root :: mozilla :: LookAndFeel_IntID = 13 ; pub const LookAndFeel_IntID_eIntID_ScrollSliderStyle : root :: mozilla :: LookAndFeel_IntID = 14 ; pub const LookAndFeel_IntID_eIntID_ScrollButtonLeftMouseButtonAction : root :: mozilla :: LookAndFeel_IntID = 15 ; pub const LookAndFeel_IntID_eIntID_ScrollButtonMiddleMouseButtonAction : root :: mozilla :: LookAndFeel_IntID = 16 ; pub const LookAndFeel_IntID_eIntID_ScrollButtonRightMouseButtonAction : root :: mozilla :: LookAndFeel_IntID = 17 ; pub const LookAndFeel_IntID_eIntID_TreeOpenDelay : root :: mozilla :: LookAndFeel_IntID = 18 ; pub const LookAndFeel_IntID_eIntID_TreeCloseDelay : root :: mozilla :: LookAndFeel_IntID = 19 ; pub const LookAndFeel_IntID_eIntID_TreeLazyScrollDelay : root :: mozilla :: LookAndFeel_IntID = 20 ; pub const LookAndFeel_IntID_eIntID_TreeScrollDelay : root :: mozilla :: LookAndFeel_IntID = 21 ; pub const LookAndFeel_IntID_eIntID_TreeScrollLinesMax : root :: mozilla :: LookAndFeel_IntID = 22 ; pub const LookAndFeel_IntID_eIntID_TabFocusModel : root :: mozilla :: LookAndFeel_IntID = 23 ; pub const LookAndFeel_IntID_eIntID_ChosenMenuItemsShouldBlink : root :: mozilla :: LookAndFeel_IntID = 24 ; pub const LookAndFeel_IntID_eIntID_WindowsAccentColorInTitlebar : root :: mozilla :: LookAndFeel_IntID = 25 ; pub const LookAndFeel_IntID_eIntID_WindowsDefaultTheme : root :: mozilla :: LookAndFeel_IntID = 26 ; pub const LookAndFeel_IntID_eIntID_DWMCompositor : root :: mozilla :: LookAndFeel_IntID = 27 ; pub const LookAndFeel_IntID_eIntID_WindowsClassic : root :: mozilla :: LookAndFeel_IntID = 28 ; pub const LookAndFeel_IntID_eIntID_WindowsGlass : root :: mozilla :: LookAndFeel_IntID = 29 ; pub const LookAndFeel_IntID_eIntID_TouchEnabled : root :: mozilla :: LookAndFeel_IntID = 30 ; pub const LookAndFeel_IntID_eIntID_MacGraphiteTheme : root :: mozilla :: LookAndFeel_IntID = 31 ; pub const LookAndFeel_IntID_eIntID_MacYosemiteTheme : root :: mozilla :: LookAndFeel_IntID = 32 ; pub const LookAndFeel_IntID_eIntID_AlertNotificationOrigin : root :: mozilla :: LookAndFeel_IntID = 33 ; pub const LookAndFeel_IntID_eIntID_ScrollToClick : root :: mozilla :: LookAndFeel_IntID = 34 ; pub const LookAndFeel_IntID_eIntID_IMERawInputUnderlineStyle : root :: mozilla :: LookAndFeel_IntID = 35 ; pub const LookAndFeel_IntID_eIntID_IMESelectedRawTextUnderlineStyle : root :: mozilla :: LookAndFeel_IntID = 36 ; pub const LookAndFeel_IntID_eIntID_IMEConvertedTextUnderlineStyle : root :: mozilla :: LookAndFeel_IntID = 37 ; pub const LookAndFeel_IntID_eIntID_IMESelectedConvertedTextUnderline : root :: mozilla :: LookAndFeel_IntID = 38 ; pub const LookAndFeel_IntID_eIntID_SpellCheckerUnderlineStyle : root :: mozilla :: LookAndFeel_IntID = 39 ; pub const LookAndFeel_IntID_eIntID_MenuBarDrag : root :: mozilla :: LookAndFeel_IntID = 40 ; pub const LookAndFeel_IntID_eIntID_WindowsThemeIdentifier : root :: mozilla :: LookAndFeel_IntID = 41 ; pub const LookAndFeel_IntID_eIntID_OperatingSystemVersionIdentifier : root :: mozilla :: LookAndFeel_IntID = 42 ; pub const LookAndFeel_IntID_eIntID_ScrollbarButtonAutoRepeatBehavior : root :: mozilla :: LookAndFeel_IntID = 43 ; pub const LookAndFeel_IntID_eIntID_TooltipDelay : root :: mozilla :: LookAndFeel_IntID = 44 ; pub const LookAndFeel_IntID_eIntID_SwipeAnimationEnabled : root :: mozilla :: LookAndFeel_IntID = 45 ; pub const LookAndFeel_IntID_eIntID_ScrollbarDisplayOnMouseMove : root :: mozilla :: LookAndFeel_IntID = 46 ; pub const LookAndFeel_IntID_eIntID_ScrollbarFadeBeginDelay : root :: mozilla :: LookAndFeel_IntID = 47 ; pub const LookAndFeel_IntID_eIntID_ScrollbarFadeDuration : root :: mozilla :: LookAndFeel_IntID = 48 ; pub const LookAndFeel_IntID_eIntID_ContextMenuOffsetVertical : root :: mozilla :: LookAndFeel_IntID = 49 ; pub const LookAndFeel_IntID_eIntID_ContextMenuOffsetHorizontal : root :: mozilla :: LookAndFeel_IntID = 50 ; pub const LookAndFeel_IntID_eIntID_GTKCSDAvailable : root :: mozilla :: LookAndFeel_IntID = 51 ; pub const LookAndFeel_IntID_eIntID_GTKCSDMinimizeButton : root :: mozilla :: LookAndFeel_IntID = 52 ; pub const LookAndFeel_IntID_eIntID_GTKCSDMaximizeButton : root :: mozilla :: LookAndFeel_IntID = 53 ; pub const LookAndFeel_IntID_eIntID_GTKCSDCloseButton : root :: mozilla :: LookAndFeel_IntID = 54 ; pub type LookAndFeel_IntID = :: std :: os :: raw :: c_uint ; pub const LookAndFeel_WindowsTheme_eWindowsTheme_Generic : root :: mozilla :: LookAndFeel_WindowsTheme = 0 ; pub const LookAndFeel_WindowsTheme_eWindowsTheme_Classic : root :: mozilla :: LookAndFeel_WindowsTheme = 1 ; pub const LookAndFeel_WindowsTheme_eWindowsTheme_Aero : root :: mozilla :: LookAndFeel_WindowsTheme = 2 ; pub const LookAndFeel_WindowsTheme_eWindowsTheme_LunaBlue : root :: mozilla :: LookAndFeel_WindowsTheme = 3 ; pub const LookAndFeel_WindowsTheme_eWindowsTheme_LunaOlive : root :: mozilla :: LookAndFeel_WindowsTheme = 4 ; pub const LookAndFeel_WindowsTheme_eWindowsTheme_LunaSilver : root :: mozilla :: LookAndFeel_WindowsTheme = 5 ; pub const LookAndFeel_WindowsTheme_eWindowsTheme_Royale : root :: mozilla :: LookAndFeel_WindowsTheme = 6 ; pub const LookAndFeel_WindowsTheme_eWindowsTheme_Zune : root :: mozilla :: LookAndFeel_WindowsTheme = 7 ; pub const LookAndFeel_WindowsTheme_eWindowsTheme_AeroLite : root :: mozilla :: LookAndFeel_WindowsTheme = 8 ; pub type LookAndFeel_WindowsTheme = :: std :: os :: raw :: c_uint ; pub const LookAndFeel_OperatingSystemVersion_eOperatingSystemVersion_Windows7 : root :: mozilla :: LookAndFeel_OperatingSystemVersion = 2 ; pub const LookAndFeel_OperatingSystemVersion_eOperatingSystemVersion_Windows8 : root :: mozilla :: LookAndFeel_OperatingSystemVersion = 3 ; pub const LookAndFeel_OperatingSystemVersion_eOperatingSystemVersion_Windows10 : root :: mozilla :: LookAndFeel_OperatingSystemVersion = 4 ; pub const LookAndFeel_OperatingSystemVersion_eOperatingSystemVersion_Unknown : root :: mozilla :: LookAndFeel_OperatingSystemVersion = 5 ; pub type LookAndFeel_OperatingSystemVersion = :: std :: os :: raw :: c_uint ; pub const LookAndFeel_eScrollArrow_None : root :: mozilla :: LookAndFeel__bindgen_ty_1 = 0 ; pub const LookAndFeel_eScrollArrow_StartBackward : root :: mozilla :: LookAndFeel__bindgen_ty_1 = 4096 ; pub const LookAndFeel_eScrollArrow_StartForward : root :: mozilla :: LookAndFeel__bindgen_ty_1 = 256 ; pub const LookAndFeel_eScrollArrow_EndBackward : root :: mozilla :: LookAndFeel__bindgen_ty_1 = 16 ; pub const LookAndFeel_eScrollArrow_EndForward : root :: mozilla :: LookAndFeel__bindgen_ty_1 = 1 ; pub type LookAndFeel__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; pub const LookAndFeel_eScrollArrowStyle_Single : root :: mozilla :: LookAndFeel__bindgen_ty_2 = 4097 ; pub const LookAndFeel_eScrollArrowStyle_BothAtBottom : root :: mozilla :: LookAndFeel__bindgen_ty_2 = 17 ; pub const LookAndFeel_eScrollArrowStyle_BothAtEachEnd : root :: mozilla :: LookAndFeel__bindgen_ty_2 = 4369 ; pub const LookAndFeel_eScrollArrowStyle_BothAtTop : root :: mozilla :: LookAndFeel__bindgen_ty_2 = 4352 ; pub type LookAndFeel__bindgen_ty_2 = :: std :: os :: raw :: c_uint ; pub const LookAndFeel_eScrollThumbStyle_Normal : root :: mozilla :: LookAndFeel__bindgen_ty_3 = 0 ; pub const LookAndFeel_eScrollThumbStyle_Proportional : root :: mozilla :: LookAndFeel__bindgen_ty_3 = 1 ; pub type LookAndFeel__bindgen_ty_3 = :: std :: os :: raw :: c_uint ; pub const LookAndFeel_FloatID_eFloatID_IMEUnderlineRelativeSize : root :: mozilla :: LookAndFeel_FloatID = 0 ; pub const LookAndFeel_FloatID_eFloatID_SpellCheckerUnderlineRelativeSize : root :: mozilla :: LookAndFeel_FloatID = 1 ; pub const LookAndFeel_FloatID_eFloatID_CaretAspectRatio : root :: mozilla :: LookAndFeel_FloatID = 2 ; pub type LookAndFeel_FloatID = :: std :: os :: raw :: c_uint ; pub const LookAndFeel_FontID_FontID_MINIMUM : root :: mozilla :: LookAndFeel_FontID = LookAndFeel_FontID :: eFont_Caption ; pub const LookAndFeel_FontID_FontID_MAXIMUM : root :: mozilla :: LookAndFeel_FontID = LookAndFeel_FontID :: eFont_Widget ; # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum LookAndFeel_FontID { eFont_Caption = 1 , eFont_Icon = 2 , eFont_Menu = 3 , eFont_MessageBox = 4 , eFont_SmallCaption = 5 , eFont_StatusBar = 6 , eFont_Window = 7 , eFont_Document = 8 , eFont_Workspace = 9 , eFont_Desktop = 10 , eFont_Info = 11 , eFont_Dialog = 12 , eFont_Button = 13 , eFont_PullDownMenu = 14 , eFont_List = 15 , eFont_Field = 16 , eFont_Tooltips = 17 , eFont_Widget = 18 , } # [ test ] fn bindgen_test_layout_LookAndFeel ( ) { assert_eq ! ( :: std :: mem :: size_of :: < LookAndFeel > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( LookAndFeel ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < LookAndFeel > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( LookAndFeel ) ) ) ; } impl Clone for LookAndFeel { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct StylePrefs { pub _address : u8 , } extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla10StylePrefs19sFontDisplayEnabledE" ] 
 pub static mut  StylePrefs_sFontDisplayEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla10StylePrefs19sOpentypeSVGEnabledE" ] 
 pub static mut  StylePrefs_sOpentypeSVGEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla10StylePrefs29sWebkitPrefixedAliasesEnabledE" ] 
 pub static mut  StylePrefs_sWebkitPrefixedAliasesEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla10StylePrefs30sWebkitDevicePixelRatioEnabledE" ] 
 pub static mut  StylePrefs_sWebkitDevicePixelRatioEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla10StylePrefs20sMozGradientsEnabledE" ] 
 pub static mut  StylePrefs_sMozGradientsEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla10StylePrefs22sControlCharVisibilityE" ] 
 pub static mut  StylePrefs_sControlCharVisibility  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla10StylePrefs28sFramesTimingFunctionEnabledE" ] 
 pub static mut  StylePrefs_sFramesTimingFunctionEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla10StylePrefs31sUnprefixedFullscreenApiEnabledE" ] 
 pub static mut  StylePrefs_sUnprefixedFullscreenApiEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla10StylePrefs20sVisitedLinksEnabledE" ] 
 pub static mut  StylePrefs_sVisitedLinksEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla10StylePrefs28sMozDocumentEnabledInContentE" ] 
 pub static mut  StylePrefs_sMozDocumentEnabledInContent  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla10StylePrefs32sGridTemplateSubgridValueEnabledE" ] 
 pub static mut  StylePrefs_sGridTemplateSubgridValueEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla10StylePrefs22sEmulateMozBoxWithFlexE" ] 
 pub static mut  StylePrefs_sEmulateMozBoxWithFlex  :  bool ;
} # [ test ] fn bindgen_test_layout_StylePrefs ( ) { assert_eq ! ( :: std :: mem :: size_of :: < StylePrefs > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( StylePrefs ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < StylePrefs > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( StylePrefs ) ) ) ; } impl Clone for StylePrefs { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct NonOwningAnimationTarget { pub mElement : * mut root :: mozilla :: dom :: Element , pub mPseudoType : root :: mozilla :: CSSPseudoElementType , } # [ test ] fn bindgen_test_layout_NonOwningAnimationTarget ( ) { assert_eq ! ( :: std :: mem :: size_of :: < NonOwningAnimationTarget > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( NonOwningAnimationTarget ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < NonOwningAnimationTarget > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( NonOwningAnimationTarget ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const NonOwningAnimationTarget ) ) . mElement as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( NonOwningAnimationTarget ) , "::" , stringify ! ( mElement ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const NonOwningAnimationTarget ) ) . mPseudoType as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( NonOwningAnimationTarget ) , "::" , stringify ! ( mPseudoType ) ) ) ; } impl Clone for NonOwningAnimationTarget { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] pub struct PseudoElementHashEntry { pub _base : root :: PLDHashEntryHdr , pub mElement : root :: RefPtr < root :: mozilla :: dom :: Element > , pub mPseudoType : root :: mozilla :: CSSPseudoElementType , } pub type PseudoElementHashEntry_KeyType = root :: mozilla :: NonOwningAnimationTarget ; pub type PseudoElementHashEntry_KeyTypePointer = * const root :: mozilla :: NonOwningAnimationTarget ; pub const PseudoElementHashEntry_ALLOW_MEMMOVE : root :: mozilla :: PseudoElementHashEntry__bindgen_ty_1 = 1 ; pub type PseudoElementHashEntry__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_PseudoElementHashEntry ( ) { assert_eq ! ( :: std :: mem :: size_of :: < PseudoElementHashEntry > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( PseudoElementHashEntry ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < PseudoElementHashEntry > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( PseudoElementHashEntry ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PseudoElementHashEntry ) ) . mElement as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( PseudoElementHashEntry ) , "::" , stringify ! ( mElement ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PseudoElementHashEntry ) ) . mPseudoType as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( PseudoElementHashEntry ) , "::" , stringify ! ( mPseudoType ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct EffectCompositor { pub mRefCnt : root :: nsCycleCollectingAutoRefCnt , pub mPresContext : * mut root :: nsPresContext , pub mElementsToRestyle : [ u64 ; 8usize ] , pub mIsInPreTraverse : bool , pub mRuleProcessors : [ u64 ; 2usize ] , } pub type EffectCompositor_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct EffectCompositor_cycleCollection { pub _base : root :: nsCycleCollectionParticipant , } # [ test ] fn bindgen_test_layout_EffectCompositor_cycleCollection ( ) { assert_eq ! ( :: std :: mem :: size_of :: < EffectCompositor_cycleCollection > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( EffectCompositor_cycleCollection ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < EffectCompositor_cycleCollection > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( EffectCompositor_cycleCollection ) ) ) ; } impl Clone for EffectCompositor_cycleCollection { fn clone ( & self ) -> Self { * self } } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum EffectCompositor_CascadeLevel { Animations = 0 , Transitions = 1 , } pub const EffectCompositor_RestyleType_Throttled : root :: mozilla :: EffectCompositor_RestyleType = 0 ; pub const EffectCompositor_RestyleType_Standard : root :: mozilla :: EffectCompositor_RestyleType = 1 ; pub const EffectCompositor_RestyleType_Layer : root :: mozilla :: EffectCompositor_RestyleType = 2 ; pub type EffectCompositor_RestyleType = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct EffectCompositor_AnimationStyleRuleProcessor { pub _base : root :: nsIStyleRuleProcessor , pub mRefCnt : root :: nsAutoRefCnt , pub mCompositor : * mut root :: mozilla :: EffectCompositor , pub mCascadeLevel : root :: mozilla :: EffectCompositor_CascadeLevel , } pub type EffectCompositor_AnimationStyleRuleProcessor_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ test ] fn bindgen_test_layout_EffectCompositor_AnimationStyleRuleProcessor ( ) { assert_eq ! ( :: std :: mem :: size_of :: < EffectCompositor_AnimationStyleRuleProcessor > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( EffectCompositor_AnimationStyleRuleProcessor ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < EffectCompositor_AnimationStyleRuleProcessor > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( EffectCompositor_AnimationStyleRuleProcessor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const EffectCompositor_AnimationStyleRuleProcessor ) ) . mRefCnt as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( EffectCompositor_AnimationStyleRuleProcessor ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const EffectCompositor_AnimationStyleRuleProcessor ) ) . mCompositor as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( EffectCompositor_AnimationStyleRuleProcessor ) , "::" , stringify ! ( mCompositor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const EffectCompositor_AnimationStyleRuleProcessor ) ) . mCascadeLevel as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( EffectCompositor_AnimationStyleRuleProcessor ) , "::" , stringify ! ( mCascadeLevel ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla16EffectCompositor21_cycleCollectorGlobalE" ] 
 pub static mut  EffectCompositor__cycleCollectorGlobal  :  root :: mozilla :: EffectCompositor_cycleCollection ;
} pub const EffectCompositor_kCascadeLevelCount : usize = 2 ; # [ test ] fn bindgen_test_layout_EffectCompositor ( ) { assert_eq ! ( :: std :: mem :: size_of :: < EffectCompositor > ( ) , 104usize , concat ! ( "Size of: " , stringify ! ( EffectCompositor ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < EffectCompositor > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( EffectCompositor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const EffectCompositor ) ) . mRefCnt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( EffectCompositor ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const EffectCompositor ) ) . mPresContext as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( EffectCompositor ) , "::" , stringify ! ( mPresContext ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const EffectCompositor ) ) . mElementsToRestyle as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( EffectCompositor ) , "::" , stringify ! ( mElementsToRestyle ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const EffectCompositor ) ) . mIsInPreTraverse as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( EffectCompositor ) , "::" , stringify ! ( mIsInPreTraverse ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const EffectCompositor ) ) . mRuleProcessors as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( EffectCompositor ) , "::" , stringify ! ( mRuleProcessors ) ) ) ; } pub type CSSPseudoClassTypeBase = u8 ; # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum CSSPseudoClassType { empty = 0 , mozOnlyWhitespace = 1 , lang = 2 , root = 3 , any = 4 , firstChild = 5 , firstNode = 6 , lastChild = 7 , lastNode = 8 , onlyChild = 9 , firstOfType = 10 , lastOfType = 11 , onlyOfType = 12 , nthChild = 13 , nthLastChild = 14 , nthOfType = 15 , nthLastOfType = 16 , mozIsHTML = 17 , unresolved = 18 , mozNativeAnonymous = 19 , mozUseShadowTreeRoot = 20 , mozLocaleDir = 21 , mozLWTheme = 22 , mozLWThemeBrightText = 23 , mozLWThemeDarkText = 24 , mozWindowInactive = 25 , mozTableBorderNonzero = 26 , mozBrowserFrame = 27 , scope = 28 , negation = 29 , dir = 30 , link = 31 , mozAnyLink = 32 , anyLink = 33 , visited = 34 , active = 35 , checked = 36 , disabled = 37 , enabled = 38 , focus = 39 , focusWithin = 40 , hover = 41 , mozDragOver = 42 , target = 43 , indeterminate = 44 , mozDevtoolsHighlighted = 45 , mozStyleeditorTransitioning = 46 , fullscreen = 47 , mozFullScreen = 48 , mozFocusRing = 49 , mozBroken = 50 , mozLoading = 51 , mozUserDisabled = 52 , mozSuppressed = 53 , mozHandlerClickToPlay = 54 , mozHandlerVulnerableUpdatable = 55 , mozHandlerVulnerableNoUpdate = 56 , mozHandlerDisabled = 57 , mozHandlerBlocked = 58 , mozHandlerCrashed = 59 , mozMathIncrementScriptLevel = 60 , mozHasDirAttr = 61 , mozDirAttrLTR = 62 , mozDirAttrRTL = 63 , mozDirAttrLikeAuto = 64 , mozAutofill = 65 , mozAutofillPreview = 66 , required = 67 , optional = 68 , valid = 69 , invalid = 70 , inRange = 71 , outOfRange = 72 , defaultPseudo = 73 , placeholderShown = 74 , mozReadOnly = 75 , mozReadWrite = 76 , mozSubmitInvalid = 77 , mozUIInvalid = 78 , mozUIValid = 79 , mozMeterOptimum = 80 , mozMeterSubOptimum = 81 , mozMeterSubSubOptimum = 82 , mozPlaceholder = 83 , Count = 84 , NotPseudo = 85 , MAX = 86 , } # [ repr ( C ) ] pub struct GeckoFont { pub gecko : root :: nsStyleFont , } # [ test ] fn bindgen_test_layout_GeckoFont ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoFont > ( ) , 136usize , concat ! ( "Size of: " , stringify ! ( GeckoFont ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoFont > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GeckoFont ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoFont ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoFont ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GeckoColor { pub gecko : root :: nsStyleColor , } # [ test ] fn bindgen_test_layout_GeckoColor ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoColor > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( GeckoColor ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoColor > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( GeckoColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoColor ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoColor ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] pub struct GeckoList { pub gecko : root :: nsStyleList , } # [ test ] fn bindgen_test_layout_GeckoList ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoList > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( GeckoList ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoList > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GeckoList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoList ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoList ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] pub struct GeckoText { pub gecko : root :: nsStyleText , } # [ test ] fn bindgen_test_layout_GeckoText ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoText > ( ) , 160usize , concat ! ( "Size of: " , stringify ! ( GeckoText ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoText > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GeckoText ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoText ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoText ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GeckoVisibility { pub gecko : root :: nsStyleVisibility , } # [ test ] fn bindgen_test_layout_GeckoVisibility ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoVisibility > ( ) , 7usize , concat ! ( "Size of: " , stringify ! ( GeckoVisibility ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoVisibility > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( GeckoVisibility ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoVisibility ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoVisibility ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GeckoUserInterface { pub gecko : root :: nsStyleUserInterface , } # [ test ] fn bindgen_test_layout_GeckoUserInterface ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoUserInterface > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( GeckoUserInterface ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoUserInterface > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GeckoUserInterface ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoUserInterface ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoUserInterface ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GeckoTableBorder { pub gecko : root :: nsStyleTableBorder , } # [ test ] fn bindgen_test_layout_GeckoTableBorder ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoTableBorder > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( GeckoTableBorder ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoTableBorder > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( GeckoTableBorder ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoTableBorder ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoTableBorder ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GeckoSVG { pub gecko : root :: nsStyleSVG , } # [ test ] fn bindgen_test_layout_GeckoSVG ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoSVG > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( GeckoSVG ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoSVG > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GeckoSVG ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoSVG ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoSVG ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GeckoBackground { pub gecko : root :: nsStyleBackground , } # [ test ] fn bindgen_test_layout_GeckoBackground ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoBackground > ( ) , 160usize , concat ! ( "Size of: " , stringify ! ( GeckoBackground ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoBackground > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GeckoBackground ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoBackground ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoBackground ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] pub struct GeckoPosition { pub gecko : root :: nsStylePosition , } # [ test ] fn bindgen_test_layout_GeckoPosition ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoPosition > ( ) , 440usize , concat ! ( "Size of: " , stringify ! ( GeckoPosition ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoPosition > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GeckoPosition ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoPosition ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoPosition ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] pub struct GeckoTextReset { pub gecko : root :: nsStyleTextReset , } # [ test ] fn bindgen_test_layout_GeckoTextReset ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoTextReset > ( ) , 80usize , concat ! ( "Size of: " , stringify ! ( GeckoTextReset ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoTextReset > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GeckoTextReset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoTextReset ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoTextReset ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GeckoDisplay { pub gecko : root :: nsStyleDisplay , } # [ test ] fn bindgen_test_layout_GeckoDisplay ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoDisplay > ( ) , 424usize , concat ! ( "Size of: " , stringify ! ( GeckoDisplay ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoDisplay > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GeckoDisplay ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoDisplay ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoDisplay ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] pub struct GeckoContent { pub gecko : root :: nsStyleContent , } # [ test ] fn bindgen_test_layout_GeckoContent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoContent > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( GeckoContent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoContent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GeckoContent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoContent ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoContent ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GeckoUIReset { pub gecko : root :: nsStyleUIReset , } # [ test ] fn bindgen_test_layout_GeckoUIReset ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoUIReset > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( GeckoUIReset ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoUIReset > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GeckoUIReset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoUIReset ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoUIReset ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GeckoTable { pub gecko : root :: nsStyleTable , } # [ test ] fn bindgen_test_layout_GeckoTable ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoTable > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( GeckoTable ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoTable > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( GeckoTable ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoTable ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoTable ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GeckoMargin { pub gecko : root :: nsStyleMargin , } # [ test ] fn bindgen_test_layout_GeckoMargin ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoMargin > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( GeckoMargin ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoMargin > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GeckoMargin ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoMargin ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoMargin ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GeckoPadding { pub gecko : root :: nsStylePadding , } # [ test ] fn bindgen_test_layout_GeckoPadding ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoPadding > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( GeckoPadding ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoPadding > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GeckoPadding ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoPadding ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoPadding ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GeckoBorder { pub gecko : root :: nsStyleBorder , } # [ test ] fn bindgen_test_layout_GeckoBorder ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoBorder > ( ) , 312usize , concat ! ( "Size of: " , stringify ! ( GeckoBorder ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoBorder > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GeckoBorder ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoBorder ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoBorder ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GeckoOutline { pub gecko : root :: nsStyleOutline , } # [ test ] fn bindgen_test_layout_GeckoOutline ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoOutline > ( ) , 104usize , concat ! ( "Size of: " , stringify ! ( GeckoOutline ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoOutline > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GeckoOutline ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoOutline ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoOutline ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GeckoXUL { pub gecko : root :: nsStyleXUL , } # [ test ] fn bindgen_test_layout_GeckoXUL ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoXUL > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( GeckoXUL ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoXUL > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( GeckoXUL ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoXUL ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoXUL ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GeckoSVGReset { pub gecko : root :: nsStyleSVGReset , } # [ test ] fn bindgen_test_layout_GeckoSVGReset ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoSVGReset > ( ) , 200usize , concat ! ( "Size of: " , stringify ! ( GeckoSVGReset ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoSVGReset > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GeckoSVGReset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoSVGReset ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoSVGReset ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GeckoColumn { pub gecko : root :: nsStyleColumn , } # [ test ] fn bindgen_test_layout_GeckoColumn ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoColumn > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( GeckoColumn ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoColumn > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GeckoColumn ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoColumn ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoColumn ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GeckoEffects { pub gecko : root :: nsStyleEffects , } # [ test ] fn bindgen_test_layout_GeckoEffects ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoEffects > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( GeckoEffects ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoEffects > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GeckoEffects ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoEffects ) ) . gecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoEffects ) , "::" , stringify ! ( gecko ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct ServoMediaList { pub _base : root :: mozilla :: dom :: MediaList , pub mRawList : root :: RefPtr < root :: RawServoMediaList > , } # [ test ] fn bindgen_test_layout_ServoMediaList ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ServoMediaList > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( ServoMediaList ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ServoMediaList > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ServoMediaList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoMediaList ) ) . mRawList as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( ServoMediaList ) , "::" , stringify ! ( mRawList ) ) ) ; } 
 /// A PostTraversalTask is a task to be performed immediately after a Servo
        /// traversal.  There are just a few tasks we need to perform, so we use this
        /// class rather than Runnables, to avoid virtual calls and some allocations.
        ///
        /// A PostTraversalTask is only safe to run immediately after the Servo
        /// traversal, since it can hold raw pointers to DOM objects. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct PostTraversalTask { pub mType : root :: mozilla :: PostTraversalTask_Type , pub mTarget : * mut :: std :: os :: raw :: c_void , pub mResult : root :: nsresult , } pub const PostTraversalTask_Type_ResolveFontFaceLoadedPromise : root :: mozilla :: PostTraversalTask_Type = 0 ; pub const PostTraversalTask_Type_RejectFontFaceLoadedPromise : root :: mozilla :: PostTraversalTask_Type = 1 ; pub const PostTraversalTask_Type_DispatchLoadingEventAndReplaceReadyPromise : root :: mozilla :: PostTraversalTask_Type = 2 ; pub const PostTraversalTask_Type_DispatchFontFaceSetCheckLoadingFinishedAfterDelay : root :: mozilla :: PostTraversalTask_Type = 3 ; pub const PostTraversalTask_Type_LoadFontEntry : root :: mozilla :: PostTraversalTask_Type = 4 ; pub type PostTraversalTask_Type = :: std :: os :: raw :: c_int ; # [ test ] fn bindgen_test_layout_PostTraversalTask ( ) { assert_eq ! ( :: std :: mem :: size_of :: < PostTraversalTask > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( PostTraversalTask ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < PostTraversalTask > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( PostTraversalTask ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PostTraversalTask ) ) . mType as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( PostTraversalTask ) , "::" , stringify ! ( mType ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PostTraversalTask ) ) . mTarget as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( PostTraversalTask ) , "::" , stringify ! ( mTarget ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PostTraversalTask ) ) . mResult as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( PostTraversalTask ) , "::" , stringify ! ( mResult ) ) ) ; } impl Clone for PostTraversalTask { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ServoStyleRuleMap { _unused : [ u8 ; 0 ] } pub const StylistState_NotDirty : root :: mozilla :: StylistState = 0 ; pub const StylistState_StyleSheetsDirty : root :: mozilla :: StylistState = 1 ; pub const StylistState_XBLStyleSheetsDirty : root :: mozilla :: StylistState = 2 ; pub type StylistState = u8 ; pub const OriginFlags_UserAgent : root :: mozilla :: OriginFlags = root :: mozilla :: OriginFlags ( 1 ) ; pub const OriginFlags_User : root :: mozilla :: OriginFlags = root :: mozilla :: OriginFlags ( 2 ) ; pub const OriginFlags_Author : root :: mozilla :: OriginFlags = root :: mozilla :: OriginFlags ( 4 ) ; pub const OriginFlags_All : root :: mozilla :: OriginFlags = root :: mozilla :: OriginFlags ( 7 ) ; impl :: std :: ops :: BitOr < root :: mozilla :: OriginFlags > for root :: mozilla :: OriginFlags { type Output = Self ; # [ inline ] fn bitor ( self , other : Self ) -> Self { OriginFlags ( self . 0 | other . 0 ) } } impl :: std :: ops :: BitOrAssign for root :: mozilla :: OriginFlags { # [ inline ] fn bitor_assign ( & mut self , rhs : root :: mozilla :: OriginFlags ) { self . 0 |= rhs . 0 ; } } impl :: std :: ops :: BitAnd < root :: mozilla :: OriginFlags > for root :: mozilla :: OriginFlags { type Output = Self ; # [ inline ] fn bitand ( self , other : Self ) -> Self { OriginFlags ( self . 0 & other . 0 ) } } impl :: std :: ops :: BitAndAssign for root :: mozilla :: OriginFlags { # [ inline ] fn bitand_assign ( & mut self , rhs : root :: mozilla :: OriginFlags ) { self . 0 &= rhs . 0 ; } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub struct OriginFlags ( pub u8 ) ; 
 /// The set of style sheets that apply to a document, backed by a Servo
        /// Stylist.  A ServoStyleSet contains ServoStyleSheets. 
 # [ repr ( C ) ] pub struct ServoStyleSet { pub mKind : root :: mozilla :: ServoStyleSet_Kind , pub mPresContext : * mut root :: nsPresContext , pub mLastPresContextUsesXBLStyleSet : * mut :: std :: os :: raw :: c_void , pub mRawSet : root :: mozilla :: UniquePtr < root :: RawServoStyleSet > , pub mSheets : [ u64 ; 9usize ] , pub mAuthorStyleDisabled : bool , pub mStylistState : root :: mozilla :: StylistState , pub mUserFontSetUpdateGeneration : u64 , pub mUserFontCacheUpdateGeneration : u32 , pub mNeedsRestyleAfterEnsureUniqueInner : bool , pub mNonInheritingStyleContexts : [ u64 ; 7usize ] , pub mPostTraversalTasks : root :: nsTArray < root :: mozilla :: PostTraversalTask > , pub mStyleRuleMap : root :: mozilla :: UniquePtr < root :: mozilla :: ServoStyleRuleMap > , pub mBindingManager : root :: RefPtr < root :: nsBindingManager > , } pub type ServoStyleSet_SnapshotTable = root :: mozilla :: ServoElementSnapshotTable ; pub const ServoStyleSet_Kind_Master : root :: mozilla :: ServoStyleSet_Kind = 0 ; pub const ServoStyleSet_Kind_ForXBL : root :: mozilla :: ServoStyleSet_Kind = 1 ; pub type ServoStyleSet_Kind = u8 ; extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla13ServoStyleSet17sInServoTraversalE" ] 
 pub static mut  ServoStyleSet_sInServoTraversal  :  * mut root :: mozilla :: ServoStyleSet ;
} # [ test ] fn bindgen_test_layout_ServoStyleSet ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ServoStyleSet > ( ) , 208usize , concat ! ( "Size of: " , stringify ! ( ServoStyleSet ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ServoStyleSet > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ServoStyleSet ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSet ) ) . mKind as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSet ) , "::" , stringify ! ( mKind ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSet ) ) . mPresContext as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSet ) , "::" , stringify ! ( mPresContext ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSet ) ) . mLastPresContextUsesXBLStyleSet as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSet ) , "::" , stringify ! ( mLastPresContextUsesXBLStyleSet ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSet ) ) . mRawSet as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSet ) , "::" , stringify ! ( mRawSet ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSet ) ) . mSheets as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSet ) , "::" , stringify ! ( mSheets ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSet ) ) . mAuthorStyleDisabled as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSet ) , "::" , stringify ! ( mAuthorStyleDisabled ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSet ) ) . mStylistState as * const _ as usize } , 105usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSet ) , "::" , stringify ! ( mStylistState ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSet ) ) . mUserFontSetUpdateGeneration as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSet ) , "::" , stringify ! ( mUserFontSetUpdateGeneration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSet ) ) . mUserFontCacheUpdateGeneration as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSet ) , "::" , stringify ! ( mUserFontCacheUpdateGeneration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSet ) ) . mNeedsRestyleAfterEnsureUniqueInner as * const _ as usize } , 124usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSet ) , "::" , stringify ! ( mNeedsRestyleAfterEnsureUniqueInner ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSet ) ) . mNonInheritingStyleContexts as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSet ) , "::" , stringify ! ( mNonInheritingStyleContexts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSet ) ) . mPostTraversalTasks as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSet ) , "::" , stringify ! ( mPostTraversalTasks ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSet ) ) . mStyleRuleMap as * const _ as usize } , 192usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSet ) , "::" , stringify ! ( mStyleRuleMap ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleSet ) ) . mBindingManager as * const _ as usize } , 200usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleSet ) , "::" , stringify ! ( mBindingManager ) ) ) ; } # [ repr ( C ) ] pub struct ServoStyleContext { pub _base : root :: nsStyleContext , pub mPresContext : * mut root :: nsPresContext , pub mSource : root :: ServoComputedData , pub mNextInheritingAnonBoxStyle : root :: RefPtr < root :: mozilla :: ServoStyleContext > , pub mNextLazyPseudoStyle : root :: RefPtr < root :: mozilla :: ServoStyleContext > , } # [ test ] fn bindgen_test_layout_ServoStyleContext ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ServoStyleContext > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( ServoStyleContext ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ServoStyleContext > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ServoStyleContext ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleContext ) ) . mPresContext as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleContext ) , "::" , stringify ! ( mPresContext ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleContext ) ) . mSource as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleContext ) , "::" , stringify ! ( mSource ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleContext ) ) . mNextInheritingAnonBoxStyle as * const _ as usize } , 240usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleContext ) , "::" , stringify ! ( mNextInheritingAnonBoxStyle ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoStyleContext ) ) . mNextLazyPseudoStyle as * const _ as usize } , 248usize , concat ! ( "Alignment of field: " , stringify ! ( ServoStyleContext ) , "::" , stringify ! ( mNextLazyPseudoStyle ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct DeclarationBlock { pub mContainer : root :: mozilla :: DeclarationBlock__bindgen_ty_1 , pub mImmutable : bool , pub mType : root :: mozilla :: StyleBackendType , pub mIsDirty : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct DeclarationBlock__bindgen_ty_1 { pub mRaw : root :: __BindgenUnionField < usize > , pub mOwningRule : root :: __BindgenUnionField < * mut root :: mozilla :: css :: Rule > , pub mHTMLCSSStyleSheet : root :: __BindgenUnionField < * mut root :: nsHTMLCSSStyleSheet > , pub bindgen_union_field : u64 , } # [ test ] fn bindgen_test_layout_DeclarationBlock__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < DeclarationBlock__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( DeclarationBlock__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < DeclarationBlock__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( DeclarationBlock__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const DeclarationBlock__bindgen_ty_1 ) ) . mRaw as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( DeclarationBlock__bindgen_ty_1 ) , "::" , stringify ! ( mRaw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const DeclarationBlock__bindgen_ty_1 ) ) . mOwningRule as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( DeclarationBlock__bindgen_ty_1 ) , "::" , stringify ! ( mOwningRule ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const DeclarationBlock__bindgen_ty_1 ) ) . mHTMLCSSStyleSheet as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( DeclarationBlock__bindgen_ty_1 ) , "::" , stringify ! ( mHTMLCSSStyleSheet ) ) ) ; } impl Clone for DeclarationBlock__bindgen_ty_1 { fn clone ( & self ) -> Self { * self } } # [ test ] fn bindgen_test_layout_DeclarationBlock ( ) { assert_eq ! ( :: std :: mem :: size_of :: < DeclarationBlock > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( DeclarationBlock ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < DeclarationBlock > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( DeclarationBlock ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const DeclarationBlock ) ) . mContainer as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( DeclarationBlock ) , "::" , stringify ! ( mContainer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const DeclarationBlock ) ) . mImmutable as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( DeclarationBlock ) , "::" , stringify ! ( mImmutable ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const DeclarationBlock ) ) . mType as * const _ as usize } , 9usize , concat ! ( "Alignment of field: " , stringify ! ( DeclarationBlock ) , "::" , stringify ! ( mType ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const DeclarationBlock ) ) . mIsDirty as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( DeclarationBlock ) , "::" , stringify ! ( mIsDirty ) ) ) ; } impl Clone for DeclarationBlock { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct ServoDeclarationBlock { pub _base : root :: mozilla :: DeclarationBlock , pub mRefCnt : root :: mozilla :: ThreadSafeAutoRefCnt , pub mRaw : root :: RefPtr < root :: RawServoDeclarationBlock > , } pub type ServoDeclarationBlock_HasThreadSafeRefCnt = root :: mozilla :: TrueType ; # [ test ] fn bindgen_test_layout_ServoDeclarationBlock ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ServoDeclarationBlock > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( ServoDeclarationBlock ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ServoDeclarationBlock > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ServoDeclarationBlock ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoDeclarationBlock ) ) . mRefCnt as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( ServoDeclarationBlock ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoDeclarationBlock ) ) . mRaw as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( ServoDeclarationBlock ) , "::" , stringify ! ( mRaw ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct CSSFontFaceDescriptors { pub mFamily : root :: nsCSSValue , pub mStyle : root :: nsCSSValue , pub mWeight : root :: nsCSSValue , pub mStretch : root :: nsCSSValue , pub mSrc : root :: nsCSSValue , pub mUnicodeRange : root :: nsCSSValue , pub mFontFeatureSettings : root :: nsCSSValue , pub mFontLanguageOverride : root :: nsCSSValue , pub mDisplay : root :: nsCSSValue , } extern "C" {
 # [ link_name = "\u{1}_ZN7mozilla22CSSFontFaceDescriptors6FieldsE" ] 
 pub static mut  CSSFontFaceDescriptors_Fields  :  [ * const root :: nsCSSValue ; 0usize ] ;
} # [ test ] fn bindgen_test_layout_CSSFontFaceDescriptors ( ) { assert_eq ! ( :: std :: mem :: size_of :: < CSSFontFaceDescriptors > ( ) , 144usize , concat ! ( "Size of: " , stringify ! ( CSSFontFaceDescriptors ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < CSSFontFaceDescriptors > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( CSSFontFaceDescriptors ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CSSFontFaceDescriptors ) ) . mFamily as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( CSSFontFaceDescriptors ) , "::" , stringify ! ( mFamily ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CSSFontFaceDescriptors ) ) . mStyle as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( CSSFontFaceDescriptors ) , "::" , stringify ! ( mStyle ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CSSFontFaceDescriptors ) ) . mWeight as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( CSSFontFaceDescriptors ) , "::" , stringify ! ( mWeight ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CSSFontFaceDescriptors ) ) . mStretch as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( CSSFontFaceDescriptors ) , "::" , stringify ! ( mStretch ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CSSFontFaceDescriptors ) ) . mSrc as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( CSSFontFaceDescriptors ) , "::" , stringify ! ( mSrc ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CSSFontFaceDescriptors ) ) . mUnicodeRange as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( CSSFontFaceDescriptors ) , "::" , stringify ! ( mUnicodeRange ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CSSFontFaceDescriptors ) ) . mFontFeatureSettings as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( CSSFontFaceDescriptors ) , "::" , stringify ! ( mFontFeatureSettings ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CSSFontFaceDescriptors ) ) . mFontLanguageOverride as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( CSSFontFaceDescriptors ) , "::" , stringify ! ( mFontLanguageOverride ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CSSFontFaceDescriptors ) ) . mDisplay as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( CSSFontFaceDescriptors ) , "::" , stringify ! ( mDisplay ) ) ) ; } pub mod intl { # [ allow ( unused_imports ) ] use self :: super :: super :: super :: root ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct LineBreaker { pub mRefCnt : root :: nsAutoRefCnt , } pub type LineBreaker_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; pub const LineBreaker_kWordBreak_Normal : root :: mozilla :: intl :: LineBreaker__bindgen_ty_1 = 0 ; pub const LineBreaker_kWordBreak_BreakAll : root :: mozilla :: intl :: LineBreaker__bindgen_ty_1 = 1 ; pub const LineBreaker_kWordBreak_KeepAll : root :: mozilla :: intl :: LineBreaker__bindgen_ty_1 = 2 ; pub type LineBreaker__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_LineBreaker ( ) { assert_eq ! ( :: std :: mem :: size_of :: < LineBreaker > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( LineBreaker ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < LineBreaker > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( LineBreaker ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const LineBreaker ) ) . mRefCnt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( LineBreaker ) , "::" , stringify ! ( mRefCnt ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct WordBreaker { pub mRefCnt : root :: nsAutoRefCnt , } pub type WordBreaker_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ test ] fn bindgen_test_layout_WordBreaker ( ) { assert_eq ! ( :: std :: mem :: size_of :: < WordBreaker > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( WordBreaker ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < WordBreaker > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( WordBreaker ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const WordBreaker ) ) . mRefCnt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( WordBreaker ) , "::" , stringify ! ( mRefCnt ) ) ) ; } } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct InfallibleAllocPolicy { pub _address : u8 , } # [ test ] fn bindgen_test_layout_InfallibleAllocPolicy ( ) { assert_eq ! ( :: std :: mem :: size_of :: < InfallibleAllocPolicy > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( InfallibleAllocPolicy ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < InfallibleAllocPolicy > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( InfallibleAllocPolicy ) ) ) ; } impl Clone for InfallibleAllocPolicy { fn clone ( & self ) -> Self { * self } } 
 /// MozRefCountType is Mozilla's reference count type.
    ///
    /// We use the same type to represent the refcount of RefCounted objects
    /// as well, in order to be able to use the leak detection facilities
    /// that are implemented by XPCOM.
    ///
    /// Note that this type is not in the mozilla namespace so that it is
    /// usable for both C and C++ code. 
 pub type MozRefCountType = usize ; pub const nsresult_NS_ERROR_NO_INTERFACE : root :: nsresult = nsresult :: NS_NOINTERFACE ; pub const nsresult_NS_ERROR_INVALID_ARG : root :: nsresult = nsresult :: NS_ERROR_ILLEGAL_VALUE ; pub const nsresult_NS_ERROR_INVALID_POINTER : root :: nsresult = nsresult :: NS_ERROR_ILLEGAL_VALUE ; pub const nsresult_NS_ERROR_NULL_POINTER : root :: nsresult = nsresult :: NS_ERROR_ILLEGAL_VALUE ; pub const nsresult_NS_BINDING_SUCCEEDED : root :: nsresult = nsresult :: NS_OK ; pub const nsresult_NS_NET_STATUS_RESOLVING_HOST : root :: nsresult = nsresult :: NS_BINDING_REDIRECTED ; pub const nsresult_NS_NET_STATUS_RESOLVED_HOST : root :: nsresult = nsresult :: NS_ERROR_ALREADY_CONNECTED ; pub const nsresult_NS_NET_STATUS_CONNECTED_TO : root :: nsresult = nsresult :: NS_BINDING_RETARGETED ; pub const nsresult_NS_NET_STATUS_TLS_HANDSHAKE_STARTING : root :: nsresult = nsresult :: NS_ERROR_NOT_CONNECTED ; pub const nsresult_NS_NET_STATUS_TLS_HANDSHAKE_ENDED : root :: nsresult = nsresult :: NS_ERROR_CONNECTION_REFUSED ; pub const nsresult_NS_NET_STATUS_WAITING_FOR : root :: nsresult = nsresult :: NS_ERROR_MALFORMED_URI ; pub const nsresult_NS_STATE_PROPERTY_EXISTS : root :: nsresult = nsresult :: NS_OK ; pub const nsresult_NS_ERROR_HTMLPARSER_CONTINUE : root :: nsresult = nsresult :: NS_OK ; pub const nsresult_NS_RDF_ASSERTION_ACCEPTED : root :: nsresult = nsresult :: NS_OK ; pub const nsresult_NS_EXACT_LENGTH : root :: nsresult = nsresult :: NS_OK_UDEC_EXACTLENGTH ; pub const nsresult_NS_PARTIAL_MORE_INPUT : root :: nsresult = nsresult :: NS_OK_UDEC_MOREINPUT ; pub const nsresult_NS_PARTIAL_MORE_OUTPUT : root :: nsresult = nsresult :: NS_OK_UDEC_MOREOUTPUT ; pub const nsresult_NS_ERROR_ILLEGAL_INPUT : root :: nsresult = nsresult :: NS_ERROR_UDEC_ILLEGALINPUT ; pub const nsresult_NS_ERROR_XPATH_INVALID_ARG : root :: nsresult = nsresult :: NS_ERROR_ILLEGAL_VALUE ; pub const nsresult_NS_SUCCESS_RESTART_APP : root :: nsresult = nsresult :: NS_SUCCESS_DONT_FIXUP ; # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsresult { NS_OK = 0 , NS_ERROR_BASE = 3253927936 , NS_ERROR_NOT_INITIALIZED = 3253927937 , NS_ERROR_ALREADY_INITIALIZED = 3253927938 , NS_ERROR_NOT_IMPLEMENTED = 2147500033 , NS_NOINTERFACE = 2147500034 , NS_ERROR_ABORT = 2147500036 , NS_ERROR_FAILURE = 2147500037 , NS_ERROR_UNEXPECTED = 2147549183 , NS_ERROR_OUT_OF_MEMORY = 2147942414 , NS_ERROR_ILLEGAL_VALUE = 2147942487 , NS_ERROR_NO_AGGREGATION = 2147746064 , NS_ERROR_NOT_AVAILABLE = 2147746065 , NS_ERROR_FACTORY_NOT_REGISTERED = 2147746132 , NS_ERROR_FACTORY_REGISTER_AGAIN = 2147746133 , NS_ERROR_FACTORY_NOT_LOADED = 2147746296 , NS_ERROR_FACTORY_NO_SIGNATURE_SUPPORT = 3253928193 , NS_ERROR_FACTORY_EXISTS = 3253928192 , NS_ERROR_CANNOT_CONVERT_DATA = 2152071169 , NS_ERROR_OBJECT_IS_IMMUTABLE = 2152071170 , NS_ERROR_LOSS_OF_SIGNIFICANT_DATA = 2152071171 , NS_ERROR_NOT_SAME_THREAD = 2152071172 , NS_ERROR_ILLEGAL_DURING_SHUTDOWN = 2152071198 , NS_ERROR_SERVICE_NOT_AVAILABLE = 2152071190 , NS_SUCCESS_LOSS_OF_INSIGNIFICANT_DATA = 4587521 , NS_SUCCESS_INTERRUPTED_TRAVERSE = 4587522 , NS_ERROR_SERVICE_NOT_FOUND = 4587542 , NS_ERROR_SERVICE_IN_USE = 4587543 , NS_BASE_STREAM_CLOSED = 2152136706 , NS_BASE_STREAM_OSERROR = 2152136707 , NS_BASE_STREAM_ILLEGAL_ARGS = 2152136708 , NS_BASE_STREAM_NO_CONVERTER = 2152136709 , NS_BASE_STREAM_BAD_CONVERSION = 2152136710 , NS_BASE_STREAM_WOULD_BLOCK = 2152136711 , NS_ERROR_GFX_PRINTER_NO_PRINTER_AVAILABLE = 2152202241 , NS_ERROR_GFX_PRINTER_NAME_NOT_FOUND = 2152202242 , NS_ERROR_GFX_PRINTER_COULD_NOT_OPEN_FILE = 2152202243 , NS_ERROR_GFX_PRINTER_STARTDOC = 2152202244 , NS_ERROR_GFX_PRINTER_ENDDOC = 2152202245 , NS_ERROR_GFX_PRINTER_STARTPAGE = 2152202246 , NS_ERROR_GFX_PRINTER_DOC_IS_BUSY = 2152202247 , NS_ERROR_GFX_CMAP_MALFORMED = 2152202291 , NS_SUCCESS_EVENT_CONSUMED = 4784129 , NS_SUCCESS_EVENT_HANDLED_ASYNCHRONOUSLY = 4784130 , NS_BINDING_FAILED = 2152398849 , NS_BINDING_ABORTED = 2152398850 , NS_BINDING_REDIRECTED = 2152398851 , NS_BINDING_RETARGETED = 2152398852 , NS_ERROR_MALFORMED_URI = 2152398858 , NS_ERROR_IN_PROGRESS = 2152398863 , NS_ERROR_NO_CONTENT = 2152398865 , NS_ERROR_UNKNOWN_PROTOCOL = 2152398866 , NS_ERROR_INVALID_CONTENT_ENCODING = 2152398875 , NS_ERROR_CORRUPTED_CONTENT = 2152398877 , NS_ERROR_INVALID_SIGNATURE = 2152398906 , NS_ERROR_FIRST_HEADER_FIELD_COMPONENT_EMPTY = 2152398882 , NS_ERROR_ALREADY_OPENED = 2152398921 , NS_ERROR_ALREADY_CONNECTED = 2152398859 , NS_ERROR_NOT_CONNECTED = 2152398860 , NS_ERROR_CONNECTION_REFUSED = 2152398861 , NS_ERROR_NET_TIMEOUT = 2152398862 , NS_ERROR_OFFLINE = 2152398864 , NS_ERROR_PORT_ACCESS_NOT_ALLOWED = 2152398867 , NS_ERROR_NET_RESET = 2152398868 , NS_ERROR_NET_INTERRUPT = 2152398919 , NS_ERROR_PROXY_CONNECTION_REFUSED = 2152398920 , NS_ERROR_NET_PARTIAL_TRANSFER = 2152398924 , NS_ERROR_NET_INADEQUATE_SECURITY = 2152398930 , NS_ERROR_NOT_RESUMABLE = 2152398873 , NS_ERROR_REDIRECT_LOOP = 2152398879 , NS_ERROR_ENTITY_CHANGED = 2152398880 , NS_ERROR_UNSAFE_CONTENT_TYPE = 2152398922 , NS_ERROR_REMOTE_XUL = 2152398923 , NS_ERROR_LOAD_SHOWED_ERRORPAGE = 2152398925 , NS_ERROR_DOCSHELL_DYING = 2152398926 , NS_ERROR_FTP_LOGIN = 2152398869 , NS_ERROR_FTP_CWD = 2152398870 , NS_ERROR_FTP_PASV = 2152398871 , NS_ERROR_FTP_PWD = 2152398872 , NS_ERROR_FTP_LIST = 2152398876 , NS_ERROR_UNKNOWN_HOST = 2152398878 , NS_ERROR_DNS_LOOKUP_QUEUE_FULL = 2152398881 , NS_ERROR_UNKNOWN_PROXY_HOST = 2152398890 , NS_ERROR_UNKNOWN_SOCKET_TYPE = 2152398899 , NS_ERROR_SOCKET_CREATE_FAILED = 2152398900 , NS_ERROR_SOCKET_ADDRESS_NOT_SUPPORTED = 2152398901 , NS_ERROR_SOCKET_ADDRESS_IN_USE = 2152398902 , NS_ERROR_CACHE_KEY_NOT_FOUND = 2152398909 , NS_ERROR_CACHE_DATA_IS_STREAM = 2152398910 , NS_ERROR_CACHE_DATA_IS_NOT_STREAM = 2152398911 , NS_ERROR_CACHE_WAIT_FOR_VALIDATION = 2152398912 , NS_ERROR_CACHE_ENTRY_DOOMED = 2152398913 , NS_ERROR_CACHE_READ_ACCESS_DENIED = 2152398914 , NS_ERROR_CACHE_WRITE_ACCESS_DENIED = 2152398915 , NS_ERROR_CACHE_IN_USE = 2152398916 , NS_ERROR_DOCUMENT_NOT_CACHED = 2152398918 , NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS = 2152398928 , NS_ERROR_HOST_IS_IP_ADDRESS = 2152398929 , NS_SUCCESS_ADOPTED_DATA = 4915290 , NS_NET_STATUS_BEGIN_FTP_TRANSACTION = 4915227 , NS_NET_STATUS_END_FTP_TRANSACTION = 4915228 , NS_SUCCESS_AUTH_FINISHED = 4915240 , NS_NET_STATUS_READING = 2152398856 , NS_NET_STATUS_WRITING = 2152398857 , NS_NET_STATUS_CONNECTING_TO = 2152398855 , NS_NET_STATUS_SENDING_TO = 2152398853 , NS_NET_STATUS_RECEIVING_FROM = 2152398854 , NS_ERROR_INTERCEPTION_FAILED = 2152398948 , NS_ERROR_HSTS_PRIMING_TIMEOUT = 2152398958 , NS_ERROR_PLUGINS_PLUGINSNOTCHANGED = 2152465384 , NS_ERROR_PLUGIN_DISABLED = 2152465385 , NS_ERROR_PLUGIN_BLOCKLISTED = 2152465386 , NS_ERROR_PLUGIN_TIME_RANGE_NOT_SUPPORTED = 2152465387 , NS_ERROR_PLUGIN_CLICKTOPLAY = 2152465388 , NS_TABLELAYOUT_CELL_NOT_FOUND = 5046272 , NS_OK_PARSE_SHEET = 5046273 , NS_POSITION_BEFORE_TABLE = 5046275 , NS_STATE_PROPERTY_NOT_THERE = 5046277 , NS_ERROR_HTMLPARSER_EOF = 2152596456 , NS_ERROR_HTMLPARSER_UNKNOWN = 2152596457 , NS_ERROR_HTMLPARSER_CANTPROPAGATE = 2152596458 , NS_ERROR_HTMLPARSER_CONTEXTMISMATCH = 2152596459 , NS_ERROR_HTMLPARSER_BADFILENAME = 2152596460 , NS_ERROR_HTMLPARSER_BADURL = 2152596461 , NS_ERROR_HTMLPARSER_INVALIDPARSERCONTEXT = 2152596462 , NS_ERROR_HTMLPARSER_INTERRUPTED = 2152596463 , NS_ERROR_HTMLPARSER_BLOCK = 2152596464 , NS_ERROR_HTMLPARSER_BADTOKENIZER = 2152596465 , NS_ERROR_HTMLPARSER_BADATTRIBUTE = 2152596466 , NS_ERROR_HTMLPARSER_UNRESOLVEDDTD = 2152596467 , NS_ERROR_HTMLPARSER_MISPLACEDTABLECONTENT = 2152596468 , NS_ERROR_HTMLPARSER_BADDTD = 2152596469 , NS_ERROR_HTMLPARSER_BADCONTEXT = 2152596470 , NS_ERROR_HTMLPARSER_STOPPARSING = 2152596471 , NS_ERROR_HTMLPARSER_UNTERMINATEDSTRINGLITERAL = 2152596472 , NS_ERROR_HTMLPARSER_HIERARCHYTOODEEP = 2152596473 , NS_ERROR_HTMLPARSER_FAKE_ENDTAG = 2152596474 , NS_ERROR_HTMLPARSER_INVALID_COMMENT = 2152596475 , NS_HTMLTOKENS_NOT_AN_ENTITY = 5113808 , NS_HTMLPARSER_VALID_META_CHARSET = 5114808 , NS_RDF_CURSOR_EMPTY = 5177345 , NS_RDF_NO_VALUE = 5177346 , NS_RDF_ASSERTION_REJECTED = 5177347 , NS_RDF_STOP_VISIT = 5177348 , NS_ERROR_UCONV_NOCONV = 2152726529 , NS_ERROR_UDEC_ILLEGALINPUT = 2152726542 , NS_OK_HAD_REPLACEMENTS = 5242883 , NS_SUCCESS_USING_FALLBACK_LOCALE = 5242882 , NS_OK_UDEC_EXACTLENGTH = 5242891 , NS_OK_UDEC_MOREINPUT = 5242892 , NS_OK_UDEC_MOREOUTPUT = 5242893 , NS_OK_UDEC_NOBOMFOUND = 5242894 , NS_OK_UENC_EXACTLENGTH = 5242913 , NS_OK_UENC_MOREOUTPUT = 5242914 , NS_ERROR_UENC_NOMAPPING = 5242915 , NS_OK_UENC_MOREINPUT = 5242916 , NS_ERROR_FILE_UNRECOGNIZED_PATH = 2152857601 , NS_ERROR_FILE_UNRESOLVABLE_SYMLINK = 2152857602 , NS_ERROR_FILE_EXECUTION_FAILED = 2152857603 , NS_ERROR_FILE_UNKNOWN_TYPE = 2152857604 , NS_ERROR_FILE_DESTINATION_NOT_DIR = 2152857605 , NS_ERROR_FILE_TARGET_DOES_NOT_EXIST = 2152857606 , NS_ERROR_FILE_COPY_OR_MOVE_FAILED = 2152857607 , NS_ERROR_FILE_ALREADY_EXISTS = 2152857608 , NS_ERROR_FILE_INVALID_PATH = 2152857609 , NS_ERROR_FILE_DISK_FULL = 2152857610 , NS_ERROR_FILE_CORRUPTED = 2152857611 , NS_ERROR_FILE_NOT_DIRECTORY = 2152857612 , NS_ERROR_FILE_IS_DIRECTORY = 2152857613 , NS_ERROR_FILE_IS_LOCKED = 2152857614 , NS_ERROR_FILE_TOO_BIG = 2152857615 , NS_ERROR_FILE_NO_DEVICE_SPACE = 2152857616 , NS_ERROR_FILE_NAME_TOO_LONG = 2152857617 , NS_ERROR_FILE_NOT_FOUND = 2152857618 , NS_ERROR_FILE_READ_ONLY = 2152857619 , NS_ERROR_FILE_DIR_NOT_EMPTY = 2152857620 , NS_ERROR_FILE_ACCESS_DENIED = 2152857621 , NS_SUCCESS_FILE_DIRECTORY_EMPTY = 5373953 , NS_SUCCESS_AGGREGATE_RESULT = 5373954 , NS_ERROR_DOM_INDEX_SIZE_ERR = 2152923137 , NS_ERROR_DOM_HIERARCHY_REQUEST_ERR = 2152923139 , NS_ERROR_DOM_WRONG_DOCUMENT_ERR = 2152923140 , NS_ERROR_DOM_INVALID_CHARACTER_ERR = 2152923141 , NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR = 2152923143 , NS_ERROR_DOM_NOT_FOUND_ERR = 2152923144 , NS_ERROR_DOM_NOT_SUPPORTED_ERR = 2152923145 , NS_ERROR_DOM_INUSE_ATTRIBUTE_ERR = 2152923146 , NS_ERROR_DOM_INVALID_STATE_ERR = 2152923147 , NS_ERROR_DOM_SYNTAX_ERR = 2152923148 , NS_ERROR_DOM_INVALID_MODIFICATION_ERR = 2152923149 , NS_ERROR_DOM_NAMESPACE_ERR = 2152923150 , NS_ERROR_DOM_INVALID_ACCESS_ERR = 2152923151 , NS_ERROR_DOM_TYPE_MISMATCH_ERR = 2152923153 , NS_ERROR_DOM_SECURITY_ERR = 2152923154 , NS_ERROR_DOM_NETWORK_ERR = 2152923155 , NS_ERROR_DOM_ABORT_ERR = 2152923156 , NS_ERROR_DOM_URL_MISMATCH_ERR = 2152923157 , NS_ERROR_DOM_QUOTA_EXCEEDED_ERR = 2152923158 , NS_ERROR_DOM_TIMEOUT_ERR = 2152923159 , NS_ERROR_DOM_INVALID_NODE_TYPE_ERR = 2152923160 , NS_ERROR_DOM_DATA_CLONE_ERR = 2152923161 , NS_ERROR_TYPE_ERR = 2152923162 , NS_ERROR_RANGE_ERR = 2152923163 , NS_ERROR_DOM_ENCODING_NOT_SUPPORTED_ERR = 2152923164 , NS_ERROR_DOM_INVALID_POINTER_ERR = 2152923165 , NS_ERROR_DOM_UNKNOWN_ERR = 2152923166 , NS_ERROR_DOM_DATA_ERR = 2152923167 , NS_ERROR_DOM_OPERATION_ERR = 2152923168 , NS_ERROR_DOM_NOT_ALLOWED_ERR = 2152923169 , NS_ERROR_DOM_SECMAN_ERR = 2152924137 , NS_ERROR_DOM_WRONG_TYPE_ERR = 2152924138 , NS_ERROR_DOM_NOT_OBJECT_ERR = 2152924139 , NS_ERROR_DOM_NOT_XPC_OBJECT_ERR = 2152924140 , NS_ERROR_DOM_NOT_NUMBER_ERR = 2152924141 , NS_ERROR_DOM_NOT_BOOLEAN_ERR = 2152924142 , NS_ERROR_DOM_NOT_FUNCTION_ERR = 2152924143 , NS_ERROR_DOM_TOO_FEW_PARAMETERS_ERR = 2152924144 , NS_ERROR_DOM_BAD_DOCUMENT_DOMAIN = 2152924145 , NS_ERROR_DOM_PROP_ACCESS_DENIED = 2152924146 , NS_ERROR_DOM_XPCONNECT_ACCESS_DENIED = 2152924147 , NS_ERROR_DOM_BAD_URI = 2152924148 , NS_ERROR_DOM_RETVAL_UNDEFINED = 2152924149 , NS_ERROR_DOM_QUOTA_REACHED = 2152924150 , NS_ERROR_UNCATCHABLE_EXCEPTION = 2152924151 , NS_ERROR_DOM_MALFORMED_URI = 2152924152 , NS_ERROR_DOM_INVALID_HEADER_NAME = 2152924153 , NS_ERROR_DOM_INVALID_STATE_XHR_HAS_INVALID_CONTEXT = 2152924154 , NS_ERROR_DOM_INVALID_STATE_XHR_MUST_BE_OPENED = 2152924155 , NS_ERROR_DOM_INVALID_STATE_XHR_MUST_NOT_BE_SENDING = 2152924156 , NS_ERROR_DOM_INVALID_STATE_XHR_MUST_NOT_BE_LOADING_OR_DONE = 2152924157 , NS_ERROR_DOM_INVALID_STATE_XHR_HAS_WRONG_RESPONSETYPE_FOR_RESPONSEXML = 2152924158 , NS_ERROR_DOM_INVALID_STATE_XHR_HAS_WRONG_RESPONSETYPE_FOR_RESPONSETEXT = 2152924159 , NS_ERROR_DOM_INVALID_STATE_XHR_CHUNKED_RESPONSETYPES_UNSUPPORTED_FOR_SYNC = 2152924160 , NS_ERROR_DOM_INVALID_ACCESS_XHR_TIMEOUT_AND_RESPONSETYPE_UNSUPPORTED_FOR_SYNC = 2152924161 , NS_ERROR_DOM_JS_DECODING_ERROR = 2152924162 , NS_SUCCESS_DOM_NO_OPERATION = 5439489 , NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW = 5439490 , NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW_UNCATCHABLE = 5439491 , NS_IMAGELIB_SUCCESS_LOAD_FINISHED = 5505024 , NS_IMAGELIB_ERROR_FAILURE = 2152988677 , NS_IMAGELIB_ERROR_NO_DECODER = 2152988678 , NS_IMAGELIB_ERROR_NOT_FINISHED = 2152988679 , NS_IMAGELIB_ERROR_NO_ENCODER = 2152988681 , NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND = 5636097 , NS_SUCCESS_EDITOR_FOUND_TARGET = 5636098 , NS_ERROR_XPC_NOT_ENOUGH_ARGS = 2153185281 , NS_ERROR_XPC_NEED_OUT_OBJECT = 2153185282 , NS_ERROR_XPC_CANT_SET_OUT_VAL = 2153185283 , NS_ERROR_XPC_NATIVE_RETURNED_FAILURE = 2153185284 , NS_ERROR_XPC_CANT_GET_INTERFACE_INFO = 2153185285 , NS_ERROR_XPC_CANT_GET_PARAM_IFACE_INFO = 2153185286 , NS_ERROR_XPC_CANT_GET_METHOD_INFO = 2153185287 , NS_ERROR_XPC_UNEXPECTED = 2153185288 , NS_ERROR_XPC_BAD_CONVERT_JS = 2153185289 , NS_ERROR_XPC_BAD_CONVERT_NATIVE = 2153185290 , NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF = 2153185291 , NS_ERROR_XPC_BAD_OP_ON_WN_PROTO = 2153185292 , NS_ERROR_XPC_CANT_CONVERT_WN_TO_FUN = 2153185293 , NS_ERROR_XPC_CANT_DEFINE_PROP_ON_WN = 2153185294 , NS_ERROR_XPC_CANT_WATCH_WN_STATIC = 2153185295 , NS_ERROR_XPC_CANT_EXPORT_WN_STATIC = 2153185296 , NS_ERROR_XPC_SCRIPTABLE_CALL_FAILED = 2153185297 , NS_ERROR_XPC_SCRIPTABLE_CTOR_FAILED = 2153185298 , NS_ERROR_XPC_CANT_CALL_WO_SCRIPTABLE = 2153185299 , NS_ERROR_XPC_CANT_CTOR_WO_SCRIPTABLE = 2153185300 , NS_ERROR_XPC_CI_RETURNED_FAILURE = 2153185301 , NS_ERROR_XPC_GS_RETURNED_FAILURE = 2153185302 , NS_ERROR_XPC_BAD_CID = 2153185303 , NS_ERROR_XPC_BAD_IID = 2153185304 , NS_ERROR_XPC_CANT_CREATE_WN = 2153185305 , NS_ERROR_XPC_JS_THREW_EXCEPTION = 2153185306 , NS_ERROR_XPC_JS_THREW_NATIVE_OBJECT = 2153185307 , NS_ERROR_XPC_JS_THREW_JS_OBJECT = 2153185308 , NS_ERROR_XPC_JS_THREW_NULL = 2153185309 , NS_ERROR_XPC_JS_THREW_STRING = 2153185310 , NS_ERROR_XPC_JS_THREW_NUMBER = 2153185311 , NS_ERROR_XPC_JAVASCRIPT_ERROR = 2153185312 , NS_ERROR_XPC_JAVASCRIPT_ERROR_WITH_DETAILS = 2153185313 , NS_ERROR_XPC_CANT_CONVERT_PRIMITIVE_TO_ARRAY = 2153185314 , NS_ERROR_XPC_CANT_CONVERT_OBJECT_TO_ARRAY = 2153185315 , NS_ERROR_XPC_NOT_ENOUGH_ELEMENTS_IN_ARRAY = 2153185316 , NS_ERROR_XPC_CANT_GET_ARRAY_INFO = 2153185317 , NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING = 2153185318 , NS_ERROR_XPC_SECURITY_MANAGER_VETO = 2153185319 , NS_ERROR_XPC_INTERFACE_NOT_SCRIPTABLE = 2153185320 , NS_ERROR_XPC_INTERFACE_NOT_FROM_NSISUPPORTS = 2153185321 , NS_ERROR_XPC_CANT_GET_JSOBJECT_OF_DOM_OBJECT = 2153185322 , NS_ERROR_XPC_CANT_SET_READ_ONLY_CONSTANT = 2153185323 , NS_ERROR_XPC_CANT_SET_READ_ONLY_ATTRIBUTE = 2153185324 , NS_ERROR_XPC_CANT_SET_READ_ONLY_METHOD = 2153185325 , NS_ERROR_XPC_CANT_ADD_PROP_TO_WRAPPED_NATIVE = 2153185326 , NS_ERROR_XPC_CALL_TO_SCRIPTABLE_FAILED = 2153185327 , NS_ERROR_XPC_JSOBJECT_HAS_NO_FUNCTION_NAMED = 2153185328 , NS_ERROR_XPC_BAD_ID_STRING = 2153185329 , NS_ERROR_XPC_BAD_INITIALIZER_NAME = 2153185330 , NS_ERROR_XPC_HAS_BEEN_SHUTDOWN = 2153185331 , NS_ERROR_XPC_CANT_MODIFY_PROP_ON_WN = 2153185332 , NS_ERROR_XPC_BAD_CONVERT_JS_ZERO_ISNOT_NULL = 2153185333 , NS_ERROR_XPC_CANT_PASS_CPOW_TO_NATIVE = 2153185334 , NS_ERROR_LAUNCHED_CHILD_PROCESS = 2153251016 , NS_ERROR_CSP_FORM_ACTION_VIOLATION = 2153381986 , NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION = 2153381987 , NS_ERROR_SRI_CORRUPT = 2153382088 , NS_ERROR_SRI_DISABLED = 2153382089 , NS_ERROR_SRI_NOT_ELIGIBLE = 2153382090 , NS_ERROR_SRI_UNEXPECTED_HASH_TYPE = 2153382091 , NS_ERROR_SRI_IMPORT = 2153382092 , NS_ERROR_CMS_VERIFY_NOT_SIGNED = 2153382912 , NS_ERROR_CMS_VERIFY_NO_CONTENT_INFO = 2153382913 , NS_ERROR_CMS_VERIFY_BAD_DIGEST = 2153382914 , NS_ERROR_CMS_VERIFY_NOCERT = 2153382916 , NS_ERROR_CMS_VERIFY_UNTRUSTED = 2153382917 , NS_ERROR_CMS_VERIFY_ERROR_UNVERIFIED = 2153382919 , NS_ERROR_CMS_VERIFY_ERROR_PROCESSING = 2153382920 , NS_ERROR_CMS_VERIFY_BAD_SIGNATURE = 2153382921 , NS_ERROR_CMS_VERIFY_DIGEST_MISMATCH = 2153382922 , NS_ERROR_CMS_VERIFY_UNKNOWN_ALGO = 2153382923 , NS_ERROR_CMS_VERIFY_UNSUPPORTED_ALGO = 2153382924 , NS_ERROR_CMS_VERIFY_MALFORMED_SIGNATURE = 2153382925 , NS_ERROR_CMS_VERIFY_HEADER_MISMATCH = 2153382926 , NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED = 2153382927 , NS_ERROR_CMS_VERIFY_CERT_WITHOUT_ADDRESS = 2153382928 , NS_ERROR_CMS_ENCRYPT_NO_BULK_ALG = 2153382944 , NS_ERROR_CMS_ENCRYPT_INCOMPLETE = 2153382945 , NS_ERROR_DOM_INVALID_EXPRESSION_ERR = 2153447475 , NS_ERROR_DOM_TYPE_ERR = 2153447476 , NS_ERROR_WONT_HANDLE_CONTENT = 2153578497 , NS_ERROR_MALWARE_URI = 2153578526 , NS_ERROR_PHISHING_URI = 2153578527 , NS_ERROR_TRACKING_URI = 2153578530 , NS_ERROR_UNWANTED_URI = 2153578531 , NS_ERROR_BLOCKED_URI = 2153578533 , NS_ERROR_HARMFUL_URI = 2153578534 , NS_ERROR_SAVE_LINK_AS_TIMEOUT = 2153578528 , NS_ERROR_PARSED_DATA_CACHED = 2153578529 , NS_REFRESHURI_HEADER_FOUND = 6094850 , NS_ERROR_CONTENT_BLOCKED = 2153644038 , NS_ERROR_CONTENT_BLOCKED_SHOW_ALT = 2153644039 , NS_PROPTABLE_PROP_NOT_THERE = 2153644042 , NS_ERROR_XBL_BLOCKED = 2153644047 , NS_ERROR_CONTENT_CRASHED = 2153644048 , NS_HTML_STYLE_PROPERTY_NOT_THERE = 6160386 , NS_CONTENT_BLOCKED = 6160392 , NS_CONTENT_BLOCKED_SHOW_ALT = 6160393 , NS_PROPTABLE_PROP_OVERWRITTEN = 6160395 , NS_FINDBROADCASTER_NOT_FOUND = 6160396 , NS_FINDBROADCASTER_FOUND = 6160397 , NS_FINDBROADCASTER_AWAIT_OVERLAYS = 6160398 , NS_ERROR_XSLT_PARSE_FAILURE = 2153775105 , NS_ERROR_XPATH_PARSE_FAILURE = 2153775106 , NS_ERROR_XSLT_ALREADY_SET = 2153775107 , NS_ERROR_XSLT_EXECUTION_FAILURE = 2153775108 , NS_ERROR_XPATH_UNKNOWN_FUNCTION = 2153775109 , NS_ERROR_XSLT_BAD_RECURSION = 2153775110 , NS_ERROR_XSLT_BAD_VALUE = 2153775111 , NS_ERROR_XSLT_NODESET_EXPECTED = 2153775112 , NS_ERROR_XSLT_ABORTED = 2153775113 , NS_ERROR_XSLT_NETWORK_ERROR = 2153775114 , NS_ERROR_XSLT_WRONG_MIME_TYPE = 2153775115 , NS_ERROR_XSLT_LOAD_RECURSION = 2153775116 , NS_ERROR_XPATH_BAD_ARGUMENT_COUNT = 2153775117 , NS_ERROR_XPATH_BAD_EXTENSION_FUNCTION = 2153775118 , NS_ERROR_XPATH_PAREN_EXPECTED = 2153775119 , NS_ERROR_XPATH_INVALID_AXIS = 2153775120 , NS_ERROR_XPATH_NO_NODE_TYPE_TEST = 2153775121 , NS_ERROR_XPATH_BRACKET_EXPECTED = 2153775122 , NS_ERROR_XPATH_INVALID_VAR_NAME = 2153775123 , NS_ERROR_XPATH_UNEXPECTED_END = 2153775124 , NS_ERROR_XPATH_OPERATOR_EXPECTED = 2153775125 , NS_ERROR_XPATH_UNCLOSED_LITERAL = 2153775126 , NS_ERROR_XPATH_BAD_COLON = 2153775127 , NS_ERROR_XPATH_BAD_BANG = 2153775128 , NS_ERROR_XPATH_ILLEGAL_CHAR = 2153775129 , NS_ERROR_XPATH_BINARY_EXPECTED = 2153775130 , NS_ERROR_XSLT_LOAD_BLOCKED_ERROR = 2153775131 , NS_ERROR_XPATH_INVALID_EXPRESSION_EVALUATED = 2153775132 , NS_ERROR_XPATH_UNBALANCED_CURLY_BRACE = 2153775133 , NS_ERROR_XSLT_BAD_NODE_NAME = 2153775134 , NS_ERROR_XSLT_VAR_ALREADY_SET = 2153775135 , NS_ERROR_XSLT_CALL_TO_KEY_NOT_ALLOWED = 2153775136 , NS_XSLT_GET_NEW_HANDLER = 6291457 , NS_ERROR_TRANSPORT_INIT = 2153840641 , NS_ERROR_DUPLICATE_HANDLE = 2153840642 , NS_ERROR_BRIDGE_OPEN_PARENT = 2153840643 , NS_ERROR_BRIDGE_OPEN_CHILD = 2153840644 , NS_ERROR_DOM_SVG_WRONG_TYPE_ERR = 2153906176 , NS_ERROR_DOM_SVG_MATRIX_NOT_INVERTABLE = 2153906178 , NS_ERROR_STORAGE_BUSY = 2153971713 , NS_ERROR_STORAGE_IOERR = 2153971714 , NS_ERROR_STORAGE_CONSTRAINT = 2153971715 , NS_ERROR_DOM_FILE_NOT_FOUND_ERR = 2154102784 , NS_ERROR_DOM_FILE_NOT_READABLE_ERR = 2154102785 , NS_ERROR_DOM_FILE_ABORT_ERR = 2154102786 , NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR = 2154168321 , NS_ERROR_DOM_INDEXEDDB_NOT_FOUND_ERR = 2154168323 , NS_ERROR_DOM_INDEXEDDB_CONSTRAINT_ERR = 2154168324 , NS_ERROR_DOM_INDEXEDDB_DATA_ERR = 2154168325 , NS_ERROR_DOM_INDEXEDDB_NOT_ALLOWED_ERR = 2154168326 , NS_ERROR_DOM_INDEXEDDB_TRANSACTION_INACTIVE_ERR = 2154168327 , NS_ERROR_DOM_INDEXEDDB_ABORT_ERR = 2154168328 , NS_ERROR_DOM_INDEXEDDB_READ_ONLY_ERR = 2154168329 , NS_ERROR_DOM_INDEXEDDB_TIMEOUT_ERR = 2154168330 , NS_ERROR_DOM_INDEXEDDB_QUOTA_ERR = 2154168331 , NS_ERROR_DOM_INDEXEDDB_VERSION_ERR = 2154168332 , NS_ERROR_DOM_INDEXEDDB_RECOVERABLE_ERR = 2154169321 , NS_ERROR_DOM_FILEHANDLE_UNKNOWN_ERR = 2154233857 , NS_ERROR_DOM_FILEHANDLE_NOT_ALLOWED_ERR = 2154233858 , NS_ERROR_DOM_FILEHANDLE_INACTIVE_ERR = 2154233859 , NS_ERROR_DOM_FILEHANDLE_ABORT_ERR = 2154233860 , NS_ERROR_DOM_FILEHANDLE_READ_ONLY_ERR = 2154233861 , NS_ERROR_DOM_FILEHANDLE_QUOTA_ERR = 2154233862 , NS_ERROR_SIGNED_JAR_NOT_SIGNED = 2154299393 , NS_ERROR_SIGNED_JAR_MODIFIED_ENTRY = 2154299394 , NS_ERROR_SIGNED_JAR_UNSIGNED_ENTRY = 2154299395 , NS_ERROR_SIGNED_JAR_ENTRY_MISSING = 2154299396 , NS_ERROR_SIGNED_JAR_WRONG_SIGNATURE = 2154299397 , NS_ERROR_SIGNED_JAR_ENTRY_TOO_LARGE = 2154299398 , NS_ERROR_SIGNED_JAR_ENTRY_INVALID = 2154299399 , NS_ERROR_SIGNED_JAR_MANIFEST_INVALID = 2154299400 , NS_ERROR_DOM_FILESYSTEM_INVALID_PATH_ERR = 2154364929 , NS_ERROR_DOM_FILESYSTEM_INVALID_MODIFICATION_ERR = 2154364930 , NS_ERROR_DOM_FILESYSTEM_NO_MODIFICATION_ALLOWED_ERR = 2154364931 , NS_ERROR_DOM_FILESYSTEM_PATH_EXISTS_ERR = 2154364932 , NS_ERROR_DOM_FILESYSTEM_TYPE_MISMATCH_ERR = 2154364933 , NS_ERROR_DOM_FILESYSTEM_UNKNOWN_ERR = 2154364934 , NS_ERROR_SIGNED_APP_MANIFEST_INVALID = 2154496001 , NS_ERROR_DOM_ANIM_MISSING_PROPS_ERR = 2154561537 , NS_ERROR_DOM_PUSH_INVALID_REGISTRATION_ERR = 2154627073 , NS_ERROR_DOM_PUSH_DENIED_ERR = 2154627074 , NS_ERROR_DOM_PUSH_ABORT_ERR = 2154627075 , NS_ERROR_DOM_PUSH_SERVICE_UNREACHABLE = 2154627076 , NS_ERROR_DOM_PUSH_INVALID_KEY_ERR = 2154627077 , NS_ERROR_DOM_PUSH_MISMATCHED_KEY_ERR = 2154627078 , NS_ERROR_DOM_PUSH_GCM_DISABLED = 2154627079 , NS_ERROR_DOM_MEDIA_ABORT_ERR = 2154692609 , NS_ERROR_DOM_MEDIA_NOT_ALLOWED_ERR = 2154692610 , NS_ERROR_DOM_MEDIA_NOT_SUPPORTED_ERR = 2154692611 , NS_ERROR_DOM_MEDIA_DECODE_ERR = 2154692612 , NS_ERROR_DOM_MEDIA_FATAL_ERR = 2154692613 , NS_ERROR_DOM_MEDIA_METADATA_ERR = 2154692614 , NS_ERROR_DOM_MEDIA_OVERFLOW_ERR = 2154692615 , NS_ERROR_DOM_MEDIA_END_OF_STREAM = 2154692616 , NS_ERROR_DOM_MEDIA_WAITING_FOR_DATA = 2154692617 , NS_ERROR_DOM_MEDIA_CANCELED = 2154692618 , NS_ERROR_DOM_MEDIA_MEDIASINK_ERR = 2154692619 , NS_ERROR_DOM_MEDIA_DEMUXER_ERR = 2154692620 , NS_ERROR_DOM_MEDIA_CDM_ERR = 2154692621 , NS_ERROR_DOM_MEDIA_NEED_NEW_DECODER = 2154692622 , NS_ERROR_DOM_MEDIA_INITIALIZING_DECODER = 2154692623 , NS_ERROR_DOM_MEDIA_CUBEB_INITIALIZATION_ERR = 2154692709 , NS_ERROR_UC_UPDATE_UNKNOWN = 2154758145 , NS_ERROR_UC_UPDATE_DUPLICATE_PREFIX = 2154758146 , NS_ERROR_UC_UPDATE_INFINITE_LOOP = 2154758147 , NS_ERROR_UC_UPDATE_WRONG_REMOVAL_INDICES = 2154758148 , NS_ERROR_UC_UPDATE_CHECKSUM_MISMATCH = 2154758149 , NS_ERROR_UC_UPDATE_MISSING_CHECKSUM = 2154758150 , NS_ERROR_UC_UPDATE_SHUTDOWNING = 2154758151 , NS_ERROR_UC_UPDATE_TABLE_NOT_FOUND = 2154758152 , NS_ERROR_UC_UPDATE_BUILD_PREFIX_FAILURE = 2154758153 , NS_ERROR_UC_UPDATE_FAIL_TO_WRITE_DISK = 2154758154 , NS_ERROR_UC_UPDATE_PROTOCOL_PARSER_ERROR = 2154758155 , NS_ERROR_INTERNAL_ERRORRESULT_JS_EXCEPTION = 2154823681 , NS_ERROR_INTERNAL_ERRORRESULT_DOMEXCEPTION = 2154823682 , NS_ERROR_INTERNAL_ERRORRESULT_EXCEPTION_ON_JSCONTEXT = 2154823683 , NS_ERROR_INTERNAL_ERRORRESULT_TYPEERROR = 2154823684 , NS_ERROR_INTERNAL_ERRORRESULT_RANGEERROR = 2154823685 , NS_ERROR_DOWNLOAD_COMPLETE = 2155347969 , NS_ERROR_DOWNLOAD_NOT_PARTIAL = 2155347970 , NS_ERROR_UNORM_MOREOUTPUT = 2155348001 , NS_ERROR_DOCSHELL_REQUEST_REJECTED = 2155348969 , NS_ERROR_DOCUMENT_IS_PRINTMODE = 2155349969 , NS_SUCCESS_DONT_FIXUP = 7864321 , NS_SUCCESS_RESTART_APP_NOT_SAME_PROFILE = 7864323 , NS_SUCCESS_UNORM_NOTFOUND = 7864337 , NS_ERROR_NOT_IN_TREE = 2155348006 , NS_OK_NO_NAME_CLAUSE_HANDLED = 7864354 , } pub type nsrefcnt = root :: MozRefCountType ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIFrame { _unused : [ u8 ; 0 ] } pub type nsAString = root :: nsTSubstring < u16 > ; pub type nsAutoString = [ u64 ; 19usize ] ; pub type nsACString = root :: nsTSubstring < :: std :: os :: raw :: c_char > ; pub type nsCString = root :: nsTString < :: std :: os :: raw :: c_char > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsCharTraits { pub _address : u8 , } 
 /// @see nsTAString 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsReadingIterator < CharT > { pub mStart : * mut CharT , pub mEnd : * mut CharT , pub mPosition : * mut CharT , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < CharT > > , } pub type nsReadingIterator_self_type < CharT > = root :: nsReadingIterator < CharT > ; pub type nsReadingIterator_difference_type = isize ; pub type nsReadingIterator_size_type = usize ; pub type nsReadingIterator_value_type < CharT > = CharT ; pub type nsReadingIterator_pointer < CharT > = * mut CharT ; pub type nsReadingIterator_reference = u8 ; 
 /// @see nsTAString 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsWritingIterator < CharT > { pub mStart : * mut CharT , pub mEnd : * mut CharT , pub mPosition : * mut CharT , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < CharT > > , } pub type nsWritingIterator_self_type < CharT > = root :: nsWritingIterator < CharT > ; pub type nsWritingIterator_difference_type = isize ; pub type nsWritingIterator_size_type = usize ; pub type nsWritingIterator_value_type < CharT > = CharT ; pub type nsWritingIterator_pointer < CharT > = * mut CharT ; pub type nsWritingIterator_reference = u8 ; # [ repr ( C ) ] pub struct nsTStringComparator__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsTStringComparator { pub vtable_ : * const nsTStringComparator__bindgen_vtable , } pub type nsTStringComparator_char_type < T > = T ; 
 /// nsTSubstring is an abstract string class. From an API perspective, this
    /// class is the root of the string class hierarchy. It represents a single
    /// contiguous array of characters, which may or may not be null-terminated.
    /// This type is not instantiated directly. A sub-class is instantiated
    /// instead. For example, see nsTString.
    ///
    /// NAMES:
    /// nsAString for wide characters
    /// nsACString for narrow characters
    /// 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsTSubstring < T > { pub _base : root :: mozilla :: detail :: nsTStringRepr < T > , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , } pub type nsTSubstring_self_type < T > = root :: nsTSubstring < T > ; pub type nsTSubstring_string_type < T > = root :: nsTString < T > ; pub type nsTSubstring_base_string_type < T > = root :: mozilla :: detail :: nsTStringRepr < T > ; pub type nsTSubstring_substring_type < T > = root :: nsTSubstring_base_string_type < T > ; pub type nsTSubstring_literalstring_type < T > = root :: nsTSubstring_base_string_type < T > ; pub type nsTSubstring_fallible_t < T > = root :: nsTSubstring_base_string_type < T > ; pub type nsTSubstring_char_type < T > = root :: nsTSubstring_base_string_type < T > ; pub type nsTSubstring_substring_tuple_type < T > = root :: nsTSubstring_base_string_type < T > ; pub type nsTSubstring_const_iterator < T > = root :: nsTSubstring_base_string_type < T > ; pub type nsTSubstring_iterator < T > = root :: nsTSubstring_base_string_type < T > ; pub type nsTSubstring_comparator_type < T > = root :: nsTSubstring_base_string_type < T > ; pub type nsTSubstring_char_iterator < T > = root :: nsTSubstring_base_string_type < T > ; pub type nsTSubstring_const_char_iterator < T > = root :: nsTSubstring_base_string_type < T > ; pub type nsTSubstring_index_type < T > = root :: nsTSubstring_base_string_type < T > ; pub type nsTSubstring_size_type < T > = root :: nsTSubstring_base_string_type < T > ; pub type nsTSubstring_DataFlags < T > = root :: nsTSubstring_base_string_type < T > ; pub type nsTSubstring_ClassFlags < T > = root :: nsTSubstring_base_string_type < T > ; 
 /// nsTSubstringTuple
    ///
    /// Represents a tuple of string fragments.  Built as a recursive binary tree.
    /// It is used to implement the concatenation of two or more string objects.
    ///
    /// NOTE: This class is a private implementation detail and should never be
    /// referenced outside the string code. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsTSubstringTuple < T > { pub mHead : * const root :: nsTSubstringTuple_self_type < T > , pub mFragA : * const root :: nsTSubstringTuple_base_string_type < T > , pub mFragB : * const root :: nsTSubstringTuple_base_string_type < T > , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , } pub type nsTSubstringTuple_char_type < T > = T ; pub type nsTSubstringTuple_self_type < T > = root :: nsTSubstringTuple < T > ; pub type nsTSubstringTuple_base_string_type < T > = root :: mozilla :: detail :: nsTStringRepr < root :: nsTSubstringTuple_char_type < T > > ; pub type nsTSubstringTuple_size_type = u32 ; 
 /// nsTLiteralString_CharT
    ///
    /// Stores a null-terminated, immutable sequence of characters.
    ///
    /// nsTString-lookalike that restricts its string value to a literal character
    /// sequence. Can be implicitly cast to const nsTString& (the const is
    /// essential, since this class's data are not writable). The data are assumed
    /// to be static (permanent) and therefore, as an optimization, this class
    /// does not have a destructor. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsTLiteralString < T > { pub _base : root :: mozilla :: detail :: nsTStringRepr < T > , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , } pub type nsTLiteralString_self_type < T > = root :: nsTLiteralString < T > ; pub type nsTLiteralString_char_type = [ u8 ; 0usize ] ; pub type nsTLiteralString_size_type = [ u8 ; 0usize ] ; pub type nsTLiteralString_DataFlags = [ u8 ; 0usize ] ; pub type nsTLiteralString_ClassFlags = [ u8 ; 0usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsTLiteralString_raw_type { pub _address : u8 , } pub type nsTLiteralString_raw_type_type < N > = * mut N ; 
 /// This is the canonical null-terminated string class.  All subclasses
    /// promise null-terminated storage.  Instances of this class allocate
    /// strings on the heap.
    ///
    /// NAMES:
    /// nsString for wide characters
    /// nsCString for narrow characters
    ///
    /// This class is also known as nsAFlat[C]String, where "flat" is used
    /// to denote a null-terminated string. 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsTString < T > { pub _base : root :: nsTSubstring < T > , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , } pub type nsTString_self_type < T > = root :: nsTString < T > ; pub type nsTString_literalstring_type = [ u8 ; 0usize ] ; pub type nsTString_fallible_t = [ u8 ; 0usize ] ; pub type nsTString_char_type = [ u8 ; 0usize ] ; pub type nsTString_substring_tuple_type = [ u8 ; 0usize ] ; pub type nsTString_const_iterator = [ u8 ; 0usize ] ; pub type nsTString_iterator = [ u8 ; 0usize ] ; pub type nsTString_comparator_type = [ u8 ; 0usize ] ; pub type nsTString_char_iterator = [ u8 ; 0usize ] ; pub type nsTString_const_char_iterator = [ u8 ; 0usize ] ; pub type nsTString_index_type = [ u8 ; 0usize ] ; pub type nsTString_size_type = [ u8 ; 0usize ] ; pub type nsTString_DataFlags = [ u8 ; 0usize ] ; pub type nsTString_ClassFlags = [ u8 ; 0usize ] ; 
 /// returns the null-terminated string 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsTString_raw_type { pub _address : u8 , } pub type nsTString_raw_type_type < U > = * mut U ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsTString_Segment { pub mBegin : u32 , pub mLength : u32 , } pub type nsTAutoStringN_self_type = u8 ; pub type nsTAutoStringN_base_string_type < T > = root :: nsTString < T > ; pub type nsTAutoStringN_string_type < T > = root :: nsTAutoStringN_base_string_type < T > ; pub type nsTAutoStringN_char_type < T > = root :: nsTAutoStringN_base_string_type < T > ; pub type nsTAutoStringN_substring_type < T > = root :: nsTAutoStringN_base_string_type < T > ; pub type nsTAutoStringN_size_type < T > = root :: nsTAutoStringN_base_string_type < T > ; pub type nsTAutoStringN_substring_tuple_type < T > = root :: nsTAutoStringN_base_string_type < T > ; pub type nsTAutoStringN_literalstring_type < T > = root :: nsTAutoStringN_base_string_type < T > ; pub type nsTAutoStringN_DataFlags < T > = root :: nsTAutoStringN_base_string_type < T > ; pub type nsTAutoStringN_ClassFlags < T > = root :: nsTAutoStringN_base_string_type < T > ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_Nothing : root :: nsCSSTokenSerializationType = 0 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_Whitespace : root :: nsCSSTokenSerializationType = 1 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_AtKeyword_or_Hash : root :: nsCSSTokenSerializationType = 2 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_Number : root :: nsCSSTokenSerializationType = 3 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_Dimension : root :: nsCSSTokenSerializationType = 4 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_Percentage : root :: nsCSSTokenSerializationType = 5 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_URange : root :: nsCSSTokenSerializationType = 6 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_URL_or_BadURL : root :: nsCSSTokenSerializationType = 7 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_Function : root :: nsCSSTokenSerializationType = 8 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_Ident : root :: nsCSSTokenSerializationType = 9 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_CDC : root :: nsCSSTokenSerializationType = 10 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_DashMatch : root :: nsCSSTokenSerializationType = 11 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_ContainsMatch : root :: nsCSSTokenSerializationType = 12 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_Symbol_Hash : root :: nsCSSTokenSerializationType = 13 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_Symbol_At : root :: nsCSSTokenSerializationType = 14 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_Symbol_Dot_or_Plus : root :: nsCSSTokenSerializationType = 15 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_Symbol_Minus : root :: nsCSSTokenSerializationType = 16 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_Symbol_OpenParen : root :: nsCSSTokenSerializationType = 17 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_Symbol_Question : root :: nsCSSTokenSerializationType = 18 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_Symbol_Assorted : root :: nsCSSTokenSerializationType = 19 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_Symbol_Equals : root :: nsCSSTokenSerializationType = 20 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_Symbol_Bar : root :: nsCSSTokenSerializationType = 21 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_Symbol_Slash : root :: nsCSSTokenSerializationType = 22 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_Symbol_Asterisk : root :: nsCSSTokenSerializationType = 23 ; pub const nsCSSTokenSerializationType_eCSSTokenSerialization_Other : root :: nsCSSTokenSerializationType = 24 ; pub type nsCSSTokenSerializationType = :: std :: os :: raw :: c_uint ; # [ repr ( C ) ] pub struct nsCSSScanner { pub mBuffer : * const u16 , pub mOffset : u32 , pub mCount : u32 , pub mLineNumber : u32 , pub mLineOffset : u32 , pub mTokenLineNumber : u32 , pub mTokenLineOffset : u32 , pub mTokenOffset : u32 , pub mRecordStartOffset : u32 , pub mEOFCharacters : root :: nsCSSScanner_EOFCharacters , pub mReporter : * mut root :: mozilla :: css :: ErrorReporter , pub mRecording : bool , pub mSeenBadToken : bool , pub mSeenVariableReference : bool , pub mSourceMapURL : ::nsstring::nsStringRepr , pub mSourceURL : ::nsstring::nsStringRepr , } pub const nsCSSScanner_EOFCharacters_eEOFCharacters_None : root :: nsCSSScanner_EOFCharacters = 0 ; pub const nsCSSScanner_EOFCharacters_eEOFCharacters_DropBackslash : root :: nsCSSScanner_EOFCharacters = 1 ; pub const nsCSSScanner_EOFCharacters_eEOFCharacters_ReplacementChar : root :: nsCSSScanner_EOFCharacters = 2 ; pub const nsCSSScanner_EOFCharacters_eEOFCharacters_Asterisk : root :: nsCSSScanner_EOFCharacters = 4 ; pub const nsCSSScanner_EOFCharacters_eEOFCharacters_Slash : root :: nsCSSScanner_EOFCharacters = 8 ; pub const nsCSSScanner_EOFCharacters_eEOFCharacters_DoubleQuote : root :: nsCSSScanner_EOFCharacters = 16 ; pub const nsCSSScanner_EOFCharacters_eEOFCharacters_SingleQuote : root :: nsCSSScanner_EOFCharacters = 32 ; pub const nsCSSScanner_EOFCharacters_eEOFCharacters_CloseParen : root :: nsCSSScanner_EOFCharacters = 64 ; pub type nsCSSScanner_EOFCharacters = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_nsCSSScanner ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSScanner > ( ) , 96usize , concat ! ( "Size of: " , stringify ! ( nsCSSScanner ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSScanner > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSScanner ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSScanner ) ) . mBuffer as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSScanner ) , "::" , stringify ! ( mBuffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSScanner ) ) . mOffset as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSScanner ) , "::" , stringify ! ( mOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSScanner ) ) . mCount as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSScanner ) , "::" , stringify ! ( mCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSScanner ) ) . mLineNumber as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSScanner ) , "::" , stringify ! ( mLineNumber ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSScanner ) ) . mLineOffset as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSScanner ) , "::" , stringify ! ( mLineOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSScanner ) ) . mTokenLineNumber as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSScanner ) , "::" , stringify ! ( mTokenLineNumber ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSScanner ) ) . mTokenLineOffset as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSScanner ) , "::" , stringify ! ( mTokenLineOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSScanner ) ) . mTokenOffset as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSScanner ) , "::" , stringify ! ( mTokenOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSScanner ) ) . mRecordStartOffset as * const _ as usize } , 36usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSScanner ) , "::" , stringify ! ( mRecordStartOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSScanner ) ) . mEOFCharacters as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSScanner ) , "::" , stringify ! ( mEOFCharacters ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSScanner ) ) . mReporter as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSScanner ) , "::" , stringify ! ( mReporter ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSScanner ) ) . mRecording as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSScanner ) , "::" , stringify ! ( mRecording ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSScanner ) ) . mSeenBadToken as * const _ as usize } , 57usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSScanner ) , "::" , stringify ! ( mSeenBadToken ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSScanner ) ) . mSeenVariableReference as * const _ as usize } , 58usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSScanner ) , "::" , stringify ! ( mSeenVariableReference ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSScanner ) ) . mSourceMapURL as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSScanner ) , "::" , stringify ! ( mSourceMapURL ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSScanner ) ) . mSourceURL as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSScanner ) , "::" , stringify ! ( mSourceURL ) ) ) ; } # [ repr ( C ) ] pub struct nsISupports__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; 
 /// Basic component object model interface. Objects which implement
    /// this interface support runtime interface discovery (QueryInterface)
    /// and a reference counted memory model (AddRef/Release). This is
    /// modelled after the win32 IUnknown API. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsISupports { pub vtable_ : * const nsISupports__bindgen_vtable , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsISupports_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsISupports ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsISupports > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsISupports ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsISupports > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsISupports ) ) ) ; } impl Clone for nsISupports { fn clone ( & self ) -> Self { * self } } pub type PRUint32 = :: std :: os :: raw :: c_uint ; pub type PRIntn = :: std :: os :: raw :: c_int ; pub type PRUintn = :: std :: os :: raw :: c_uint ; 
 /// TYPES:       PRSize
    /// DESCRIPTION:
    /// A type for representing the size of objects. 
 pub type PRSize = usize ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct PRThread { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsCycleCollectingAutoRefCnt { pub mRefCntAndFlags : usize , } pub type nsCycleCollectingAutoRefCnt_Suspect = :: std :: option :: Option < unsafe extern "C" fn ( aPtr : * mut :: std :: os :: raw :: c_void , aCp : * mut root :: nsCycleCollectionParticipant , aRefCnt : * mut root :: nsCycleCollectingAutoRefCnt , aShouldDelete : * mut bool ) > ; # [ test ] fn bindgen_test_layout_nsCycleCollectingAutoRefCnt ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCycleCollectingAutoRefCnt > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsCycleCollectingAutoRefCnt ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCycleCollectingAutoRefCnt > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCycleCollectingAutoRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCycleCollectingAutoRefCnt ) ) . mRefCntAndFlags as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCycleCollectingAutoRefCnt ) , "::" , stringify ! ( mRefCntAndFlags ) ) ) ; } impl Clone for nsCycleCollectingAutoRefCnt { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsAutoRefCnt { pub mValue : root :: nsrefcnt , } pub const nsAutoRefCnt_isThreadSafe : bool = false ; # [ test ] fn bindgen_test_layout_nsAutoRefCnt ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsAutoRefCnt > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsAutoRefCnt ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsAutoRefCnt > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsAutoRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsAutoRefCnt ) ) . mValue as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsAutoRefCnt ) , "::" , stringify ! ( mValue ) ) ) ; } impl Clone for nsAutoRefCnt { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct RefPtr < T > { pub mRawPtr : * mut T , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , } pub type RefPtr_element_type < T > = T ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RefPtr_Proxy { pub _address : u8 , } pub type RefPtr_Proxy_member_function = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RefPtr_ConstRemovingRefPtrTraits { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct JSContext { _unused : [ u8 ; 0 ] } pub mod JS { # [ allow ( unused_imports ) ] use self :: super :: super :: root ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct DeletePolicy { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct FreePolicy { pub _address : u8 , } # [ test ] fn bindgen_test_layout_FreePolicy ( ) { assert_eq ! ( :: std :: mem :: size_of :: < FreePolicy > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( FreePolicy ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < FreePolicy > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( FreePolicy ) ) ) ; } impl Clone for FreePolicy { fn clone ( & self ) -> Self { * self } } 
 /// Local variable of type T whose value is always rooted. This is typically
        /// used for local variables, or for non-rooted values being passed to a
        /// function that requires a handle, e.g. Foo(Root<T>(cx, x)).
        ///
        /// If you want to add additional methods to Rooted for a specific
        /// specialization, define a RootedBase<T> specialization containing them. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Rooted { pub _address : u8 , } pub type Rooted_ElementType < T > = T ; pub mod dbg { # [ allow ( unused_imports ) ] use self :: super :: super :: super :: root ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GarbageCollectionEvent { pub majorGCNumber_ : u64 , pub reason : * const :: std :: os :: raw :: c_char , pub nonincrementalReason : * const :: std :: os :: raw :: c_char , pub collections : [ u64 ; 3usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct GarbageCollectionEvent_Collection { pub startTimestamp : root :: mozilla :: TimeStamp , pub endTimestamp : root :: mozilla :: TimeStamp , } # [ test ] fn bindgen_test_layout_GarbageCollectionEvent_Collection ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GarbageCollectionEvent_Collection > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( GarbageCollectionEvent_Collection ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GarbageCollectionEvent_Collection > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GarbageCollectionEvent_Collection ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GarbageCollectionEvent_Collection ) ) . startTimestamp as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GarbageCollectionEvent_Collection ) , "::" , stringify ! ( startTimestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GarbageCollectionEvent_Collection ) ) . endTimestamp as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( GarbageCollectionEvent_Collection ) , "::" , stringify ! ( endTimestamp ) ) ) ; } impl Clone for GarbageCollectionEvent_Collection { fn clone ( & self ) -> Self { * self } } pub type GarbageCollectionEvent_Ptr = root :: mozilla :: UniquePtr < root :: JS :: dbg :: GarbageCollectionEvent > ; # [ test ] fn bindgen_test_layout_GarbageCollectionEvent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GarbageCollectionEvent > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( GarbageCollectionEvent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GarbageCollectionEvent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GarbageCollectionEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GarbageCollectionEvent ) ) . majorGCNumber_ as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GarbageCollectionEvent ) , "::" , stringify ! ( majorGCNumber_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GarbageCollectionEvent ) ) . reason as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( GarbageCollectionEvent ) , "::" , stringify ! ( reason ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GarbageCollectionEvent ) ) . nonincrementalReason as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( GarbageCollectionEvent ) , "::" , stringify ! ( nonincrementalReason ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GarbageCollectionEvent ) ) . collections as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( GarbageCollectionEvent ) , "::" , stringify ! ( collections ) ) ) ; } } pub type Value_PayloadType = u64 ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct Value_layout { pub asBits : root :: __BindgenUnionField < u64 > , pub debugView : root :: __BindgenUnionField < root :: JS :: Value_layout__bindgen_ty_1 > , pub s : root :: __BindgenUnionField < root :: JS :: Value_layout__bindgen_ty_2 > , pub asDouble : root :: __BindgenUnionField < f64 > , pub asPtr : root :: __BindgenUnionField < * mut :: std :: os :: raw :: c_void > , pub asWord : root :: __BindgenUnionField < usize > , pub asUIntPtr : root :: __BindgenUnionField < usize > , pub bindgen_union_field : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct Value_layout__bindgen_ty_1 { pub _bitfield_1 : u64 , pub __bindgen_align : [ u64 ; 0usize ] , } # [ test ] fn bindgen_test_layout_Value_layout__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Value_layout__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( Value_layout__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Value_layout__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Value_layout__bindgen_ty_1 ) ) ) ; } impl Clone for Value_layout__bindgen_ty_1 { fn clone ( & self ) -> Self { * self } } impl Value_layout__bindgen_ty_1 { # [ inline ] pub fn payload47 ( & self ) -> u64 { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x7fffffffffff as u64 ; let val = ( unit_field_val & mask ) >> 0usize ; unsafe { :: std :: mem :: transmute ( val as u64 ) } } # [ inline ] pub fn set_payload47 ( & mut self , val : u64 ) { let mask = 0x7fffffffffff as u64 ; let val = val as u64 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 0usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn tag ( & self ) -> root :: JSValueTag { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0xffff800000000000 as u64 ; let val = ( unit_field_val & mask ) >> 47usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_tag ( & mut self , val : root :: JSValueTag ) { let mask = 0xffff800000000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 47usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn new_bitfield_1 ( payload47 : u64 , tag : root :: JSValueTag ) -> u64 { ( ( 0 | ( ( payload47 as u64 as u64 ) << 0usize ) & ( 0x7fffffffffff as u64 ) ) | ( ( tag as u32 as u64 ) << 47usize ) & ( 0xffff800000000000 as u64 ) ) } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct Value_layout__bindgen_ty_2 { pub payload : root :: JS :: Value_layout__bindgen_ty_2__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct Value_layout__bindgen_ty_2__bindgen_ty_1 { pub i32 : root :: __BindgenUnionField < i32 > , pub u32 : root :: __BindgenUnionField < u32 > , pub why : root :: __BindgenUnionField < root :: JSWhyMagic > , pub bindgen_union_field : u32 , } # [ test ] fn bindgen_test_layout_Value_layout__bindgen_ty_2__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Value_layout__bindgen_ty_2__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( Value_layout__bindgen_ty_2__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Value_layout__bindgen_ty_2__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( Value_layout__bindgen_ty_2__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Value_layout__bindgen_ty_2__bindgen_ty_1 ) ) . i32 as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( Value_layout__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! ( i32 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Value_layout__bindgen_ty_2__bindgen_ty_1 ) ) . u32 as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( Value_layout__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! ( u32 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Value_layout__bindgen_ty_2__bindgen_ty_1 ) ) . why as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( Value_layout__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! ( why ) ) ) ; } impl Clone for Value_layout__bindgen_ty_2__bindgen_ty_1 { fn clone ( & self ) -> Self { * self } } # [ test ] fn bindgen_test_layout_Value_layout__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Value_layout__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( Value_layout__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Value_layout__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( Value_layout__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Value_layout__bindgen_ty_2 ) ) . payload as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( Value_layout__bindgen_ty_2 ) , "::" , stringify ! ( payload ) ) ) ; } impl Clone for Value_layout__bindgen_ty_2 { fn clone ( & self ) -> Self { * self } } # [ test ] fn bindgen_test_layout_Value_layout ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Value_layout > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( Value_layout ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Value_layout > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Value_layout ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Value_layout ) ) . asBits as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( Value_layout ) , "::" , stringify ! ( asBits ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Value_layout ) ) . debugView as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( Value_layout ) , "::" , stringify ! ( debugView ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Value_layout ) ) . s as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( Value_layout ) , "::" , stringify ! ( s ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Value_layout ) ) . asDouble as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( Value_layout ) , "::" , stringify ! ( asDouble ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Value_layout ) ) . asPtr as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( Value_layout ) , "::" , stringify ! ( asPtr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Value_layout ) ) . asWord as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( Value_layout ) , "::" , stringify ! ( asWord ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const Value_layout ) ) . asUIntPtr as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( Value_layout ) , "::" , stringify ! ( asUIntPtr ) ) ) ; } impl Clone for Value_layout { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct ConstUTF8CharsZ { pub data_ : * const :: std :: os :: raw :: c_char , } pub type ConstUTF8CharsZ_CharT = :: std :: os :: raw :: c_uchar ; # [ test ] fn bindgen_test_layout_ConstUTF8CharsZ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ConstUTF8CharsZ > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( ConstUTF8CharsZ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ConstUTF8CharsZ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ConstUTF8CharsZ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ConstUTF8CharsZ ) ) . data_ as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ConstUTF8CharsZ ) , "::" , stringify ! ( data_ ) ) ) ; } impl Clone for ConstUTF8CharsZ { fn clone ( & self ) -> Self { * self } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct JSObject { _unused : [ u8 ; 0 ] } pub mod js { # [ allow ( unused_imports ) ] use self :: super :: super :: root ; pub mod gc { # [ allow ( unused_imports ) ] use self :: super :: super :: super :: root ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct SystemAllocPolicy { pub _address : u8 , } # [ test ] fn bindgen_test_layout_SystemAllocPolicy ( ) { assert_eq ! ( :: std :: mem :: size_of :: < SystemAllocPolicy > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( SystemAllocPolicy ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < SystemAllocPolicy > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( SystemAllocPolicy ) ) ) ; } impl Clone for SystemAllocPolicy { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] pub struct SourceHook__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; 
 /// A class of objects that return source code on demand.
        ///
        /// When code is compiled with setSourceIsLazy(true), SpiderMonkey doesn't
        /// retain the source code (and doesn't do lazy bytecode generation). If we ever
        /// need the source code, say, in response to a call to Function.prototype.
        /// toSource or Debugger.Source.prototype.text, then we call the 'load' member
        /// function of the instance of this class that has hopefully been registered
        /// with the runtime, passing the code's URL, and hope that it will be able to
        /// find the source. 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SourceHook { pub vtable_ : * const SourceHook__bindgen_vtable , } # [ test ] fn bindgen_test_layout_SourceHook ( ) { assert_eq ! ( :: std :: mem :: size_of :: < SourceHook > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SourceHook ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < SourceHook > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SourceHook ) ) ) ; } } 
 /// Factors implementation for all template versions of nsCOMPtr.
    ///
    /// Here's the way people normally do things like this:
    ///
    /// template<class T> class Foo { ... };
    /// template<> class Foo<void*> { ... };
    /// template<class T> class Foo<T*> : private Foo<void*> { ... }; 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCOMPtr_base { pub mRawPtr : * mut root :: nsISupports , } # [ test ] fn bindgen_test_layout_nsCOMPtr_base ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCOMPtr_base > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsCOMPtr_base ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCOMPtr_base > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCOMPtr_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCOMPtr_base ) ) . mRawPtr as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCOMPtr_base ) , "::" , stringify ! ( mRawPtr ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCOMPtr { pub _base : root :: nsCOMPtr_base , } pub type nsCOMPtr_element_type < T > = T ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsAutoPtr < T > { pub mRawPtr : * mut T , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsAutoPtr_Ptr < T > { pub mPtr : * mut T , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , } pub type nsAutoPtr_element_type < T > = T ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsAutoPtr_Proxy { pub _address : u8 , } pub type nsAutoPtr_Proxy_member_function = u8 ; pub type PLDHashNumber = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct PLDHashEntryHdr { pub mKeyHash : root :: PLDHashNumber , } # [ test ] fn bindgen_test_layout_PLDHashEntryHdr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < PLDHashEntryHdr > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( PLDHashEntryHdr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < PLDHashEntryHdr > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( PLDHashEntryHdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLDHashEntryHdr ) ) . mKeyHash as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( PLDHashEntryHdr ) , "::" , stringify ! ( mKeyHash ) ) ) ; } impl Clone for PLDHashEntryHdr { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct PLDHashTable { pub mOps : * const root :: PLDHashTableOps , pub mEntryStore : root :: PLDHashTable_EntryStore , pub mGeneration : u16 , pub mHashShift : u8 , pub mEntrySize : u8 , pub mEntryCount : u32 , pub mRemovedCount : u32 , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct PLDHashTable_EntryStore { pub mEntryStore : * mut :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_PLDHashTable_EntryStore ( ) { assert_eq ! ( :: std :: mem :: size_of :: < PLDHashTable_EntryStore > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( PLDHashTable_EntryStore ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < PLDHashTable_EntryStore > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( PLDHashTable_EntryStore ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLDHashTable_EntryStore ) ) . mEntryStore as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( PLDHashTable_EntryStore ) , "::" , stringify ! ( mEntryStore ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct PLDHashTable_Iterator { pub mTable : * mut root :: PLDHashTable , pub mStart : * mut :: std :: os :: raw :: c_char , pub mLimit : * mut :: std :: os :: raw :: c_char , pub mCurrent : * mut :: std :: os :: raw :: c_char , pub mNexts : u32 , pub mNextsLimit : u32 , pub mHaveRemoved : bool , } # [ test ] fn bindgen_test_layout_PLDHashTable_Iterator ( ) { assert_eq ! ( :: std :: mem :: size_of :: < PLDHashTable_Iterator > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( PLDHashTable_Iterator ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < PLDHashTable_Iterator > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( PLDHashTable_Iterator ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLDHashTable_Iterator ) ) . mTable as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( PLDHashTable_Iterator ) , "::" , stringify ! ( mTable ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLDHashTable_Iterator ) ) . mStart as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( PLDHashTable_Iterator ) , "::" , stringify ! ( mStart ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLDHashTable_Iterator ) ) . mLimit as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( PLDHashTable_Iterator ) , "::" , stringify ! ( mLimit ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLDHashTable_Iterator ) ) . mCurrent as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( PLDHashTable_Iterator ) , "::" , stringify ! ( mCurrent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLDHashTable_Iterator ) ) . mNexts as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( PLDHashTable_Iterator ) , "::" , stringify ! ( mNexts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLDHashTable_Iterator ) ) . mNextsLimit as * const _ as usize } , 36usize , concat ! ( "Alignment of field: " , stringify ! ( PLDHashTable_Iterator ) , "::" , stringify ! ( mNextsLimit ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLDHashTable_Iterator ) ) . mHaveRemoved as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( PLDHashTable_Iterator ) , "::" , stringify ! ( mHaveRemoved ) ) ) ; } pub const PLDHashTable_SearchReason_ForSearchOrRemove : root :: PLDHashTable_SearchReason = 0 ; pub const PLDHashTable_SearchReason_ForAdd : root :: PLDHashTable_SearchReason = 1 ; pub type PLDHashTable_SearchReason = :: std :: os :: raw :: c_uint ; pub const PLDHashTable_kMaxCapacity : u32 = 67108864 ; pub const PLDHashTable_kMinCapacity : u32 = 8 ; pub const PLDHashTable_kMaxInitialLength : u32 = 33554432 ; pub const PLDHashTable_kDefaultInitialLength : u32 = 4 ; pub const PLDHashTable_kHashBits : u32 = 32 ; pub const PLDHashTable_kGoldenRatio : u32 = 2654435769 ; pub const PLDHashTable_kCollisionFlag : root :: PLDHashNumber = 1 ; # [ test ] fn bindgen_test_layout_PLDHashTable ( ) { assert_eq ! ( :: std :: mem :: size_of :: < PLDHashTable > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( PLDHashTable ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < PLDHashTable > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( PLDHashTable ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLDHashTable ) ) . mOps as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( PLDHashTable ) , "::" , stringify ! ( mOps ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLDHashTable ) ) . mEntryStore as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( PLDHashTable ) , "::" , stringify ! ( mEntryStore ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLDHashTable ) ) . mGeneration as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( PLDHashTable ) , "::" , stringify ! ( mGeneration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLDHashTable ) ) . mHashShift as * const _ as usize } , 18usize , concat ! ( "Alignment of field: " , stringify ! ( PLDHashTable ) , "::" , stringify ! ( mHashShift ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLDHashTable ) ) . mEntrySize as * const _ as usize } , 19usize , concat ! ( "Alignment of field: " , stringify ! ( PLDHashTable ) , "::" , stringify ! ( mEntrySize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLDHashTable ) ) . mEntryCount as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( PLDHashTable ) , "::" , stringify ! ( mEntryCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLDHashTable ) ) . mRemovedCount as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( PLDHashTable ) , "::" , stringify ! ( mRemovedCount ) ) ) ; } pub type PLDHashHashKey = :: std :: option :: Option < unsafe extern "C" fn ( aKey : * const :: std :: os :: raw :: c_void ) -> root :: PLDHashNumber > ; pub type PLDHashMatchEntry = :: std :: option :: Option < unsafe extern "C" fn ( aEntry : * const root :: PLDHashEntryHdr , aKey : * const :: std :: os :: raw :: c_void ) -> bool > ; pub type PLDHashMoveEntry = :: std :: option :: Option < unsafe extern "C" fn ( aTable : * mut root :: PLDHashTable , aFrom : * const root :: PLDHashEntryHdr , aTo : * mut root :: PLDHashEntryHdr ) > ; pub type PLDHashClearEntry = :: std :: option :: Option < unsafe extern "C" fn ( aTable : * mut root :: PLDHashTable , aEntry : * mut root :: PLDHashEntryHdr ) > ; pub type PLDHashInitEntry = :: std :: option :: Option < unsafe extern "C" fn ( aEntry : * mut root :: PLDHashEntryHdr , aKey : * const :: std :: os :: raw :: c_void ) > ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct PLDHashTableOps { pub hashKey : root :: PLDHashHashKey , pub matchEntry : root :: PLDHashMatchEntry , pub moveEntry : root :: PLDHashMoveEntry , pub clearEntry : root :: PLDHashClearEntry , pub initEntry : root :: PLDHashInitEntry , } # [ test ] fn bindgen_test_layout_PLDHashTableOps ( ) { assert_eq ! ( :: std :: mem :: size_of :: < PLDHashTableOps > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( PLDHashTableOps ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < PLDHashTableOps > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( PLDHashTableOps ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLDHashTableOps ) ) . hashKey as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( PLDHashTableOps ) , "::" , stringify ! ( hashKey ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLDHashTableOps ) ) . matchEntry as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( PLDHashTableOps ) , "::" , stringify ! ( matchEntry ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLDHashTableOps ) ) . moveEntry as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( PLDHashTableOps ) , "::" , stringify ! ( moveEntry ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLDHashTableOps ) ) . clearEntry as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( PLDHashTableOps ) , "::" , stringify ! ( clearEntry ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLDHashTableOps ) ) . initEntry as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( PLDHashTableOps ) , "::" , stringify ! ( initEntry ) ) ) ; } impl Clone for PLDHashTableOps { fn clone ( & self ) -> Self { * self } } 
 /// hashkey wrapper using T* KeyType
    ///
    /// @see nsTHashtable::EntryType for specification 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsPtrHashKey < T > { pub _base : root :: PLDHashEntryHdr , pub mKey : * mut T , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , } pub type nsPtrHashKey_KeyType < T > = * mut T ; pub type nsPtrHashKey_KeyTypePointer < T > = * mut T ; pub const nsPtrHashKey_ALLOW_MEMMOVE : root :: nsPtrHashKey__bindgen_ty_1 = 0 ; pub type nsPtrHashKey__bindgen_ty_1 = i32 ; 
 /// hashkey wrapper using nsAString KeyType
    ///
    /// @see nsTHashtable::EntryType for specification 
 # [ repr ( C ) ] pub struct nsStringHashKey { pub _base : root :: PLDHashEntryHdr , pub mStr : ::nsstring::nsStringRepr , } pub type nsStringHashKey_KeyType = * const root :: nsAString ; pub type nsStringHashKey_KeyTypePointer = * const root :: nsAString ; pub const nsStringHashKey_ALLOW_MEMMOVE : root :: nsStringHashKey__bindgen_ty_1 = 1 ; pub type nsStringHashKey__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_nsStringHashKey ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStringHashKey > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsStringHashKey ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStringHashKey > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStringHashKey ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStringHashKey ) ) . mStr as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStringHashKey ) , "::" , stringify ! ( mStr ) ) ) ; } 
 /// hashkey wrapper using nsACString KeyType
    ///
    /// @see nsTHashtable::EntryType for specification 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCStringHashKey { pub _base : root :: PLDHashEntryHdr , pub mStr : root :: nsCString , } pub type nsCStringHashKey_KeyType = * const root :: nsACString ; pub type nsCStringHashKey_KeyTypePointer = * const root :: nsACString ; pub const nsCStringHashKey_ALLOW_MEMMOVE : root :: nsCStringHashKey__bindgen_ty_1 = 1 ; pub type nsCStringHashKey__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_nsCStringHashKey ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCStringHashKey > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsCStringHashKey ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCStringHashKey > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCStringHashKey ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCStringHashKey ) ) . mStr as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsCStringHashKey ) , "::" , stringify ! ( mStr ) ) ) ; } 
 /// hashkey wrapper using nsISupports* KeyType
    ///
    /// @see nsTHashtable::EntryType for specification 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsISupportsHashKey { pub _base : root :: PLDHashEntryHdr , pub mSupports : root :: nsCOMPtr , } pub type nsISupportsHashKey_KeyType = * mut root :: nsISupports ; pub type nsISupportsHashKey_KeyTypePointer = * const root :: nsISupports ; pub const nsISupportsHashKey_ALLOW_MEMMOVE : root :: nsISupportsHashKey__bindgen_ty_1 = 1 ; pub type nsISupportsHashKey__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_nsISupportsHashKey ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsISupportsHashKey > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsISupportsHashKey ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsISupportsHashKey > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsISupportsHashKey ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsISupportsHashKey ) ) . mSupports as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsISupportsHashKey ) , "::" , stringify ! ( mSupports ) ) ) ; } 
 /// hashkey wrapper using refcounted * KeyType
    ///
    /// @see nsTHashtable::EntryType for specification 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsRefPtrHashKey < T > { pub _base : root :: PLDHashEntryHdr , pub mKey : root :: RefPtr < T > , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , } pub type nsRefPtrHashKey_KeyType < T > = * mut T ; pub type nsRefPtrHashKey_KeyTypePointer < T > = * mut T ; pub const nsRefPtrHashKey_ALLOW_MEMMOVE : root :: nsRefPtrHashKey__bindgen_ty_1 = 0 ; pub type nsRefPtrHashKey__bindgen_ty_1 = i32 ; 
 /// a base class for templated hashtables.
    ///
    /// Clients will rarely need to use this class directly. Check the derived
    /// classes first, to see if they will meet your needs.
    ///
    /// @param EntryType  the templated entry-type class that is managed by the
    /// hashtable. <code>EntryType</code> must extend the following declaration,
    /// and <strong>must not declare any virtual functions or derive from classes
    /// with virtual functions.</strong>  Any vtable pointer would break the
    /// PLDHashTable code.
    /// <pre>   class EntryType : public PLDHashEntryHdr
    /// {
    /// public: or friend nsTHashtable<EntryType>;
    /// // KeyType is what we use when Get()ing or Put()ing this entry
    /// // this should either be a simple datatype (uint32_t, nsISupports*) or
    /// // a const reference (const nsAString&)
    /// typedef something KeyType;
    /// // KeyTypePointer is the pointer-version of KeyType, because
    /// // PLDHashTable.h requires keys to cast to <code>const void*</code>
    /// typedef const something* KeyTypePointer;
    ///
    /// EntryType(KeyTypePointer aKey);
    ///
    /// // A copy or C++11 Move constructor must be defined, even if
    /// // AllowMemMove() == true, otherwise you will cause link errors.
    /// EntryType(const EntryType& aEnt);  // Either this...
    /// EntryType(EntryType&& aEnt);       // ...or this
    ///
    /// // the destructor must be defined... or you will cause link errors!
    /// ~EntryType();
    ///
    /// // KeyEquals(): does this entry match this key?
    /// bool KeyEquals(KeyTypePointer aKey) const;
    ///
    /// // KeyToPointer(): Convert KeyType to KeyTypePointer
    /// static KeyTypePointer KeyToPointer(KeyType aKey);
    ///
    /// // HashKey(): calculate the hash number
    /// static PLDHashNumber HashKey(KeyTypePointer aKey);
    ///
    /// // ALLOW_MEMMOVE can we move this class with memmove(), or do we have
    /// // to use the copy constructor?
    /// enum { ALLOW_MEMMOVE = true/false };
    /// }</pre>
    ///
    /// @see nsInterfaceHashtable
    /// @see nsDataHashtable
    /// @see nsClassHashtable
    /// @author "Benjamin Smedberg <bsmedberg@covad.net>" 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsTHashtable { pub _address : u8 , } pub type nsTHashtable_fallible_t = root :: mozilla :: fallible_t ; 
 /// KeyType is typedef'ed for ease of use. 
 pub type nsTHashtable_KeyType = [ u8 ; 0usize ] ; 
 /// KeyTypePointer is typedef'ed for ease of use. 
 pub type nsTHashtable_KeyTypePointer = [ u8 ; 0usize ] ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsTHashtable_Iterator { pub _base : root :: PLDHashTable_Iterator , } pub type nsTHashtable_Iterator_Base = root :: PLDHashTable_Iterator ; 
 /// the private nsTHashtable::EntryType class used by nsBaseHashtable
    /// @see nsTHashtable for the specification of this class
    /// @see nsBaseHashtable for template parameters 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsBaseHashtableET < KeyClass , DataType > { pub _base : KeyClass , pub mData : DataType , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < KeyClass > > , pub _phantom_1 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < DataType > > , } pub type nsBaseHashtableET_KeyType = [ u8 ; 0usize ] ; pub type nsBaseHashtableET_KeyTypePointer = [ u8 ; 0usize ] ; 
 /// templated hashtable for simple data types
    /// This class manages simple data types that do not need construction or
    /// destruction.
    ///
    /// @param KeyClass a wrapper-class for the hashtable key, see nsHashKeys.h
    /// for a complete specification.
    /// @param DataType the datatype stored in the hashtable,
    /// for example, uint32_t or nsCOMPtr.  If UserDataType is not the same,
    /// DataType must implicitly cast to UserDataType
    /// @param UserDataType the user sees, for example uint32_t or nsISupports* 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsBaseHashtable { pub _address : u8 , } pub type nsBaseHashtable_fallible_t = root :: mozilla :: fallible_t ; pub type nsBaseHashtable_KeyType = [ u8 ; 0usize ] ; pub type nsBaseHashtable_EntryType < KeyClass , DataType > = root :: nsBaseHashtableET < KeyClass , DataType > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsBaseHashtable_LookupResult < KeyClass , DataType > { pub mEntry : * mut root :: nsBaseHashtable_EntryType < KeyClass , DataType > , pub mTable : * mut u8 , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < KeyClass > > , pub _phantom_1 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < DataType > > , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsBaseHashtable_EntryPtr < KeyClass , DataType > { pub mEntry : * mut root :: nsBaseHashtable_EntryType < KeyClass , DataType > , pub mExistingEntry : bool , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < KeyClass > > , pub _phantom_1 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < DataType > > , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsBaseHashtable_Iterator { pub _base : root :: PLDHashTable_Iterator , } pub type nsBaseHashtable_Iterator_Base = root :: PLDHashTable_Iterator ; 
 /// templated hashtable class maps keys to simple datatypes.
    /// See nsBaseHashtable for complete declaration
    /// @param KeyClass a wrapper-class for the hashtable key, see nsHashKeys.h
    /// for a complete specification.
    /// @param DataType the simple datatype being wrapped
    /// @see nsInterfaceHashtable, nsClassHashtable 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsDataHashtable { pub _address : u8 , } pub type nsDataHashtable_BaseClass = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsTArrayHeader { pub mLength : u32 , pub _bitfield_1 : u32 , } extern "C" {
 # [ link_name = "\u{1}_ZN14nsTArrayHeader9sEmptyHdrE" ] 
 pub static mut  nsTArrayHeader_sEmptyHdr  :  root :: nsTArrayHeader ;
} # [ test ] fn bindgen_test_layout_nsTArrayHeader ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsTArrayHeader > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsTArrayHeader ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsTArrayHeader > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( nsTArrayHeader ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsTArrayHeader ) ) . mLength as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsTArrayHeader ) , "::" , stringify ! ( mLength ) ) ) ; } impl Clone for nsTArrayHeader { fn clone ( & self ) -> Self { * self } } impl nsTArrayHeader { # [ inline ] pub fn mCapacity ( & self ) -> u32 { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x7fffffff as u32 ; let val = ( unit_field_val & mask ) >> 0usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mCapacity ( & mut self , val : u32 ) { let mask = 0x7fffffff as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 0usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn mIsAutoArray ( & self ) -> u32 { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x80000000 as u32 ; let val = ( unit_field_val & mask ) >> 31usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mIsAutoArray ( & mut self , val : u32 ) { let mask = 0x80000000 as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 31usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn new_bitfield_1 ( mCapacity : u32 , mIsAutoArray : u32 ) -> u32 { ( ( 0 | ( ( mCapacity as u32 as u32 ) << 0usize ) & ( 0x7fffffff as u32 ) ) | ( ( mIsAutoArray as u32 as u32 ) << 31usize ) & ( 0x80000000 as u32 ) ) } } pub type AutoTArray_self_type = u8 ; pub type AutoTArray_base_type < E > = root :: nsTArray < E > ; pub type AutoTArray_Header < E > = root :: AutoTArray_base_type < E > ; pub type AutoTArray_elem_type < E > = root :: AutoTArray_base_type < E > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct AutoTArray__bindgen_ty_1 { pub mAutoBuf : root :: __BindgenUnionField < * mut :: std :: os :: raw :: c_char > , pub mAlign : root :: __BindgenUnionField < u8 > , pub bindgen_union_field : u64 , } pub type nscoord = i32 ; pub type nscolor = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct gfxFontFeature { pub mTag : u32 , pub mValue : u32 , } # [ test ] fn bindgen_test_layout_gfxFontFeature ( ) { assert_eq ! ( :: std :: mem :: size_of :: < gfxFontFeature > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( gfxFontFeature ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < gfxFontFeature > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( gfxFontFeature ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const gfxFontFeature ) ) . mTag as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( gfxFontFeature ) , "::" , stringify ! ( mTag ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const gfxFontFeature ) ) . mValue as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( gfxFontFeature ) , "::" , stringify ! ( mValue ) ) ) ; } impl Clone for gfxFontFeature { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] pub struct gfxAlternateValue { pub alternate : u32 , pub value : ::nsstring::nsStringRepr , } # [ test ] fn bindgen_test_layout_gfxAlternateValue ( ) { assert_eq ! ( :: std :: mem :: size_of :: < gfxAlternateValue > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( gfxAlternateValue ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < gfxAlternateValue > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( gfxAlternateValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const gfxAlternateValue ) ) . alternate as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( gfxAlternateValue ) , "::" , stringify ! ( alternate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const gfxAlternateValue ) ) . value as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( gfxAlternateValue ) , "::" , stringify ! ( value ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct gfxFontFeatureValueSet { pub mRefCnt : root :: mozilla :: ThreadSafeAutoRefCnt , pub mFontFeatureValues : [ u64 ; 4usize ] , } pub type gfxFontFeatureValueSet_HasThreadSafeRefCnt = root :: mozilla :: TrueType ; # [ repr ( C ) ] pub struct gfxFontFeatureValueSet_ValueList { pub name : ::nsstring::nsStringRepr , pub featureSelectors : root :: nsTArray < u32 > , } # [ test ] fn bindgen_test_layout_gfxFontFeatureValueSet_ValueList ( ) { assert_eq ! ( :: std :: mem :: size_of :: < gfxFontFeatureValueSet_ValueList > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( gfxFontFeatureValueSet_ValueList ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < gfxFontFeatureValueSet_ValueList > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( gfxFontFeatureValueSet_ValueList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const gfxFontFeatureValueSet_ValueList ) ) . name as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( gfxFontFeatureValueSet_ValueList ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const gfxFontFeatureValueSet_ValueList ) ) . featureSelectors as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( gfxFontFeatureValueSet_ValueList ) , "::" , stringify ! ( featureSelectors ) ) ) ; } # [ repr ( C ) ] pub struct gfxFontFeatureValueSet_FeatureValues { pub alternate : u32 , pub valuelist : root :: nsTArray < root :: gfxFontFeatureValueSet_ValueList > , } # [ test ] fn bindgen_test_layout_gfxFontFeatureValueSet_FeatureValues ( ) { assert_eq ! ( :: std :: mem :: size_of :: < gfxFontFeatureValueSet_FeatureValues > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( gfxFontFeatureValueSet_FeatureValues ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < gfxFontFeatureValueSet_FeatureValues > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( gfxFontFeatureValueSet_FeatureValues ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const gfxFontFeatureValueSet_FeatureValues ) ) . alternate as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( gfxFontFeatureValueSet_FeatureValues ) , "::" , stringify ! ( alternate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const gfxFontFeatureValueSet_FeatureValues ) ) . valuelist as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( gfxFontFeatureValueSet_FeatureValues ) , "::" , stringify ! ( valuelist ) ) ) ; } # [ repr ( C ) ] pub struct gfxFontFeatureValueSet_FeatureValueHashKey { pub mFamily : ::nsstring::nsStringRepr , pub mPropVal : u32 , pub mName : ::nsstring::nsStringRepr , } # [ test ] fn bindgen_test_layout_gfxFontFeatureValueSet_FeatureValueHashKey ( ) { assert_eq ! ( :: std :: mem :: size_of :: < gfxFontFeatureValueSet_FeatureValueHashKey > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( gfxFontFeatureValueSet_FeatureValueHashKey ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < gfxFontFeatureValueSet_FeatureValueHashKey > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( gfxFontFeatureValueSet_FeatureValueHashKey ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const gfxFontFeatureValueSet_FeatureValueHashKey ) ) . mFamily as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( gfxFontFeatureValueSet_FeatureValueHashKey ) , "::" , stringify ! ( mFamily ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const gfxFontFeatureValueSet_FeatureValueHashKey ) ) . mPropVal as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( gfxFontFeatureValueSet_FeatureValueHashKey ) , "::" , stringify ! ( mPropVal ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const gfxFontFeatureValueSet_FeatureValueHashKey ) ) . mName as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( gfxFontFeatureValueSet_FeatureValueHashKey ) , "::" , stringify ! ( mName ) ) ) ; } # [ repr ( C ) ] pub struct gfxFontFeatureValueSet_FeatureValueHashEntry { pub _base : root :: PLDHashEntryHdr , pub mKey : root :: gfxFontFeatureValueSet_FeatureValueHashKey , pub mValues : root :: nsTArray < u32 > , } pub type gfxFontFeatureValueSet_FeatureValueHashEntry_KeyType = * const root :: gfxFontFeatureValueSet_FeatureValueHashKey ; pub type gfxFontFeatureValueSet_FeatureValueHashEntry_KeyTypePointer = * const root :: gfxFontFeatureValueSet_FeatureValueHashKey ; pub const gfxFontFeatureValueSet_FeatureValueHashEntry_ALLOW_MEMMOVE : root :: gfxFontFeatureValueSet_FeatureValueHashEntry__bindgen_ty_1 = 1 ; pub type gfxFontFeatureValueSet_FeatureValueHashEntry__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_gfxFontFeatureValueSet_FeatureValueHashEntry ( ) { assert_eq ! ( :: std :: mem :: size_of :: < gfxFontFeatureValueSet_FeatureValueHashEntry > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( gfxFontFeatureValueSet_FeatureValueHashEntry ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < gfxFontFeatureValueSet_FeatureValueHashEntry > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( gfxFontFeatureValueSet_FeatureValueHashEntry ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const gfxFontFeatureValueSet_FeatureValueHashEntry ) ) . mKey as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( gfxFontFeatureValueSet_FeatureValueHashEntry ) , "::" , stringify ! ( mKey ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const gfxFontFeatureValueSet_FeatureValueHashEntry ) ) . mValues as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( gfxFontFeatureValueSet_FeatureValueHashEntry ) , "::" , stringify ! ( mValues ) ) ) ; } # [ test ] fn bindgen_test_layout_gfxFontFeatureValueSet ( ) { assert_eq ! ( :: std :: mem :: size_of :: < gfxFontFeatureValueSet > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( gfxFontFeatureValueSet ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < gfxFontFeatureValueSet > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( gfxFontFeatureValueSet ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const gfxFontFeatureValueSet ) ) . mRefCnt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( gfxFontFeatureValueSet ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const gfxFontFeatureValueSet ) ) . mFontFeatureValues as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( gfxFontFeatureValueSet ) , "::" , stringify ! ( mFontFeatureValues ) ) ) ; } pub type gfxFontVariation = root :: mozilla :: gfx :: FontVariation ; pub const kGenericFont_NONE : u8 = 0 ; pub const kGenericFont_moz_variable : u8 = 0 ; pub const kGenericFont_moz_fixed : u8 = 1 ; pub const kGenericFont_serif : u8 = 2 ; pub const kGenericFont_sans_serif : u8 = 4 ; pub const kGenericFont_monospace : u8 = 8 ; pub const kGenericFont_cursive : u8 = 16 ; pub const kGenericFont_fantasy : u8 = 32 ; # [ repr ( C ) ] pub struct nsFont { pub fontlist : root :: mozilla :: FontFamilyList , pub style : u8 , pub systemFont : bool , pub variantCaps : u8 , pub variantNumeric : u8 , pub variantPosition : u8 , pub variantWidth : u8 , pub variantLigatures : u16 , pub variantEastAsian : u16 , pub variantAlternates : u16 , pub smoothing : u8 , pub fontSmoothingBackgroundColor : root :: nscolor , pub weight : u16 , pub stretch : i16 , pub kerning : u8 , pub synthesis : u8 , pub size : root :: nscoord , pub sizeAdjust : f32 , pub alternateValues : root :: nsTArray < root :: gfxAlternateValue > , pub featureValueLookup : root :: RefPtr < root :: gfxFontFeatureValueSet > , pub fontFeatureSettings : root :: nsTArray < root :: gfxFontFeature > , pub fontVariationSettings : root :: nsTArray < root :: gfxFontVariation > , pub languageOverride : u32 , } pub const nsFont_MaxDifference_eNone : root :: nsFont_MaxDifference = 0 ; pub const nsFont_MaxDifference_eVisual : root :: nsFont_MaxDifference = 1 ; pub const nsFont_MaxDifference_eLayoutAffecting : root :: nsFont_MaxDifference = 2 ; pub type nsFont_MaxDifference = u8 ; # [ test ] fn bindgen_test_layout_nsFont ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsFont > ( ) , 96usize , concat ! ( "Size of: " , stringify ! ( nsFont ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsFont > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsFont ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . fontlist as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( fontlist ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . style as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( style ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . systemFont as * const _ as usize } , 17usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( systemFont ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . variantCaps as * const _ as usize } , 18usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( variantCaps ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . variantNumeric as * const _ as usize } , 19usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( variantNumeric ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . variantPosition as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( variantPosition ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . variantWidth as * const _ as usize } , 21usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( variantWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . variantLigatures as * const _ as usize } , 22usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( variantLigatures ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . variantEastAsian as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( variantEastAsian ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . variantAlternates as * const _ as usize } , 26usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( variantAlternates ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . smoothing as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( smoothing ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . fontSmoothingBackgroundColor as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( fontSmoothingBackgroundColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . weight as * const _ as usize } , 36usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( weight ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . stretch as * const _ as usize } , 38usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( stretch ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . kerning as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( kerning ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . synthesis as * const _ as usize } , 41usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( synthesis ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . size as * const _ as usize } , 44usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . sizeAdjust as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( sizeAdjust ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . alternateValues as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( alternateValues ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . featureValueLookup as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( featureValueLookup ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . fontFeatureSettings as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( fontFeatureSettings ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . fontVariationSettings as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( fontVariationSettings ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFont ) ) . languageOverride as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( nsFont ) , "::" , stringify ! ( languageOverride ) ) ) ; } 
 /// An array of objects, similar to AutoTArray<T,1> but which is memmovable. It
    /// always has length >= 1. 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleAutoArray < T > { pub mFirstElement : T , pub mOtherElements : root :: nsTArray < T > , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , } pub const nsStyleAutoArray_WithSingleInitialElement_WITH_SINGLE_INITIAL_ELEMENT : root :: nsStyleAutoArray_WithSingleInitialElement = 0 ; pub type nsStyleAutoArray_WithSingleInitialElement = i32 ; pub const nsStyleUnit_eStyleUnit_MAX : root :: nsStyleUnit = nsStyleUnit :: eStyleUnit_Calc ; # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsStyleUnit { eStyleUnit_Null = 0 , eStyleUnit_Normal = 1 , eStyleUnit_Auto = 2 , eStyleUnit_None = 3 , eStyleUnit_Percent = 10 , eStyleUnit_Factor = 11 , eStyleUnit_Degree = 12 , eStyleUnit_Grad = 13 , eStyleUnit_Radian = 14 , eStyleUnit_Turn = 15 , eStyleUnit_FlexFraction = 16 , eStyleUnit_Coord = 20 , eStyleUnit_Integer = 30 , eStyleUnit_Enumerated = 32 , eStyleUnit_Calc = 40 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsStyleUnion { pub mInt : root :: __BindgenUnionField < i32 > , pub mFloat : root :: __BindgenUnionField < f32 > , pub mPointer : root :: __BindgenUnionField < * mut :: std :: os :: raw :: c_void > , pub bindgen_union_field : u64 , } # [ test ] fn bindgen_test_layout_nsStyleUnion ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleUnion > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsStyleUnion ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleUnion > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleUnion ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleUnion ) ) . mInt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleUnion ) , "::" , stringify ! ( mInt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleUnion ) ) . mFloat as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleUnion ) , "::" , stringify ! ( mFloat ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleUnion ) ) . mPointer as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleUnion ) , "::" , stringify ! ( mPointer ) ) ) ; } impl Clone for nsStyleUnion { fn clone ( & self ) -> Self { * self } } 
 /// Class that hold a single size specification used by the style
    /// system.  The size specification consists of two parts -- a number
    /// and a unit.  The number is an integer, a floating point value, an
    /// nscoord, or undefined, and the unit is an nsStyleUnit.  Checking
    /// the unit is a must before asking for the value in any particular
    /// form.
    /// /
    /// /** <div rustbindgen private accessor="unsafe"></div> 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleCoord { mUnit : root :: nsStyleUnit , mValue : root :: nsStyleUnion , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsStyleCoord_CalcValue { pub mLength : root :: nscoord , pub mPercent : f32 , pub mHasPercent : bool , } # [ test ] fn bindgen_test_layout_nsStyleCoord_CalcValue ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleCoord_CalcValue > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( nsStyleCoord_CalcValue ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleCoord_CalcValue > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( nsStyleCoord_CalcValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleCoord_CalcValue ) ) . mLength as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleCoord_CalcValue ) , "::" , stringify ! ( mLength ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleCoord_CalcValue ) ) . mPercent as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleCoord_CalcValue ) , "::" , stringify ! ( mPercent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleCoord_CalcValue ) ) . mHasPercent as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleCoord_CalcValue ) , "::" , stringify ! ( mHasPercent ) ) ) ; } impl Clone for nsStyleCoord_CalcValue { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleCoord_Calc { pub _base : root :: nsStyleCoord_CalcValue , pub mRefCnt : root :: mozilla :: ThreadSafeAutoRefCnt , } pub type nsStyleCoord_Calc_HasThreadSafeRefCnt = root :: mozilla :: TrueType ; # [ test ] fn bindgen_test_layout_nsStyleCoord_Calc ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleCoord_Calc > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsStyleCoord_Calc ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleCoord_Calc > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleCoord_Calc ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleCoord_Calc ) ) . mRefCnt as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleCoord_Calc ) , "::" , stringify ! ( mRefCnt ) ) ) ; } pub const nsStyleCoord_CoordConstructorType_CoordConstructor : root :: nsStyleCoord_CoordConstructorType = 0 ; pub type nsStyleCoord_CoordConstructorType = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_nsStyleCoord ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleCoord > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsStyleCoord ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleCoord > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleCoord ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleCoord ) ) . mUnit as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleCoord ) , "::" , stringify ! ( mUnit ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleCoord ) ) . mValue as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleCoord ) , "::" , stringify ! ( mValue ) ) ) ; } impl nsStyleCoord { # [ inline ] pub unsafe fn get_mUnit ( & self ) -> & root :: nsStyleUnit { & self . mUnit } # [ inline ] pub unsafe fn get_mUnit_mut ( & mut self ) -> & mut root :: nsStyleUnit { & mut self . mUnit } # [ inline ] pub unsafe fn get_mValue ( & self ) -> & root :: nsStyleUnion { & self . mValue } # [ inline ] pub unsafe fn get_mValue_mut ( & mut self ) -> & mut root :: nsStyleUnion { & mut self . mValue } } 
 /// Class that represents a set of top/right/bottom/left nsStyleCoords.
    /// This is commonly used to hold the widths of the borders, margins,
    /// or paddings of a box.
    /// /
    /// /** <div rustbindgen private accessor="unsafe"></div> 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleSides { mUnits : [ root :: nsStyleUnit ; 4usize ] , mValues : [ root :: nsStyleUnion ; 4usize ] , } # [ test ] fn bindgen_test_layout_nsStyleSides ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleSides > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( nsStyleSides ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleSides > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleSides ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSides ) ) . mUnits as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSides ) , "::" , stringify ! ( mUnits ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSides ) ) . mValues as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSides ) , "::" , stringify ! ( mValues ) ) ) ; } impl nsStyleSides { # [ inline ] pub unsafe fn get_mUnits ( & self ) -> & [ root :: nsStyleUnit ; 4usize ] { & self . mUnits } # [ inline ] pub unsafe fn get_mUnits_mut ( & mut self ) -> & mut [ root :: nsStyleUnit ; 4usize ] { & mut self . mUnits } # [ inline ] pub unsafe fn get_mValues ( & self ) -> & [ root :: nsStyleUnion ; 4usize ] { & self . mValues } # [ inline ] pub unsafe fn get_mValues_mut ( & mut self ) -> & mut [ root :: nsStyleUnion ; 4usize ] { & mut self . mValues } } 
 /// Class that represents a set of top-left/top-right/bottom-right/bottom-left
    /// nsStyleCoord pairs.  This is used to hold the dimensions of the
    /// corners of a box (for, e.g., border-radius and outline-radius).
    /// /
    /// /** <div rustbindgen private accessor="unsafe"></div> 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleCorners { mUnits : [ root :: nsStyleUnit ; 8usize ] , mValues : [ root :: nsStyleUnion ; 8usize ] , } # [ test ] fn bindgen_test_layout_nsStyleCorners ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleCorners > ( ) , 72usize , concat ! ( "Size of: " , stringify ! ( nsStyleCorners ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleCorners > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleCorners ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleCorners ) ) . mUnits as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleCorners ) , "::" , stringify ! ( mUnits ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleCorners ) ) . mValues as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleCorners ) , "::" , stringify ! ( mValues ) ) ) ; } impl nsStyleCorners { # [ inline ] pub unsafe fn get_mUnits ( & self ) -> & [ root :: nsStyleUnit ; 8usize ] { & self . mUnits } # [ inline ] pub unsafe fn get_mUnits_mut ( & mut self ) -> & mut [ root :: nsStyleUnit ; 8usize ] { & mut self . mUnits } # [ inline ] pub unsafe fn get_mValues ( & self ) -> & [ root :: nsStyleUnion ; 8usize ] { & self . mValues } # [ inline ] pub unsafe fn get_mValues_mut ( & mut self ) -> & mut [ root :: nsStyleUnion ; 8usize ] { & mut self . mValues } } pub const nsChangeHint_nsChangeHint_Empty : root :: nsChangeHint = root :: nsChangeHint ( 0 ) ; pub const nsChangeHint_nsChangeHint_RepaintFrame : root :: nsChangeHint = root :: nsChangeHint ( 1 ) ; pub const nsChangeHint_nsChangeHint_NeedReflow : root :: nsChangeHint = root :: nsChangeHint ( 2 ) ; pub const nsChangeHint_nsChangeHint_ClearAncestorIntrinsics : root :: nsChangeHint = root :: nsChangeHint ( 4 ) ; pub const nsChangeHint_nsChangeHint_ClearDescendantIntrinsics : root :: nsChangeHint = root :: nsChangeHint ( 8 ) ; pub const nsChangeHint_nsChangeHint_NeedDirtyReflow : root :: nsChangeHint = root :: nsChangeHint ( 16 ) ; pub const nsChangeHint_nsChangeHint_SyncFrameView : root :: nsChangeHint = root :: nsChangeHint ( 32 ) ; pub const nsChangeHint_nsChangeHint_UpdateCursor : root :: nsChangeHint = root :: nsChangeHint ( 64 ) ; pub const nsChangeHint_nsChangeHint_UpdateEffects : root :: nsChangeHint = root :: nsChangeHint ( 128 ) ; pub const nsChangeHint_nsChangeHint_UpdateOpacityLayer : root :: nsChangeHint = root :: nsChangeHint ( 256 ) ; pub const nsChangeHint_nsChangeHint_UpdateTransformLayer : root :: nsChangeHint = root :: nsChangeHint ( 512 ) ; pub const nsChangeHint_nsChangeHint_ReconstructFrame : root :: nsChangeHint = root :: nsChangeHint ( 1024 ) ; pub const nsChangeHint_nsChangeHint_UpdateOverflow : root :: nsChangeHint = root :: nsChangeHint ( 2048 ) ; pub const nsChangeHint_nsChangeHint_UpdateSubtreeOverflow : root :: nsChangeHint = root :: nsChangeHint ( 4096 ) ; pub const nsChangeHint_nsChangeHint_UpdatePostTransformOverflow : root :: nsChangeHint = root :: nsChangeHint ( 8192 ) ; pub const nsChangeHint_nsChangeHint_UpdateParentOverflow : root :: nsChangeHint = root :: nsChangeHint ( 16384 ) ; pub const nsChangeHint_nsChangeHint_ChildrenOnlyTransform : root :: nsChangeHint = root :: nsChangeHint ( 32768 ) ; pub const nsChangeHint_nsChangeHint_RecomputePosition : root :: nsChangeHint = root :: nsChangeHint ( 65536 ) ; pub const nsChangeHint_nsChangeHint_UpdateContainingBlock : root :: nsChangeHint = root :: nsChangeHint ( 131072 ) ; pub const nsChangeHint_nsChangeHint_BorderStyleNoneChange : root :: nsChangeHint = root :: nsChangeHint ( 262144 ) ; pub const nsChangeHint_nsChangeHint_UpdateTextPath : root :: nsChangeHint = root :: nsChangeHint ( 524288 ) ; pub const nsChangeHint_nsChangeHint_SchedulePaint : root :: nsChangeHint = root :: nsChangeHint ( 1048576 ) ; pub const nsChangeHint_nsChangeHint_NeutralChange : root :: nsChangeHint = root :: nsChangeHint ( 2097152 ) ; pub const nsChangeHint_nsChangeHint_InvalidateRenderingObservers : root :: nsChangeHint = root :: nsChangeHint ( 4194304 ) ; pub const nsChangeHint_nsChangeHint_ReflowChangesSizeOrPosition : root :: nsChangeHint = root :: nsChangeHint ( 8388608 ) ; pub const nsChangeHint_nsChangeHint_UpdateComputedBSize : root :: nsChangeHint = root :: nsChangeHint ( 16777216 ) ; pub const nsChangeHint_nsChangeHint_UpdateUsesOpacity : root :: nsChangeHint = root :: nsChangeHint ( 33554432 ) ; pub const nsChangeHint_nsChangeHint_UpdateBackgroundPosition : root :: nsChangeHint = root :: nsChangeHint ( 67108864 ) ; pub const nsChangeHint_nsChangeHint_AddOrRemoveTransform : root :: nsChangeHint = root :: nsChangeHint ( 134217728 ) ; pub const nsChangeHint_nsChangeHint_CSSOverflowChange : root :: nsChangeHint = root :: nsChangeHint ( 268435456 ) ; pub const nsChangeHint_nsChangeHint_UpdateWidgetProperties : root :: nsChangeHint = root :: nsChangeHint ( 536870912 ) ; pub const nsChangeHint_nsChangeHint_UpdateTableCellSpans : root :: nsChangeHint = root :: nsChangeHint ( 1073741824 ) ; pub const nsChangeHint_nsChangeHint_AllHints : root :: nsChangeHint = root :: nsChangeHint ( 2147483647 ) ; impl :: std :: ops :: BitOr < root :: nsChangeHint > for root :: nsChangeHint { type Output = Self ; # [ inline ] fn bitor ( self , other : Self ) -> Self { nsChangeHint ( self . 0 | other . 0 ) } } impl :: std :: ops :: BitOrAssign for root :: nsChangeHint { # [ inline ] fn bitor_assign ( & mut self , rhs : root :: nsChangeHint ) { self . 0 |= rhs . 0 ; } } impl :: std :: ops :: BitAnd < root :: nsChangeHint > for root :: nsChangeHint { type Output = Self ; # [ inline ] fn bitand ( self , other : Self ) -> Self { nsChangeHint ( self . 0 & other . 0 ) } } impl :: std :: ops :: BitAndAssign for root :: nsChangeHint { # [ inline ] fn bitand_assign ( & mut self , rhs : root :: nsChangeHint ) { self . 0 &= rhs . 0 ; } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub struct nsChangeHint ( pub u32 ) ; pub const nsRestyleHint_eRestyle_Self : root :: nsRestyleHint = root :: nsRestyleHint ( 1 ) ; pub const nsRestyleHint_eRestyle_SomeDescendants : root :: nsRestyleHint = root :: nsRestyleHint ( 2 ) ; pub const nsRestyleHint_eRestyle_Subtree : root :: nsRestyleHint = root :: nsRestyleHint ( 4 ) ; pub const nsRestyleHint_eRestyle_LaterSiblings : root :: nsRestyleHint = root :: nsRestyleHint ( 8 ) ; pub const nsRestyleHint_eRestyle_CSSTransitions : root :: nsRestyleHint = root :: nsRestyleHint ( 16 ) ; pub const nsRestyleHint_eRestyle_CSSAnimations : root :: nsRestyleHint = root :: nsRestyleHint ( 32 ) ; pub const nsRestyleHint_eRestyle_StyleAttribute : root :: nsRestyleHint = root :: nsRestyleHint ( 64 ) ; pub const nsRestyleHint_eRestyle_StyleAttribute_Animations : root :: nsRestyleHint = root :: nsRestyleHint ( 128 ) ; pub const nsRestyleHint_eRestyle_Force : root :: nsRestyleHint = root :: nsRestyleHint ( 256 ) ; pub const nsRestyleHint_eRestyle_ForceDescendants : root :: nsRestyleHint = root :: nsRestyleHint ( 512 ) ; pub const nsRestyleHint_eRestyle_AllHintsWithAnimations : root :: nsRestyleHint = root :: nsRestyleHint ( 176 ) ; impl :: std :: ops :: BitOr < root :: nsRestyleHint > for root :: nsRestyleHint { type Output = Self ; # [ inline ] fn bitor ( self , other : Self ) -> Self { nsRestyleHint ( self . 0 | other . 0 ) } } impl :: std :: ops :: BitOrAssign for root :: nsRestyleHint { # [ inline ] fn bitor_assign ( & mut self , rhs : root :: nsRestyleHint ) { self . 0 |= rhs . 0 ; } } impl :: std :: ops :: BitAnd < root :: nsRestyleHint > for root :: nsRestyleHint { type Output = Self ; # [ inline ] fn bitand ( self , other : Self ) -> Self { nsRestyleHint ( self . 0 & other . 0 ) } } impl :: std :: ops :: BitAndAssign for root :: nsRestyleHint { # [ inline ] fn bitand_assign ( & mut self , rhs : root :: nsRestyleHint ) { self . 0 &= rhs . 0 ; } } # [ repr ( C ) ] 
 /// |nsRestyleHint| is a bitfield for the result of
    /// |HasStateDependentStyle| and |HasAttributeDependentStyle|.  When no
    /// restyling is necessary, use |nsRestyleHint(0)|.
    ///
    /// Without eRestyle_Force or eRestyle_ForceDescendants, the restyling process
    /// can stop processing at a frame when it detects no style changes and it is
    /// known that the styles of the subtree beneath it will not change, leaving
    /// the old style context on the frame.  eRestyle_Force can be used to skip this
    /// optimization on a frame, and to force its new style context to be used.
    ///
    /// Similarly, eRestyle_ForceDescendants will cause the frame and all of its
    /// descendants to be traversed and for the new style contexts that are created
    /// to be set on the frames.
    ///
    /// NOTE: When adding new restyle hints, please also add them to
    /// RestyleManager::RestyleHintToString. 
 # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub struct nsRestyleHint ( pub u32 ) ; 
 /// We want C++ to be able to read the style struct fields of ComputedValues
    /// so we define this type on the C++ side and use the bindgenned version
    /// on the Rust side. 
 # [ repr ( C ) ] pub struct ServoComputedData { pub Font : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoFont > , pub Color : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoColor > , pub List : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoList > , pub Text : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoText > , pub Visibility : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoVisibility > , pub UserInterface : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoUserInterface > , pub TableBorder : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoTableBorder > , pub SVG : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoSVG > , pub Background : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoBackground > , pub Position : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoPosition > , pub TextReset : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoTextReset > , pub Display : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoDisplay > , pub Content : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoContent > , pub UIReset : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoUIReset > , pub Table : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoTable > , pub Margin : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoMargin > , pub Padding : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoPadding > , pub Border : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoBorder > , pub Outline : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoOutline > , pub XUL : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoXUL > , pub SVGReset : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoSVGReset > , pub Column : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoColumn > , pub Effects : ::gecko_bindings::structs::ServoRawOffsetArc < root :: mozilla :: GeckoEffects > , pub custom_properties : ::gecko_bindings::structs::ServoCustomPropertiesMap , pub writing_mode : ::gecko_bindings::structs::ServoWritingMode , pub flags : ::gecko_bindings::structs::ServoComputedValueFlags , 
 /// The rule node representing the ordered list of rules matched for this
        /// /// node.  Can be None for default values and text nodes.  This is
        /// /// essentially an optimization to avoid referencing the root rule node. 
 pub rules : ::gecko_bindings::structs::ServoRuleNode , 
 /// The element's computed values if visited, only computed if there's a
        /// /// relevant link for this element. A element's "relevant link" is the
        /// /// element being matched if it is a link or the nearest ancestor link. 
 pub visited_style : ::gecko_bindings::structs::ServoVisitedStyle , } # [ test ] fn bindgen_test_layout_ServoComputedData ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ServoComputedData > ( ) , 216usize , concat ! ( "Size of: " , stringify ! ( ServoComputedData ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ServoComputedData > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ServoComputedData ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . Font as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( Font ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . Color as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( Color ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . List as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( List ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . Text as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( Text ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . Visibility as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( Visibility ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . UserInterface as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( UserInterface ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . TableBorder as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( TableBorder ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . SVG as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( SVG ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . Background as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( Background ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . Position as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( Position ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . TextReset as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( TextReset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . Display as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( Display ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . Content as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( Content ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . UIReset as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( UIReset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . Table as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( Table ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . Margin as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( Margin ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . Padding as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( Padding ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . Border as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( Border ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . Outline as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( Outline ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . XUL as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( XUL ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . SVGReset as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( SVGReset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . Column as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( Column ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . Effects as * const _ as usize } , 176usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( Effects ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . custom_properties as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( custom_properties ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . writing_mode as * const _ as usize } , 192usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( writing_mode ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . flags as * const _ as usize } , 194usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . rules as * const _ as usize } , 200usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( rules ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoComputedData ) ) . visited_style as * const _ as usize } , 208usize , concat ! ( "Alignment of field: " , stringify ! ( ServoComputedData ) , "::" , stringify ! ( visited_style ) ) ) ; } pub const JSValueTag_JSVAL_TAG_MAX_DOUBLE : root :: JSValueTag = 131056 ; pub const JSValueTag_JSVAL_TAG_INT32 : root :: JSValueTag = 131057 ; pub const JSValueTag_JSVAL_TAG_UNDEFINED : root :: JSValueTag = 131058 ; pub const JSValueTag_JSVAL_TAG_NULL : root :: JSValueTag = 131059 ; pub const JSValueTag_JSVAL_TAG_BOOLEAN : root :: JSValueTag = 131060 ; pub const JSValueTag_JSVAL_TAG_MAGIC : root :: JSValueTag = 131061 ; pub const JSValueTag_JSVAL_TAG_STRING : root :: JSValueTag = 131062 ; pub const JSValueTag_JSVAL_TAG_SYMBOL : root :: JSValueTag = 131063 ; pub const JSValueTag_JSVAL_TAG_PRIVATE_GCTHING : root :: JSValueTag = 131064 ; pub const JSValueTag_JSVAL_TAG_OBJECT : root :: JSValueTag = 131068 ; pub type JSValueTag = :: std :: os :: raw :: c_uint ; pub const JSWhyMagic_JS_ELEMENTS_HOLE : root :: JSWhyMagic = 0 ; pub const JSWhyMagic_JS_NO_ITER_VALUE : root :: JSWhyMagic = 1 ; pub const JSWhyMagic_JS_GENERATOR_CLOSING : root :: JSWhyMagic = 2 ; pub const JSWhyMagic_JS_NO_CONSTANT : root :: JSWhyMagic = 3 ; pub const JSWhyMagic_JS_THIS_POISON : root :: JSWhyMagic = 4 ; pub const JSWhyMagic_JS_ARG_POISON : root :: JSWhyMagic = 5 ; pub const JSWhyMagic_JS_SERIALIZE_NO_NODE : root :: JSWhyMagic = 6 ; pub const JSWhyMagic_JS_LAZY_ARGUMENTS : root :: JSWhyMagic = 7 ; pub const JSWhyMagic_JS_OPTIMIZED_ARGUMENTS : root :: JSWhyMagic = 8 ; pub const JSWhyMagic_JS_IS_CONSTRUCTING : root :: JSWhyMagic = 9 ; pub const JSWhyMagic_JS_BLOCK_NEEDS_CLONE : root :: JSWhyMagic = 10 ; pub const JSWhyMagic_JS_HASH_KEY_EMPTY : root :: JSWhyMagic = 11 ; pub const JSWhyMagic_JS_ION_ERROR : root :: JSWhyMagic = 12 ; pub const JSWhyMagic_JS_ION_BAILOUT : root :: JSWhyMagic = 13 ; pub const JSWhyMagic_JS_OPTIMIZED_OUT : root :: JSWhyMagic = 14 ; pub const JSWhyMagic_JS_UNINITIALIZED_LEXICAL : root :: JSWhyMagic = 15 ; pub const JSWhyMagic_JS_GENERIC_MAGIC : root :: JSWhyMagic = 16 ; pub const JSWhyMagic_JS_WHY_MAGIC_COUNT : root :: JSWhyMagic = 17 ; pub type JSWhyMagic = :: std :: os :: raw :: c_uint ; 
 /// This structure precedes the string buffers "we" allocate.  It may be the
    /// case that nsTAString::mData does not point to one of these special
    /// buffers.  The mDataFlags member variable distinguishes the buffer type.
    ///
    /// When this header is in use, it enables reference counting, and capacity
    /// tracking.  NOTE: A string buffer can be modified only if its reference
    /// count is 1. 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStringBuffer { pub mRefCount : u32 , pub mStorageSize : u32 , pub mCanary : u32 , } # [ test ] fn bindgen_test_layout_nsStringBuffer ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStringBuffer > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( nsStringBuffer ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStringBuffer > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( nsStringBuffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStringBuffer ) ) . mRefCount as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStringBuffer ) , "::" , stringify ! ( mRefCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStringBuffer ) ) . mStorageSize as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( nsStringBuffer ) , "::" , stringify ! ( mStorageSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStringBuffer ) ) . mCanary as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStringBuffer ) , "::" , stringify ! ( mCanary ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsAtom { pub mRefCnt : root :: mozilla :: ThreadSafeAutoRefCnt , pub _bitfield_1 : u32 , pub mHash : u32 , pub mString : * mut u16 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsAtom_AtomKind { DynamicAtom = 0 , StaticAtom = 1 , HTML5Atom = 2 , } pub type nsAtom_HasThreadSafeRefCnt = root :: mozilla :: TrueType ; # [ test ] fn bindgen_test_layout_nsAtom ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsAtom > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsAtom ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsAtom > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsAtom ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsAtom ) ) . mRefCnt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsAtom ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsAtom ) ) . mHash as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( nsAtom ) , "::" , stringify ! ( mHash ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsAtom ) ) . mString as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsAtom ) , "::" , stringify ! ( mString ) ) ) ; } impl nsAtom { # [ inline ] pub fn mLength ( & self ) -> u32 { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x3fffffff as u32 ; let val = ( unit_field_val & mask ) >> 0usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mLength ( & mut self , val : u32 ) { let mask = 0x3fffffff as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 0usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn mKind ( & self ) -> u32 { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0xc0000000 as u32 ; let val = ( unit_field_val & mask ) >> 30usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mKind ( & mut self , val : u32 ) { let mask = 0xc0000000 as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 30usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn new_bitfield_1 ( mLength : u32 , mKind : u32 ) -> u32 { ( ( 0 | ( ( mLength as u32 as u32 ) << 0usize ) & ( 0x3fffffff as u32 ) ) | ( ( mKind as u32 as u32 ) << 30usize ) & ( 0xc0000000 as u32 ) ) } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStaticAtom { pub _base : root :: nsAtom , } # [ test ] fn bindgen_test_layout_nsStaticAtom ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStaticAtom > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsStaticAtom ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStaticAtom > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStaticAtom ) ) ) ; } pub type nsLoadFlags = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIRequest { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIRequest_COMTypeInfo { pub _address : u8 , } pub const nsIRequest_LOAD_REQUESTMASK : root :: nsIRequest__bindgen_ty_1 = 65535 ; pub const nsIRequest_LOAD_NORMAL : root :: nsIRequest__bindgen_ty_1 = 0 ; pub const nsIRequest_LOAD_BACKGROUND : root :: nsIRequest__bindgen_ty_1 = 1 ; pub const nsIRequest_LOAD_HTML_OBJECT_DATA : root :: nsIRequest__bindgen_ty_1 = 2 ; pub const nsIRequest_LOAD_DOCUMENT_NEEDS_COOKIE : root :: nsIRequest__bindgen_ty_1 = 4 ; pub const nsIRequest_INHIBIT_CACHING : root :: nsIRequest__bindgen_ty_1 = 128 ; pub const nsIRequest_INHIBIT_PERSISTENT_CACHING : root :: nsIRequest__bindgen_ty_1 = 256 ; pub const nsIRequest_LOAD_BYPASS_CACHE : root :: nsIRequest__bindgen_ty_1 = 512 ; pub const nsIRequest_LOAD_FROM_CACHE : root :: nsIRequest__bindgen_ty_1 = 1024 ; pub const nsIRequest_VALIDATE_ALWAYS : root :: nsIRequest__bindgen_ty_1 = 2048 ; pub const nsIRequest_VALIDATE_NEVER : root :: nsIRequest__bindgen_ty_1 = 4096 ; pub const nsIRequest_VALIDATE_ONCE_PER_SESSION : root :: nsIRequest__bindgen_ty_1 = 8192 ; pub const nsIRequest_LOAD_ANONYMOUS : root :: nsIRequest__bindgen_ty_1 = 16384 ; pub const nsIRequest_LOAD_FRESH_CONNECTION : root :: nsIRequest__bindgen_ty_1 = 32768 ; pub type nsIRequest__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_nsIRequest ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIRequest > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIRequest ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIRequest > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIRequest ) ) ) ; } impl Clone for nsIRequest { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIContentPolicy { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIContentPolicy_COMTypeInfo { pub _address : u8 , } pub const nsIContentPolicy_TYPE_INVALID : root :: nsIContentPolicy__bindgen_ty_1 = 0 ; pub const nsIContentPolicy_TYPE_OTHER : root :: nsIContentPolicy__bindgen_ty_1 = 1 ; pub const nsIContentPolicy_TYPE_SCRIPT : root :: nsIContentPolicy__bindgen_ty_1 = 2 ; pub const nsIContentPolicy_TYPE_IMAGE : root :: nsIContentPolicy__bindgen_ty_1 = 3 ; pub const nsIContentPolicy_TYPE_STYLESHEET : root :: nsIContentPolicy__bindgen_ty_1 = 4 ; pub const nsIContentPolicy_TYPE_OBJECT : root :: nsIContentPolicy__bindgen_ty_1 = 5 ; pub const nsIContentPolicy_TYPE_DOCUMENT : root :: nsIContentPolicy__bindgen_ty_1 = 6 ; pub const nsIContentPolicy_TYPE_SUBDOCUMENT : root :: nsIContentPolicy__bindgen_ty_1 = 7 ; pub const nsIContentPolicy_TYPE_REFRESH : root :: nsIContentPolicy__bindgen_ty_1 = 8 ; pub const nsIContentPolicy_TYPE_XBL : root :: nsIContentPolicy__bindgen_ty_1 = 9 ; pub const nsIContentPolicy_TYPE_PING : root :: nsIContentPolicy__bindgen_ty_1 = 10 ; pub const nsIContentPolicy_TYPE_XMLHTTPREQUEST : root :: nsIContentPolicy__bindgen_ty_1 = 11 ; pub const nsIContentPolicy_TYPE_DATAREQUEST : root :: nsIContentPolicy__bindgen_ty_1 = 11 ; pub const nsIContentPolicy_TYPE_OBJECT_SUBREQUEST : root :: nsIContentPolicy__bindgen_ty_1 = 12 ; pub const nsIContentPolicy_TYPE_DTD : root :: nsIContentPolicy__bindgen_ty_1 = 13 ; pub const nsIContentPolicy_TYPE_FONT : root :: nsIContentPolicy__bindgen_ty_1 = 14 ; pub const nsIContentPolicy_TYPE_MEDIA : root :: nsIContentPolicy__bindgen_ty_1 = 15 ; pub const nsIContentPolicy_TYPE_WEBSOCKET : root :: nsIContentPolicy__bindgen_ty_1 = 16 ; pub const nsIContentPolicy_TYPE_CSP_REPORT : root :: nsIContentPolicy__bindgen_ty_1 = 17 ; pub const nsIContentPolicy_TYPE_XSLT : root :: nsIContentPolicy__bindgen_ty_1 = 18 ; pub const nsIContentPolicy_TYPE_BEACON : root :: nsIContentPolicy__bindgen_ty_1 = 19 ; pub const nsIContentPolicy_TYPE_FETCH : root :: nsIContentPolicy__bindgen_ty_1 = 20 ; pub const nsIContentPolicy_TYPE_IMAGESET : root :: nsIContentPolicy__bindgen_ty_1 = 21 ; pub const nsIContentPolicy_TYPE_WEB_MANIFEST : root :: nsIContentPolicy__bindgen_ty_1 = 22 ; pub const nsIContentPolicy_TYPE_SAVEAS_DOWNLOAD : root :: nsIContentPolicy__bindgen_ty_1 = 43 ; pub const nsIContentPolicy_TYPE_INTERNAL_SCRIPT : root :: nsIContentPolicy__bindgen_ty_1 = 23 ; pub const nsIContentPolicy_TYPE_INTERNAL_WORKER : root :: nsIContentPolicy__bindgen_ty_1 = 24 ; pub const nsIContentPolicy_TYPE_INTERNAL_SHARED_WORKER : root :: nsIContentPolicy__bindgen_ty_1 = 25 ; pub const nsIContentPolicy_TYPE_INTERNAL_EMBED : root :: nsIContentPolicy__bindgen_ty_1 = 26 ; pub const nsIContentPolicy_TYPE_INTERNAL_OBJECT : root :: nsIContentPolicy__bindgen_ty_1 = 27 ; pub const nsIContentPolicy_TYPE_INTERNAL_FRAME : root :: nsIContentPolicy__bindgen_ty_1 = 28 ; pub const nsIContentPolicy_TYPE_INTERNAL_IFRAME : root :: nsIContentPolicy__bindgen_ty_1 = 29 ; pub const nsIContentPolicy_TYPE_INTERNAL_AUDIO : root :: nsIContentPolicy__bindgen_ty_1 = 30 ; pub const nsIContentPolicy_TYPE_INTERNAL_VIDEO : root :: nsIContentPolicy__bindgen_ty_1 = 31 ; pub const nsIContentPolicy_TYPE_INTERNAL_TRACK : root :: nsIContentPolicy__bindgen_ty_1 = 32 ; pub const nsIContentPolicy_TYPE_INTERNAL_XMLHTTPREQUEST : root :: nsIContentPolicy__bindgen_ty_1 = 33 ; pub const nsIContentPolicy_TYPE_INTERNAL_EVENTSOURCE : root :: nsIContentPolicy__bindgen_ty_1 = 34 ; pub const nsIContentPolicy_TYPE_INTERNAL_SERVICE_WORKER : root :: nsIContentPolicy__bindgen_ty_1 = 35 ; pub const nsIContentPolicy_TYPE_INTERNAL_SCRIPT_PRELOAD : root :: nsIContentPolicy__bindgen_ty_1 = 36 ; pub const nsIContentPolicy_TYPE_INTERNAL_IMAGE : root :: nsIContentPolicy__bindgen_ty_1 = 37 ; pub const nsIContentPolicy_TYPE_INTERNAL_IMAGE_PRELOAD : root :: nsIContentPolicy__bindgen_ty_1 = 38 ; pub const nsIContentPolicy_TYPE_INTERNAL_STYLESHEET : root :: nsIContentPolicy__bindgen_ty_1 = 39 ; pub const nsIContentPolicy_TYPE_INTERNAL_STYLESHEET_PRELOAD : root :: nsIContentPolicy__bindgen_ty_1 = 40 ; pub const nsIContentPolicy_TYPE_INTERNAL_IMAGE_FAVICON : root :: nsIContentPolicy__bindgen_ty_1 = 41 ; pub const nsIContentPolicy_TYPE_INTERNAL_WORKER_IMPORT_SCRIPTS : root :: nsIContentPolicy__bindgen_ty_1 = 42 ; pub const nsIContentPolicy_REJECT_REQUEST : root :: nsIContentPolicy__bindgen_ty_1 = -1 ; pub const nsIContentPolicy_REJECT_TYPE : root :: nsIContentPolicy__bindgen_ty_1 = -2 ; pub const nsIContentPolicy_REJECT_SERVER : root :: nsIContentPolicy__bindgen_ty_1 = -3 ; pub const nsIContentPolicy_REJECT_OTHER : root :: nsIContentPolicy__bindgen_ty_1 = -4 ; pub const nsIContentPolicy_ACCEPT : root :: nsIContentPolicy__bindgen_ty_1 = 1 ; pub type nsIContentPolicy__bindgen_ty_1 = :: std :: os :: raw :: c_int ; # [ test ] fn bindgen_test_layout_nsIContentPolicy ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIContentPolicy > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIContentPolicy ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIContentPolicy > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIContentPolicy ) ) ) ; } impl Clone for nsIContentPolicy { fn clone ( & self ) -> Self { * self } } 
 /// Base class that implements parts shared by JSErrorReport and
    /// JSErrorNotes::Note. 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct JSErrorBase { pub message_ : root :: JS :: ConstUTF8CharsZ , pub filename : * const :: std :: os :: raw :: c_char , pub lineno : :: std :: os :: raw :: c_uint , pub column : :: std :: os :: raw :: c_uint , pub errorNumber : :: std :: os :: raw :: c_uint , pub _bitfield_1 : u8 , pub __bindgen_padding_0 : [ u8 ; 3usize ] , } # [ test ] fn bindgen_test_layout_JSErrorBase ( ) { assert_eq ! ( :: std :: mem :: size_of :: < JSErrorBase > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( JSErrorBase ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < JSErrorBase > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( JSErrorBase ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const JSErrorBase ) ) . message_ as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( JSErrorBase ) , "::" , stringify ! ( message_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const JSErrorBase ) ) . filename as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( JSErrorBase ) , "::" , stringify ! ( filename ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const JSErrorBase ) ) . lineno as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( JSErrorBase ) , "::" , stringify ! ( lineno ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const JSErrorBase ) ) . column as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( JSErrorBase ) , "::" , stringify ! ( column ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const JSErrorBase ) ) . errorNumber as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( JSErrorBase ) , "::" , stringify ! ( errorNumber ) ) ) ; } impl JSErrorBase { # [ inline ] pub fn ownsMessage_ ( & self ) -> bool { let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0x1 as u8 ; let val = ( unit_field_val & mask ) >> 0usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_ownsMessage_ ( & mut self , val : bool ) { let mask = 0x1 as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 0usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn new_bitfield_1 ( ownsMessage_ : bool ) -> u8 { ( 0 | ( ( ownsMessage_ as u8 as u8 ) << 0usize ) & ( 0x1 as u8 ) ) } } 
 /// Notes associated with JSErrorReport. 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct JSErrorNotes { pub notes_ : [ u64 ; 4usize ] , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct JSErrorNotes_Note { pub _base : root :: JSErrorBase , } # [ test ] fn bindgen_test_layout_JSErrorNotes_Note ( ) { assert_eq ! ( :: std :: mem :: size_of :: < JSErrorNotes_Note > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( JSErrorNotes_Note ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < JSErrorNotes_Note > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( JSErrorNotes_Note ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct JSErrorNotes_iterator { pub note_ : * mut root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > , } # [ test ] fn bindgen_test_layout_JSErrorNotes_iterator ( ) { assert_eq ! ( :: std :: mem :: size_of :: < JSErrorNotes_iterator > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( JSErrorNotes_iterator ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < JSErrorNotes_iterator > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( JSErrorNotes_iterator ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const JSErrorNotes_iterator ) ) . note_ as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( JSErrorNotes_iterator ) , "::" , stringify ! ( note_ ) ) ) ; } # [ test ] fn bindgen_test_layout_JSErrorNotes ( ) { assert_eq ! ( :: std :: mem :: size_of :: < JSErrorNotes > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( JSErrorNotes ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < JSErrorNotes > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( JSErrorNotes ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const JSErrorNotes ) ) . notes_ as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( JSErrorNotes ) , "::" , stringify ! ( notes_ ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsISerializable { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsISerializable_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsISerializable ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsISerializable > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsISerializable ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsISerializable > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsISerializable ) ) ) ; } impl Clone for nsISerializable { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIPrincipal { pub _base : root :: nsISerializable , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIPrincipal_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIPrincipal ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIPrincipal > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIPrincipal ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIPrincipal > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIPrincipal ) ) ) ; } impl Clone for nsIPrincipal { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIDocShell { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIScriptSecurityManager { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIScriptSecurityManager_COMTypeInfo { pub _address : u8 , } pub const nsIScriptSecurityManager_STANDARD : root :: nsIScriptSecurityManager__bindgen_ty_1 = 0 ; pub const nsIScriptSecurityManager_LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT : root :: nsIScriptSecurityManager__bindgen_ty_1 = 1 ; pub const nsIScriptSecurityManager_ALLOW_CHROME : root :: nsIScriptSecurityManager__bindgen_ty_1 = 2 ; pub const nsIScriptSecurityManager_DISALLOW_INHERIT_PRINCIPAL : root :: nsIScriptSecurityManager__bindgen_ty_1 = 4 ; pub const nsIScriptSecurityManager_DISALLOW_SCRIPT_OR_DATA : root :: nsIScriptSecurityManager__bindgen_ty_1 = 4 ; pub const nsIScriptSecurityManager_DISALLOW_SCRIPT : root :: nsIScriptSecurityManager__bindgen_ty_1 = 8 ; pub const nsIScriptSecurityManager_DONT_REPORT_ERRORS : root :: nsIScriptSecurityManager__bindgen_ty_1 = 16 ; pub type nsIScriptSecurityManager__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; pub const nsIScriptSecurityManager_NO_APP_ID : root :: nsIScriptSecurityManager__bindgen_ty_2 = 0 ; pub const nsIScriptSecurityManager_UNKNOWN_APP_ID : root :: nsIScriptSecurityManager__bindgen_ty_2 = 4294967295 ; pub const nsIScriptSecurityManager_DEFAULT_USER_CONTEXT_ID : root :: nsIScriptSecurityManager__bindgen_ty_2 = 0 ; pub type nsIScriptSecurityManager__bindgen_ty_2 = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_nsIScriptSecurityManager ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIScriptSecurityManager > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIScriptSecurityManager ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIScriptSecurityManager > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIScriptSecurityManager ) ) ) ; } impl Clone for nsIScriptSecurityManager { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIChannel { pub _base : root :: nsIRequest , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIChannel_COMTypeInfo { pub _address : u8 , } pub const nsIChannel_LOAD_DOCUMENT_URI : root :: nsIChannel__bindgen_ty_1 = 65536 ; pub const nsIChannel_LOAD_RETARGETED_DOCUMENT_URI : root :: nsIChannel__bindgen_ty_1 = 131072 ; pub const nsIChannel_LOAD_REPLACE : root :: nsIChannel__bindgen_ty_1 = 262144 ; pub const nsIChannel_LOAD_INITIAL_DOCUMENT_URI : root :: nsIChannel__bindgen_ty_1 = 524288 ; pub const nsIChannel_LOAD_TARGETED : root :: nsIChannel__bindgen_ty_1 = 1048576 ; pub const nsIChannel_LOAD_CALL_CONTENT_SNIFFERS : root :: nsIChannel__bindgen_ty_1 = 2097152 ; pub const nsIChannel_LOAD_CLASSIFY_URI : root :: nsIChannel__bindgen_ty_1 = 4194304 ; pub const nsIChannel_LOAD_MEDIA_SNIFFER_OVERRIDES_CONTENT_TYPE : root :: nsIChannel__bindgen_ty_1 = 8388608 ; pub const nsIChannel_LOAD_EXPLICIT_CREDENTIALS : root :: nsIChannel__bindgen_ty_1 = 16777216 ; pub const nsIChannel_LOAD_BYPASS_SERVICE_WORKER : root :: nsIChannel__bindgen_ty_1 = 33554432 ; pub type nsIChannel__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; pub const nsIChannel_DISPOSITION_INLINE : root :: nsIChannel__bindgen_ty_2 = 0 ; pub const nsIChannel_DISPOSITION_ATTACHMENT : root :: nsIChannel__bindgen_ty_2 = 1 ; pub type nsIChannel__bindgen_ty_2 = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_nsIChannel ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIChannel > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIChannel ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIChannel > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIChannel ) ) ) ; } impl Clone for nsIChannel { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsICSSLoaderObserver { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsICSSLoaderObserver_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsICSSLoaderObserver ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsICSSLoaderObserver > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsICSSLoaderObserver ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsICSSLoaderObserver > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsICSSLoaderObserver ) ) ) ; } impl Clone for nsICSSLoaderObserver { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIDOMStyleSheet { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIDOMStyleSheet_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIDOMStyleSheet ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIDOMStyleSheet > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIDOMStyleSheet ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIDOMStyleSheet > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIDOMStyleSheet ) ) ) ; } impl Clone for nsIDOMStyleSheet { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIDOMCSSStyleSheet { pub _base : root :: nsIDOMStyleSheet , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIDOMCSSStyleSheet_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIDOMCSSStyleSheet ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIDOMCSSStyleSheet > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIDOMCSSStyleSheet ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIDOMCSSStyleSheet > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIDOMCSSStyleSheet ) ) ) ; } impl Clone for nsIDOMCSSStyleSheet { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] pub struct nsCycleCollectionParticipant__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; 
 /// Participant implementation classes 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsCycleCollectionParticipant { pub vtable_ : * const nsCycleCollectionParticipant__bindgen_vtable , pub mMightSkip : bool , pub mTraverseShouldTrace : bool , } # [ test ] fn bindgen_test_layout_nsCycleCollectionParticipant ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCycleCollectionParticipant > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsCycleCollectionParticipant ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCycleCollectionParticipant > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCycleCollectionParticipant ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCycleCollectionParticipant ) ) . mMightSkip as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsCycleCollectionParticipant ) , "::" , stringify ! ( mMightSkip ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCycleCollectionParticipant ) ) . mTraverseShouldTrace as * const _ as usize } , 9usize , concat ! ( "Alignment of field: " , stringify ! ( nsCycleCollectionParticipant ) , "::" , stringify ! ( mTraverseShouldTrace ) ) ) ; } impl Clone for nsCycleCollectionParticipant { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsScriptObjectTracer { pub _base : root :: nsCycleCollectionParticipant , } # [ test ] fn bindgen_test_layout_nsScriptObjectTracer ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsScriptObjectTracer > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsScriptObjectTracer ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsScriptObjectTracer > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsScriptObjectTracer ) ) ) ; } impl Clone for nsScriptObjectTracer { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsXPCOMCycleCollectionParticipant { pub _base : root :: nsScriptObjectTracer , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsXPCOMCycleCollectionParticipant_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsXPCOMCycleCollectionParticipant ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsXPCOMCycleCollectionParticipant > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsXPCOMCycleCollectionParticipant ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsXPCOMCycleCollectionParticipant > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsXPCOMCycleCollectionParticipant ) ) ) ; } impl Clone for nsXPCOMCycleCollectionParticipant { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] pub struct nsWrapperCache__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; 
 /// Class to store the wrapper for an object. This can only be used with objects
    /// that only have one non-security wrapper at a time (for an XPCWrappedNative
    /// this is usually ensured by setting an explicit parent in the PreCreate hook
    /// for the class).
    ///
    /// An instance of nsWrapperCache can be gotten from an object that implements
    /// a wrapper cache by calling QueryInterface on it. Note that this breaks XPCOM
    /// rules a bit (this object doesn't derive from nsISupports).
    ///
    /// The cache can store objects other than wrappers. We allow wrappers to use a
    /// separate JSObject to store their state (mostly expandos). If the wrapper is
    /// collected and we want to preserve this state we actually store the state
    /// object in the cache.
    ///
    /// The cache can store 2 types of objects:
    ///
    /// If WRAPPER_IS_NOT_DOM_BINDING is set (IsDOMBinding() returns false):
    /// - the JSObject of an XPCWrappedNative wrapper
    ///
    /// If WRAPPER_IS_NOT_DOM_BINDING is not set (IsDOMBinding() returns true):
    /// - a DOM binding object (regular JS object or proxy)
    ///
    /// The finalizer for the wrapper clears the cache.
    ///
    /// A compacting GC can move the wrapper object. Pointers to moved objects are
    /// usually found and updated by tracing the heap, however non-preserved wrappers
    /// are weak references and are not traced, so another approach is
    /// necessary. Instead a class hook (objectMovedOp) is provided that is called
    /// when an object is moved and is responsible for ensuring pointers are
    /// updated. It does this by calling UpdateWrapper() on the wrapper
    /// cache. SetWrapper() asserts that the hook is implemented for any wrapper set.
    ///
    /// A number of the methods are implemented in nsWrapperCacheInlines.h because we
    /// have to include some JS headers that don't play nicely with the rest of the
    /// codebase. Include nsWrapperCacheInlines.h if you need to call those methods. 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsWrapperCache { pub vtable_ : * const nsWrapperCache__bindgen_vtable , pub mWrapper : * mut root :: JSObject , pub mFlags : root :: nsWrapperCache_FlagsType , pub mBoolFlags : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsWrapperCache_COMTypeInfo { pub _address : u8 , } pub type nsWrapperCache_FlagsType = u32 ; pub const nsWrapperCache_WRAPPER_BIT_PRESERVED : root :: nsWrapperCache__bindgen_ty_1 = 1 ; pub type nsWrapperCache__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; pub const nsWrapperCache_WRAPPER_IS_NOT_DOM_BINDING : root :: nsWrapperCache__bindgen_ty_2 = 2 ; pub type nsWrapperCache__bindgen_ty_2 = :: std :: os :: raw :: c_uint ; pub const nsWrapperCache_kWrapperFlagsMask : root :: nsWrapperCache__bindgen_ty_3 = 3 ; pub type nsWrapperCache__bindgen_ty_3 = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_nsWrapperCache ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsWrapperCache > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsWrapperCache ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsWrapperCache > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsWrapperCache ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsWrapperCache ) ) . mWrapper as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsWrapperCache ) , "::" , stringify ! ( mWrapper ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsWrapperCache ) ) . mFlags as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsWrapperCache ) , "::" , stringify ! ( mFlags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsWrapperCache ) ) . mBoolFlags as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( nsWrapperCache ) , "::" , stringify ! ( mBoolFlags ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ProfilerBacktrace { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ProfilerMarkerPayload { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct ProfilerBacktraceDestructor { pub _address : u8 , } # [ test ] fn bindgen_test_layout_ProfilerBacktraceDestructor ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ProfilerBacktraceDestructor > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( ProfilerBacktraceDestructor ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ProfilerBacktraceDestructor > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( ProfilerBacktraceDestructor ) ) ) ; } impl Clone for ProfilerBacktraceDestructor { fn clone ( & self ) -> Self { * self } } pub type UniqueProfilerBacktrace = root :: mozilla :: UniquePtr < root :: ProfilerBacktrace > ; pub type gfxSize = [ u64 ; 2usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIDOMNode { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIDOMNode_COMTypeInfo { pub _address : u8 , } pub const nsIDOMNode_ELEMENT_NODE : root :: nsIDOMNode__bindgen_ty_1 = 1 ; pub const nsIDOMNode_ATTRIBUTE_NODE : root :: nsIDOMNode__bindgen_ty_1 = 2 ; pub const nsIDOMNode_TEXT_NODE : root :: nsIDOMNode__bindgen_ty_1 = 3 ; pub const nsIDOMNode_CDATA_SECTION_NODE : root :: nsIDOMNode__bindgen_ty_1 = 4 ; pub const nsIDOMNode_ENTITY_REFERENCE_NODE : root :: nsIDOMNode__bindgen_ty_1 = 5 ; pub const nsIDOMNode_ENTITY_NODE : root :: nsIDOMNode__bindgen_ty_1 = 6 ; pub const nsIDOMNode_PROCESSING_INSTRUCTION_NODE : root :: nsIDOMNode__bindgen_ty_1 = 7 ; pub const nsIDOMNode_COMMENT_NODE : root :: nsIDOMNode__bindgen_ty_1 = 8 ; pub const nsIDOMNode_DOCUMENT_NODE : root :: nsIDOMNode__bindgen_ty_1 = 9 ; pub const nsIDOMNode_DOCUMENT_TYPE_NODE : root :: nsIDOMNode__bindgen_ty_1 = 10 ; pub const nsIDOMNode_DOCUMENT_FRAGMENT_NODE : root :: nsIDOMNode__bindgen_ty_1 = 11 ; pub const nsIDOMNode_NOTATION_NODE : root :: nsIDOMNode__bindgen_ty_1 = 12 ; pub type nsIDOMNode__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; pub const nsIDOMNode_DOCUMENT_POSITION_DISCONNECTED : root :: nsIDOMNode__bindgen_ty_2 = 1 ; pub const nsIDOMNode_DOCUMENT_POSITION_PRECEDING : root :: nsIDOMNode__bindgen_ty_2 = 2 ; pub const nsIDOMNode_DOCUMENT_POSITION_FOLLOWING : root :: nsIDOMNode__bindgen_ty_2 = 4 ; pub const nsIDOMNode_DOCUMENT_POSITION_CONTAINS : root :: nsIDOMNode__bindgen_ty_2 = 8 ; pub const nsIDOMNode_DOCUMENT_POSITION_CONTAINED_BY : root :: nsIDOMNode__bindgen_ty_2 = 16 ; pub const nsIDOMNode_DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC : root :: nsIDOMNode__bindgen_ty_2 = 32 ; pub type nsIDOMNode__bindgen_ty_2 = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_nsIDOMNode ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIDOMNode > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIDOMNode ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIDOMNode > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIDOMNode ) ) ) ; } impl Clone for nsIDOMNode { fn clone ( & self ) -> Self { * self } } pub const kNameSpaceID_None : i32 = 0 ; pub type PLHashNumber = root :: PRUint32 ; pub type PLHashFunction = :: std :: option :: Option < unsafe extern "C" fn ( key : * const :: std :: os :: raw :: c_void ) -> root :: PLHashNumber > ; pub type PLHashComparator = :: std :: option :: Option < unsafe extern "C" fn ( v1 : * const :: std :: os :: raw :: c_void , v2 : * const :: std :: os :: raw :: c_void ) -> root :: PRIntn > ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct PLHashAllocOps { pub allocTable : :: std :: option :: Option < unsafe extern "C" fn ( pool : * mut :: std :: os :: raw :: c_void , size : root :: PRSize ) -> * mut :: std :: os :: raw :: c_void > , pub freeTable : :: std :: option :: Option < unsafe extern "C" fn ( pool : * mut :: std :: os :: raw :: c_void , item : * mut :: std :: os :: raw :: c_void ) > , pub allocEntry : :: std :: option :: Option < unsafe extern "C" fn ( pool : * mut :: std :: os :: raw :: c_void , key : * const :: std :: os :: raw :: c_void ) -> * mut root :: PLHashEntry > , pub freeEntry : :: std :: option :: Option < unsafe extern "C" fn ( pool : * mut :: std :: os :: raw :: c_void , he : * mut root :: PLHashEntry , flag : root :: PRUintn ) > , } # [ test ] fn bindgen_test_layout_PLHashAllocOps ( ) { assert_eq ! ( :: std :: mem :: size_of :: < PLHashAllocOps > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( PLHashAllocOps ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < PLHashAllocOps > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( PLHashAllocOps ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLHashAllocOps ) ) . allocTable as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( PLHashAllocOps ) , "::" , stringify ! ( allocTable ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLHashAllocOps ) ) . freeTable as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( PLHashAllocOps ) , "::" , stringify ! ( freeTable ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLHashAllocOps ) ) . allocEntry as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( PLHashAllocOps ) , "::" , stringify ! ( allocEntry ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLHashAllocOps ) ) . freeEntry as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( PLHashAllocOps ) , "::" , stringify ! ( freeEntry ) ) ) ; } impl Clone for PLHashAllocOps { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct PLHashEntry { pub next : * mut root :: PLHashEntry , pub keyHash : root :: PLHashNumber , pub key : * const :: std :: os :: raw :: c_void , pub value : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout_PLHashEntry ( ) { assert_eq ! ( :: std :: mem :: size_of :: < PLHashEntry > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( PLHashEntry ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < PLHashEntry > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( PLHashEntry ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLHashEntry ) ) . next as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( PLHashEntry ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLHashEntry ) ) . keyHash as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( PLHashEntry ) , "::" , stringify ! ( keyHash ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLHashEntry ) ) . key as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( PLHashEntry ) , "::" , stringify ! ( key ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLHashEntry ) ) . value as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( PLHashEntry ) , "::" , stringify ! ( value ) ) ) ; } impl Clone for PLHashEntry { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct PLHashTable { pub buckets : * mut * mut root :: PLHashEntry , pub nentries : root :: PRUint32 , pub shift : root :: PRUint32 , pub keyHash : root :: PLHashFunction , pub keyCompare : root :: PLHashComparator , pub valueCompare : root :: PLHashComparator , pub allocOps : * const root :: PLHashAllocOps , pub allocPriv : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout_PLHashTable ( ) { assert_eq ! ( :: std :: mem :: size_of :: < PLHashTable > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( PLHashTable ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < PLHashTable > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( PLHashTable ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLHashTable ) ) . buckets as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( PLHashTable ) , "::" , stringify ! ( buckets ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLHashTable ) ) . nentries as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( PLHashTable ) , "::" , stringify ! ( nentries ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLHashTable ) ) . shift as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( PLHashTable ) , "::" , stringify ! ( shift ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLHashTable ) ) . keyHash as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( PLHashTable ) , "::" , stringify ! ( keyHash ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLHashTable ) ) . keyCompare as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( PLHashTable ) , "::" , stringify ! ( keyCompare ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLHashTable ) ) . valueCompare as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( PLHashTable ) , "::" , stringify ! ( valueCompare ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLHashTable ) ) . allocOps as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( PLHashTable ) , "::" , stringify ! ( allocOps ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const PLHashTable ) ) . allocPriv as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( PLHashTable ) , "::" , stringify ! ( allocPriv ) ) ) ; } impl Clone for PLHashTable { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIVariant { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIVariant_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIVariant ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIVariant > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIVariant ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIVariant > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIVariant ) ) ) ; } impl Clone for nsIVariant { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] pub struct nsNodeInfoManager { pub mRefCnt : root :: nsCycleCollectingAutoRefCnt , pub mNodeInfoHash : * mut root :: PLHashTable , pub mDocument : * mut root :: nsIDocument , pub mNonDocumentNodeInfos : u32 , pub mPrincipal : root :: nsCOMPtr , pub mDefaultPrincipal : root :: nsCOMPtr , pub mTextNodeInfo : * mut root :: mozilla :: dom :: NodeInfo , pub mCommentNodeInfo : * mut root :: mozilla :: dom :: NodeInfo , pub mDocumentNodeInfo : * mut root :: mozilla :: dom :: NodeInfo , pub mBindingManager : root :: RefPtr < root :: nsBindingManager > , pub mRecentlyUsedNodeInfos : [ * mut root :: mozilla :: dom :: NodeInfo ; 31usize ] , pub mSVGEnabled : root :: nsNodeInfoManager_Tri , pub mMathMLEnabled : root :: nsNodeInfoManager_Tri , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsNodeInfoManager_cycleCollection { pub _base : root :: nsCycleCollectionParticipant , } # [ test ] fn bindgen_test_layout_nsNodeInfoManager_cycleCollection ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsNodeInfoManager_cycleCollection > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsNodeInfoManager_cycleCollection ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsNodeInfoManager_cycleCollection > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsNodeInfoManager_cycleCollection ) ) ) ; } impl Clone for nsNodeInfoManager_cycleCollection { fn clone ( & self ) -> Self { * self } } pub type nsNodeInfoManager_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; pub const nsNodeInfoManager_Tri_eTriUnset : root :: nsNodeInfoManager_Tri = 0 ; pub const nsNodeInfoManager_Tri_eTriFalse : root :: nsNodeInfoManager_Tri = 1 ; pub const nsNodeInfoManager_Tri_eTriTrue : root :: nsNodeInfoManager_Tri = 2 ; pub type nsNodeInfoManager_Tri = :: std :: os :: raw :: c_uint ; extern "C" {
 # [ link_name = "\u{1}_ZN17nsNodeInfoManager21_cycleCollectorGlobalE" ] 
 pub static mut  nsNodeInfoManager__cycleCollectorGlobal  :  root :: nsNodeInfoManager_cycleCollection ;
} # [ test ] fn bindgen_test_layout_nsNodeInfoManager ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsNodeInfoManager > ( ) , 336usize , concat ! ( "Size of: " , stringify ! ( nsNodeInfoManager ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsNodeInfoManager > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsNodeInfoManager ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsNodeInfoManager ) ) . mRefCnt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsNodeInfoManager ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsNodeInfoManager ) ) . mNodeInfoHash as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsNodeInfoManager ) , "::" , stringify ! ( mNodeInfoHash ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsNodeInfoManager ) ) . mDocument as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsNodeInfoManager ) , "::" , stringify ! ( mDocument ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsNodeInfoManager ) ) . mNonDocumentNodeInfos as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsNodeInfoManager ) , "::" , stringify ! ( mNonDocumentNodeInfos ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsNodeInfoManager ) ) . mPrincipal as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsNodeInfoManager ) , "::" , stringify ! ( mPrincipal ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsNodeInfoManager ) ) . mDefaultPrincipal as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( nsNodeInfoManager ) , "::" , stringify ! ( mDefaultPrincipal ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsNodeInfoManager ) ) . mTextNodeInfo as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( nsNodeInfoManager ) , "::" , stringify ! ( mTextNodeInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsNodeInfoManager ) ) . mCommentNodeInfo as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( nsNodeInfoManager ) , "::" , stringify ! ( mCommentNodeInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsNodeInfoManager ) ) . mDocumentNodeInfo as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( nsNodeInfoManager ) , "::" , stringify ! ( mDocumentNodeInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsNodeInfoManager ) ) . mBindingManager as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( nsNodeInfoManager ) , "::" , stringify ! ( mBindingManager ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsNodeInfoManager ) ) . mRecentlyUsedNodeInfos as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( nsNodeInfoManager ) , "::" , stringify ! ( mRecentlyUsedNodeInfos ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsNodeInfoManager ) ) . mSVGEnabled as * const _ as usize } , 328usize , concat ! ( "Alignment of field: " , stringify ! ( nsNodeInfoManager ) , "::" , stringify ! ( mSVGEnabled ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsNodeInfoManager ) ) . mMathMLEnabled as * const _ as usize } , 332usize , concat ! ( "Alignment of field: " , stringify ! ( nsNodeInfoManager ) , "::" , stringify ! ( mMathMLEnabled ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsPropertyTable { pub mPropertyList : * mut root :: nsPropertyTable_PropertyList , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsPropertyTable_PropertyList { _unused : [ u8 ; 0 ] } # [ test ] fn bindgen_test_layout_nsPropertyTable ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsPropertyTable > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsPropertyTable ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsPropertyTable > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsPropertyTable ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPropertyTable ) ) . mPropertyList as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsPropertyTable ) , "::" , stringify ! ( mPropertyList ) ) ) ; } pub type nsTObserverArray_base_index_type = usize ; pub type nsTObserverArray_base_size_type = usize ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsTObserverArray_base_Iterator_base { pub mPosition : root :: nsTObserverArray_base_index_type , pub mNext : * mut root :: nsTObserverArray_base_Iterator_base , } # [ test ] fn bindgen_test_layout_nsTObserverArray_base_Iterator_base ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsTObserverArray_base_Iterator_base > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsTObserverArray_base_Iterator_base ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsTObserverArray_base_Iterator_base > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsTObserverArray_base_Iterator_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsTObserverArray_base_Iterator_base ) ) . mPosition as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsTObserverArray_base_Iterator_base ) , "::" , stringify ! ( mPosition ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsTObserverArray_base_Iterator_base ) ) . mNext as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsTObserverArray_base_Iterator_base ) , "::" , stringify ! ( mNext ) ) ) ; } impl Clone for nsTObserverArray_base_Iterator_base { fn clone ( & self ) -> Self { * self } } pub type nsAutoTObserverArray_elem_type < T > = T ; pub type nsAutoTObserverArray_array_type < T > = root :: nsTArray < T > ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsAutoTObserverArray_Iterator { pub _base : root :: nsTObserverArray_base_Iterator_base , pub mArray : * mut root :: nsAutoTObserverArray_Iterator_array_type , } pub type nsAutoTObserverArray_Iterator_array_type = u8 ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsAutoTObserverArray_ForwardIterator { pub _base : root :: nsAutoTObserverArray_Iterator , } pub type nsAutoTObserverArray_ForwardIterator_array_type = u8 ; pub type nsAutoTObserverArray_ForwardIterator_base_type = root :: nsAutoTObserverArray_Iterator ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsAutoTObserverArray_EndLimitedIterator { pub _base : root :: nsAutoTObserverArray_ForwardIterator , pub mEnd : root :: nsAutoTObserverArray_ForwardIterator , } pub type nsAutoTObserverArray_EndLimitedIterator_array_type = u8 ; pub type nsAutoTObserverArray_EndLimitedIterator_base_type = root :: nsAutoTObserverArray_Iterator ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsAutoTObserverArray_BackwardIterator { pub _base : root :: nsAutoTObserverArray_Iterator , } pub type nsAutoTObserverArray_BackwardIterator_array_type = u8 ; pub type nsAutoTObserverArray_BackwardIterator_base_type = root :: nsAutoTObserverArray_Iterator ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsTObserverArray { pub _address : u8 , } pub type nsTObserverArray_base_type = u8 ; pub type nsTObserverArray_size_type = root :: nsTObserverArray_base_size_type ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIDOMEventTarget { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIDOMEventTarget_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIDOMEventTarget ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIDOMEventTarget > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIDOMEventTarget ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIDOMEventTarget > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIDOMEventTarget ) ) ) ; } impl Clone for nsIDOMEventTarget { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsAttrChildContentList { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsCSSSelectorList { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsRange { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RawServoSelectorList { _unused : [ u8 ; 0 ] } pub const NODE_HAS_LISTENERMANAGER : root :: _bindgen_ty_77 = 4 ; pub const NODE_HAS_PROPERTIES : root :: _bindgen_ty_77 = 8 ; pub const NODE_IS_ANONYMOUS_ROOT : root :: _bindgen_ty_77 = 16 ; pub const NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE : root :: _bindgen_ty_77 = 32 ; pub const NODE_IS_NATIVE_ANONYMOUS_ROOT : root :: _bindgen_ty_77 = 64 ; pub const NODE_FORCE_XBL_BINDINGS : root :: _bindgen_ty_77 = 128 ; pub const NODE_MAY_BE_IN_BINDING_MNGR : root :: _bindgen_ty_77 = 256 ; pub const NODE_IS_EDITABLE : root :: _bindgen_ty_77 = 512 ; pub const NODE_IS_NATIVE_ANONYMOUS : root :: _bindgen_ty_77 = 1024 ; pub const NODE_IS_IN_SHADOW_TREE : root :: _bindgen_ty_77 = 2048 ; pub const NODE_HAS_EMPTY_SELECTOR : root :: _bindgen_ty_77 = 4096 ; pub const NODE_HAS_SLOW_SELECTOR : root :: _bindgen_ty_77 = 8192 ; pub const NODE_HAS_EDGE_CHILD_SELECTOR : root :: _bindgen_ty_77 = 16384 ; pub const NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS : root :: _bindgen_ty_77 = 32768 ; pub const NODE_ALL_SELECTOR_FLAGS : root :: _bindgen_ty_77 = 61440 ; pub const NODE_NEEDS_FRAME : root :: _bindgen_ty_77 = 65536 ; pub const NODE_DESCENDANTS_NEED_FRAMES : root :: _bindgen_ty_77 = 131072 ; pub const NODE_HAS_ACCESSKEY : root :: _bindgen_ty_77 = 262144 ; pub const NODE_HAS_DIRECTION_RTL : root :: _bindgen_ty_77 = 524288 ; pub const NODE_HAS_DIRECTION_LTR : root :: _bindgen_ty_77 = 1048576 ; pub const NODE_ALL_DIRECTION_FLAGS : root :: _bindgen_ty_77 = 1572864 ; pub const NODE_CHROME_ONLY_ACCESS : root :: _bindgen_ty_77 = 2097152 ; pub const NODE_IS_ROOT_OF_CHROME_ONLY_ACCESS : root :: _bindgen_ty_77 = 4194304 ; pub const NODE_TYPE_SPECIFIC_BITS_OFFSET : root :: _bindgen_ty_77 = 21 ; pub type _bindgen_ty_77 = :: std :: os :: raw :: c_uint ; 
 /// An internal interface that abstracts some DOMNode-related parts that both
    /// nsIContent and nsIDocument share.  An instance of this interface has a list
    /// of nsIContent children and provides access to them. 
 # [ repr ( C ) ] pub struct nsINode { pub _base : root :: mozilla :: dom :: EventTarget , pub mNodeInfo : root :: RefPtr < root :: mozilla :: dom :: NodeInfo > , pub mParent : * mut root :: nsINode , pub mNextSibling : * mut root :: nsIContent , pub mPreviousSibling : * mut root :: nsIContent , pub mFirstChild : * mut root :: nsIContent , pub __bindgen_anon_1 : root :: nsINode__bindgen_ty_1 , pub mSlots : * mut root :: nsINode_nsSlots , } pub type nsINode_BoxQuadOptions = root :: mozilla :: dom :: BoxQuadOptions ; pub type nsINode_ConvertCoordinateOptions = root :: mozilla :: dom :: ConvertCoordinateOptions ; pub type nsINode_DocGroup = root :: mozilla :: dom :: DocGroup ; pub type nsINode_DOMPoint = root :: mozilla :: dom :: DOMPoint ; pub type nsINode_DOMPointInit = root :: mozilla :: dom :: DOMPointInit ; pub type nsINode_DOMQuad = root :: mozilla :: dom :: DOMQuad ; pub type nsINode_DOMRectReadOnly = root :: mozilla :: dom :: DOMRectReadOnly ; pub type nsINode_OwningNodeOrString = root :: mozilla :: dom :: OwningNodeOrString ; pub type nsINode_TextOrElementOrDocument = root :: mozilla :: dom :: TextOrElementOrDocument ; pub use self :: super :: root :: mozilla :: dom :: CallerType as nsINode_CallerType ; pub type nsINode_Sequence = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsINode_COMTypeInfo { pub _address : u8 , } pub const nsINode_eDOCUMENT : root :: nsINode__bindgen_ty_2 = 2 ; pub const nsINode_eATTRIBUTE : root :: nsINode__bindgen_ty_2 = 4 ; pub const nsINode_eTEXT : root :: nsINode__bindgen_ty_2 = 8 ; pub const nsINode_ePROCESSING_INSTRUCTION : root :: nsINode__bindgen_ty_2 = 16 ; pub const nsINode_eCOMMENT : root :: nsINode__bindgen_ty_2 = 32 ; pub const nsINode_eHTML_FORM_CONTROL : root :: nsINode__bindgen_ty_2 = 64 ; pub const nsINode_eDOCUMENT_FRAGMENT : root :: nsINode__bindgen_ty_2 = 128 ; pub const nsINode_eDATA_NODE : root :: nsINode__bindgen_ty_2 = 256 ; pub const nsINode_eMEDIA : root :: nsINode__bindgen_ty_2 = 512 ; pub const nsINode_eANIMATION : root :: nsINode__bindgen_ty_2 = 1024 ; pub const nsINode_eFILTER : root :: nsINode__bindgen_ty_2 = 2048 ; pub type nsINode__bindgen_ty_2 = :: std :: os :: raw :: c_uint ; # [ repr ( C ) ] pub struct nsINode_nsSlots__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsINode_nsSlots { pub vtable_ : * const nsINode_nsSlots__bindgen_vtable , 
 /// A list of mutation observers 
 pub mMutationObservers : [ u64 ; 4usize ] , 
 /// An object implementing nsIDOMNodeList for this content (childNodes)
        /// @see nsIDOMNodeList
        /// @see nsGenericHTMLElement::GetChildNodes 
 pub mChildNodes : root :: RefPtr < root :: nsAttrChildContentList > , 
 /// Weak reference to this node.  This is cleared by the destructor of
        /// nsNodeWeakReference. 
 pub mWeakReference : * mut root :: nsNodeWeakReference , 
 /// A set of ranges which are in the selection and which have this node as
        /// their endpoints' common ancestor.  This is a UniquePtr instead of just a
        /// LinkedList, because that prevents us from pushing DOMSlots up to the next
        /// allocation bucket size, at the cost of some complexity. 
 pub mCommonAncestorRanges : root :: mozilla :: UniquePtr < root :: mozilla :: LinkedList > , 
 /// Number of descendant nodes in the uncomposed document that have been
        /// explicitly set as editable. 
 pub mEditableDescendantCount : u32 , } # [ test ] fn bindgen_test_layout_nsINode_nsSlots ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsINode_nsSlots > ( ) , 72usize , concat ! ( "Size of: " , stringify ! ( nsINode_nsSlots ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsINode_nsSlots > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsINode_nsSlots ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsINode_nsSlots ) ) . mMutationObservers as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsINode_nsSlots ) , "::" , stringify ! ( mMutationObservers ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsINode_nsSlots ) ) . mChildNodes as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( nsINode_nsSlots ) , "::" , stringify ! ( mChildNodes ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsINode_nsSlots ) ) . mWeakReference as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( nsINode_nsSlots ) , "::" , stringify ! ( mWeakReference ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsINode_nsSlots ) ) . mCommonAncestorRanges as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( nsINode_nsSlots ) , "::" , stringify ! ( mCommonAncestorRanges ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsINode_nsSlots ) ) . mEditableDescendantCount as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( nsINode_nsSlots ) , "::" , stringify ! ( mEditableDescendantCount ) ) ) ; } # [ repr ( u32 ) ] 
 /// Boolean flags 
 # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsINode_BooleanFlag { NodeHasRenderingObservers = 0 , IsInDocument = 1 , ParentIsContent = 2 , NodeIsElement = 3 , ElementHasID = 4 , ElementMayHaveClass = 5 , ElementMayHaveStyle = 6 , ElementHasName = 7 , ElementMayHaveContentEditableAttr = 8 , NodeIsCommonAncestorForRangeInSelection = 9 , NodeIsDescendantOfCommonAncestorForRangeInSelection = 10 , NodeIsCCMarkedRoot = 11 , NodeIsCCBlackTree = 12 , NodeIsPurpleRoot = 13 , ElementHasLockedStyleStates = 14 , ElementHasPointerLock = 15 , NodeMayHaveDOMMutationObserver = 16 , NodeIsContent = 17 , ElementHasAnimations = 18 , NodeHasValidDirAttribute = 19 , NodeHasDirAutoSet = 20 , NodeHasTextNodeDirectionalityMap = 21 , NodeAncestorHasDirAuto = 22 , ElementIsInStyleScope = 23 , ElementIsScopedStyleRoot = 24 , NodeHandlingClick = 25 , NodeHasRelevantHoverRules = 26 , ElementHasWeirdParserInsertionMode = 27 , ParserHasNotified = 28 , MayBeApzAware = 29 , ElementMayHaveAnonymousChildren = 30 , NodeMayHaveChildrenWithLayoutBoxesDisabled = 31 , BooleanFlagCount = 32 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsINode__bindgen_ty_1 { pub mPrimaryFrame : root :: __BindgenUnionField < * mut root :: nsIFrame > , pub mSubtreeRoot : root :: __BindgenUnionField < * mut root :: nsINode > , pub bindgen_union_field : u64 , } # [ test ] fn bindgen_test_layout_nsINode__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsINode__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsINode__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsINode__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsINode__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsINode__bindgen_ty_1 ) ) . mPrimaryFrame as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsINode__bindgen_ty_1 ) , "::" , stringify ! ( mPrimaryFrame ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsINode__bindgen_ty_1 ) ) . mSubtreeRoot as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsINode__bindgen_ty_1 ) , "::" , stringify ! ( mSubtreeRoot ) ) ) ; } impl Clone for nsINode__bindgen_ty_1 { fn clone ( & self ) -> Self { * self } } # [ test ] fn bindgen_test_layout_nsINode ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsINode > ( ) , 88usize , concat ! ( "Size of: " , stringify ! ( nsINode ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsINode > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsINode ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsINode ) ) . mNodeInfo as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsINode ) , "::" , stringify ! ( mNodeInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsINode ) ) . mParent as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( nsINode ) , "::" , stringify ! ( mParent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsINode ) ) . mNextSibling as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( nsINode ) , "::" , stringify ! ( mNextSibling ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsINode ) ) . mPreviousSibling as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( nsINode ) , "::" , stringify ! ( mPreviousSibling ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsINode ) ) . mFirstChild as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( nsINode ) , "::" , stringify ! ( mFirstChild ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsINode ) ) . mSlots as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( nsINode ) , "::" , stringify ! ( mSlots ) ) ) ; } 
 /// A node of content in a document's content model. This interface
    /// is supported by all content objects. 
 # [ repr ( C ) ] pub struct nsIContent { pub _base : root :: nsINode , } pub type nsIContent_IMEState = root :: mozilla :: widget :: IMEState ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIContent_COMTypeInfo { pub _address : u8 , } pub const nsIContent_eAllChildren : root :: nsIContent__bindgen_ty_1 = 0 ; pub const nsIContent_eAllButXBL : root :: nsIContent__bindgen_ty_1 = 1 ; pub const nsIContent_eSkipPlaceholderContent : root :: nsIContent__bindgen_ty_1 = 2 ; pub const nsIContent_eSkipDocumentLevelNativeAnonymousContent : root :: nsIContent__bindgen_ty_1 = 4 ; pub type nsIContent__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; pub const nsIContent_FlattenedParentType_eNotForStyle : root :: nsIContent_FlattenedParentType = 0 ; pub const nsIContent_FlattenedParentType_eForStyle : root :: nsIContent_FlattenedParentType = 1 ; pub type nsIContent_FlattenedParentType = :: std :: os :: raw :: c_uint ; # [ repr ( C ) ] pub struct nsIContent_nsExtendedContentSlots__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; 
 /// Lazily allocated extended slots to avoid
    /// that may only be instantiated when a content object is accessed
    /// through the DOM. Rather than burn actual slots in the content
    /// objects for each of these instance variables, we put them off
    /// in a side structure that's only allocated when the content is
    /// accessed through the DOM. 
 # [ repr ( C ) ] pub struct nsIContent_nsExtendedContentSlots { pub vtable_ : * const nsIContent_nsExtendedContentSlots__bindgen_vtable , 
 /// The nearest enclosing content node with a binding that created us.
        /// @see nsIContent::GetBindingParent 
 pub mBindingParent : * mut root :: nsIContent , 
 /// @see nsIContent::GetXBLInsertionPoint 
 pub mXBLInsertionPoint : root :: nsCOMPtr , 
 /// @see nsIContent::GetContainingShadow 
 pub mContainingShadow : root :: RefPtr < root :: mozilla :: dom :: ShadowRoot > , 
 /// @see nsIContent::GetAssignedSlot 
 pub mAssignedSlot : root :: RefPtr < root :: mozilla :: dom :: HTMLSlotElement > , } # [ test ] fn bindgen_test_layout_nsIContent_nsExtendedContentSlots ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIContent_nsExtendedContentSlots > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( nsIContent_nsExtendedContentSlots ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIContent_nsExtendedContentSlots > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIContent_nsExtendedContentSlots ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIContent_nsExtendedContentSlots ) ) . mBindingParent as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsIContent_nsExtendedContentSlots ) , "::" , stringify ! ( mBindingParent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIContent_nsExtendedContentSlots ) ) . mXBLInsertionPoint as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsIContent_nsExtendedContentSlots ) , "::" , stringify ! ( mXBLInsertionPoint ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIContent_nsExtendedContentSlots ) ) . mContainingShadow as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsIContent_nsExtendedContentSlots ) , "::" , stringify ! ( mContainingShadow ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIContent_nsExtendedContentSlots ) ) . mAssignedSlot as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsIContent_nsExtendedContentSlots ) , "::" , stringify ! ( mAssignedSlot ) ) ) ; } # [ repr ( C ) ] pub struct nsIContent_nsContentSlots { pub _base : root :: nsINode_nsSlots , pub mExtendedSlots : root :: mozilla :: UniquePtr < root :: nsIContent_nsExtendedContentSlots > , } # [ test ] fn bindgen_test_layout_nsIContent_nsContentSlots ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIContent_nsContentSlots > ( ) , 80usize , concat ! ( "Size of: " , stringify ! ( nsIContent_nsContentSlots ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIContent_nsContentSlots > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIContent_nsContentSlots ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIContent_nsContentSlots ) ) . mExtendedSlots as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( nsIContent_nsContentSlots ) , "::" , stringify ! ( mExtendedSlots ) ) ) ; } pub const nsIContent_ETabFocusType_eTabFocus_textControlsMask : root :: nsIContent_ETabFocusType = 1 ; pub const nsIContent_ETabFocusType_eTabFocus_formElementsMask : root :: nsIContent_ETabFocusType = 2 ; pub const nsIContent_ETabFocusType_eTabFocus_linksMask : root :: nsIContent_ETabFocusType = 4 ; pub const nsIContent_ETabFocusType_eTabFocus_any : root :: nsIContent_ETabFocusType = 7 ; pub type nsIContent_ETabFocusType = :: std :: os :: raw :: c_uint ; extern "C" {
 # [ link_name = "\u{1}_ZN10nsIContent14sTabFocusModelE" ] 
 pub static mut  nsIContent_sTabFocusModel  :  i32 ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsIContent26sTabFocusModelAppliesToXULE" ] 
 pub static mut  nsIContent_sTabFocusModelAppliesToXUL  :  bool ;
} # [ test ] fn bindgen_test_layout_nsIContent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIContent > ( ) , 88usize , concat ! ( "Size of: " , stringify ! ( nsIContent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIContent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIContent ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsFrameManagerBase { pub mPresShell : * mut root :: nsIPresShell , pub mRootFrame : * mut root :: nsIFrame , pub mDisplayNoneMap : * mut root :: nsFrameManagerBase_UndisplayedMap , pub mDisplayContentsMap : * mut root :: nsFrameManagerBase_UndisplayedMap , pub mIsDestroyingFrames : bool , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsFrameManagerBase_UndisplayedMap { _unused : [ u8 ; 0 ] } # [ test ] fn bindgen_test_layout_nsFrameManagerBase ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsFrameManagerBase > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( nsFrameManagerBase ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsFrameManagerBase > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsFrameManagerBase ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFrameManagerBase ) ) . mPresShell as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsFrameManagerBase ) , "::" , stringify ! ( mPresShell ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFrameManagerBase ) ) . mRootFrame as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsFrameManagerBase ) , "::" , stringify ! ( mRootFrame ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFrameManagerBase ) ) . mDisplayNoneMap as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsFrameManagerBase ) , "::" , stringify ! ( mDisplayNoneMap ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFrameManagerBase ) ) . mDisplayContentsMap as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsFrameManagerBase ) , "::" , stringify ! ( mDisplayContentsMap ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFrameManagerBase ) ) . mIsDestroyingFrames as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsFrameManagerBase ) , "::" , stringify ! ( mIsDestroyingFrames ) ) ) ; } impl Clone for nsFrameManagerBase { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIWeakReference { pub _base : root :: nsISupports , pub mObject : * mut root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIWeakReference_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIWeakReference ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIWeakReference > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsIWeakReference ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIWeakReference > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIWeakReference ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIWeakReference ) ) . mObject as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsIWeakReference ) , "::" , stringify ! ( mObject ) ) ) ; } impl Clone for nsIWeakReference { fn clone ( & self ) -> Self { * self } } pub type nsWeakPtr = root :: nsCOMPtr ; 
 /// templated hashtable class maps keys to reference pointers.
    /// See nsBaseHashtable for complete declaration.
    /// @param KeyClass a wrapper-class for the hashtable key, see nsHashKeys.h
    /// for a complete specification.
    /// @param PtrType the reference-type being wrapped
    /// @see nsDataHashtable, nsClassHashtable 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsRefPtrHashtable { pub _address : u8 , } pub type nsRefPtrHashtable_KeyType = [ u8 ; 0usize ] ; pub type nsRefPtrHashtable_UserDataType < PtrType > = * mut PtrType ; pub type nsRefPtrHashtable_base_type = u8 ; 
 /// templated hashtable class maps keys to C++ object pointers.
    /// See nsBaseHashtable for complete declaration.
    /// @param KeyClass a wrapper-class for the hashtable key, see nsHashKeys.h
    /// for a complete specification.
    /// @param Class the class-type being wrapped
    /// @see nsInterfaceHashtable, nsClassHashtable 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsClassHashtable { pub _address : u8 , } pub type nsClassHashtable_KeyType = [ u8 ; 0usize ] ; pub type nsClassHashtable_UserDataType < T > = * mut T ; pub type nsClassHashtable_base_type = u8 ; # [ repr ( C ) ] pub struct nsPresArena { pub mFreeLists : [ root :: nsPresArena_FreeList ; 211usize ] , pub mPool : [ u64 ; 5usize ] , pub mArenaRefPtrs : [ u64 ; 4usize ] , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsPresArena_FreeList { pub mEntries : root :: nsTArray < * mut :: std :: os :: raw :: c_void > , pub mEntrySize : usize , pub mEntriesEverAllocated : usize , } # [ test ] fn bindgen_test_layout_nsPresArena_FreeList ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsPresArena_FreeList > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsPresArena_FreeList ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsPresArena_FreeList > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsPresArena_FreeList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresArena_FreeList ) ) . mEntries as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresArena_FreeList ) , "::" , stringify ! ( mEntries ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresArena_FreeList ) ) . mEntrySize as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresArena_FreeList ) , "::" , stringify ! ( mEntrySize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresArena_FreeList ) ) . mEntriesEverAllocated as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresArena_FreeList ) , "::" , stringify ! ( mEntriesEverAllocated ) ) ) ; } # [ test ] fn bindgen_test_layout_nsPresArena ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsPresArena > ( ) , 5136usize , concat ! ( "Size of: " , stringify ! ( nsPresArena ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsPresArena > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsPresArena ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresArena ) ) . mFreeLists as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresArena ) , "::" , stringify ! ( mFreeLists ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresArena ) ) . mPool as * const _ as usize } , 5064usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresArena ) , "::" , stringify ! ( mPool ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresArena ) ) . mArenaRefPtrs as * const _ as usize } , 5104usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresArena ) , "::" , stringify ! ( mArenaRefPtrs ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct imgINotificationObserver { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct imgINotificationObserver_COMTypeInfo { pub _address : u8 , } pub const imgINotificationObserver_SIZE_AVAILABLE : root :: imgINotificationObserver__bindgen_ty_1 = 1 ; pub const imgINotificationObserver_FRAME_UPDATE : root :: imgINotificationObserver__bindgen_ty_1 = 2 ; pub const imgINotificationObserver_FRAME_COMPLETE : root :: imgINotificationObserver__bindgen_ty_1 = 3 ; pub const imgINotificationObserver_LOAD_COMPLETE : root :: imgINotificationObserver__bindgen_ty_1 = 4 ; pub const imgINotificationObserver_DECODE_COMPLETE : root :: imgINotificationObserver__bindgen_ty_1 = 5 ; pub const imgINotificationObserver_DISCARD : root :: imgINotificationObserver__bindgen_ty_1 = 6 ; pub const imgINotificationObserver_UNLOCKED_DRAW : root :: imgINotificationObserver__bindgen_ty_1 = 7 ; pub const imgINotificationObserver_IS_ANIMATED : root :: imgINotificationObserver__bindgen_ty_1 = 8 ; pub const imgINotificationObserver_HAS_TRANSPARENCY : root :: imgINotificationObserver__bindgen_ty_1 = 9 ; pub type imgINotificationObserver__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_imgINotificationObserver ( ) { assert_eq ! ( :: std :: mem :: size_of :: < imgINotificationObserver > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( imgINotificationObserver ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < imgINotificationObserver > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( imgINotificationObserver ) ) ) ; } impl Clone for imgINotificationObserver { fn clone ( & self ) -> Self { * self } } 
 /// Mutation observer interface
    ///
    /// See nsINode::AddMutationObserver, nsINode::RemoveMutationObserver for how to
    /// attach or remove your observers.
    ///
    /// WARNING: During these notifications, you are not allowed to perform
    /// any mutations to the current or any other document, or start a
    /// network load.  If you need to perform such operations do that
    /// during the _last_ nsIDocumentObserver::EndUpdate notification.  The
    /// expection for this is ParentChainChanged, where mutations should be
    /// done from an async event, as the notification might not be
    /// surrounded by BeginUpdate/EndUpdate calls. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIMutationObserver { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIMutationObserver_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIMutationObserver ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIMutationObserver > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIMutationObserver ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIMutationObserver > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIMutationObserver ) ) ) ; } impl Clone for nsIMutationObserver { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIDocumentObserver { pub _base : root :: nsIMutationObserver , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIDocumentObserver_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIDocumentObserver ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIDocumentObserver > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIDocumentObserver ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIDocumentObserver > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIDocumentObserver ) ) ) ; } impl Clone for nsIDocumentObserver { fn clone ( & self ) -> Self { * self } } 
 /// There are two advantages to inheriting from nsStubDocumentObserver
    /// rather than directly from nsIDocumentObserver:
    /// 1. smaller compiled code size (since there's no need for the code
    /// for the empty virtual function implementations for every
    /// nsIDocumentObserver implementation)
    /// 2. the performance of document's loop over observers benefits from
    /// the fact that more of the functions called are the same (which
    /// can reduce instruction cache misses and perhaps improve branch
    /// prediction) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsStubDocumentObserver { pub _base : root :: nsIDocumentObserver , } # [ test ] fn bindgen_test_layout_nsStubDocumentObserver ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStubDocumentObserver > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsStubDocumentObserver ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStubDocumentObserver > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStubDocumentObserver ) ) ) ; } impl Clone for nsStubDocumentObserver { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsDocShell { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsViewManager { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsFrameSelection { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsCSSFrameConstructor { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct AutoWeakFrame { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct WeakFrame { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsRefreshDriver { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] pub struct CapturingContentInfo { pub mAllowed : bool , pub mPointerLock : bool , pub mRetargetToElement : bool , pub mPreventDrag : bool , pub mContent : root :: mozilla :: StaticRefPtr < root :: nsIContent > , } # [ test ] fn bindgen_test_layout_CapturingContentInfo ( ) { assert_eq ! ( :: std :: mem :: size_of :: < CapturingContentInfo > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( CapturingContentInfo ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < CapturingContentInfo > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( CapturingContentInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CapturingContentInfo ) ) . mAllowed as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( CapturingContentInfo ) , "::" , stringify ! ( mAllowed ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CapturingContentInfo ) ) . mPointerLock as * const _ as usize } , 1usize , concat ! ( "Alignment of field: " , stringify ! ( CapturingContentInfo ) , "::" , stringify ! ( mPointerLock ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CapturingContentInfo ) ) . mRetargetToElement as * const _ as usize } , 2usize , concat ! ( "Alignment of field: " , stringify ! ( CapturingContentInfo ) , "::" , stringify ! ( mRetargetToElement ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CapturingContentInfo ) ) . mPreventDrag as * const _ as usize } , 3usize , concat ! ( "Alignment of field: " , stringify ! ( CapturingContentInfo ) , "::" , stringify ! ( mPreventDrag ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CapturingContentInfo ) ) . mContent as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( CapturingContentInfo ) , "::" , stringify ! ( mContent ) ) ) ; } 
 /// Presentation shell interface. Presentation shells are the
    /// controlling point for managing the presentation of a document. The
    /// presentation shell holds a live reference to the document, the
    /// presentation context, the style manager, the style set and the root
    /// frame. <p>
    ///
    /// When this object is Release'd, it will release the document, the
    /// presentation context, the style manager, the style set and the root
    /// frame. 
 # [ repr ( C ) ] pub struct nsIPresShell { pub _base : root :: nsStubDocumentObserver , pub mDocument : root :: nsCOMPtr , pub mPresContext : root :: RefPtr < root :: nsPresContext > , pub mStyleSet : root :: mozilla :: StyleSetHandle , pub mFrameConstructor : * mut root :: nsCSSFrameConstructor , pub mViewManager : * mut root :: nsViewManager , pub mFrameArena : root :: nsPresArena , pub mSelection : root :: RefPtr < root :: nsFrameSelection > , pub mFrameManager : * mut root :: nsFrameManagerBase , pub mForwardingContainer : u64 , pub mDocAccessible : * mut root :: mozilla :: a11y :: DocAccessible , pub mReflowContinueTimer : root :: nsCOMPtr , pub mPaintCount : u64 , pub mScrollPositionClampingScrollPortSize : root :: nsSize , pub mAutoWeakFrames : * mut root :: AutoWeakFrame , pub mWeakFrames : [ u64 ; 4usize ] , pub mStyleCause : root :: UniqueProfilerBacktrace , pub mReflowCause : root :: UniqueProfilerBacktrace , pub mCanvasBackgroundColor : root :: nscolor , pub mResolution : [ u32 ; 2usize ] , pub mSelectionFlags : i16 , pub mChangeNestCount : u16 , pub mRenderFlags : root :: nsIPresShell_RenderFlags , pub _bitfield_1 : [ u8 ; 3usize ] , pub mPresShellId : u32 , pub mFontSizeInflationEmPerLine : u32 , pub mFontSizeInflationMinTwips : u32 , pub mFontSizeInflationLineThreshold : u32 , pub mFontSizeInflationForceEnabled : bool , pub mFontSizeInflationDisabledInMasterProcess : bool , pub mFontSizeInflationEnabled : bool , pub mFontSizeInflationEnabledIsDirty : bool , pub mPaintingIsFrozen : bool , pub mIsNeverPainting : bool , pub mInFlush : bool , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIPresShell_COMTypeInfo { pub _address : u8 , } pub type nsIPresShell_LayerManager = root :: mozilla :: layers :: LayerManager ; pub type nsIPresShell_SourceSurface = root :: mozilla :: gfx :: SourceSurface ; pub const nsIPresShell_eRenderFlag_STATE_IGNORING_VIEWPORT_SCROLLING : root :: nsIPresShell_eRenderFlag = 1 ; pub const nsIPresShell_eRenderFlag_STATE_DRAWWINDOW_NOT_FLUSHING : root :: nsIPresShell_eRenderFlag = 2 ; pub type nsIPresShell_eRenderFlag = :: std :: os :: raw :: c_uint ; pub type nsIPresShell_RenderFlags = u8 ; pub const nsIPresShell_ResizeReflowOptions_eBSizeExact : root :: nsIPresShell_ResizeReflowOptions = 0 ; pub const nsIPresShell_ResizeReflowOptions_eBSizeLimit : root :: nsIPresShell_ResizeReflowOptions = 1 ; pub type nsIPresShell_ResizeReflowOptions = u32 ; pub const nsIPresShell_ScrollDirection_eHorizontal : root :: nsIPresShell_ScrollDirection = 0 ; pub const nsIPresShell_ScrollDirection_eVertical : root :: nsIPresShell_ScrollDirection = 1 ; pub const nsIPresShell_ScrollDirection_eEither : root :: nsIPresShell_ScrollDirection = 2 ; pub type nsIPresShell_ScrollDirection = :: std :: os :: raw :: c_uint ; pub const nsIPresShell_IntrinsicDirty_eResize : root :: nsIPresShell_IntrinsicDirty = 0 ; pub const nsIPresShell_IntrinsicDirty_eTreeChange : root :: nsIPresShell_IntrinsicDirty = 1 ; pub const nsIPresShell_IntrinsicDirty_eStyleChange : root :: nsIPresShell_IntrinsicDirty = 2 ; pub type nsIPresShell_IntrinsicDirty = :: std :: os :: raw :: c_uint ; pub const nsIPresShell_ReflowRootHandling_ePositionOrSizeChange : root :: nsIPresShell_ReflowRootHandling = 0 ; pub const nsIPresShell_ReflowRootHandling_eNoPositionOrSizeChange : root :: nsIPresShell_ReflowRootHandling = 1 ; pub const nsIPresShell_ReflowRootHandling_eInferFromBitToAdd : root :: nsIPresShell_ReflowRootHandling = 2 ; pub type nsIPresShell_ReflowRootHandling = :: std :: os :: raw :: c_uint ; pub const nsIPresShell_SCROLL_TOP : root :: nsIPresShell__bindgen_ty_1 = 0 ; pub const nsIPresShell_SCROLL_BOTTOM : root :: nsIPresShell__bindgen_ty_1 = 100 ; pub const nsIPresShell_SCROLL_LEFT : root :: nsIPresShell__bindgen_ty_1 = 0 ; pub const nsIPresShell_SCROLL_RIGHT : root :: nsIPresShell__bindgen_ty_1 = 100 ; pub const nsIPresShell_SCROLL_CENTER : root :: nsIPresShell__bindgen_ty_1 = 50 ; pub const nsIPresShell_SCROLL_MINIMUM : root :: nsIPresShell__bindgen_ty_1 = -1 ; pub type nsIPresShell__bindgen_ty_1 = :: std :: os :: raw :: c_int ; pub const nsIPresShell_WhenToScroll_SCROLL_ALWAYS : root :: nsIPresShell_WhenToScroll = 0 ; pub const nsIPresShell_WhenToScroll_SCROLL_IF_NOT_VISIBLE : root :: nsIPresShell_WhenToScroll = 1 ; pub const nsIPresShell_WhenToScroll_SCROLL_IF_NOT_FULLY_VISIBLE : root :: nsIPresShell_WhenToScroll = 2 ; pub type nsIPresShell_WhenToScroll = :: std :: os :: raw :: c_uint ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIPresShell_ScrollAxis { pub _bindgen_opaque_blob : u32 , } # [ test ] fn bindgen_test_layout_nsIPresShell_ScrollAxis ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIPresShell_ScrollAxis > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( nsIPresShell_ScrollAxis ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIPresShell_ScrollAxis > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( nsIPresShell_ScrollAxis ) ) ) ; } impl Clone for nsIPresShell_ScrollAxis { fn clone ( & self ) -> Self { * self } } pub const nsIPresShell_SCROLL_FIRST_ANCESTOR_ONLY : root :: nsIPresShell__bindgen_ty_2 = 1 ; pub const nsIPresShell_SCROLL_OVERFLOW_HIDDEN : root :: nsIPresShell__bindgen_ty_2 = 2 ; pub const nsIPresShell_SCROLL_NO_PARENT_FRAMES : root :: nsIPresShell__bindgen_ty_2 = 4 ; pub const nsIPresShell_SCROLL_SMOOTH : root :: nsIPresShell__bindgen_ty_2 = 8 ; pub const nsIPresShell_SCROLL_SMOOTH_AUTO : root :: nsIPresShell__bindgen_ty_2 = 16 ; pub type nsIPresShell__bindgen_ty_2 = :: std :: os :: raw :: c_uint ; pub const nsIPresShell_RENDER_IS_UNTRUSTED : root :: nsIPresShell__bindgen_ty_3 = 1 ; pub const nsIPresShell_RENDER_IGNORE_VIEWPORT_SCROLLING : root :: nsIPresShell__bindgen_ty_3 = 2 ; pub const nsIPresShell_RENDER_CARET : root :: nsIPresShell__bindgen_ty_3 = 4 ; pub const nsIPresShell_RENDER_USE_WIDGET_LAYERS : root :: nsIPresShell__bindgen_ty_3 = 8 ; pub const nsIPresShell_RENDER_ASYNC_DECODE_IMAGES : root :: nsIPresShell__bindgen_ty_3 = 16 ; pub const nsIPresShell_RENDER_DOCUMENT_RELATIVE : root :: nsIPresShell__bindgen_ty_3 = 32 ; pub const nsIPresShell_RENDER_DRAWWINDOW_NOT_FLUSHING : root :: nsIPresShell__bindgen_ty_3 = 64 ; pub type nsIPresShell__bindgen_ty_3 = :: std :: os :: raw :: c_uint ; pub const nsIPresShell_RENDER_IS_IMAGE : root :: nsIPresShell__bindgen_ty_4 = 256 ; pub const nsIPresShell_RENDER_AUTO_SCALE : root :: nsIPresShell__bindgen_ty_4 = 128 ; pub type nsIPresShell__bindgen_ty_4 = :: std :: os :: raw :: c_uint ; pub const nsIPresShell_FORCE_DRAW : root :: nsIPresShell__bindgen_ty_5 = 1 ; pub const nsIPresShell_ADD_FOR_SUBDOC : root :: nsIPresShell__bindgen_ty_5 = 2 ; pub const nsIPresShell_APPEND_UNSCROLLED_ONLY : root :: nsIPresShell__bindgen_ty_5 = 4 ; pub type nsIPresShell__bindgen_ty_5 = :: std :: os :: raw :: c_uint ; pub const nsIPresShell_PaintFlags_PAINT_LAYERS : root :: nsIPresShell_PaintFlags = 1 ; pub const nsIPresShell_PaintFlags_PAINT_COMPOSITE : root :: nsIPresShell_PaintFlags = 2 ; pub const nsIPresShell_PaintFlags_PAINT_SYNC_DECODE_IMAGES : root :: nsIPresShell_PaintFlags = 4 ; pub type nsIPresShell_PaintFlags = :: std :: os :: raw :: c_uint ; pub const nsIPresShell_PaintType_PAINT_DEFAULT : root :: nsIPresShell_PaintType = 0 ; pub const nsIPresShell_PaintType_PAINT_DELAYED_COMPRESS : root :: nsIPresShell_PaintType = 1 ; pub type nsIPresShell_PaintType = :: std :: os :: raw :: c_uint ; extern "C" {
 # [ link_name = "\u{1}_ZN12nsIPresShell12gCaptureInfoE" ] 
 pub static mut  nsIPresShell_gCaptureInfo  :  root :: CapturingContentInfo ;
} extern "C" {
 # [ link_name = "\u{1}_ZN12nsIPresShell14gKeyDownTargetE" ] 
 pub static mut  nsIPresShell_gKeyDownTarget  :  * mut root :: nsIContent ;
} # [ test ] fn bindgen_test_layout_nsIPresShell ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIPresShell > ( ) , 5344usize , concat ! ( "Size of: " , stringify ! ( nsIPresShell ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIPresShell > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIPresShell ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mDocument as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mDocument ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mPresContext as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mPresContext ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mStyleSet as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mStyleSet ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mFrameConstructor as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mFrameConstructor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mViewManager as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mViewManager ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mFrameArena as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mFrameArena ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mSelection as * const _ as usize } , 5184usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mSelection ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mFrameManager as * const _ as usize } , 5192usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mFrameManager ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mForwardingContainer as * const _ as usize } , 5200usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mForwardingContainer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mDocAccessible as * const _ as usize } , 5208usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mDocAccessible ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mReflowContinueTimer as * const _ as usize } , 5216usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mReflowContinueTimer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mPaintCount as * const _ as usize } , 5224usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mPaintCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mScrollPositionClampingScrollPortSize as * const _ as usize } , 5232usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mScrollPositionClampingScrollPortSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mAutoWeakFrames as * const _ as usize } , 5240usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mAutoWeakFrames ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mWeakFrames as * const _ as usize } , 5248usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mWeakFrames ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mStyleCause as * const _ as usize } , 5280usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mStyleCause ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mReflowCause as * const _ as usize } , 5288usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mReflowCause ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mCanvasBackgroundColor as * const _ as usize } , 5296usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mCanvasBackgroundColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mResolution as * const _ as usize } , 5300usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mResolution ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mSelectionFlags as * const _ as usize } , 5308usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mSelectionFlags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mChangeNestCount as * const _ as usize } , 5310usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mChangeNestCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mRenderFlags as * const _ as usize } , 5312usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mRenderFlags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mPresShellId as * const _ as usize } , 5316usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mPresShellId ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mFontSizeInflationEmPerLine as * const _ as usize } , 5320usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mFontSizeInflationEmPerLine ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mFontSizeInflationMinTwips as * const _ as usize } , 5324usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mFontSizeInflationMinTwips ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mFontSizeInflationLineThreshold as * const _ as usize } , 5328usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mFontSizeInflationLineThreshold ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mFontSizeInflationForceEnabled as * const _ as usize } , 5332usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mFontSizeInflationForceEnabled ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mFontSizeInflationDisabledInMasterProcess as * const _ as usize } , 5333usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mFontSizeInflationDisabledInMasterProcess ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mFontSizeInflationEnabled as * const _ as usize } , 5334usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mFontSizeInflationEnabled ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mFontSizeInflationEnabledIsDirty as * const _ as usize } , 5335usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mFontSizeInflationEnabledIsDirty ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mPaintingIsFrozen as * const _ as usize } , 5336usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mPaintingIsFrozen ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mIsNeverPainting as * const _ as usize } , 5337usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mIsNeverPainting ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIPresShell ) ) . mInFlush as * const _ as usize } , 5338usize , concat ! ( "Alignment of field: " , stringify ! ( nsIPresShell ) , "::" , stringify ! ( mInFlush ) ) ) ; } impl nsIPresShell { # [ inline ] pub fn mDidInitialize ( & self ) -> bool { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x1 as u32 ; let val = ( unit_field_val & mask ) >> 0usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mDidInitialize ( & mut self , val : bool ) { let mask = 0x1 as u32 ; let val = val as u8 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 0usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn mIsDestroying ( & self ) -> bool { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x2 as u32 ; let val = ( unit_field_val & mask ) >> 1usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIsDestroying ( & mut self , val : bool ) { let mask = 0x2 as u32 ; let val = val as u8 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 1usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn mIsReflowing ( & self ) -> bool { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x4 as u32 ; let val = ( unit_field_val & mask ) >> 2usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIsReflowing ( & mut self , val : bool ) { let mask = 0x4 as u32 ; let val = val as u8 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 2usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn mIsObservingDocument ( & self ) -> bool { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x8 as u32 ; let val = ( unit_field_val & mask ) >> 3usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIsObservingDocument ( & mut self , val : bool ) { let mask = 0x8 as u32 ; let val = val as u8 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 3usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn mIsDocumentGone ( & self ) -> bool { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x10 as u32 ; let val = ( unit_field_val & mask ) >> 4usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIsDocumentGone ( & mut self , val : bool ) { let mask = 0x10 as u32 ; let val = val as u8 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 4usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn mPaintingSuppressed ( & self ) -> bool { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x20 as u32 ; let val = ( unit_field_val & mask ) >> 5usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mPaintingSuppressed ( & mut self , val : bool ) { let mask = 0x20 as u32 ; let val = val as u8 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 5usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn mIsActive ( & self ) -> bool { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x40 as u32 ; let val = ( unit_field_val & mask ) >> 6usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIsActive ( & mut self , val : bool ) { let mask = 0x40 as u32 ; let val = val as u8 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 6usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn mFrozen ( & self ) -> bool { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x80 as u32 ; let val = ( unit_field_val & mask ) >> 7usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mFrozen ( & mut self , val : bool ) { let mask = 0x80 as u32 ; let val = val as u8 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 7usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn mIsFirstPaint ( & self ) -> bool { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x100 as u32 ; let val = ( unit_field_val & mask ) >> 8usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIsFirstPaint ( & mut self , val : bool ) { let mask = 0x100 as u32 ; let val = val as u8 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 8usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn mObservesMutationsForPrint ( & self ) -> bool { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x200 as u32 ; let val = ( unit_field_val & mask ) >> 9usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mObservesMutationsForPrint ( & mut self , val : bool ) { let mask = 0x200 as u32 ; let val = val as u8 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 9usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn mWasLastReflowInterrupted ( & self ) -> bool { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x400 as u32 ; let val = ( unit_field_val & mask ) >> 10usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mWasLastReflowInterrupted ( & mut self , val : bool ) { let mask = 0x400 as u32 ; let val = val as u8 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 10usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn mScrollPositionClampingScrollPortSizeSet ( & self ) -> bool { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x800 as u32 ; let val = ( unit_field_val & mask ) >> 11usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mScrollPositionClampingScrollPortSizeSet ( & mut self , val : bool ) { let mask = 0x800 as u32 ; let val = val as u8 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 11usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn mNeedLayoutFlush ( & self ) -> bool { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x1000 as u32 ; let val = ( unit_field_val & mask ) >> 12usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mNeedLayoutFlush ( & mut self , val : bool ) { let mask = 0x1000 as u32 ; let val = val as u8 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 12usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn mNeedStyleFlush ( & self ) -> bool { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x2000 as u32 ; let val = ( unit_field_val & mask ) >> 13usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mNeedStyleFlush ( & mut self , val : bool ) { let mask = 0x2000 as u32 ; let val = val as u8 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 13usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn mObservingStyleFlushes ( & self ) -> bool { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x4000 as u32 ; let val = ( unit_field_val & mask ) >> 14usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mObservingStyleFlushes ( & mut self , val : bool ) { let mask = 0x4000 as u32 ; let val = val as u8 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 14usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn mObservingLayoutFlushes ( & self ) -> bool { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x8000 as u32 ; let val = ( unit_field_val & mask ) >> 15usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mObservingLayoutFlushes ( & mut self , val : bool ) { let mask = 0x8000 as u32 ; let val = val as u8 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 15usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn mNeedThrottledAnimationFlush ( & self ) -> bool { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x10000 as u32 ; let val = ( unit_field_val & mask ) >> 16usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mNeedThrottledAnimationFlush ( & mut self , val : bool ) { let mask = 0x10000 as u32 ; let val = val as u8 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 16usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn new_bitfield_1 ( mDidInitialize : bool , mIsDestroying : bool , mIsReflowing : bool , mIsObservingDocument : bool , mIsDocumentGone : bool , mPaintingSuppressed : bool , mIsActive : bool , mFrozen : bool , mIsFirstPaint : bool , mObservesMutationsForPrint : bool , mWasLastReflowInterrupted : bool , mScrollPositionClampingScrollPortSizeSet : bool , mNeedLayoutFlush : bool , mNeedStyleFlush : bool , mObservingStyleFlushes : bool , mObservingLayoutFlushes : bool , mNeedThrottledAnimationFlush : bool ) -> u32 { ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( 0 | ( ( mDidInitialize as u8 as u32 ) << 0usize ) & ( 0x1 as u32 ) ) | ( ( mIsDestroying as u8 as u32 ) << 1usize ) & ( 0x2 as u32 ) ) | ( ( mIsReflowing as u8 as u32 ) << 2usize ) & ( 0x4 as u32 ) ) | ( ( mIsObservingDocument as u8 as u32 ) << 3usize ) & ( 0x8 as u32 ) ) | ( ( mIsDocumentGone as u8 as u32 ) << 4usize ) & ( 0x10 as u32 ) ) | ( ( mPaintingSuppressed as u8 as u32 ) << 5usize ) & ( 0x20 as u32 ) ) | ( ( mIsActive as u8 as u32 ) << 6usize ) & ( 0x40 as u32 ) ) | ( ( mFrozen as u8 as u32 ) << 7usize ) & ( 0x80 as u32 ) ) | ( ( mIsFirstPaint as u8 as u32 ) << 8usize ) & ( 0x100 as u32 ) ) | ( ( mObservesMutationsForPrint as u8 as u32 ) << 9usize ) & ( 0x200 as u32 ) ) | ( ( mWasLastReflowInterrupted as u8 as u32 ) << 10usize ) & ( 0x400 as u32 ) ) | ( ( mScrollPositionClampingScrollPortSizeSet as u8 as u32 ) << 11usize ) & ( 0x800 as u32 ) ) | ( ( mNeedLayoutFlush as u8 as u32 ) << 12usize ) & ( 0x1000 as u32 ) ) | ( ( mNeedStyleFlush as u8 as u32 ) << 13usize ) & ( 0x2000 as u32 ) ) | ( ( mObservingStyleFlushes as u8 as u32 ) << 14usize ) & ( 0x4000 as u32 ) ) | ( ( mObservingLayoutFlushes as u8 as u32 ) << 15usize ) & ( 0x8000 as u32 ) ) | ( ( mNeedThrottledAnimationFlush as u8 as u32 ) << 16usize ) & ( 0x10000 as u32 ) ) } } 
 /// The signature of the timer callback function passed to initWithFuncCallback.
    /// This is the function that will get called when the timer expires if the
    /// timer is initialized via initWithFuncCallback.
    ///
    /// @param aTimer the timer which has expired
    /// @param aClosure opaque parameter passed to initWithFuncCallback 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsITimer { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsITimer_COMTypeInfo { pub _address : u8 , } pub const nsITimer_TYPE_ONE_SHOT : root :: nsITimer__bindgen_ty_1 = 0 ; pub const nsITimer_TYPE_REPEATING_SLACK : root :: nsITimer__bindgen_ty_1 = 1 ; pub const nsITimer_TYPE_REPEATING_PRECISE : root :: nsITimer__bindgen_ty_1 = 2 ; pub const nsITimer_TYPE_REPEATING_PRECISE_CAN_SKIP : root :: nsITimer__bindgen_ty_1 = 3 ; pub const nsITimer_TYPE_REPEATING_SLACK_LOW_PRIORITY : root :: nsITimer__bindgen_ty_1 = 4 ; pub const nsITimer_TYPE_ONE_SHOT_LOW_PRIORITY : root :: nsITimer__bindgen_ty_1 = 5 ; pub type nsITimer__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_nsITimer ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsITimer > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsITimer ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsITimer > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsITimer ) ) ) ; } impl Clone for nsITimer { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsLanguageAtomService { pub mLangToGroup : [ u64 ; 4usize ] , pub mLocaleLanguage : root :: RefPtr < root :: nsAtom > , } pub type nsLanguageAtomService_Encoding = root :: mozilla :: Encoding ; pub type nsLanguageAtomService_NotNull < T > = root :: mozilla :: NotNull < T > ; # [ test ] fn bindgen_test_layout_nsLanguageAtomService ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsLanguageAtomService > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( nsLanguageAtomService ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsLanguageAtomService > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsLanguageAtomService ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsLanguageAtomService ) ) . mLangToGroup as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsLanguageAtomService ) , "::" , stringify ! ( mLangToGroup ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsLanguageAtomService ) ) . mLocaleLanguage as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsLanguageAtomService ) , "::" , stringify ! ( mLocaleLanguage ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsINamed { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsINamed_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsINamed ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsINamed > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsINamed ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsINamed > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsINamed ) ) ) ; } impl Clone for nsINamed { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIRunnable { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIRunnable_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIRunnable ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIRunnable > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIRunnable ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIRunnable > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIRunnable ) ) ) ; } impl Clone for nsIRunnable { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIEventTarget { pub _base : root :: nsISupports , pub mVirtualThread : * mut root :: PRThread , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIEventTarget_COMTypeInfo { pub _address : u8 , } pub const nsIEventTarget_DISPATCH_NORMAL : root :: nsIEventTarget__bindgen_ty_1 = 0 ; pub const nsIEventTarget_DISPATCH_SYNC : root :: nsIEventTarget__bindgen_ty_1 = 1 ; pub const nsIEventTarget_DISPATCH_AT_END : root :: nsIEventTarget__bindgen_ty_1 = 2 ; pub type nsIEventTarget__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_nsIEventTarget ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIEventTarget > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsIEventTarget ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIEventTarget > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIEventTarget ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIEventTarget ) ) . mVirtualThread as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsIEventTarget ) , "::" , stringify ! ( mVirtualThread ) ) ) ; } impl Clone for nsIEventTarget { fn clone ( & self ) -> Self { * self } } pub type nsRunnableMethod_BaseType = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsRunnableMethod_ReturnTypeEnforcer { pub _address : u8 , } pub type nsRunnableMethod_ReturnTypeEnforcer_ReturnTypeIsSafe = :: std :: os :: raw :: c_int ; pub type nsRunnableMethod_check = root :: nsRunnableMethod_ReturnTypeEnforcer ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsIGlobalObject { pub _base : root :: nsISupports , pub _base_1 : root :: mozilla :: dom :: DispatcherTrait , pub mHostObjectURIs : root :: nsTArray < root :: nsCString > , pub mIsDying : bool , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIGlobalObject_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIGlobalObject ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIGlobalObject > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( nsIGlobalObject ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIGlobalObject > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIGlobalObject ) ) ) ; } 
 /// The global object which keeps a script context for each supported script
    /// language. This often used to store per-window global state.
    /// This is a heavyweight interface implemented only by DOM globals, and
    /// it might go away some time in the future. 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsIScriptGlobalObject { pub _base : root :: nsIGlobalObject , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIScriptGlobalObject_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIScriptGlobalObject ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIScriptGlobalObject > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( nsIScriptGlobalObject ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIScriptGlobalObject > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIScriptGlobalObject ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIObserver { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIObserver_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIObserver ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIObserver > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIObserver ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIObserver > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIObserver ) ) ) ; } impl Clone for nsIObserver { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIXPConnectJSObjectHolder { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIXPConnectJSObjectHolder_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIXPConnectJSObjectHolder ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIXPConnectJSObjectHolder > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIXPConnectJSObjectHolder ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIXPConnectJSObjectHolder > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIXPConnectJSObjectHolder ) ) ) ; } impl Clone for nsIXPConnectJSObjectHolder { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIXPConnectWrappedJS { pub _base : root :: nsIXPConnectJSObjectHolder , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIXPConnectWrappedJS_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIXPConnectWrappedJS ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIXPConnectWrappedJS > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIXPConnectWrappedJS ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIXPConnectWrappedJS > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIXPConnectWrappedJS ) ) ) ; } impl Clone for nsIXPConnectWrappedJS { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIXPConnect { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIXPConnect_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIXPConnect ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIXPConnect > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIXPConnect ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIXPConnect > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIXPConnect ) ) ) ; } impl Clone for nsIXPConnect { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIURI { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIURI_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIURI ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIURI > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIURI ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIURI > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIURI ) ) ) ; } impl Clone for nsIURI { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIControllers { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct mozIDOMWindow { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mozIDOMWindow_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_mozIDOMWindow ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mozIDOMWindow > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( mozIDOMWindow ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mozIDOMWindow > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( mozIDOMWindow ) ) ) ; } impl Clone for mozIDOMWindow { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct mozIDOMWindowProxy { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mozIDOMWindowProxy_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_mozIDOMWindowProxy ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mozIDOMWindowProxy > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( mozIDOMWindowProxy ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mozIDOMWindowProxy > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( mozIDOMWindowProxy ) ) ) ; } impl Clone for mozIDOMWindowProxy { fn clone ( & self ) -> Self { * self } } pub type SuspendTypes = u32 ; pub const PopupControlState_openAllowed : root :: PopupControlState = 0 ; pub const PopupControlState_openControlled : root :: PopupControlState = 1 ; pub const PopupControlState_openBlocked : root :: PopupControlState = 2 ; pub const PopupControlState_openAbused : root :: PopupControlState = 3 ; pub const PopupControlState_openOverridden : root :: PopupControlState = 4 ; pub type PopupControlState = :: std :: os :: raw :: c_uint ; # [ repr ( C ) ] pub struct nsPIDOMWindowInner { pub _base : root :: mozIDOMWindow , pub mChromeEventHandler : root :: nsCOMPtr , pub mDoc : root :: nsCOMPtr , pub mDocumentURI : root :: nsCOMPtr , pub mDocBaseURI : root :: nsCOMPtr , pub mParentTarget : root :: nsCOMPtr , pub mPerformance : root :: RefPtr < root :: mozilla :: dom :: Performance > , pub mTimeoutManager : root :: mozilla :: UniquePtr < root :: mozilla :: dom :: TimeoutManager > , pub mServiceWorkerRegistrationTable : root :: nsPIDOMWindowInner_ServiceWorkerRegistrationTable , pub mMutationBits : u32 , pub mActivePeerConnections : u32 , pub mIsDocumentLoaded : bool , pub mIsHandlingResizeEvent : bool , pub mMayHavePaintEventListener : bool , pub mMayHaveTouchEventListener : bool , pub mMayHaveSelectionChangeEventListener : bool , pub mMayHaveMouseEnterLeaveEventListener : bool , pub mMayHavePointerEnterLeaveEventListener : bool , pub mInnerObjectsFreed : bool , pub mAudioCaptured : bool , pub mOuterWindow : root :: nsCOMPtr , pub mFocusedNode : root :: nsCOMPtr , pub mAudioContexts : root :: nsTArray < * mut root :: mozilla :: dom :: AudioContext > , pub mTabGroup : root :: RefPtr < root :: mozilla :: dom :: TabGroup > , pub mWindowID : u64 , pub mHasNotifiedGlobalCreated : bool , pub mMarkedCCGeneration : u32 , pub mTopInnerWindow : root :: nsCOMPtr , pub mHasTriedToCacheTopInnerWindow : bool , pub mNumOfIndexedDBDatabases : u32 , pub mNumOfOpenWebSockets : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsPIDOMWindowInner_COMTypeInfo { pub _address : u8 , } pub type nsPIDOMWindowInner_ServiceWorkerRegistrationTable = [ u64 ; 4usize ] ; # [ test ] fn bindgen_test_layout_nsPIDOMWindowInner ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsPIDOMWindowInner > ( ) , 192usize , concat ! ( "Size of: " , stringify ! ( nsPIDOMWindowInner ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsPIDOMWindowInner > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsPIDOMWindowInner ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mChromeEventHandler as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mChromeEventHandler ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mDoc as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mDoc ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mDocumentURI as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mDocumentURI ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mDocBaseURI as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mDocBaseURI ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mParentTarget as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mParentTarget ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mPerformance as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mPerformance ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mTimeoutManager as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mTimeoutManager ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mServiceWorkerRegistrationTable as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mServiceWorkerRegistrationTable ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mMutationBits as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mMutationBits ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mActivePeerConnections as * const _ as usize } , 100usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mActivePeerConnections ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mIsDocumentLoaded as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mIsDocumentLoaded ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mIsHandlingResizeEvent as * const _ as usize } , 105usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mIsHandlingResizeEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mMayHavePaintEventListener as * const _ as usize } , 106usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mMayHavePaintEventListener ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mMayHaveTouchEventListener as * const _ as usize } , 107usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mMayHaveTouchEventListener ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mMayHaveSelectionChangeEventListener as * const _ as usize } , 108usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mMayHaveSelectionChangeEventListener ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mMayHaveMouseEnterLeaveEventListener as * const _ as usize } , 109usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mMayHaveMouseEnterLeaveEventListener ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mMayHavePointerEnterLeaveEventListener as * const _ as usize } , 110usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mMayHavePointerEnterLeaveEventListener ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mInnerObjectsFreed as * const _ as usize } , 111usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mInnerObjectsFreed ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mAudioCaptured as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mAudioCaptured ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mOuterWindow as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mOuterWindow ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mFocusedNode as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mFocusedNode ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mAudioContexts as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mAudioContexts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mTabGroup as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mTabGroup ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mWindowID as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mWindowID ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mHasNotifiedGlobalCreated as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mHasNotifiedGlobalCreated ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mMarkedCCGeneration as * const _ as usize } , 164usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mMarkedCCGeneration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mTopInnerWindow as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mTopInnerWindow ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mHasTriedToCacheTopInnerWindow as * const _ as usize } , 176usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mHasTriedToCacheTopInnerWindow ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mNumOfIndexedDBDatabases as * const _ as usize } , 180usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mNumOfIndexedDBDatabases ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowInner ) ) . mNumOfOpenWebSockets as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowInner ) , "::" , stringify ! ( mNumOfOpenWebSockets ) ) ) ; } # [ repr ( C ) ] pub struct nsPIDOMWindowOuter { pub _base : root :: mozIDOMWindowProxy , pub mChromeEventHandler : root :: nsCOMPtr , pub mDoc : root :: nsCOMPtr , pub mDocumentURI : root :: nsCOMPtr , pub mDocBaseURI : root :: nsCOMPtr , pub mParentTarget : root :: nsCOMPtr , pub mFrameElement : root :: nsCOMPtr , pub mDocShell : root :: nsCOMPtr , pub mModalStateDepth : u32 , pub mIsActive : bool , pub mIsBackground : bool , 
 /// The suspended types can be "disposable" or "permanent". This varable only
        /// stores the value about permanent suspend.
        /// - disposable
        /// To pause all playing media in that window, but doesn't affect the media
        /// which starts after that.
        ///
        /// - permanent
        /// To pause all media in that window, and also affect the media which starts
        /// after that. 
 pub mMediaSuspend : root :: SuspendTypes , pub mAudioMuted : bool , pub mAudioVolume : f32 , pub mDesktopModeViewport : bool , pub mIsRootOuterWindow : bool , pub mInnerWindow : * mut root :: nsPIDOMWindowInner , pub mTabGroup : root :: RefPtr < root :: mozilla :: dom :: TabGroup > , pub mWindowID : u64 , pub mMarkedCCGeneration : u32 , pub mServiceWorkersTestingEnabled : bool , pub mLargeAllocStatus : root :: mozilla :: dom :: LargeAllocStatus , pub mOpenerForInitialContentBrowser : root :: nsCOMPtr , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsPIDOMWindowOuter_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsPIDOMWindowOuter ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsPIDOMWindowOuter > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( nsPIDOMWindowOuter ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsPIDOMWindowOuter > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsPIDOMWindowOuter ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowOuter ) ) . mChromeEventHandler as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowOuter ) , "::" , stringify ! ( mChromeEventHandler ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowOuter ) ) . mDoc as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowOuter ) , "::" , stringify ! ( mDoc ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowOuter ) ) . mDocumentURI as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowOuter ) , "::" , stringify ! ( mDocumentURI ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowOuter ) ) . mDocBaseURI as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowOuter ) , "::" , stringify ! ( mDocBaseURI ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowOuter ) ) . mParentTarget as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowOuter ) , "::" , stringify ! ( mParentTarget ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowOuter ) ) . mFrameElement as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowOuter ) , "::" , stringify ! ( mFrameElement ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowOuter ) ) . mDocShell as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowOuter ) , "::" , stringify ! ( mDocShell ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowOuter ) ) . mModalStateDepth as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowOuter ) , "::" , stringify ! ( mModalStateDepth ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowOuter ) ) . mIsActive as * const _ as usize } , 68usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowOuter ) , "::" , stringify ! ( mIsActive ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowOuter ) ) . mIsBackground as * const _ as usize } , 69usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowOuter ) , "::" , stringify ! ( mIsBackground ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowOuter ) ) . mMediaSuspend as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowOuter ) , "::" , stringify ! ( mMediaSuspend ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowOuter ) ) . mAudioMuted as * const _ as usize } , 76usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowOuter ) , "::" , stringify ! ( mAudioMuted ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowOuter ) ) . mAudioVolume as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowOuter ) , "::" , stringify ! ( mAudioVolume ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowOuter ) ) . mDesktopModeViewport as * const _ as usize } , 84usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowOuter ) , "::" , stringify ! ( mDesktopModeViewport ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowOuter ) ) . mIsRootOuterWindow as * const _ as usize } , 85usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowOuter ) , "::" , stringify ! ( mIsRootOuterWindow ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowOuter ) ) . mInnerWindow as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowOuter ) , "::" , stringify ! ( mInnerWindow ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowOuter ) ) . mTabGroup as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowOuter ) , "::" , stringify ! ( mTabGroup ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowOuter ) ) . mWindowID as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowOuter ) , "::" , stringify ! ( mWindowID ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowOuter ) ) . mMarkedCCGeneration as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowOuter ) , "::" , stringify ! ( mMarkedCCGeneration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowOuter ) ) . mServiceWorkersTestingEnabled as * const _ as usize } , 116usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowOuter ) , "::" , stringify ! ( mServiceWorkersTestingEnabled ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowOuter ) ) . mLargeAllocStatus as * const _ as usize } , 117usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowOuter ) , "::" , stringify ! ( mLargeAllocStatus ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPIDOMWindowOuter ) ) . mOpenerForInitialContentBrowser as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( nsPIDOMWindowOuter ) , "::" , stringify ! ( mOpenerForInitialContentBrowser ) ) ) ; } pub mod xpc { # [ allow ( unused_imports ) ] use self :: super :: super :: root ; } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsCompatibility { eCompatibility_FullStandards = 1 , eCompatibility_AlmostStandards = 2 , eCompatibility_NavQuirks = 3 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsILoadGroup { pub _base : root :: nsIRequest , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsILoadGroup_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsILoadGroup ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsILoadGroup > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsILoadGroup ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsILoadGroup > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsILoadGroup ) ) ) ; } impl Clone for nsILoadGroup { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIRequestObserver { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIRequestObserver_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIRequestObserver ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIRequestObserver > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIRequestObserver ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIRequestObserver > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIRequestObserver ) ) ) ; } impl Clone for nsIRequestObserver { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIStreamListener { pub _base : root :: nsIRequestObserver , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIStreamListener_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIStreamListener ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIStreamListener > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIStreamListener ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIStreamListener > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIStreamListener ) ) ) ; } impl Clone for nsIStreamListener { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsParserBase { pub _base : root :: nsISupports , } # [ test ] fn bindgen_test_layout_nsParserBase ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsParserBase > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsParserBase ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsParserBase > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsParserBase ) ) ) ; } impl Clone for nsParserBase { fn clone ( & self ) -> Self { * self } } 
 /// This GECKO-INTERNAL interface is on track to being REMOVED (or refactored
    /// to the point of being near-unrecognizable).
    ///
    /// Please DO NOT #include this file in comm-central code, in your XULRunner
    /// app or binary extensions.
    ///
    /// Please DO NOT #include this into new files even inside Gecko. It is more
    /// likely than not that #including this header is the wrong thing to do. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIParser { pub _base : root :: nsParserBase , } pub type nsIParser_Encoding = root :: mozilla :: Encoding ; pub type nsIParser_NotNull < T > = root :: mozilla :: NotNull < T > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIParser_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIParser ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIParser > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIParser ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIParser > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIParser ) ) ) ; } impl Clone for nsIParser { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIUUIDGenerator { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIUUIDGenerator_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIUUIDGenerator ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIUUIDGenerator > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIUUIDGenerator ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIUUIDGenerator > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIUUIDGenerator ) ) ) ; } impl Clone for nsIUUIDGenerator { fn clone ( & self ) -> Self { * self } } 
 /// Hashtable key class to use with nsTHashtable/nsBaseHashtable 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsURIHashKey { pub _base : root :: PLDHashEntryHdr , pub mKey : root :: nsCOMPtr , } pub type nsURIHashKey_KeyType = * mut root :: nsIURI ; pub type nsURIHashKey_KeyTypePointer = * const root :: nsIURI ; pub const nsURIHashKey_ALLOW_MEMMOVE : root :: nsURIHashKey__bindgen_ty_1 = 1 ; pub type nsURIHashKey__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_nsURIHashKey ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsURIHashKey > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsURIHashKey ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsURIHashKey > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsURIHashKey ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsURIHashKey ) ) . mKey as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsURIHashKey ) , "::" , stringify ! ( mKey ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsContentList { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIIOService { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIStringBundleService { _unused : [ u8 ; 0 ] } 
 /// Data used to track the expiration state of an object. We promise that this
    /// is 32 bits so that objects that includes this as a field can pad and align
    /// efficiently. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsExpirationState { pub _bitfield_1 : u32 , pub __bindgen_align : [ u32 ; 0usize ] , } pub const nsExpirationState_NOT_TRACKED : root :: nsExpirationState__bindgen_ty_1 = 15 ; pub const nsExpirationState_MAX_INDEX_IN_GENERATION : root :: nsExpirationState__bindgen_ty_1 = 268435455 ; pub type nsExpirationState__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_nsExpirationState ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsExpirationState > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( nsExpirationState ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsExpirationState > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( nsExpirationState ) ) ) ; } impl Clone for nsExpirationState { fn clone ( & self ) -> Self { * self } } impl nsExpirationState { # [ inline ] pub fn mGeneration ( & self ) -> u32 { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0xf as u32 ; let val = ( unit_field_val & mask ) >> 0usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mGeneration ( & mut self , val : u32 ) { let mask = 0xf as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 0usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn mIndexInGeneration ( & self ) -> u32 { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0xfffffff0 as u32 ; let val = ( unit_field_val & mask ) >> 4usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mIndexInGeneration ( & mut self , val : u32 ) { let mask = 0xfffffff0 as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 4usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn new_bitfield_1 ( mGeneration : u32 , mIndexInGeneration : u32 ) -> u32 { ( ( 0 | ( ( mGeneration as u32 as u32 ) << 0usize ) & ( 0xf as u32 ) ) | ( ( mIndexInGeneration as u32 as u32 ) << 4usize ) & ( 0xfffffff0 as u32 ) ) } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsBaseContentList { _unused : [ u8 ; 0 ] } 
 /// Right now our identifier map entries contain information for 'name'
    /// and 'id' mappings of a given string. This is so that
    /// nsHTMLDocument::ResolveName only has to do one hash lookup instead
    /// of two. It's not clear whether this still matters for performance.
    ///
    /// We also store the document.all result list here. This is mainly so that
    /// when all elements with the given ID are removed and we remove
    /// the ID's nsIdentifierMapEntry, the document.all result is released too.
    /// Perhaps the document.all results should have their own hashtable
    /// in nsHTMLDocument. 
 # [ repr ( C ) ] pub struct nsIdentifierMapEntry { pub _base : root :: PLDHashEntryHdr , pub mKey : root :: nsIdentifierMapEntry_AtomOrString , pub mIdContentList : [ u64 ; 3usize ] , pub mNameContentList : root :: RefPtr < root :: nsBaseContentList > , pub mChangeCallbacks : u64 , pub mImageElement : root :: RefPtr < root :: nsIdentifierMapEntry_Element > , } pub type nsIdentifierMapEntry_Element = root :: mozilla :: dom :: Element ; pub use self :: super :: root :: mozilla :: net :: ReferrerPolicy as nsIdentifierMapEntry_ReferrerPolicy ; 
 /// @see nsIDocument::IDTargetObserver, this is just here to avoid include
    /// hell. 
 pub type nsIdentifierMapEntry_IDTargetObserver = :: std :: option :: Option < unsafe extern "C" fn ( aOldElement : * mut root :: nsIdentifierMapEntry_Element , aNewelement : * mut root :: nsIdentifierMapEntry_Element , aData : * mut :: std :: os :: raw :: c_void ) -> bool > ; # [ repr ( C ) ] pub struct nsIdentifierMapEntry_AtomOrString { pub mAtom : root :: RefPtr < root :: nsAtom > , pub mString : ::nsstring::nsStringRepr , } # [ test ] fn bindgen_test_layout_nsIdentifierMapEntry_AtomOrString ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIdentifierMapEntry_AtomOrString > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsIdentifierMapEntry_AtomOrString ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIdentifierMapEntry_AtomOrString > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIdentifierMapEntry_AtomOrString ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIdentifierMapEntry_AtomOrString ) ) . mAtom as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsIdentifierMapEntry_AtomOrString ) , "::" , stringify ! ( mAtom ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIdentifierMapEntry_AtomOrString ) ) . mString as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsIdentifierMapEntry_AtomOrString ) , "::" , stringify ! ( mString ) ) ) ; } pub type nsIdentifierMapEntry_KeyType = * const root :: nsIdentifierMapEntry_AtomOrString ; pub type nsIdentifierMapEntry_KeyTypePointer = * const root :: nsIdentifierMapEntry_AtomOrString ; pub const nsIdentifierMapEntry_ALLOW_MEMMOVE : root :: nsIdentifierMapEntry__bindgen_ty_1 = 0 ; pub type nsIdentifierMapEntry__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIdentifierMapEntry_ChangeCallback { pub mCallback : root :: nsIdentifierMapEntry_IDTargetObserver , pub mData : * mut :: std :: os :: raw :: c_void , pub mForImage : bool , } # [ test ] fn bindgen_test_layout_nsIdentifierMapEntry_ChangeCallback ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIdentifierMapEntry_ChangeCallback > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsIdentifierMapEntry_ChangeCallback ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIdentifierMapEntry_ChangeCallback > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIdentifierMapEntry_ChangeCallback ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIdentifierMapEntry_ChangeCallback ) ) . mCallback as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsIdentifierMapEntry_ChangeCallback ) , "::" , stringify ! ( mCallback ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIdentifierMapEntry_ChangeCallback ) ) . mData as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsIdentifierMapEntry_ChangeCallback ) , "::" , stringify ! ( mData ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIdentifierMapEntry_ChangeCallback ) ) . mForImage as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsIdentifierMapEntry_ChangeCallback ) , "::" , stringify ! ( mForImage ) ) ) ; } impl Clone for nsIdentifierMapEntry_ChangeCallback { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIdentifierMapEntry_ChangeCallbackEntry { pub _base : root :: PLDHashEntryHdr , pub mKey : root :: nsIdentifierMapEntry_ChangeCallback , } pub type nsIdentifierMapEntry_ChangeCallbackEntry_KeyType = root :: nsIdentifierMapEntry_ChangeCallback ; pub type nsIdentifierMapEntry_ChangeCallbackEntry_KeyTypePointer = * const root :: nsIdentifierMapEntry_ChangeCallback ; pub const nsIdentifierMapEntry_ChangeCallbackEntry_ALLOW_MEMMOVE : root :: nsIdentifierMapEntry_ChangeCallbackEntry__bindgen_ty_1 = 1 ; pub type nsIdentifierMapEntry_ChangeCallbackEntry__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_nsIdentifierMapEntry_ChangeCallbackEntry ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIdentifierMapEntry_ChangeCallbackEntry > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( nsIdentifierMapEntry_ChangeCallbackEntry ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIdentifierMapEntry_ChangeCallbackEntry > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIdentifierMapEntry_ChangeCallbackEntry ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIdentifierMapEntry_ChangeCallbackEntry ) ) . mKey as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsIdentifierMapEntry_ChangeCallbackEntry ) , "::" , stringify ! ( mKey ) ) ) ; } impl Clone for nsIdentifierMapEntry_ChangeCallbackEntry { fn clone ( & self ) -> Self { * self } } # [ test ] fn bindgen_test_layout_nsIdentifierMapEntry ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIdentifierMapEntry > ( ) , 80usize , concat ! ( "Size of: " , stringify ! ( nsIdentifierMapEntry ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIdentifierMapEntry > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIdentifierMapEntry ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIdentifierMapEntry ) ) . mKey as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsIdentifierMapEntry ) , "::" , stringify ! ( mKey ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIdentifierMapEntry ) ) . mIdContentList as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsIdentifierMapEntry ) , "::" , stringify ! ( mIdContentList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIdentifierMapEntry ) ) . mNameContentList as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( nsIdentifierMapEntry ) , "::" , stringify ! ( mNameContentList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIdentifierMapEntry ) ) . mChangeCallbacks as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( nsIdentifierMapEntry ) , "::" , stringify ! ( mChangeCallbacks ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIdentifierMapEntry ) ) . mImageElement as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( nsIdentifierMapEntry ) , "::" , stringify ! ( mImageElement ) ) ) ; } pub const nsCSSPropertyID_eCSSProperty_COUNT_no_shorthands : root :: nsCSSPropertyID = nsCSSPropertyID :: eCSSProperty_all ; pub const nsCSSPropertyID_eCSSProperty_COUNT_DUMMY : root :: nsCSSPropertyID = nsCSSPropertyID :: eCSSProperty_z_index ; pub const nsCSSPropertyID_eCSSProperty_COUNT : root :: nsCSSPropertyID = nsCSSPropertyID :: eCSSPropertyAlias_WordWrap ; pub const nsCSSPropertyID_eCSSProperty_COUNT_DUMMY2 : root :: nsCSSPropertyID = nsCSSPropertyID :: eCSSProperty_transition ; pub const nsCSSPropertyID_eCSSProperty_COUNT_with_aliases : root :: nsCSSPropertyID = nsCSSPropertyID :: eCSSPropertyExtra_no_properties ; pub const nsCSSPropertyID_eCSSProperty_COUNT_DUMMY3 : root :: nsCSSPropertyID = nsCSSPropertyID :: eCSSPropertyAlias_WebkitMaskSize ; # [ repr ( i32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsCSSPropertyID { eCSSProperty_UNKNOWN = -1 , eCSSProperty_align_content = 0 , eCSSProperty_align_items = 1 , eCSSProperty_align_self = 2 , eCSSProperty_animation_delay = 3 , eCSSProperty_animation_direction = 4 , eCSSProperty_animation_duration = 5 , eCSSProperty_animation_fill_mode = 6 , eCSSProperty_animation_iteration_count = 7 , eCSSProperty_animation_name = 8 , eCSSProperty_animation_play_state = 9 , eCSSProperty_animation_timing_function = 10 , eCSSProperty__moz_appearance = 11 , eCSSProperty_backface_visibility = 12 , eCSSProperty_background_attachment = 13 , eCSSProperty_background_blend_mode = 14 , eCSSProperty_background_clip = 15 , eCSSProperty_background_color = 16 , eCSSProperty_background_image = 17 , eCSSProperty_background_origin = 18 , eCSSProperty_background_position_x = 19 , eCSSProperty_background_position_y = 20 , eCSSProperty_background_repeat = 21 , eCSSProperty_background_size = 22 , eCSSProperty__moz_binding = 23 , eCSSProperty_block_size = 24 , eCSSProperty_border_block_end_color = 25 , eCSSProperty_border_block_end_style = 26 , eCSSProperty_border_block_end_width = 27 , eCSSProperty_border_block_start_color = 28 , eCSSProperty_border_block_start_style = 29 , eCSSProperty_border_block_start_width = 30 , eCSSProperty_border_bottom_color = 31 , eCSSProperty__moz_border_bottom_colors = 32 , eCSSProperty_border_bottom_left_radius = 33 , eCSSProperty_border_bottom_right_radius = 34 , eCSSProperty_border_bottom_style = 35 , eCSSProperty_border_bottom_width = 36 , eCSSProperty_border_collapse = 37 , eCSSProperty_border_image_outset = 38 , eCSSProperty_border_image_repeat = 39 , eCSSProperty_border_image_slice = 40 , eCSSProperty_border_image_source = 41 , eCSSProperty_border_image_width = 42 , eCSSProperty_border_inline_end_color = 43 , eCSSProperty_border_inline_end_style = 44 , eCSSProperty_border_inline_end_width = 45 , eCSSProperty_border_inline_start_color = 46 , eCSSProperty_border_inline_start_style = 47 , eCSSProperty_border_inline_start_width = 48 , eCSSProperty_border_left_color = 49 , eCSSProperty__moz_border_left_colors = 50 , eCSSProperty_border_left_style = 51 , eCSSProperty_border_left_width = 52 , eCSSProperty_border_right_color = 53 , eCSSProperty__moz_border_right_colors = 54 , eCSSProperty_border_right_style = 55 , eCSSProperty_border_right_width = 56 , eCSSProperty_border_spacing = 57 , eCSSProperty_border_top_color = 58 , eCSSProperty__moz_border_top_colors = 59 , eCSSProperty_border_top_left_radius = 60 , eCSSProperty_border_top_right_radius = 61 , eCSSProperty_border_top_style = 62 , eCSSProperty_border_top_width = 63 , eCSSProperty_bottom = 64 , eCSSProperty__moz_box_align = 65 , eCSSProperty_box_decoration_break = 66 , eCSSProperty__moz_box_direction = 67 , eCSSProperty__moz_box_flex = 68 , eCSSProperty__moz_box_ordinal_group = 69 , eCSSProperty__moz_box_orient = 70 , eCSSProperty__moz_box_pack = 71 , eCSSProperty_box_shadow = 72 , eCSSProperty_box_sizing = 73 , eCSSProperty_caption_side = 74 , eCSSProperty_caret_color = 75 , eCSSProperty_clear = 76 , eCSSProperty_clip = 77 , eCSSProperty_clip_path = 78 , eCSSProperty_clip_rule = 79 , eCSSProperty_color = 80 , eCSSProperty_color_adjust = 81 , eCSSProperty_color_interpolation = 82 , eCSSProperty_color_interpolation_filters = 83 , eCSSProperty_column_count = 84 , eCSSProperty_column_fill = 85 , eCSSProperty_column_gap = 86 , eCSSProperty_column_rule_color = 87 , eCSSProperty_column_rule_style = 88 , eCSSProperty_column_rule_width = 89 , eCSSProperty_column_span = 90 , eCSSProperty_column_width = 91 , eCSSProperty_contain = 92 , eCSSProperty_content = 93 , eCSSProperty__moz_context_properties = 94 , eCSSProperty__moz_control_character_visibility = 95 , eCSSProperty_counter_increment = 96 , eCSSProperty_counter_reset = 97 , eCSSProperty_cursor = 98 , eCSSProperty_direction = 99 , eCSSProperty_display = 100 , eCSSProperty_dominant_baseline = 101 , eCSSProperty_empty_cells = 102 , eCSSProperty_fill = 103 , eCSSProperty_fill_opacity = 104 , eCSSProperty_fill_rule = 105 , eCSSProperty_filter = 106 , eCSSProperty_flex_basis = 107 , eCSSProperty_flex_direction = 108 , eCSSProperty_flex_grow = 109 , eCSSProperty_flex_shrink = 110 , eCSSProperty_flex_wrap = 111 , eCSSProperty_float_ = 112 , eCSSProperty__moz_float_edge = 113 , eCSSProperty_flood_color = 114 , eCSSProperty_flood_opacity = 115 , eCSSProperty_font_family = 116 , eCSSProperty_font_feature_settings = 117 , eCSSProperty_font_kerning = 118 , eCSSProperty_font_language_override = 119 , eCSSProperty_font_size = 120 , eCSSProperty_font_size_adjust = 121 , eCSSProperty__moz_font_smoothing_background_color = 122 , eCSSProperty_font_stretch = 123 , eCSSProperty_font_style = 124 , eCSSProperty_font_synthesis = 125 , eCSSProperty_font_variant_alternates = 126 , eCSSProperty_font_variant_caps = 127 , eCSSProperty_font_variant_east_asian = 128 , eCSSProperty_font_variant_ligatures = 129 , eCSSProperty_font_variant_numeric = 130 , eCSSProperty_font_variant_position = 131 , eCSSProperty_font_variation_settings = 132 , eCSSProperty_font_weight = 133 , eCSSProperty__moz_force_broken_image_icon = 134 , eCSSProperty_grid_auto_columns = 135 , eCSSProperty_grid_auto_flow = 136 , eCSSProperty_grid_auto_rows = 137 , eCSSProperty_grid_column_end = 138 , eCSSProperty_grid_column_gap = 139 , eCSSProperty_grid_column_start = 140 , eCSSProperty_grid_row_end = 141 , eCSSProperty_grid_row_gap = 142 , eCSSProperty_grid_row_start = 143 , eCSSProperty_grid_template_areas = 144 , eCSSProperty_grid_template_columns = 145 , eCSSProperty_grid_template_rows = 146 , eCSSProperty_height = 147 , eCSSProperty_hyphens = 148 , eCSSProperty_initial_letter = 149 , eCSSProperty_image_orientation = 150 , eCSSProperty__moz_image_region = 151 , eCSSProperty_image_rendering = 152 , eCSSProperty_ime_mode = 153 , eCSSProperty_inline_size = 154 , eCSSProperty_isolation = 155 , eCSSProperty_justify_content = 156 , eCSSProperty_justify_items = 157 , eCSSProperty_justify_self = 158 , eCSSProperty__x_lang = 159 , eCSSProperty_left = 160 , eCSSProperty_letter_spacing = 161 , eCSSProperty_lighting_color = 162 , eCSSProperty_line_height = 163 , eCSSProperty_list_style_image = 164 , eCSSProperty_list_style_position = 165 , eCSSProperty_list_style_type = 166 , eCSSProperty_margin_block_end = 167 , eCSSProperty_margin_block_start = 168 , eCSSProperty_margin_bottom = 169 , eCSSProperty_margin_inline_end = 170 , eCSSProperty_margin_inline_start = 171 , eCSSProperty_margin_left = 172 , eCSSProperty_margin_right = 173 , eCSSProperty_margin_top = 174 , eCSSProperty_marker_end = 175 , eCSSProperty_marker_mid = 176 , eCSSProperty_marker_start = 177 , eCSSProperty_mask_clip = 178 , eCSSProperty_mask_composite = 179 , eCSSProperty_mask_image = 180 , eCSSProperty_mask_mode = 181 , eCSSProperty_mask_origin = 182 , eCSSProperty_mask_position_x = 183 , eCSSProperty_mask_position_y = 184 , eCSSProperty_mask_repeat = 185 , eCSSProperty_mask_size = 186 , eCSSProperty_mask_type = 187 , eCSSProperty__moz_math_display = 188 , eCSSProperty__moz_math_variant = 189 , eCSSProperty_max_block_size = 190 , eCSSProperty_max_height = 191 , eCSSProperty_max_inline_size = 192 , eCSSProperty_max_width = 193 , eCSSProperty_min_block_size = 194 , eCSSProperty__moz_min_font_size_ratio = 195 , eCSSProperty_min_height = 196 , eCSSProperty_min_inline_size = 197 , eCSSProperty_min_width = 198 , eCSSProperty_mix_blend_mode = 199 , eCSSProperty_object_fit = 200 , eCSSProperty_object_position = 201 , eCSSProperty_offset_block_end = 202 , eCSSProperty_offset_block_start = 203 , eCSSProperty_offset_inline_end = 204 , eCSSProperty_offset_inline_start = 205 , eCSSProperty_opacity = 206 , eCSSProperty_order = 207 , eCSSProperty__moz_orient = 208 , eCSSProperty__moz_osx_font_smoothing = 209 , eCSSProperty_outline_color = 210 , eCSSProperty_outline_offset = 211 , eCSSProperty__moz_outline_radius_bottomleft = 212 , eCSSProperty__moz_outline_radius_bottomright = 213 , eCSSProperty__moz_outline_radius_topleft = 214 , eCSSProperty__moz_outline_radius_topright = 215 , eCSSProperty_outline_style = 216 , eCSSProperty_outline_width = 217 , eCSSProperty_overflow_clip_box_block = 218 , eCSSProperty_overflow_clip_box_inline = 219 , eCSSProperty_overflow_x = 220 , eCSSProperty_overflow_y = 221 , eCSSProperty_padding_block_end = 222 , eCSSProperty_padding_block_start = 223 , eCSSProperty_padding_bottom = 224 , eCSSProperty_padding_inline_end = 225 , eCSSProperty_padding_inline_start = 226 , eCSSProperty_padding_left = 227 , eCSSProperty_padding_right = 228 , eCSSProperty_padding_top = 229 , eCSSProperty_page_break_after = 230 , eCSSProperty_page_break_before = 231 , eCSSProperty_page_break_inside = 232 , eCSSProperty_paint_order = 233 , eCSSProperty_perspective = 234 , eCSSProperty_perspective_origin = 235 , eCSSProperty_pointer_events = 236 , eCSSProperty_position = 237 , eCSSProperty_quotes = 238 , eCSSProperty_resize = 239 , eCSSProperty_right = 240 , eCSSProperty_ruby_align = 241 , eCSSProperty_ruby_position = 242 , eCSSProperty__moz_script_level = 243 , eCSSProperty__moz_script_min_size = 244 , eCSSProperty__moz_script_size_multiplier = 245 , eCSSProperty_scroll_behavior = 246 , eCSSProperty_overscroll_behavior_x = 247 , eCSSProperty_overscroll_behavior_y = 248 , eCSSProperty_scroll_snap_coordinate = 249 , eCSSProperty_scroll_snap_destination = 250 , eCSSProperty_scroll_snap_points_x = 251 , eCSSProperty_scroll_snap_points_y = 252 , eCSSProperty_scroll_snap_type_x = 253 , eCSSProperty_scroll_snap_type_y = 254 , eCSSProperty_shape_image_threshold = 255 , eCSSProperty_shape_outside = 256 , eCSSProperty_shape_rendering = 257 , eCSSProperty__x_span = 258 , eCSSProperty__moz_stack_sizing = 259 , eCSSProperty_stop_color = 260 , eCSSProperty_stop_opacity = 261 , eCSSProperty_stroke = 262 , eCSSProperty_stroke_dasharray = 263 , eCSSProperty_stroke_dashoffset = 264 , eCSSProperty_stroke_linecap = 265 , eCSSProperty_stroke_linejoin = 266 , eCSSProperty_stroke_miterlimit = 267 , eCSSProperty_stroke_opacity = 268 , eCSSProperty_stroke_width = 269 , eCSSProperty__x_system_font = 270 , eCSSProperty__moz_tab_size = 271 , eCSSProperty_table_layout = 272 , eCSSProperty_text_align = 273 , eCSSProperty_text_align_last = 274 , eCSSProperty_text_anchor = 275 , eCSSProperty_text_combine_upright = 276 , eCSSProperty_text_decoration_color = 277 , eCSSProperty_text_decoration_line = 278 , eCSSProperty_text_decoration_style = 279 , eCSSProperty_text_emphasis_color = 280 , eCSSProperty_text_emphasis_position = 281 , eCSSProperty_text_emphasis_style = 282 , eCSSProperty__webkit_text_fill_color = 283 , eCSSProperty_text_indent = 284 , eCSSProperty_text_justify = 285 , eCSSProperty_text_orientation = 286 , eCSSProperty_text_overflow = 287 , eCSSProperty_text_rendering = 288 , eCSSProperty_text_shadow = 289 , eCSSProperty__moz_text_size_adjust = 290 , eCSSProperty__webkit_text_stroke_color = 291 , eCSSProperty__webkit_text_stroke_width = 292 , eCSSProperty_text_transform = 293 , eCSSProperty__x_text_zoom = 294 , eCSSProperty_top = 295 , eCSSProperty__moz_top_layer = 296 , eCSSProperty_touch_action = 297 , eCSSProperty_transform = 298 , eCSSProperty_transform_box = 299 , eCSSProperty_transform_origin = 300 , eCSSProperty_transform_style = 301 , eCSSProperty_transition_delay = 302 , eCSSProperty_transition_duration = 303 , eCSSProperty_transition_property = 304 , eCSSProperty_transition_timing_function = 305 , eCSSProperty_unicode_bidi = 306 , eCSSProperty__moz_user_focus = 307 , eCSSProperty__moz_user_input = 308 , eCSSProperty__moz_user_modify = 309 , eCSSProperty__moz_user_select = 310 , eCSSProperty_vector_effect = 311 , eCSSProperty_vertical_align = 312 , eCSSProperty_visibility = 313 , eCSSProperty_white_space = 314 , eCSSProperty_width = 315 , eCSSProperty_will_change = 316 , eCSSProperty__moz_window_dragging = 317 , eCSSProperty__moz_window_shadow = 318 , eCSSProperty__moz_window_opacity = 319 , eCSSProperty__moz_window_transform = 320 , eCSSProperty__moz_window_transform_origin = 321 , eCSSProperty_word_break = 322 , eCSSProperty_word_spacing = 323 , eCSSProperty_overflow_wrap = 324 , eCSSProperty_writing_mode = 325 , eCSSProperty_z_index = 326 , eCSSProperty_all = 327 , eCSSProperty_animation = 328 , eCSSProperty_background = 329 , eCSSProperty_background_position = 330 , eCSSProperty_border = 331 , eCSSProperty_border_block_end = 332 , eCSSProperty_border_block_start = 333 , eCSSProperty_border_bottom = 334 , eCSSProperty_border_color = 335 , eCSSProperty_border_image = 336 , eCSSProperty_border_inline_end = 337 , eCSSProperty_border_inline_start = 338 , eCSSProperty_border_left = 339 , eCSSProperty_border_radius = 340 , eCSSProperty_border_right = 341 , eCSSProperty_border_style = 342 , eCSSProperty_border_top = 343 , eCSSProperty_border_width = 344 , eCSSProperty_column_rule = 345 , eCSSProperty_columns = 346 , eCSSProperty_flex = 347 , eCSSProperty_flex_flow = 348 , eCSSProperty_font = 349 , eCSSProperty_font_variant = 350 , eCSSProperty_grid = 351 , eCSSProperty_grid_area = 352 , eCSSProperty_grid_column = 353 , eCSSProperty_grid_gap = 354 , eCSSProperty_grid_row = 355 , eCSSProperty_grid_template = 356 , eCSSProperty_list_style = 357 , eCSSProperty_margin = 358 , eCSSProperty_marker = 359 , eCSSProperty_mask = 360 , eCSSProperty_mask_position = 361 , eCSSProperty_outline = 362 , eCSSProperty__moz_outline_radius = 363 , eCSSProperty_overflow = 364 , eCSSProperty_overflow_clip_box = 365 , eCSSProperty_padding = 366 , eCSSProperty_place_content = 367 , eCSSProperty_place_items = 368 , eCSSProperty_place_self = 369 , eCSSProperty_overscroll_behavior = 370 , eCSSProperty_scroll_snap_type = 371 , eCSSProperty_text_decoration = 372 , eCSSProperty_text_emphasis = 373 , eCSSProperty__webkit_text_stroke = 374 , eCSSProperty__moz_transform = 375 , eCSSProperty_transition = 376 , eCSSPropertyAlias_WordWrap = 377 , eCSSPropertyAlias_MozTransformOrigin = 378 , eCSSPropertyAlias_MozPerspectiveOrigin = 379 , eCSSPropertyAlias_MozPerspective = 380 , eCSSPropertyAlias_MozTransformStyle = 381 , eCSSPropertyAlias_MozBackfaceVisibility = 382 , eCSSPropertyAlias_MozBorderImage = 383 , eCSSPropertyAlias_MozTransition = 384 , eCSSPropertyAlias_MozTransitionDelay = 385 , eCSSPropertyAlias_MozTransitionDuration = 386 , eCSSPropertyAlias_MozTransitionProperty = 387 , eCSSPropertyAlias_MozTransitionTimingFunction = 388 , eCSSPropertyAlias_MozAnimation = 389 , eCSSPropertyAlias_MozAnimationDelay = 390 , eCSSPropertyAlias_MozAnimationDirection = 391 , eCSSPropertyAlias_MozAnimationDuration = 392 , eCSSPropertyAlias_MozAnimationFillMode = 393 , eCSSPropertyAlias_MozAnimationIterationCount = 394 , eCSSPropertyAlias_MozAnimationName = 395 , eCSSPropertyAlias_MozAnimationPlayState = 396 , eCSSPropertyAlias_MozAnimationTimingFunction = 397 , eCSSPropertyAlias_MozBoxSizing = 398 , eCSSPropertyAlias_MozFontFeatureSettings = 399 , eCSSPropertyAlias_MozFontLanguageOverride = 400 , eCSSPropertyAlias_MozPaddingEnd = 401 , eCSSPropertyAlias_MozPaddingStart = 402 , eCSSPropertyAlias_MozMarginEnd = 403 , eCSSPropertyAlias_MozMarginStart = 404 , eCSSPropertyAlias_MozBorderEnd = 405 , eCSSPropertyAlias_MozBorderEndColor = 406 , eCSSPropertyAlias_MozBorderEndStyle = 407 , eCSSPropertyAlias_MozBorderEndWidth = 408 , eCSSPropertyAlias_MozBorderStart = 409 , eCSSPropertyAlias_MozBorderStartColor = 410 , eCSSPropertyAlias_MozBorderStartStyle = 411 , eCSSPropertyAlias_MozBorderStartWidth = 412 , eCSSPropertyAlias_MozHyphens = 413 , eCSSPropertyAlias_MozColumnCount = 414 , eCSSPropertyAlias_MozColumnFill = 415 , eCSSPropertyAlias_MozColumnGap = 416 , eCSSPropertyAlias_MozColumnRule = 417 , eCSSPropertyAlias_MozColumnRuleColor = 418 , eCSSPropertyAlias_MozColumnRuleStyle = 419 , eCSSPropertyAlias_MozColumnRuleWidth = 420 , eCSSPropertyAlias_MozColumnSpan = 421 , eCSSPropertyAlias_MozColumnWidth = 422 , eCSSPropertyAlias_MozColumns = 423 , eCSSPropertyAlias_WebkitAnimation = 424 , eCSSPropertyAlias_WebkitAnimationDelay = 425 , eCSSPropertyAlias_WebkitAnimationDirection = 426 , eCSSPropertyAlias_WebkitAnimationDuration = 427 , eCSSPropertyAlias_WebkitAnimationFillMode = 428 , eCSSPropertyAlias_WebkitAnimationIterationCount = 429 , eCSSPropertyAlias_WebkitAnimationName = 430 , eCSSPropertyAlias_WebkitAnimationPlayState = 431 , eCSSPropertyAlias_WebkitAnimationTimingFunction = 432 , eCSSPropertyAlias_WebkitFilter = 433 , eCSSPropertyAlias_WebkitTextSizeAdjust = 434 , eCSSPropertyAlias_WebkitTransform = 435 , eCSSPropertyAlias_WebkitTransformOrigin = 436 , eCSSPropertyAlias_WebkitTransformStyle = 437 , eCSSPropertyAlias_WebkitBackfaceVisibility = 438 , eCSSPropertyAlias_WebkitPerspective = 439 , eCSSPropertyAlias_WebkitPerspectiveOrigin = 440 , eCSSPropertyAlias_WebkitTransition = 441 , eCSSPropertyAlias_WebkitTransitionDelay = 442 , eCSSPropertyAlias_WebkitTransitionDuration = 443 , eCSSPropertyAlias_WebkitTransitionProperty = 444 , eCSSPropertyAlias_WebkitTransitionTimingFunction = 445 , eCSSPropertyAlias_WebkitBorderRadius = 446 , eCSSPropertyAlias_WebkitBorderTopLeftRadius = 447 , eCSSPropertyAlias_WebkitBorderTopRightRadius = 448 , eCSSPropertyAlias_WebkitBorderBottomLeftRadius = 449 , eCSSPropertyAlias_WebkitBorderBottomRightRadius = 450 , eCSSPropertyAlias_WebkitBackgroundClip = 451 , eCSSPropertyAlias_WebkitBackgroundOrigin = 452 , eCSSPropertyAlias_WebkitBackgroundSize = 453 , eCSSPropertyAlias_WebkitBorderImage = 454 , eCSSPropertyAlias_WebkitBoxShadow = 455 , eCSSPropertyAlias_WebkitBoxSizing = 456 , eCSSPropertyAlias_WebkitBoxFlex = 457 , eCSSPropertyAlias_WebkitBoxOrdinalGroup = 458 , eCSSPropertyAlias_WebkitBoxOrient = 459 , eCSSPropertyAlias_WebkitBoxDirection = 460 , eCSSPropertyAlias_WebkitBoxAlign = 461 , eCSSPropertyAlias_WebkitBoxPack = 462 , eCSSPropertyAlias_WebkitFlexDirection = 463 , eCSSPropertyAlias_WebkitFlexWrap = 464 , eCSSPropertyAlias_WebkitFlexFlow = 465 , eCSSPropertyAlias_WebkitOrder = 466 , eCSSPropertyAlias_WebkitFlex = 467 , eCSSPropertyAlias_WebkitFlexGrow = 468 , eCSSPropertyAlias_WebkitFlexShrink = 469 , eCSSPropertyAlias_WebkitFlexBasis = 470 , eCSSPropertyAlias_WebkitJustifyContent = 471 , eCSSPropertyAlias_WebkitAlignItems = 472 , eCSSPropertyAlias_WebkitAlignSelf = 473 , eCSSPropertyAlias_WebkitAlignContent = 474 , eCSSPropertyAlias_WebkitUserSelect = 475 , eCSSPropertyAlias_WebkitMask = 476 , eCSSPropertyAlias_WebkitMaskClip = 477 , eCSSPropertyAlias_WebkitMaskComposite = 478 , eCSSPropertyAlias_WebkitMaskImage = 479 , eCSSPropertyAlias_WebkitMaskOrigin = 480 , eCSSPropertyAlias_WebkitMaskPosition = 481 , eCSSPropertyAlias_WebkitMaskPositionX = 482 , eCSSPropertyAlias_WebkitMaskPositionY = 483 , eCSSPropertyAlias_WebkitMaskRepeat = 484 , eCSSPropertyAlias_WebkitMaskSize = 485 , eCSSPropertyExtra_no_properties = 486 , eCSSPropertyExtra_all_properties = 487 , eCSSPropertyExtra_x_none_value = 488 , eCSSPropertyExtra_x_auto_value = 489 , eCSSPropertyExtra_variable = 490 , eCSSProperty_DOM = 491 , } # [ repr ( i32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsCSSFontDesc { eCSSFontDesc_UNKNOWN = -1 , eCSSFontDesc_Family = 0 , eCSSFontDesc_Style = 1 , eCSSFontDesc_Weight = 2 , eCSSFontDesc_Stretch = 3 , eCSSFontDesc_Src = 4 , eCSSFontDesc_UnicodeRange = 5 , eCSSFontDesc_FontFeatureSettings = 6 , eCSSFontDesc_FontLanguageOverride = 7 , eCSSFontDesc_Display = 8 , eCSSFontDesc_COUNT = 9 , } # [ repr ( i32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsCSSCounterDesc { eCSSCounterDesc_UNKNOWN = -1 , eCSSCounterDesc_System = 0 , eCSSCounterDesc_Symbols = 1 , eCSSCounterDesc_AdditiveSymbols = 2 , eCSSCounterDesc_Negative = 3 , eCSSCounterDesc_Prefix = 4 , eCSSCounterDesc_Suffix = 5 , eCSSCounterDesc_Range = 6 , eCSSCounterDesc_Pad = 7 , eCSSCounterDesc_Fallback = 8 , eCSSCounterDesc_SpeakAs = 9 , eCSSCounterDesc_COUNT = 10 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RawServoStyleSet { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RawServoSourceSizeList { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RustString { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RawServoStyleSheetContents { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RawServoDeclarationBlock { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RawServoStyleRule { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RawServoAnimationValue { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RawServoMediaList { _unused : [ u8 ; 0 ] } pub mod nsStyleTransformMatrix { # [ allow ( unused_imports ) ] use self :: super :: super :: root ; # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum MatrixTransformOperator { Interpolate = 0 , Accumulate = 1 , } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsCSSPropertyIDSet { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsSimpleContentList { _unused : [ u8 ; 0 ] } pub type RawGeckoNode = root :: nsINode ; pub type RawGeckoElement = root :: mozilla :: dom :: Element ; pub type RawGeckoDocument = root :: nsIDocument ; pub type RawGeckoPresContext = root :: nsPresContext ; pub type RawGeckoXBLBinding = root :: nsXBLBinding ; pub type RawGeckoURLExtraData = root :: mozilla :: URLExtraData ; pub type RawGeckoServoAnimationValueList = root :: nsTArray < root :: RefPtr < root :: RawServoAnimationValue > > ; pub type RawGeckoKeyframeList = root :: nsTArray < root :: mozilla :: Keyframe > ; pub type RawGeckoPropertyValuePairList = root :: nsTArray < root :: mozilla :: PropertyValuePair > ; pub type RawGeckoComputedKeyframeValuesList = root :: nsTArray < root :: mozilla :: ComputedKeyframeValues > ; pub type RawGeckoStyleAnimationList = root :: nsStyleAutoArray < root :: mozilla :: StyleAnimation > ; pub type RawGeckoFontFaceRuleList = root :: nsTArray < root :: nsFontFaceRuleContainer > ; pub type RawGeckoAnimationPropertySegment = root :: mozilla :: AnimationPropertySegment ; pub type RawGeckoComputedTiming = root :: mozilla :: ComputedTiming ; pub type RawGeckoServoStyleRuleList = root :: nsTArray < * const root :: RawServoStyleRule > ; pub type RawGeckoCSSPropertyIDList = root :: nsTArray < root :: nsCSSPropertyID > ; pub type RawGeckoGfxMatrix4x4 = [ root :: mozilla :: gfx :: Float ; 16usize ] ; pub type RawGeckoStyleChildrenIterator = root :: mozilla :: dom :: StyleChildrenIterator ; pub type ServoStyleContextBorrowed = * const root :: mozilla :: ServoStyleContext ; pub type ServoStyleContextBorrowedOrNull = * const root :: mozilla :: ServoStyleContext ; pub type ServoComputedDataBorrowed = * const root :: ServoComputedData ; pub type RawGeckoNodeBorrowed = * const root :: RawGeckoNode ; pub type RawGeckoNodeBorrowedOrNull = * const root :: RawGeckoNode ; pub type RawGeckoElementBorrowed = * const root :: RawGeckoElement ; pub type RawGeckoElementBorrowedOrNull = * const root :: RawGeckoElement ; pub type RawGeckoDocumentBorrowed = * const root :: RawGeckoDocument ; pub type RawGeckoDocumentBorrowedOrNull = * const root :: RawGeckoDocument ; pub type RawGeckoXBLBindingBorrowed = * const root :: RawGeckoXBLBinding ; pub type RawGeckoXBLBindingBorrowedOrNull = * const root :: RawGeckoXBLBinding ; pub type RawGeckoPresContextOwned = * mut root :: RawGeckoPresContext ; pub type RawGeckoPresContextBorrowed = * const root :: RawGeckoPresContext ; pub type RawGeckoPresContextBorrowedMut = * mut root :: RawGeckoPresContext ; pub type RawGeckoServoAnimationValueListBorrowedMut = * mut root :: RawGeckoServoAnimationValueList ; pub type RawGeckoServoAnimationValueListBorrowed = * const root :: RawGeckoServoAnimationValueList ; pub type RawGeckoKeyframeListBorrowedMut = * mut root :: RawGeckoKeyframeList ; pub type RawGeckoKeyframeListBorrowed = * const root :: RawGeckoKeyframeList ; pub type RawGeckoPropertyValuePairListBorrowedMut = * mut root :: RawGeckoPropertyValuePairList ; pub type RawGeckoPropertyValuePairListBorrowed = * const root :: RawGeckoPropertyValuePairList ; pub type RawGeckoComputedKeyframeValuesListBorrowedMut = * mut root :: RawGeckoComputedKeyframeValuesList ; pub type RawGeckoStyleAnimationListBorrowedMut = * mut root :: RawGeckoStyleAnimationList ; pub type RawGeckoStyleAnimationListBorrowed = * const root :: RawGeckoStyleAnimationList ; pub type RawGeckoFontFaceRuleListBorrowedMut = * mut root :: RawGeckoFontFaceRuleList ; pub type RawGeckoAnimationPropertySegmentBorrowed = * const root :: RawGeckoAnimationPropertySegment ; pub type RawGeckoComputedTimingBorrowed = * const root :: RawGeckoComputedTiming ; pub type RawGeckoServoStyleRuleListBorrowedMut = * mut root :: RawGeckoServoStyleRuleList ; pub type RawGeckoCSSPropertyIDListBorrowed = * const root :: RawGeckoCSSPropertyIDList ; pub type RawGeckoStyleChildrenIteratorBorrowedMut = * mut root :: RawGeckoStyleChildrenIterator ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsHTMLCSSStyleSheet { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsHTMLStyleSheet { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIBFCacheEntry { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIDocumentEncoder { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIStructuredCloneContainer { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsSMILAnimationController { _unused : [ u8 ; 0 ] } pub const HSTSPrimingState_eNO_HSTS_PRIMING : root :: HSTSPrimingState = 0 ; pub const HSTSPrimingState_eHSTS_PRIMING_ALLOW : root :: HSTSPrimingState = 1 ; pub const HSTSPrimingState_eHSTS_PRIMING_BLOCK : root :: HSTSPrimingState = 2 ; pub type HSTSPrimingState = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] pub struct nsIDocument { pub _base : root :: nsINode , pub _base_1 : root :: mozilla :: dom :: DocumentOrShadowRoot , pub _base_2 : root :: mozilla :: dom :: DispatcherTrait , pub mDeprecationWarnedAbout : u64 , pub mDocWarningWarnedAbout : u64 , pub mServoSelectorCache : root :: mozilla :: UniquePtr < root :: nsIDocument_SelectorCache > , pub mGeckoSelectorCache : root :: mozilla :: UniquePtr < root :: nsIDocument_SelectorCache > , pub mReferrer : root :: nsCString , pub mLastModified : ::nsstring::nsStringRepr , pub mDocumentURI : root :: nsCOMPtr , pub mOriginalURI : root :: nsCOMPtr , pub mChromeXHRDocURI : root :: nsCOMPtr , pub mDocumentBaseURI : root :: nsCOMPtr , pub mChromeXHRDocBaseURI : root :: nsCOMPtr , pub mCachedURLData : root :: RefPtr < root :: mozilla :: URLExtraData > , pub mDocumentLoadGroup : root :: nsWeakPtr , pub mReferrerPolicySet : bool , pub mReferrerPolicy : root :: nsIDocument_ReferrerPolicyEnum , pub mBlockAllMixedContent : bool , pub mBlockAllMixedContentPreloads : bool , pub mUpgradeInsecureRequests : bool , pub mUpgradeInsecurePreloads : bool , pub mHSTSPrimingURIList : [ u64 ; 4usize ] , pub mDocumentContainer : u64 , pub mCharacterSet : root :: mozilla :: NotNull < * const root :: nsIDocument_Encoding > , pub mCharacterSetSource : i32 , pub mParentDocument : * mut root :: nsIDocument , pub mCachedRootElement : * mut root :: mozilla :: dom :: Element , pub mNodeInfoManager : * mut root :: nsNodeInfoManager , pub mCSSLoader : root :: RefPtr < root :: mozilla :: css :: Loader > , pub mStyleImageLoader : root :: RefPtr < root :: mozilla :: css :: ImageLoader > , pub mAttrStyleSheet : root :: RefPtr < root :: nsHTMLStyleSheet > , pub mStyleAttrStyleSheet : root :: RefPtr < root :: nsHTMLCSSStyleSheet > , pub mImageTracker : root :: RefPtr < root :: mozilla :: dom :: ImageTracker > , pub mActivityObservers : u64 , pub mLinksToUpdate : [ u64 ; 3usize ] , pub mAnimationController : root :: RefPtr < root :: nsSMILAnimationController > , pub mPropertyTable : root :: nsPropertyTable , pub mExtraPropertyTables : root :: nsTArray < root :: nsAutoPtr < root :: nsPropertyTable > > , pub mChildrenCollection : root :: nsCOMPtr , pub mFontFaceSet : root :: RefPtr < root :: mozilla :: dom :: FontFaceSet > , pub mLastFocusTime : root :: mozilla :: TimeStamp , pub mDocumentState : root :: mozilla :: EventStates , pub _bitfield_1 : [ u8 ; 7usize ] , pub mCompatMode : root :: nsCompatibility , pub mReadyState : root :: nsIDocument_ReadyState , pub mStyleBackendType : root :: mozilla :: StyleBackendType , pub mVisibilityState : root :: mozilla :: dom :: VisibilityState , pub mType : root :: nsIDocument_Type , pub mDefaultElementType : u8 , pub mAllowXULXBL : root :: nsIDocument_Tri , pub mScriptGlobalObject : root :: nsCOMPtr , pub mOriginalDocument : root :: nsCOMPtr , pub mBidiOptions : u32 , pub mSandboxFlags : u32 , pub mContentLanguage : root :: nsCString , pub mChannel : root :: nsCOMPtr , pub mContentType : root :: nsCString , pub mSecurityInfo : root :: nsCOMPtr , pub mFailedChannel : root :: nsCOMPtr , pub mPartID : u32 , pub mMarkedCCGeneration : u32 , pub mPresShell : * mut root :: nsIPresShell , pub mSubtreeModifiedTargets : root :: nsCOMArray , pub mSubtreeModifiedDepth : u32 , pub mDisplayDocument : root :: nsCOMPtr , pub mEventsSuppressed : u32 , 
 /// https://html.spec.whatwg.org/#ignore-destructive-writes-counter 
 pub mIgnoreDestructiveWritesCounter : u32 , 
 /// The current frame request callback handle 
 pub mFrameRequestCallbackCounter : i32 , pub mStaticCloneCount : u32 , pub mBlockedTrackingNodes : root :: nsTArray < root :: nsWeakPtr > , pub mWindow : * mut root :: nsPIDOMWindowInner , pub mCachedEncoder : root :: nsCOMPtr , pub mFrameRequestCallbacks : root :: nsTArray < root :: nsIDocument_FrameRequest > , pub mBFCacheEntry : * mut root :: nsIBFCacheEntry , pub mBaseTarget : ::nsstring::nsStringRepr , pub mStateObjectContainer : root :: nsCOMPtr , pub mStateObjectCached : root :: nsCOMPtr , pub mInSyncOperationCount : u32 , pub mXPathEvaluator : root :: RefPtr < root :: mozilla :: dom :: XPathEvaluator > , pub mAnonymousContents : root :: nsTArray < root :: RefPtr < root :: mozilla :: dom :: AnonymousContent > > , pub mBlockDOMContentLoaded : u32 , pub mDOMMediaQueryLists : root :: mozilla :: LinkedList , pub mUseCounters : [ u64 ; 2usize ] , pub mChildDocumentUseCounters : [ u64 ; 2usize ] , pub mNotifiedPageForUseCounter : [ u64 ; 2usize ] , pub mIncCounters : u16 , pub mUserHasInteracted : bool , pub mUserHasActivatedInteraction : bool , pub mPageUnloadingEventTimeStamp : root :: mozilla :: TimeStamp , pub mDocGroup : root :: RefPtr < root :: mozilla :: dom :: DocGroup > , pub mTrackingScripts : [ u64 ; 4usize ] , pub mBufferedCSPViolations : root :: nsTArray < root :: nsCOMPtr > , pub mAncestorPrincipals : root :: nsTArray < root :: nsCOMPtr > , pub mAncestorOuterWindowIDs : root :: nsTArray < u64 > , pub mServoRestyleRoot : root :: nsCOMPtr , pub mServoRestyleRootDirtyBits : u32 , pub mThrowOnDynamicMarkupInsertionCounter : u32 , pub mIgnoreOpensDuringUnloadCounter : u32 , } pub type nsIDocument_GlobalObject = root :: mozilla :: dom :: GlobalObject ; pub type nsIDocument_Encoding = root :: mozilla :: Encoding ; pub type nsIDocument_NotNull < T > = root :: mozilla :: NotNull < T > ; pub use self :: super :: root :: mozilla :: net :: ReferrerPolicy as nsIDocument_ReferrerPolicyEnum ; pub type nsIDocument_Element = root :: mozilla :: dom :: Element ; pub type nsIDocument_FullscreenRequest = root :: mozilla :: dom :: FullscreenRequest ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIDocument_COMTypeInfo { pub _address : u8 , } # [ repr ( C ) ] pub struct nsIDocument_PageUnloadingEventTimeStamp { pub mDocument : root :: nsCOMPtr , pub mSet : bool , } # [ test ] fn bindgen_test_layout_nsIDocument_PageUnloadingEventTimeStamp ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIDocument_PageUnloadingEventTimeStamp > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsIDocument_PageUnloadingEventTimeStamp ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIDocument_PageUnloadingEventTimeStamp > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIDocument_PageUnloadingEventTimeStamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIDocument_PageUnloadingEventTimeStamp ) ) . mDocument as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsIDocument_PageUnloadingEventTimeStamp ) , "::" , stringify ! ( mDocument ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIDocument_PageUnloadingEventTimeStamp ) ) . mSet as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsIDocument_PageUnloadingEventTimeStamp ) , "::" , stringify ! ( mSet ) ) ) ; } 
 /// This gets fired when the element that an id refers to changes.
    /// This fires at difficult times. It is generally not safe to do anything
    /// which could modify the DOM in any way. Use
    /// nsContentUtils::AddScriptRunner.
    /// @return true to keep the callback in the callback set, false
    /// to remove it. 
 pub type nsIDocument_IDTargetObserver = :: std :: option :: Option < unsafe extern "C" fn ( aOldElement : * mut root :: nsIDocument_Element , aNewelement : * mut root :: nsIDocument_Element , aData : * mut :: std :: os :: raw :: c_void ) -> bool > ; # [ repr ( C ) ] pub struct nsIDocument_SelectorCacheKey { pub mKey : ::nsstring::nsStringRepr , pub mState : root :: nsExpirationState , } # [ test ] fn bindgen_test_layout_nsIDocument_SelectorCacheKey ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIDocument_SelectorCacheKey > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsIDocument_SelectorCacheKey ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIDocument_SelectorCacheKey > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIDocument_SelectorCacheKey ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIDocument_SelectorCacheKey ) ) . mKey as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsIDocument_SelectorCacheKey ) , "::" , stringify ! ( mKey ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIDocument_SelectorCacheKey ) ) . mState as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsIDocument_SelectorCacheKey ) , "::" , stringify ! ( mState ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIDocument_SelectorCacheKeyDeleter { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIDocument_SelectorCache { pub _bindgen_opaque_blob : [ u64 ; 16usize ] , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsIDocument_SelectorCache_SelectorList { pub mIsServo : bool , pub __bindgen_anon_1 : root :: nsIDocument_SelectorCache_SelectorList__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIDocument_SelectorCache_SelectorList__bindgen_ty_1 { pub mGecko : root :: __BindgenUnionField < * mut root :: nsCSSSelectorList > , pub mServo : root :: __BindgenUnionField < * mut root :: RawServoSelectorList > , pub bindgen_union_field : u64 , } # [ test ] fn bindgen_test_layout_nsIDocument_SelectorCache_SelectorList__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIDocument_SelectorCache_SelectorList__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIDocument_SelectorCache_SelectorList__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIDocument_SelectorCache_SelectorList__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIDocument_SelectorCache_SelectorList__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIDocument_SelectorCache_SelectorList__bindgen_ty_1 ) ) . mGecko as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsIDocument_SelectorCache_SelectorList__bindgen_ty_1 ) , "::" , stringify ! ( mGecko ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIDocument_SelectorCache_SelectorList__bindgen_ty_1 ) ) . mServo as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsIDocument_SelectorCache_SelectorList__bindgen_ty_1 ) , "::" , stringify ! ( mServo ) ) ) ; } impl Clone for nsIDocument_SelectorCache_SelectorList__bindgen_ty_1 { fn clone ( & self ) -> Self { * self } } # [ test ] fn bindgen_test_layout_nsIDocument_SelectorCache_SelectorList ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIDocument_SelectorCache_SelectorList > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsIDocument_SelectorCache_SelectorList ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIDocument_SelectorCache_SelectorList > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIDocument_SelectorCache_SelectorList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIDocument_SelectorCache_SelectorList ) ) . mIsServo as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsIDocument_SelectorCache_SelectorList ) , "::" , stringify ! ( mIsServo ) ) ) ; } # [ test ] fn bindgen_test_layout_nsIDocument_SelectorCache ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIDocument_SelectorCache > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( nsIDocument_SelectorCache ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIDocument_SelectorCache > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIDocument_SelectorCache ) ) ) ; } impl Clone for nsIDocument_SelectorCache { fn clone ( & self ) -> Self { * self } } pub const nsIDocument_additionalSheetType_eAgentSheet : root :: nsIDocument_additionalSheetType = 0 ; pub const nsIDocument_additionalSheetType_eUserSheet : root :: nsIDocument_additionalSheetType = 1 ; pub const nsIDocument_additionalSheetType_eAuthorSheet : root :: nsIDocument_additionalSheetType = 2 ; pub const nsIDocument_additionalSheetType_AdditionalSheetTypeCount : root :: nsIDocument_additionalSheetType = 3 ; pub type nsIDocument_additionalSheetType = :: std :: os :: raw :: c_uint ; pub const nsIDocument_ReadyState_READYSTATE_UNINITIALIZED : root :: nsIDocument_ReadyState = 0 ; pub const nsIDocument_ReadyState_READYSTATE_LOADING : root :: nsIDocument_ReadyState = 1 ; pub const nsIDocument_ReadyState_READYSTATE_INTERACTIVE : root :: nsIDocument_ReadyState = 3 ; pub const nsIDocument_ReadyState_READYSTATE_COMPLETE : root :: nsIDocument_ReadyState = 4 ; pub type nsIDocument_ReadyState = :: std :: os :: raw :: c_uint ; 
 /// Enumerate all subdocuments.
    /// The enumerator callback should return true to continue enumerating, or
    /// false to stop.  This will never get passed a null aDocument. 
 pub type nsIDocument_nsSubDocEnumFunc = :: std :: option :: Option < unsafe extern "C" fn ( aDocument : * mut root :: nsIDocument , aData : * mut :: std :: os :: raw :: c_void ) -> bool > ; pub const nsIDocument_ElementsFromPointFlags_IGNORE_ROOT_SCROLL_FRAME : root :: nsIDocument_ElementsFromPointFlags = 1 ; pub const nsIDocument_ElementsFromPointFlags_FLUSH_LAYOUT : root :: nsIDocument_ElementsFromPointFlags = 2 ; pub const nsIDocument_ElementsFromPointFlags_IS_ELEMENT_FROM_POINT : root :: nsIDocument_ElementsFromPointFlags = 4 ; pub type nsIDocument_ElementsFromPointFlags = :: std :: os :: raw :: c_uint ; 
 /// A class that represents an external resource load that has begun but
    /// doesn't have a document yet.  Observers can be registered on this object,
    /// and will be notified after the document is created.  Observers registered
    /// after the document has been created will NOT be notified.  When observers
    /// are notified, the subject will be the newly-created document, the topic
    /// will be "external-resource-document-created", and the data will be null.
    /// If document creation fails for some reason, observers will still be
    /// notified, with a null document pointer. 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsIDocument_ExternalResourceLoad { pub _base : root :: nsISupports , pub mObservers : [ u64 ; 10usize ] , } # [ test ] fn bindgen_test_layout_nsIDocument_ExternalResourceLoad ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIDocument_ExternalResourceLoad > ( ) , 88usize , concat ! ( "Size of: " , stringify ! ( nsIDocument_ExternalResourceLoad ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIDocument_ExternalResourceLoad > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIDocument_ExternalResourceLoad ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIDocument_ExternalResourceLoad ) ) . mObservers as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsIDocument_ExternalResourceLoad ) , "::" , stringify ! ( mObservers ) ) ) ; } pub type nsIDocument_ActivityObserverEnumerator = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut root :: nsISupports , arg2 : * mut :: std :: os :: raw :: c_void ) > ; # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsIDocument_DocumentTheme { Doc_Theme_Uninitialized = 0 , Doc_Theme_None = 1 , Doc_Theme_Neutral = 2 , Doc_Theme_Dark = 3 , Doc_Theme_Bright = 4 , } pub type nsIDocument_FrameRequestCallbackList = root :: nsTArray < root :: RefPtr < root :: mozilla :: dom :: FrameRequestCallback > > ; pub const nsIDocument_DeprecatedOperations_eEnablePrivilege : root :: nsIDocument_DeprecatedOperations = 0 ; pub const nsIDocument_DeprecatedOperations_eDOMExceptionCode : root :: nsIDocument_DeprecatedOperations = 1 ; pub const nsIDocument_DeprecatedOperations_eMutationEvent : root :: nsIDocument_DeprecatedOperations = 2 ; pub const nsIDocument_DeprecatedOperations_eComponents : root :: nsIDocument_DeprecatedOperations = 3 ; pub const nsIDocument_DeprecatedOperations_ePrefixedVisibilityAPI : root :: nsIDocument_DeprecatedOperations = 4 ; pub const nsIDocument_DeprecatedOperations_eNodeIteratorDetach : root :: nsIDocument_DeprecatedOperations = 5 ; pub const nsIDocument_DeprecatedOperations_eLenientThis : root :: nsIDocument_DeprecatedOperations = 6 ; pub const nsIDocument_DeprecatedOperations_eGetPreventDefault : root :: nsIDocument_DeprecatedOperations = 7 ; pub const nsIDocument_DeprecatedOperations_eGetSetUserData : root :: nsIDocument_DeprecatedOperations = 8 ; pub const nsIDocument_DeprecatedOperations_eMozGetAsFile : root :: nsIDocument_DeprecatedOperations = 9 ; pub const nsIDocument_DeprecatedOperations_eUseOfCaptureEvents : root :: nsIDocument_DeprecatedOperations = 10 ; pub const nsIDocument_DeprecatedOperations_eUseOfReleaseEvents : root :: nsIDocument_DeprecatedOperations = 11 ; pub const nsIDocument_DeprecatedOperations_eUseOfDOM3LoadMethod : root :: nsIDocument_DeprecatedOperations = 12 ; pub const nsIDocument_DeprecatedOperations_eChromeUseOfDOM3LoadMethod : root :: nsIDocument_DeprecatedOperations = 13 ; pub const nsIDocument_DeprecatedOperations_eShowModalDialog : root :: nsIDocument_DeprecatedOperations = 14 ; pub const nsIDocument_DeprecatedOperations_eSyncXMLHttpRequest : root :: nsIDocument_DeprecatedOperations = 15 ; pub const nsIDocument_DeprecatedOperations_eWindow_Cc_ontrollers : root :: nsIDocument_DeprecatedOperations = 16 ; pub const nsIDocument_DeprecatedOperations_eImportXULIntoContent : root :: nsIDocument_DeprecatedOperations = 17 ; pub const nsIDocument_DeprecatedOperations_ePannerNodeDoppler : root :: nsIDocument_DeprecatedOperations = 18 ; pub const nsIDocument_DeprecatedOperations_eNavigatorGetUserMedia : root :: nsIDocument_DeprecatedOperations = 19 ; pub const nsIDocument_DeprecatedOperations_eWebrtcDeprecatedPrefix : root :: nsIDocument_DeprecatedOperations = 20 ; pub const nsIDocument_DeprecatedOperations_eRTCPeerConnectionGetStreams : root :: nsIDocument_DeprecatedOperations = 21 ; pub const nsIDocument_DeprecatedOperations_eAppCache : root :: nsIDocument_DeprecatedOperations = 22 ; pub const nsIDocument_DeprecatedOperations_ePrefixedImageSmoothingEnabled : root :: nsIDocument_DeprecatedOperations = 23 ; pub const nsIDocument_DeprecatedOperations_ePrefixedFullscreenAPI : root :: nsIDocument_DeprecatedOperations = 24 ; pub const nsIDocument_DeprecatedOperations_eLenientSetter : root :: nsIDocument_DeprecatedOperations = 25 ; pub const nsIDocument_DeprecatedOperations_eFileLastModifiedDate : root :: nsIDocument_DeprecatedOperations = 26 ; pub const nsIDocument_DeprecatedOperations_eImageBitmapRenderingContext_TransferImageBitmap : root :: nsIDocument_DeprecatedOperations = 27 ; pub const nsIDocument_DeprecatedOperations_eURLCreateObjectURL_MediaStream : root :: nsIDocument_DeprecatedOperations = 28 ; pub const nsIDocument_DeprecatedOperations_eXMLBaseAttribute : root :: nsIDocument_DeprecatedOperations = 29 ; pub const nsIDocument_DeprecatedOperations_eWindowContentUntrusted : root :: nsIDocument_DeprecatedOperations = 30 ; pub const nsIDocument_DeprecatedOperations_eDeprecatedOperationCount : root :: nsIDocument_DeprecatedOperations = 31 ; pub type nsIDocument_DeprecatedOperations = :: std :: os :: raw :: c_uint ; pub const nsIDocument_DocumentWarnings_eIgnoringWillChangeOverBudget : root :: nsIDocument_DocumentWarnings = 0 ; pub const nsIDocument_DocumentWarnings_ePreventDefaultFromPassiveListener : root :: nsIDocument_DocumentWarnings = 1 ; pub const nsIDocument_DocumentWarnings_eSVGRefLoop : root :: nsIDocument_DocumentWarnings = 2 ; pub const nsIDocument_DocumentWarnings_eSVGRefChainLengthExceeded : root :: nsIDocument_DocumentWarnings = 3 ; pub const nsIDocument_DocumentWarnings_eDocumentWarningCount : root :: nsIDocument_DocumentWarnings = 4 ; pub type nsIDocument_DocumentWarnings = :: std :: os :: raw :: c_uint ; pub const nsIDocument_ElementCallbackType_eConnected : root :: nsIDocument_ElementCallbackType = 0 ; pub const nsIDocument_ElementCallbackType_eDisconnected : root :: nsIDocument_ElementCallbackType = 1 ; pub const nsIDocument_ElementCallbackType_eAdopted : root :: nsIDocument_ElementCallbackType = 2 ; pub const nsIDocument_ElementCallbackType_eAttributeChanged : root :: nsIDocument_ElementCallbackType = 3 ; pub type nsIDocument_ElementCallbackType = :: std :: os :: raw :: c_uint ; pub const nsIDocument_eScopedStyle_Unknown : root :: nsIDocument__bindgen_ty_1 = 0 ; pub const nsIDocument_eScopedStyle_Disabled : root :: nsIDocument__bindgen_ty_1 = 1 ; pub const nsIDocument_eScopedStyle_Enabled : root :: nsIDocument__bindgen_ty_1 = 2 ; pub type nsIDocument__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsIDocument_Type { eUnknown = 0 , eHTML = 1 , eXHTML = 2 , eGenericXML = 3 , eSVG = 4 , eXUL = 5 , } pub const nsIDocument_Tri_eTriUnset : root :: nsIDocument_Tri = 0 ; pub const nsIDocument_Tri_eTriFalse : root :: nsIDocument_Tri = 1 ; pub const nsIDocument_Tri_eTriTrue : root :: nsIDocument_Tri = 2 ; pub type nsIDocument_Tri = :: std :: os :: raw :: c_uint ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIDocument_FrameRequest { _unused : [ u8 ; 0 ] } pub const nsIDocument_kSegmentSize : usize = 128 ; # [ test ] fn bindgen_test_layout_nsIDocument ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIDocument > ( ) , 952usize , concat ! ( "Size of: " , stringify ! ( nsIDocument ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIDocument > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIDocument ) ) ) ; } impl nsIDocument { # [ inline ] pub fn mBidiEnabled ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x1 as u64 ; let val = ( unit_field_val & mask ) >> 0usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mBidiEnabled ( & mut self , val : bool ) { let mask = 0x1 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 0usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mMathMLEnabled ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x2 as u64 ; let val = ( unit_field_val & mask ) >> 1usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mMathMLEnabled ( & mut self , val : bool ) { let mask = 0x2 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 1usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mIsInitialDocumentInWindow ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x4 as u64 ; let val = ( unit_field_val & mask ) >> 2usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIsInitialDocumentInWindow ( & mut self , val : bool ) { let mask = 0x4 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 2usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mIgnoreDocGroupMismatches ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x8 as u64 ; let val = ( unit_field_val & mask ) >> 3usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIgnoreDocGroupMismatches ( & mut self , val : bool ) { let mask = 0x8 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 3usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mLoadedAsData ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x10 as u64 ; let val = ( unit_field_val & mask ) >> 4usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mLoadedAsData ( & mut self , val : bool ) { let mask = 0x10 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 4usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mLoadedAsInteractiveData ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x20 as u64 ; let val = ( unit_field_val & mask ) >> 5usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mLoadedAsInteractiveData ( & mut self , val : bool ) { let mask = 0x20 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 5usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mMayStartLayout ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x40 as u64 ; let val = ( unit_field_val & mask ) >> 6usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mMayStartLayout ( & mut self , val : bool ) { let mask = 0x40 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 6usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mHaveFiredTitleChange ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x80 as u64 ; let val = ( unit_field_val & mask ) >> 7usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mHaveFiredTitleChange ( & mut self , val : bool ) { let mask = 0x80 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 7usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mIsShowing ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x100 as u64 ; let val = ( unit_field_val & mask ) >> 8usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIsShowing ( & mut self , val : bool ) { let mask = 0x100 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 8usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mVisible ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x200 as u64 ; let val = ( unit_field_val & mask ) >> 9usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mVisible ( & mut self , val : bool ) { let mask = 0x200 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 9usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mHasReferrerPolicyCSP ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x400 as u64 ; let val = ( unit_field_val & mask ) >> 10usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mHasReferrerPolicyCSP ( & mut self , val : bool ) { let mask = 0x400 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 10usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mRemovedFromDocShell ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x800 as u64 ; let val = ( unit_field_val & mask ) >> 11usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mRemovedFromDocShell ( & mut self , val : bool ) { let mask = 0x800 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 11usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mAllowDNSPrefetch ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x1000 as u64 ; let val = ( unit_field_val & mask ) >> 12usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mAllowDNSPrefetch ( & mut self , val : bool ) { let mask = 0x1000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 12usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mIsStaticDocument ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x2000 as u64 ; let val = ( unit_field_val & mask ) >> 13usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIsStaticDocument ( & mut self , val : bool ) { let mask = 0x2000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 13usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mCreatingStaticClone ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x4000 as u64 ; let val = ( unit_field_val & mask ) >> 14usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mCreatingStaticClone ( & mut self , val : bool ) { let mask = 0x4000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 14usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mInUnlinkOrDeletion ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x8000 as u64 ; let val = ( unit_field_val & mask ) >> 15usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mInUnlinkOrDeletion ( & mut self , val : bool ) { let mask = 0x8000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 15usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mHasHadScriptHandlingObject ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x10000 as u64 ; let val = ( unit_field_val & mask ) >> 16usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mHasHadScriptHandlingObject ( & mut self , val : bool ) { let mask = 0x10000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 16usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mIsBeingUsedAsImage ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x20000 as u64 ; let val = ( unit_field_val & mask ) >> 17usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIsBeingUsedAsImage ( & mut self , val : bool ) { let mask = 0x20000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 17usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mIsSyntheticDocument ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x40000 as u64 ; let val = ( unit_field_val & mask ) >> 18usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIsSyntheticDocument ( & mut self , val : bool ) { let mask = 0x40000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 18usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mHasLinksToUpdate ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x80000 as u64 ; let val = ( unit_field_val & mask ) >> 19usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mHasLinksToUpdate ( & mut self , val : bool ) { let mask = 0x80000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 19usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mHasLinksToUpdateRunnable ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x100000 as u64 ; let val = ( unit_field_val & mask ) >> 20usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mHasLinksToUpdateRunnable ( & mut self , val : bool ) { let mask = 0x100000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 20usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mMayHaveDOMMutationObservers ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x200000 as u64 ; let val = ( unit_field_val & mask ) >> 21usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mMayHaveDOMMutationObservers ( & mut self , val : bool ) { let mask = 0x200000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 21usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mMayHaveAnimationObservers ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x400000 as u64 ; let val = ( unit_field_val & mask ) >> 22usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mMayHaveAnimationObservers ( & mut self , val : bool ) { let mask = 0x400000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 22usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mHasMixedActiveContentLoaded ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x800000 as u64 ; let val = ( unit_field_val & mask ) >> 23usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mHasMixedActiveContentLoaded ( & mut self , val : bool ) { let mask = 0x800000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 23usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mHasMixedActiveContentBlocked ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x1000000 as u64 ; let val = ( unit_field_val & mask ) >> 24usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mHasMixedActiveContentBlocked ( & mut self , val : bool ) { let mask = 0x1000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 24usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mHasMixedDisplayContentLoaded ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x2000000 as u64 ; let val = ( unit_field_val & mask ) >> 25usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mHasMixedDisplayContentLoaded ( & mut self , val : bool ) { let mask = 0x2000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 25usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mHasMixedDisplayContentBlocked ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x4000000 as u64 ; let val = ( unit_field_val & mask ) >> 26usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mHasMixedDisplayContentBlocked ( & mut self , val : bool ) { let mask = 0x4000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 26usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mHasMixedContentObjectSubrequest ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x8000000 as u64 ; let val = ( unit_field_val & mask ) >> 27usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mHasMixedContentObjectSubrequest ( & mut self , val : bool ) { let mask = 0x8000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 27usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mHasCSP ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x10000000 as u64 ; let val = ( unit_field_val & mask ) >> 28usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mHasCSP ( & mut self , val : bool ) { let mask = 0x10000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 28usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mHasUnsafeEvalCSP ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x20000000 as u64 ; let val = ( unit_field_val & mask ) >> 29usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mHasUnsafeEvalCSP ( & mut self , val : bool ) { let mask = 0x20000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 29usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mHasUnsafeInlineCSP ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x40000000 as u64 ; let val = ( unit_field_val & mask ) >> 30usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mHasUnsafeInlineCSP ( & mut self , val : bool ) { let mask = 0x40000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 30usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mHasTrackingContentBlocked ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x80000000 as u64 ; let val = ( unit_field_val & mask ) >> 31usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mHasTrackingContentBlocked ( & mut self , val : bool ) { let mask = 0x80000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 31usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mHasTrackingContentLoaded ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x100000000 as u64 ; let val = ( unit_field_val & mask ) >> 32usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mHasTrackingContentLoaded ( & mut self , val : bool ) { let mask = 0x100000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 32usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mBFCacheDisallowed ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x200000000 as u64 ; let val = ( unit_field_val & mask ) >> 33usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mBFCacheDisallowed ( & mut self , val : bool ) { let mask = 0x200000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 33usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mHasHadDefaultView ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x400000000 as u64 ; let val = ( unit_field_val & mask ) >> 34usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mHasHadDefaultView ( & mut self , val : bool ) { let mask = 0x400000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 34usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mStyleSheetChangeEventsEnabled ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x800000000 as u64 ; let val = ( unit_field_val & mask ) >> 35usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mStyleSheetChangeEventsEnabled ( & mut self , val : bool ) { let mask = 0x800000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 35usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mIsSrcdocDocument ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x1000000000 as u64 ; let val = ( unit_field_val & mask ) >> 36usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIsSrcdocDocument ( & mut self , val : bool ) { let mask = 0x1000000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 36usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mDidDocumentOpen ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x2000000000 as u64 ; let val = ( unit_field_val & mask ) >> 37usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mDidDocumentOpen ( & mut self , val : bool ) { let mask = 0x2000000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 37usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mHasDisplayDocument ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x4000000000 as u64 ; let val = ( unit_field_val & mask ) >> 38usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mHasDisplayDocument ( & mut self , val : bool ) { let mask = 0x4000000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 38usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mFontFaceSetDirty ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x8000000000 as u64 ; let val = ( unit_field_val & mask ) >> 39usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mFontFaceSetDirty ( & mut self , val : bool ) { let mask = 0x8000000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 39usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mGetUserFontSetCalled ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x10000000000 as u64 ; let val = ( unit_field_val & mask ) >> 40usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mGetUserFontSetCalled ( & mut self , val : bool ) { let mask = 0x10000000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 40usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mPostedFlushUserFontSet ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x20000000000 as u64 ; let val = ( unit_field_val & mask ) >> 41usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mPostedFlushUserFontSet ( & mut self , val : bool ) { let mask = 0x20000000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 41usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mDidFireDOMContentLoaded ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x40000000000 as u64 ; let val = ( unit_field_val & mask ) >> 42usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mDidFireDOMContentLoaded ( & mut self , val : bool ) { let mask = 0x40000000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 42usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mHasScrollLinkedEffect ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x80000000000 as u64 ; let val = ( unit_field_val & mask ) >> 43usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mHasScrollLinkedEffect ( & mut self , val : bool ) { let mask = 0x80000000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 43usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mFrameRequestCallbacksScheduled ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x100000000000 as u64 ; let val = ( unit_field_val & mask ) >> 44usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mFrameRequestCallbacksScheduled ( & mut self , val : bool ) { let mask = 0x100000000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 44usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mIsTopLevelContentDocument ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x200000000000 as u64 ; let val = ( unit_field_val & mask ) >> 45usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIsTopLevelContentDocument ( & mut self , val : bool ) { let mask = 0x200000000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 45usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mIsContentDocument ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x400000000000 as u64 ; let val = ( unit_field_val & mask ) >> 46usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIsContentDocument ( & mut self , val : bool ) { let mask = 0x400000000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 46usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mDidCallBeginLoad ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x800000000000 as u64 ; let val = ( unit_field_val & mask ) >> 47usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mDidCallBeginLoad ( & mut self , val : bool ) { let mask = 0x800000000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 47usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mBufferingCSPViolations ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x1000000000000 as u64 ; let val = ( unit_field_val & mask ) >> 48usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mBufferingCSPViolations ( & mut self , val : bool ) { let mask = 0x1000000000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 48usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mAllowPaymentRequest ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x2000000000000 as u64 ; let val = ( unit_field_val & mask ) >> 49usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mAllowPaymentRequest ( & mut self , val : bool ) { let mask = 0x2000000000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 49usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mEncodingMenuDisabled ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x4000000000000 as u64 ; let val = ( unit_field_val & mask ) >> 50usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mEncodingMenuDisabled ( & mut self , val : bool ) { let mask = 0x4000000000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 50usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mIsWebComponentsEnabled ( & self ) -> bool { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x8000000000000 as u64 ; let val = ( unit_field_val & mask ) >> 51usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIsWebComponentsEnabled ( & mut self , val : bool ) { let mask = 0x8000000000000 as u64 ; let val = val as u8 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 51usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mIsScopedStyleEnabled ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x30000000000000 as u64 ; let val = ( unit_field_val & mask ) >> 52usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mIsScopedStyleEnabled ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x30000000000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 52usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn new_bitfield_1 ( mBidiEnabled : bool , mMathMLEnabled : bool , mIsInitialDocumentInWindow : bool , mIgnoreDocGroupMismatches : bool , mLoadedAsData : bool , mLoadedAsInteractiveData : bool , mMayStartLayout : bool , mHaveFiredTitleChange : bool , mIsShowing : bool , mVisible : bool , mHasReferrerPolicyCSP : bool , mRemovedFromDocShell : bool , mAllowDNSPrefetch : bool , mIsStaticDocument : bool , mCreatingStaticClone : bool , mInUnlinkOrDeletion : bool , mHasHadScriptHandlingObject : bool , mIsBeingUsedAsImage : bool , mIsSyntheticDocument : bool , mHasLinksToUpdate : bool , mHasLinksToUpdateRunnable : bool , mMayHaveDOMMutationObservers : bool , mMayHaveAnimationObservers : bool , mHasMixedActiveContentLoaded : bool , mHasMixedActiveContentBlocked : bool , mHasMixedDisplayContentLoaded : bool , mHasMixedDisplayContentBlocked : bool , mHasMixedContentObjectSubrequest : bool , mHasCSP : bool , mHasUnsafeEvalCSP : bool , mHasUnsafeInlineCSP : bool , mHasTrackingContentBlocked : bool , mHasTrackingContentLoaded : bool , mBFCacheDisallowed : bool , mHasHadDefaultView : bool , mStyleSheetChangeEventsEnabled : bool , mIsSrcdocDocument : bool , mDidDocumentOpen : bool , mHasDisplayDocument : bool , mFontFaceSetDirty : bool , mGetUserFontSetCalled : bool , mPostedFlushUserFontSet : bool , mDidFireDOMContentLoaded : bool , mHasScrollLinkedEffect : bool , mFrameRequestCallbacksScheduled : bool , mIsTopLevelContentDocument : bool , mIsContentDocument : bool , mDidCallBeginLoad : bool , mBufferingCSPViolations : bool , mAllowPaymentRequest : bool , mEncodingMenuDisabled : bool , mIsWebComponentsEnabled : bool , mIsScopedStyleEnabled : :: std :: os :: raw :: c_uint ) -> u64 { ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( 0 | ( ( mBidiEnabled as u8 as u64 ) << 0usize ) & ( 0x1 as u64 ) ) | ( ( mMathMLEnabled as u8 as u64 ) << 1usize ) & ( 0x2 as u64 ) ) | ( ( mIsInitialDocumentInWindow as u8 as u64 ) << 2usize ) & ( 0x4 as u64 ) ) | ( ( mIgnoreDocGroupMismatches as u8 as u64 ) << 3usize ) & ( 0x8 as u64 ) ) | ( ( mLoadedAsData as u8 as u64 ) << 4usize ) & ( 0x10 as u64 ) ) | ( ( mLoadedAsInteractiveData as u8 as u64 ) << 5usize ) & ( 0x20 as u64 ) ) | ( ( mMayStartLayout as u8 as u64 ) << 6usize ) & ( 0x40 as u64 ) ) | ( ( mHaveFiredTitleChange as u8 as u64 ) << 7usize ) & ( 0x80 as u64 ) ) | ( ( mIsShowing as u8 as u64 ) << 8usize ) & ( 0x100 as u64 ) ) | ( ( mVisible as u8 as u64 ) << 9usize ) & ( 0x200 as u64 ) ) | ( ( mHasReferrerPolicyCSP as u8 as u64 ) << 10usize ) & ( 0x400 as u64 ) ) | ( ( mRemovedFromDocShell as u8 as u64 ) << 11usize ) & ( 0x800 as u64 ) ) | ( ( mAllowDNSPrefetch as u8 as u64 ) << 12usize ) & ( 0x1000 as u64 ) ) | ( ( mIsStaticDocument as u8 as u64 ) << 13usize ) & ( 0x2000 as u64 ) ) | ( ( mCreatingStaticClone as u8 as u64 ) << 14usize ) & ( 0x4000 as u64 ) ) | ( ( mInUnlinkOrDeletion as u8 as u64 ) << 15usize ) & ( 0x8000 as u64 ) ) | ( ( mHasHadScriptHandlingObject as u8 as u64 ) << 16usize ) & ( 0x10000 as u64 ) ) | ( ( mIsBeingUsedAsImage as u8 as u64 ) << 17usize ) & ( 0x20000 as u64 ) ) | ( ( mIsSyntheticDocument as u8 as u64 ) << 18usize ) & ( 0x40000 as u64 ) ) | ( ( mHasLinksToUpdate as u8 as u64 ) << 19usize ) & ( 0x80000 as u64 ) ) | ( ( mHasLinksToUpdateRunnable as u8 as u64 ) << 20usize ) & ( 0x100000 as u64 ) ) | ( ( mMayHaveDOMMutationObservers as u8 as u64 ) << 21usize ) & ( 0x200000 as u64 ) ) | ( ( mMayHaveAnimationObservers as u8 as u64 ) << 22usize ) & ( 0x400000 as u64 ) ) | ( ( mHasMixedActiveContentLoaded as u8 as u64 ) << 23usize ) & ( 0x800000 as u64 ) ) | ( ( mHasMixedActiveContentBlocked as u8 as u64 ) << 24usize ) & ( 0x1000000 as u64 ) ) | ( ( mHasMixedDisplayContentLoaded as u8 as u64 ) << 25usize ) & ( 0x2000000 as u64 ) ) | ( ( mHasMixedDisplayContentBlocked as u8 as u64 ) << 26usize ) & ( 0x4000000 as u64 ) ) | ( ( mHasMixedContentObjectSubrequest as u8 as u64 ) << 27usize ) & ( 0x8000000 as u64 ) ) | ( ( mHasCSP as u8 as u64 ) << 28usize ) & ( 0x10000000 as u64 ) ) | ( ( mHasUnsafeEvalCSP as u8 as u64 ) << 29usize ) & ( 0x20000000 as u64 ) ) | ( ( mHasUnsafeInlineCSP as u8 as u64 ) << 30usize ) & ( 0x40000000 as u64 ) ) | ( ( mHasTrackingContentBlocked as u8 as u64 ) << 31usize ) & ( 0x80000000 as u64 ) ) | ( ( mHasTrackingContentLoaded as u8 as u64 ) << 32usize ) & ( 0x100000000 as u64 ) ) | ( ( mBFCacheDisallowed as u8 as u64 ) << 33usize ) & ( 0x200000000 as u64 ) ) | ( ( mHasHadDefaultView as u8 as u64 ) << 34usize ) & ( 0x400000000 as u64 ) ) | ( ( mStyleSheetChangeEventsEnabled as u8 as u64 ) << 35usize ) & ( 0x800000000 as u64 ) ) | ( ( mIsSrcdocDocument as u8 as u64 ) << 36usize ) & ( 0x1000000000 as u64 ) ) | ( ( mDidDocumentOpen as u8 as u64 ) << 37usize ) & ( 0x2000000000 as u64 ) ) | ( ( mHasDisplayDocument as u8 as u64 ) << 38usize ) & ( 0x4000000000 as u64 ) ) | ( ( mFontFaceSetDirty as u8 as u64 ) << 39usize ) & ( 0x8000000000 as u64 ) ) | ( ( mGetUserFontSetCalled as u8 as u64 ) << 40usize ) & ( 0x10000000000 as u64 ) ) | ( ( mPostedFlushUserFontSet as u8 as u64 ) << 41usize ) & ( 0x20000000000 as u64 ) ) | ( ( mDidFireDOMContentLoaded as u8 as u64 ) << 42usize ) & ( 0x40000000000 as u64 ) ) | ( ( mHasScrollLinkedEffect as u8 as u64 ) << 43usize ) & ( 0x80000000000 as u64 ) ) | ( ( mFrameRequestCallbacksScheduled as u8 as u64 ) << 44usize ) & ( 0x100000000000 as u64 ) ) | ( ( mIsTopLevelContentDocument as u8 as u64 ) << 45usize ) & ( 0x200000000000 as u64 ) ) | ( ( mIsContentDocument as u8 as u64 ) << 46usize ) & ( 0x400000000000 as u64 ) ) | ( ( mDidCallBeginLoad as u8 as u64 ) << 47usize ) & ( 0x800000000000 as u64 ) ) | ( ( mBufferingCSPViolations as u8 as u64 ) << 48usize ) & ( 0x1000000000000 as u64 ) ) | ( ( mAllowPaymentRequest as u8 as u64 ) << 49usize ) & ( 0x2000000000000 as u64 ) ) | ( ( mEncodingMenuDisabled as u8 as u64 ) << 50usize ) & ( 0x4000000000000 as u64 ) ) | ( ( mIsWebComponentsEnabled as u8 as u64 ) << 51usize ) & ( 0x8000000000000 as u64 ) ) | ( ( mIsScopedStyleEnabled as u32 as u64 ) << 52usize ) & ( 0x30000000000000 as u64 ) ) } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsBidi { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIPrintSettings { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct gfxTextPerfMetrics { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsTransitionManager { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsAnimationManager { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsDeviceContext { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct gfxMissingFontRecorder { _unused : [ u8 ; 0 ] } pub const kPresContext_DefaultVariableFont_ID : u8 = 0 ; pub const kPresContext_DefaultFixedFont_ID : u8 = 1 ; # [ repr ( C ) ] pub struct nsPresContext { pub _base : root :: nsISupports , pub _base_1 : u64 , pub mRefCnt : root :: nsCycleCollectingAutoRefCnt , pub mType : root :: nsPresContext_nsPresContextType , pub mShell : * mut root :: nsIPresShell , pub mDocument : root :: nsCOMPtr , pub mDeviceContext : root :: RefPtr < root :: nsDeviceContext > , pub mEventManager : root :: RefPtr < root :: mozilla :: EventStateManager > , pub mRefreshDriver : root :: RefPtr < root :: nsRefreshDriver > , pub mEffectCompositor : root :: RefPtr < root :: mozilla :: EffectCompositor > , pub mTransitionManager : root :: RefPtr < root :: nsTransitionManager > , pub mAnimationManager : root :: RefPtr < root :: nsAnimationManager > , pub mRestyleManager : root :: RefPtr < root :: mozilla :: RestyleManager > , pub mCounterStyleManager : root :: RefPtr < root :: mozilla :: CounterStyleManager > , pub mMedium : * mut root :: nsAtom , pub mMediaEmulated : root :: RefPtr < root :: nsAtom > , pub mFontFeatureValuesLookup : root :: RefPtr < root :: gfxFontFeatureValueSet > , pub mLinkHandler : * mut root :: nsILinkHandler , pub mLanguage : root :: RefPtr < root :: nsAtom > , pub mInflationDisabledForShrinkWrap : bool , pub mContainer : u64 , pub mBaseMinFontSize : i32 , pub mSystemFontScale : f32 , pub mTextZoom : f32 , pub mEffectiveTextZoom : f32 , pub mFullZoom : f32 , pub mOverrideDPPX : f32 , pub mLastFontInflationScreenSize : root :: gfxSize , pub mCurAppUnitsPerDevPixel : i32 , pub mAutoQualityMinFontSizePixelsPref : i32 , pub mTheme : root :: nsCOMPtr , pub mLangService : * mut root :: nsLanguageAtomService , pub mPrintSettings : root :: nsCOMPtr , pub mPrefChangedTimer : root :: nsCOMPtr , pub mBidiEngine : root :: mozilla :: UniquePtr < root :: nsBidi > , pub mTransactions : [ u64 ; 10usize ] , pub mTextPerf : root :: nsAutoPtr < root :: gfxTextPerfMetrics > , pub mMissingFonts : root :: nsAutoPtr < root :: gfxMissingFontRecorder > , pub mVisibleArea : root :: nsRect , pub mLastResizeEventVisibleArea : root :: nsRect , pub mPageSize : root :: nsSize , pub mPageScale : f32 , pub mPPScale : f32 , pub mDefaultColor : root :: nscolor , pub mBackgroundColor : root :: nscolor , pub mLinkColor : root :: nscolor , pub mActiveLinkColor : root :: nscolor , pub mVisitedLinkColor : root :: nscolor , pub mFocusBackgroundColor : root :: nscolor , pub mFocusTextColor : root :: nscolor , pub mBodyTextColor : root :: nscolor , pub mViewportScrollbarOverrideElement : * mut root :: mozilla :: dom :: Element , pub mViewportStyleScrollbar : root :: nsPresContext_ScrollbarStyles , pub mFocusRingWidth : u8 , pub mExistThrottledUpdates : bool , pub mImageAnimationMode : u16 , pub mImageAnimationModePref : u16 , pub mLangGroupFontPrefs : root :: nsPresContext_LangGroupFontPrefs , pub mFontGroupCacheDirty : bool , pub mLanguagesUsed : [ u64 ; 4usize ] , pub mBorderWidthTable : [ root :: nscoord ; 3usize ] , pub mInterruptChecksToSkip : u32 , pub mElementsRestyled : u64 , pub mFramesConstructed : u64 , pub mFramesReflowed : u64 , pub mReflowStartTime : root :: mozilla :: TimeStamp , pub mFirstNonBlankPaintTime : root :: mozilla :: TimeStamp , pub mFirstClickTime : root :: mozilla :: TimeStamp , pub mFirstKeyTime : root :: mozilla :: TimeStamp , pub mFirstMouseMoveTime : root :: mozilla :: TimeStamp , pub mFirstScrollTime : root :: mozilla :: TimeStamp , pub mInteractionTimeEnabled : bool , pub mLastStyleUpdateForAllAnimations : root :: mozilla :: TimeStamp , pub mTelemetryScrollLastY : root :: nscoord , pub mTelemetryScrollMaxY : root :: nscoord , pub mTelemetryScrollTotalY : root :: nscoord , pub _bitfield_1 : [ u8 ; 6usize ] , pub __bindgen_padding_0 : [ u16 ; 3usize ] , } pub type nsPresContext_Encoding = root :: mozilla :: Encoding ; pub type nsPresContext_NotNull < T > = root :: mozilla :: NotNull < T > ; pub type nsPresContext_LangGroupFontPrefs = root :: mozilla :: LangGroupFontPrefs ; pub type nsPresContext_ScrollbarStyles = root :: mozilla :: ScrollbarStyles ; pub type nsPresContext_StaticPresData = root :: mozilla :: StaticPresData ; pub type nsPresContext_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsPresContext_cycleCollection { pub _base : root :: nsXPCOMCycleCollectionParticipant , } # [ test ] fn bindgen_test_layout_nsPresContext_cycleCollection ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsPresContext_cycleCollection > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsPresContext_cycleCollection ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsPresContext_cycleCollection > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsPresContext_cycleCollection ) ) ) ; } impl Clone for nsPresContext_cycleCollection { fn clone ( & self ) -> Self { * self } } pub const nsPresContext_nsPresContextType_eContext_Galley : root :: nsPresContext_nsPresContextType = 0 ; pub const nsPresContext_nsPresContextType_eContext_PrintPreview : root :: nsPresContext_nsPresContextType = 1 ; pub const nsPresContext_nsPresContextType_eContext_Print : root :: nsPresContext_nsPresContextType = 2 ; pub const nsPresContext_nsPresContextType_eContext_PageLayout : root :: nsPresContext_nsPresContextType = 3 ; pub type nsPresContext_nsPresContextType = :: std :: os :: raw :: c_uint ; pub const nsPresContext_InteractionType_eClickInteraction : root :: nsPresContext_InteractionType = 0 ; pub const nsPresContext_InteractionType_eKeyInteraction : root :: nsPresContext_InteractionType = 1 ; pub const nsPresContext_InteractionType_eMouseMoveInteraction : root :: nsPresContext_InteractionType = 2 ; pub const nsPresContext_InteractionType_eScrollInteraction : root :: nsPresContext_InteractionType = 3 ; pub type nsPresContext_InteractionType = u32 ; 
 /// A class that can be used to temporarily disable reflow interruption. 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsPresContext_InterruptPreventer { pub mCtx : * mut root :: nsPresContext , pub mInterruptsEnabled : bool , pub mHasPendingInterrupt : bool , } # [ test ] fn bindgen_test_layout_nsPresContext_InterruptPreventer ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsPresContext_InterruptPreventer > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsPresContext_InterruptPreventer ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsPresContext_InterruptPreventer > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsPresContext_InterruptPreventer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext_InterruptPreventer ) ) . mCtx as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext_InterruptPreventer ) , "::" , stringify ! ( mCtx ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext_InterruptPreventer ) ) . mInterruptsEnabled as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext_InterruptPreventer ) , "::" , stringify ! ( mInterruptsEnabled ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext_InterruptPreventer ) ) . mHasPendingInterrupt as * const _ as usize } , 9usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext_InterruptPreventer ) , "::" , stringify ! ( mHasPendingInterrupt ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsPresContext_TransactionInvalidations { pub mTransactionId : u64 , pub mInvalidations : root :: nsTArray < root :: nsRect > , } # [ test ] fn bindgen_test_layout_nsPresContext_TransactionInvalidations ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsPresContext_TransactionInvalidations > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsPresContext_TransactionInvalidations ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsPresContext_TransactionInvalidations > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsPresContext_TransactionInvalidations ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext_TransactionInvalidations ) ) . mTransactionId as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext_TransactionInvalidations ) , "::" , stringify ! ( mTransactionId ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext_TransactionInvalidations ) ) . mInvalidations as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext_TransactionInvalidations ) , "::" , stringify ! ( mInvalidations ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}_ZN13nsPresContext21_cycleCollectorGlobalE" ] 
 pub static mut  nsPresContext__cycleCollectorGlobal  :  root :: nsPresContext_cycleCollection ;
} # [ test ] fn bindgen_test_layout_nsPresContext ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsPresContext > ( ) , 1376usize , concat ! ( "Size of: " , stringify ! ( nsPresContext ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsPresContext > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsPresContext ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mRefCnt as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mType as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mType ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mShell as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mShell ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mDocument as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mDocument ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mDeviceContext as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mDeviceContext ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mEventManager as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mEventManager ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mRefreshDriver as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mRefreshDriver ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mEffectCompositor as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mEffectCompositor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mTransitionManager as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mTransitionManager ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mAnimationManager as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mAnimationManager ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mRestyleManager as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mRestyleManager ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mCounterStyleManager as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mCounterStyleManager ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mMedium as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mMedium ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mMediaEmulated as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mMediaEmulated ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mFontFeatureValuesLookup as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mFontFeatureValuesLookup ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mLinkHandler as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mLinkHandler ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mLanguage as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mLanguage ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mInflationDisabledForShrinkWrap as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mInflationDisabledForShrinkWrap ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mContainer as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mContainer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mBaseMinFontSize as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mBaseMinFontSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mSystemFontScale as * const _ as usize } , 172usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mSystemFontScale ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mTextZoom as * const _ as usize } , 176usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mTextZoom ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mEffectiveTextZoom as * const _ as usize } , 180usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mEffectiveTextZoom ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mFullZoom as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mFullZoom ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mOverrideDPPX as * const _ as usize } , 188usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mOverrideDPPX ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mLastFontInflationScreenSize as * const _ as usize } , 192usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mLastFontInflationScreenSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mCurAppUnitsPerDevPixel as * const _ as usize } , 208usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mCurAppUnitsPerDevPixel ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mAutoQualityMinFontSizePixelsPref as * const _ as usize } , 212usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mAutoQualityMinFontSizePixelsPref ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mTheme as * const _ as usize } , 216usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mTheme ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mLangService as * const _ as usize } , 224usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mLangService ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mPrintSettings as * const _ as usize } , 232usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mPrintSettings ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mPrefChangedTimer as * const _ as usize } , 240usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mPrefChangedTimer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mBidiEngine as * const _ as usize } , 248usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mBidiEngine ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mTransactions as * const _ as usize } , 256usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mTransactions ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mTextPerf as * const _ as usize } , 336usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mTextPerf ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mMissingFonts as * const _ as usize } , 344usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mMissingFonts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mVisibleArea as * const _ as usize } , 352usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mVisibleArea ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mLastResizeEventVisibleArea as * const _ as usize } , 368usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mLastResizeEventVisibleArea ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mPageSize as * const _ as usize } , 384usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mPageSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mPageScale as * const _ as usize } , 392usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mPageScale ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mPPScale as * const _ as usize } , 396usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mPPScale ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mDefaultColor as * const _ as usize } , 400usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mDefaultColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mBackgroundColor as * const _ as usize } , 404usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mBackgroundColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mLinkColor as * const _ as usize } , 408usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mLinkColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mActiveLinkColor as * const _ as usize } , 412usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mActiveLinkColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mVisitedLinkColor as * const _ as usize } , 416usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mVisitedLinkColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mFocusBackgroundColor as * const _ as usize } , 420usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mFocusBackgroundColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mFocusTextColor as * const _ as usize } , 424usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mFocusTextColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mBodyTextColor as * const _ as usize } , 428usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mBodyTextColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mViewportScrollbarOverrideElement as * const _ as usize } , 432usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mViewportScrollbarOverrideElement ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mViewportStyleScrollbar as * const _ as usize } , 440usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mViewportStyleScrollbar ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mFocusRingWidth as * const _ as usize } , 504usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mFocusRingWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mExistThrottledUpdates as * const _ as usize } , 505usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mExistThrottledUpdates ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mImageAnimationMode as * const _ as usize } , 506usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mImageAnimationMode ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mImageAnimationModePref as * const _ as usize } , 508usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mImageAnimationModePref ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mLangGroupFontPrefs as * const _ as usize } , 512usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mLangGroupFontPrefs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mFontGroupCacheDirty as * const _ as usize } , 1208usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mFontGroupCacheDirty ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mLanguagesUsed as * const _ as usize } , 1216usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mLanguagesUsed ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mBorderWidthTable as * const _ as usize } , 1248usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mBorderWidthTable ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mInterruptChecksToSkip as * const _ as usize } , 1260usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mInterruptChecksToSkip ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mElementsRestyled as * const _ as usize } , 1264usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mElementsRestyled ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mFramesConstructed as * const _ as usize } , 1272usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mFramesConstructed ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mFramesReflowed as * const _ as usize } , 1280usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mFramesReflowed ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mReflowStartTime as * const _ as usize } , 1288usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mReflowStartTime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mFirstNonBlankPaintTime as * const _ as usize } , 1296usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mFirstNonBlankPaintTime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mFirstClickTime as * const _ as usize } , 1304usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mFirstClickTime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mFirstKeyTime as * const _ as usize } , 1312usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mFirstKeyTime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mFirstMouseMoveTime as * const _ as usize } , 1320usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mFirstMouseMoveTime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mFirstScrollTime as * const _ as usize } , 1328usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mFirstScrollTime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mInteractionTimeEnabled as * const _ as usize } , 1336usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mInteractionTimeEnabled ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mLastStyleUpdateForAllAnimations as * const _ as usize } , 1344usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mLastStyleUpdateForAllAnimations ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mTelemetryScrollLastY as * const _ as usize } , 1352usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mTelemetryScrollLastY ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mTelemetryScrollMaxY as * const _ as usize } , 1356usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mTelemetryScrollMaxY ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPresContext ) ) . mTelemetryScrollTotalY as * const _ as usize } , 1360usize , concat ! ( "Alignment of field: " , stringify ! ( nsPresContext ) , "::" , stringify ! ( mTelemetryScrollTotalY ) ) ) ; } impl nsPresContext { # [ inline ] pub fn mHasPendingInterrupt ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x1 as u64 ; let val = ( unit_field_val & mask ) >> 0usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mHasPendingInterrupt ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x1 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 0usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mPendingInterruptFromTest ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x2 as u64 ; let val = ( unit_field_val & mask ) >> 1usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mPendingInterruptFromTest ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x2 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 1usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mInterruptsEnabled ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x4 as u64 ; let val = ( unit_field_val & mask ) >> 2usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mInterruptsEnabled ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x4 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 2usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mUseDocumentFonts ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x8 as u64 ; let val = ( unit_field_val & mask ) >> 3usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mUseDocumentFonts ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x8 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 3usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mUseDocumentColors ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x10 as u64 ; let val = ( unit_field_val & mask ) >> 4usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mUseDocumentColors ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x10 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 4usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mUnderlineLinks ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x20 as u64 ; let val = ( unit_field_val & mask ) >> 5usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mUnderlineLinks ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x20 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 5usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mSendAfterPaintToContent ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x40 as u64 ; let val = ( unit_field_val & mask ) >> 6usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mSendAfterPaintToContent ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x40 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 6usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mUseFocusColors ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x80 as u64 ; let val = ( unit_field_val & mask ) >> 7usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mUseFocusColors ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x80 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 7usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mFocusRingOnAnything ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x100 as u64 ; let val = ( unit_field_val & mask ) >> 8usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mFocusRingOnAnything ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x100 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 8usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mFocusRingStyle ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x200 as u64 ; let val = ( unit_field_val & mask ) >> 9usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mFocusRingStyle ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x200 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 9usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mDrawImageBackground ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x400 as u64 ; let val = ( unit_field_val & mask ) >> 10usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mDrawImageBackground ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x400 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 10usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mDrawColorBackground ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x800 as u64 ; let val = ( unit_field_val & mask ) >> 11usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mDrawColorBackground ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x800 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 11usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mNeverAnimate ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x1000 as u64 ; let val = ( unit_field_val & mask ) >> 12usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mNeverAnimate ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x1000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 12usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mIsRenderingOnlySelection ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x2000 as u64 ; let val = ( unit_field_val & mask ) >> 13usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mIsRenderingOnlySelection ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x2000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 13usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mPaginated ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x4000 as u64 ; let val = ( unit_field_val & mask ) >> 14usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mPaginated ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x4000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 14usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mCanPaginatedScroll ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x8000 as u64 ; let val = ( unit_field_val & mask ) >> 15usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mCanPaginatedScroll ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x8000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 15usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mDoScaledTwips ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x10000 as u64 ; let val = ( unit_field_val & mask ) >> 16usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mDoScaledTwips ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x10000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 16usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mIsRootPaginatedDocument ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x20000 as u64 ; let val = ( unit_field_val & mask ) >> 17usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mIsRootPaginatedDocument ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x20000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 17usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mPrefBidiDirection ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x40000 as u64 ; let val = ( unit_field_val & mask ) >> 18usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mPrefBidiDirection ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x40000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 18usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mPrefScrollbarSide ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x180000 as u64 ; let val = ( unit_field_val & mask ) >> 19usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mPrefScrollbarSide ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x180000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 19usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mPendingSysColorChanged ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x200000 as u64 ; let val = ( unit_field_val & mask ) >> 21usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mPendingSysColorChanged ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x200000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 21usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mPendingThemeChanged ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x400000 as u64 ; let val = ( unit_field_val & mask ) >> 22usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mPendingThemeChanged ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x400000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 22usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mPendingUIResolutionChanged ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x800000 as u64 ; let val = ( unit_field_val & mask ) >> 23usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mPendingUIResolutionChanged ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x800000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 23usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mPendingMediaFeatureValuesChanged ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x1000000 as u64 ; let val = ( unit_field_val & mask ) >> 24usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mPendingMediaFeatureValuesChanged ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x1000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 24usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mPrefChangePendingNeedsReflow ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x2000000 as u64 ; let val = ( unit_field_val & mask ) >> 25usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mPrefChangePendingNeedsReflow ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x2000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 25usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mIsEmulatingMedia ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x4000000 as u64 ; let val = ( unit_field_val & mask ) >> 26usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mIsEmulatingMedia ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x4000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 26usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mIsGlyph ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x8000000 as u64 ; let val = ( unit_field_val & mask ) >> 27usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mIsGlyph ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x8000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 27usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mUsesRootEMUnits ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x10000000 as u64 ; let val = ( unit_field_val & mask ) >> 28usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mUsesRootEMUnits ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x10000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 28usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mUsesExChUnits ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x20000000 as u64 ; let val = ( unit_field_val & mask ) >> 29usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mUsesExChUnits ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x20000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 29usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mPendingViewportChange ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x40000000 as u64 ; let val = ( unit_field_val & mask ) >> 30usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mPendingViewportChange ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x40000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 30usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mCounterStylesDirty ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x80000000 as u64 ; let val = ( unit_field_val & mask ) >> 31usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mCounterStylesDirty ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x80000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 31usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mPostedFlushCounterStyles ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x100000000 as u64 ; let val = ( unit_field_val & mask ) >> 32usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mPostedFlushCounterStyles ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x100000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 32usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mFontFeatureValuesDirty ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x200000000 as u64 ; let val = ( unit_field_val & mask ) >> 33usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mFontFeatureValuesDirty ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x200000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 33usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mPostedFlushFontFeatureValues ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x400000000 as u64 ; let val = ( unit_field_val & mask ) >> 34usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mPostedFlushFontFeatureValues ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x400000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 34usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mSuppressResizeReflow ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x800000000 as u64 ; let val = ( unit_field_val & mask ) >> 35usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mSuppressResizeReflow ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x800000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 35usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mIsVisual ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x1000000000 as u64 ; let val = ( unit_field_val & mask ) >> 36usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mIsVisual ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x1000000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 36usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mFireAfterPaintEvents ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x2000000000 as u64 ; let val = ( unit_field_val & mask ) >> 37usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mFireAfterPaintEvents ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x2000000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 37usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mIsChrome ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x4000000000 as u64 ; let val = ( unit_field_val & mask ) >> 38usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mIsChrome ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x4000000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 38usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mIsChromeOriginImage ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x8000000000 as u64 ; let val = ( unit_field_val & mask ) >> 39usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mIsChromeOriginImage ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x8000000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 39usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mPaintFlashing ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x10000000000 as u64 ; let val = ( unit_field_val & mask ) >> 40usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mPaintFlashing ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x10000000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 40usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mPaintFlashingInitialized ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x20000000000 as u64 ; let val = ( unit_field_val & mask ) >> 41usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mPaintFlashingInitialized ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x20000000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 41usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mHasWarnedAboutPositionedTableParts ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x40000000000 as u64 ; let val = ( unit_field_val & mask ) >> 42usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mHasWarnedAboutPositionedTableParts ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x40000000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 42usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mHasWarnedAboutTooLargeDashedOrDottedRadius ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x80000000000 as u64 ; let val = ( unit_field_val & mask ) >> 43usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mHasWarnedAboutTooLargeDashedOrDottedRadius ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x80000000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 43usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mQuirkSheetAdded ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x100000000000 as u64 ; let val = ( unit_field_val & mask ) >> 44usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mQuirkSheetAdded ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x100000000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 44usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mNeedsPrefUpdate ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x200000000000 as u64 ; let val = ( unit_field_val & mask ) >> 45usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mNeedsPrefUpdate ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x200000000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 45usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn mHadNonBlankPaint ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; let mask = 0x400000000000 as u64 ; let val = ( unit_field_val & mask ) >> 46usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_mHadNonBlankPaint ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x400000000000 as u64 ; let val = val as u32 as u64 ; let mut unit_field_val : u64 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u64 as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 46usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u64 > ( ) , ) ; } } # [ inline ] pub fn new_bitfield_1 ( mHasPendingInterrupt : :: std :: os :: raw :: c_uint , mPendingInterruptFromTest : :: std :: os :: raw :: c_uint , mInterruptsEnabled : :: std :: os :: raw :: c_uint , mUseDocumentFonts : :: std :: os :: raw :: c_uint , mUseDocumentColors : :: std :: os :: raw :: c_uint , mUnderlineLinks : :: std :: os :: raw :: c_uint , mSendAfterPaintToContent : :: std :: os :: raw :: c_uint , mUseFocusColors : :: std :: os :: raw :: c_uint , mFocusRingOnAnything : :: std :: os :: raw :: c_uint , mFocusRingStyle : :: std :: os :: raw :: c_uint , mDrawImageBackground : :: std :: os :: raw :: c_uint , mDrawColorBackground : :: std :: os :: raw :: c_uint , mNeverAnimate : :: std :: os :: raw :: c_uint , mIsRenderingOnlySelection : :: std :: os :: raw :: c_uint , mPaginated : :: std :: os :: raw :: c_uint , mCanPaginatedScroll : :: std :: os :: raw :: c_uint , mDoScaledTwips : :: std :: os :: raw :: c_uint , mIsRootPaginatedDocument : :: std :: os :: raw :: c_uint , mPrefBidiDirection : :: std :: os :: raw :: c_uint , mPrefScrollbarSide : :: std :: os :: raw :: c_uint , mPendingSysColorChanged : :: std :: os :: raw :: c_uint , mPendingThemeChanged : :: std :: os :: raw :: c_uint , mPendingUIResolutionChanged : :: std :: os :: raw :: c_uint , mPendingMediaFeatureValuesChanged : :: std :: os :: raw :: c_uint , mPrefChangePendingNeedsReflow : :: std :: os :: raw :: c_uint , mIsEmulatingMedia : :: std :: os :: raw :: c_uint , mIsGlyph : :: std :: os :: raw :: c_uint , mUsesRootEMUnits : :: std :: os :: raw :: c_uint , mUsesExChUnits : :: std :: os :: raw :: c_uint , mPendingViewportChange : :: std :: os :: raw :: c_uint , mCounterStylesDirty : :: std :: os :: raw :: c_uint , mPostedFlushCounterStyles : :: std :: os :: raw :: c_uint , mFontFeatureValuesDirty : :: std :: os :: raw :: c_uint , mPostedFlushFontFeatureValues : :: std :: os :: raw :: c_uint , mSuppressResizeReflow : :: std :: os :: raw :: c_uint , mIsVisual : :: std :: os :: raw :: c_uint , mFireAfterPaintEvents : :: std :: os :: raw :: c_uint , mIsChrome : :: std :: os :: raw :: c_uint , mIsChromeOriginImage : :: std :: os :: raw :: c_uint , mPaintFlashing : :: std :: os :: raw :: c_uint , mPaintFlashingInitialized : :: std :: os :: raw :: c_uint , mHasWarnedAboutPositionedTableParts : :: std :: os :: raw :: c_uint , mHasWarnedAboutTooLargeDashedOrDottedRadius : :: std :: os :: raw :: c_uint , mQuirkSheetAdded : :: std :: os :: raw :: c_uint , mNeedsPrefUpdate : :: std :: os :: raw :: c_uint , mHadNonBlankPaint : :: std :: os :: raw :: c_uint ) -> u64 { ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( 0 | ( ( mHasPendingInterrupt as u32 as u64 ) << 0usize ) & ( 0x1 as u64 ) ) | ( ( mPendingInterruptFromTest as u32 as u64 ) << 1usize ) & ( 0x2 as u64 ) ) | ( ( mInterruptsEnabled as u32 as u64 ) << 2usize ) & ( 0x4 as u64 ) ) | ( ( mUseDocumentFonts as u32 as u64 ) << 3usize ) & ( 0x8 as u64 ) ) | ( ( mUseDocumentColors as u32 as u64 ) << 4usize ) & ( 0x10 as u64 ) ) | ( ( mUnderlineLinks as u32 as u64 ) << 5usize ) & ( 0x20 as u64 ) ) | ( ( mSendAfterPaintToContent as u32 as u64 ) << 6usize ) & ( 0x40 as u64 ) ) | ( ( mUseFocusColors as u32 as u64 ) << 7usize ) & ( 0x80 as u64 ) ) | ( ( mFocusRingOnAnything as u32 as u64 ) << 8usize ) & ( 0x100 as u64 ) ) | ( ( mFocusRingStyle as u32 as u64 ) << 9usize ) & ( 0x200 as u64 ) ) | ( ( mDrawImageBackground as u32 as u64 ) << 10usize ) & ( 0x400 as u64 ) ) | ( ( mDrawColorBackground as u32 as u64 ) << 11usize ) & ( 0x800 as u64 ) ) | ( ( mNeverAnimate as u32 as u64 ) << 12usize ) & ( 0x1000 as u64 ) ) | ( ( mIsRenderingOnlySelection as u32 as u64 ) << 13usize ) & ( 0x2000 as u64 ) ) | ( ( mPaginated as u32 as u64 ) << 14usize ) & ( 0x4000 as u64 ) ) | ( ( mCanPaginatedScroll as u32 as u64 ) << 15usize ) & ( 0x8000 as u64 ) ) | ( ( mDoScaledTwips as u32 as u64 ) << 16usize ) & ( 0x10000 as u64 ) ) | ( ( mIsRootPaginatedDocument as u32 as u64 ) << 17usize ) & ( 0x20000 as u64 ) ) | ( ( mPrefBidiDirection as u32 as u64 ) << 18usize ) & ( 0x40000 as u64 ) ) | ( ( mPrefScrollbarSide as u32 as u64 ) << 19usize ) & ( 0x180000 as u64 ) ) | ( ( mPendingSysColorChanged as u32 as u64 ) << 21usize ) & ( 0x200000 as u64 ) ) | ( ( mPendingThemeChanged as u32 as u64 ) << 22usize ) & ( 0x400000 as u64 ) ) | ( ( mPendingUIResolutionChanged as u32 as u64 ) << 23usize ) & ( 0x800000 as u64 ) ) | ( ( mPendingMediaFeatureValuesChanged as u32 as u64 ) << 24usize ) & ( 0x1000000 as u64 ) ) | ( ( mPrefChangePendingNeedsReflow as u32 as u64 ) << 25usize ) & ( 0x2000000 as u64 ) ) | ( ( mIsEmulatingMedia as u32 as u64 ) << 26usize ) & ( 0x4000000 as u64 ) ) | ( ( mIsGlyph as u32 as u64 ) << 27usize ) & ( 0x8000000 as u64 ) ) | ( ( mUsesRootEMUnits as u32 as u64 ) << 28usize ) & ( 0x10000000 as u64 ) ) | ( ( mUsesExChUnits as u32 as u64 ) << 29usize ) & ( 0x20000000 as u64 ) ) | ( ( mPendingViewportChange as u32 as u64 ) << 30usize ) & ( 0x40000000 as u64 ) ) | ( ( mCounterStylesDirty as u32 as u64 ) << 31usize ) & ( 0x80000000 as u64 ) ) | ( ( mPostedFlushCounterStyles as u32 as u64 ) << 32usize ) & ( 0x100000000 as u64 ) ) | ( ( mFontFeatureValuesDirty as u32 as u64 ) << 33usize ) & ( 0x200000000 as u64 ) ) | ( ( mPostedFlushFontFeatureValues as u32 as u64 ) << 34usize ) & ( 0x400000000 as u64 ) ) | ( ( mSuppressResizeReflow as u32 as u64 ) << 35usize ) & ( 0x800000000 as u64 ) ) | ( ( mIsVisual as u32 as u64 ) << 36usize ) & ( 0x1000000000 as u64 ) ) | ( ( mFireAfterPaintEvents as u32 as u64 ) << 37usize ) & ( 0x2000000000 as u64 ) ) | ( ( mIsChrome as u32 as u64 ) << 38usize ) & ( 0x4000000000 as u64 ) ) | ( ( mIsChromeOriginImage as u32 as u64 ) << 39usize ) & ( 0x8000000000 as u64 ) ) | ( ( mPaintFlashing as u32 as u64 ) << 40usize ) & ( 0x10000000000 as u64 ) ) | ( ( mPaintFlashingInitialized as u32 as u64 ) << 41usize ) & ( 0x20000000000 as u64 ) ) | ( ( mHasWarnedAboutPositionedTableParts as u32 as u64 ) << 42usize ) & ( 0x40000000000 as u64 ) ) | ( ( mHasWarnedAboutTooLargeDashedOrDottedRadius as u32 as u64 ) << 43usize ) & ( 0x80000000000 as u64 ) ) | ( ( mQuirkSheetAdded as u32 as u64 ) << 44usize ) & ( 0x100000000000 as u64 ) ) | ( ( mNeedsPrefUpdate as u32 as u64 ) << 45usize ) & ( 0x200000000000 as u64 ) ) | ( ( mHadNonBlankPaint as u32 as u64 ) << 46usize ) & ( 0x400000000000 as u64 ) ) } } # [ repr ( i16 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsCSSKeyword { eCSSKeyword_UNKNOWN = -1 , eCSSKeyword__moz_activehyperlinktext = 0 , eCSSKeyword__moz_all = 1 , eCSSKeyword__moz_alt_content = 2 , eCSSKeyword__moz_available = 3 , eCSSKeyword__moz_box = 4 , eCSSKeyword__moz_button = 5 , eCSSKeyword__moz_buttondefault = 6 , eCSSKeyword__moz_buttonhoverface = 7 , eCSSKeyword__moz_buttonhovertext = 8 , eCSSKeyword__moz_cellhighlight = 9 , eCSSKeyword__moz_cellhighlighttext = 10 , eCSSKeyword__moz_center = 11 , eCSSKeyword__moz_combobox = 12 , eCSSKeyword__moz_comboboxtext = 13 , eCSSKeyword__moz_context_properties = 14 , eCSSKeyword__moz_block_height = 15 , eCSSKeyword__moz_deck = 16 , eCSSKeyword__moz_default_background_color = 17 , eCSSKeyword__moz_default_color = 18 , eCSSKeyword__moz_desktop = 19 , eCSSKeyword__moz_dialog = 20 , eCSSKeyword__moz_dialogtext = 21 , eCSSKeyword__moz_document = 22 , eCSSKeyword__moz_dragtargetzone = 23 , eCSSKeyword__moz_element = 24 , eCSSKeyword__moz_eventreerow = 25 , eCSSKeyword__moz_field = 26 , eCSSKeyword__moz_fieldtext = 27 , eCSSKeyword__moz_fit_content = 28 , eCSSKeyword__moz_fixed = 29 , eCSSKeyword__moz_grabbing = 30 , eCSSKeyword__moz_grab = 31 , eCSSKeyword__moz_grid_group = 32 , eCSSKeyword__moz_grid_line = 33 , eCSSKeyword__moz_grid = 34 , eCSSKeyword__moz_groupbox = 35 , eCSSKeyword__moz_gtk_info_bar = 36 , eCSSKeyword__moz_gtk_info_bar_text = 37 , eCSSKeyword__moz_hidden_unscrollable = 38 , eCSSKeyword__moz_hyperlinktext = 39 , eCSSKeyword__moz_html_cellhighlight = 40 , eCSSKeyword__moz_html_cellhighlighttext = 41 , eCSSKeyword__moz_image_rect = 42 , eCSSKeyword__moz_info = 43 , eCSSKeyword__moz_inline_box = 44 , eCSSKeyword__moz_inline_grid = 45 , eCSSKeyword__moz_inline_stack = 46 , eCSSKeyword__moz_left = 47 , eCSSKeyword__moz_list = 48 , eCSSKeyword__moz_mac_buttonactivetext = 49 , eCSSKeyword__moz_mac_chrome_active = 50 , eCSSKeyword__moz_mac_chrome_inactive = 51 , eCSSKeyword__moz_mac_defaultbuttontext = 52 , eCSSKeyword__moz_mac_focusring = 53 , eCSSKeyword__moz_mac_fullscreen_button = 54 , eCSSKeyword__moz_mac_menuselect = 55 , eCSSKeyword__moz_mac_menushadow = 56 , eCSSKeyword__moz_mac_menutextdisable = 57 , eCSSKeyword__moz_mac_menutextselect = 58 , eCSSKeyword__moz_mac_disabledtoolbartext = 59 , eCSSKeyword__moz_mac_secondaryhighlight = 60 , eCSSKeyword__moz_mac_menuitem = 61 , eCSSKeyword__moz_mac_active_menuitem = 62 , eCSSKeyword__moz_mac_menupopup = 63 , eCSSKeyword__moz_mac_tooltip = 64 , eCSSKeyword__moz_max_content = 65 , eCSSKeyword__moz_menuhover = 66 , eCSSKeyword__moz_menuhovertext = 67 , eCSSKeyword__moz_menubartext = 68 , eCSSKeyword__moz_menubarhovertext = 69 , eCSSKeyword__moz_middle_with_baseline = 70 , eCSSKeyword__moz_min_content = 71 , eCSSKeyword__moz_nativehyperlinktext = 72 , eCSSKeyword__moz_none = 73 , eCSSKeyword__moz_oddtreerow = 74 , eCSSKeyword__moz_popup = 75 , eCSSKeyword__moz_pre_space = 76 , eCSSKeyword__moz_pull_down_menu = 77 , eCSSKeyword__moz_right = 78 , eCSSKeyword__moz_scrollbars_horizontal = 79 , eCSSKeyword__moz_scrollbars_none = 80 , eCSSKeyword__moz_scrollbars_vertical = 81 , eCSSKeyword__moz_stack = 82 , eCSSKeyword__moz_text = 83 , eCSSKeyword__moz_use_system_font = 84 , eCSSKeyword__moz_visitedhyperlinktext = 85 , eCSSKeyword__moz_window = 86 , eCSSKeyword__moz_workspace = 87 , eCSSKeyword__moz_zoom_in = 88 , eCSSKeyword__moz_zoom_out = 89 , eCSSKeyword__webkit_box = 90 , eCSSKeyword__webkit_flex = 91 , eCSSKeyword__webkit_inline_box = 92 , eCSSKeyword__webkit_inline_flex = 93 , eCSSKeyword_absolute = 94 , eCSSKeyword_active = 95 , eCSSKeyword_activeborder = 96 , eCSSKeyword_activecaption = 97 , eCSSKeyword_add = 98 , eCSSKeyword_additive = 99 , eCSSKeyword_alias = 100 , eCSSKeyword_all = 101 , eCSSKeyword_all_petite_caps = 102 , eCSSKeyword_all_scroll = 103 , eCSSKeyword_all_small_caps = 104 , eCSSKeyword_alpha = 105 , eCSSKeyword_alternate = 106 , eCSSKeyword_alternate_reverse = 107 , eCSSKeyword_always = 108 , eCSSKeyword_annotation = 109 , eCSSKeyword_appworkspace = 110 , eCSSKeyword_auto = 111 , eCSSKeyword_auto_fill = 112 , eCSSKeyword_auto_fit = 113 , eCSSKeyword_auto_flow = 114 , eCSSKeyword_avoid = 115 , eCSSKeyword_background = 116 , eCSSKeyword_backwards = 117 , eCSSKeyword_balance = 118 , eCSSKeyword_baseline = 119 , eCSSKeyword_bidi_override = 120 , eCSSKeyword_blink = 121 , eCSSKeyword_block = 122 , eCSSKeyword_block_axis = 123 , eCSSKeyword_blur = 124 , eCSSKeyword_bold = 125 , eCSSKeyword_bold_fraktur = 126 , eCSSKeyword_bold_italic = 127 , eCSSKeyword_bold_sans_serif = 128 , eCSSKeyword_bold_script = 129 , eCSSKeyword_bolder = 130 , eCSSKeyword_border_box = 131 , eCSSKeyword_both = 132 , eCSSKeyword_bottom = 133 , eCSSKeyword_bottom_outside = 134 , eCSSKeyword_break_all = 135 , eCSSKeyword_break_word = 136 , eCSSKeyword_brightness = 137 , eCSSKeyword_browser = 138 , eCSSKeyword_bullets = 139 , eCSSKeyword_button = 140 , eCSSKeyword_buttonface = 141 , eCSSKeyword_buttonhighlight = 142 , eCSSKeyword_buttonshadow = 143 , eCSSKeyword_buttontext = 144 , eCSSKeyword_capitalize = 145 , eCSSKeyword_caption = 146 , eCSSKeyword_captiontext = 147 , eCSSKeyword_cell = 148 , eCSSKeyword_center = 149 , eCSSKeyword_ch = 150 , eCSSKeyword_character_variant = 151 , eCSSKeyword_circle = 152 , eCSSKeyword_cjk_decimal = 153 , eCSSKeyword_clip = 154 , eCSSKeyword_clone = 155 , eCSSKeyword_close_quote = 156 , eCSSKeyword_closest_corner = 157 , eCSSKeyword_closest_side = 158 , eCSSKeyword_cm = 159 , eCSSKeyword_col_resize = 160 , eCSSKeyword_collapse = 161 , eCSSKeyword_color = 162 , eCSSKeyword_color_burn = 163 , eCSSKeyword_color_dodge = 164 , eCSSKeyword_common_ligatures = 165 , eCSSKeyword_column = 166 , eCSSKeyword_column_reverse = 167 , eCSSKeyword_condensed = 168 , eCSSKeyword_contain = 169 , eCSSKeyword_content_box = 170 , eCSSKeyword_contents = 171 , eCSSKeyword_context_fill = 172 , eCSSKeyword_context_fill_opacity = 173 , eCSSKeyword_context_menu = 174 , eCSSKeyword_context_stroke = 175 , eCSSKeyword_context_stroke_opacity = 176 , eCSSKeyword_context_value = 177 , eCSSKeyword_continuous = 178 , eCSSKeyword_contrast = 179 , eCSSKeyword_copy = 180 , eCSSKeyword_contextual = 181 , eCSSKeyword_cover = 182 , eCSSKeyword_crop = 183 , eCSSKeyword_cross = 184 , eCSSKeyword_crosshair = 185 , eCSSKeyword_currentcolor = 186 , eCSSKeyword_cursive = 187 , eCSSKeyword_cyclic = 188 , eCSSKeyword_darken = 189 , eCSSKeyword_dashed = 190 , eCSSKeyword_dense = 191 , eCSSKeyword_decimal = 192 , eCSSKeyword_default = 193 , eCSSKeyword_deg = 194 , eCSSKeyword_diagonal_fractions = 195 , eCSSKeyword_dialog = 196 , eCSSKeyword_difference = 197 , eCSSKeyword_digits = 198 , eCSSKeyword_disabled = 199 , eCSSKeyword_disc = 200 , eCSSKeyword_discretionary_ligatures = 201 , eCSSKeyword_distribute = 202 , eCSSKeyword_dot = 203 , eCSSKeyword_dotted = 204 , eCSSKeyword_double = 205 , eCSSKeyword_double_circle = 206 , eCSSKeyword_double_struck = 207 , eCSSKeyword_drag = 208 , eCSSKeyword_drop_shadow = 209 , eCSSKeyword_e_resize = 210 , eCSSKeyword_ease = 211 , eCSSKeyword_ease_in = 212 , eCSSKeyword_ease_in_out = 213 , eCSSKeyword_ease_out = 214 , eCSSKeyword_economy = 215 , eCSSKeyword_element = 216 , eCSSKeyword_elements = 217 , eCSSKeyword_ellipse = 218 , eCSSKeyword_ellipsis = 219 , eCSSKeyword_em = 220 , eCSSKeyword_embed = 221 , eCSSKeyword_enabled = 222 , eCSSKeyword_end = 223 , eCSSKeyword_ex = 224 , eCSSKeyword_exact = 225 , eCSSKeyword_exclude = 226 , eCSSKeyword_exclusion = 227 , eCSSKeyword_expanded = 228 , eCSSKeyword_extends = 229 , eCSSKeyword_extra_condensed = 230 , eCSSKeyword_extra_expanded = 231 , eCSSKeyword_ew_resize = 232 , eCSSKeyword_fallback = 233 , eCSSKeyword_fantasy = 234 , eCSSKeyword_farthest_side = 235 , eCSSKeyword_farthest_corner = 236 , eCSSKeyword_fill = 237 , eCSSKeyword_filled = 238 , eCSSKeyword_fill_box = 239 , eCSSKeyword_first = 240 , eCSSKeyword_fit_content = 241 , eCSSKeyword_fixed = 242 , eCSSKeyword_flat = 243 , eCSSKeyword_flex = 244 , eCSSKeyword_flex_end = 245 , eCSSKeyword_flex_start = 246 , eCSSKeyword_flip = 247 , eCSSKeyword_flow_root = 248 , eCSSKeyword_forwards = 249 , eCSSKeyword_fraktur = 250 , eCSSKeyword_frames = 251 , eCSSKeyword_from_image = 252 , eCSSKeyword_full_width = 253 , eCSSKeyword_fullscreen = 254 , eCSSKeyword_grab = 255 , eCSSKeyword_grabbing = 256 , eCSSKeyword_grad = 257 , eCSSKeyword_grayscale = 258 , eCSSKeyword_graytext = 259 , eCSSKeyword_grid = 260 , eCSSKeyword_groove = 261 , eCSSKeyword_hard_light = 262 , eCSSKeyword_help = 263 , eCSSKeyword_hidden = 264 , eCSSKeyword_hide = 265 , eCSSKeyword_highlight = 266 , eCSSKeyword_highlighttext = 267 , eCSSKeyword_historical_forms = 268 , eCSSKeyword_historical_ligatures = 269 , eCSSKeyword_horizontal = 270 , eCSSKeyword_horizontal_tb = 271 , eCSSKeyword_hue = 272 , eCSSKeyword_hue_rotate = 273 , eCSSKeyword_hz = 274 , eCSSKeyword_icon = 275 , eCSSKeyword_ignore = 276 , eCSSKeyword_ignore_horizontal = 277 , eCSSKeyword_ignore_vertical = 278 , eCSSKeyword_in = 279 , eCSSKeyword_interlace = 280 , eCSSKeyword_inactive = 281 , eCSSKeyword_inactiveborder = 282 , eCSSKeyword_inactivecaption = 283 , eCSSKeyword_inactivecaptiontext = 284 , eCSSKeyword_infinite = 285 , eCSSKeyword_infobackground = 286 , eCSSKeyword_infotext = 287 , eCSSKeyword_inherit = 288 , eCSSKeyword_initial = 289 , eCSSKeyword_inline = 290 , eCSSKeyword_inline_axis = 291 , eCSSKeyword_inline_block = 292 , eCSSKeyword_inline_end = 293 , eCSSKeyword_inline_flex = 294 , eCSSKeyword_inline_grid = 295 , eCSSKeyword_inline_start = 296 , eCSSKeyword_inline_table = 297 , eCSSKeyword_inset = 298 , eCSSKeyword_inside = 299 , eCSSKeyword_inter_character = 300 , eCSSKeyword_inter_word = 301 , eCSSKeyword_interpolatematrix = 302 , eCSSKeyword_accumulatematrix = 303 , eCSSKeyword_intersect = 304 , eCSSKeyword_isolate = 305 , eCSSKeyword_isolate_override = 306 , eCSSKeyword_invert = 307 , eCSSKeyword_italic = 308 , eCSSKeyword_jis78 = 309 , eCSSKeyword_jis83 = 310 , eCSSKeyword_jis90 = 311 , eCSSKeyword_jis04 = 312 , eCSSKeyword_justify = 313 , eCSSKeyword_keep_all = 314 , eCSSKeyword_khz = 315 , eCSSKeyword_landscape = 316 , eCSSKeyword_large = 317 , eCSSKeyword_larger = 318 , eCSSKeyword_last = 319 , eCSSKeyword_last_baseline = 320 , eCSSKeyword_layout = 321 , eCSSKeyword_left = 322 , eCSSKeyword_legacy = 323 , eCSSKeyword_lighten = 324 , eCSSKeyword_lighter = 325 , eCSSKeyword_line_through = 326 , eCSSKeyword_linear = 327 , eCSSKeyword_lining_nums = 328 , eCSSKeyword_list_item = 329 , eCSSKeyword_local = 330 , eCSSKeyword_logical = 331 , eCSSKeyword_looped = 332 , eCSSKeyword_lowercase = 333 , eCSSKeyword_lr = 334 , eCSSKeyword_lr_tb = 335 , eCSSKeyword_ltr = 336 , eCSSKeyword_luminance = 337 , eCSSKeyword_luminosity = 338 , eCSSKeyword_mandatory = 339 , eCSSKeyword_manipulation = 340 , eCSSKeyword_manual = 341 , eCSSKeyword_margin_box = 342 , eCSSKeyword_markers = 343 , eCSSKeyword_match_parent = 344 , eCSSKeyword_match_source = 345 , eCSSKeyword_matrix = 346 , eCSSKeyword_matrix3d = 347 , eCSSKeyword_max_content = 348 , eCSSKeyword_medium = 349 , eCSSKeyword_menu = 350 , eCSSKeyword_menutext = 351 , eCSSKeyword_message_box = 352 , eCSSKeyword_middle = 353 , eCSSKeyword_min_content = 354 , eCSSKeyword_minmax = 355 , eCSSKeyword_mix = 356 , eCSSKeyword_mixed = 357 , eCSSKeyword_mm = 358 , eCSSKeyword_monospace = 359 , eCSSKeyword_move = 360 , eCSSKeyword_ms = 361 , eCSSKeyword_multiply = 362 , eCSSKeyword_n_resize = 363 , eCSSKeyword_narrower = 364 , eCSSKeyword_ne_resize = 365 , eCSSKeyword_nesw_resize = 366 , eCSSKeyword_no_clip = 367 , eCSSKeyword_no_close_quote = 368 , eCSSKeyword_no_common_ligatures = 369 , eCSSKeyword_no_contextual = 370 , eCSSKeyword_no_discretionary_ligatures = 371 , eCSSKeyword_no_drag = 372 , eCSSKeyword_no_drop = 373 , eCSSKeyword_no_historical_ligatures = 374 , eCSSKeyword_no_open_quote = 375 , eCSSKeyword_no_repeat = 376 , eCSSKeyword_none = 377 , eCSSKeyword_normal = 378 , eCSSKeyword_not_allowed = 379 , eCSSKeyword_nowrap = 380 , eCSSKeyword_numeric = 381 , eCSSKeyword_ns_resize = 382 , eCSSKeyword_nw_resize = 383 , eCSSKeyword_nwse_resize = 384 , eCSSKeyword_oblique = 385 , eCSSKeyword_oldstyle_nums = 386 , eCSSKeyword_opacity = 387 , eCSSKeyword_open = 388 , eCSSKeyword_open_quote = 389 , eCSSKeyword_optional = 390 , eCSSKeyword_ordinal = 391 , eCSSKeyword_ornaments = 392 , eCSSKeyword_outset = 393 , eCSSKeyword_outside = 394 , eCSSKeyword_over = 395 , eCSSKeyword_overlay = 396 , eCSSKeyword_overline = 397 , eCSSKeyword_paint = 398 , eCSSKeyword_padding_box = 399 , eCSSKeyword_painted = 400 , eCSSKeyword_pan_x = 401 , eCSSKeyword_pan_y = 402 , eCSSKeyword_paused = 403 , eCSSKeyword_pc = 404 , eCSSKeyword_perspective = 405 , eCSSKeyword_petite_caps = 406 , eCSSKeyword_physical = 407 , eCSSKeyword_plaintext = 408 , eCSSKeyword_pointer = 409 , eCSSKeyword_polygon = 410 , eCSSKeyword_portrait = 411 , eCSSKeyword_pre = 412 , eCSSKeyword_pre_wrap = 413 , eCSSKeyword_pre_line = 414 , eCSSKeyword_preserve_3d = 415 , eCSSKeyword_progress = 416 , eCSSKeyword_progressive = 417 , eCSSKeyword_proportional_nums = 418 , eCSSKeyword_proportional_width = 419 , eCSSKeyword_proximity = 420 , eCSSKeyword_pt = 421 , eCSSKeyword_px = 422 , eCSSKeyword_rad = 423 , eCSSKeyword_read_only = 424 , eCSSKeyword_read_write = 425 , eCSSKeyword_relative = 426 , eCSSKeyword_repeat = 427 , eCSSKeyword_repeat_x = 428 , eCSSKeyword_repeat_y = 429 , eCSSKeyword_reverse = 430 , eCSSKeyword_ridge = 431 , eCSSKeyword_right = 432 , eCSSKeyword_rl = 433 , eCSSKeyword_rl_tb = 434 , eCSSKeyword_rotate = 435 , eCSSKeyword_rotate3d = 436 , eCSSKeyword_rotatex = 437 , eCSSKeyword_rotatey = 438 , eCSSKeyword_rotatez = 439 , eCSSKeyword_round = 440 , eCSSKeyword_row = 441 , eCSSKeyword_row_resize = 442 , eCSSKeyword_row_reverse = 443 , eCSSKeyword_rtl = 444 , eCSSKeyword_ruby = 445 , eCSSKeyword_ruby_base = 446 , eCSSKeyword_ruby_base_container = 447 , eCSSKeyword_ruby_text = 448 , eCSSKeyword_ruby_text_container = 449 , eCSSKeyword_running = 450 , eCSSKeyword_s = 451 , eCSSKeyword_s_resize = 452 , eCSSKeyword_safe = 453 , eCSSKeyword_saturate = 454 , eCSSKeyword_saturation = 455 , eCSSKeyword_scale = 456 , eCSSKeyword_scale_down = 457 , eCSSKeyword_scale3d = 458 , eCSSKeyword_scalex = 459 , eCSSKeyword_scaley = 460 , eCSSKeyword_scalez = 461 , eCSSKeyword_screen = 462 , eCSSKeyword_script = 463 , eCSSKeyword_scroll = 464 , eCSSKeyword_scrollbar = 465 , eCSSKeyword_scrollbar_small = 466 , eCSSKeyword_scrollbar_horizontal = 467 , eCSSKeyword_scrollbar_vertical = 468 , eCSSKeyword_se_resize = 469 , eCSSKeyword_select_after = 470 , eCSSKeyword_select_all = 471 , eCSSKeyword_select_before = 472 , eCSSKeyword_select_menu = 473 , eCSSKeyword_select_same = 474 , eCSSKeyword_self_end = 475 , eCSSKeyword_self_start = 476 , eCSSKeyword_semi_condensed = 477 , eCSSKeyword_semi_expanded = 478 , eCSSKeyword_separate = 479 , eCSSKeyword_sepia = 480 , eCSSKeyword_serif = 481 , eCSSKeyword_sesame = 482 , eCSSKeyword_show = 483 , eCSSKeyword_sideways = 484 , eCSSKeyword_sideways_lr = 485 , eCSSKeyword_sideways_right = 486 , eCSSKeyword_sideways_rl = 487 , eCSSKeyword_simplified = 488 , eCSSKeyword_skew = 489 , eCSSKeyword_skewx = 490 , eCSSKeyword_skewy = 491 , eCSSKeyword_slashed_zero = 492 , eCSSKeyword_slice = 493 , eCSSKeyword_small = 494 , eCSSKeyword_small_caps = 495 , eCSSKeyword_small_caption = 496 , eCSSKeyword_smaller = 497 , eCSSKeyword_smooth = 498 , eCSSKeyword_soft = 499 , eCSSKeyword_soft_light = 500 , eCSSKeyword_solid = 501 , eCSSKeyword_space_around = 502 , eCSSKeyword_space_between = 503 , eCSSKeyword_space_evenly = 504 , eCSSKeyword_span = 505 , eCSSKeyword_spell_out = 506 , eCSSKeyword_square = 507 , eCSSKeyword_stacked_fractions = 508 , eCSSKeyword_start = 509 , eCSSKeyword_static = 510 , eCSSKeyword_standalone = 511 , eCSSKeyword_status_bar = 512 , eCSSKeyword_step_end = 513 , eCSSKeyword_step_start = 514 , eCSSKeyword_sticky = 515 , eCSSKeyword_stretch = 516 , eCSSKeyword_stretch_to_fit = 517 , eCSSKeyword_stretched = 518 , eCSSKeyword_strict = 519 , eCSSKeyword_stroke = 520 , eCSSKeyword_stroke_box = 521 , eCSSKeyword_style = 522 , eCSSKeyword_styleset = 523 , eCSSKeyword_stylistic = 524 , eCSSKeyword_sub = 525 , eCSSKeyword_subgrid = 526 , eCSSKeyword_subtract = 527 , eCSSKeyword_super = 528 , eCSSKeyword_sw_resize = 529 , eCSSKeyword_swash = 530 , eCSSKeyword_swap = 531 , eCSSKeyword_table = 532 , eCSSKeyword_table_caption = 533 , eCSSKeyword_table_cell = 534 , eCSSKeyword_table_column = 535 , eCSSKeyword_table_column_group = 536 , eCSSKeyword_table_footer_group = 537 , eCSSKeyword_table_header_group = 538 , eCSSKeyword_table_row = 539 , eCSSKeyword_table_row_group = 540 , eCSSKeyword_tabular_nums = 541 , eCSSKeyword_tailed = 542 , eCSSKeyword_tb = 543 , eCSSKeyword_tb_rl = 544 , eCSSKeyword_text = 545 , eCSSKeyword_text_bottom = 546 , eCSSKeyword_text_top = 547 , eCSSKeyword_thick = 548 , eCSSKeyword_thin = 549 , eCSSKeyword_threeddarkshadow = 550 , eCSSKeyword_threedface = 551 , eCSSKeyword_threedhighlight = 552 , eCSSKeyword_threedlightshadow = 553 , eCSSKeyword_threedshadow = 554 , eCSSKeyword_titling_caps = 555 , eCSSKeyword_toggle = 556 , eCSSKeyword_top = 557 , eCSSKeyword_top_outside = 558 , eCSSKeyword_traditional = 559 , eCSSKeyword_translate = 560 , eCSSKeyword_translate3d = 561 , eCSSKeyword_translatex = 562 , eCSSKeyword_translatey = 563 , eCSSKeyword_translatez = 564 , eCSSKeyword_transparent = 565 , eCSSKeyword_triangle = 566 , eCSSKeyword_tri_state = 567 , eCSSKeyword_ultra_condensed = 568 , eCSSKeyword_ultra_expanded = 569 , eCSSKeyword_under = 570 , eCSSKeyword_underline = 571 , eCSSKeyword_unicase = 572 , eCSSKeyword_unsafe = 573 , eCSSKeyword_unset = 574 , eCSSKeyword_uppercase = 575 , eCSSKeyword_upright = 576 , eCSSKeyword_vertical = 577 , eCSSKeyword_vertical_lr = 578 , eCSSKeyword_vertical_rl = 579 , eCSSKeyword_vertical_text = 580 , eCSSKeyword_view_box = 581 , eCSSKeyword_visible = 582 , eCSSKeyword_visiblefill = 583 , eCSSKeyword_visiblepainted = 584 , eCSSKeyword_visiblestroke = 585 , eCSSKeyword_w_resize = 586 , eCSSKeyword_wait = 587 , eCSSKeyword_wavy = 588 , eCSSKeyword_weight = 589 , eCSSKeyword_wider = 590 , eCSSKeyword_window = 591 , eCSSKeyword_windowframe = 592 , eCSSKeyword_windowtext = 593 , eCSSKeyword_words = 594 , eCSSKeyword_wrap = 595 , eCSSKeyword_wrap_reverse = 596 , eCSSKeyword_write_only = 597 , eCSSKeyword_x_large = 598 , eCSSKeyword_x_small = 599 , eCSSKeyword_xx_large = 600 , eCSSKeyword_xx_small = 601 , eCSSKeyword_zoom_in = 602 , eCSSKeyword_zoom_out = 603 , eCSSKeyword_radio = 604 , eCSSKeyword_checkbox = 605 , eCSSKeyword_button_bevel = 606 , eCSSKeyword_toolbox = 607 , eCSSKeyword_toolbar = 608 , eCSSKeyword_toolbarbutton = 609 , eCSSKeyword_toolbargripper = 610 , eCSSKeyword_dualbutton = 611 , eCSSKeyword_toolbarbutton_dropdown = 612 , eCSSKeyword_button_arrow_up = 613 , eCSSKeyword_button_arrow_down = 614 , eCSSKeyword_button_arrow_next = 615 , eCSSKeyword_button_arrow_previous = 616 , eCSSKeyword_separator = 617 , eCSSKeyword_splitter = 618 , eCSSKeyword_statusbar = 619 , eCSSKeyword_statusbarpanel = 620 , eCSSKeyword_resizerpanel = 621 , eCSSKeyword_resizer = 622 , eCSSKeyword_listbox = 623 , eCSSKeyword_listitem = 624 , eCSSKeyword_numbers = 625 , eCSSKeyword_number_input = 626 , eCSSKeyword_treeview = 627 , eCSSKeyword_treeitem = 628 , eCSSKeyword_treetwisty = 629 , eCSSKeyword_treetwistyopen = 630 , eCSSKeyword_treeline = 631 , eCSSKeyword_treeheader = 632 , eCSSKeyword_treeheadercell = 633 , eCSSKeyword_treeheadersortarrow = 634 , eCSSKeyword_progressbar = 635 , eCSSKeyword_progressbar_vertical = 636 , eCSSKeyword_progresschunk = 637 , eCSSKeyword_progresschunk_vertical = 638 , eCSSKeyword_tab = 639 , eCSSKeyword_tabpanels = 640 , eCSSKeyword_tabpanel = 641 , eCSSKeyword_tab_scroll_arrow_back = 642 , eCSSKeyword_tab_scroll_arrow_forward = 643 , eCSSKeyword_tooltip = 644 , eCSSKeyword_inner_spin_button = 645 , eCSSKeyword_spinner = 646 , eCSSKeyword_spinner_upbutton = 647 , eCSSKeyword_spinner_downbutton = 648 , eCSSKeyword_spinner_textfield = 649 , eCSSKeyword_scrollbarbutton_up = 650 , eCSSKeyword_scrollbarbutton_down = 651 , eCSSKeyword_scrollbarbutton_left = 652 , eCSSKeyword_scrollbarbutton_right = 653 , eCSSKeyword_scrollbartrack_horizontal = 654 , eCSSKeyword_scrollbartrack_vertical = 655 , eCSSKeyword_scrollbarthumb_horizontal = 656 , eCSSKeyword_scrollbarthumb_vertical = 657 , eCSSKeyword_sheet = 658 , eCSSKeyword_textfield = 659 , eCSSKeyword_textfield_multiline = 660 , eCSSKeyword_caret = 661 , eCSSKeyword_searchfield = 662 , eCSSKeyword_menubar = 663 , eCSSKeyword_menupopup = 664 , eCSSKeyword_menuitem = 665 , eCSSKeyword_checkmenuitem = 666 , eCSSKeyword_radiomenuitem = 667 , eCSSKeyword_menucheckbox = 668 , eCSSKeyword_menuradio = 669 , eCSSKeyword_menuseparator = 670 , eCSSKeyword_menuarrow = 671 , eCSSKeyword_menuimage = 672 , eCSSKeyword_menuitemtext = 673 , eCSSKeyword_menulist = 674 , eCSSKeyword_menulist_button = 675 , eCSSKeyword_menulist_text = 676 , eCSSKeyword_menulist_textfield = 677 , eCSSKeyword_meterbar = 678 , eCSSKeyword_meterchunk = 679 , eCSSKeyword_minimal_ui = 680 , eCSSKeyword_range = 681 , eCSSKeyword_range_thumb = 682 , eCSSKeyword_sans_serif = 683 , eCSSKeyword_sans_serif_bold_italic = 684 , eCSSKeyword_sans_serif_italic = 685 , eCSSKeyword_scale_horizontal = 686 , eCSSKeyword_scale_vertical = 687 , eCSSKeyword_scalethumb_horizontal = 688 , eCSSKeyword_scalethumb_vertical = 689 , eCSSKeyword_scalethumbstart = 690 , eCSSKeyword_scalethumbend = 691 , eCSSKeyword_scalethumbtick = 692 , eCSSKeyword_groupbox = 693 , eCSSKeyword_checkbox_container = 694 , eCSSKeyword_radio_container = 695 , eCSSKeyword_checkbox_label = 696 , eCSSKeyword_radio_label = 697 , eCSSKeyword_button_focus = 698 , eCSSKeyword__moz_win_media_toolbox = 699 , eCSSKeyword__moz_win_communications_toolbox = 700 , eCSSKeyword__moz_win_browsertabbar_toolbox = 701 , eCSSKeyword__moz_win_accentcolor = 702 , eCSSKeyword__moz_win_accentcolortext = 703 , eCSSKeyword__moz_win_mediatext = 704 , eCSSKeyword__moz_win_communicationstext = 705 , eCSSKeyword__moz_win_glass = 706 , eCSSKeyword__moz_win_borderless_glass = 707 , eCSSKeyword__moz_window_titlebar = 708 , eCSSKeyword__moz_window_titlebar_maximized = 709 , eCSSKeyword__moz_window_frame_left = 710 , eCSSKeyword__moz_window_frame_right = 711 , eCSSKeyword__moz_window_frame_bottom = 712 , eCSSKeyword__moz_window_button_close = 713 , eCSSKeyword__moz_window_button_minimize = 714 , eCSSKeyword__moz_window_button_maximize = 715 , eCSSKeyword__moz_window_button_restore = 716 , eCSSKeyword__moz_window_button_box = 717 , eCSSKeyword__moz_window_button_box_maximized = 718 , eCSSKeyword__moz_mac_help_button = 719 , eCSSKeyword__moz_win_exclude_glass = 720 , eCSSKeyword__moz_mac_vibrancy_light = 721 , eCSSKeyword__moz_mac_vibrancy_dark = 722 , eCSSKeyword__moz_mac_vibrant_titlebar_light = 723 , eCSSKeyword__moz_mac_vibrant_titlebar_dark = 724 , eCSSKeyword__moz_mac_disclosure_button_closed = 725 , eCSSKeyword__moz_mac_disclosure_button_open = 726 , eCSSKeyword__moz_mac_source_list = 727 , eCSSKeyword__moz_mac_source_list_selection = 728 , eCSSKeyword__moz_mac_active_source_list_selection = 729 , eCSSKeyword_alphabetic = 730 , eCSSKeyword_bevel = 731 , eCSSKeyword_butt = 732 , eCSSKeyword_central = 733 , eCSSKeyword_crispedges = 734 , eCSSKeyword_evenodd = 735 , eCSSKeyword_geometricprecision = 736 , eCSSKeyword_hanging = 737 , eCSSKeyword_ideographic = 738 , eCSSKeyword_linearrgb = 739 , eCSSKeyword_mathematical = 740 , eCSSKeyword_miter = 741 , eCSSKeyword_no_change = 742 , eCSSKeyword_non_scaling_stroke = 743 , eCSSKeyword_nonzero = 744 , eCSSKeyword_optimizelegibility = 745 , eCSSKeyword_optimizequality = 746 , eCSSKeyword_optimizespeed = 747 , eCSSKeyword_reset_size = 748 , eCSSKeyword_srgb = 749 , eCSSKeyword_symbolic = 750 , eCSSKeyword_symbols = 751 , eCSSKeyword_text_after_edge = 752 , eCSSKeyword_text_before_edge = 753 , eCSSKeyword_use_script = 754 , eCSSKeyword__moz_crisp_edges = 755 , eCSSKeyword_space = 756 , eCSSKeyword_COUNT = 757 , } pub const nsStyleStructID_nsStyleStructID_None : root :: nsStyleStructID = -1 ; pub const nsStyleStructID_nsStyleStructID_Inherited_Start : root :: nsStyleStructID = 0 ; pub const nsStyleStructID_nsStyleStructID_DUMMY1 : root :: nsStyleStructID = -1 ; pub const nsStyleStructID_eStyleStruct_Font : root :: nsStyleStructID = 0 ; pub const nsStyleStructID_eStyleStruct_Color : root :: nsStyleStructID = 1 ; pub const nsStyleStructID_eStyleStruct_List : root :: nsStyleStructID = 2 ; pub const nsStyleStructID_eStyleStruct_Text : root :: nsStyleStructID = 3 ; pub const nsStyleStructID_eStyleStruct_Visibility : root :: nsStyleStructID = 4 ; pub const nsStyleStructID_eStyleStruct_UserInterface : root :: nsStyleStructID = 5 ; pub const nsStyleStructID_eStyleStruct_TableBorder : root :: nsStyleStructID = 6 ; pub const nsStyleStructID_eStyleStruct_SVG : root :: nsStyleStructID = 7 ; pub const nsStyleStructID_eStyleStruct_Variables : root :: nsStyleStructID = 8 ; pub const nsStyleStructID_nsStyleStructID_Reset_Start : root :: nsStyleStructID = 9 ; pub const nsStyleStructID_nsStyleStructID_DUMMY2 : root :: nsStyleStructID = 8 ; pub const nsStyleStructID_eStyleStruct_Background : root :: nsStyleStructID = 9 ; pub const nsStyleStructID_eStyleStruct_Position : root :: nsStyleStructID = 10 ; pub const nsStyleStructID_eStyleStruct_TextReset : root :: nsStyleStructID = 11 ; pub const nsStyleStructID_eStyleStruct_Display : root :: nsStyleStructID = 12 ; pub const nsStyleStructID_eStyleStruct_Content : root :: nsStyleStructID = 13 ; pub const nsStyleStructID_eStyleStruct_UIReset : root :: nsStyleStructID = 14 ; pub const nsStyleStructID_eStyleStruct_Table : root :: nsStyleStructID = 15 ; pub const nsStyleStructID_eStyleStruct_Margin : root :: nsStyleStructID = 16 ; pub const nsStyleStructID_eStyleStruct_Padding : root :: nsStyleStructID = 17 ; pub const nsStyleStructID_eStyleStruct_Border : root :: nsStyleStructID = 18 ; pub const nsStyleStructID_eStyleStruct_Outline : root :: nsStyleStructID = 19 ; pub const nsStyleStructID_eStyleStruct_XUL : root :: nsStyleStructID = 20 ; pub const nsStyleStructID_eStyleStruct_SVGReset : root :: nsStyleStructID = 21 ; pub const nsStyleStructID_eStyleStruct_Column : root :: nsStyleStructID = 22 ; pub const nsStyleStructID_eStyleStruct_Effects : root :: nsStyleStructID = 23 ; pub const nsStyleStructID_nsStyleStructID_Length : root :: nsStyleStructID = 24 ; pub const nsStyleStructID_nsStyleStructID_Inherited_Count : root :: nsStyleStructID = 9 ; pub const nsStyleStructID_nsStyleStructID_Reset_Count : root :: nsStyleStructID = 15 ; pub type nsStyleStructID = :: std :: os :: raw :: c_int ; pub const nsStyleAnimType_eStyleAnimType_Custom : root :: nsStyleAnimType = 0 ; pub const nsStyleAnimType_eStyleAnimType_Coord : root :: nsStyleAnimType = 1 ; pub const nsStyleAnimType_eStyleAnimType_Sides_Top : root :: nsStyleAnimType = 2 ; pub const nsStyleAnimType_eStyleAnimType_Sides_Right : root :: nsStyleAnimType = 3 ; pub const nsStyleAnimType_eStyleAnimType_Sides_Bottom : root :: nsStyleAnimType = 4 ; pub const nsStyleAnimType_eStyleAnimType_Sides_Left : root :: nsStyleAnimType = 5 ; pub const nsStyleAnimType_eStyleAnimType_Corner_TopLeft : root :: nsStyleAnimType = 6 ; pub const nsStyleAnimType_eStyleAnimType_Corner_TopRight : root :: nsStyleAnimType = 7 ; pub const nsStyleAnimType_eStyleAnimType_Corner_BottomRight : root :: nsStyleAnimType = 8 ; pub const nsStyleAnimType_eStyleAnimType_Corner_BottomLeft : root :: nsStyleAnimType = 9 ; pub const nsStyleAnimType_eStyleAnimType_nscoord : root :: nsStyleAnimType = 10 ; pub const nsStyleAnimType_eStyleAnimType_float : root :: nsStyleAnimType = 11 ; pub const nsStyleAnimType_eStyleAnimType_Color : root :: nsStyleAnimType = 12 ; pub const nsStyleAnimType_eStyleAnimType_ComplexColor : root :: nsStyleAnimType = 13 ; pub const nsStyleAnimType_eStyleAnimType_PaintServer : root :: nsStyleAnimType = 14 ; pub const nsStyleAnimType_eStyleAnimType_Shadow : root :: nsStyleAnimType = 15 ; pub const nsStyleAnimType_eStyleAnimType_Discrete : root :: nsStyleAnimType = 16 ; pub const nsStyleAnimType_eStyleAnimType_None : root :: nsStyleAnimType = 17 ; pub type nsStyleAnimType = :: std :: os :: raw :: c_uint ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsCSSProps { pub _address : u8 , } pub use self :: super :: root :: mozilla :: CSSEnabledState as nsCSSProps_EnabledState ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsCSSProps_KTableEntry { pub mKeyword : root :: nsCSSKeyword , pub mValue : i16 , } # [ test ] fn bindgen_test_layout_nsCSSProps_KTableEntry ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSProps_KTableEntry > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( nsCSSProps_KTableEntry ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSProps_KTableEntry > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( nsCSSProps_KTableEntry ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSProps_KTableEntry ) ) . mKeyword as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSProps_KTableEntry ) , "::" , stringify ! ( mKeyword ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSProps_KTableEntry ) ) . mValue as * const _ as usize } , 2usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSProps_KTableEntry ) , "::" , stringify ! ( mValue ) ) ) ; } impl Clone for nsCSSProps_KTableEntry { fn clone ( & self ) -> Self { * self } } extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps9kSIDTableE" ] 
 pub static mut  nsCSSProps_kSIDTable  :  [ root :: nsStyleStructID ; 327usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps18kKeywordTableTableE" ] 
 pub static mut  nsCSSProps_kKeywordTableTable  :  [ * const root :: nsCSSProps_KTableEntry ; 327usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps14kAnimTypeTableE" ] 
 pub static mut  nsCSSProps_kAnimTypeTable  :  [ root :: nsStyleAnimType ; 327usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps23kStyleStructOffsetTableE" ] 
 pub static mut  nsCSSProps_kStyleStructOffsetTable  :  [ isize ; 327usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps11kFlagsTableE" ] 
 pub static mut  nsCSSProps_kFlagsTable  :  [ u32 ; 377usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps19kParserVariantTableE" ] 
 pub static mut  nsCSSProps_kParserVariantTable  :  [ u32 ; 327usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps17kSubpropertyTableE" ] 
 pub static mut  nsCSSProps_kSubpropertyTable  :  [ * const root :: nsCSSPropertyID ; 50usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps26gShorthandsContainingTableE" ] 
 pub static mut  nsCSSProps_gShorthandsContainingTable  :  [ * mut root :: nsCSSPropertyID ; 327usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps25gShorthandsContainingPoolE" ] 
 pub static mut  nsCSSProps_gShorthandsContainingPool  :  * mut root :: nsCSSPropertyID ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps22gPropertyCountInStructE" ] 
 pub static mut  nsCSSProps_gPropertyCountInStruct  :  [ usize ; 24usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps22gPropertyIndexInStructE" ] 
 pub static mut  nsCSSProps_gPropertyIndexInStruct  :  [ usize ; 327usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps18kLogicalGroupTableE" ] 
 pub static mut  nsCSSProps_kLogicalGroupTable  :  [ * const root :: nsCSSPropertyID ; 9usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps16gPropertyEnabledE" ] 
 pub static mut  nsCSSProps_gPropertyEnabled  :  [ bool ; 486usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps13kIDLNameTableE" ] 
 pub static mut  nsCSSProps_kIDLNameTable  :  [ * const :: std :: os :: raw :: c_char ; 377usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps25kIDLNameSortPositionTableE" ] 
 pub static mut  nsCSSProps_kIDLNameSortPositionTable  :  [ i32 ; 377usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps19gPropertyUseCounterE" ] 
 pub static mut  nsCSSProps_gPropertyUseCounter  :  [ root :: mozilla :: UseCounter ; 327usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps25kAnimationDirectionKTableE" ] 
 pub static mut  nsCSSProps_kAnimationDirectionKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps24kAnimationFillModeKTableE" ] 
 pub static mut  nsCSSProps_kAnimationFillModeKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps30kAnimationIterationCountKTableE" ] 
 pub static mut  nsCSSProps_kAnimationIterationCountKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps25kAnimationPlayStateKTableE" ] 
 pub static mut  nsCSSProps_kAnimationPlayStateKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps30kAnimationTimingFunctionKTableE" ] 
 pub static mut  nsCSSProps_kAnimationTimingFunctionKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps17kAppearanceKTableE" ] 
 pub static mut  nsCSSProps_kAppearanceKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps14kAzimuthKTableE" ] 
 pub static mut  nsCSSProps_kAzimuthKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps25kBackfaceVisibilityKTableE" ] 
 pub static mut  nsCSSProps_kBackfaceVisibilityKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps21kTransformStyleKTableE" ] 
 pub static mut  nsCSSProps_kTransformStyleKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps27kImageLayerAttachmentKTableE" ] 
 pub static mut  nsCSSProps_kImageLayerAttachmentKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps23kBackgroundOriginKTableE" ] 
 pub static mut  nsCSSProps_kBackgroundOriginKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps17kMaskOriginKTableE" ] 
 pub static mut  nsCSSProps_kMaskOriginKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps25kImageLayerPositionKTableE" ] 
 pub static mut  nsCSSProps_kImageLayerPositionKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps23kImageLayerRepeatKTableE" ] 
 pub static mut  nsCSSProps_kImageLayerRepeatKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps27kImageLayerRepeatPartKTableE" ] 
 pub static mut  nsCSSProps_kImageLayerRepeatPartKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps21kImageLayerSizeKTableE" ] 
 pub static mut  nsCSSProps_kImageLayerSizeKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps26kImageLayerCompositeKTableE" ] 
 pub static mut  nsCSSProps_kImageLayerCompositeKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps21kImageLayerModeKTableE" ] 
 pub static mut  nsCSSProps_kImageLayerModeKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps21kBackgroundClipKTableE" ] 
 pub static mut  nsCSSProps_kBackgroundClipKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps15kMaskClipKTableE" ] 
 pub static mut  nsCSSProps_kMaskClipKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps16kBlendModeKTableE" ] 
 pub static mut  nsCSSProps_kBlendModeKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps21kBorderCollapseKTableE" ] 
 pub static mut  nsCSSProps_kBorderCollapseKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps24kBorderImageRepeatKTableE" ] 
 pub static mut  nsCSSProps_kBorderImageRepeatKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps23kBorderImageSliceKTableE" ] 
 pub static mut  nsCSSProps_kBorderImageSliceKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps18kBorderStyleKTableE" ] 
 pub static mut  nsCSSProps_kBorderStyleKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps18kBorderWidthKTableE" ] 
 pub static mut  nsCSSProps_kBorderWidthKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps15kBoxAlignKTableE" ] 
 pub static mut  nsCSSProps_kBoxAlignKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps25kBoxDecorationBreakKTableE" ] 
 pub static mut  nsCSSProps_kBoxDecorationBreakKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps19kBoxDirectionKTableE" ] 
 pub static mut  nsCSSProps_kBoxDirectionKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps16kBoxOrientKTableE" ] 
 pub static mut  nsCSSProps_kBoxOrientKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps14kBoxPackKTableE" ] 
 pub static mut  nsCSSProps_kBoxPackKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps26kClipPathGeometryBoxKTableE" ] 
 pub static mut  nsCSSProps_kClipPathGeometryBoxKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps19kCounterRangeKTableE" ] 
 pub static mut  nsCSSProps_kCounterRangeKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps21kCounterSpeakAsKTableE" ] 
 pub static mut  nsCSSProps_kCounterSpeakAsKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps27kCounterSymbolsSystemKTableE" ] 
 pub static mut  nsCSSProps_kCounterSymbolsSystemKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps20kCounterSystemKTableE" ] 
 pub static mut  nsCSSProps_kCounterSystemKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps23kDominantBaselineKTableE" ] 
 pub static mut  nsCSSProps_kDominantBaselineKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps18kShapeRadiusKTableE" ] 
 pub static mut  nsCSSProps_kShapeRadiusKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps15kFillRuleKTableE" ] 
 pub static mut  nsCSSProps_kFillRuleKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps21kFilterFunctionKTableE" ] 
 pub static mut  nsCSSProps_kFilterFunctionKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps21kImageRenderingKTableE" ] 
 pub static mut  nsCSSProps_kImageRenderingKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps27kShapeOutsideShapeBoxKTableE" ] 
 pub static mut  nsCSSProps_kShapeOutsideShapeBoxKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps21kShapeRenderingKTableE" ] 
 pub static mut  nsCSSProps_kShapeRenderingKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps20kStrokeLinecapKTableE" ] 
 pub static mut  nsCSSProps_kStrokeLinecapKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps21kStrokeLinejoinKTableE" ] 
 pub static mut  nsCSSProps_kStrokeLinejoinKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps25kStrokeContextValueKTableE" ] 
 pub static mut  nsCSSProps_kStrokeContextValueKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps19kVectorEffectKTableE" ] 
 pub static mut  nsCSSProps_kVectorEffectKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps17kTextAnchorKTableE" ] 
 pub static mut  nsCSSProps_kTextAnchorKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps20kTextRenderingKTableE" ] 
 pub static mut  nsCSSProps_kTextRenderingKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps18kColorAdjustKTableE" ] 
 pub static mut  nsCSSProps_kColorAdjustKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps25kColorInterpolationKTableE" ] 
 pub static mut  nsCSSProps_kColorInterpolationKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps17kColumnFillKTableE" ] 
 pub static mut  nsCSSProps_kColumnFillKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps17kColumnSpanKTableE" ] 
 pub static mut  nsCSSProps_kColumnSpanKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps20kBoxPropSourceKTableE" ] 
 pub static mut  nsCSSProps_kBoxPropSourceKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps20kBoxShadowTypeKTableE" ] 
 pub static mut  nsCSSProps_kBoxShadowTypeKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps16kBoxSizingKTableE" ] 
 pub static mut  nsCSSProps_kBoxSizingKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps18kCaptionSideKTableE" ] 
 pub static mut  nsCSSProps_kCaptionSideKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps12kClearKTableE" ] 
 pub static mut  nsCSSProps_kClearKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps12kColorKTableE" ] 
 pub static mut  nsCSSProps_kColorKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps14kContentKTableE" ] 
 pub static mut  nsCSSProps_kContentKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps33kControlCharacterVisibilityKTableE" ] 
 pub static mut  nsCSSProps_kControlCharacterVisibilityKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps13kCursorKTableE" ] 
 pub static mut  nsCSSProps_kCursorKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps16kDirectionKTableE" ] 
 pub static mut  nsCSSProps_kDirectionKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps14kDisplayKTableE" ] 
 pub static mut  nsCSSProps_kDisplayKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps16kElevationKTableE" ] 
 pub static mut  nsCSSProps_kElevationKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps17kEmptyCellsKTableE" ] 
 pub static mut  nsCSSProps_kEmptyCellsKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps17kAlignAllKeywordsE" ] 
 pub static mut  nsCSSProps_kAlignAllKeywords  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps22kAlignOverflowPositionE" ] 
 pub static mut  nsCSSProps_kAlignOverflowPosition  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps18kAlignSelfPositionE" ] 
 pub static mut  nsCSSProps_kAlignSelfPosition  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps12kAlignLegacyE" ] 
 pub static mut  nsCSSProps_kAlignLegacy  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps20kAlignLegacyPositionE" ] 
 pub static mut  nsCSSProps_kAlignLegacyPosition  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps31kAlignAutoNormalStretchBaselineE" ] 
 pub static mut  nsCSSProps_kAlignAutoNormalStretchBaseline  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps27kAlignNormalStretchBaselineE" ] 
 pub static mut  nsCSSProps_kAlignNormalStretchBaseline  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps20kAlignNormalBaselineE" ] 
 pub static mut  nsCSSProps_kAlignNormalBaseline  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps25kAlignContentDistributionE" ] 
 pub static mut  nsCSSProps_kAlignContentDistribution  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps21kAlignContentPositionE" ] 
 pub static mut  nsCSSProps_kAlignContentPosition  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps31kAutoCompletionAlignJustifySelfE" ] 
 pub static mut  nsCSSProps_kAutoCompletionAlignJustifySelf  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps25kAutoCompletionAlignItemsE" ] 
 pub static mut  nsCSSProps_kAutoCompletionAlignItems  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps34kAutoCompletionAlignJustifyContentE" ] 
 pub static mut  nsCSSProps_kAutoCompletionAlignJustifyContent  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps20kFlexDirectionKTableE" ] 
 pub static mut  nsCSSProps_kFlexDirectionKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps15kFlexWrapKTableE" ] 
 pub static mut  nsCSSProps_kFlexWrapKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps12kFloatKTableE" ] 
 pub static mut  nsCSSProps_kFloatKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps16kFloatEdgeKTableE" ] 
 pub static mut  nsCSSProps_kFloatEdgeKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps18kFontDisplayKTableE" ] 
 pub static mut  nsCSSProps_kFontDisplayKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps11kFontKTableE" ] 
 pub static mut  nsCSSProps_kFontKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps18kFontKerningKTableE" ] 
 pub static mut  nsCSSProps_kFontKerningKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps15kFontSizeKTableE" ] 
 pub static mut  nsCSSProps_kFontSizeKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps20kFontSmoothingKTableE" ] 
 pub static mut  nsCSSProps_kFontSmoothingKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps18kFontStretchKTableE" ] 
 pub static mut  nsCSSProps_kFontStretchKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps16kFontStyleKTableE" ] 
 pub static mut  nsCSSProps_kFontStyleKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps20kFontSynthesisKTableE" ] 
 pub static mut  nsCSSProps_kFontSynthesisKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps18kFontVariantKTableE" ] 
 pub static mut  nsCSSProps_kFontVariantKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps28kFontVariantAlternatesKTableE" ] 
 pub static mut  nsCSSProps_kFontVariantAlternatesKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps33kFontVariantAlternatesFuncsKTableE" ] 
 pub static mut  nsCSSProps_kFontVariantAlternatesFuncsKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps22kFontVariantCapsKTableE" ] 
 pub static mut  nsCSSProps_kFontVariantCapsKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps27kFontVariantEastAsianKTableE" ] 
 pub static mut  nsCSSProps_kFontVariantEastAsianKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps27kFontVariantLigaturesKTableE" ] 
 pub static mut  nsCSSProps_kFontVariantLigaturesKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps25kFontVariantNumericKTableE" ] 
 pub static mut  nsCSSProps_kFontVariantNumericKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps26kFontVariantPositionKTableE" ] 
 pub static mut  nsCSSProps_kFontVariantPositionKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps17kFontWeightKTableE" ] 
 pub static mut  nsCSSProps_kFontWeightKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps19kGridAutoFlowKTableE" ] 
 pub static mut  nsCSSProps_kGridAutoFlowKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps23kGridTrackBreadthKTableE" ] 
 pub static mut  nsCSSProps_kGridTrackBreadthKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps14kHyphensKTableE" ] 
 pub static mut  nsCSSProps_kHyphensKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps23kImageOrientationKTableE" ] 
 pub static mut  nsCSSProps_kImageOrientationKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps27kImageOrientationFlipKTableE" ] 
 pub static mut  nsCSSProps_kImageOrientationFlipKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps16kIsolationKTableE" ] 
 pub static mut  nsCSSProps_kIsolationKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps14kIMEModeKTableE" ] 
 pub static mut  nsCSSProps_kIMEModeKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps17kLineHeightKTableE" ] 
 pub static mut  nsCSSProps_kLineHeightKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps24kListStylePositionKTableE" ] 
 pub static mut  nsCSSProps_kListStylePositionKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps15kMaskTypeKTableE" ] 
 pub static mut  nsCSSProps_kMaskTypeKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps18kMathVariantKTableE" ] 
 pub static mut  nsCSSProps_kMathVariantKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps18kMathDisplayKTableE" ] 
 pub static mut  nsCSSProps_kMathDisplayKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps14kContainKTableE" ] 
 pub static mut  nsCSSProps_kContainKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps21kContextOpacityKTableE" ] 
 pub static mut  nsCSSProps_kContextOpacityKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps21kContextPatternKTableE" ] 
 pub static mut  nsCSSProps_kContextPatternKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps16kObjectFitKTableE" ] 
 pub static mut  nsCSSProps_kObjectFitKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps13kOrientKTableE" ] 
 pub static mut  nsCSSProps_kOrientKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps19kOutlineStyleKTableE" ] 
 pub static mut  nsCSSProps_kOutlineStyleKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps15kOverflowKTableE" ] 
 pub static mut  nsCSSProps_kOverflowKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps18kOverflowSubKTableE" ] 
 pub static mut  nsCSSProps_kOverflowSubKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps22kOverflowClipBoxKTableE" ] 
 pub static mut  nsCSSProps_kOverflowClipBoxKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps19kOverflowWrapKTableE" ] 
 pub static mut  nsCSSProps_kOverflowWrapKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps16kPageBreakKTableE" ] 
 pub static mut  nsCSSProps_kPageBreakKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps22kPageBreakInsideKTableE" ] 
 pub static mut  nsCSSProps_kPageBreakInsideKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps16kPageMarksKTableE" ] 
 pub static mut  nsCSSProps_kPageMarksKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps15kPageSizeKTableE" ] 
 pub static mut  nsCSSProps_kPageSizeKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps12kPitchKTableE" ] 
 pub static mut  nsCSSProps_kPitchKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps20kPointerEventsKTableE" ] 
 pub static mut  nsCSSProps_kPointerEventsKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps15kPositionKTableE" ] 
 pub static mut  nsCSSProps_kPositionKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps26kRadialGradientShapeKTableE" ] 
 pub static mut  nsCSSProps_kRadialGradientShapeKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps25kRadialGradientSizeKTableE" ] 
 pub static mut  nsCSSProps_kRadialGradientSizeKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps31kRadialGradientLegacySizeKTableE" ] 
 pub static mut  nsCSSProps_kRadialGradientLegacySizeKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps13kResizeKTableE" ] 
 pub static mut  nsCSSProps_kResizeKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps16kRubyAlignKTableE" ] 
 pub static mut  nsCSSProps_kRubyAlignKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps19kRubyPositionKTableE" ] 
 pub static mut  nsCSSProps_kRubyPositionKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps21kScrollBehaviorKTableE" ] 
 pub static mut  nsCSSProps_kScrollBehaviorKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps25kOverscrollBehaviorKTableE" ] 
 pub static mut  nsCSSProps_kOverscrollBehaviorKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps21kScrollSnapTypeKTableE" ] 
 pub static mut  nsCSSProps_kScrollSnapTypeKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps12kSpeakKTableE" ] 
 pub static mut  nsCSSProps_kSpeakKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps18kSpeakHeaderKTableE" ] 
 pub static mut  nsCSSProps_kSpeakHeaderKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps19kSpeakNumeralKTableE" ] 
 pub static mut  nsCSSProps_kSpeakNumeralKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps23kSpeakPunctuationKTableE" ] 
 pub static mut  nsCSSProps_kSpeakPunctuationKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps17kSpeechRateKTableE" ] 
 pub static mut  nsCSSProps_kSpeechRateKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps18kStackSizingKTableE" ] 
 pub static mut  nsCSSProps_kStackSizingKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps18kTableLayoutKTableE" ] 
 pub static mut  nsCSSProps_kTableLayoutKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps16kTextAlignKTableE" ] 
 pub static mut  nsCSSProps_kTextAlignKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps20kTextAlignLastKTableE" ] 
 pub static mut  nsCSSProps_kTextAlignLastKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps25kTextCombineUprightKTableE" ] 
 pub static mut  nsCSSProps_kTextCombineUprightKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps25kTextDecorationLineKTableE" ] 
 pub static mut  nsCSSProps_kTextDecorationLineKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps26kTextDecorationStyleKTableE" ] 
 pub static mut  nsCSSProps_kTextDecorationStyleKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps27kTextEmphasisPositionKTableE" ] 
 pub static mut  nsCSSProps_kTextEmphasisPositionKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps28kTextEmphasisStyleFillKTableE" ] 
 pub static mut  nsCSSProps_kTextEmphasisStyleFillKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps29kTextEmphasisStyleShapeKTableE" ] 
 pub static mut  nsCSSProps_kTextEmphasisStyleShapeKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps18kTextJustifyKTableE" ] 
 pub static mut  nsCSSProps_kTextJustifyKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps22kTextOrientationKTableE" ] 
 pub static mut  nsCSSProps_kTextOrientationKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps19kTextOverflowKTableE" ] 
 pub static mut  nsCSSProps_kTextOverflowKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps21kTextSizeAdjustKTableE" ] 
 pub static mut  nsCSSProps_kTextSizeAdjustKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps20kTextTransformKTableE" ] 
 pub static mut  nsCSSProps_kTextTransformKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps18kTouchActionKTableE" ] 
 pub static mut  nsCSSProps_kTouchActionKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps15kTopLayerKTableE" ] 
 pub static mut  nsCSSProps_kTopLayerKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps19kTransformBoxKTableE" ] 
 pub static mut  nsCSSProps_kTransformBoxKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps31kTransitionTimingFunctionKTableE" ] 
 pub static mut  nsCSSProps_kTransitionTimingFunctionKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps18kUnicodeBidiKTableE" ] 
 pub static mut  nsCSSProps_kUnicodeBidiKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps16kUserFocusKTableE" ] 
 pub static mut  nsCSSProps_kUserFocusKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps16kUserInputKTableE" ] 
 pub static mut  nsCSSProps_kUserInputKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps17kUserModifyKTableE" ] 
 pub static mut  nsCSSProps_kUserModifyKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps17kUserSelectKTableE" ] 
 pub static mut  nsCSSProps_kUserSelectKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps20kVerticalAlignKTableE" ] 
 pub static mut  nsCSSProps_kVerticalAlignKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps17kVisibilityKTableE" ] 
 pub static mut  nsCSSProps_kVisibilityKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps13kVolumeKTableE" ] 
 pub static mut  nsCSSProps_kVolumeKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps17kWhitespaceKTableE" ] 
 pub static mut  nsCSSProps_kWhitespaceKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps12kWidthKTableE" ] 
 pub static mut  nsCSSProps_kWidthKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps21kWindowDraggingKTableE" ] 
 pub static mut  nsCSSProps_kWindowDraggingKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps19kWindowShadowKTableE" ] 
 pub static mut  nsCSSProps_kWindowShadowKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps16kWordBreakKTableE" ] 
 pub static mut  nsCSSProps_kWordBreakKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN10nsCSSProps18kWritingModeKTableE" ] 
 pub static mut  nsCSSProps_kWritingModeKTable  :  [ root :: nsCSSProps_KTableEntry ; 0usize ] ;
} # [ test ] fn bindgen_test_layout_nsCSSProps ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSProps > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( nsCSSProps ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSProps > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( nsCSSProps ) ) ) ; } impl Clone for nsCSSProps { fn clone ( & self ) -> Self { * self } } 
 /// Class to safely handle main-thread-only pointers off the main thread.
    ///
    /// Classes like XPCWrappedJS are main-thread-only, which means that it is
    /// forbidden to call methods on instances of these classes off the main thread.
    /// For various reasons (see bug 771074), this restriction recently began to
    /// apply to AddRef/Release as well.
    ///
    /// This presents a problem for consumers that wish to hold a callback alive
    /// on non-main-thread code. A common example of this is the proxy callback
    /// pattern, where non-main-thread code holds a strong-reference to the callback
    /// object, and dispatches new Runnables (also with a strong reference) to the
    /// main thread in order to execute the callback. This involves several AddRef
    /// and Release calls on the other thread, which is (now) verboten.
    ///
    /// The basic idea of this class is to introduce a layer of indirection.
    /// nsMainThreadPtrHolder is a threadsafe reference-counted class that internally
    /// maintains one strong reference to the main-thread-only object. It must be
    /// instantiated on the main thread (so that the AddRef of the underlying object
    /// happens on the main thread), but consumers may subsequently pass references
    /// to the holder anywhere they please. These references are meant to be opaque
    /// when accessed off-main-thread (assertions enforce this).
    ///
    /// The semantics of RefPtr<nsMainThreadPtrHolder<T> > would be cumbersome, so
    /// we also introduce nsMainThreadPtrHandle<T>, which is conceptually identical
    /// to the above (though it includes various convenience methods). The basic
    /// pattern is as follows.
    ///
    /// // On the main thread:
    /// nsCOMPtr<nsIFooCallback> callback = ...;
    /// nsMainThreadPtrHandle<nsIFooCallback> callbackHandle =
    /// new nsMainThreadPtrHolder<nsIFooCallback>(callback);
    /// // Pass callbackHandle to structs/classes that might be accessed on other
    /// // threads.
    ///
    /// All structs and classes that might be accessed on other threads should store
    /// an nsMainThreadPtrHandle<T> rather than an nsCOMPtr<T>. 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsMainThreadPtrHolder < T > { pub mRefCnt : root :: mozilla :: ThreadSafeAutoRefCnt , pub mRawPtr : * mut T , pub mStrict : bool , pub mMainThreadEventTarget : root :: nsCOMPtr , pub mName : * const :: std :: os :: raw :: c_char , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , } pub type nsMainThreadPtrHolder_HasThreadSafeRefCnt = root :: mozilla :: TrueType ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsMainThreadPtrHandle < T > { pub mPtr : root :: RefPtr < root :: nsMainThreadPtrHolder < T > > , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsCSSUnit { eCSSUnit_Null = 0 , eCSSUnit_Auto = 1 , eCSSUnit_Inherit = 2 , eCSSUnit_Initial = 3 , eCSSUnit_Unset = 4 , eCSSUnit_None = 5 , eCSSUnit_Normal = 6 , eCSSUnit_System_Font = 7 , eCSSUnit_All = 8 , eCSSUnit_Dummy = 9 , eCSSUnit_DummyInherit = 10 , eCSSUnit_String = 11 , eCSSUnit_Ident = 12 , eCSSUnit_Attr = 14 , eCSSUnit_Local_Font = 15 , eCSSUnit_Font_Format = 16 , eCSSUnit_Element = 17 , eCSSUnit_Array = 20 , eCSSUnit_Counter = 21 , eCSSUnit_Counters = 22 , eCSSUnit_Cubic_Bezier = 23 , eCSSUnit_Steps = 24 , eCSSUnit_Symbols = 25 , eCSSUnit_Function = 26 , eCSSUnit_Calc = 30 , eCSSUnit_Calc_Plus = 31 , eCSSUnit_Calc_Minus = 32 , eCSSUnit_Calc_Times_L = 33 , eCSSUnit_Calc_Times_R = 34 , eCSSUnit_Calc_Divided = 35 , eCSSUnit_URL = 40 , eCSSUnit_Image = 41 , eCSSUnit_Gradient = 42 , eCSSUnit_TokenStream = 43 , eCSSUnit_GridTemplateAreas = 44 , eCSSUnit_Pair = 50 , eCSSUnit_Triplet = 51 , eCSSUnit_Rect = 52 , eCSSUnit_List = 53 , eCSSUnit_ListDep = 54 , eCSSUnit_SharedList = 55 , eCSSUnit_PairList = 56 , eCSSUnit_PairListDep = 57 , eCSSUnit_FontFamilyList = 58 , eCSSUnit_AtomIdent = 60 , eCSSUnit_Integer = 70 , eCSSUnit_Enumerated = 71 , eCSSUnit_EnumColor = 80 , eCSSUnit_RGBColor = 81 , eCSSUnit_RGBAColor = 82 , eCSSUnit_HexColor = 83 , eCSSUnit_ShortHexColor = 84 , eCSSUnit_HexColorAlpha = 85 , eCSSUnit_ShortHexColorAlpha = 86 , eCSSUnit_PercentageRGBColor = 87 , eCSSUnit_PercentageRGBAColor = 88 , eCSSUnit_HSLColor = 89 , eCSSUnit_HSLAColor = 90 , eCSSUnit_ComplexColor = 91 , eCSSUnit_Percent = 100 , eCSSUnit_Number = 101 , eCSSUnit_ViewportWidth = 700 , eCSSUnit_ViewportHeight = 701 , eCSSUnit_ViewportMin = 702 , eCSSUnit_ViewportMax = 703 , eCSSUnit_EM = 800 , eCSSUnit_XHeight = 801 , eCSSUnit_Char = 802 , eCSSUnit_RootEM = 803 , eCSSUnit_Point = 900 , eCSSUnit_Inch = 901 , eCSSUnit_Millimeter = 902 , eCSSUnit_Centimeter = 903 , eCSSUnit_Pica = 904 , eCSSUnit_Quarter = 905 , eCSSUnit_Pixel = 906 , eCSSUnit_Degree = 1000 , eCSSUnit_Grad = 1001 , eCSSUnit_Radian = 1002 , eCSSUnit_Turn = 1003 , eCSSUnit_Hertz = 2000 , eCSSUnit_Kilohertz = 2001 , eCSSUnit_Seconds = 3000 , eCSSUnit_Milliseconds = 3001 , eCSSUnit_FlexFraction = 4000 , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCSSValue { pub mUnit : root :: nsCSSUnit , pub mValue : root :: nsCSSValue__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsCSSValue__bindgen_ty_1 { pub mInt : root :: __BindgenUnionField < i32 > , pub mFloat : root :: __BindgenUnionField < f32 > , pub mString : root :: __BindgenUnionField < * mut root :: nsStringBuffer > , pub mColor : root :: __BindgenUnionField < root :: nscolor > , pub mAtom : root :: __BindgenUnionField < * mut root :: nsAtom > , pub mArray : root :: __BindgenUnionField < * mut root :: nsCSSValue_Array > , pub mURL : root :: __BindgenUnionField < * mut root :: mozilla :: css :: URLValue > , pub mImage : root :: __BindgenUnionField < * mut root :: mozilla :: css :: ImageValue > , pub mGridTemplateAreas : root :: __BindgenUnionField < * mut root :: mozilla :: css :: GridTemplateAreasValue > , pub mGradient : root :: __BindgenUnionField < * mut root :: nsCSSValueGradient > , pub mTokenStream : root :: __BindgenUnionField < * mut root :: nsCSSValueTokenStream > , pub mPair : root :: __BindgenUnionField < * mut root :: nsCSSValuePair_heap > , pub mRect : root :: __BindgenUnionField < * mut root :: nsCSSRect_heap > , pub mTriplet : root :: __BindgenUnionField < * mut root :: nsCSSValueTriplet_heap > , pub mList : root :: __BindgenUnionField < * mut root :: nsCSSValueList_heap > , pub mListDependent : root :: __BindgenUnionField < * mut root :: nsCSSValueList > , pub mSharedList : root :: __BindgenUnionField < * mut root :: nsCSSValueSharedList > , pub mPairList : root :: __BindgenUnionField < * mut root :: nsCSSValuePairList_heap > , pub mPairListDependent : root :: __BindgenUnionField < * mut root :: nsCSSValuePairList > , pub mFloatColor : root :: __BindgenUnionField < * mut root :: nsCSSValueFloatColor > , pub mFontFamilyList : root :: __BindgenUnionField < * mut root :: mozilla :: SharedFontList > , pub mComplexColor : root :: __BindgenUnionField < * mut root :: mozilla :: css :: ComplexColorValue > , pub bindgen_union_field : u64 , } # [ test ] fn bindgen_test_layout_nsCSSValue__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSValue__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSValue__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSValue__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mInt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mInt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mFloat as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mFloat ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mString as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mString ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mColor as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mAtom as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mAtom ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mArray as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mArray ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mURL as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mURL ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mImage as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mImage ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mGridTemplateAreas as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mGridTemplateAreas ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mGradient as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mGradient ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mTokenStream as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mTokenStream ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mPair as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mPair ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mRect as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mRect ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mTriplet as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mTriplet ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mList as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mListDependent as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mListDependent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mSharedList as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mSharedList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mPairList as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mPairList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mPairListDependent as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mPairListDependent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mFloatColor as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mFloatColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mFontFamilyList as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mFontFamilyList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mComplexColor as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mComplexColor ) ) ) ; } impl Clone for nsCSSValue__bindgen_ty_1 { fn clone ( & self ) -> Self { * self } } # [ test ] fn bindgen_test_layout_nsCSSValue ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSValue > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsCSSValue ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSValue > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue ) ) . mUnit as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue ) , "::" , stringify ! ( mUnit ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue ) ) . mValue as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue ) , "::" , stringify ! ( mValue ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCSSValue_Array { pub mRefCnt : root :: mozilla :: ThreadSafeAutoRefCnt , pub mCount : usize , pub mArray : [ root :: nsCSSValue ; 1usize ] , } pub type nsCSSValue_Array_HasThreadSafeRefCnt = root :: mozilla :: TrueType ; # [ test ] fn bindgen_test_layout_nsCSSValue_Array ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSValue_Array > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( nsCSSValue_Array ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSValue_Array > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSValue_Array ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue_Array ) ) . mRefCnt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue_Array ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue_Array ) ) . mCount as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue_Array ) , "::" , stringify ! ( mCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValue_Array ) ) . mArray as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValue_Array ) , "::" , stringify ! ( mArray ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCSSValueList { pub mValue : root :: nsCSSValue , pub mNext : * mut root :: nsCSSValueList , } # [ test ] fn bindgen_test_layout_nsCSSValueList ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSValueList > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsCSSValueList ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSValueList > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSValueList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueList ) ) . mValue as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueList ) , "::" , stringify ! ( mValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueList ) ) . mNext as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueList ) , "::" , stringify ! ( mNext ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCSSValueList_heap { pub _base : root :: nsCSSValueList , pub mRefCnt : root :: nsAutoRefCnt , } pub type nsCSSValueList_heap_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ test ] fn bindgen_test_layout_nsCSSValueList_heap ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSValueList_heap > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( nsCSSValueList_heap ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSValueList_heap > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSValueList_heap ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueList_heap ) ) . mRefCnt as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueList_heap ) , "::" , stringify ! ( mRefCnt ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCSSValueSharedList { pub mRefCnt : root :: mozilla :: ThreadSafeAutoRefCnt , pub mHead : * mut root :: nsCSSValueList , } pub type nsCSSValueSharedList_HasThreadSafeRefCnt = root :: mozilla :: TrueType ; # [ test ] fn bindgen_test_layout_nsCSSValueSharedList ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSValueSharedList > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsCSSValueSharedList ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSValueSharedList > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSValueSharedList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueSharedList ) ) . mRefCnt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueSharedList ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueSharedList ) ) . mHead as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueSharedList ) , "::" , stringify ! ( mHead ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCSSRect { pub mTop : root :: nsCSSValue , pub mRight : root :: nsCSSValue , pub mBottom : root :: nsCSSValue , pub mLeft : root :: nsCSSValue , } pub type nsCSSRect_side_type = * mut root :: nsCSSValue ; extern "C" {
 # [ link_name = "\u{1}_ZN9nsCSSRect5sidesE" ] 
 pub static mut  nsCSSRect_sides  :  [ root :: nsCSSRect_side_type ; 4usize ] ;
} # [ test ] fn bindgen_test_layout_nsCSSRect ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSRect > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( nsCSSRect ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSRect > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSRect ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSRect ) ) . mTop as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSRect ) , "::" , stringify ! ( mTop ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSRect ) ) . mRight as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSRect ) , "::" , stringify ! ( mRight ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSRect ) ) . mBottom as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSRect ) , "::" , stringify ! ( mBottom ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSRect ) ) . mLeft as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSRect ) , "::" , stringify ! ( mLeft ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCSSRect_heap { pub _base : root :: nsCSSRect , pub mRefCnt : root :: nsAutoRefCnt , } pub type nsCSSRect_heap_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ test ] fn bindgen_test_layout_nsCSSRect_heap ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSRect_heap > ( ) , 72usize , concat ! ( "Size of: " , stringify ! ( nsCSSRect_heap ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSRect_heap > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSRect_heap ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSRect_heap ) ) . mRefCnt as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSRect_heap ) , "::" , stringify ! ( mRefCnt ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCSSValuePair { pub mXValue : root :: nsCSSValue , pub mYValue : root :: nsCSSValue , } # [ test ] fn bindgen_test_layout_nsCSSValuePair ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSValuePair > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( nsCSSValuePair ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSValuePair > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSValuePair ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValuePair ) ) . mXValue as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValuePair ) , "::" , stringify ! ( mXValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValuePair ) ) . mYValue as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValuePair ) , "::" , stringify ! ( mYValue ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCSSValuePair_heap { pub _base : root :: nsCSSValuePair , pub mRefCnt : root :: nsAutoRefCnt , } pub type nsCSSValuePair_heap_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ test ] fn bindgen_test_layout_nsCSSValuePair_heap ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSValuePair_heap > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( nsCSSValuePair_heap ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSValuePair_heap > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSValuePair_heap ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValuePair_heap ) ) . mRefCnt as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValuePair_heap ) , "::" , stringify ! ( mRefCnt ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCSSValueTriplet { pub mXValue : root :: nsCSSValue , pub mYValue : root :: nsCSSValue , pub mZValue : root :: nsCSSValue , } # [ test ] fn bindgen_test_layout_nsCSSValueTriplet ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSValueTriplet > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( nsCSSValueTriplet ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSValueTriplet > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSValueTriplet ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueTriplet ) ) . mXValue as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueTriplet ) , "::" , stringify ! ( mXValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueTriplet ) ) . mYValue as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueTriplet ) , "::" , stringify ! ( mYValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueTriplet ) ) . mZValue as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueTriplet ) , "::" , stringify ! ( mZValue ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCSSValueTriplet_heap { pub _base : root :: nsCSSValueTriplet , pub mRefCnt : root :: nsAutoRefCnt , } pub type nsCSSValueTriplet_heap_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ test ] fn bindgen_test_layout_nsCSSValueTriplet_heap ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSValueTriplet_heap > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( nsCSSValueTriplet_heap ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSValueTriplet_heap > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSValueTriplet_heap ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueTriplet_heap ) ) . mRefCnt as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueTriplet_heap ) , "::" , stringify ! ( mRefCnt ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCSSValuePairList { pub mXValue : root :: nsCSSValue , pub mYValue : root :: nsCSSValue , pub mNext : * mut root :: nsCSSValuePairList , } # [ test ] fn bindgen_test_layout_nsCSSValuePairList ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSValuePairList > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( nsCSSValuePairList ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSValuePairList > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSValuePairList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValuePairList ) ) . mXValue as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValuePairList ) , "::" , stringify ! ( mXValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValuePairList ) ) . mYValue as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValuePairList ) , "::" , stringify ! ( mYValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValuePairList ) ) . mNext as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValuePairList ) , "::" , stringify ! ( mNext ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCSSValuePairList_heap { pub _base : root :: nsCSSValuePairList , pub mRefCnt : root :: nsAutoRefCnt , } pub type nsCSSValuePairList_heap_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ test ] fn bindgen_test_layout_nsCSSValuePairList_heap ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSValuePairList_heap > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( nsCSSValuePairList_heap ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSValuePairList_heap > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSValuePairList_heap ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValuePairList_heap ) ) . mRefCnt as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValuePairList_heap ) , "::" , stringify ! ( mRefCnt ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCSSValueGradientStop { pub mLocation : root :: nsCSSValue , pub mColor : root :: nsCSSValue , pub mIsInterpolationHint : bool , } # [ test ] fn bindgen_test_layout_nsCSSValueGradientStop ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSValueGradientStop > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( nsCSSValueGradientStop ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSValueGradientStop > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSValueGradientStop ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueGradientStop ) ) . mLocation as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueGradientStop ) , "::" , stringify ! ( mLocation ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueGradientStop ) ) . mColor as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueGradientStop ) , "::" , stringify ! ( mColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueGradientStop ) ) . mIsInterpolationHint as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueGradientStop ) , "::" , stringify ! ( mIsInterpolationHint ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCSSValueGradient { pub mIsRadial : bool , pub mIsRepeating : bool , pub mIsLegacySyntax : bool , pub mIsMozLegacySyntax : bool , pub mIsExplicitSize : bool , pub mBgPos : root :: nsCSSValuePair , pub mAngle : root :: nsCSSValue , pub mRadialValues : [ root :: nsCSSValue ; 2usize ] , pub mStops : root :: nsTArray < root :: nsCSSValueGradientStop > , pub mRefCnt : root :: nsAutoRefCnt , } pub type nsCSSValueGradient_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ test ] fn bindgen_test_layout_nsCSSValueGradient ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSValueGradient > ( ) , 104usize , concat ! ( "Size of: " , stringify ! ( nsCSSValueGradient ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSValueGradient > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSValueGradient ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueGradient ) ) . mIsRadial as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueGradient ) , "::" , stringify ! ( mIsRadial ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueGradient ) ) . mIsRepeating as * const _ as usize } , 1usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueGradient ) , "::" , stringify ! ( mIsRepeating ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueGradient ) ) . mIsLegacySyntax as * const _ as usize } , 2usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueGradient ) , "::" , stringify ! ( mIsLegacySyntax ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueGradient ) ) . mIsMozLegacySyntax as * const _ as usize } , 3usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueGradient ) , "::" , stringify ! ( mIsMozLegacySyntax ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueGradient ) ) . mIsExplicitSize as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueGradient ) , "::" , stringify ! ( mIsExplicitSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueGradient ) ) . mBgPos as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueGradient ) , "::" , stringify ! ( mBgPos ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueGradient ) ) . mAngle as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueGradient ) , "::" , stringify ! ( mAngle ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueGradient ) ) . mRadialValues as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueGradient ) , "::" , stringify ! ( mRadialValues ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueGradient ) ) . mStops as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueGradient ) , "::" , stringify ! ( mStops ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueGradient ) ) . mRefCnt as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueGradient ) , "::" , stringify ! ( mRefCnt ) ) ) ; } # [ repr ( C ) ] pub struct nsCSSValueTokenStream { pub mRefCnt : root :: nsAutoRefCnt , pub mPropertyID : root :: nsCSSPropertyID , pub mShorthandPropertyID : root :: nsCSSPropertyID , pub mTokenStream : ::nsstring::nsStringRepr , pub mBaseURI : root :: nsCOMPtr , pub mSheetURI : root :: nsCOMPtr , pub mSheetPrincipal : root :: nsCOMPtr , pub mLineNumber : u32 , pub mLineOffset : u32 , pub mLevel : root :: mozilla :: SheetType , } pub type nsCSSValueTokenStream_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ test ] fn bindgen_test_layout_nsCSSValueTokenStream ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSValueTokenStream > ( ) , 72usize , concat ! ( "Size of: " , stringify ! ( nsCSSValueTokenStream ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSValueTokenStream > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSValueTokenStream ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueTokenStream ) ) . mRefCnt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueTokenStream ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueTokenStream ) ) . mPropertyID as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueTokenStream ) , "::" , stringify ! ( mPropertyID ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueTokenStream ) ) . mShorthandPropertyID as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueTokenStream ) , "::" , stringify ! ( mShorthandPropertyID ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueTokenStream ) ) . mTokenStream as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueTokenStream ) , "::" , stringify ! ( mTokenStream ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueTokenStream ) ) . mBaseURI as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueTokenStream ) , "::" , stringify ! ( mBaseURI ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueTokenStream ) ) . mSheetURI as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueTokenStream ) , "::" , stringify ! ( mSheetURI ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueTokenStream ) ) . mSheetPrincipal as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueTokenStream ) , "::" , stringify ! ( mSheetPrincipal ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueTokenStream ) ) . mLineNumber as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueTokenStream ) , "::" , stringify ! ( mLineNumber ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueTokenStream ) ) . mLineOffset as * const _ as usize } , 60usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueTokenStream ) , "::" , stringify ! ( mLineOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueTokenStream ) ) . mLevel as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueTokenStream ) , "::" , stringify ! ( mLevel ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCSSValueFloatColor { pub mRefCnt : root :: nsAutoRefCnt , pub mComponent1 : f32 , pub mComponent2 : f32 , pub mComponent3 : f32 , pub mAlpha : f32 , } pub type nsCSSValueFloatColor_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ test ] fn bindgen_test_layout_nsCSSValueFloatColor ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSValueFloatColor > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsCSSValueFloatColor ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSValueFloatColor > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSValueFloatColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueFloatColor ) ) . mRefCnt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueFloatColor ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueFloatColor ) ) . mComponent1 as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueFloatColor ) , "::" , stringify ! ( mComponent1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueFloatColor ) ) . mComponent2 as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueFloatColor ) , "::" , stringify ! ( mComponent2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueFloatColor ) ) . mComponent3 as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueFloatColor ) , "::" , stringify ! ( mComponent3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSValueFloatColor ) ) . mAlpha as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSValueFloatColor ) , "::" , stringify ! ( mAlpha ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct imgIContainer { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct imgIRequest { pub _base : root :: nsIRequest , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct imgIRequest_COMTypeInfo { pub _address : u8 , } pub const imgIRequest_STATUS_NONE : root :: imgIRequest__bindgen_ty_1 = 0 ; pub const imgIRequest_STATUS_SIZE_AVAILABLE : root :: imgIRequest__bindgen_ty_1 = 1 ; pub const imgIRequest_STATUS_LOAD_COMPLETE : root :: imgIRequest__bindgen_ty_1 = 2 ; pub const imgIRequest_STATUS_ERROR : root :: imgIRequest__bindgen_ty_1 = 4 ; pub const imgIRequest_STATUS_FRAME_COMPLETE : root :: imgIRequest__bindgen_ty_1 = 8 ; pub const imgIRequest_STATUS_DECODE_COMPLETE : root :: imgIRequest__bindgen_ty_1 = 16 ; pub const imgIRequest_STATUS_IS_ANIMATED : root :: imgIRequest__bindgen_ty_1 = 32 ; pub const imgIRequest_STATUS_HAS_TRANSPARENCY : root :: imgIRequest__bindgen_ty_1 = 64 ; pub type imgIRequest__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; pub const imgIRequest_CORS_NONE : root :: imgIRequest__bindgen_ty_2 = 1 ; pub const imgIRequest_CORS_ANONYMOUS : root :: imgIRequest__bindgen_ty_2 = 2 ; pub const imgIRequest_CORS_USE_CREDENTIALS : root :: imgIRequest__bindgen_ty_2 = 3 ; pub type imgIRequest__bindgen_ty_2 = :: std :: os :: raw :: c_uint ; pub const imgIRequest_CATEGORY_FRAME_INIT : root :: imgIRequest__bindgen_ty_3 = 1 ; pub const imgIRequest_CATEGORY_SIZE_QUERY : root :: imgIRequest__bindgen_ty_3 = 2 ; pub const imgIRequest_CATEGORY_DISPLAY : root :: imgIRequest__bindgen_ty_3 = 4 ; pub type imgIRequest__bindgen_ty_3 = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_imgIRequest ( ) { assert_eq ! ( :: std :: mem :: size_of :: < imgIRequest > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( imgIRequest ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < imgIRequest > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( imgIRequest ) ) ) ; } impl Clone for imgIRequest { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsISecurityInfoProvider { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsISecurityInfoProvider_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsISecurityInfoProvider ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsISecurityInfoProvider > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsISecurityInfoProvider ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsISecurityInfoProvider > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsISecurityInfoProvider ) ) ) ; } impl Clone for nsISecurityInfoProvider { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsISupportsPriority { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsISupportsPriority_COMTypeInfo { pub _address : u8 , } pub const nsISupportsPriority_PRIORITY_HIGHEST : root :: nsISupportsPriority__bindgen_ty_1 = -20 ; pub const nsISupportsPriority_PRIORITY_HIGH : root :: nsISupportsPriority__bindgen_ty_1 = -10 ; pub const nsISupportsPriority_PRIORITY_NORMAL : root :: nsISupportsPriority__bindgen_ty_1 = 0 ; pub const nsISupportsPriority_PRIORITY_LOW : root :: nsISupportsPriority__bindgen_ty_1 = 10 ; pub const nsISupportsPriority_PRIORITY_LOWEST : root :: nsISupportsPriority__bindgen_ty_1 = 20 ; pub type nsISupportsPriority__bindgen_ty_1 = :: std :: os :: raw :: c_int ; # [ test ] fn bindgen_test_layout_nsISupportsPriority ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsISupportsPriority > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsISupportsPriority ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsISupportsPriority > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsISupportsPriority ) ) ) ; } impl Clone for nsISupportsPriority { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsITimedChannel { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsITimedChannel_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsITimedChannel ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsITimedChannel > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsITimedChannel ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsITimedChannel > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsITimedChannel ) ) ) ; } impl Clone for nsITimedChannel { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIInterfaceRequestor { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIInterfaceRequestor_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIInterfaceRequestor ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIInterfaceRequestor > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIInterfaceRequestor ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIInterfaceRequestor > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIInterfaceRequestor ) ) ) ; } impl Clone for nsIInterfaceRequestor { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ProxyBehaviour { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct imgRequestProxy { pub _base : root :: imgIRequest , pub _base_1 : root :: mozilla :: image :: IProgressObserver , pub _base_2 : root :: nsISupportsPriority , pub _base_3 : root :: nsISecurityInfoProvider , pub _base_4 : root :: nsITimedChannel , pub mRefCnt : root :: nsAutoRefCnt , pub mBehaviour : root :: mozilla :: UniquePtr < root :: ProxyBehaviour > , pub mURI : root :: RefPtr < root :: imgRequestProxy_ImageURL > , pub mListener : * mut root :: imgINotificationObserver , pub mLoadGroup : root :: nsCOMPtr , pub mTabGroup : root :: RefPtr < root :: mozilla :: dom :: TabGroup > , pub mEventTarget : root :: nsCOMPtr , pub mLoadFlags : root :: nsLoadFlags , pub mLockCount : u32 , pub mAnimationConsumers : u32 , pub _bitfield_1 : u8 , pub __bindgen_padding_0 : [ u8 ; 3usize ] , } pub type imgRequestProxy_Image = root :: mozilla :: image :: Image ; pub type imgRequestProxy_ImageURL = root :: mozilla :: image :: ImageURL ; pub type imgRequestProxy_ProgressTracker = root :: mozilla :: image :: ProgressTracker ; pub type imgRequestProxy_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct imgRequestProxy_imgCancelRunnable { pub _base : root :: mozilla :: Runnable , pub mOwner : root :: RefPtr < root :: imgRequestProxy > , pub mStatus : root :: nsresult , } # [ test ] fn bindgen_test_layout_imgRequestProxy_imgCancelRunnable ( ) { assert_eq ! ( :: std :: mem :: size_of :: < imgRequestProxy_imgCancelRunnable > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( imgRequestProxy_imgCancelRunnable ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < imgRequestProxy_imgCancelRunnable > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( imgRequestProxy_imgCancelRunnable ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const imgRequestProxy_imgCancelRunnable ) ) . mOwner as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( imgRequestProxy_imgCancelRunnable ) , "::" , stringify ! ( mOwner ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const imgRequestProxy_imgCancelRunnable ) ) . mStatus as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( imgRequestProxy_imgCancelRunnable ) , "::" , stringify ! ( mStatus ) ) ) ; } # [ test ] fn bindgen_test_layout_imgRequestProxy ( ) { assert_eq ! ( :: std :: mem :: size_of :: < imgRequestProxy > ( ) , 120usize , concat ! ( "Size of: " , stringify ! ( imgRequestProxy ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < imgRequestProxy > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( imgRequestProxy ) ) ) ; } impl imgRequestProxy { # [ inline ] pub fn mCanceled ( & self ) -> bool { let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0x1 as u8 ; let val = ( unit_field_val & mask ) >> 0usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mCanceled ( & mut self , val : bool ) { let mask = 0x1 as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 0usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn mIsInLoadGroup ( & self ) -> bool { let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0x2 as u8 ; let val = ( unit_field_val & mask ) >> 1usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIsInLoadGroup ( & mut self , val : bool ) { let mask = 0x2 as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 1usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn mForceDispatchLoadGroup ( & self ) -> bool { let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0x4 as u8 ; let val = ( unit_field_val & mask ) >> 2usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mForceDispatchLoadGroup ( & mut self , val : bool ) { let mask = 0x4 as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 2usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn mListenerIsStrongRef ( & self ) -> bool { let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0x8 as u8 ; let val = ( unit_field_val & mask ) >> 3usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mListenerIsStrongRef ( & mut self , val : bool ) { let mask = 0x8 as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 3usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn mDecodeRequested ( & self ) -> bool { let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0x10 as u8 ; let val = ( unit_field_val & mask ) >> 4usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mDecodeRequested ( & mut self , val : bool ) { let mask = 0x10 as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 4usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn mDeferNotifications ( & self ) -> bool { let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0x20 as u8 ; let val = ( unit_field_val & mask ) >> 5usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mDeferNotifications ( & mut self , val : bool ) { let mask = 0x20 as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 5usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn mHadListener ( & self ) -> bool { let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0x40 as u8 ; let val = ( unit_field_val & mask ) >> 6usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mHadListener ( & mut self , val : bool ) { let mask = 0x40 as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 6usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn mHadDispatch ( & self ) -> bool { let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0x80 as u8 ; let val = ( unit_field_val & mask ) >> 7usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mHadDispatch ( & mut self , val : bool ) { let mask = 0x80 as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 7usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn new_bitfield_1 ( mCanceled : bool , mIsInLoadGroup : bool , mForceDispatchLoadGroup : bool , mListenerIsStrongRef : bool , mDecodeRequested : bool , mDeferNotifications : bool , mHadListener : bool , mHadDispatch : bool ) -> u8 { ( ( ( ( ( ( ( ( 0 | ( ( mCanceled as u8 as u8 ) << 0usize ) & ( 0x1 as u8 ) ) | ( ( mIsInLoadGroup as u8 as u8 ) << 1usize ) & ( 0x2 as u8 ) ) | ( ( mForceDispatchLoadGroup as u8 as u8 ) << 2usize ) & ( 0x4 as u8 ) ) | ( ( mListenerIsStrongRef as u8 as u8 ) << 3usize ) & ( 0x8 as u8 ) ) | ( ( mDecodeRequested as u8 as u8 ) << 4usize ) & ( 0x10 as u8 ) ) | ( ( mDeferNotifications as u8 as u8 ) << 5usize ) & ( 0x20 as u8 ) ) | ( ( mHadListener as u8 as u8 ) << 6usize ) & ( 0x40 as u8 ) ) | ( ( mHadDispatch as u8 as u8 ) << 7usize ) & ( 0x80 as u8 ) ) } } # [ repr ( C ) ] pub struct nsStyleFont { pub mFont : root :: nsFont , pub mSize : root :: nscoord , pub mFontSizeFactor : f32 , pub mFontSizeOffset : root :: nscoord , pub mFontSizeKeyword : u8 , pub mGenericID : u8 , pub mScriptLevel : i8 , pub mMathVariant : u8 , pub mMathDisplay : u8 , pub mMinFontSizeRatio : u8 , pub mExplicitLanguage : bool , pub mAllowZoom : bool , pub mScriptUnconstrainedSize : root :: nscoord , pub mScriptMinSize : root :: nscoord , pub mScriptSizeMultiplier : f32 , pub mLanguage : root :: RefPtr < root :: nsAtom > , } pub const nsStyleFont_kHasFinishStyle : bool = false ; # [ test ] fn bindgen_test_layout_nsStyleFont ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleFont > ( ) , 136usize , concat ! ( "Size of: " , stringify ! ( nsStyleFont ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleFont > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleFont ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleFont ) ) . mFont as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleFont ) , "::" , stringify ! ( mFont ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleFont ) ) . mSize as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleFont ) , "::" , stringify ! ( mSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleFont ) ) . mFontSizeFactor as * const _ as usize } , 100usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleFont ) , "::" , stringify ! ( mFontSizeFactor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleFont ) ) . mFontSizeOffset as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleFont ) , "::" , stringify ! ( mFontSizeOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleFont ) ) . mFontSizeKeyword as * const _ as usize } , 108usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleFont ) , "::" , stringify ! ( mFontSizeKeyword ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleFont ) ) . mGenericID as * const _ as usize } , 109usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleFont ) , "::" , stringify ! ( mGenericID ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleFont ) ) . mScriptLevel as * const _ as usize } , 110usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleFont ) , "::" , stringify ! ( mScriptLevel ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleFont ) ) . mMathVariant as * const _ as usize } , 111usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleFont ) , "::" , stringify ! ( mMathVariant ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleFont ) ) . mMathDisplay as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleFont ) , "::" , stringify ! ( mMathDisplay ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleFont ) ) . mMinFontSizeRatio as * const _ as usize } , 113usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleFont ) , "::" , stringify ! ( mMinFontSizeRatio ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleFont ) ) . mExplicitLanguage as * const _ as usize } , 114usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleFont ) , "::" , stringify ! ( mExplicitLanguage ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleFont ) ) . mAllowZoom as * const _ as usize } , 115usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleFont ) , "::" , stringify ! ( mAllowZoom ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleFont ) ) . mScriptUnconstrainedSize as * const _ as usize } , 116usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleFont ) , "::" , stringify ! ( mScriptUnconstrainedSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleFont ) ) . mScriptMinSize as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleFont ) , "::" , stringify ! ( mScriptMinSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleFont ) ) . mScriptSizeMultiplier as * const _ as usize } , 124usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleFont ) , "::" , stringify ! ( mScriptSizeMultiplier ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleFont ) ) . mLanguage as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleFont ) , "::" , stringify ! ( mLanguage ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleGradientStop { pub mLocation : root :: nsStyleCoord , pub mColor : root :: nscolor , pub mIsInterpolationHint : bool , } # [ test ] fn bindgen_test_layout_nsStyleGradientStop ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleGradientStop > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsStyleGradientStop ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleGradientStop > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleGradientStop ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGradientStop ) ) . mLocation as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGradientStop ) , "::" , stringify ! ( mLocation ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGradientStop ) ) . mColor as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGradientStop ) , "::" , stringify ! ( mColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGradientStop ) ) . mIsInterpolationHint as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGradientStop ) , "::" , stringify ! ( mIsInterpolationHint ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleGradient { pub mShape : u8 , pub mSize : u8 , pub mRepeating : bool , pub mLegacySyntax : bool , pub mMozLegacySyntax : bool , pub mBgPosX : root :: nsStyleCoord , pub mBgPosY : root :: nsStyleCoord , pub mAngle : root :: nsStyleCoord , pub mRadiusX : root :: nsStyleCoord , pub mRadiusY : root :: nsStyleCoord , pub mStops : root :: nsTArray < root :: nsStyleGradientStop > , pub mRefCnt : root :: mozilla :: ThreadSafeAutoRefCnt , } pub type nsStyleGradient_HasThreadSafeRefCnt = root :: mozilla :: TrueType ; # [ test ] fn bindgen_test_layout_nsStyleGradient ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleGradient > ( ) , 104usize , concat ! ( "Size of: " , stringify ! ( nsStyleGradient ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleGradient > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleGradient ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGradient ) ) . mShape as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGradient ) , "::" , stringify ! ( mShape ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGradient ) ) . mSize as * const _ as usize } , 1usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGradient ) , "::" , stringify ! ( mSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGradient ) ) . mRepeating as * const _ as usize } , 2usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGradient ) , "::" , stringify ! ( mRepeating ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGradient ) ) . mLegacySyntax as * const _ as usize } , 3usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGradient ) , "::" , stringify ! ( mLegacySyntax ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGradient ) ) . mMozLegacySyntax as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGradient ) , "::" , stringify ! ( mMozLegacySyntax ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGradient ) ) . mBgPosX as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGradient ) , "::" , stringify ! ( mBgPosX ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGradient ) ) . mBgPosY as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGradient ) , "::" , stringify ! ( mBgPosY ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGradient ) ) . mAngle as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGradient ) , "::" , stringify ! ( mAngle ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGradient ) ) . mRadiusX as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGradient ) , "::" , stringify ! ( mRadiusX ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGradient ) ) . mRadiusY as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGradient ) , "::" , stringify ! ( mRadiusY ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGradient ) ) . mStops as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGradient ) , "::" , stringify ! ( mStops ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGradient ) ) . mRefCnt as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGradient ) , "::" , stringify ! ( mRefCnt ) ) ) ; } 
 /// A wrapper for an imgRequestProxy that supports off-main-thread creation
    /// and equality comparison.
    ///
    /// An nsStyleImageRequest can be created in two ways:
    ///
    /// 1. Using the constructor that takes an imgRequestProxy.  This must
    /// be called from the main thread.  The nsStyleImageRequest is
    /// immediately considered "resolved", and the get() method that
    /// returns the imgRequestProxy can be called.
    ///
    /// 2. Using the constructor that takes the URL, base URI, referrer
    /// and principal that can be used to inititiate an image load and
    /// produce an imgRequestProxy later.  This can be called from
    /// any thread.  The nsStyleImageRequest is not considered "resolved"
    /// at this point, and the Resolve() method must be called later
    /// to initiate the image load and make calls to get() valid.
    ///
    /// Calls to TrackImage(), UntrackImage(), LockImage(), UnlockImage() and
    /// RequestDiscard() are made to the imgRequestProxy and ImageTracker as
    /// appropriate, according to the mode flags passed in to the constructor.
    ///
    /// The main thread constructor takes a pointer to the css::ImageValue that
    /// is the specified url() value, while the off-main-thread constructor
    /// creates a new css::ImageValue to represent the url() information passed
    /// to the constructor.  This ImageValue is held on to for the comparisons done
    /// in DefinitelyEquals(), so that we don't need to call into the non-OMT-safe
    /// Equals() on the nsIURI objects returned from imgRequestProxy::GetURI(). 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleImageRequest { pub mRefCnt : root :: mozilla :: ThreadSafeAutoRefCnt , pub mRequestProxy : root :: RefPtr < root :: imgRequestProxy > , pub mImageValue : root :: RefPtr < root :: mozilla :: css :: ImageValue > , pub mImageTracker : root :: RefPtr < root :: mozilla :: dom :: ImageTracker > , pub mDocGroup : root :: RefPtr < root :: mozilla :: dom :: DocGroup > , pub mModeFlags : root :: nsStyleImageRequest_Mode , pub mResolved : bool , } pub type nsStyleImageRequest_URLValueData = root :: mozilla :: css :: URLValueData ; pub const nsStyleImageRequest_Mode_Track : root :: nsStyleImageRequest_Mode = 1 ; pub const nsStyleImageRequest_Mode_Discard : root :: nsStyleImageRequest_Mode = 2 ; pub type nsStyleImageRequest_Mode = u8 ; pub type nsStyleImageRequest_HasThreadSafeRefCnt = root :: mozilla :: TrueType ; # [ test ] fn bindgen_test_layout_nsStyleImageRequest ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleImageRequest > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( nsStyleImageRequest ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleImageRequest > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleImageRequest ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageRequest ) ) . mRefCnt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageRequest ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageRequest ) ) . mRequestProxy as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageRequest ) , "::" , stringify ! ( mRequestProxy ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageRequest ) ) . mImageValue as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageRequest ) , "::" , stringify ! ( mImageValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageRequest ) ) . mImageTracker as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageRequest ) , "::" , stringify ! ( mImageTracker ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageRequest ) ) . mDocGroup as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageRequest ) , "::" , stringify ! ( mDocGroup ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageRequest ) ) . mModeFlags as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageRequest ) , "::" , stringify ! ( mModeFlags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageRequest ) ) . mResolved as * const _ as usize } , 41usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageRequest ) , "::" , stringify ! ( mResolved ) ) ) ; } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsStyleImageType { eStyleImageType_Null = 0 , eStyleImageType_Image = 1 , eStyleImageType_Gradient = 2 , eStyleImageType_Element = 3 , eStyleImageType_URL = 4 , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct CachedBorderImageData { pub mCachedSVGViewportSize : [ u32 ; 3usize ] , pub mSubImages : root :: nsCOMArray , } # [ test ] fn bindgen_test_layout_CachedBorderImageData ( ) { assert_eq ! ( :: std :: mem :: size_of :: < CachedBorderImageData > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( CachedBorderImageData ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < CachedBorderImageData > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( CachedBorderImageData ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CachedBorderImageData ) ) . mCachedSVGViewportSize as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( CachedBorderImageData ) , "::" , stringify ! ( mCachedSVGViewportSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const CachedBorderImageData ) ) . mSubImages as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( CachedBorderImageData ) , "::" , stringify ! ( mSubImages ) ) ) ; } 
 /// Represents a paintable image of one of the following types.
    /// (1) A real image loaded from an external source.
    /// (2) A CSS linear or radial gradient.
    /// (3) An element within a document, or an <img>, <video>, or <canvas> element
    /// not in a document.
    /// (*) Optionally a crop rect can be set to paint a partial (rectangular)
    /// region of an image. (Currently, this feature is only supported with an
    /// image of type (1)). 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleImage { pub mCachedBIData : root :: mozilla :: UniquePtr < root :: CachedBorderImageData > , pub mType : root :: nsStyleImageType , pub __bindgen_anon_1 : root :: nsStyleImage__bindgen_ty_1 , pub mCropRect : root :: mozilla :: UniquePtr < root :: nsStyleSides > , } pub type nsStyleImage_URLValue = root :: mozilla :: css :: URLValue ; pub type nsStyleImage_URLValueData = root :: mozilla :: css :: URLValueData ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsStyleImage__bindgen_ty_1 { pub mImage : root :: __BindgenUnionField < * mut root :: nsStyleImageRequest > , pub mGradient : root :: __BindgenUnionField < * mut root :: nsStyleGradient > , pub mURLValue : root :: __BindgenUnionField < * mut root :: nsStyleImage_URLValue > , pub mElementId : root :: __BindgenUnionField < * mut root :: nsAtom > , pub bindgen_union_field : u64 , } # [ test ] fn bindgen_test_layout_nsStyleImage__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleImage__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsStyleImage__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleImage__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleImage__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImage__bindgen_ty_1 ) ) . mImage as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImage__bindgen_ty_1 ) , "::" , stringify ! ( mImage ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImage__bindgen_ty_1 ) ) . mGradient as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImage__bindgen_ty_1 ) , "::" , stringify ! ( mGradient ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImage__bindgen_ty_1 ) ) . mURLValue as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImage__bindgen_ty_1 ) , "::" , stringify ! ( mURLValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImage__bindgen_ty_1 ) ) . mElementId as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImage__bindgen_ty_1 ) , "::" , stringify ! ( mElementId ) ) ) ; } impl Clone for nsStyleImage__bindgen_ty_1 { fn clone ( & self ) -> Self { * self } } # [ test ] fn bindgen_test_layout_nsStyleImage ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleImage > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( nsStyleImage ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleImage > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleImage ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImage ) ) . mCachedBIData as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImage ) , "::" , stringify ! ( mCachedBIData ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImage ) ) . mType as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImage ) , "::" , stringify ! ( mType ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImage ) ) . mCropRect as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImage ) , "::" , stringify ! ( mCropRect ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleColor { pub mColor : root :: nscolor , } pub const nsStyleColor_kHasFinishStyle : bool = false ; # [ test ] fn bindgen_test_layout_nsStyleColor ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleColor > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( nsStyleColor ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleColor > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( nsStyleColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleColor ) ) . mColor as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleColor ) , "::" , stringify ! ( mColor ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleImageLayers { pub mAttachmentCount : u32 , pub mClipCount : u32 , pub mOriginCount : u32 , pub mRepeatCount : u32 , pub mPositionXCount : u32 , pub mPositionYCount : u32 , pub mImageCount : u32 , pub mSizeCount : u32 , pub mMaskModeCount : u32 , pub mBlendModeCount : u32 , pub mCompositeCount : u32 , pub mLayers : root :: nsStyleAutoArray < root :: nsStyleImageLayers_Layer > , } pub const nsStyleImageLayers_shorthand : root :: nsStyleImageLayers__bindgen_ty_1 = 0 ; pub const nsStyleImageLayers_color : root :: nsStyleImageLayers__bindgen_ty_1 = 1 ; pub const nsStyleImageLayers_image : root :: nsStyleImageLayers__bindgen_ty_1 = 2 ; pub const nsStyleImageLayers_repeat : root :: nsStyleImageLayers__bindgen_ty_1 = 3 ; pub const nsStyleImageLayers_positionX : root :: nsStyleImageLayers__bindgen_ty_1 = 4 ; pub const nsStyleImageLayers_positionY : root :: nsStyleImageLayers__bindgen_ty_1 = 5 ; pub const nsStyleImageLayers_clip : root :: nsStyleImageLayers__bindgen_ty_1 = 6 ; pub const nsStyleImageLayers_origin : root :: nsStyleImageLayers__bindgen_ty_1 = 7 ; pub const nsStyleImageLayers_size : root :: nsStyleImageLayers__bindgen_ty_1 = 8 ; pub const nsStyleImageLayers_attachment : root :: nsStyleImageLayers__bindgen_ty_1 = 9 ; pub const nsStyleImageLayers_maskMode : root :: nsStyleImageLayers__bindgen_ty_1 = 10 ; pub const nsStyleImageLayers_composite : root :: nsStyleImageLayers__bindgen_ty_1 = 11 ; pub type nsStyleImageLayers__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsStyleImageLayers_LayerType { Background = 0 , Mask = 1 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsStyleImageLayers_Size { pub mWidth : root :: nsStyleImageLayers_Size_Dimension , pub mHeight : root :: nsStyleImageLayers_Size_Dimension , pub mWidthType : u8 , pub mHeightType : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsStyleImageLayers_Size_Dimension { pub _base : root :: nsStyleCoord_CalcValue , } # [ test ] fn bindgen_test_layout_nsStyleImageLayers_Size_Dimension ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleImageLayers_Size_Dimension > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( nsStyleImageLayers_Size_Dimension ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleImageLayers_Size_Dimension > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( nsStyleImageLayers_Size_Dimension ) ) ) ; } impl Clone for nsStyleImageLayers_Size_Dimension { fn clone ( & self ) -> Self { * self } } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsStyleImageLayers_Size_DimensionType { eContain = 0 , eCover = 1 , eAuto = 2 , eLengthPercentage = 3 , eDimensionType_COUNT = 4 , } # [ test ] fn bindgen_test_layout_nsStyleImageLayers_Size ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleImageLayers_Size > ( ) , 28usize , concat ! ( "Size of: " , stringify ! ( nsStyleImageLayers_Size ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleImageLayers_Size > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( nsStyleImageLayers_Size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers_Size ) ) . mWidth as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers_Size ) , "::" , stringify ! ( mWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers_Size ) ) . mHeight as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers_Size ) , "::" , stringify ! ( mHeight ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers_Size ) ) . mWidthType as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers_Size ) , "::" , stringify ! ( mWidthType ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers_Size ) ) . mHeightType as * const _ as usize } , 25usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers_Size ) , "::" , stringify ! ( mHeightType ) ) ) ; } impl Clone for nsStyleImageLayers_Size { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsStyleImageLayers_Repeat { pub mXRepeat : root :: mozilla :: StyleImageLayerRepeat , pub mYRepeat : root :: mozilla :: StyleImageLayerRepeat , } # [ test ] fn bindgen_test_layout_nsStyleImageLayers_Repeat ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleImageLayers_Repeat > ( ) , 2usize , concat ! ( "Size of: " , stringify ! ( nsStyleImageLayers_Repeat ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleImageLayers_Repeat > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( nsStyleImageLayers_Repeat ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers_Repeat ) ) . mXRepeat as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers_Repeat ) , "::" , stringify ! ( mXRepeat ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers_Repeat ) ) . mYRepeat as * const _ as usize } , 1usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers_Repeat ) , "::" , stringify ! ( mYRepeat ) ) ) ; } impl Clone for nsStyleImageLayers_Repeat { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleImageLayers_Layer { pub mImage : root :: nsStyleImage , pub mPosition : root :: mozilla :: Position , pub mSize : root :: nsStyleImageLayers_Size , pub mClip : root :: nsStyleImageLayers_Layer_StyleGeometryBox , pub mOrigin : root :: nsStyleImageLayers_Layer_StyleGeometryBox , pub mAttachment : u8 , pub mBlendMode : u8 , pub mComposite : u8 , pub mMaskMode : u8 , pub mRepeat : root :: nsStyleImageLayers_Repeat , } pub use self :: super :: root :: mozilla :: StyleGeometryBox as nsStyleImageLayers_Layer_StyleGeometryBox ; # [ test ] fn bindgen_test_layout_nsStyleImageLayers_Layer ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleImageLayers_Layer > ( ) , 96usize , concat ! ( "Size of: " , stringify ! ( nsStyleImageLayers_Layer ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleImageLayers_Layer > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleImageLayers_Layer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) . mImage as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers_Layer ) , "::" , stringify ! ( mImage ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) . mPosition as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers_Layer ) , "::" , stringify ! ( mPosition ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) . mSize as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers_Layer ) , "::" , stringify ! ( mSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) . mClip as * const _ as usize } , 84usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers_Layer ) , "::" , stringify ! ( mClip ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) . mOrigin as * const _ as usize } , 85usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers_Layer ) , "::" , stringify ! ( mOrigin ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) . mAttachment as * const _ as usize } , 86usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers_Layer ) , "::" , stringify ! ( mAttachment ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) . mBlendMode as * const _ as usize } , 87usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers_Layer ) , "::" , stringify ! ( mBlendMode ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) . mComposite as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers_Layer ) , "::" , stringify ! ( mComposite ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) . mMaskMode as * const _ as usize } , 89usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers_Layer ) , "::" , stringify ! ( mMaskMode ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) . mRepeat as * const _ as usize } , 90usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers_Layer ) , "::" , stringify ! ( mRepeat ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}_ZN18nsStyleImageLayers21kBackgroundLayerTableE" ] 
 pub static mut  nsStyleImageLayers_kBackgroundLayerTable  :  [ root :: nsCSSPropertyID ; 0usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN18nsStyleImageLayers15kMaskLayerTableE" ] 
 pub static mut  nsStyleImageLayers_kMaskLayerTable  :  [ root :: nsCSSPropertyID ; 0usize ] ;
} # [ test ] fn bindgen_test_layout_nsStyleImageLayers ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleImageLayers > ( ) , 152usize , concat ! ( "Size of: " , stringify ! ( nsStyleImageLayers ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleImageLayers > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleImageLayers ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers ) ) . mAttachmentCount as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers ) , "::" , stringify ! ( mAttachmentCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers ) ) . mClipCount as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers ) , "::" , stringify ! ( mClipCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers ) ) . mOriginCount as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers ) , "::" , stringify ! ( mOriginCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers ) ) . mRepeatCount as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers ) , "::" , stringify ! ( mRepeatCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers ) ) . mPositionXCount as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers ) , "::" , stringify ! ( mPositionXCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers ) ) . mPositionYCount as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers ) , "::" , stringify ! ( mPositionYCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers ) ) . mImageCount as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers ) , "::" , stringify ! ( mImageCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers ) ) . mSizeCount as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers ) , "::" , stringify ! ( mSizeCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers ) ) . mMaskModeCount as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers ) , "::" , stringify ! ( mMaskModeCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers ) ) . mBlendModeCount as * const _ as usize } , 36usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers ) , "::" , stringify ! ( mBlendModeCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers ) ) . mCompositeCount as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers ) , "::" , stringify ! ( mCompositeCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageLayers ) ) . mLayers as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageLayers ) , "::" , stringify ! ( mLayers ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleBackground { pub mImage : root :: nsStyleImageLayers , pub mBackgroundColor : root :: mozilla :: StyleComplexColor , } pub const nsStyleBackground_kHasFinishStyle : bool = true ; # [ test ] fn bindgen_test_layout_nsStyleBackground ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleBackground > ( ) , 160usize , concat ! ( "Size of: " , stringify ! ( nsStyleBackground ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleBackground > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleBackground ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleBackground ) ) . mImage as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleBackground ) , "::" , stringify ! ( mImage ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleBackground ) ) . mBackgroundColor as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleBackground ) , "::" , stringify ! ( mBackgroundColor ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleMargin { pub mMargin : root :: nsStyleSides , } pub const nsStyleMargin_kHasFinishStyle : bool = false ; # [ test ] fn bindgen_test_layout_nsStyleMargin ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleMargin > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( nsStyleMargin ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleMargin > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleMargin ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleMargin ) ) . mMargin as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleMargin ) , "::" , stringify ! ( mMargin ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStylePadding { pub mPadding : root :: nsStyleSides , } pub const nsStylePadding_kHasFinishStyle : bool = false ; # [ test ] fn bindgen_test_layout_nsStylePadding ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStylePadding > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( nsStylePadding ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStylePadding > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStylePadding ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePadding ) ) . mPadding as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePadding ) , "::" , stringify ! ( mPadding ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCSSShadowItem { pub mXOffset : root :: nscoord , pub mYOffset : root :: nscoord , pub mRadius : root :: nscoord , pub mSpread : root :: nscoord , pub mColor : root :: nscolor , pub mHasColor : bool , pub mInset : bool , } # [ test ] fn bindgen_test_layout_nsCSSShadowItem ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSShadowItem > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsCSSShadowItem ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSShadowItem > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( nsCSSShadowItem ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSShadowItem ) ) . mXOffset as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSShadowItem ) , "::" , stringify ! ( mXOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSShadowItem ) ) . mYOffset as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSShadowItem ) , "::" , stringify ! ( mYOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSShadowItem ) ) . mRadius as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSShadowItem ) , "::" , stringify ! ( mRadius ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSShadowItem ) ) . mSpread as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSShadowItem ) , "::" , stringify ! ( mSpread ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSShadowItem ) ) . mColor as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSShadowItem ) , "::" , stringify ! ( mColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSShadowItem ) ) . mHasColor as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSShadowItem ) , "::" , stringify ! ( mHasColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSShadowItem ) ) . mInset as * const _ as usize } , 21usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSShadowItem ) , "::" , stringify ! ( mInset ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCSSShadowArray { pub mRefCnt : root :: mozilla :: ThreadSafeAutoRefCnt , pub mLength : u32 , pub mArray : [ root :: nsCSSShadowItem ; 1usize ] , } pub type nsCSSShadowArray_HasThreadSafeRefCnt = root :: mozilla :: TrueType ; # [ test ] fn bindgen_test_layout_nsCSSShadowArray ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSShadowArray > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( nsCSSShadowArray ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSShadowArray > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSShadowArray ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSShadowArray ) ) . mRefCnt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSShadowArray ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSShadowArray ) ) . mLength as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSShadowArray ) , "::" , stringify ! ( mLength ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSShadowArray ) ) . mArray as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSShadowArray ) , "::" , stringify ! ( mArray ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsBorderColors { pub mColors : [ root :: nsTArray < root :: nscolor > ; 4usize ] , } # [ test ] fn bindgen_test_layout_nsBorderColors ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsBorderColors > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( nsBorderColors ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsBorderColors > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsBorderColors ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsBorderColors ) ) . mColors as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsBorderColors ) , "::" , stringify ! ( mColors ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleBorder { pub mBorderColors : root :: mozilla :: UniquePtr < root :: nsBorderColors > , pub mBorderRadius : root :: nsStyleCorners , pub mBorderImageSource : root :: nsStyleImage , pub mBorderImageSlice : root :: nsStyleSides , pub mBorderImageWidth : root :: nsStyleSides , pub mBorderImageOutset : root :: nsStyleSides , pub mBorderImageFill : u8 , pub mBorderImageRepeatH : root :: mozilla :: StyleBorderImageRepeat , pub mBorderImageRepeatV : root :: mozilla :: StyleBorderImageRepeat , pub mFloatEdge : root :: mozilla :: StyleFloatEdge , pub mBoxDecorationBreak : root :: mozilla :: StyleBoxDecorationBreak , pub mBorderStyle : [ u8 ; 4usize ] , pub __bindgen_anon_1 : root :: nsStyleBorder__bindgen_ty_1 , pub mComputedBorder : root :: nsMargin , pub mBorder : root :: nsMargin , pub mTwipsPerPixel : root :: nscoord , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsStyleBorder__bindgen_ty_1 { pub __bindgen_anon_1 : root :: __BindgenUnionField < root :: nsStyleBorder__bindgen_ty_1__bindgen_ty_1 > , pub mBorderColor : root :: __BindgenUnionField < [ root :: mozilla :: StyleComplexColor ; 4usize ] > , pub bindgen_union_field : [ u32 ; 8usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsStyleBorder__bindgen_ty_1__bindgen_ty_1 { pub mBorderTopColor : root :: mozilla :: StyleComplexColor , pub mBorderRightColor : root :: mozilla :: StyleComplexColor , pub mBorderBottomColor : root :: mozilla :: StyleComplexColor , pub mBorderLeftColor : root :: mozilla :: StyleComplexColor , } # [ test ] fn bindgen_test_layout_nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleBorder__bindgen_ty_1__bindgen_ty_1 > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleBorder__bindgen_ty_1__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) ) . mBorderTopColor as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( mBorderTopColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) ) . mBorderRightColor as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( mBorderRightColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) ) . mBorderBottomColor as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( mBorderBottomColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) ) . mBorderLeftColor as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( mBorderLeftColor ) ) ) ; } impl Clone for nsStyleBorder__bindgen_ty_1__bindgen_ty_1 { fn clone ( & self ) -> Self { * self } } # [ test ] fn bindgen_test_layout_nsStyleBorder__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleBorder__bindgen_ty_1 > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( nsStyleBorder__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleBorder__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( nsStyleBorder__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleBorder__bindgen_ty_1 ) ) . mBorderColor as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleBorder__bindgen_ty_1 ) , "::" , stringify ! ( mBorderColor ) ) ) ; } impl Clone for nsStyleBorder__bindgen_ty_1 { fn clone ( & self ) -> Self { * self } } pub const nsStyleBorder_kHasFinishStyle : bool = true ; # [ test ] fn bindgen_test_layout_nsStyleBorder ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleBorder > ( ) , 312usize , concat ! ( "Size of: " , stringify ! ( nsStyleBorder ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleBorder > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleBorder ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleBorder ) ) . mBorderColors as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleBorder ) , "::" , stringify ! ( mBorderColors ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleBorder ) ) . mBorderRadius as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleBorder ) , "::" , stringify ! ( mBorderRadius ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleBorder ) ) . mBorderImageSource as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleBorder ) , "::" , stringify ! ( mBorderImageSource ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleBorder ) ) . mBorderImageSlice as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleBorder ) , "::" , stringify ! ( mBorderImageSlice ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleBorder ) ) . mBorderImageWidth as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleBorder ) , "::" , stringify ! ( mBorderImageWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleBorder ) ) . mBorderImageOutset as * const _ as usize } , 192usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleBorder ) , "::" , stringify ! ( mBorderImageOutset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleBorder ) ) . mBorderImageFill as * const _ as usize } , 232usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleBorder ) , "::" , stringify ! ( mBorderImageFill ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleBorder ) ) . mBorderImageRepeatH as * const _ as usize } , 233usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleBorder ) , "::" , stringify ! ( mBorderImageRepeatH ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleBorder ) ) . mBorderImageRepeatV as * const _ as usize } , 234usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleBorder ) , "::" , stringify ! ( mBorderImageRepeatV ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleBorder ) ) . mFloatEdge as * const _ as usize } , 235usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleBorder ) , "::" , stringify ! ( mFloatEdge ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleBorder ) ) . mBoxDecorationBreak as * const _ as usize } , 236usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleBorder ) , "::" , stringify ! ( mBoxDecorationBreak ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleBorder ) ) . mBorderStyle as * const _ as usize } , 237usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleBorder ) , "::" , stringify ! ( mBorderStyle ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleBorder ) ) . mComputedBorder as * const _ as usize } , 276usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleBorder ) , "::" , stringify ! ( mComputedBorder ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleBorder ) ) . mBorder as * const _ as usize } , 292usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleBorder ) , "::" , stringify ! ( mBorder ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleBorder ) ) . mTwipsPerPixel as * const _ as usize } , 308usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleBorder ) , "::" , stringify ! ( mTwipsPerPixel ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleOutline { pub mOutlineRadius : root :: nsStyleCorners , pub mOutlineWidth : root :: nscoord , pub mOutlineOffset : root :: nscoord , pub mOutlineColor : root :: mozilla :: StyleComplexColor , pub mOutlineStyle : u8 , pub mActualOutlineWidth : root :: nscoord , pub mTwipsPerPixel : root :: nscoord , } pub const nsStyleOutline_kHasFinishStyle : bool = false ; # [ test ] fn bindgen_test_layout_nsStyleOutline ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleOutline > ( ) , 104usize , concat ! ( "Size of: " , stringify ! ( nsStyleOutline ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleOutline > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleOutline ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleOutline ) ) . mOutlineRadius as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleOutline ) , "::" , stringify ! ( mOutlineRadius ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleOutline ) ) . mOutlineWidth as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleOutline ) , "::" , stringify ! ( mOutlineWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleOutline ) ) . mOutlineOffset as * const _ as usize } , 76usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleOutline ) , "::" , stringify ! ( mOutlineOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleOutline ) ) . mOutlineColor as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleOutline ) , "::" , stringify ! ( mOutlineColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleOutline ) ) . mOutlineStyle as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleOutline ) , "::" , stringify ! ( mOutlineStyle ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleOutline ) ) . mActualOutlineWidth as * const _ as usize } , 92usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleOutline ) , "::" , stringify ! ( mActualOutlineWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleOutline ) ) . mTwipsPerPixel as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleOutline ) , "::" , stringify ! ( mTwipsPerPixel ) ) ) ; } 
 /// An object that allows sharing of arrays that store 'quotes' property
    /// values.  This is particularly important for inheritance, where we want
    /// to share the same 'quotes' value with a parent style context. 
 # [ repr ( C ) ] pub struct nsStyleQuoteValues { pub mRefCnt : root :: mozilla :: ThreadSafeAutoRefCnt , pub mQuotePairs : root :: nsStyleQuoteValues_QuotePairArray , } pub type nsStyleQuoteValues_QuotePairArray = root :: nsTArray < root :: std :: pair < ::nsstring::nsStringRepr , ::nsstring::nsStringRepr > > ; pub type nsStyleQuoteValues_HasThreadSafeRefCnt = root :: mozilla :: TrueType ; # [ test ] fn bindgen_test_layout_nsStyleQuoteValues ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleQuoteValues > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsStyleQuoteValues ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleQuoteValues > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleQuoteValues ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleQuoteValues ) ) . mRefCnt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleQuoteValues ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleQuoteValues ) ) . mQuotePairs as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleQuoteValues ) , "::" , stringify ! ( mQuotePairs ) ) ) ; } # [ repr ( C ) ] pub struct nsStyleList { pub mListStylePosition : u8 , pub mListStyleImage : root :: RefPtr < root :: nsStyleImageRequest > , pub mCounterStyle : root :: mozilla :: CounterStylePtr , pub mQuotes : root :: RefPtr < root :: nsStyleQuoteValues > , pub mImageRegion : root :: nsRect , } pub const nsStyleList_kHasFinishStyle : bool = true ; extern "C" {
 # [ link_name = "\u{1}_ZN11nsStyleList14sInitialQuotesE" ] 
 pub static mut  nsStyleList_sInitialQuotes  :  root :: mozilla :: StaticRefPtr < root :: nsStyleQuoteValues > ;
} extern "C" {
 # [ link_name = "\u{1}_ZN11nsStyleList11sNoneQuotesE" ] 
 pub static mut  nsStyleList_sNoneQuotes  :  root :: mozilla :: StaticRefPtr < root :: nsStyleQuoteValues > ;
} # [ test ] fn bindgen_test_layout_nsStyleList ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleList > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( nsStyleList ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleList > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleList ) ) . mListStylePosition as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleList ) , "::" , stringify ! ( mListStylePosition ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleList ) ) . mListStyleImage as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleList ) , "::" , stringify ! ( mListStyleImage ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleList ) ) . mCounterStyle as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleList ) , "::" , stringify ! ( mCounterStyle ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleList ) ) . mQuotes as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleList ) , "::" , stringify ! ( mQuotes ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleList ) ) . mImageRegion as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleList ) , "::" , stringify ! ( mImageRegion ) ) ) ; } # [ test ] fn __bindgen_test_layout_StaticRefPtr_open0_nsStyleQuoteValues_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: StaticRefPtr < root :: nsStyleQuoteValues > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: StaticRefPtr < root :: nsStyleQuoteValues > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: StaticRefPtr < root :: nsStyleQuoteValues > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: StaticRefPtr < root :: nsStyleQuoteValues > ) ) ) ; } # [ test ] fn __bindgen_test_layout_StaticRefPtr_open0_nsStyleQuoteValues_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: StaticRefPtr < root :: nsStyleQuoteValues > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: StaticRefPtr < root :: nsStyleQuoteValues > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: StaticRefPtr < root :: nsStyleQuoteValues > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: StaticRefPtr < root :: nsStyleQuoteValues > ) ) ) ; } # [ repr ( C ) ] pub struct nsStyleGridLine { pub mHasSpan : bool , pub mInteger : i32 , pub mLineName : ::nsstring::nsStringRepr , } pub const nsStyleGridLine_kMinLine : i32 = -10000 ; pub const nsStyleGridLine_kMaxLine : i32 = 10000 ; # [ test ] fn bindgen_test_layout_nsStyleGridLine ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleGridLine > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsStyleGridLine ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleGridLine > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleGridLine ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGridLine ) ) . mHasSpan as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGridLine ) , "::" , stringify ! ( mHasSpan ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGridLine ) ) . mInteger as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGridLine ) , "::" , stringify ! ( mInteger ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGridLine ) ) . mLineName as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGridLine ) , "::" , stringify ! ( mLineName ) ) ) ; } # [ repr ( C ) ] pub struct nsStyleGridTemplate { pub mLineNameLists : root :: nsTArray < root :: nsTArray < ::nsstring::nsStringRepr > > , pub mMinTrackSizingFunctions : root :: nsTArray < root :: nsStyleCoord > , pub mMaxTrackSizingFunctions : root :: nsTArray < root :: nsStyleCoord > , pub mRepeatAutoLineNameListBefore : root :: nsTArray < ::nsstring::nsStringRepr > , pub mRepeatAutoLineNameListAfter : root :: nsTArray < ::nsstring::nsStringRepr > , pub mRepeatAutoIndex : i16 , pub _bitfield_1 : u8 , pub __bindgen_padding_0 : [ u8 ; 5usize ] , } # [ test ] fn bindgen_test_layout_nsStyleGridTemplate ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleGridTemplate > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( nsStyleGridTemplate ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleGridTemplate > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleGridTemplate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGridTemplate ) ) . mLineNameLists as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGridTemplate ) , "::" , stringify ! ( mLineNameLists ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGridTemplate ) ) . mMinTrackSizingFunctions as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGridTemplate ) , "::" , stringify ! ( mMinTrackSizingFunctions ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGridTemplate ) ) . mMaxTrackSizingFunctions as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGridTemplate ) , "::" , stringify ! ( mMaxTrackSizingFunctions ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGridTemplate ) ) . mRepeatAutoLineNameListBefore as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGridTemplate ) , "::" , stringify ! ( mRepeatAutoLineNameListBefore ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGridTemplate ) ) . mRepeatAutoLineNameListAfter as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGridTemplate ) , "::" , stringify ! ( mRepeatAutoLineNameListAfter ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleGridTemplate ) ) . mRepeatAutoIndex as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleGridTemplate ) , "::" , stringify ! ( mRepeatAutoIndex ) ) ) ; } impl nsStyleGridTemplate { # [ inline ] pub fn mIsAutoFill ( & self ) -> bool { let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0x1 as u8 ; let val = ( unit_field_val & mask ) >> 0usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIsAutoFill ( & mut self , val : bool ) { let mask = 0x1 as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 0usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn mIsSubgrid ( & self ) -> bool { let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0x2 as u8 ; let val = ( unit_field_val & mask ) >> 1usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mIsSubgrid ( & mut self , val : bool ) { let mask = 0x2 as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 1usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn new_bitfield_1 ( mIsAutoFill : bool , mIsSubgrid : bool ) -> u8 { ( ( 0 | ( ( mIsAutoFill as u8 as u8 ) << 0usize ) & ( 0x1 as u8 ) ) | ( ( mIsSubgrid as u8 as u8 ) << 1usize ) & ( 0x2 as u8 ) ) } } # [ repr ( C ) ] pub struct nsStylePosition { pub mObjectPosition : root :: mozilla :: Position , pub mOffset : root :: nsStyleSides , pub mWidth : root :: nsStyleCoord , pub mMinWidth : root :: nsStyleCoord , pub mMaxWidth : root :: nsStyleCoord , pub mHeight : root :: nsStyleCoord , pub mMinHeight : root :: nsStyleCoord , pub mMaxHeight : root :: nsStyleCoord , pub mFlexBasis : root :: nsStyleCoord , pub mGridAutoColumnsMin : root :: nsStyleCoord , pub mGridAutoColumnsMax : root :: nsStyleCoord , pub mGridAutoRowsMin : root :: nsStyleCoord , pub mGridAutoRowsMax : root :: nsStyleCoord , pub mGridAutoFlow : u8 , pub mBoxSizing : root :: mozilla :: StyleBoxSizing , pub mAlignContent : u16 , pub mAlignItems : u8 , pub mAlignSelf : u8 , pub mJustifyContent : u16 , pub mSpecifiedJustifyItems : u8 , pub mJustifyItems : u8 , pub mJustifySelf : u8 , pub mFlexDirection : u8 , pub mFlexWrap : u8 , pub mObjectFit : u8 , pub mOrder : i32 , pub mFlexGrow : f32 , pub mFlexShrink : f32 , pub mZIndex : root :: nsStyleCoord , pub mGridTemplateColumns : root :: mozilla :: UniquePtr < root :: nsStyleGridTemplate > , pub mGridTemplateRows : root :: mozilla :: UniquePtr < root :: nsStyleGridTemplate > , pub mGridTemplateAreas : root :: RefPtr < root :: mozilla :: css :: GridTemplateAreasValue > , pub mGridColumnStart : root :: nsStyleGridLine , pub mGridColumnEnd : root :: nsStyleGridLine , pub mGridRowStart : root :: nsStyleGridLine , pub mGridRowEnd : root :: nsStyleGridLine , pub mGridColumnGap : root :: nsStyleCoord , pub mGridRowGap : root :: nsStyleCoord , } pub const nsStylePosition_kHasFinishStyle : bool = false ; # [ test ] fn bindgen_test_layout_nsStylePosition ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStylePosition > ( ) , 440usize , concat ! ( "Size of: " , stringify ! ( nsStylePosition ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStylePosition > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStylePosition ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mObjectPosition as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mObjectPosition ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mOffset as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mWidth as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mMinWidth as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mMinWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mMaxWidth as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mMaxWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mHeight as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mHeight ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mMinHeight as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mMinHeight ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mMaxHeight as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mMaxHeight ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mFlexBasis as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mFlexBasis ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mGridAutoColumnsMin as * const _ as usize } , 176usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mGridAutoColumnsMin ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mGridAutoColumnsMax as * const _ as usize } , 192usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mGridAutoColumnsMax ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mGridAutoRowsMin as * const _ as usize } , 208usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mGridAutoRowsMin ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mGridAutoRowsMax as * const _ as usize } , 224usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mGridAutoRowsMax ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mGridAutoFlow as * const _ as usize } , 240usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mGridAutoFlow ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mBoxSizing as * const _ as usize } , 241usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mBoxSizing ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mAlignContent as * const _ as usize } , 242usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mAlignContent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mAlignItems as * const _ as usize } , 244usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mAlignItems ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mAlignSelf as * const _ as usize } , 245usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mAlignSelf ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mJustifyContent as * const _ as usize } , 246usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mJustifyContent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mSpecifiedJustifyItems as * const _ as usize } , 248usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mSpecifiedJustifyItems ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mJustifyItems as * const _ as usize } , 249usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mJustifyItems ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mJustifySelf as * const _ as usize } , 250usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mJustifySelf ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mFlexDirection as * const _ as usize } , 251usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mFlexDirection ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mFlexWrap as * const _ as usize } , 252usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mFlexWrap ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mObjectFit as * const _ as usize } , 253usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mObjectFit ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mOrder as * const _ as usize } , 256usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mOrder ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mFlexGrow as * const _ as usize } , 260usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mFlexGrow ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mFlexShrink as * const _ as usize } , 264usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mFlexShrink ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mZIndex as * const _ as usize } , 272usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mZIndex ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mGridTemplateColumns as * const _ as usize } , 288usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mGridTemplateColumns ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mGridTemplateRows as * const _ as usize } , 296usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mGridTemplateRows ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mGridTemplateAreas as * const _ as usize } , 304usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mGridTemplateAreas ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mGridColumnStart as * const _ as usize } , 312usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mGridColumnStart ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mGridColumnEnd as * const _ as usize } , 336usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mGridColumnEnd ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mGridRowStart as * const _ as usize } , 360usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mGridRowStart ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mGridRowEnd as * const _ as usize } , 384usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mGridRowEnd ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mGridColumnGap as * const _ as usize } , 408usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mGridColumnGap ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStylePosition ) ) . mGridRowGap as * const _ as usize } , 424usize , concat ! ( "Alignment of field: " , stringify ! ( nsStylePosition ) , "::" , stringify ! ( mGridRowGap ) ) ) ; } # [ repr ( C ) ] pub struct nsStyleTextOverflowSide { pub mString : ::nsstring::nsStringRepr , pub mType : u8 , } # [ test ] fn bindgen_test_layout_nsStyleTextOverflowSide ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleTextOverflowSide > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsStyleTextOverflowSide ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleTextOverflowSide > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleTextOverflowSide ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleTextOverflowSide ) ) . mString as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleTextOverflowSide ) , "::" , stringify ! ( mString ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleTextOverflowSide ) ) . mType as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleTextOverflowSide ) , "::" , stringify ! ( mType ) ) ) ; } # [ repr ( C ) ] pub struct nsStyleTextOverflow { pub mLeft : root :: nsStyleTextOverflowSide , pub mRight : root :: nsStyleTextOverflowSide , pub mLogicalDirections : bool , } # [ test ] fn bindgen_test_layout_nsStyleTextOverflow ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleTextOverflow > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( nsStyleTextOverflow ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleTextOverflow > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleTextOverflow ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleTextOverflow ) ) . mLeft as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleTextOverflow ) , "::" , stringify ! ( mLeft ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleTextOverflow ) ) . mRight as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleTextOverflow ) , "::" , stringify ! ( mRight ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleTextOverflow ) ) . mLogicalDirections as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleTextOverflow ) , "::" , stringify ! ( mLogicalDirections ) ) ) ; } # [ repr ( C ) ] pub struct nsStyleTextReset { pub mTextOverflow : root :: nsStyleTextOverflow , pub mTextDecorationLine : u8 , pub mTextDecorationStyle : u8 , pub mUnicodeBidi : u8 , pub mInitialLetterSink : root :: nscoord , pub mInitialLetterSize : f32 , pub mTextDecorationColor : root :: mozilla :: StyleComplexColor , } pub const nsStyleTextReset_kHasFinishStyle : bool = false ; # [ test ] fn bindgen_test_layout_nsStyleTextReset ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleTextReset > ( ) , 80usize , concat ! ( "Size of: " , stringify ! ( nsStyleTextReset ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleTextReset > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleTextReset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleTextReset ) ) . mTextOverflow as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleTextReset ) , "::" , stringify ! ( mTextOverflow ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleTextReset ) ) . mTextDecorationLine as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleTextReset ) , "::" , stringify ! ( mTextDecorationLine ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleTextReset ) ) . mTextDecorationStyle as * const _ as usize } , 57usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleTextReset ) , "::" , stringify ! ( mTextDecorationStyle ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleTextReset ) ) . mUnicodeBidi as * const _ as usize } , 58usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleTextReset ) , "::" , stringify ! ( mUnicodeBidi ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleTextReset ) ) . mInitialLetterSink as * const _ as usize } , 60usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleTextReset ) , "::" , stringify ! ( mInitialLetterSink ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleTextReset ) ) . mInitialLetterSize as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleTextReset ) , "::" , stringify ! ( mInitialLetterSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleTextReset ) ) . mTextDecorationColor as * const _ as usize } , 68usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleTextReset ) , "::" , stringify ! ( mTextDecorationColor ) ) ) ; } # [ repr ( C ) ] pub struct nsStyleText { pub mTextAlign : u8 , pub mTextAlignLast : u8 , pub _bitfield_1 : u8 , pub mTextJustify : root :: mozilla :: StyleTextJustify , pub mTextTransform : u8 , pub mWhiteSpace : root :: mozilla :: StyleWhiteSpace , pub mWordBreak : u8 , pub mOverflowWrap : u8 , pub mHyphens : root :: mozilla :: StyleHyphens , pub mRubyAlign : u8 , pub mRubyPosition : u8 , pub mTextSizeAdjust : u8 , pub mTextCombineUpright : u8 , pub mControlCharacterVisibility : u8 , pub mTextEmphasisPosition : u8 , pub mTextEmphasisStyle : u8 , pub mTextRendering : u8 , pub mTextEmphasisColor : root :: mozilla :: StyleComplexColor , pub mWebkitTextFillColor : root :: mozilla :: StyleComplexColor , pub mWebkitTextStrokeColor : root :: mozilla :: StyleComplexColor , pub mTabSize : root :: nsStyleCoord , pub mWordSpacing : root :: nsStyleCoord , pub mLetterSpacing : root :: nsStyleCoord , pub mLineHeight : root :: nsStyleCoord , pub mTextIndent : root :: nsStyleCoord , pub mWebkitTextStrokeWidth : root :: nscoord , pub mTextShadow : root :: RefPtr < root :: nsCSSShadowArray > , pub mTextEmphasisStyleString : ::nsstring::nsStringRepr , } pub const nsStyleText_kHasFinishStyle : bool = false ; # [ test ] fn bindgen_test_layout_nsStyleText ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleText > ( ) , 160usize , concat ! ( "Size of: " , stringify ! ( nsStyleText ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleText > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleText ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mTextAlign as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mTextAlign ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mTextAlignLast as * const _ as usize } , 1usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mTextAlignLast ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mTextJustify as * const _ as usize } , 3usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mTextJustify ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mTextTransform as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mTextTransform ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mWhiteSpace as * const _ as usize } , 5usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mWhiteSpace ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mWordBreak as * const _ as usize } , 6usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mWordBreak ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mOverflowWrap as * const _ as usize } , 7usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mOverflowWrap ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mHyphens as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mHyphens ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mRubyAlign as * const _ as usize } , 9usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mRubyAlign ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mRubyPosition as * const _ as usize } , 10usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mRubyPosition ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mTextSizeAdjust as * const _ as usize } , 11usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mTextSizeAdjust ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mTextCombineUpright as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mTextCombineUpright ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mControlCharacterVisibility as * const _ as usize } , 13usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mControlCharacterVisibility ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mTextEmphasisPosition as * const _ as usize } , 14usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mTextEmphasisPosition ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mTextEmphasisStyle as * const _ as usize } , 15usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mTextEmphasisStyle ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mTextRendering as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mTextRendering ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mTextEmphasisColor as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mTextEmphasisColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mWebkitTextFillColor as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mWebkitTextFillColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mWebkitTextStrokeColor as * const _ as usize } , 36usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mWebkitTextStrokeColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mTabSize as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mTabSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mWordSpacing as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mWordSpacing ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mLetterSpacing as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mLetterSpacing ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mLineHeight as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mLineHeight ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mTextIndent as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mTextIndent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mWebkitTextStrokeWidth as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mWebkitTextStrokeWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mTextShadow as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mTextShadow ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleText ) ) . mTextEmphasisStyleString as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleText ) , "::" , stringify ! ( mTextEmphasisStyleString ) ) ) ; } impl nsStyleText { # [ inline ] pub fn mTextAlignTrue ( & self ) -> bool { let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0x1 as u8 ; let val = ( unit_field_val & mask ) >> 0usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mTextAlignTrue ( & mut self , val : bool ) { let mask = 0x1 as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 0usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn mTextAlignLastTrue ( & self ) -> bool { let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0x2 as u8 ; let val = ( unit_field_val & mask ) >> 1usize ; unsafe { :: std :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_mTextAlignLastTrue ( & mut self , val : bool ) { let mask = 0x2 as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 1usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn new_bitfield_1 ( mTextAlignTrue : bool , mTextAlignLastTrue : bool ) -> u8 { ( ( 0 | ( ( mTextAlignTrue as u8 as u8 ) << 0usize ) & ( 0x1 as u8 ) ) | ( ( mTextAlignLastTrue as u8 as u8 ) << 1usize ) & ( 0x2 as u8 ) ) } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsStyleImageOrientation { pub mOrientation : u8 , } pub const nsStyleImageOrientation_Bits_ORIENTATION_MASK : root :: nsStyleImageOrientation_Bits = 3 ; pub const nsStyleImageOrientation_Bits_FLIP_MASK : root :: nsStyleImageOrientation_Bits = 4 ; pub const nsStyleImageOrientation_Bits_FROM_IMAGE_MASK : root :: nsStyleImageOrientation_Bits = 8 ; pub type nsStyleImageOrientation_Bits = :: std :: os :: raw :: c_uint ; # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsStyleImageOrientation_Angles { ANGLE_0 = 0 , ANGLE_90 = 1 , ANGLE_180 = 2 , ANGLE_270 = 3 , } # [ test ] fn bindgen_test_layout_nsStyleImageOrientation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleImageOrientation > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( nsStyleImageOrientation ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleImageOrientation > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( nsStyleImageOrientation ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleImageOrientation ) ) . mOrientation as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleImageOrientation ) , "::" , stringify ! ( mOrientation ) ) ) ; } impl Clone for nsStyleImageOrientation { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleVisibility { pub mImageOrientation : root :: nsStyleImageOrientation , pub mDirection : u8 , pub mVisible : u8 , pub mImageRendering : u8 , pub mWritingMode : u8 , pub mTextOrientation : u8 , pub mColorAdjust : u8 , } pub const nsStyleVisibility_kHasFinishStyle : bool = false ; # [ test ] fn bindgen_test_layout_nsStyleVisibility ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleVisibility > ( ) , 7usize , concat ! ( "Size of: " , stringify ! ( nsStyleVisibility ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleVisibility > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( nsStyleVisibility ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleVisibility ) ) . mImageOrientation as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleVisibility ) , "::" , stringify ! ( mImageOrientation ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleVisibility ) ) . mDirection as * const _ as usize } , 1usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleVisibility ) , "::" , stringify ! ( mDirection ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleVisibility ) ) . mVisible as * const _ as usize } , 2usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleVisibility ) , "::" , stringify ! ( mVisible ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleVisibility ) ) . mImageRendering as * const _ as usize } , 3usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleVisibility ) , "::" , stringify ! ( mImageRendering ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleVisibility ) ) . mWritingMode as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleVisibility ) , "::" , stringify ! ( mWritingMode ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleVisibility ) ) . mTextOrientation as * const _ as usize } , 5usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleVisibility ) , "::" , stringify ! ( mTextOrientation ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleVisibility ) ) . mColorAdjust as * const _ as usize } , 6usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleVisibility ) , "::" , stringify ! ( mColorAdjust ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsTimingFunction { pub mType : root :: nsTimingFunction_Type , pub __bindgen_anon_1 : root :: nsTimingFunction__bindgen_ty_1 , } # [ repr ( i32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsTimingFunction_Type { Ease = 0 , Linear = 1 , EaseIn = 2 , EaseOut = 3 , EaseInOut = 4 , StepStart = 5 , StepEnd = 6 , CubicBezier = 7 , Frames = 8 , } pub const nsTimingFunction_Keyword_Implicit : root :: nsTimingFunction_Keyword = 0 ; pub const nsTimingFunction_Keyword_Explicit : root :: nsTimingFunction_Keyword = 1 ; pub type nsTimingFunction_Keyword = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsTimingFunction__bindgen_ty_1 { pub mFunc : root :: __BindgenUnionField < root :: nsTimingFunction__bindgen_ty_1__bindgen_ty_1 > , pub __bindgen_anon_1 : root :: __BindgenUnionField < root :: nsTimingFunction__bindgen_ty_1__bindgen_ty_2 > , pub bindgen_union_field : [ u32 ; 4usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsTimingFunction__bindgen_ty_1__bindgen_ty_1 { pub mX1 : f32 , pub mY1 : f32 , pub mX2 : f32 , pub mY2 : f32 , } # [ test ] fn bindgen_test_layout_nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsTimingFunction__bindgen_ty_1__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsTimingFunction__bindgen_ty_1__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) ) . mX1 as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( mX1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) ) . mY1 as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( mY1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) ) . mX2 as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( mX2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) ) . mY2 as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( mY2 ) ) ) ; } impl Clone for nsTimingFunction__bindgen_ty_1__bindgen_ty_1 { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsTimingFunction__bindgen_ty_1__bindgen_ty_2 { pub mStepsOrFrames : u32 , } # [ test ] fn bindgen_test_layout_nsTimingFunction__bindgen_ty_1__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsTimingFunction__bindgen_ty_1__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( nsTimingFunction__bindgen_ty_1__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsTimingFunction__bindgen_ty_1__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( nsTimingFunction__bindgen_ty_1__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsTimingFunction__bindgen_ty_1__bindgen_ty_2 ) ) . mStepsOrFrames as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsTimingFunction__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! ( mStepsOrFrames ) ) ) ; } impl Clone for nsTimingFunction__bindgen_ty_1__bindgen_ty_2 { fn clone ( & self ) -> Self { * self } } # [ test ] fn bindgen_test_layout_nsTimingFunction__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsTimingFunction__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsTimingFunction__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsTimingFunction__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( nsTimingFunction__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsTimingFunction__bindgen_ty_1 ) ) . mFunc as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsTimingFunction__bindgen_ty_1 ) , "::" , stringify ! ( mFunc ) ) ) ; } impl Clone for nsTimingFunction__bindgen_ty_1 { fn clone ( & self ) -> Self { * self } } # [ test ] fn bindgen_test_layout_nsTimingFunction ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsTimingFunction > ( ) , 20usize , concat ! ( "Size of: " , stringify ! ( nsTimingFunction ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsTimingFunction > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( nsTimingFunction ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsTimingFunction ) ) . mType as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsTimingFunction ) , "::" , stringify ! ( mType ) ) ) ; } impl Clone for nsTimingFunction { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleDisplay { pub mBinding : root :: RefPtr < root :: mozilla :: css :: URLValue > , pub mDisplay : root :: mozilla :: StyleDisplay , pub mOriginalDisplay : root :: mozilla :: StyleDisplay , pub mContain : u8 , pub mAppearance : u8 , pub mPosition : u8 , pub mFloat : root :: mozilla :: StyleFloat , pub mOriginalFloat : root :: mozilla :: StyleFloat , pub mBreakType : root :: mozilla :: StyleClear , pub mBreakInside : u8 , pub mBreakBefore : bool , pub mBreakAfter : bool , pub mOverflowX : u8 , pub mOverflowY : u8 , pub mOverflowClipBoxBlock : u8 , pub mOverflowClipBoxInline : u8 , pub mResize : u8 , pub mOrient : root :: mozilla :: StyleOrient , pub mIsolation : u8 , pub mTopLayer : u8 , pub mWillChangeBitField : u8 , pub mWillChange : root :: nsTArray < root :: RefPtr < root :: nsAtom > > , pub mTouchAction : u8 , pub mScrollBehavior : u8 , pub mOverscrollBehaviorX : root :: mozilla :: StyleOverscrollBehavior , pub mOverscrollBehaviorY : root :: mozilla :: StyleOverscrollBehavior , pub mScrollSnapTypeX : u8 , pub mScrollSnapTypeY : u8 , pub mScrollSnapPointsX : root :: nsStyleCoord , pub mScrollSnapPointsY : root :: nsStyleCoord , pub mScrollSnapDestination : root :: mozilla :: Position , pub mScrollSnapCoordinate : root :: nsTArray < root :: mozilla :: Position > , pub mBackfaceVisibility : u8 , pub mTransformStyle : u8 , pub mTransformBox : root :: nsStyleDisplay_StyleGeometryBox , pub mSpecifiedTransform : root :: RefPtr < root :: nsCSSValueSharedList > , pub mTransformOrigin : [ root :: nsStyleCoord ; 3usize ] , pub mChildPerspective : root :: nsStyleCoord , pub mPerspectiveOrigin : [ root :: nsStyleCoord ; 2usize ] , pub mVerticalAlign : root :: nsStyleCoord , pub mTransitions : root :: nsStyleAutoArray < root :: mozilla :: StyleTransition > , pub mTransitionTimingFunctionCount : u32 , pub mTransitionDurationCount : u32 , pub mTransitionDelayCount : u32 , pub mTransitionPropertyCount : u32 , pub mAnimations : root :: nsStyleAutoArray < root :: mozilla :: StyleAnimation > , pub mAnimationTimingFunctionCount : u32 , pub mAnimationDurationCount : u32 , pub mAnimationDelayCount : u32 , pub mAnimationNameCount : u32 , pub mAnimationDirectionCount : u32 , pub mAnimationFillModeCount : u32 , pub mAnimationPlayStateCount : u32 , pub mAnimationIterationCountCount : u32 , pub mShapeImageThreshold : f32 , pub mShapeOutside : root :: mozilla :: StyleShapeSource , } pub use self :: super :: root :: mozilla :: StyleGeometryBox as nsStyleDisplay_StyleGeometryBox ; pub const nsStyleDisplay_kHasFinishStyle : bool = true ; # [ test ] fn bindgen_test_layout_nsStyleDisplay ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleDisplay > ( ) , 424usize , concat ! ( "Size of: " , stringify ! ( nsStyleDisplay ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleDisplay > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleDisplay ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mBinding as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mBinding ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mDisplay as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mDisplay ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mOriginalDisplay as * const _ as usize } , 9usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mOriginalDisplay ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mContain as * const _ as usize } , 10usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mContain ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mAppearance as * const _ as usize } , 11usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mAppearance ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mPosition as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mPosition ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mFloat as * const _ as usize } , 13usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mFloat ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mOriginalFloat as * const _ as usize } , 14usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mOriginalFloat ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mBreakType as * const _ as usize } , 15usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mBreakType ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mBreakInside as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mBreakInside ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mBreakBefore as * const _ as usize } , 17usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mBreakBefore ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mBreakAfter as * const _ as usize } , 18usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mBreakAfter ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mOverflowX as * const _ as usize } , 19usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mOverflowX ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mOverflowY as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mOverflowY ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mOverflowClipBoxBlock as * const _ as usize } , 21usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mOverflowClipBoxBlock ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mOverflowClipBoxInline as * const _ as usize } , 22usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mOverflowClipBoxInline ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mResize as * const _ as usize } , 23usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mResize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mOrient as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mOrient ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mIsolation as * const _ as usize } , 25usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mIsolation ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mTopLayer as * const _ as usize } , 26usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mTopLayer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mWillChangeBitField as * const _ as usize } , 27usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mWillChangeBitField ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mWillChange as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mWillChange ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mTouchAction as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mTouchAction ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mScrollBehavior as * const _ as usize } , 41usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mScrollBehavior ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mOverscrollBehaviorX as * const _ as usize } , 42usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mOverscrollBehaviorX ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mOverscrollBehaviorY as * const _ as usize } , 43usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mOverscrollBehaviorY ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mScrollSnapTypeX as * const _ as usize } , 44usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mScrollSnapTypeX ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mScrollSnapTypeY as * const _ as usize } , 45usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mScrollSnapTypeY ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mScrollSnapPointsX as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mScrollSnapPointsX ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mScrollSnapPointsY as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mScrollSnapPointsY ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mScrollSnapDestination as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mScrollSnapDestination ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mScrollSnapCoordinate as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mScrollSnapCoordinate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mBackfaceVisibility as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mBackfaceVisibility ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mTransformStyle as * const _ as usize } , 113usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mTransformStyle ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mTransformBox as * const _ as usize } , 114usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mTransformBox ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mSpecifiedTransform as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mSpecifiedTransform ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mTransformOrigin as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mTransformOrigin ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mChildPerspective as * const _ as usize } , 176usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mChildPerspective ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mPerspectiveOrigin as * const _ as usize } , 192usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mPerspectiveOrigin ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mVerticalAlign as * const _ as usize } , 224usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mVerticalAlign ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mTransitions as * const _ as usize } , 240usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mTransitions ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mTransitionTimingFunctionCount as * const _ as usize } , 288usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mTransitionTimingFunctionCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mTransitionDurationCount as * const _ as usize } , 292usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mTransitionDurationCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mTransitionDelayCount as * const _ as usize } , 296usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mTransitionDelayCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mTransitionPropertyCount as * const _ as usize } , 300usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mTransitionPropertyCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mAnimations as * const _ as usize } , 304usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mAnimations ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mAnimationTimingFunctionCount as * const _ as usize } , 360usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mAnimationTimingFunctionCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mAnimationDurationCount as * const _ as usize } , 364usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mAnimationDurationCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mAnimationDelayCount as * const _ as usize } , 368usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mAnimationDelayCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mAnimationNameCount as * const _ as usize } , 372usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mAnimationNameCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mAnimationDirectionCount as * const _ as usize } , 376usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mAnimationDirectionCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mAnimationFillModeCount as * const _ as usize } , 380usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mAnimationFillModeCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mAnimationPlayStateCount as * const _ as usize } , 384usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mAnimationPlayStateCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mAnimationIterationCountCount as * const _ as usize } , 388usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mAnimationIterationCountCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mShapeImageThreshold as * const _ as usize } , 392usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mShapeImageThreshold ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleDisplay ) ) . mShapeOutside as * const _ as usize } , 400usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleDisplay ) , "::" , stringify ! ( mShapeOutside ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleTable { pub mLayoutStrategy : u8 , pub mSpan : i32 , } pub const nsStyleTable_kHasFinishStyle : bool = false ; # [ test ] fn bindgen_test_layout_nsStyleTable ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleTable > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsStyleTable ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleTable > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( nsStyleTable ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleTable ) ) . mLayoutStrategy as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleTable ) , "::" , stringify ! ( mLayoutStrategy ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleTable ) ) . mSpan as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleTable ) , "::" , stringify ! ( mSpan ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleTableBorder { pub mBorderSpacingCol : root :: nscoord , pub mBorderSpacingRow : root :: nscoord , pub mBorderCollapse : u8 , pub mCaptionSide : u8 , pub mEmptyCells : u8 , } pub const nsStyleTableBorder_kHasFinishStyle : bool = false ; # [ test ] fn bindgen_test_layout_nsStyleTableBorder ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleTableBorder > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( nsStyleTableBorder ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleTableBorder > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( nsStyleTableBorder ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleTableBorder ) ) . mBorderSpacingCol as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleTableBorder ) , "::" , stringify ! ( mBorderSpacingCol ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleTableBorder ) ) . mBorderSpacingRow as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleTableBorder ) , "::" , stringify ! ( mBorderSpacingRow ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleTableBorder ) ) . mBorderCollapse as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleTableBorder ) , "::" , stringify ! ( mBorderCollapse ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleTableBorder ) ) . mCaptionSide as * const _ as usize } , 9usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleTableBorder ) , "::" , stringify ! ( mCaptionSide ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleTableBorder ) ) . mEmptyCells as * const _ as usize } , 10usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleTableBorder ) , "::" , stringify ! ( mEmptyCells ) ) ) ; } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsStyleContentType { eStyleContentType_String = 1 , eStyleContentType_Image = 10 , eStyleContentType_Attr = 20 , eStyleContentType_Counter = 30 , eStyleContentType_Counters = 31 , eStyleContentType_OpenQuote = 40 , eStyleContentType_CloseQuote = 41 , eStyleContentType_NoOpenQuote = 42 , eStyleContentType_NoCloseQuote = 43 , eStyleContentType_AltContent = 50 , eStyleContentType_Uninitialized = 51 , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleContentData { pub mType : root :: nsStyleContentType , pub mContent : root :: nsStyleContentData__bindgen_ty_1 , } # [ repr ( C ) ] pub struct nsStyleContentData_CounterFunction { pub mIdent : ::nsstring::nsStringRepr , pub mSeparator : ::nsstring::nsStringRepr , pub mCounterStyle : root :: mozilla :: CounterStylePtr , pub mRefCnt : root :: mozilla :: ThreadSafeAutoRefCnt , } pub type nsStyleContentData_CounterFunction_HasThreadSafeRefCnt = root :: mozilla :: TrueType ; # [ test ] fn bindgen_test_layout_nsStyleContentData_CounterFunction ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleContentData_CounterFunction > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( nsStyleContentData_CounterFunction ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleContentData_CounterFunction > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleContentData_CounterFunction ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleContentData_CounterFunction ) ) . mIdent as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleContentData_CounterFunction ) , "::" , stringify ! ( mIdent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleContentData_CounterFunction ) ) . mSeparator as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleContentData_CounterFunction ) , "::" , stringify ! ( mSeparator ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleContentData_CounterFunction ) ) . mCounterStyle as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleContentData_CounterFunction ) , "::" , stringify ! ( mCounterStyle ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleContentData_CounterFunction ) ) . mRefCnt as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleContentData_CounterFunction ) , "::" , stringify ! ( mRefCnt ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsStyleContentData__bindgen_ty_1 { pub mString : root :: __BindgenUnionField < * mut u16 > , pub mImage : root :: __BindgenUnionField < * mut root :: nsStyleImageRequest > , pub mCounters : root :: __BindgenUnionField < * mut root :: nsStyleContentData_CounterFunction > , pub bindgen_union_field : u64 , } # [ test ] fn bindgen_test_layout_nsStyleContentData__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleContentData__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsStyleContentData__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleContentData__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleContentData__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleContentData__bindgen_ty_1 ) ) . mString as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleContentData__bindgen_ty_1 ) , "::" , stringify ! ( mString ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleContentData__bindgen_ty_1 ) ) . mImage as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleContentData__bindgen_ty_1 ) , "::" , stringify ! ( mImage ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleContentData__bindgen_ty_1 ) ) . mCounters as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleContentData__bindgen_ty_1 ) , "::" , stringify ! ( mCounters ) ) ) ; } impl Clone for nsStyleContentData__bindgen_ty_1 { fn clone ( & self ) -> Self { * self } } # [ test ] fn bindgen_test_layout_nsStyleContentData ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleContentData > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsStyleContentData ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleContentData > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleContentData ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleContentData ) ) . mType as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleContentData ) , "::" , stringify ! ( mType ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleContentData ) ) . mContent as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleContentData ) , "::" , stringify ! ( mContent ) ) ) ; } # [ repr ( C ) ] pub struct nsStyleCounterData { pub mCounter : ::nsstring::nsStringRepr , pub mValue : i32 , } # [ test ] fn bindgen_test_layout_nsStyleCounterData ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleCounterData > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsStyleCounterData ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleCounterData > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleCounterData ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleCounterData ) ) . mCounter as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleCounterData ) , "::" , stringify ! ( mCounter ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleCounterData ) ) . mValue as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleCounterData ) , "::" , stringify ! ( mValue ) ) ) ; } # [ repr ( C ) ] pub struct nsStyleContent { pub mContents : root :: nsTArray < root :: nsStyleContentData > , pub mIncrements : root :: nsTArray < root :: nsStyleCounterData > , pub mResets : root :: nsTArray < root :: nsStyleCounterData > , } pub const nsStyleContent_kHasFinishStyle : bool = true ; # [ test ] fn bindgen_test_layout_nsStyleContent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleContent > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsStyleContent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleContent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleContent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleContent ) ) . mContents as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleContent ) , "::" , stringify ! ( mContents ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleContent ) ) . mIncrements as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleContent ) , "::" , stringify ! ( mIncrements ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleContent ) ) . mResets as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleContent ) , "::" , stringify ! ( mResets ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleUIReset { pub mUserSelect : root :: mozilla :: StyleUserSelect , pub mForceBrokenImageIcon : u8 , pub mIMEMode : u8 , pub mWindowDragging : root :: mozilla :: StyleWindowDragging , pub mWindowShadow : u8 , pub mWindowOpacity : f32 , pub mSpecifiedWindowTransform : root :: RefPtr < root :: nsCSSValueSharedList > , pub mWindowTransformOrigin : [ root :: nsStyleCoord ; 2usize ] , } pub const nsStyleUIReset_kHasFinishStyle : bool = false ; # [ test ] fn bindgen_test_layout_nsStyleUIReset ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleUIReset > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( nsStyleUIReset ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleUIReset > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleUIReset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleUIReset ) ) . mUserSelect as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleUIReset ) , "::" , stringify ! ( mUserSelect ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleUIReset ) ) . mForceBrokenImageIcon as * const _ as usize } , 1usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleUIReset ) , "::" , stringify ! ( mForceBrokenImageIcon ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleUIReset ) ) . mIMEMode as * const _ as usize } , 2usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleUIReset ) , "::" , stringify ! ( mIMEMode ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleUIReset ) ) . mWindowDragging as * const _ as usize } , 3usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleUIReset ) , "::" , stringify ! ( mWindowDragging ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleUIReset ) ) . mWindowShadow as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleUIReset ) , "::" , stringify ! ( mWindowShadow ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleUIReset ) ) . mWindowOpacity as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleUIReset ) , "::" , stringify ! ( mWindowOpacity ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleUIReset ) ) . mSpecifiedWindowTransform as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleUIReset ) , "::" , stringify ! ( mSpecifiedWindowTransform ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleUIReset ) ) . mWindowTransformOrigin as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleUIReset ) , "::" , stringify ! ( mWindowTransformOrigin ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCursorImage { pub mHaveHotspot : bool , pub mHotspotX : f32 , pub mHotspotY : f32 , pub mImage : root :: RefPtr < root :: nsStyleImageRequest > , } # [ test ] fn bindgen_test_layout_nsCursorImage ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCursorImage > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsCursorImage ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCursorImage > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCursorImage ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCursorImage ) ) . mHaveHotspot as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsCursorImage ) , "::" , stringify ! ( mHaveHotspot ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCursorImage ) ) . mHotspotX as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( nsCursorImage ) , "::" , stringify ! ( mHotspotX ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCursorImage ) ) . mHotspotY as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsCursorImage ) , "::" , stringify ! ( mHotspotY ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCursorImage ) ) . mImage as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsCursorImage ) , "::" , stringify ! ( mImage ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleUserInterface { pub mUserInput : root :: mozilla :: StyleUserInput , pub mUserModify : root :: mozilla :: StyleUserModify , pub mUserFocus : root :: mozilla :: StyleUserFocus , pub mPointerEvents : u8 , pub mCursor : u8 , pub mCursorImages : root :: nsTArray < root :: nsCursorImage > , pub mCaretColor : root :: mozilla :: StyleComplexColor , } pub const nsStyleUserInterface_kHasFinishStyle : bool = true ; # [ test ] fn bindgen_test_layout_nsStyleUserInterface ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleUserInterface > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsStyleUserInterface ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleUserInterface > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleUserInterface ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleUserInterface ) ) . mUserInput as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleUserInterface ) , "::" , stringify ! ( mUserInput ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleUserInterface ) ) . mUserModify as * const _ as usize } , 1usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleUserInterface ) , "::" , stringify ! ( mUserModify ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleUserInterface ) ) . mUserFocus as * const _ as usize } , 2usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleUserInterface ) , "::" , stringify ! ( mUserFocus ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleUserInterface ) ) . mPointerEvents as * const _ as usize } , 3usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleUserInterface ) , "::" , stringify ! ( mPointerEvents ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleUserInterface ) ) . mCursor as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleUserInterface ) , "::" , stringify ! ( mCursor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleUserInterface ) ) . mCursorImages as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleUserInterface ) , "::" , stringify ! ( mCursorImages ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleUserInterface ) ) . mCaretColor as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleUserInterface ) , "::" , stringify ! ( mCaretColor ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleXUL { pub mBoxFlex : f32 , pub mBoxOrdinal : u32 , pub mBoxAlign : root :: mozilla :: StyleBoxAlign , pub mBoxDirection : root :: mozilla :: StyleBoxDirection , pub mBoxOrient : root :: mozilla :: StyleBoxOrient , pub mBoxPack : root :: mozilla :: StyleBoxPack , pub mStackSizing : root :: mozilla :: StyleStackSizing , } pub const nsStyleXUL_kHasFinishStyle : bool = false ; # [ test ] fn bindgen_test_layout_nsStyleXUL ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleXUL > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsStyleXUL ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleXUL > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( nsStyleXUL ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleXUL ) ) . mBoxFlex as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::" , stringify ! ( mBoxFlex ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleXUL ) ) . mBoxOrdinal as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::" , stringify ! ( mBoxOrdinal ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleXUL ) ) . mBoxAlign as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::" , stringify ! ( mBoxAlign ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleXUL ) ) . mBoxDirection as * const _ as usize } , 9usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::" , stringify ! ( mBoxDirection ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleXUL ) ) . mBoxOrient as * const _ as usize } , 10usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::" , stringify ! ( mBoxOrient ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleXUL ) ) . mBoxPack as * const _ as usize } , 11usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::" , stringify ! ( mBoxPack ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleXUL ) ) . mStackSizing as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::" , stringify ! ( mStackSizing ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleColumn { pub mColumnCount : u32 , pub mColumnWidth : root :: nsStyleCoord , pub mColumnGap : root :: nsStyleCoord , pub mColumnRuleColor : root :: mozilla :: StyleComplexColor , pub mColumnRuleStyle : u8 , pub mColumnFill : u8 , pub mColumnSpan : u8 , pub mColumnRuleWidth : root :: nscoord , pub mTwipsPerPixel : root :: nscoord , } pub const nsStyleColumn_kHasFinishStyle : bool = false ; pub const nsStyleColumn_kMaxColumnCount : u32 = 1000 ; # [ test ] fn bindgen_test_layout_nsStyleColumn ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleColumn > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( nsStyleColumn ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleColumn > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleColumn ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleColumn ) ) . mColumnCount as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleColumn ) , "::" , stringify ! ( mColumnCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleColumn ) ) . mColumnWidth as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleColumn ) , "::" , stringify ! ( mColumnWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleColumn ) ) . mColumnGap as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleColumn ) , "::" , stringify ! ( mColumnGap ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleColumn ) ) . mColumnRuleColor as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleColumn ) , "::" , stringify ! ( mColumnRuleColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleColumn ) ) . mColumnRuleStyle as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleColumn ) , "::" , stringify ! ( mColumnRuleStyle ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleColumn ) ) . mColumnFill as * const _ as usize } , 49usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleColumn ) , "::" , stringify ! ( mColumnFill ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleColumn ) ) . mColumnSpan as * const _ as usize } , 50usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleColumn ) , "::" , stringify ! ( mColumnSpan ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleColumn ) ) . mColumnRuleWidth as * const _ as usize } , 52usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleColumn ) , "::" , stringify ! ( mColumnRuleWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleColumn ) ) . mTwipsPerPixel as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleColumn ) , "::" , stringify ! ( mTwipsPerPixel ) ) ) ; } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsStyleSVGPaintType { eStyleSVGPaintType_None = 1 , eStyleSVGPaintType_Color = 2 , eStyleSVGPaintType_Server = 3 , eStyleSVGPaintType_ContextFill = 4 , eStyleSVGPaintType_ContextStroke = 5 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsStyleSVGFallbackType { eStyleSVGFallbackType_NotSet = 0 , eStyleSVGFallbackType_None = 1 , eStyleSVGFallbackType_Color = 2 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsStyleSVGOpacitySource { eStyleSVGOpacitySource_Normal = 0 , eStyleSVGOpacitySource_ContextFillOpacity = 1 , eStyleSVGOpacitySource_ContextStrokeOpacity = 2 , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleSVGPaint { pub mPaint : root :: nsStyleSVGPaint__bindgen_ty_1 , pub mType : root :: nsStyleSVGPaintType , pub mFallbackType : root :: nsStyleSVGFallbackType , pub mFallbackColor : root :: nscolor , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsStyleSVGPaint__bindgen_ty_1 { pub mColor : root :: __BindgenUnionField < root :: nscolor > , pub mPaintServer : root :: __BindgenUnionField < * mut root :: mozilla :: css :: URLValue > , pub bindgen_union_field : u64 , } # [ test ] fn bindgen_test_layout_nsStyleSVGPaint__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleSVGPaint__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsStyleSVGPaint__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleSVGPaint__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleSVGPaint__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVGPaint__bindgen_ty_1 ) ) . mColor as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVGPaint__bindgen_ty_1 ) , "::" , stringify ! ( mColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVGPaint__bindgen_ty_1 ) ) . mPaintServer as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVGPaint__bindgen_ty_1 ) , "::" , stringify ! ( mPaintServer ) ) ) ; } impl Clone for nsStyleSVGPaint__bindgen_ty_1 { fn clone ( & self ) -> Self { * self } } # [ test ] fn bindgen_test_layout_nsStyleSVGPaint ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleSVGPaint > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsStyleSVGPaint ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleSVGPaint > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleSVGPaint ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVGPaint ) ) . mPaint as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVGPaint ) , "::" , stringify ! ( mPaint ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVGPaint ) ) . mType as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVGPaint ) , "::" , stringify ! ( mType ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVGPaint ) ) . mFallbackType as * const _ as usize } , 9usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVGPaint ) , "::" , stringify ! ( mFallbackType ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVGPaint ) ) . mFallbackColor as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVGPaint ) , "::" , stringify ! ( mFallbackColor ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleSVG { pub mFill : root :: nsStyleSVGPaint , pub mStroke : root :: nsStyleSVGPaint , pub mMarkerEnd : root :: RefPtr < root :: mozilla :: css :: URLValue > , pub mMarkerMid : root :: RefPtr < root :: mozilla :: css :: URLValue > , pub mMarkerStart : root :: RefPtr < root :: mozilla :: css :: URLValue > , pub mStrokeDasharray : root :: nsTArray < root :: nsStyleCoord > , pub mContextProps : root :: nsTArray < root :: RefPtr < root :: nsAtom > > , pub mStrokeDashoffset : root :: nsStyleCoord , pub mStrokeWidth : root :: nsStyleCoord , pub mFillOpacity : f32 , pub mStrokeMiterlimit : f32 , pub mStrokeOpacity : f32 , pub mClipRule : root :: mozilla :: StyleFillRule , pub mColorInterpolation : u8 , pub mColorInterpolationFilters : u8 , pub mFillRule : root :: mozilla :: StyleFillRule , pub mPaintOrder : u8 , pub mShapeRendering : u8 , pub mStrokeLinecap : u8 , pub mStrokeLinejoin : u8 , pub mTextAnchor : u8 , pub mContextPropsBits : u8 , pub mContextFlags : u8 , } pub const nsStyleSVG_kHasFinishStyle : bool = false ; pub const nsStyleSVG_FILL_OPACITY_SOURCE_MASK : u8 = 3 ; pub const nsStyleSVG_STROKE_OPACITY_SOURCE_MASK : u8 = 12 ; pub const nsStyleSVG_STROKE_DASHARRAY_CONTEXT : u8 = 16 ; pub const nsStyleSVG_STROKE_DASHOFFSET_CONTEXT : u8 = 32 ; pub const nsStyleSVG_STROKE_WIDTH_CONTEXT : u8 = 64 ; pub const nsStyleSVG_FILL_OPACITY_SOURCE_SHIFT : u8 = 0 ; pub const nsStyleSVG_STROKE_OPACITY_SOURCE_SHIFT : u8 = 2 ; # [ test ] fn bindgen_test_layout_nsStyleSVG ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleSVG > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( nsStyleSVG ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleSVG > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleSVG ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mFill as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mFill ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mStroke as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mStroke ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mMarkerEnd as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mMarkerEnd ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mMarkerMid as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mMarkerMid ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mMarkerStart as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mMarkerStart ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeDasharray as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mStrokeDasharray ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mContextProps as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mContextProps ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeDashoffset as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mStrokeDashoffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeWidth as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mStrokeWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mFillOpacity as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mFillOpacity ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeMiterlimit as * const _ as usize } , 108usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mStrokeMiterlimit ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeOpacity as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mStrokeOpacity ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mClipRule as * const _ as usize } , 116usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mClipRule ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mColorInterpolation as * const _ as usize } , 117usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mColorInterpolation ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mColorInterpolationFilters as * const _ as usize } , 118usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mColorInterpolationFilters ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mFillRule as * const _ as usize } , 119usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mFillRule ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mPaintOrder as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mPaintOrder ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mShapeRendering as * const _ as usize } , 121usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mShapeRendering ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeLinecap as * const _ as usize } , 122usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mStrokeLinecap ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeLinejoin as * const _ as usize } , 123usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mStrokeLinejoin ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mTextAnchor as * const _ as usize } , 124usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mTextAnchor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mContextPropsBits as * const _ as usize } , 125usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mContextPropsBits ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVG ) ) . mContextFlags as * const _ as usize } , 126usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::" , stringify ! ( mContextFlags ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleFilter { pub mType : u32 , pub mFilterParameter : root :: nsStyleCoord , pub __bindgen_anon_1 : root :: nsStyleFilter__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsStyleFilter__bindgen_ty_1 { pub mURL : root :: __BindgenUnionField < * mut root :: mozilla :: css :: URLValue > , pub mDropShadow : root :: __BindgenUnionField < * mut root :: nsCSSShadowArray > , pub bindgen_union_field : u64 , } # [ test ] fn bindgen_test_layout_nsStyleFilter__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleFilter__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsStyleFilter__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleFilter__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleFilter__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleFilter__bindgen_ty_1 ) ) . mURL as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleFilter__bindgen_ty_1 ) , "::" , stringify ! ( mURL ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleFilter__bindgen_ty_1 ) ) . mDropShadow as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleFilter__bindgen_ty_1 ) , "::" , stringify ! ( mDropShadow ) ) ) ; } impl Clone for nsStyleFilter__bindgen_ty_1 { fn clone ( & self ) -> Self { * self } } pub const nsStyleFilter_kHasFinishStyle : bool = false ; # [ test ] fn bindgen_test_layout_nsStyleFilter ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleFilter > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( nsStyleFilter ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleFilter > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleFilter ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleFilter ) ) . mType as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleFilter ) , "::" , stringify ! ( mType ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleFilter ) ) . mFilterParameter as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleFilter ) , "::" , stringify ! ( mFilterParameter ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleSVGReset { pub mMask : root :: nsStyleImageLayers , pub mClipPath : root :: mozilla :: StyleShapeSource , pub mStopColor : root :: nscolor , pub mFloodColor : root :: nscolor , pub mLightingColor : root :: nscolor , pub mStopOpacity : f32 , pub mFloodOpacity : f32 , pub mDominantBaseline : u8 , pub mVectorEffect : u8 , pub mMaskType : u8 , } pub const nsStyleSVGReset_kHasFinishStyle : bool = true ; # [ test ] fn bindgen_test_layout_nsStyleSVGReset ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleSVGReset > ( ) , 200usize , concat ! ( "Size of: " , stringify ! ( nsStyleSVGReset ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleSVGReset > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleSVGReset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVGReset ) ) . mMask as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVGReset ) , "::" , stringify ! ( mMask ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVGReset ) ) . mClipPath as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVGReset ) , "::" , stringify ! ( mClipPath ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVGReset ) ) . mStopColor as * const _ as usize } , 176usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVGReset ) , "::" , stringify ! ( mStopColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVGReset ) ) . mFloodColor as * const _ as usize } , 180usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVGReset ) , "::" , stringify ! ( mFloodColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVGReset ) ) . mLightingColor as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVGReset ) , "::" , stringify ! ( mLightingColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVGReset ) ) . mStopOpacity as * const _ as usize } , 188usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVGReset ) , "::" , stringify ! ( mStopOpacity ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVGReset ) ) . mFloodOpacity as * const _ as usize } , 192usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVGReset ) , "::" , stringify ! ( mFloodOpacity ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVGReset ) ) . mDominantBaseline as * const _ as usize } , 196usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVGReset ) , "::" , stringify ! ( mDominantBaseline ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVGReset ) ) . mVectorEffect as * const _ as usize } , 197usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVGReset ) , "::" , stringify ! ( mVectorEffect ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleSVGReset ) ) . mMaskType as * const _ as usize } , 198usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleSVGReset ) , "::" , stringify ! ( mMaskType ) ) ) ; } # [ repr ( C ) ] pub struct nsStyleVariables { pub mVariables : root :: mozilla :: CSSVariableValues , } pub const nsStyleVariables_kHasFinishStyle : bool = false ; # [ test ] fn bindgen_test_layout_nsStyleVariables ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleVariables > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( nsStyleVariables ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleVariables > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleVariables ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleVariables ) ) . mVariables as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleVariables ) , "::" , stringify ! ( mVariables ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleEffects { pub mFilters : root :: nsTArray < root :: nsStyleFilter > , pub mBoxShadow : root :: RefPtr < root :: nsCSSShadowArray > , pub mClip : root :: nsRect , pub mOpacity : f32 , pub mClipFlags : u8 , pub mMixBlendMode : u8 , } pub const nsStyleEffects_kHasFinishStyle : bool = false ; # [ test ] fn bindgen_test_layout_nsStyleEffects ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleEffects > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( nsStyleEffects ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleEffects > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleEffects ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleEffects ) ) . mFilters as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleEffects ) , "::" , stringify ! ( mFilters ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleEffects ) ) . mBoxShadow as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleEffects ) , "::" , stringify ! ( mBoxShadow ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleEffects ) ) . mClip as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleEffects ) , "::" , stringify ! ( mClip ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleEffects ) ) . mOpacity as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleEffects ) , "::" , stringify ! ( mOpacity ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleEffects ) ) . mClipFlags as * const _ as usize } , 36usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleEffects ) , "::" , stringify ! ( mClipFlags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleEffects ) ) . mMixBlendMode as * const _ as usize } , 37usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleEffects ) , "::" , stringify ! ( mMixBlendMode ) ) ) ; } 
 /// These *_Simple types are used to map Gecko types to layout-equivalent but
    /// simpler Rust types, to aid Rust binding generation.
    ///
    /// If something in this types or the assertions below needs to change, ask
    /// bholley, heycam or emilio before!
    ///
    /// <div rustbindgen="true" replaces="nsPoint"> 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsPoint { pub x : root :: nscoord , pub y : root :: nscoord , } # [ test ] fn bindgen_test_layout_nsPoint ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsPoint > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsPoint ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsPoint > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( nsPoint ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPoint ) ) . x as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsPoint ) , "::" , stringify ! ( x ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsPoint ) ) . y as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( nsPoint ) , "::" , stringify ! ( y ) ) ) ; } impl Clone for nsPoint { fn clone ( & self ) -> Self { * self } } 
 /// <div rustbindgen="true" replaces="nsMargin"> 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsMargin { pub top : root :: nscoord , pub right : root :: nscoord , pub bottom : root :: nscoord , pub left : root :: nscoord , } # [ test ] fn bindgen_test_layout_nsMargin ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsMargin > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsMargin ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsMargin > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( nsMargin ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsMargin ) ) . top as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsMargin ) , "::" , stringify ! ( top ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsMargin ) ) . right as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( nsMargin ) , "::" , stringify ! ( right ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsMargin ) ) . bottom as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsMargin ) , "::" , stringify ! ( bottom ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsMargin ) ) . left as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( nsMargin ) , "::" , stringify ! ( left ) ) ) ; } impl Clone for nsMargin { fn clone ( & self ) -> Self { * self } } 
 /// <div rustbindgen="true" replaces="nsRect"> 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsRect { pub x : root :: nscoord , pub y : root :: nscoord , pub width : root :: nscoord , pub height : root :: nscoord , } # [ test ] fn bindgen_test_layout_nsRect ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsRect > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsRect ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsRect > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( nsRect ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsRect ) ) . x as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsRect ) , "::" , stringify ! ( x ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsRect ) ) . y as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( nsRect ) , "::" , stringify ! ( y ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsRect ) ) . width as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsRect ) , "::" , stringify ! ( width ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsRect ) ) . height as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( nsRect ) , "::" , stringify ! ( height ) ) ) ; } impl Clone for nsRect { fn clone ( & self ) -> Self { * self } } 
 /// <div rustbindgen="true" replaces="nsSize"> 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsSize { pub width : root :: nscoord , pub height : root :: nscoord , } # [ test ] fn bindgen_test_layout_nsSize ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsSize > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsSize ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsSize > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( nsSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsSize ) ) . width as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsSize ) , "::" , stringify ! ( width ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsSize ) ) . height as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( nsSize ) , "::" , stringify ! ( height ) ) ) ; } impl Clone for nsSize { fn clone ( & self ) -> Self { * self } } 
 /// <div rustbindgen replaces="nsTArray"></div> 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsTArray < T > { pub mBuffer : * mut T , pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , } 
 /// <div rustbindgen replaces="nsCOMArray"></div>
    ///
    /// mozilla::ArrayIterator doesn't work well with bindgen. 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCOMArray { pub mBuffer : root :: nsTArray < * mut root :: nsISupports > , } pub const ThemeWidgetType_NS_THEME_NONE : root :: ThemeWidgetType = 0 ; pub const ThemeWidgetType_NS_THEME_BUTTON : root :: ThemeWidgetType = 1 ; pub const ThemeWidgetType_NS_THEME_RADIO : root :: ThemeWidgetType = 2 ; pub const ThemeWidgetType_NS_THEME_CHECKBOX : root :: ThemeWidgetType = 3 ; pub const ThemeWidgetType_NS_THEME_BUTTON_BEVEL : root :: ThemeWidgetType = 4 ; pub const ThemeWidgetType_NS_THEME_FOCUS_OUTLINE : root :: ThemeWidgetType = 5 ; pub const ThemeWidgetType_NS_THEME_TOOLBOX : root :: ThemeWidgetType = 6 ; pub const ThemeWidgetType_NS_THEME_TOOLBAR : root :: ThemeWidgetType = 7 ; pub const ThemeWidgetType_NS_THEME_TOOLBARBUTTON : root :: ThemeWidgetType = 8 ; pub const ThemeWidgetType_NS_THEME_DUALBUTTON : root :: ThemeWidgetType = 9 ; pub const ThemeWidgetType_NS_THEME_TOOLBARBUTTON_DROPDOWN : root :: ThemeWidgetType = 10 ; pub const ThemeWidgetType_NS_THEME_BUTTON_ARROW_UP : root :: ThemeWidgetType = 11 ; pub const ThemeWidgetType_NS_THEME_BUTTON_ARROW_DOWN : root :: ThemeWidgetType = 12 ; pub const ThemeWidgetType_NS_THEME_BUTTON_ARROW_NEXT : root :: ThemeWidgetType = 13 ; pub const ThemeWidgetType_NS_THEME_BUTTON_ARROW_PREVIOUS : root :: ThemeWidgetType = 14 ; pub const ThemeWidgetType_NS_THEME_SEPARATOR : root :: ThemeWidgetType = 15 ; pub const ThemeWidgetType_NS_THEME_TOOLBARGRIPPER : root :: ThemeWidgetType = 16 ; pub const ThemeWidgetType_NS_THEME_SPLITTER : root :: ThemeWidgetType = 17 ; pub const ThemeWidgetType_NS_THEME_STATUSBAR : root :: ThemeWidgetType = 18 ; pub const ThemeWidgetType_NS_THEME_STATUSBARPANEL : root :: ThemeWidgetType = 19 ; pub const ThemeWidgetType_NS_THEME_RESIZERPANEL : root :: ThemeWidgetType = 20 ; pub const ThemeWidgetType_NS_THEME_RESIZER : root :: ThemeWidgetType = 21 ; pub const ThemeWidgetType_NS_THEME_LISTBOX : root :: ThemeWidgetType = 22 ; pub const ThemeWidgetType_NS_THEME_LISTITEM : root :: ThemeWidgetType = 23 ; pub const ThemeWidgetType_NS_THEME_TREEVIEW : root :: ThemeWidgetType = 24 ; pub const ThemeWidgetType_NS_THEME_TREEITEM : root :: ThemeWidgetType = 25 ; pub const ThemeWidgetType_NS_THEME_TREETWISTY : root :: ThemeWidgetType = 26 ; pub const ThemeWidgetType_NS_THEME_TREELINE : root :: ThemeWidgetType = 27 ; pub const ThemeWidgetType_NS_THEME_TREEHEADER : root :: ThemeWidgetType = 28 ; pub const ThemeWidgetType_NS_THEME_TREEHEADERCELL : root :: ThemeWidgetType = 29 ; pub const ThemeWidgetType_NS_THEME_TREEHEADERSORTARROW : root :: ThemeWidgetType = 30 ; pub const ThemeWidgetType_NS_THEME_TREETWISTYOPEN : root :: ThemeWidgetType = 31 ; pub const ThemeWidgetType_NS_THEME_PROGRESSBAR : root :: ThemeWidgetType = 32 ; pub const ThemeWidgetType_NS_THEME_PROGRESSCHUNK : root :: ThemeWidgetType = 33 ; pub const ThemeWidgetType_NS_THEME_PROGRESSBAR_VERTICAL : root :: ThemeWidgetType = 34 ; pub const ThemeWidgetType_NS_THEME_PROGRESSCHUNK_VERTICAL : root :: ThemeWidgetType = 35 ; pub const ThemeWidgetType_NS_THEME_METERBAR : root :: ThemeWidgetType = 36 ; pub const ThemeWidgetType_NS_THEME_METERCHUNK : root :: ThemeWidgetType = 37 ; pub const ThemeWidgetType_NS_THEME_TAB : root :: ThemeWidgetType = 38 ; pub const ThemeWidgetType_NS_THEME_TABPANEL : root :: ThemeWidgetType = 39 ; pub const ThemeWidgetType_NS_THEME_TABPANELS : root :: ThemeWidgetType = 40 ; pub const ThemeWidgetType_NS_THEME_TAB_SCROLL_ARROW_BACK : root :: ThemeWidgetType = 41 ; pub const ThemeWidgetType_NS_THEME_TAB_SCROLL_ARROW_FORWARD : root :: ThemeWidgetType = 42 ; pub const ThemeWidgetType_NS_THEME_TOOLTIP : root :: ThemeWidgetType = 43 ; pub const ThemeWidgetType_NS_THEME_INNER_SPIN_BUTTON : root :: ThemeWidgetType = 44 ; pub const ThemeWidgetType_NS_THEME_SPINNER : root :: ThemeWidgetType = 45 ; pub const ThemeWidgetType_NS_THEME_SPINNER_UPBUTTON : root :: ThemeWidgetType = 46 ; pub const ThemeWidgetType_NS_THEME_SPINNER_DOWNBUTTON : root :: ThemeWidgetType = 47 ; pub const ThemeWidgetType_NS_THEME_SPINNER_TEXTFIELD : root :: ThemeWidgetType = 48 ; pub const ThemeWidgetType_NS_THEME_NUMBER_INPUT : root :: ThemeWidgetType = 49 ; pub const ThemeWidgetType_NS_THEME_SCROLLBAR : root :: ThemeWidgetType = 50 ; pub const ThemeWidgetType_NS_THEME_SCROLLBAR_SMALL : root :: ThemeWidgetType = 51 ; pub const ThemeWidgetType_NS_THEME_SCROLLBAR_HORIZONTAL : root :: ThemeWidgetType = 52 ; pub const ThemeWidgetType_NS_THEME_SCROLLBAR_VERTICAL : root :: ThemeWidgetType = 53 ; pub const ThemeWidgetType_NS_THEME_SCROLLBARBUTTON_UP : root :: ThemeWidgetType = 54 ; pub const ThemeWidgetType_NS_THEME_SCROLLBARBUTTON_DOWN : root :: ThemeWidgetType = 55 ; pub const ThemeWidgetType_NS_THEME_SCROLLBARBUTTON_LEFT : root :: ThemeWidgetType = 56 ; pub const ThemeWidgetType_NS_THEME_SCROLLBARBUTTON_RIGHT : root :: ThemeWidgetType = 57 ; pub const ThemeWidgetType_NS_THEME_SCROLLBARTRACK_HORIZONTAL : root :: ThemeWidgetType = 58 ; pub const ThemeWidgetType_NS_THEME_SCROLLBARTRACK_VERTICAL : root :: ThemeWidgetType = 59 ; pub const ThemeWidgetType_NS_THEME_SCROLLBARTHUMB_HORIZONTAL : root :: ThemeWidgetType = 60 ; pub const ThemeWidgetType_NS_THEME_SCROLLBARTHUMB_VERTICAL : root :: ThemeWidgetType = 61 ; pub const ThemeWidgetType_NS_THEME_SCROLLBAR_NON_DISAPPEARING : root :: ThemeWidgetType = 62 ; pub const ThemeWidgetType_NS_THEME_TEXTFIELD : root :: ThemeWidgetType = 63 ; pub const ThemeWidgetType_NS_THEME_CARET : root :: ThemeWidgetType = 64 ; pub const ThemeWidgetType_NS_THEME_TEXTFIELD_MULTILINE : root :: ThemeWidgetType = 65 ; pub const ThemeWidgetType_NS_THEME_SEARCHFIELD : root :: ThemeWidgetType = 66 ; pub const ThemeWidgetType_NS_THEME_MENULIST : root :: ThemeWidgetType = 67 ; pub const ThemeWidgetType_NS_THEME_MENULIST_BUTTON : root :: ThemeWidgetType = 68 ; pub const ThemeWidgetType_NS_THEME_MENULIST_TEXT : root :: ThemeWidgetType = 69 ; pub const ThemeWidgetType_NS_THEME_MENULIST_TEXTFIELD : root :: ThemeWidgetType = 70 ; pub const ThemeWidgetType_NS_THEME_SCALE_HORIZONTAL : root :: ThemeWidgetType = 71 ; pub const ThemeWidgetType_NS_THEME_SCALE_VERTICAL : root :: ThemeWidgetType = 72 ; pub const ThemeWidgetType_NS_THEME_SCALETHUMB_HORIZONTAL : root :: ThemeWidgetType = 73 ; pub const ThemeWidgetType_NS_THEME_SCALETHUMB_VERTICAL : root :: ThemeWidgetType = 74 ; pub const ThemeWidgetType_NS_THEME_SCALETHUMBSTART : root :: ThemeWidgetType = 75 ; pub const ThemeWidgetType_NS_THEME_SCALETHUMBEND : root :: ThemeWidgetType = 76 ; pub const ThemeWidgetType_NS_THEME_SCALETHUMBTICK : root :: ThemeWidgetType = 77 ; pub const ThemeWidgetType_NS_THEME_RANGE : root :: ThemeWidgetType = 78 ; pub const ThemeWidgetType_NS_THEME_RANGE_THUMB : root :: ThemeWidgetType = 79 ; pub const ThemeWidgetType_NS_THEME_GROUPBOX : root :: ThemeWidgetType = 80 ; pub const ThemeWidgetType_NS_THEME_CHECKBOX_CONTAINER : root :: ThemeWidgetType = 81 ; pub const ThemeWidgetType_NS_THEME_RADIO_CONTAINER : root :: ThemeWidgetType = 82 ; pub const ThemeWidgetType_NS_THEME_CHECKBOX_LABEL : root :: ThemeWidgetType = 83 ; pub const ThemeWidgetType_NS_THEME_RADIO_LABEL : root :: ThemeWidgetType = 84 ; pub const ThemeWidgetType_NS_THEME_BUTTON_FOCUS : root :: ThemeWidgetType = 85 ; pub const ThemeWidgetType_NS_THEME_WINDOW : root :: ThemeWidgetType = 86 ; pub const ThemeWidgetType_NS_THEME_DIALOG : root :: ThemeWidgetType = 87 ; pub const ThemeWidgetType_NS_THEME_MENUBAR : root :: ThemeWidgetType = 88 ; pub const ThemeWidgetType_NS_THEME_MENUPOPUP : root :: ThemeWidgetType = 89 ; pub const ThemeWidgetType_NS_THEME_MENUITEM : root :: ThemeWidgetType = 90 ; pub const ThemeWidgetType_NS_THEME_CHECKMENUITEM : root :: ThemeWidgetType = 91 ; pub const ThemeWidgetType_NS_THEME_RADIOMENUITEM : root :: ThemeWidgetType = 92 ; pub const ThemeWidgetType_NS_THEME_MENUCHECKBOX : root :: ThemeWidgetType = 93 ; pub const ThemeWidgetType_NS_THEME_MENURADIO : root :: ThemeWidgetType = 94 ; pub const ThemeWidgetType_NS_THEME_MENUSEPARATOR : root :: ThemeWidgetType = 95 ; pub const ThemeWidgetType_NS_THEME_MENUARROW : root :: ThemeWidgetType = 96 ; pub const ThemeWidgetType_NS_THEME_MENUIMAGE : root :: ThemeWidgetType = 97 ; pub const ThemeWidgetType_NS_THEME_MENUITEMTEXT : root :: ThemeWidgetType = 98 ; pub const ThemeWidgetType_NS_THEME_WIN_COMMUNICATIONS_TOOLBOX : root :: ThemeWidgetType = 99 ; pub const ThemeWidgetType_NS_THEME_WIN_MEDIA_TOOLBOX : root :: ThemeWidgetType = 100 ; pub const ThemeWidgetType_NS_THEME_WIN_BROWSERTABBAR_TOOLBOX : root :: ThemeWidgetType = 101 ; pub const ThemeWidgetType_NS_THEME_MAC_FULLSCREEN_BUTTON : root :: ThemeWidgetType = 102 ; pub const ThemeWidgetType_NS_THEME_MAC_HELP_BUTTON : root :: ThemeWidgetType = 103 ; pub const ThemeWidgetType_NS_THEME_WIN_BORDERLESS_GLASS : root :: ThemeWidgetType = 104 ; pub const ThemeWidgetType_NS_THEME_WIN_GLASS : root :: ThemeWidgetType = 105 ; pub const ThemeWidgetType_NS_THEME_WINDOW_TITLEBAR : root :: ThemeWidgetType = 106 ; pub const ThemeWidgetType_NS_THEME_WINDOW_TITLEBAR_MAXIMIZED : root :: ThemeWidgetType = 107 ; pub const ThemeWidgetType_NS_THEME_WINDOW_FRAME_LEFT : root :: ThemeWidgetType = 108 ; pub const ThemeWidgetType_NS_THEME_WINDOW_FRAME_RIGHT : root :: ThemeWidgetType = 109 ; pub const ThemeWidgetType_NS_THEME_WINDOW_FRAME_BOTTOM : root :: ThemeWidgetType = 110 ; pub const ThemeWidgetType_NS_THEME_WINDOW_BUTTON_CLOSE : root :: ThemeWidgetType = 111 ; pub const ThemeWidgetType_NS_THEME_WINDOW_BUTTON_MINIMIZE : root :: ThemeWidgetType = 112 ; pub const ThemeWidgetType_NS_THEME_WINDOW_BUTTON_MAXIMIZE : root :: ThemeWidgetType = 113 ; pub const ThemeWidgetType_NS_THEME_WINDOW_BUTTON_RESTORE : root :: ThemeWidgetType = 114 ; pub const ThemeWidgetType_NS_THEME_WINDOW_BUTTON_BOX : root :: ThemeWidgetType = 115 ; pub const ThemeWidgetType_NS_THEME_WINDOW_BUTTON_BOX_MAXIMIZED : root :: ThemeWidgetType = 116 ; pub const ThemeWidgetType_NS_THEME_WIN_EXCLUDE_GLASS : root :: ThemeWidgetType = 117 ; pub const ThemeWidgetType_NS_THEME_MAC_VIBRANCY_LIGHT : root :: ThemeWidgetType = 118 ; pub const ThemeWidgetType_NS_THEME_MAC_VIBRANCY_DARK : root :: ThemeWidgetType = 119 ; pub const ThemeWidgetType_NS_THEME_MAC_VIBRANT_TITLEBAR_LIGHT : root :: ThemeWidgetType = 120 ; pub const ThemeWidgetType_NS_THEME_MAC_VIBRANT_TITLEBAR_DARK : root :: ThemeWidgetType = 121 ; pub const ThemeWidgetType_NS_THEME_MAC_DISCLOSURE_BUTTON_OPEN : root :: ThemeWidgetType = 122 ; pub const ThemeWidgetType_NS_THEME_MAC_DISCLOSURE_BUTTON_CLOSED : root :: ThemeWidgetType = 123 ; pub const ThemeWidgetType_NS_THEME_GTK_INFO_BAR : root :: ThemeWidgetType = 124 ; pub const ThemeWidgetType_NS_THEME_MAC_SOURCE_LIST : root :: ThemeWidgetType = 125 ; pub const ThemeWidgetType_NS_THEME_MAC_SOURCE_LIST_SELECTION : root :: ThemeWidgetType = 126 ; pub const ThemeWidgetType_NS_THEME_MAC_ACTIVE_SOURCE_LIST_SELECTION : root :: ThemeWidgetType = 127 ; pub const ThemeWidgetType_ThemeWidgetType_COUNT : root :: ThemeWidgetType = 128 ; pub type ThemeWidgetType = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIConsoleReportCollector { _unused : [ u8 ; 0 ] } 
 /// Utility class to provide scaling defined in a keySplines element. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsSMILKeySpline { pub mX1 : f64 , pub mY1 : f64 , pub mX2 : f64 , pub mY2 : f64 , pub mSampleValues : [ f64 ; 11usize ] , } pub const nsSMILKeySpline_kSplineTableSize : root :: nsSMILKeySpline__bindgen_ty_1 = 11 ; pub type nsSMILKeySpline__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; extern "C" {
 # [ link_name = "\u{1}_ZN15nsSMILKeySpline15kSampleStepSizeE" ] 
 pub static mut  nsSMILKeySpline_kSampleStepSize  :  f64 ;
} # [ test ] fn bindgen_test_layout_nsSMILKeySpline ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsSMILKeySpline > ( ) , 120usize , concat ! ( "Size of: " , stringify ! ( nsSMILKeySpline ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsSMILKeySpline > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsSMILKeySpline ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsSMILKeySpline ) ) . mX1 as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsSMILKeySpline ) , "::" , stringify ! ( mX1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsSMILKeySpline ) ) . mY1 as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsSMILKeySpline ) , "::" , stringify ! ( mY1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsSMILKeySpline ) ) . mX2 as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsSMILKeySpline ) , "::" , stringify ! ( mX2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsSMILKeySpline ) ) . mY2 as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsSMILKeySpline ) , "::" , stringify ! ( mY2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsSMILKeySpline ) ) . mSampleValues as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsSMILKeySpline ) , "::" , stringify ! ( mSampleValues ) ) ) ; } impl Clone for nsSMILKeySpline { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsAttrName { pub mBits : usize , } # [ test ] fn bindgen_test_layout_nsAttrName ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsAttrName > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsAttrName ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsAttrName > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsAttrName ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsAttrName ) ) . mBits as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsAttrName ) , "::" , stringify ! ( mBits ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsAttrValue { pub mBits : usize , } pub const nsAttrValue_ValueType_eString : root :: nsAttrValue_ValueType = 0 ; pub const nsAttrValue_ValueType_eAtom : root :: nsAttrValue_ValueType = 2 ; pub const nsAttrValue_ValueType_eInteger : root :: nsAttrValue_ValueType = 3 ; pub const nsAttrValue_ValueType_eColor : root :: nsAttrValue_ValueType = 7 ; pub const nsAttrValue_ValueType_eEnum : root :: nsAttrValue_ValueType = 11 ; pub const nsAttrValue_ValueType_ePercent : root :: nsAttrValue_ValueType = 15 ; pub const nsAttrValue_ValueType_eCSSDeclaration : root :: nsAttrValue_ValueType = 16 ; pub const nsAttrValue_ValueType_eURL : root :: nsAttrValue_ValueType = 17 ; pub const nsAttrValue_ValueType_eImage : root :: nsAttrValue_ValueType = 18 ; pub const nsAttrValue_ValueType_eAtomArray : root :: nsAttrValue_ValueType = 19 ; pub const nsAttrValue_ValueType_eDoubleValue : root :: nsAttrValue_ValueType = 20 ; pub const nsAttrValue_ValueType_eIntMarginValue : root :: nsAttrValue_ValueType = 21 ; pub const nsAttrValue_ValueType_eSVGAngle : root :: nsAttrValue_ValueType = 22 ; pub const nsAttrValue_ValueType_eSVGTypesBegin : root :: nsAttrValue_ValueType = 22 ; pub const nsAttrValue_ValueType_eSVGIntegerPair : root :: nsAttrValue_ValueType = 23 ; pub const nsAttrValue_ValueType_eSVGLength : root :: nsAttrValue_ValueType = 24 ; pub const nsAttrValue_ValueType_eSVGLengthList : root :: nsAttrValue_ValueType = 25 ; pub const nsAttrValue_ValueType_eSVGNumberList : root :: nsAttrValue_ValueType = 26 ; pub const nsAttrValue_ValueType_eSVGNumberPair : root :: nsAttrValue_ValueType = 27 ; pub const nsAttrValue_ValueType_eSVGPathData : root :: nsAttrValue_ValueType = 28 ; pub const nsAttrValue_ValueType_eSVGPointList : root :: nsAttrValue_ValueType = 29 ; pub const nsAttrValue_ValueType_eSVGPreserveAspectRatio : root :: nsAttrValue_ValueType = 30 ; pub const nsAttrValue_ValueType_eSVGStringList : root :: nsAttrValue_ValueType = 31 ; pub const nsAttrValue_ValueType_eSVGTransformList : root :: nsAttrValue_ValueType = 32 ; pub const nsAttrValue_ValueType_eSVGViewBox : root :: nsAttrValue_ValueType = 33 ; pub const nsAttrValue_ValueType_eSVGTypesEnd : root :: nsAttrValue_ValueType = 33 ; pub type nsAttrValue_ValueType = :: std :: os :: raw :: c_uint ; 
 /// Structure for a mapping from int (enum) values to strings.  When you use
    /// it you generally create an array of them.
    /// Instantiate like this:
    /// EnumTable myTable[] = {
    /// { "string1", 1 },
    /// { "string2", 2 },
    /// { nullptr, 0 }
    /// } 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsAttrValue_EnumTable { 
 /// The string the value maps to 
 pub tag : * const :: std :: os :: raw :: c_char , 
 /// The enum value that maps to this string 
 pub value : i16 , } # [ test ] fn bindgen_test_layout_nsAttrValue_EnumTable ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsAttrValue_EnumTable > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsAttrValue_EnumTable ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsAttrValue_EnumTable > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsAttrValue_EnumTable ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsAttrValue_EnumTable ) ) . tag as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsAttrValue_EnumTable ) , "::" , stringify ! ( tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsAttrValue_EnumTable ) ) . value as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsAttrValue_EnumTable ) , "::" , stringify ! ( value ) ) ) ; } impl Clone for nsAttrValue_EnumTable { fn clone ( & self ) -> Self { * self } } pub const nsAttrValue_ValueBaseType_eStringBase : root :: nsAttrValue_ValueBaseType = 0 ; pub const nsAttrValue_ValueBaseType_eOtherBase : root :: nsAttrValue_ValueBaseType = 1 ; pub const nsAttrValue_ValueBaseType_eAtomBase : root :: nsAttrValue_ValueBaseType = 2 ; pub const nsAttrValue_ValueBaseType_eIntegerBase : root :: nsAttrValue_ValueBaseType = 3 ; pub type nsAttrValue_ValueBaseType = :: std :: os :: raw :: c_uint ; extern "C" {
 # [ link_name = "\u{1}_ZN11nsAttrValue15sEnumTableArrayE" ] 
 pub static mut  nsAttrValue_sEnumTableArray  :  * mut root :: nsTArray < * const root :: nsAttrValue_EnumTable > ;
} # [ test ] fn bindgen_test_layout_nsAttrValue ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsAttrValue > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsAttrValue ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsAttrValue > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsAttrValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsAttrValue ) ) . mBits as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsAttrValue ) , "::" , stringify ! ( mBits ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsMappedAttributes { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsAttrAndChildArray { pub mImpl : * mut root :: nsAttrAndChildArray_Impl , } pub type nsAttrAndChildArray_BorrowedAttrInfo = root :: mozilla :: dom :: BorrowedAttrInfo ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsAttrAndChildArray_InternalAttr { pub mName : root :: nsAttrName , pub mValue : root :: nsAttrValue , } # [ test ] fn bindgen_test_layout_nsAttrAndChildArray_InternalAttr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsAttrAndChildArray_InternalAttr > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsAttrAndChildArray_InternalAttr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsAttrAndChildArray_InternalAttr > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsAttrAndChildArray_InternalAttr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsAttrAndChildArray_InternalAttr ) ) . mName as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsAttrAndChildArray_InternalAttr ) , "::" , stringify ! ( mName ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsAttrAndChildArray_InternalAttr ) ) . mValue as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsAttrAndChildArray_InternalAttr ) , "::" , stringify ! ( mValue ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsAttrAndChildArray_Impl { pub mAttrAndChildCount : u32 , pub mBufferSize : u32 , pub mMappedAttrs : * mut root :: nsMappedAttributes , pub mBuffer : [ * mut :: std :: os :: raw :: c_void ; 1usize ] , } # [ test ] fn bindgen_test_layout_nsAttrAndChildArray_Impl ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsAttrAndChildArray_Impl > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsAttrAndChildArray_Impl ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsAttrAndChildArray_Impl > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsAttrAndChildArray_Impl ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsAttrAndChildArray_Impl ) ) . mAttrAndChildCount as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsAttrAndChildArray_Impl ) , "::" , stringify ! ( mAttrAndChildCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsAttrAndChildArray_Impl ) ) . mBufferSize as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( nsAttrAndChildArray_Impl ) , "::" , stringify ! ( mBufferSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsAttrAndChildArray_Impl ) ) . mMappedAttrs as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsAttrAndChildArray_Impl ) , "::" , stringify ! ( mMappedAttrs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsAttrAndChildArray_Impl ) ) . mBuffer as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsAttrAndChildArray_Impl ) , "::" , stringify ! ( mBuffer ) ) ) ; } impl Clone for nsAttrAndChildArray_Impl { fn clone ( & self ) -> Self { * self } } # [ test ] fn bindgen_test_layout_nsAttrAndChildArray ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsAttrAndChildArray > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsAttrAndChildArray ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsAttrAndChildArray > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsAttrAndChildArray ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsAttrAndChildArray ) ) . mImpl as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsAttrAndChildArray ) , "::" , stringify ! ( mImpl ) ) ) ; } 
 /// An internal interface 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIHTMLCollection { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIHTMLCollection_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIHTMLCollection ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIHTMLCollection > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIHTMLCollection ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIHTMLCollection > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIHTMLCollection ) ) ) ; } impl Clone for nsIHTMLCollection { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsXBLDocumentInfo { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIStyleRuleProcessor { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIStyleRuleProcessor_COMTypeInfo { pub _address : u8 , } pub type nsIStyleRuleProcessor_EnumFunc = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut root :: nsIStyleRuleProcessor , arg2 : * mut :: std :: os :: raw :: c_void ) -> bool > ; # [ test ] fn bindgen_test_layout_nsIStyleRuleProcessor ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIStyleRuleProcessor > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIStyleRuleProcessor ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIStyleRuleProcessor > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIStyleRuleProcessor ) ) ) ; } impl Clone for nsIStyleRuleProcessor { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsXBLPrototypeBinding { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsAnonymousContentList { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] pub struct nsXBLBinding { pub mRefCnt : root :: nsCycleCollectingAutoRefCnt , pub mMarkedForDeath : bool , pub mUsingContentXBLScope : bool , pub mIsShadowRootBinding : bool , pub mPrototypeBinding : * mut root :: nsXBLPrototypeBinding , pub mContent : root :: nsCOMPtr , pub mNextBinding : root :: RefPtr < root :: nsXBLBinding > , pub mBoundElement : * mut root :: mozilla :: dom :: Element , pub mDefaultInsertionPoint : root :: RefPtr < root :: mozilla :: dom :: XBLChildrenElement > , pub mInsertionPoints : root :: nsTArray < root :: RefPtr < root :: mozilla :: dom :: XBLChildrenElement > > , pub mAnonymousContentList : root :: RefPtr < root :: nsAnonymousContentList > , } pub type nsXBLBinding_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsXBLBinding_cycleCollection { pub _base : root :: nsCycleCollectionParticipant , } # [ test ] fn bindgen_test_layout_nsXBLBinding_cycleCollection ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsXBLBinding_cycleCollection > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsXBLBinding_cycleCollection ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsXBLBinding_cycleCollection > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsXBLBinding_cycleCollection ) ) ) ; } impl Clone for nsXBLBinding_cycleCollection { fn clone ( & self ) -> Self { * self } } extern "C" {
 # [ link_name = "\u{1}_ZN12nsXBLBinding21_cycleCollectorGlobalE" ] 
 pub static mut  nsXBLBinding__cycleCollectorGlobal  :  root :: nsXBLBinding_cycleCollection ;
} # [ test ] fn bindgen_test_layout_nsXBLBinding ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsXBLBinding > ( ) , 72usize , concat ! ( "Size of: " , stringify ! ( nsXBLBinding ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsXBLBinding > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsXBLBinding ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsXBLBinding ) ) . mRefCnt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsXBLBinding ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsXBLBinding ) ) . mMarkedForDeath as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsXBLBinding ) , "::" , stringify ! ( mMarkedForDeath ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsXBLBinding ) ) . mUsingContentXBLScope as * const _ as usize } , 9usize , concat ! ( "Alignment of field: " , stringify ! ( nsXBLBinding ) , "::" , stringify ! ( mUsingContentXBLScope ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsXBLBinding ) ) . mIsShadowRootBinding as * const _ as usize } , 10usize , concat ! ( "Alignment of field: " , stringify ! ( nsXBLBinding ) , "::" , stringify ! ( mIsShadowRootBinding ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsXBLBinding ) ) . mPrototypeBinding as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsXBLBinding ) , "::" , stringify ! ( mPrototypeBinding ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsXBLBinding ) ) . mContent as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsXBLBinding ) , "::" , stringify ! ( mContent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsXBLBinding ) ) . mNextBinding as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsXBLBinding ) , "::" , stringify ! ( mNextBinding ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsXBLBinding ) ) . mBoundElement as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( nsXBLBinding ) , "::" , stringify ! ( mBoundElement ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsXBLBinding ) ) . mDefaultInsertionPoint as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( nsXBLBinding ) , "::" , stringify ! ( mDefaultInsertionPoint ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsXBLBinding ) ) . mInsertionPoints as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( nsXBLBinding ) , "::" , stringify ! ( mInsertionPoints ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsXBLBinding ) ) . mAnonymousContentList as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( nsXBLBinding ) , "::" , stringify ! ( mAnonymousContentList ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsLabelsNodeList { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsDOMTokenList { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsDOMStringMap { _unused : [ u8 ; 0 ] } 
 /// A class that implements nsIWeakReference 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsNodeWeakReference { pub _base : root :: nsIWeakReference , pub mRefCnt : root :: nsAutoRefCnt , } pub type nsNodeWeakReference_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ test ] fn bindgen_test_layout_nsNodeWeakReference ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsNodeWeakReference > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsNodeWeakReference ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsNodeWeakReference > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsNodeWeakReference ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsNodeWeakReference ) ) . mRefCnt as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsNodeWeakReference ) , "::" , stringify ! ( mRefCnt ) ) ) ; } 
 /// Interface used for handling clicks on links 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsILinkHandler { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsILinkHandler_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsILinkHandler ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsILinkHandler > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsILinkHandler ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsILinkHandler > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsILinkHandler ) ) ) ; } impl Clone for nsILinkHandler { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] pub struct nsIAttribute { pub _base : root :: nsINode , pub mAttrMap : root :: RefPtr < root :: nsDOMAttributeMap > , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIAttribute_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIAttribute ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIAttribute > ( ) , 96usize , concat ! ( "Size of: " , stringify ! ( nsIAttribute ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIAttribute > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIAttribute ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIAttribute ) ) . mAttrMap as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( nsIAttribute ) , "::" , stringify ! ( mAttrMap ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIDOMAttr { pub _base : root :: nsIDOMNode , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIDOMAttr_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIDOMAttr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIDOMAttr > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIDOMAttr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIDOMAttr > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIDOMAttr ) ) ) ; } impl Clone for nsIDOMAttr { fn clone ( & self ) -> Self { * self } } 
 /// There are two advantages to inheriting from nsStubMutationObserver
    /// rather than directly from nsIMutationObserver:
    /// 1. smaller compiled code size (since there's no need for the code
    /// for the empty virtual function implementations for every
    /// nsIMutationObserver implementation)
    /// 2. the performance of document's loop over observers benefits from
    /// the fact that more of the functions called are the same (which
    /// can reduce instruction cache misses and perhaps improve branch
    /// prediction) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsStubMutationObserver { pub _base : root :: nsIMutationObserver , } # [ test ] fn bindgen_test_layout_nsStubMutationObserver ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStubMutationObserver > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsStubMutationObserver ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStubMutationObserver > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStubMutationObserver ) ) ) ; } impl Clone for nsStubMutationObserver { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIDOMMozNamedAttrMap { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIDOMMozNamedAttrMap_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIDOMMozNamedAttrMap ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIDOMMozNamedAttrMap > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIDOMMozNamedAttrMap ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIDOMMozNamedAttrMap > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIDOMMozNamedAttrMap ) ) ) ; } impl Clone for nsIDOMMozNamedAttrMap { fn clone ( & self ) -> Self { * self } } 
 /// Structure used as a key for caching Attrs in nsDOMAttributeMap's mAttributeCache. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsAttrKey { 
 /// The namespace of the attribute 
 pub mNamespaceID : i32 , 
 /// The atom for attribute, stored as void*, to make sure that we only use it
        /// for the hashcode, and we can never dereference it. 
 pub mLocalName : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout_nsAttrKey ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsAttrKey > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsAttrKey ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsAttrKey > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsAttrKey ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsAttrKey ) ) . mNamespaceID as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsAttrKey ) , "::" , stringify ! ( mNamespaceID ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsAttrKey ) ) . mLocalName as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsAttrKey ) , "::" , stringify ! ( mLocalName ) ) ) ; } impl Clone for nsAttrKey { fn clone ( & self ) -> Self { * self } } 
 /// PLDHashEntryHdr implementation for nsAttrKey. 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsAttrHashKey { pub _base : root :: PLDHashEntryHdr , pub mKey : root :: nsAttrKey , } pub type nsAttrHashKey_KeyType = * const root :: nsAttrKey ; pub type nsAttrHashKey_KeyTypePointer = * const root :: nsAttrKey ; pub const nsAttrHashKey_ALLOW_MEMMOVE : root :: nsAttrHashKey__bindgen_ty_1 = 1 ; pub type nsAttrHashKey__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_nsAttrHashKey ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsAttrHashKey > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( nsAttrHashKey ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsAttrHashKey > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsAttrHashKey ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsAttrHashKey ) ) . mKey as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsAttrHashKey ) , "::" , stringify ! ( mKey ) ) ) ; } # [ repr ( C ) ] pub struct nsDOMAttributeMap { pub _base : root :: nsIDOMMozNamedAttrMap , pub _base_1 : root :: nsWrapperCache , pub mRefCnt : root :: nsCycleCollectingAutoRefCnt , pub mContent : root :: nsCOMPtr , 
 /// Cache of Attrs. 
 pub mAttributeCache : root :: nsDOMAttributeMap_AttrCache , } pub type nsDOMAttributeMap_Attr = root :: mozilla :: dom :: Attr ; pub type nsDOMAttributeMap_DocGroup = root :: mozilla :: dom :: DocGroup ; pub type nsDOMAttributeMap_Element = root :: mozilla :: dom :: Element ; pub type nsDOMAttributeMap_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsDOMAttributeMap_cycleCollection { pub _base : root :: nsXPCOMCycleCollectionParticipant , } # [ test ] fn bindgen_test_layout_nsDOMAttributeMap_cycleCollection ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsDOMAttributeMap_cycleCollection > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsDOMAttributeMap_cycleCollection ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsDOMAttributeMap_cycleCollection > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsDOMAttributeMap_cycleCollection ) ) ) ; } impl Clone for nsDOMAttributeMap_cycleCollection { fn clone ( & self ) -> Self { * self } } pub type nsDOMAttributeMap_AttrCache = [ u64 ; 4usize ] ; extern "C" {
 # [ link_name = "\u{1}_ZN17nsDOMAttributeMap21_cycleCollectorGlobalE" ] 
 pub static mut  nsDOMAttributeMap__cycleCollectorGlobal  :  root :: nsDOMAttributeMap_cycleCollection ;
} # [ test ] fn bindgen_test_layout_nsDOMAttributeMap ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsDOMAttributeMap > ( ) , 80usize , concat ! ( "Size of: " , stringify ! ( nsDOMAttributeMap ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsDOMAttributeMap > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsDOMAttributeMap ) ) ) ; } # [ repr ( C ) ] pub struct nsISMILAttr__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; 
 /// 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsISMILAttr { pub vtable_ : * const nsISMILAttr__bindgen_vtable , } # [ test ] fn bindgen_test_layout_nsISMILAttr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsISMILAttr > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsISMILAttr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsISMILAttr > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsISMILAttr ) ) ) ; } 
 /// nsITheme is a service that provides platform-specific native
    /// rendering for widgets.  In other words, it provides the necessary
    /// operations to draw a rendering object (an nsIFrame) as a native
    /// widget.
    ///
    /// All the methods on nsITheme take a rendering context or device
    /// context, a frame (the rendering object), and a widget type (one of
    /// the constants in nsThemeConstants.h). 
 # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsITheme { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsITheme_COMTypeInfo { pub _address : u8 , } pub const nsITheme_Transparency_eOpaque : root :: nsITheme_Transparency = 0 ; pub const nsITheme_Transparency_eTransparent : root :: nsITheme_Transparency = 1 ; pub const nsITheme_Transparency_eUnknownTransparency : root :: nsITheme_Transparency = 2 ; pub type nsITheme_Transparency = :: std :: os :: raw :: c_uint ; 
 /// ThemeGeometryType values are used for describing themed nsIFrames in
    /// calls to nsIWidget::UpdateThemeGeometries. We don't simply pass the
    /// -moz-appearance value ("widget type") of the frame because the widget may
    /// want to treat different frames with the same -moz-appearance differently
    /// based on other properties of the frame. So we give the theme a first look
    /// at the frame in nsITheme::ThemeGeometryTypeForWidget and pass the
    /// returned ThemeGeometryType along to the widget.
    /// Each theme backend defines the ThemeGeometryType values it needs in its
    /// own nsITheme subclass. eThemeGeometryTypeUnknown is the only value that's
    /// shared between backends. 
 pub type nsITheme_ThemeGeometryType = u8 ; pub const nsITheme_eThemeGeometryTypeUnknown : root :: nsITheme__bindgen_ty_1 = 0 ; pub type nsITheme__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_nsITheme ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsITheme > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsITheme ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsITheme > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsITheme ) ) ) ; } impl Clone for nsITheme { fn clone ( & self ) -> Self { * self } } pub type nsIWidget_LayoutDeviceIntPoint = root :: mozilla :: LayoutDeviceIntPoint ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsIWidget_LongTapInfo { pub mPointerId : i32 , pub mPosition : root :: nsIWidget_LayoutDeviceIntPoint , pub mDuration : root :: mozilla :: TimeDuration , pub mObserver : root :: nsCOMPtr , pub mStamp : root :: mozilla :: TimeStamp , } # [ test ] fn bindgen_test_layout_nsIWidget_LongTapInfo ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIWidget_LongTapInfo > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( nsIWidget_LongTapInfo ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIWidget_LongTapInfo > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIWidget_LongTapInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIWidget_LongTapInfo ) ) . mPointerId as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsIWidget_LongTapInfo ) , "::" , stringify ! ( mPointerId ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIWidget_LongTapInfo ) ) . mPosition as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( nsIWidget_LongTapInfo ) , "::" , stringify ! ( mPosition ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIWidget_LongTapInfo ) ) . mDuration as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsIWidget_LongTapInfo ) , "::" , stringify ! ( mDuration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIWidget_LongTapInfo ) ) . mObserver as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsIWidget_LongTapInfo ) , "::" , stringify ! ( mObserver ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsIWidget_LongTapInfo ) ) . mStamp as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsIWidget_LongTapInfo ) , "::" , stringify ! ( mStamp ) ) ) ; } pub const ELEMENT_SHARED_RESTYLE_BIT_1 : root :: _bindgen_ty_79 = 8388608 ; pub const ELEMENT_SHARED_RESTYLE_BIT_2 : root :: _bindgen_ty_79 = 16777216 ; pub const ELEMENT_SHARED_RESTYLE_BIT_3 : root :: _bindgen_ty_79 = 33554432 ; pub const ELEMENT_SHARED_RESTYLE_BIT_4 : root :: _bindgen_ty_79 = 67108864 ; pub const ELEMENT_SHARED_RESTYLE_BITS : root :: _bindgen_ty_79 = 125829120 ; pub const ELEMENT_HAS_DIRTY_DESCENDANTS_FOR_SERVO : root :: _bindgen_ty_79 = 8388608 ; pub const ELEMENT_HAS_ANIMATION_ONLY_DIRTY_DESCENDANTS_FOR_SERVO : root :: _bindgen_ty_79 = 16777216 ; pub const ELEMENT_HAS_SNAPSHOT : root :: _bindgen_ty_79 = 33554432 ; pub const ELEMENT_HANDLED_SNAPSHOT : root :: _bindgen_ty_79 = 67108864 ; pub const ELEMENT_HAS_PENDING_RESTYLE : root :: _bindgen_ty_79 = 8388608 ; pub const ELEMENT_IS_POTENTIAL_RESTYLE_ROOT : root :: _bindgen_ty_79 = 16777216 ; pub const ELEMENT_HAS_PENDING_ANIMATION_ONLY_RESTYLE : root :: _bindgen_ty_79 = 33554432 ; pub const ELEMENT_IS_POTENTIAL_ANIMATION_ONLY_RESTYLE_ROOT : root :: _bindgen_ty_79 = 67108864 ; pub const ELEMENT_IS_CONDITIONAL_RESTYLE_ANCESTOR : root :: _bindgen_ty_79 = 134217728 ; pub const ELEMENT_HAS_CHILD_WITH_LATER_SIBLINGS_HINT : root :: _bindgen_ty_79 = 268435456 ; pub const ELEMENT_PENDING_RESTYLE_FLAGS : root :: _bindgen_ty_79 = 41943040 ; pub const ELEMENT_POTENTIAL_RESTYLE_ROOT_FLAGS : root :: _bindgen_ty_79 = 83886080 ; pub const ELEMENT_ALL_RESTYLE_FLAGS : root :: _bindgen_ty_79 = 260046848 ; pub const ELEMENT_TYPE_SPECIFIC_BITS_OFFSET : root :: _bindgen_ty_79 = 27 ; pub type _bindgen_ty_79 = :: std :: os :: raw :: c_uint ; pub const GECKO_IS_NIGHTLY : bool = true ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct ServoBundledURI { pub mURLString : * const u8 , pub mURLStringLength : u32 , pub mExtraData : * mut root :: mozilla :: URLExtraData , } # [ test ] fn bindgen_test_layout_ServoBundledURI ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ServoBundledURI > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( ServoBundledURI ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ServoBundledURI > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ServoBundledURI ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoBundledURI ) ) . mURLString as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ServoBundledURI ) , "::" , stringify ! ( mURLString ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoBundledURI ) ) . mURLStringLength as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ServoBundledURI ) , "::" , stringify ! ( mURLStringLength ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ServoBundledURI ) ) . mExtraData as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( ServoBundledURI ) , "::" , stringify ! ( mExtraData ) ) ) ; } impl Clone for ServoBundledURI { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct FontSizePrefs { pub mDefaultVariableSize : root :: nscoord , pub mDefaultFixedSize : root :: nscoord , pub mDefaultSerifSize : root :: nscoord , pub mDefaultSansSerifSize : root :: nscoord , pub mDefaultMonospaceSize : root :: nscoord , pub mDefaultCursiveSize : root :: nscoord , pub mDefaultFantasySize : root :: nscoord , } # [ test ] fn bindgen_test_layout_FontSizePrefs ( ) { assert_eq ! ( :: std :: mem :: size_of :: < FontSizePrefs > ( ) , 28usize , concat ! ( "Size of: " , stringify ! ( FontSizePrefs ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < FontSizePrefs > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( FontSizePrefs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FontSizePrefs ) ) . mDefaultVariableSize as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( FontSizePrefs ) , "::" , stringify ! ( mDefaultVariableSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FontSizePrefs ) ) . mDefaultFixedSize as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( FontSizePrefs ) , "::" , stringify ! ( mDefaultFixedSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FontSizePrefs ) ) . mDefaultSerifSize as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( FontSizePrefs ) , "::" , stringify ! ( mDefaultSerifSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FontSizePrefs ) ) . mDefaultSansSerifSize as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( FontSizePrefs ) , "::" , stringify ! ( mDefaultSansSerifSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FontSizePrefs ) ) . mDefaultMonospaceSize as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( FontSizePrefs ) , "::" , stringify ! ( mDefaultMonospaceSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FontSizePrefs ) ) . mDefaultCursiveSize as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( FontSizePrefs ) , "::" , stringify ! ( mDefaultCursiveSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const FontSizePrefs ) ) . mDefaultFantasySize as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( FontSizePrefs ) , "::" , stringify ! ( mDefaultFantasySize ) ) ) ; } impl Clone for FontSizePrefs { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct GeckoFontMetrics { pub mChSize : root :: nscoord , pub mXSize : root :: nscoord , } # [ test ] fn bindgen_test_layout_GeckoFontMetrics ( ) { assert_eq ! ( :: std :: mem :: size_of :: < GeckoFontMetrics > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( GeckoFontMetrics ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < GeckoFontMetrics > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( GeckoFontMetrics ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoFontMetrics ) ) . mChSize as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoFontMetrics ) , "::" , stringify ! ( mChSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const GeckoFontMetrics ) ) . mXSize as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( GeckoFontMetrics ) , "::" , stringify ! ( mXSize ) ) ) ; } impl Clone for GeckoFontMetrics { fn clone ( & self ) -> Self { * self } } pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_after : u32 = 65 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_before : u32 = 65 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_backdrop : u32 = 0 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_cue : u32 = 36 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_firstLetter : u32 = 3 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_firstLine : u32 = 3 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozSelection : u32 = 2 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozFocusInner : u32 = 0 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozFocusOuter : u32 = 0 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozListBullet : u32 = 0 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozListNumber : u32 = 0 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozMathAnonymous : u32 = 0 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozNumberWrapper : u32 = 24 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozNumberText : u32 = 24 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozNumberSpinBox : u32 = 24 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozNumberSpinUp : u32 = 24 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozNumberSpinDown : u32 = 24 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozProgressBar : u32 = 8 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozRangeTrack : u32 = 8 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozRangeProgress : u32 = 8 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozRangeThumb : u32 = 8 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozMeterBar : u32 = 8 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozPlaceholder : u32 = 8 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_placeholder : u32 = 8 ; pub const SERVO_CSS_PSEUDO_ELEMENT_FLAGS_mozColorSwatch : u32 = 12 ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIDOMMediaList { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIDOMMediaList_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIDOMMediaList ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIDOMMediaList > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIDOMMediaList ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIDOMMediaList > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIDOMMediaList ) ) ) ; } impl Clone for nsIDOMMediaList { fn clone ( & self ) -> Self { * self } } pub type nsCSSAnonBoxes_NonInheritingBase = u8 ; pub const nsCSSAnonBoxes_NonInheriting_oofPlaceholder : root :: nsCSSAnonBoxes_NonInheriting = 0 ; pub const nsCSSAnonBoxes_NonInheriting_horizontalFramesetBorder : root :: nsCSSAnonBoxes_NonInheriting = 1 ; pub const nsCSSAnonBoxes_NonInheriting_verticalFramesetBorder : root :: nsCSSAnonBoxes_NonInheriting = 2 ; pub const nsCSSAnonBoxes_NonInheriting_framesetBlank : root :: nsCSSAnonBoxes_NonInheriting = 3 ; pub const nsCSSAnonBoxes_NonInheriting_tableColGroup : root :: nsCSSAnonBoxes_NonInheriting = 4 ; pub const nsCSSAnonBoxes_NonInheriting_tableCol : root :: nsCSSAnonBoxes_NonInheriting = 5 ; pub const nsCSSAnonBoxes_NonInheriting_pageBreak : root :: nsCSSAnonBoxes_NonInheriting = 6 ; pub const nsCSSAnonBoxes_NonInheriting__Count : root :: nsCSSAnonBoxes_NonInheriting = 7 ; pub type nsCSSAnonBoxes_NonInheriting = root :: nsCSSAnonBoxes_NonInheritingBase ; 
 /// templated hashtable class maps keys to interface pointers.
    /// See nsBaseHashtable for complete declaration.
    /// @param KeyClass a wrapper-class for the hashtable key, see nsHashKeys.h
    /// for a complete specification.
    /// @param Interface the interface-type being wrapped
    /// @see nsDataHashtable, nsClassHashtable 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsInterfaceHashtable { pub _address : u8 , } pub type nsInterfaceHashtable_KeyType = [ u8 ; 0usize ] ; pub type nsInterfaceHashtable_UserDataType < Interface > = * mut Interface ; pub type nsInterfaceHashtable_base_type = u8 ; pub type nsBindingList = root :: nsTArray < root :: RefPtr < root :: nsXBLBinding > > ; # [ repr ( C ) ] pub struct nsBindingManager { pub _base : root :: nsStubMutationObserver , pub mRefCnt : root :: nsCycleCollectingAutoRefCnt , pub mBoundContentSet : u64 , pub mWrapperTable : root :: nsAutoPtr < root :: nsBindingManager_WrapperHashtable > , pub mDocumentTable : u64 , pub mLoadingDocTable : u64 , pub mAttachedStack : root :: nsBindingList , pub mProcessingAttachedStack : bool , pub mDestroyed : bool , pub mAttachedStackSizeOnOutermost : u32 , pub mProcessAttachedQueueEvent : u64 , pub mDocument : * mut root :: nsIDocument , } pub type nsBindingManager_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; pub const nsBindingManager_DestructorHandling_eRunDtor : root :: nsBindingManager_DestructorHandling = 0 ; pub const nsBindingManager_DestructorHandling_eDoNotRunDtor : root :: nsBindingManager_DestructorHandling = 1 ; pub type nsBindingManager_DestructorHandling = :: std :: os :: raw :: c_uint ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsBindingManager_cycleCollection { pub _base : root :: nsXPCOMCycleCollectionParticipant , } # [ test ] fn bindgen_test_layout_nsBindingManager_cycleCollection ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsBindingManager_cycleCollection > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsBindingManager_cycleCollection ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsBindingManager_cycleCollection > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsBindingManager_cycleCollection ) ) ) ; } impl Clone for nsBindingManager_cycleCollection { fn clone ( & self ) -> Self { * self } } pub type nsBindingManager_BoundContentBindingCallback = root :: std :: function ; pub type nsBindingManager_WrapperHashtable = u8 ; extern "C" {
 # [ link_name = "\u{1}_ZN16nsBindingManager21_cycleCollectorGlobalE" ] 
 pub static mut  nsBindingManager__cycleCollectorGlobal  :  root :: nsBindingManager_cycleCollection ;
} # [ test ] fn bindgen_test_layout_nsBindingManager ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsBindingManager > ( ) , 80usize , concat ! ( "Size of: " , stringify ! ( nsBindingManager ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsBindingManager > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsBindingManager ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsBindingManager ) ) . mRefCnt as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsBindingManager ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsBindingManager ) ) . mBoundContentSet as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsBindingManager ) , "::" , stringify ! ( mBoundContentSet ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsBindingManager ) ) . mWrapperTable as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsBindingManager ) , "::" , stringify ! ( mWrapperTable ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsBindingManager ) ) . mDocumentTable as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsBindingManager ) , "::" , stringify ! ( mDocumentTable ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsBindingManager ) ) . mLoadingDocTable as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( nsBindingManager ) , "::" , stringify ! ( mLoadingDocTable ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsBindingManager ) ) . mAttachedStack as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( nsBindingManager ) , "::" , stringify ! ( mAttachedStack ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsBindingManager ) ) . mProcessingAttachedStack as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( nsBindingManager ) , "::" , stringify ! ( mProcessingAttachedStack ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsBindingManager ) ) . mDestroyed as * const _ as usize } , 57usize , concat ! ( "Alignment of field: " , stringify ! ( nsBindingManager ) , "::" , stringify ! ( mDestroyed ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsBindingManager ) ) . mAttachedStackSizeOnOutermost as * const _ as usize } , 60usize , concat ! ( "Alignment of field: " , stringify ! ( nsBindingManager ) , "::" , stringify ! ( mAttachedStackSizeOnOutermost ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsBindingManager ) ) . mProcessAttachedQueueEvent as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( nsBindingManager ) , "::" , stringify ! ( mProcessAttachedQueueEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsBindingManager ) ) . mDocument as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( nsBindingManager ) , "::" , stringify ! ( mDocument ) ) ) ; } 
 /// An nsStyleContext represents the computed style data for an element.
    /// The computed style data are stored in a set of structs (see
    /// nsStyleStruct.h) that are cached either on the style context or in
    /// the rule tree (see nsRuleNode.h for a description of this caching and
    /// how the cached structs are shared).
    ///
    /// Since the data in |nsIStyleRule|s and |nsRuleNode|s are immutable
    /// (with a few exceptions, like system color changes), the data in an
    /// nsStyleContext are also immutable (with the additional exception of
    /// GetUniqueStyleData).  When style data change,
    /// ElementRestyler::Restyle creates a new style context.
    ///
    /// Style contexts are reference counted.  References are generally held
    /// by:
    /// 1. the |nsIFrame|s that are using the style context and
    /// 2. any *child* style contexts (this might be the reverse of
    /// expectation, but it makes sense in this case) 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsStyleContext { pub mPseudoTag : root :: RefPtr < root :: nsAtom > , pub mBits : u64 , } # [ test ] fn bindgen_test_layout_nsStyleContext ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsStyleContext > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsStyleContext ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsStyleContext > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsStyleContext ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleContext ) ) . mPseudoTag as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleContext ) , "::" , stringify ! ( mPseudoTag ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsStyleContext ) ) . mBits as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsStyleContext ) , "::" , stringify ! ( mBits ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIDOMCSSRule { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIDOMCSSRule_COMTypeInfo { pub _address : u8 , } pub const nsIDOMCSSRule_UNKNOWN_RULE : root :: nsIDOMCSSRule__bindgen_ty_1 = 0 ; pub const nsIDOMCSSRule_STYLE_RULE : root :: nsIDOMCSSRule__bindgen_ty_1 = 1 ; pub const nsIDOMCSSRule_CHARSET_RULE : root :: nsIDOMCSSRule__bindgen_ty_1 = 2 ; pub const nsIDOMCSSRule_IMPORT_RULE : root :: nsIDOMCSSRule__bindgen_ty_1 = 3 ; pub const nsIDOMCSSRule_MEDIA_RULE : root :: nsIDOMCSSRule__bindgen_ty_1 = 4 ; pub const nsIDOMCSSRule_FONT_FACE_RULE : root :: nsIDOMCSSRule__bindgen_ty_1 = 5 ; pub const nsIDOMCSSRule_PAGE_RULE : root :: nsIDOMCSSRule__bindgen_ty_1 = 6 ; pub const nsIDOMCSSRule_KEYFRAMES_RULE : root :: nsIDOMCSSRule__bindgen_ty_1 = 7 ; pub const nsIDOMCSSRule_KEYFRAME_RULE : root :: nsIDOMCSSRule__bindgen_ty_1 = 8 ; pub const nsIDOMCSSRule_MOZ_KEYFRAMES_RULE : root :: nsIDOMCSSRule__bindgen_ty_1 = 7 ; pub const nsIDOMCSSRule_MOZ_KEYFRAME_RULE : root :: nsIDOMCSSRule__bindgen_ty_1 = 8 ; pub const nsIDOMCSSRule_NAMESPACE_RULE : root :: nsIDOMCSSRule__bindgen_ty_1 = 10 ; pub const nsIDOMCSSRule_COUNTER_STYLE_RULE : root :: nsIDOMCSSRule__bindgen_ty_1 = 11 ; pub const nsIDOMCSSRule_SUPPORTS_RULE : root :: nsIDOMCSSRule__bindgen_ty_1 = 12 ; pub const nsIDOMCSSRule_DOCUMENT_RULE : root :: nsIDOMCSSRule__bindgen_ty_1 = 13 ; pub const nsIDOMCSSRule_FONT_FEATURE_VALUES_RULE : root :: nsIDOMCSSRule__bindgen_ty_1 = 14 ; pub type nsIDOMCSSRule__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; # [ test ] fn bindgen_test_layout_nsIDOMCSSRule ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIDOMCSSRule > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIDOMCSSRule ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIDOMCSSRule > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIDOMCSSRule ) ) ) ; } impl Clone for nsIDOMCSSRule { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIDOMCSSCounterStyleRule { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIDOMCSSCounterStyleRule_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIDOMCSSCounterStyleRule ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIDOMCSSCounterStyleRule > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIDOMCSSCounterStyleRule ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIDOMCSSCounterStyleRule > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIDOMCSSCounterStyleRule ) ) ) ; } impl Clone for nsIDOMCSSCounterStyleRule { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCSSCounterStyleRule { pub _base : root :: mozilla :: css :: Rule , pub _base_1 : root :: nsIDOMCSSCounterStyleRule , pub mName : root :: RefPtr < root :: nsAtom > , pub mValues : [ root :: nsCSSValue ; 10usize ] , pub mGeneration : u32 , } pub type nsCSSCounterStyleRule_Getter = :: std :: option :: Option < unsafe extern "C" fn ( ) -> root :: nsresult > ; extern "C" {
 # [ link_name = "\u{1}_ZN21nsCSSCounterStyleRule8kGettersE" ] 
 pub static mut  nsCSSCounterStyleRule_kGetters  :  [ root :: nsCSSCounterStyleRule_Getter ; 0usize ] ;
} # [ test ] fn bindgen_test_layout_nsCSSCounterStyleRule ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSCounterStyleRule > ( ) , 248usize , concat ! ( "Size of: " , stringify ! ( nsCSSCounterStyleRule ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSCounterStyleRule > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSCounterStyleRule ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIDOMCSSStyleDeclaration { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIDOMCSSStyleDeclaration_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIDOMCSSStyleDeclaration ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIDOMCSSStyleDeclaration > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIDOMCSSStyleDeclaration ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIDOMCSSStyleDeclaration > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIDOMCSSStyleDeclaration ) ) ) ; } impl Clone for nsIDOMCSSStyleDeclaration { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsICSSDeclaration { pub _base : root :: nsIDOMCSSStyleDeclaration , pub _base_1 : root :: nsWrapperCache , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsICSSDeclaration_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsICSSDeclaration ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsICSSDeclaration > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( nsICSSDeclaration ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsICSSDeclaration > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsICSSDeclaration ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsIDOMCSSFontFaceRule { pub _base : root :: nsISupports , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIDOMCSSFontFaceRule_COMTypeInfo { pub _address : u8 , } # [ test ] fn bindgen_test_layout_nsIDOMCSSFontFaceRule ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsIDOMCSSFontFaceRule > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsIDOMCSSFontFaceRule ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsIDOMCSSFontFaceRule > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsIDOMCSSFontFaceRule ) ) ) ; } impl Clone for nsIDOMCSSFontFaceRule { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCSSFontFaceStyleDecl { pub _base : root :: nsICSSDeclaration , pub mDescriptors : root :: mozilla :: CSSFontFaceDescriptors , } # [ test ] fn bindgen_test_layout_nsCSSFontFaceStyleDecl ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSFontFaceStyleDecl > ( ) , 176usize , concat ! ( "Size of: " , stringify ! ( nsCSSFontFaceStyleDecl ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSFontFaceStyleDecl > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSFontFaceStyleDecl ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsCSSFontFaceStyleDecl ) ) . mDescriptors as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsCSSFontFaceStyleDecl ) , "::" , stringify ! ( mDescriptors ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsCSSFontFaceRule { pub _base : root :: mozilla :: css :: Rule , pub _base_1 : root :: nsIDOMCSSFontFaceRule , pub mDecl : root :: nsCSSFontFaceStyleDecl , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsCSSFontFaceRule_cycleCollection { pub _base : root :: mozilla :: css :: Rule_cycleCollection , } # [ test ] fn bindgen_test_layout_nsCSSFontFaceRule_cycleCollection ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSFontFaceRule_cycleCollection > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsCSSFontFaceRule_cycleCollection ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSFontFaceRule_cycleCollection > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSFontFaceRule_cycleCollection ) ) ) ; } impl Clone for nsCSSFontFaceRule_cycleCollection { fn clone ( & self ) -> Self { * self } } extern "C" {
 # [ link_name = "\u{1}_ZN17nsCSSFontFaceRule21_cycleCollectorGlobalE" ] 
 pub static mut  nsCSSFontFaceRule__cycleCollectorGlobal  :  root :: nsCSSFontFaceRule_cycleCollection ;
} # [ test ] fn bindgen_test_layout_nsCSSFontFaceRule ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsCSSFontFaceRule > ( ) , 248usize , concat ! ( "Size of: " , stringify ! ( nsCSSFontFaceRule ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsCSSFontFaceRule > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsCSSFontFaceRule ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsFontFaceRuleContainer { pub mRule : root :: RefPtr < root :: nsCSSFontFaceRule > , pub mSheetType : root :: mozilla :: SheetType , } # [ test ] fn bindgen_test_layout_nsFontFaceRuleContainer ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsFontFaceRuleContainer > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( nsFontFaceRuleContainer ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsFontFaceRuleContainer > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsFontFaceRuleContainer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFontFaceRuleContainer ) ) . mRule as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsFontFaceRuleContainer ) , "::" , stringify ! ( mRule ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsFontFaceRuleContainer ) ) . mSheetType as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsFontFaceRuleContainer ) , "::" , stringify ! ( mSheetType ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsHtml5StringParser { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIConsoleService { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIFragmentContentSink { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIStringBundle { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsIBidiKeyboard { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct EventNameMapping { pub mAtom : * mut root :: nsAtom , pub mType : i32 , pub mMessage : root :: mozilla :: EventMessage , pub mEventClassID : root :: mozilla :: EventClassID , pub mMaybeSpecialSVGorSMILEvent : bool , } # [ test ] fn bindgen_test_layout_EventNameMapping ( ) { assert_eq ! ( :: std :: mem :: size_of :: < EventNameMapping > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( EventNameMapping ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < EventNameMapping > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( EventNameMapping ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const EventNameMapping ) ) . mAtom as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( EventNameMapping ) , "::" , stringify ! ( mAtom ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const EventNameMapping ) ) . mType as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( EventNameMapping ) , "::" , stringify ! ( mType ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const EventNameMapping ) ) . mMessage as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( EventNameMapping ) , "::" , stringify ! ( mMessage ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const EventNameMapping ) ) . mEventClassID as * const _ as usize } , 14usize , concat ! ( "Alignment of field: " , stringify ! ( EventNameMapping ) , "::" , stringify ! ( mEventClassID ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const EventNameMapping ) ) . mMaybeSpecialSVGorSMILEvent as * const _ as usize } , 15usize , concat ! ( "Alignment of field: " , stringify ! ( EventNameMapping ) , "::" , stringify ! ( mMaybeSpecialSVGorSMILEvent ) ) ) ; } impl Clone for EventNameMapping { fn clone ( & self ) -> Self { * self } } extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils10sXPConnectE" ] 
 pub static mut  nsContentUtils_sXPConnect  :  * mut root :: nsIXPConnect ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils16sSecurityManagerE" ] 
 pub static mut  nsContentUtils_sSecurityManager  :  * mut root :: nsIScriptSecurityManager ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils16sSystemPrincipalE" ] 
 pub static mut  nsContentUtils_sSystemPrincipal  :  * mut root :: nsIPrincipal ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils21sNullSubjectPrincipalE" ] 
 pub static mut  nsContentUtils_sNullSubjectPrincipal  :  * mut root :: nsIPrincipal ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils17sNameSpaceManagerE" ] 
 pub static mut  nsContentUtils_sNameSpaceManager  :  * mut root :: nsNameSpaceManager ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils10sIOServiceE" ] 
 pub static mut  nsContentUtils_sIOService  :  * mut root :: nsIIOService ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils14sUUIDGeneratorE" ] 
 pub static mut  nsContentUtils_sUUIDGenerator  :  * mut root :: nsIUUIDGenerator ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils15sConsoleServiceE" ] 
 pub static mut  nsContentUtils_sConsoleService  :  * mut root :: nsIConsoleService ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils15sAtomEventTableE" ] 
 pub static mut  nsContentUtils_sAtomEventTable  :  * mut u8 ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils17sStringEventTableE" ] 
 pub static mut  nsContentUtils_sStringEventTable  :  * mut u8 ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils18sUserDefinedEventsE" ] 
 pub static mut  nsContentUtils_sUserDefinedEvents  :  * mut root :: nsTArray < root :: RefPtr < root :: nsAtom > > ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils20sStringBundleServiceE" ] 
 pub static mut  nsContentUtils_sStringBundleService  :  * mut root :: nsIStringBundleService ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils14sStringBundlesE" ] 
 pub static mut  nsContentUtils_sStringBundles  :  [ * mut root :: nsIStringBundle ; 14usize ] ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils21sContentPolicyServiceE" ] 
 pub static mut  nsContentUtils_sContentPolicyService  :  * mut root :: nsIContentPolicy ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils24sTriedToGetContentPolicyE" ] 
 pub static mut  nsContentUtils_sTriedToGetContentPolicy  :  bool ;
} # [ test ] fn __bindgen_test_layout_RefPtr_open0_LineBreaker_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: intl :: LineBreaker > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: intl :: LineBreaker > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: intl :: LineBreaker > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: intl :: LineBreaker > ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils12sLineBreakerE" ] 
 pub static mut  nsContentUtils_sLineBreaker  :  root :: RefPtr < root :: mozilla :: intl :: LineBreaker > ;
} # [ test ] fn __bindgen_test_layout_RefPtr_open0_WordBreaker_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: intl :: WordBreaker > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: intl :: WordBreaker > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: intl :: WordBreaker > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: intl :: WordBreaker > ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils12sWordBreakerE" ] 
 pub static mut  nsContentUtils_sWordBreaker  :  root :: RefPtr < root :: mozilla :: intl :: WordBreaker > ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils13sBidiKeyboardE" ] 
 pub static mut  nsContentUtils_sBidiKeyboard  :  * mut root :: nsIBidiKeyboard ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils12sInitializedE" ] 
 pub static mut  nsContentUtils_sInitialized  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils19sScriptBlockerCountE" ] 
 pub static mut  nsContentUtils_sScriptBlockerCount  :  u32 ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils28sDOMNodeRemovedSuppressCountE" ] 
 pub static mut  nsContentUtils_sDOMNodeRemovedSuppressCount  :  u32 ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils21sBlockedScriptRunnersE" ] 
 pub static mut  nsContentUtils_sBlockedScriptRunners  :  * mut u8 ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils27sRunnersCountAtFirstBlockerE" ] 
 pub static mut  nsContentUtils_sRunnersCountAtFirstBlocker  :  u32 ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils40sScriptBlockerCountWhereRunnersPreventedE" ] 
 pub static mut  nsContentUtils_sScriptBlockerCountWhereRunnersPrevented  :  u32 ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils18sSameOriginCheckerE" ] 
 pub static mut  nsContentUtils_sSameOriginChecker  :  * mut root :: nsIInterfaceRequestor ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils24sIsHandlingKeyBoardEventE" ] 
 pub static mut  nsContentUtils_sIsHandlingKeyBoardEvent  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils21sAllowXULXBL_for_fileE" ] 
 pub static mut  nsContentUtils_sAllowXULXBL_for_file  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils23sIsFullScreenApiEnabledE" ] 
 pub static mut  nsContentUtils_sIsFullScreenApiEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils33sIsUnprefixedFullscreenApiEnabledE" ] 
 pub static mut  nsContentUtils_sIsUnprefixedFullscreenApiEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils22sTrustedFullScreenOnlyE" ] 
 pub static mut  nsContentUtils_sTrustedFullScreenOnly  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils17sIsCutCopyAllowedE" ] 
 pub static mut  nsContentUtils_sIsCutCopyAllowed  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils21sHandlingInputTimeoutE" ] 
 pub static mut  nsContentUtils_sHandlingInputTimeout  :  u32 ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils27sIsPerformanceTimingEnabledE" ] 
 pub static mut  nsContentUtils_sIsPerformanceTimingEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils24sIsResourceTimingEnabledE" ] 
 pub static mut  nsContentUtils_sIsResourceTimingEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils37sIsPerformanceNavigationTimingEnabledE" ] 
 pub static mut  nsContentUtils_sIsPerformanceNavigationTimingEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils27sIsUserTimingLoggingEnabledE" ] 
 pub static mut  nsContentUtils_sIsUserTimingLoggingEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils25sIsFrameTimingPrefEnabledE" ] 
 pub static mut  nsContentUtils_sIsFrameTimingPrefEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils34sIsFormAutofillAutocompleteEnabledE" ] 
 pub static mut  nsContentUtils_sIsFormAutofillAutocompleteEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils23sIsWebComponentsEnabledE" ] 
 pub static mut  nsContentUtils_sIsWebComponentsEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils24sIsCustomElementsEnabledE" ] 
 pub static mut  nsContentUtils_sIsCustomElementsEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils16sDevToolsEnabledE" ] 
 pub static mut  nsContentUtils_sDevToolsEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils35sSendPerformanceTimingNotificationsE" ] 
 pub static mut  nsContentUtils_sSendPerformanceTimingNotifications  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils18sUseActivityCursorE" ] 
 pub static mut  nsContentUtils_sUseActivityCursor  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils25sAnimationsAPICoreEnabledE" ] 
 pub static mut  nsContentUtils_sAnimationsAPICoreEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils35sAnimationsAPIElementAnimateEnabledE" ] 
 pub static mut  nsContentUtils_sAnimationsAPIElementAnimateEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils34sAnimationsAPIPendingMemberEnabledE" ] 
 pub static mut  nsContentUtils_sAnimationsAPIPendingMemberEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils19sGetBoxQuadsEnabledE" ] 
 pub static mut  nsContentUtils_sGetBoxQuadsEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils30sSkipCursorMoveForSameValueSetE" ] 
 pub static mut  nsContentUtils_sSkipCursorMoveForSameValueSet  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils27sRequestIdleCallbackEnabledE" ] 
 pub static mut  nsContentUtils_sRequestIdleCallbackEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils21sLowerNetworkPriorityE" ] 
 pub static mut  nsContentUtils_sLowerNetworkPriority  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils15sTailingEnabledE" ] 
 pub static mut  nsContentUtils_sTailingEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils28sShowInputPlaceholderOnFocusE" ] 
 pub static mut  nsContentUtils_sShowInputPlaceholderOnFocus  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils17sAutoFocusEnabledE" ] 
 pub static mut  nsContentUtils_sAutoFocusEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils23sBypassCSSOMOriginCheckE" ] 
 pub static mut  nsContentUtils_sBypassCSSOMOriginCheck  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils21sIsScopedStyleEnabledE" ] 
 pub static mut  nsContentUtils_sIsScopedStyleEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils23sIsBytecodeCacheEnabledE" ] 
 pub static mut  nsContentUtils_sIsBytecodeCacheEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils22sBytecodeCacheStrategyE" ] 
 pub static mut  nsContentUtils_sBytecodeCacheStrategy  :  i32 ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils22sCookiesLifetimePolicyE" ] 
 pub static mut  nsContentUtils_sCookiesLifetimePolicy  :  u32 ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils16sCookiesBehaviorE" ] 
 pub static mut  nsContentUtils_sCookiesBehavior  :  u32 ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils20sShortcutsCustomizedE" ] 
 pub static mut  nsContentUtils_sShortcutsCustomized  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils21sPrivacyMaxInnerWidthE" ] 
 pub static mut  nsContentUtils_sPrivacyMaxInnerWidth  :  i32 ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils22sPrivacyMaxInnerHeightE" ] 
 pub static mut  nsContentUtils_sPrivacyMaxInnerHeight  :  i32 ;
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct nsContentUtils_UserInteractionObserver { _unused : [ u8 ; 0 ] } extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils24sUserInteractionObserverE" ] 
 pub static mut  nsContentUtils_sUserInteractionObserver  :  * mut root :: nsContentUtils_UserInteractionObserver ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils19sHTMLFragmentParserE" ] 
 pub static mut  nsContentUtils_sHTMLFragmentParser  :  * mut root :: nsHtml5StringParser ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils18sXMLFragmentParserE" ] 
 pub static mut  nsContentUtils_sXMLFragmentParser  :  * mut root :: nsIParser ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils16sXMLFragmentSinkE" ] 
 pub static mut  nsContentUtils_sXMLFragmentSink  :  * mut root :: nsIFragmentContentSink ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils22sFragmentParsingActiveE" ] 
 pub static mut  nsContentUtils_sFragmentParsingActive  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils10sShiftTextE" ] 
 pub static mut  nsContentUtils_sShiftText  :  * mut ::nsstring::nsStringRepr ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils12sControlTextE" ] 
 pub static mut  nsContentUtils_sControlText  :  * mut ::nsstring::nsStringRepr ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils9sMetaTextE" ] 
 pub static mut  nsContentUtils_sMetaText  :  * mut ::nsstring::nsStringRepr ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils7sOSTextE" ] 
 pub static mut  nsContentUtils_sOSText  :  * mut ::nsstring::nsStringRepr ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils8sAltTextE" ] 
 pub static mut  nsContentUtils_sAltText  :  * mut ::nsstring::nsStringRepr ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils18sModifierSeparatorE" ] 
 pub static mut  nsContentUtils_sModifierSeparator  :  * mut ::nsstring::nsStringRepr ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils19sJSBytecodeMimeTypeE" ] 
 pub static mut  nsContentUtils_sJSBytecodeMimeType  :  * mut root :: nsCString ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils21sDOMWindowDumpEnabledE" ] 
 pub static mut  nsContentUtils_sDOMWindowDumpEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils18sDoNotTrackEnabledE" ] 
 pub static mut  nsContentUtils_sDoNotTrackEnabled  :  bool ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils11sDOMDumpLogE" ] 
 pub static mut  nsContentUtils_sDOMDumpLog  :  root :: mozilla :: LazyLogModule ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils18sPopupControlStateE" ] 
 pub static mut  nsContentUtils_sPopupControlState  :  root :: PopupControlState ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils24sInnerOrOuterWindowCountE" ] 
 pub static mut  nsContentUtils_sInnerOrOuterWindowCount  :  i32 ;
} extern "C" {
 # [ link_name = "\u{1}_ZN14nsContentUtils32sInnerOrOuterWindowSerialCounterE" ] 
 pub static mut  nsContentUtils_sInnerOrOuterWindowSerialCounter  :  u32 ;
} 
 /// The Name Space Manager tracks the association between a NameSpace
    /// URI and the int32_t runtime id. Mappings between NameSpaces and
    /// NameSpace prefixes are managed by nsINameSpaces.
    ///
    /// All NameSpace URIs are stored in a global table so that IDs are
    /// consistent accross the app. NameSpace IDs are only consistent at runtime
    /// ie: they are not guaranteed to be consistent accross app sessions.
    ///
    /// The nsNameSpaceManager needs to have a live reference for as long as
    /// the NameSpace IDs are needed.
    /// 
 # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct nsNameSpaceManager { pub _base : root :: nsIObserver , pub mRefCnt : root :: nsAutoRefCnt , pub mMathMLDisabled : bool , pub mSVGDisabled : bool , pub mURIToIDTable : [ u64 ; 4usize ] , pub mDisabledURIToIDTable : [ u64 ; 4usize ] , pub mURIArray : root :: nsTArray < root :: RefPtr < root :: nsAtom > > , } pub type nsNameSpaceManager_HasThreadSafeRefCnt = root :: mozilla :: FalseType ; extern "C" {
 # [ link_name = "\u{1}_ZN18nsNameSpaceManager9sInstanceE" ] 
 pub static mut  nsNameSpaceManager_sInstance  :  root :: mozilla :: StaticRefPtr < root :: nsNameSpaceManager > ;
} # [ test ] fn bindgen_test_layout_nsNameSpaceManager ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsNameSpaceManager > ( ) , 96usize , concat ! ( "Size of: " , stringify ! ( nsNameSpaceManager ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsNameSpaceManager > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsNameSpaceManager ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsNameSpaceManager ) ) . mRefCnt as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsNameSpaceManager ) , "::" , stringify ! ( mRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsNameSpaceManager ) ) . mMathMLDisabled as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsNameSpaceManager ) , "::" , stringify ! ( mMathMLDisabled ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsNameSpaceManager ) ) . mSVGDisabled as * const _ as usize } , 17usize , concat ! ( "Alignment of field: " , stringify ! ( nsNameSpaceManager ) , "::" , stringify ! ( mSVGDisabled ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsNameSpaceManager ) ) . mURIToIDTable as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsNameSpaceManager ) , "::" , stringify ! ( mURIToIDTable ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsNameSpaceManager ) ) . mDisabledURIToIDTable as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( nsNameSpaceManager ) , "::" , stringify ! ( mDisabledURIToIDTable ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsNameSpaceManager ) ) . mURIArray as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( nsNameSpaceManager ) , "::" , stringify ! ( mURIArray ) ) ) ; } pub type nsMediaFeatureValueGetter = :: std :: option :: Option < unsafe extern "C" fn ( aPresContext : * mut root :: nsPresContext , aFeature : * const root :: nsMediaFeature , aResult : * mut root :: nsCSSValue ) > ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsMediaFeature { pub mName : * mut * mut root :: nsStaticAtom , pub mRangeType : root :: nsMediaFeature_RangeType , pub mValueType : root :: nsMediaFeature_ValueType , pub mReqFlags : u8 , pub mData : root :: nsMediaFeature__bindgen_ty_1 , pub mGetter : root :: nsMediaFeatureValueGetter , } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsMediaFeature_RangeType { eMinMaxAllowed = 0 , eMinMaxNotAllowed = 1 , } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum nsMediaFeature_ValueType { eLength = 0 , eInteger = 1 , eFloat = 2 , eBoolInteger = 3 , eIntRatio = 4 , eResolution = 5 , eEnumerated = 6 , eIdent = 7 , } pub const nsMediaFeature_RequirementFlags_eNoRequirements : root :: nsMediaFeature_RequirementFlags = 0 ; pub const nsMediaFeature_RequirementFlags_eHasWebkitPrefix : root :: nsMediaFeature_RequirementFlags = 1 ; pub const nsMediaFeature_RequirementFlags_eWebkitDevicePixelRatioPrefEnabled : root :: nsMediaFeature_RequirementFlags = 2 ; pub const nsMediaFeature_RequirementFlags_eUserAgentAndChromeOnly : root :: nsMediaFeature_RequirementFlags = 4 ; pub type nsMediaFeature_RequirementFlags = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsMediaFeature__bindgen_ty_1 { pub mInitializer_ : root :: __BindgenUnionField < * const :: std :: os :: raw :: c_void > , pub mKeywordTable : root :: __BindgenUnionField < * const root :: nsCSSProps_KTableEntry > , pub mMetric : root :: __BindgenUnionField < * const * const root :: nsAtom > , pub bindgen_union_field : u64 , } # [ test ] fn bindgen_test_layout_nsMediaFeature__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsMediaFeature__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( nsMediaFeature__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsMediaFeature__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsMediaFeature__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsMediaFeature__bindgen_ty_1 ) ) . mInitializer_ as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsMediaFeature__bindgen_ty_1 ) , "::" , stringify ! ( mInitializer_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsMediaFeature__bindgen_ty_1 ) ) . mKeywordTable as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsMediaFeature__bindgen_ty_1 ) , "::" , stringify ! ( mKeywordTable ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsMediaFeature__bindgen_ty_1 ) ) . mMetric as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsMediaFeature__bindgen_ty_1 ) , "::" , stringify ! ( mMetric ) ) ) ; } impl Clone for nsMediaFeature__bindgen_ty_1 { fn clone ( & self ) -> Self { * self } } # [ test ] fn bindgen_test_layout_nsMediaFeature ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsMediaFeature > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( nsMediaFeature ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsMediaFeature > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( nsMediaFeature ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsMediaFeature ) ) . mName as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( nsMediaFeature ) , "::" , stringify ! ( mName ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsMediaFeature ) ) . mRangeType as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( nsMediaFeature ) , "::" , stringify ! ( mRangeType ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsMediaFeature ) ) . mValueType as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( nsMediaFeature ) , "::" , stringify ! ( mValueType ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsMediaFeature ) ) . mReqFlags as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( nsMediaFeature ) , "::" , stringify ! ( mReqFlags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsMediaFeature ) ) . mData as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( nsMediaFeature ) , "::" , stringify ! ( mData ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const nsMediaFeature ) ) . mGetter as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( nsMediaFeature ) , "::" , stringify ! ( mGetter ) ) ) ; } impl Clone for nsMediaFeature { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct nsMediaFeatures { pub _address : u8 , } extern "C" {
 # [ link_name = "\u{1}_ZN15nsMediaFeatures8featuresE" ] 
 pub static mut  nsMediaFeatures_features  :  [ root :: nsMediaFeature ; 0usize ] ;
} # [ test ] fn bindgen_test_layout_nsMediaFeatures ( ) { assert_eq ! ( :: std :: mem :: size_of :: < nsMediaFeatures > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( nsMediaFeatures ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < nsMediaFeatures > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( nsMediaFeatures ) ) ) ; } impl Clone for nsMediaFeatures { fn clone ( & self ) -> Self { * self } } # [ test ] fn __bindgen_test_layout_nsTSubstring_open0_char16_t_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTSubstring < u16 > > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTSubstring < u16 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTSubstring < u16 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTSubstring < u16 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTString_open0_char16_t_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ::nsstring::nsStringRepr > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( ::nsstring::nsStringRepr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ::nsstring::nsStringRepr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( ::nsstring::nsStringRepr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTSubstring_open0_char_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTSubstring < :: std :: os :: raw :: c_char > > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTSubstring < :: std :: os :: raw :: c_char > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTSubstring < :: std :: os :: raw :: c_char > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTSubstring < :: std :: os :: raw :: c_char > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTString_open0_char_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTString < :: std :: os :: raw :: c_char > > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTString < :: std :: os :: raw :: c_char > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTString < :: std :: os :: raw :: c_char > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTString < :: std :: os :: raw :: c_char > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsISupports_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_CSSVariableValues_Variable_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: mozilla :: CSSVariableValues_Variable > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: mozilla :: CSSVariableValues_Variable > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: mozilla :: CSSVariableValues_Variable > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: mozilla :: CSSVariableValues_Variable > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_FontFamilyName_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: mozilla :: FontFamilyName > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: mozilla :: FontFamilyName > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: mozilla :: FontFamilyName > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: mozilla :: FontFamilyName > ) ) ) ; } # [ test ] fn __bindgen_test_layout_NotNull_open0_RefPtr_open1_SharedFontList_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: NotNull < root :: RefPtr < root :: mozilla :: SharedFontList > > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: NotNull < root :: RefPtr < root :: mozilla :: SharedFontList > > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: NotNull < root :: RefPtr < root :: mozilla :: SharedFontList > > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: NotNull < root :: RefPtr < root :: mozilla :: SharedFontList > > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_SharedFontList_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: SharedFontList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: SharedFontList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: SharedFontList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: SharedFontList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_uint32_t_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < u32 > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < u32 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < u32 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < u32 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_gfxFontFeatureValueSet_ValueList_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: gfxFontFeatureValueSet_ValueList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: gfxFontFeatureValueSet_ValueList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: gfxFontFeatureValueSet_ValueList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: gfxFontFeatureValueSet_ValueList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_uint32_t_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < u32 > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < u32 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < u32 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < u32 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_gfxAlternateValue_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: gfxAlternateValue > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: gfxAlternateValue > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: gfxAlternateValue > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: gfxAlternateValue > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_gfxFontFeatureValueSet_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: gfxFontFeatureValueSet > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: gfxFontFeatureValueSet > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: gfxFontFeatureValueSet > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: gfxFontFeatureValueSet > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_gfxFontFeature_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: gfxFontFeature > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: gfxFontFeature > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: gfxFontFeature > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: gfxFontFeature > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_gfxFontVariation_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: gfxFontVariation > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: gfxFontVariation > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: gfxFontVariation > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: gfxFontVariation > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_nsAtom_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: RefPtr < root :: nsAtom > > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: nsAtom > > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: RefPtr < root :: nsAtom > > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: nsAtom > > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsAtom_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; } # [ test ] fn __bindgen_test_layout_BaseTimeDuration_open0_TimeDurationValueCalculator_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: BaseTimeDuration > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: BaseTimeDuration ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: BaseTimeDuration > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: BaseTimeDuration ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_JSErrorNotes_Note_DeletePolicy_open1_JSErrorNotes_Note_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_Note_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: JS :: DeletePolicy > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: JS :: DeletePolicy ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: JS :: DeletePolicy > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: JS :: DeletePolicy ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_JSErrorNotes_DeletePolicy_open1_JSErrorNotes_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: JSErrorNotes > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: JSErrorNotes > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: JSErrorNotes > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: JSErrorNotes > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: JS :: DeletePolicy > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: JS :: DeletePolicy ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: JS :: DeletePolicy > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: JS :: DeletePolicy ) ) ) ; } # [ test ] fn __bindgen_test_layout_iterator_open0_input_iterator_tag_UniquePtr_open1_JSErrorNotes_Note_DeletePolicy_open2_JSErrorNotes_Note_close2_close1_long_ptr_UniquePtr_ref_UniquePtr_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: std :: iterator > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: std :: iterator ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: std :: iterator > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: std :: iterator ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_JSErrorNotes_Note_DeletePolicy_open1_JSErrorNotes_Note_close1_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_Note_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: JS :: DeletePolicy > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: JS :: DeletePolicy ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: JS :: DeletePolicy > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: JS :: DeletePolicy ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_JSErrorNotes_Note_DeletePolicy_open1_JSErrorNotes_Note_close1_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_Note_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: JS :: DeletePolicy > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: JS :: DeletePolicy ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: JS :: DeletePolicy > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: JS :: DeletePolicy ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_JSErrorNotes_Note_DeletePolicy_open1_JSErrorNotes_Note_close1_close0_instantiation_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_Note_close0_instantiation_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: JS :: DeletePolicy > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: JS :: DeletePolicy ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: JS :: DeletePolicy > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: JS :: DeletePolicy ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_JSErrorNotes_Note_DeletePolicy_open1_JSErrorNotes_Note_close1_close0_instantiation_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_Note_close0_instantiation_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: JS :: DeletePolicy > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: JS :: DeletePolicy ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: JS :: DeletePolicy > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: JS :: DeletePolicy ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_JSErrorNotes_Note_DeletePolicy_open1_JSErrorNotes_Note_close1_close0_instantiation_5 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: JSErrorNotes_Note > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_Note_close0_instantiation_5 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: JS :: DeletePolicy > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: JS :: DeletePolicy ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: JS :: DeletePolicy > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: JS :: DeletePolicy ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_JSErrorNotes_DeletePolicy_open1_JSErrorNotes_close1_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: JSErrorNotes > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: JSErrorNotes > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: JSErrorNotes > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: JSErrorNotes > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: JS :: DeletePolicy > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: JS :: DeletePolicy ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: JS :: DeletePolicy > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: JS :: DeletePolicy ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_StyleSheet_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: StyleSheet > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: StyleSheet > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: StyleSheet > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: StyleSheet > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_MediaList_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: dom :: MediaList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: MediaList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: dom :: MediaList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: MediaList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_StyleSheet_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: StyleSheet > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: StyleSheet > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: StyleSheet > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: StyleSheet > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_StyleSetHandle_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: mozilla :: StyleSetHandle > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: mozilla :: StyleSetHandle > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: mozilla :: StyleSetHandle > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: mozilla :: StyleSetHandle > ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_ProfilerBacktrace_ProfilerBacktraceDestructor_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: ProfilerBacktrace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: ProfilerBacktrace > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: ProfilerBacktrace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: ProfilerBacktrace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsNodeInfoManager_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsNodeInfoManager > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsNodeInfoManager > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsNodeInfoManager > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsNodeInfoManager > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIPrincipal_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIPrincipal_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsBindingManager_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsBindingManager > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsBindingManager > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsBindingManager > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsBindingManager > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsAttrChildContentList_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsAttrChildContentList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAttrChildContentList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsAttrChildContentList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAttrChildContentList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_LinkedList_open1_nsRange_close1_DefaultDelete_open1_LinkedList_open2_nsRange_close2_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: mozilla :: LinkedList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: mozilla :: LinkedList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: mozilla :: LinkedList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: mozilla :: LinkedList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_LinkedList_open1_nsRange_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_LinkedList_open1_nsRange_close1_DefaultDelete_open1_LinkedList_open2_nsRange_close2_close1_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: mozilla :: LinkedList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: mozilla :: LinkedList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: mozilla :: LinkedList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: mozilla :: LinkedList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_LinkedList_open1_nsRange_close1_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_NodeInfo_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: dom :: NodeInfo > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: NodeInfo > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: dom :: NodeInfo > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: NodeInfo > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIContent_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_ShadowRoot_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: dom :: ShadowRoot > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: ShadowRoot > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: dom :: ShadowRoot > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: ShadowRoot > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_HTMLSlotElement_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: dom :: HTMLSlotElement > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: HTMLSlotElement > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: dom :: HTMLSlotElement > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: HTMLSlotElement > ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsIContent_nsExtendedContentSlots_DefaultDelete_open1_nsIContent_nsExtendedContentSlots_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsIContent_nsExtendedContentSlots > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsIContent_nsExtendedContentSlots > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsIContent_nsExtendedContentSlots > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsIContent_nsExtendedContentSlots > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsIContent_nsExtendedContentSlots_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIWeakReference_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_ptr_void_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < * mut :: std :: os :: raw :: c_void > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < * mut :: std :: os :: raw :: c_void > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < * mut :: std :: os :: raw :: c_void > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < * mut :: std :: os :: raw :: c_void > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsPtrHashKey_open0_void_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsPtrHashKey < :: std :: os :: raw :: c_void > > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsPtrHashKey < :: std :: os :: raw :: c_void > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsPtrHashKey < :: std :: os :: raw :: c_void > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsPtrHashKey < :: std :: os :: raw :: c_void > ) ) ) ; } # [ test ] fn __bindgen_test_layout_StaticRefPtr_open0_nsIContent_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: StaticRefPtr < root :: nsIContent > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: StaticRefPtr < root :: nsIContent > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: StaticRefPtr < root :: nsIContent > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: StaticRefPtr < root :: nsIContent > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIDocument_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsPresContext_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsPresContext > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsPresContext > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsPresContext > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsPresContext > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsFrameSelection_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsFrameSelection > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsFrameSelection > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsFrameSelection > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsFrameSelection > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsITimer_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsPtrHashKey_open0_WeakFrame_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsPtrHashKey < root :: WeakFrame > > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsPtrHashKey < root :: WeakFrame > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsPtrHashKey < root :: WeakFrame > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsPtrHashKey < root :: WeakFrame > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsRefPtrHashKey_open0_nsAtom_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsRefPtrHashKey < root :: nsAtom > > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsRefPtrHashKey < root :: nsAtom > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsRefPtrHashKey < root :: nsAtom > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsRefPtrHashKey < root :: nsAtom > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsAtom_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsCString_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: nsCString > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: nsCString > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: nsCString > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: nsCString > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_EventTarget_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIDocument_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_EventTarget_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_Performance_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: dom :: Performance > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: Performance > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: dom :: Performance > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: Performance > ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_TimeoutManager_DefaultDelete_open1_TimeoutManager_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: mozilla :: dom :: TimeoutManager > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: mozilla :: dom :: TimeoutManager > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: mozilla :: dom :: TimeoutManager > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: mozilla :: dom :: TimeoutManager > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_TimeoutManager_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsPIDOMWindowOuter_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIContent_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_ptr_AudioContext_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < * mut root :: mozilla :: dom :: AudioContext > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < * mut root :: mozilla :: dom :: AudioContext > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < * mut root :: mozilla :: dom :: AudioContext > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < * mut root :: mozilla :: dom :: AudioContext > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_TabGroup_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: dom :: TabGroup > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: TabGroup > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: dom :: TabGroup > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: TabGroup > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsPIDOMWindowInner_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_EventTarget_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIDocument_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_EventTarget_close0_instantiation_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_Element_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIDocShell_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_TabGroup_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: dom :: TabGroup > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: TabGroup > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: dom :: TabGroup > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: TabGroup > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsPIDOMWindowOuter_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsAtom_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsBaseContentList_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsBaseContentList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsBaseContentList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsBaseContentList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsBaseContentList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsAutoPtr_open0_nsTHashtable_open1_nsIdentifierMapEntry_ChangeCallbackEntry_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < u64 > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( u64 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < u64 > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( u64 ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsIdentifierMapEntry_Element_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsIdentifierMapEntry_Element > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsIdentifierMapEntry_Element > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsIdentifierMapEntry_Element > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsIdentifierMapEntry_Element > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_StyleSheet_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: RefPtr < root :: mozilla :: StyleSheet > > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: mozilla :: StyleSheet > > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: RefPtr < root :: mozilla :: StyleSheet > > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: mozilla :: StyleSheet > > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_StyleSheet_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: StyleSheet > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: StyleSheet > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: StyleSheet > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: StyleSheet > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_StyleSheetList_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: dom :: StyleSheetList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: StyleSheetList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: dom :: StyleSheetList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: StyleSheetList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_RawServoAnimationValue_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: RawServoAnimationValue > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: RawServoAnimationValue > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: RawServoAnimationValue > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: RawServoAnimationValue > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_PropertyValuePair_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: mozilla :: PropertyValuePair > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: mozilla :: PropertyValuePair > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: mozilla :: PropertyValuePair > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: mozilla :: PropertyValuePair > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsStyleAutoArray_open0_StyleAnimation_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsStyleAutoArray < root :: mozilla :: StyleAnimation > > ( ) , 56usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsStyleAutoArray < root :: mozilla :: StyleAnimation > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsStyleAutoArray < root :: mozilla :: StyleAnimation > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsStyleAutoArray < root :: mozilla :: StyleAnimation > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIDocument_close0_instantiation_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_RawServoSelectorList_DefaultDelete_open1_RawServoSelectorList_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: RawServoSelectorList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: RawServoSelectorList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: RawServoSelectorList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: RawServoSelectorList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_RawServoSelectorList_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsCSSSelectorList_DefaultDelete_open1_nsCSSSelectorList_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsCSSSelectorList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsCSSSelectorList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsCSSSelectorList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsCSSSelectorList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsCSSSelectorList_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsCSSSelectorList_DefaultDelete_open1_nsCSSSelectorList_close1_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsCSSSelectorList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsCSSSelectorList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsCSSSelectorList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsCSSSelectorList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsCSSSelectorList_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_RawServoSelectorList_DefaultDelete_open1_RawServoSelectorList_close1_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: RawServoSelectorList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: RawServoSelectorList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: RawServoSelectorList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: RawServoSelectorList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_RawServoSelectorList_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIObserver_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsIDocument_SelectorCache_DefaultDelete_open1_nsIDocument_SelectorCache_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsIDocument_SelectorCache > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsIDocument_SelectorCache > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsIDocument_SelectorCache > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsIDocument_SelectorCache > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsIDocument_SelectorCache_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsIDocument_SelectorCache_DefaultDelete_open1_nsIDocument_SelectorCache_close1_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsIDocument_SelectorCache > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsIDocument_SelectorCache > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsIDocument_SelectorCache > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsIDocument_SelectorCache > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsIDocument_SelectorCache_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_5 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_6 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_7 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_8 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_9 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_URLExtraData_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: URLExtraData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: URLExtraData > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: URLExtraData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: URLExtraData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_NotNull_open0_ptr_const_nsIDocument__Encoding_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: NotNull < * const root :: nsIDocument_Encoding > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: NotNull < * const root :: nsIDocument_Encoding > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: NotNull < * const root :: nsIDocument_Encoding > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: NotNull < * const root :: nsIDocument_Encoding > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_Loader_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: css :: Loader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: css :: Loader > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: css :: Loader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: css :: Loader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_ImageLoader_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: css :: ImageLoader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: css :: ImageLoader > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: css :: ImageLoader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: css :: ImageLoader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsHTMLStyleSheet_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsHTMLStyleSheet > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsHTMLStyleSheet > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsHTMLStyleSheet > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsHTMLStyleSheet > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsHTMLCSSStyleSheet_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsHTMLCSSStyleSheet > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsHTMLCSSStyleSheet > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsHTMLCSSStyleSheet > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsHTMLCSSStyleSheet > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_ImageTracker_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: dom :: ImageTracker > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: ImageTracker > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: dom :: ImageTracker > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: ImageTracker > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsAutoPtr_open0_nsTHashtable_open1_nsPtrHashKey_open2_nsISupports_close2_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < u64 > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( u64 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < u64 > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( u64 ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_Link_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsSMILAnimationController_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsSMILAnimationController > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsSMILAnimationController > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsSMILAnimationController > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsSMILAnimationController > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsAutoPtr_open1_nsPropertyTable_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: nsAutoPtr < root :: nsPropertyTable > > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: nsAutoPtr < root :: nsPropertyTable > > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: nsAutoPtr < root :: nsPropertyTable > > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: nsAutoPtr < root :: nsPropertyTable > > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIHTMLCollection_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_FontFaceSet_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: dom :: FontFaceSet > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: FontFaceSet > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: dom :: FontFaceSet > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: FontFaceSet > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIScriptGlobalObject_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIDocument_close0_instantiation_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIChannel_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsISupports_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIChannel_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMArray_open0_nsINode_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMArray > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMArray ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMArray > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMArray ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIDocument_close0_instantiation_5 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsWeakPtr_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: nsWeakPtr > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: nsWeakPtr > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: nsWeakPtr > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: nsWeakPtr > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIDocumentEncoder_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsIDocument_FrameRequest_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: nsIDocument_FrameRequest > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: nsIDocument_FrameRequest > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: nsIDocument_FrameRequest > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: nsIDocument_FrameRequest > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIStructuredCloneContainer_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIVariant_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_XPathEvaluator_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: dom :: XPathEvaluator > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: XPathEvaluator > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: dom :: XPathEvaluator > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: XPathEvaluator > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_AnonymousContent_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: RefPtr < root :: mozilla :: dom :: AnonymousContent > > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: mozilla :: dom :: AnonymousContent > > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: RefPtr < root :: mozilla :: dom :: AnonymousContent > > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: mozilla :: dom :: AnonymousContent > > ) ) ) ; } # [ test ] fn __bindgen_test_layout_LinkedList_open0_MediaQueryList_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: LinkedList > ( ) , 24usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: LinkedList ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: LinkedList > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: LinkedList ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_DocGroup_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: dom :: DocGroup > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: DocGroup > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: dom :: DocGroup > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: DocGroup > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsCOMPtr_open1_nsIRunnable_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: nsCOMPtr > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: nsCOMPtr > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: nsCOMPtr > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: nsCOMPtr > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIRunnable_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsCOMPtr_open1_nsIPrincipal_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: nsCOMPtr > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: nsCOMPtr > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: nsCOMPtr > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: nsCOMPtr > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIPrincipal_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_uint64_t_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < u64 > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < u64 > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < u64 > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < u64 > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsINode_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsAtom_close0_instantiation_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsAutoPtr_open0_LangGroupFontPrefs_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsAutoPtr < root :: mozilla :: LangGroupFontPrefs > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsAutoPtr < root :: mozilla :: LangGroupFontPrefs > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsAutoPtr < root :: mozilla :: LangGroupFontPrefs > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsAutoPtr < root :: mozilla :: LangGroupFontPrefs > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIDocument_close0_instantiation_6 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsDeviceContext_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsDeviceContext > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsDeviceContext > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsDeviceContext > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsDeviceContext > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_EventStateManager_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: EventStateManager > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: EventStateManager > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: EventStateManager > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: EventStateManager > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsRefreshDriver_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsRefreshDriver > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsRefreshDriver > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsRefreshDriver > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsRefreshDriver > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_EffectCompositor_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: EffectCompositor > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: EffectCompositor > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: EffectCompositor > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: EffectCompositor > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsTransitionManager_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsTransitionManager > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsTransitionManager > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsTransitionManager > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsTransitionManager > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsAnimationManager_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsAnimationManager > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAnimationManager > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsAnimationManager > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAnimationManager > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_RestyleManager_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: RestyleManager > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: RestyleManager > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: RestyleManager > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: RestyleManager > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_CounterStyleManager_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: CounterStyleManager > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: CounterStyleManager > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: CounterStyleManager > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: CounterStyleManager > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsAtom_close0_instantiation_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_gfxFontFeatureValueSet_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: gfxFontFeatureValueSet > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: gfxFontFeatureValueSet > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: gfxFontFeatureValueSet > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: gfxFontFeatureValueSet > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsAtom_close0_instantiation_5 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsITheme_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIPrintSettings_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsITimer_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsBidi_DefaultDelete_open1_nsBidi_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsBidi > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsBidi > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsBidi > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsBidi > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsBidi_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsRect_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: nsRect > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: nsRect > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: nsRect > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: nsRect > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsAutoPtr_open0_gfxTextPerfMetrics_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsAutoPtr < root :: gfxTextPerfMetrics > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsAutoPtr < root :: gfxTextPerfMetrics > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsAutoPtr < root :: gfxTextPerfMetrics > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsAutoPtr < root :: gfxTextPerfMetrics > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsAutoPtr_open0_gfxMissingFontRecorder_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsAutoPtr < root :: gfxMissingFontRecorder > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsAutoPtr < root :: gfxMissingFontRecorder > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsAutoPtr < root :: gfxMissingFontRecorder > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsAutoPtr < root :: gfxMissingFontRecorder > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsRefPtrHashKey_open0_nsAtom_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsRefPtrHashKey < root :: nsAtom > > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsRefPtrHashKey < root :: nsAtom > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsRefPtrHashKey < root :: nsAtom > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsRefPtrHashKey < root :: nsAtom > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_URLParams_Param_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: mozilla :: dom :: URLParams_Param > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: mozilla :: dom :: URLParams_Param > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: mozilla :: dom :: URLParams_Param > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: mozilla :: dom :: URLParams_Param > ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_URLParams_DefaultDelete_open1_URLParams_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: mozilla :: dom :: URLParams > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: mozilla :: dom :: URLParams > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: mozilla :: dom :: URLParams > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: mozilla :: dom :: URLParams > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_URLParams_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_10 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_11 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIPrincipal_close0_instantiation_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_const_char_FreePolicy_open1_const_char_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < :: std :: os :: raw :: c_char > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < :: std :: os :: raw :: c_char > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < :: std :: os :: raw :: c_char > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < :: std :: os :: raw :: c_char > ) ) ) ; } # [ test ] fn __bindgen_test_layout_FreePolicy_open0_const_char_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: detail :: FreePolicy > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: detail :: FreePolicy ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: detail :: FreePolicy > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: detail :: FreePolicy ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIEventTarget_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsMainThreadPtrHandle_open0_nsIURI_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsMainThreadPtrHandle < root :: nsIURI > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsMainThreadPtrHandle < root :: nsIURI > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsMainThreadPtrHandle < root :: nsIURI > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsMainThreadPtrHandle < root :: nsIURI > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_URLExtraData_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: URLExtraData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: URLExtraData > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: URLExtraData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: URLExtraData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsPtrHashKey_open0_nsIDocument_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsPtrHashKey < root :: nsIDocument > > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsPtrHashKey < root :: nsIDocument > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsPtrHashKey < root :: nsIDocument > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsPtrHashKey < root :: nsIDocument > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_GridNamedArea_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: mozilla :: css :: GridNamedArea > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: mozilla :: css :: GridNamedArea > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: mozilla :: css :: GridNamedArea > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: mozilla :: css :: GridNamedArea > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsString_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < ::nsstring::nsStringRepr > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < ::nsstring::nsStringRepr > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < ::nsstring::nsStringRepr > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < ::nsstring::nsStringRepr > ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsCSSValueList_DefaultDelete_open1_nsCSSValueList_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsCSSValueList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsCSSValueList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsCSSValueList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsCSSValueList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsCSSValueList_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsCSSValuePairList_DefaultDelete_open1_nsCSSValuePairList_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsCSSValuePairList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsCSSValuePairList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsCSSValuePairList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsCSSValuePairList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsCSSValuePairList_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsCSSValueGradientStop_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: nsCSSValueGradientStop > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: nsCSSValueGradientStop > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: nsCSSValueGradientStop > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: nsCSSValueGradientStop > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_12 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_13 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIPrincipal_close0_instantiation_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_imgRequestProxy_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: imgRequestProxy > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: imgRequestProxy > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: imgRequestProxy > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: imgRequestProxy > ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_ProxyBehaviour_DefaultDelete_open1_ProxyBehaviour_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: ProxyBehaviour > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: ProxyBehaviour > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: ProxyBehaviour > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: ProxyBehaviour > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_ProxyBehaviour_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_imgRequestProxy_ImageURL_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: imgRequestProxy_ImageURL > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: imgRequestProxy_ImageURL > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: imgRequestProxy_ImageURL > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: imgRequestProxy_ImageURL > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsILoadGroup_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_TabGroup_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: dom :: TabGroup > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: TabGroup > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: dom :: TabGroup > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: TabGroup > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIEventTarget_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsString_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < ::nsstring::nsStringRepr > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < ::nsstring::nsStringRepr > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < ::nsstring::nsStringRepr > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < ::nsstring::nsStringRepr > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsRefPtrHashKey_open0_nsAtom_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsRefPtrHashKey < root :: nsAtom > > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsRefPtrHashKey < root :: nsAtom > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsRefPtrHashKey < root :: nsAtom > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsRefPtrHashKey < root :: nsAtom > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_ptr_CounterStyle_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < * mut root :: mozilla :: CounterStyle > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < * mut root :: mozilla :: CounterStyle > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < * mut root :: mozilla :: CounterStyle > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < * mut root :: mozilla :: CounterStyle > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsAtom_close0_instantiation_6 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsStyleGradientStop_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: nsStyleGradientStop > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: nsStyleGradientStop > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: nsStyleGradientStop > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: nsStyleGradientStop > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_imgRequestProxy_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: imgRequestProxy > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: imgRequestProxy > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: imgRequestProxy > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: imgRequestProxy > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_ImageValue_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: css :: ImageValue > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: css :: ImageValue > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: css :: ImageValue > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: css :: ImageValue > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_ImageTracker_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: dom :: ImageTracker > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: ImageTracker > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: dom :: ImageTracker > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: ImageTracker > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_DocGroup_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: dom :: DocGroup > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: DocGroup > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: dom :: DocGroup > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: DocGroup > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMArray_open0_imgIContainer_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMArray > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMArray ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMArray > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMArray ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsStyleSides_DefaultDelete_open1_nsStyleSides_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsStyleSides > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsStyleSides > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsStyleSides > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsStyleSides > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsStyleSides_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsStyleSides_DefaultDelete_open1_nsStyleSides_close1_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsStyleSides > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsStyleSides > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsStyleSides > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsStyleSides > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsStyleSides_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_CachedBorderImageData_DefaultDelete_open1_CachedBorderImageData_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: CachedBorderImageData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: CachedBorderImageData > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: CachedBorderImageData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: CachedBorderImageData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_CachedBorderImageData_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsStyleSides_DefaultDelete_open1_nsStyleSides_close1_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsStyleSides > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsStyleSides > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsStyleSides > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsStyleSides > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsStyleSides_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsStyleAutoArray_open0_nsStyleImageLayers_Layer_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsStyleAutoArray < root :: nsStyleImageLayers_Layer > > ( ) , 104usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsStyleAutoArray < root :: nsStyleImageLayers_Layer > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsStyleAutoArray < root :: nsStyleImageLayers_Layer > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsStyleAutoArray < root :: nsStyleImageLayers_Layer > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nscolor_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: nscolor > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: nscolor > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: nscolor > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: nscolor > ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsBorderColors_DefaultDelete_open1_nsBorderColors_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsBorderColors > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsBorderColors > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsBorderColors > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsBorderColors > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsBorderColors_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_pair_open1_nsString_nsString_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: std :: pair < ::nsstring::nsStringRepr , ::nsstring::nsStringRepr > > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: std :: pair < ::nsstring::nsStringRepr , ::nsstring::nsStringRepr > > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: std :: pair < ::nsstring::nsStringRepr , ::nsstring::nsStringRepr > > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: std :: pair < ::nsstring::nsStringRepr , ::nsstring::nsStringRepr > > ) ) ) ; } # [ test ] fn __bindgen_test_layout_pair_open0_nsString_nsString_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: std :: pair < ::nsstring::nsStringRepr , ::nsstring::nsStringRepr > > ( ) , 32usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: std :: pair < ::nsstring::nsStringRepr , ::nsstring::nsStringRepr > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: std :: pair < ::nsstring::nsStringRepr , ::nsstring::nsStringRepr > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: std :: pair < ::nsstring::nsStringRepr , ::nsstring::nsStringRepr > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsStyleImageRequest_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsStyleImageRequest > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsStyleImageRequest > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsStyleImageRequest > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsStyleImageRequest > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsStyleQuoteValues_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsStyleQuoteValues > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsStyleQuoteValues > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsStyleQuoteValues > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsStyleQuoteValues > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsTArray_open1_nsString_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: nsTArray < ::nsstring::nsStringRepr > > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: nsTArray < ::nsstring::nsStringRepr > > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: nsTArray < ::nsstring::nsStringRepr > > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: nsTArray < ::nsstring::nsStringRepr > > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsString_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < ::nsstring::nsStringRepr > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < ::nsstring::nsStringRepr > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < ::nsstring::nsStringRepr > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < ::nsstring::nsStringRepr > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsStyleCoord_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: nsStyleCoord > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: nsStyleCoord > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: nsStyleCoord > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: nsStyleCoord > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsStyleCoord_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: nsStyleCoord > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: nsStyleCoord > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: nsStyleCoord > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: nsStyleCoord > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsString_close0_instantiation_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < ::nsstring::nsStringRepr > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < ::nsstring::nsStringRepr > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < ::nsstring::nsStringRepr > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < ::nsstring::nsStringRepr > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsString_close0_instantiation_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < ::nsstring::nsStringRepr > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < ::nsstring::nsStringRepr > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < ::nsstring::nsStringRepr > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < ::nsstring::nsStringRepr > ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsStyleGridTemplate_DefaultDelete_open1_nsStyleGridTemplate_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsStyleGridTemplate > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsStyleGridTemplate > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsStyleGridTemplate > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsStyleGridTemplate > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsStyleGridTemplate_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsStyleGridTemplate_DefaultDelete_open1_nsStyleGridTemplate_close1_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsStyleGridTemplate > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsStyleGridTemplate > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsStyleGridTemplate > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsStyleGridTemplate > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsStyleGridTemplate_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_GridTemplateAreasValue_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: css :: GridTemplateAreasValue > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: css :: GridTemplateAreasValue > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: css :: GridTemplateAreasValue > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: css :: GridTemplateAreasValue > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsCSSShadowArray_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsCSSShadowArray > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsCSSShadowArray > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsCSSShadowArray > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsCSSShadowArray > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsAtom_close0_instantiation_7 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsAtom_close0_instantiation_8 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsStyleCoord_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: nsStyleCoord > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: nsStyleCoord > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: nsStyleCoord > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: nsStyleCoord > ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsStyleImage_DefaultDelete_open1_nsStyleImage_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsStyleImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsStyleImage > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsStyleImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsStyleImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsStyleImage_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsStyleImage_DefaultDelete_open1_nsStyleImage_close1_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsStyleImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsStyleImage > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsStyleImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsStyleImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsStyleImage_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_StyleBasicShape_DefaultDelete_open1_StyleBasicShape_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: mozilla :: StyleBasicShape > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: mozilla :: StyleBasicShape > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: mozilla :: StyleBasicShape > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: mozilla :: StyleBasicShape > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_StyleBasicShape_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_StyleBasicShape_DefaultDelete_open1_StyleBasicShape_close1_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: mozilla :: StyleBasicShape > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: mozilla :: StyleBasicShape > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: mozilla :: StyleBasicShape > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: mozilla :: StyleBasicShape > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_StyleBasicShape_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_StyleBasicShape_DefaultDelete_open1_StyleBasicShape_close1_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: mozilla :: StyleBasicShape > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: mozilla :: StyleBasicShape > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: mozilla :: StyleBasicShape > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: mozilla :: StyleBasicShape > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_StyleBasicShape_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsStyleImage_DefaultDelete_open1_nsStyleImage_close1_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsStyleImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsStyleImage > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsStyleImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsStyleImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsStyleImage_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_URLValue_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: css :: URLValue > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: css :: URLValue > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: css :: URLValue > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: css :: URLValue > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_nsAtom_close1_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: RefPtr < root :: nsAtom > > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: nsAtom > > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: RefPtr < root :: nsAtom > > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: nsAtom > > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsAtom_close0_instantiation_9 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_Position_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: mozilla :: Position > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: mozilla :: Position > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: mozilla :: Position > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: mozilla :: Position > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsCSSValueSharedList_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsCSSValueSharedList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsCSSValueSharedList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsCSSValueSharedList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsCSSValueSharedList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsStyleAutoArray_open0_StyleTransition_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsStyleAutoArray < root :: mozilla :: StyleTransition > > ( ) , 48usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsStyleAutoArray < root :: mozilla :: StyleTransition > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsStyleAutoArray < root :: mozilla :: StyleTransition > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsStyleAutoArray < root :: mozilla :: StyleTransition > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsStyleAutoArray_open0_StyleAnimation_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsStyleAutoArray < root :: mozilla :: StyleAnimation > > ( ) , 56usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsStyleAutoArray < root :: mozilla :: StyleAnimation > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsStyleAutoArray < root :: mozilla :: StyleAnimation > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsStyleAutoArray < root :: mozilla :: StyleAnimation > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsStyleContentData_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: nsStyleContentData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: nsStyleContentData > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: nsStyleContentData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: nsStyleContentData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsStyleCounterData_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: nsStyleCounterData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: nsStyleCounterData > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: nsStyleCounterData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: nsStyleCounterData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsStyleCounterData_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: nsStyleCounterData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: nsStyleCounterData > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: nsStyleCounterData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: nsStyleCounterData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsCSSValueSharedList_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsCSSValueSharedList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsCSSValueSharedList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsCSSValueSharedList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsCSSValueSharedList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsStyleImageRequest_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsStyleImageRequest > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsStyleImageRequest > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsStyleImageRequest > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsStyleImageRequest > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsCursorImage_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: nsCursorImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: nsCursorImage > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: nsCursorImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: nsCursorImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_URLValue_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: css :: URLValue > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: css :: URLValue > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: css :: URLValue > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: css :: URLValue > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_URLValue_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: css :: URLValue > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: css :: URLValue > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: css :: URLValue > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: css :: URLValue > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_URLValue_close0_instantiation_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: css :: URLValue > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: css :: URLValue > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: css :: URLValue > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: css :: URLValue > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsStyleCoord_close0_instantiation_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: nsStyleCoord > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: nsStyleCoord > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: nsStyleCoord > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: nsStyleCoord > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_nsAtom_close1_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: RefPtr < root :: nsAtom > > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: nsAtom > > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: RefPtr < root :: nsAtom > > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: nsAtom > > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsAtom_close0_instantiation_10 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsStyleFilter_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: nsStyleFilter > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: nsStyleFilter > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: nsStyleFilter > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: nsStyleFilter > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsCSSShadowArray_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsCSSShadowArray > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsCSSShadowArray > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsCSSShadowArray > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsCSSShadowArray > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_ptr_nsISupports_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < * mut root :: nsISupports > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < * mut root :: nsISupports > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < * mut root :: nsISupports > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < * mut root :: nsISupports > ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsCSSValueList_DefaultDelete_open1_nsCSSValueList_close1_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsCSSValueList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsCSSValueList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsCSSValueList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsCSSValueList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsCSSValueList_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsCSSValuePairList_DefaultDelete_open1_nsCSSValuePairList_close1_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsCSSValuePairList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsCSSValuePairList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsCSSValuePairList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsCSSValuePairList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsCSSValuePairList_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_RawServoAnimationValue_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: RawServoAnimationValue > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: RawServoAnimationValue > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: RawServoAnimationValue > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: RawServoAnimationValue > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_nsCString_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: nsCString > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: nsCString > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: nsCString > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: nsCString > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_14 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_15 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIURI_close0_instantiation_16 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIPrincipal_close0_instantiation_5 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_StyleSheet_close0_instantiation_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: StyleSheet > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: StyleSheet > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: StyleSheet > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: StyleSheet > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_RawServoStyleSheetContents_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: RawServoStyleSheetContents > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: RawServoStyleSheetContents > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: RawServoStyleSheetContents > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: RawServoStyleSheetContents > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_URLExtraData_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: URLExtraData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: URLExtraData > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: URLExtraData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: URLExtraData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_ServoCSSRuleList_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: ServoCSSRuleList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: ServoCSSRuleList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: ServoCSSRuleList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: ServoCSSRuleList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIPrincipal_close0_instantiation_6 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_StyleSheet_close1_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: RefPtr < root :: mozilla :: StyleSheet > > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: mozilla :: StyleSheet > > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: RefPtr < root :: mozilla :: StyleSheet > > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: mozilla :: StyleSheet > > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_StyleSheet_close0_instantiation_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: StyleSheet > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: StyleSheet > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: StyleSheet > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: StyleSheet > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_SheetLoadData_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: RefPtr < root :: mozilla :: css :: SheetLoadData > > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: mozilla :: css :: SheetLoadData > > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: RefPtr < root :: mozilla :: css :: SheetLoadData > > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: mozilla :: css :: SheetLoadData > > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_StyleSheet_close0_instantiation_5 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: StyleSheet > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: StyleSheet > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: StyleSheet > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: StyleSheet > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsAutoPtr_open0_Loader_Sheets_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsAutoPtr < root :: mozilla :: css :: Loader_Sheets > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsAutoPtr < root :: mozilla :: css :: Loader_Sheets > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsAutoPtr < root :: mozilla :: css :: Loader_Sheets > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsAutoPtr < root :: mozilla :: css :: Loader_Sheets > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_DocGroup_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: dom :: DocGroup > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: DocGroup > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: dom :: DocGroup > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: DocGroup > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIConsoleReportCollector_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_BaseTimeDuration_open0_StickyTimeDurationValueCalculator_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: BaseTimeDuration > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: BaseTimeDuration ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: BaseTimeDuration > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: BaseTimeDuration ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_RawServoDeclarationBlock_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: RawServoDeclarationBlock > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: RawServoDeclarationBlock > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: RawServoDeclarationBlock > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: RawServoDeclarationBlock > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_PropertyValuePair_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: mozilla :: PropertyValuePair > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: mozilla :: PropertyValuePair > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: mozilla :: PropertyValuePair > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: mozilla :: PropertyValuePair > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIContent_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsXBLBinding_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsXBLBinding > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsXBLBinding > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsXBLBinding > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsXBLBinding > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_XBLChildrenElement_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: dom :: XBLChildrenElement > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: XBLChildrenElement > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: dom :: XBLChildrenElement > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: XBLChildrenElement > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_XBLChildrenElement_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: RefPtr < root :: mozilla :: dom :: XBLChildrenElement > > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: mozilla :: dom :: XBLChildrenElement > > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: RefPtr < root :: mozilla :: dom :: XBLChildrenElement > > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: mozilla :: dom :: XBLChildrenElement > > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_XBLChildrenElement_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: dom :: XBLChildrenElement > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: XBLChildrenElement > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: dom :: XBLChildrenElement > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: XBLChildrenElement > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsAnonymousContentList_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsAnonymousContentList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAnonymousContentList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsAnonymousContentList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAnonymousContentList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsICSSDeclaration_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_DeclarationBlock_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: DeclarationBlock > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: DeclarationBlock > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: DeclarationBlock > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: DeclarationBlock > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIControllers_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsLabelsNodeList_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsLabelsNodeList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsLabelsNodeList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsLabelsNodeList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsLabelsNodeList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_ShadowRoot_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: dom :: ShadowRoot > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: ShadowRoot > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: dom :: ShadowRoot > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: ShadowRoot > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsXBLBinding_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsXBLBinding > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsXBLBinding > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsXBLBinding > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsXBLBinding > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_CustomElementData_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: dom :: CustomElementData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: CustomElementData > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: dom :: CustomElementData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: CustomElementData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsISupports_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsICSSDeclaration_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsDOMAttributeMap_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsDOMAttributeMap > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsDOMAttributeMap > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsDOMAttributeMap > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsDOMAttributeMap > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsContentList_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsContentList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsContentList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsContentList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsContentList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsDOMTokenList_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsDOMTokenList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsDOMTokenList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsDOMTokenList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsDOMTokenList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsDOMAttributeMap_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsDOMAttributeMap > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsDOMAttributeMap > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsDOMAttributeMap > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsDOMAttributeMap > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsDOMAttributeMap_Element_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsISupports_close0_instantiation_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIObserver_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsIWidget_LongTapInfo_DefaultDelete_open1_nsIWidget_LongTapInfo_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsIWidget_LongTapInfo > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsIWidget_LongTapInfo > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsIWidget_LongTapInfo > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsIWidget_LongTapInfo > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsIWidget_LongTapInfo_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsISMILAttr_DefaultDelete_open1_nsISMILAttr_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsISMILAttr > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsISMILAttr > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsISMILAttr > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsISMILAttr > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsISMILAttr_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_ServoAttrSnapshot_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: mozilla :: ServoAttrSnapshot > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: mozilla :: ServoAttrSnapshot > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: mozilla :: ServoAttrSnapshot > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: mozilla :: ServoAttrSnapshot > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsRefPtrHashKey_open0_Element_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsRefPtrHashKey < root :: mozilla :: dom :: Element > > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsRefPtrHashKey < root :: mozilla :: dom :: Element > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsRefPtrHashKey < root :: mozilla :: dom :: Element > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsRefPtrHashKey < root :: mozilla :: dom :: Element > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_ptr_nsIContent_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < * mut root :: nsIContent > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < * mut root :: nsIContent > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < * mut root :: nsIContent > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < * mut root :: nsIContent > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_Element_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: dom :: Element > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: Element > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: dom :: Element > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: dom :: Element > ) ) ) ; } # [ test ] fn __bindgen_test_layout_OwningNonNull_open0_EffectCompositor_AnimationStyleRuleProcessor_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: OwningNonNull < root :: mozilla :: EffectCompositor_AnimationStyleRuleProcessor > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: OwningNonNull < root :: mozilla :: EffectCompositor_AnimationStyleRuleProcessor > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: OwningNonNull < root :: mozilla :: EffectCompositor_AnimationStyleRuleProcessor > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: OwningNonNull < root :: mozilla :: EffectCompositor_AnimationStyleRuleProcessor > ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsStyleGridTemplate_DefaultDelete_open1_nsStyleGridTemplate_close1_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsStyleGridTemplate > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsStyleGridTemplate > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsStyleGridTemplate > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsStyleGridTemplate > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsStyleGridTemplate_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_nsStyleGridTemplate_DefaultDelete_open1_nsStyleGridTemplate_close1_close0_instantiation_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: nsStyleGridTemplate > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsStyleGridTemplate > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: nsStyleGridTemplate > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: nsStyleGridTemplate > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_nsStyleGridTemplate_close0_instantiation_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_RawServoMediaList_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: RawServoMediaList > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: RawServoMediaList > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: RawServoMediaList > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: RawServoMediaList > ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_RawServoStyleSet_DefaultDelete_open1_RawServoStyleSet_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: RawServoStyleSet > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: RawServoStyleSet > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: RawServoStyleSet > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: RawServoStyleSet > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_RawServoStyleSet_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_ServoStyleSheet_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: RefPtr < root :: mozilla :: ServoStyleSheet > > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: mozilla :: ServoStyleSheet > > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: RefPtr < root :: mozilla :: ServoStyleSheet > > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: mozilla :: ServoStyleSheet > > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_ServoStyleContext_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: ServoStyleContext > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: ServoStyleContext > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: ServoStyleContext > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: ServoStyleContext > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_PostTraversalTask_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: mozilla :: PostTraversalTask > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: mozilla :: PostTraversalTask > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: mozilla :: PostTraversalTask > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: mozilla :: PostTraversalTask > ) ) ) ; } # [ test ] fn __bindgen_test_layout_UniquePtr_open0_ServoStyleRuleMap_DefaultDelete_open1_ServoStyleRuleMap_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: UniquePtr < root :: mozilla :: ServoStyleRuleMap > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: mozilla :: ServoStyleRuleMap > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: UniquePtr < root :: mozilla :: ServoStyleRuleMap > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: UniquePtr < root :: mozilla :: ServoStyleRuleMap > ) ) ) ; } # [ test ] fn __bindgen_test_layout_DefaultDelete_open0_ServoStyleRuleMap_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: mozilla :: DefaultDelete ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsBindingManager_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsBindingManager > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsBindingManager > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsBindingManager > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsBindingManager > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_nsXBLBinding_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: RefPtr < root :: nsXBLBinding > > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: nsXBLBinding > > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: RefPtr < root :: nsXBLBinding > > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: nsXBLBinding > > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsXBLBinding_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsXBLBinding > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsXBLBinding > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsXBLBinding > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsXBLBinding > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsAutoPtr_open0_nsTHashtable_open1_nsRefPtrHashKey_open2_nsIContent_close2_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < u64 > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( u64 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < u64 > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( u64 ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsRefPtrHashKey_open0_nsIContent_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsRefPtrHashKey < root :: nsIContent > > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsRefPtrHashKey < root :: nsIContent > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsRefPtrHashKey < root :: nsIContent > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsRefPtrHashKey < root :: nsIContent > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsAutoPtr_open0_nsBindingManager_WrapperHashtable_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsAutoPtr < root :: nsBindingManager_WrapperHashtable > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsAutoPtr < root :: nsBindingManager_WrapperHashtable > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsAutoPtr < root :: nsBindingManager_WrapperHashtable > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsAutoPtr < root :: nsBindingManager_WrapperHashtable > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsAutoPtr_open0_nsRefPtrHashtable_open1_nsURIHashKey_nsXBLDocumentInfo_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < u64 > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( u64 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < u64 > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( u64 ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsAutoPtr_open0_nsInterfaceHashtable_open1_nsURIHashKey_nsIStreamListener_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < u64 > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( u64 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < u64 > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( u64 ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsRunnableMethod_open1_nsBindingManager_void_close1_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < u64 > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( u64 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < u64 > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( u64 ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsAtom_close0_instantiation_11 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_ServoStyleContext_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: ServoStyleContext > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: ServoStyleContext > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: ServoStyleContext > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: ServoStyleContext > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_ServoStyleContext_close0_instantiation_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: ServoStyleContext > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: ServoStyleContext > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: ServoStyleContext > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: mozilla :: ServoStyleContext > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_RawServoDeclarationBlock_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: RawServoDeclarationBlock > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: RawServoDeclarationBlock > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: RawServoDeclarationBlock > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: RawServoDeclarationBlock > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsAtom_close0_instantiation_12 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsCSSFontFaceRule_close0_instantiation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsCSSFontFaceRule > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsCSSFontFaceRule > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsCSSFontFaceRule > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsCSSFontFaceRule > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsRefPtrHashKey_open0_nsAtom_close0_instantiation_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsRefPtrHashKey < root :: nsAtom > > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsRefPtrHashKey < root :: nsAtom > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsRefPtrHashKey < root :: nsAtom > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsRefPtrHashKey < root :: nsAtom > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_nsAtom_close1_close0_instantiation_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: RefPtr < root :: nsAtom > > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: nsAtom > > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: RefPtr < root :: nsAtom > > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: nsAtom > > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsAtom_close0_instantiation_13 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsCOMPtr_open0_nsIRunnable_close0_instantiation_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsCOMPtr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsCOMPtr ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsRefPtrHashKey_open0_nsAtom_close0_instantiation_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsRefPtrHashKey < root :: nsAtom > > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsRefPtrHashKey < root :: nsAtom > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsRefPtrHashKey < root :: nsAtom > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsRefPtrHashKey < root :: nsAtom > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsRefPtrHashKey_open0_nsAtom_close0_instantiation_5 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsRefPtrHashKey < root :: nsAtom > > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsRefPtrHashKey < root :: nsAtom > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsRefPtrHashKey < root :: nsAtom > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsRefPtrHashKey < root :: nsAtom > ) ) ) ; } # [ test ] fn __bindgen_test_layout_nsTArray_open0_RefPtr_open1_nsAtom_close1_close0_instantiation_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: nsTArray < root :: RefPtr < root :: nsAtom > > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: nsAtom > > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: nsTArray < root :: RefPtr < root :: nsAtom > > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: nsTArray < root :: RefPtr < root :: nsAtom > > ) ) ) ; } # [ test ] fn __bindgen_test_layout_RefPtr_open0_nsAtom_close0_instantiation_14 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < root :: RefPtr < root :: nsAtom > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( root :: RefPtr < root :: nsAtom > ) ) ) ; } }