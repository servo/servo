/* automatically generated by rust-bindgen */

pub use self::root::*;
pub use self::root::mozilla::*;
pub use self::root::mozilla::css::*;
pub use self::root::mozilla::dom::*;
use atomic_refcell::AtomicRefCell;
use data::ElementData;
pub type ServoUnsafeCell<T> = ::std::cell::UnsafeCell<T>;
pub type ServoCell<T> = ::std::cell::Cell<T>;
pub type ServoNodeData = AtomicRefCell<ElementData>;

pub mod root {
    #[repr(C)]
    pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
    impl <T> __BindgenUnionField<T> {
        #[inline]
        pub fn new() -> Self {
            __BindgenUnionField(::std::marker::PhantomData)
        }
        #[inline]
        pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
        #[inline]
        pub unsafe fn as_mut(&mut self) -> &mut T {
            ::std::mem::transmute(self)
        }
    }
    impl <T> ::std::default::Default for __BindgenUnionField<T> {
        #[inline]
        fn default() -> Self { Self::new() }
    }
    impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
        #[inline]
        fn clone(&self) -> Self { Self::new() }
    }
    impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
    impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            fmt.write_str("__BindgenUnionField")
        }
    }
    #[allow(unused_imports)]
    use self::super::root;
    pub const NS_FONT_STYLE_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_STYLE_ITALIC: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_STYLE_OBLIQUE: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_WEIGHT_NORMAL: ::std::os::raw::c_uint = 400;
    pub const NS_FONT_WEIGHT_BOLD: ::std::os::raw::c_uint = 700;
    pub const NS_FONT_WEIGHT_THIN: ::std::os::raw::c_uint = 100;
    pub const NS_FONT_STRETCH_ULTRA_CONDENSED: ::std::os::raw::c_int = -4;
    pub const NS_FONT_STRETCH_EXTRA_CONDENSED: ::std::os::raw::c_int = -3;
    pub const NS_FONT_STRETCH_CONDENSED: ::std::os::raw::c_int = -2;
    pub const NS_FONT_STRETCH_SEMI_CONDENSED: ::std::os::raw::c_int = -1;
    pub const NS_FONT_STRETCH_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_STRETCH_SEMI_EXPANDED: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_STRETCH_EXPANDED: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_STRETCH_EXTRA_EXPANDED: ::std::os::raw::c_uint = 3;
    pub const NS_FONT_STRETCH_ULTRA_EXPANDED: ::std::os::raw::c_uint = 4;
    pub const NS_FONT_SMOOTHING_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_SMOOTHING_GRAYSCALE: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_KERNING_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_KERNING_NONE: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_KERNING_NORMAL: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_SYNTHESIS_WEIGHT: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_SYNTHESIS_STYLE: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_DISPLAY_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_DISPLAY_BLOCK: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_DISPLAY_SWAP: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_DISPLAY_FALLBACK: ::std::os::raw::c_uint = 3;
    pub const NS_FONT_DISPLAY_OPTIONAL: ::std::os::raw::c_uint = 4;
    pub const NS_FONT_VARIANT_CAPS_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_CAPS_SMALLCAPS: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_VARIANT_CAPS_ALLSMALL: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_VARIANT_CAPS_PETITECAPS: ::std::os::raw::c_uint = 3;
    pub const NS_FONT_VARIANT_CAPS_ALLPETITE: ::std::os::raw::c_uint = 4;
    pub const NS_FONT_VARIANT_CAPS_TITLING: ::std::os::raw::c_uint = 5;
    pub const NS_FONT_VARIANT_CAPS_UNICASE: ::std::os::raw::c_uint = 6;
    pub const NS_FONT_VARIANT_POSITION_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_POSITION_SUPER: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_VARIANT_POSITION_SUB: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_VARIANT_WIDTH_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_WIDTH_FULL: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_VARIANT_WIDTH_HALF: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_VARIANT_WIDTH_THIRD: ::std::os::raw::c_uint = 3;
    pub const NS_FONT_VARIANT_WIDTH_QUARTER: ::std::os::raw::c_uint = 4;
    pub const NS_FONT_SUBSCRIPT_OFFSET_RATIO: f32 = 0.2;
    pub const NS_FONT_SUPERSCRIPT_OFFSET_RATIO: f32 = 0.34;
    pub const NS_FONT_SUB_SUPER_SIZE_RATIO_SMALL: f32 = 0.82;
    pub const NS_FONT_SUB_SUPER_SIZE_RATIO_LARGE: f32 = 0.667;
    pub const NS_FONT_SUB_SUPER_SMALL_SIZE: f32 = 20.;
    pub const NS_FONT_SUB_SUPER_LARGE_SIZE: f32 = 45.;
    pub const NS_THEME_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_THEME_BUTTON: ::std::os::raw::c_uint = 1;
    pub const NS_THEME_RADIO: ::std::os::raw::c_uint = 2;
    pub const NS_THEME_CHECKBOX: ::std::os::raw::c_uint = 3;
    pub const NS_THEME_BUTTON_BEVEL: ::std::os::raw::c_uint = 7;
    pub const NS_THEME_FOCUS_OUTLINE: ::std::os::raw::c_uint = 8;
    pub const NS_THEME_TOOLBOX: ::std::os::raw::c_uint = 11;
    pub const NS_THEME_TOOLBAR: ::std::os::raw::c_uint = 12;
    pub const NS_THEME_TOOLBARBUTTON: ::std::os::raw::c_uint = 13;
    pub const NS_THEME_DUALBUTTON: ::std::os::raw::c_uint = 14;
    pub const NS_THEME_TOOLBARBUTTON_DROPDOWN: ::std::os::raw::c_uint = 15;
    pub const NS_THEME_BUTTON_ARROW_UP: ::std::os::raw::c_uint = 16;
    pub const NS_THEME_BUTTON_ARROW_DOWN: ::std::os::raw::c_uint = 17;
    pub const NS_THEME_BUTTON_ARROW_NEXT: ::std::os::raw::c_uint = 18;
    pub const NS_THEME_BUTTON_ARROW_PREVIOUS: ::std::os::raw::c_uint = 19;
    pub const NS_THEME_SEPARATOR: ::std::os::raw::c_uint = 20;
    pub const NS_THEME_TOOLBARGRIPPER: ::std::os::raw::c_uint = 21;
    pub const NS_THEME_SPLITTER: ::std::os::raw::c_uint = 22;
    pub const NS_THEME_STATUSBAR: ::std::os::raw::c_uint = 23;
    pub const NS_THEME_STATUSBARPANEL: ::std::os::raw::c_uint = 24;
    pub const NS_THEME_RESIZERPANEL: ::std::os::raw::c_uint = 25;
    pub const NS_THEME_RESIZER: ::std::os::raw::c_uint = 26;
    pub const NS_THEME_LISTBOX: ::std::os::raw::c_uint = 31;
    pub const NS_THEME_LISTITEM: ::std::os::raw::c_uint = 32;
    pub const NS_THEME_TREEVIEW: ::std::os::raw::c_uint = 41;
    pub const NS_THEME_TREEITEM: ::std::os::raw::c_uint = 42;
    pub const NS_THEME_TREETWISTY: ::std::os::raw::c_uint = 43;
    pub const NS_THEME_TREELINE: ::std::os::raw::c_uint = 44;
    pub const NS_THEME_TREEHEADER: ::std::os::raw::c_uint = 45;
    pub const NS_THEME_TREEHEADERCELL: ::std::os::raw::c_uint = 46;
    pub const NS_THEME_TREEHEADERSORTARROW: ::std::os::raw::c_uint = 47;
    pub const NS_THEME_TREETWISTYOPEN: ::std::os::raw::c_uint = 48;
    pub const NS_THEME_PROGRESSBAR: ::std::os::raw::c_uint = 51;
    pub const NS_THEME_PROGRESSCHUNK: ::std::os::raw::c_uint = 52;
    pub const NS_THEME_PROGRESSBAR_VERTICAL: ::std::os::raw::c_uint = 53;
    pub const NS_THEME_PROGRESSCHUNK_VERTICAL: ::std::os::raw::c_uint = 54;
    pub const NS_THEME_METERBAR: ::std::os::raw::c_uint = 55;
    pub const NS_THEME_METERCHUNK: ::std::os::raw::c_uint = 56;
    pub const NS_THEME_TAB: ::std::os::raw::c_uint = 61;
    pub const NS_THEME_TABPANEL: ::std::os::raw::c_uint = 62;
    pub const NS_THEME_TABPANELS: ::std::os::raw::c_uint = 65;
    pub const NS_THEME_TAB_SCROLL_ARROW_BACK: ::std::os::raw::c_uint = 66;
    pub const NS_THEME_TAB_SCROLL_ARROW_FORWARD: ::std::os::raw::c_uint = 67;
    pub const NS_THEME_TOOLTIP: ::std::os::raw::c_uint = 71;
    pub const NS_THEME_SPINNER: ::std::os::raw::c_uint = 72;
    pub const NS_THEME_SPINNER_UPBUTTON: ::std::os::raw::c_uint = 73;
    pub const NS_THEME_SPINNER_DOWNBUTTON: ::std::os::raw::c_uint = 74;
    pub const NS_THEME_SPINNER_TEXTFIELD: ::std::os::raw::c_uint = 75;
    pub const NS_THEME_NUMBER_INPUT: ::std::os::raw::c_uint = 76;
    pub const NS_THEME_SCROLLBAR: ::std::os::raw::c_uint = 80;
    pub const NS_THEME_SCROLLBAR_SMALL: ::std::os::raw::c_uint = 81;
    pub const NS_THEME_SCROLLBAR_HORIZONTAL: ::std::os::raw::c_uint = 82;
    pub const NS_THEME_SCROLLBAR_VERTICAL: ::std::os::raw::c_uint = 83;
    pub const NS_THEME_SCROLLBARBUTTON_UP: ::std::os::raw::c_uint = 84;
    pub const NS_THEME_SCROLLBARBUTTON_DOWN: ::std::os::raw::c_uint = 85;
    pub const NS_THEME_SCROLLBARBUTTON_LEFT: ::std::os::raw::c_uint = 86;
    pub const NS_THEME_SCROLLBARBUTTON_RIGHT: ::std::os::raw::c_uint = 87;
    pub const NS_THEME_SCROLLBARTRACK_HORIZONTAL: ::std::os::raw::c_uint = 88;
    pub const NS_THEME_SCROLLBARTRACK_VERTICAL: ::std::os::raw::c_uint = 89;
    pub const NS_THEME_SCROLLBARTHUMB_HORIZONTAL: ::std::os::raw::c_uint = 90;
    pub const NS_THEME_SCROLLBARTHUMB_VERTICAL: ::std::os::raw::c_uint = 91;
    pub const NS_THEME_SCROLLBAR_NON_DISAPPEARING: ::std::os::raw::c_uint =
        92;
    pub const NS_THEME_TEXTFIELD: ::std::os::raw::c_uint = 95;
    pub const NS_THEME_CARET: ::std::os::raw::c_uint = 96;
    pub const NS_THEME_TEXTFIELD_MULTILINE: ::std::os::raw::c_uint = 97;
    pub const NS_THEME_SEARCHFIELD: ::std::os::raw::c_uint = 98;
    pub const NS_THEME_MENULIST: ::std::os::raw::c_uint = 101;
    pub const NS_THEME_MENULIST_BUTTON: ::std::os::raw::c_uint = 102;
    pub const NS_THEME_MENULIST_TEXT: ::std::os::raw::c_uint = 103;
    pub const NS_THEME_MENULIST_TEXTFIELD: ::std::os::raw::c_uint = 104;
    pub const NS_THEME_SCALE_HORIZONTAL: ::std::os::raw::c_uint = 111;
    pub const NS_THEME_SCALE_VERTICAL: ::std::os::raw::c_uint = 112;
    pub const NS_THEME_SCALETHUMB_HORIZONTAL: ::std::os::raw::c_uint = 113;
    pub const NS_THEME_SCALETHUMB_VERTICAL: ::std::os::raw::c_uint = 114;
    pub const NS_THEME_SCALETHUMBSTART: ::std::os::raw::c_uint = 115;
    pub const NS_THEME_SCALETHUMBEND: ::std::os::raw::c_uint = 116;
    pub const NS_THEME_SCALETHUMBTICK: ::std::os::raw::c_uint = 117;
    pub const NS_THEME_RANGE: ::std::os::raw::c_uint = 120;
    pub const NS_THEME_RANGE_THUMB: ::std::os::raw::c_uint = 121;
    pub const NS_THEME_GROUPBOX: ::std::os::raw::c_uint = 149;
    pub const NS_THEME_CHECKBOX_CONTAINER: ::std::os::raw::c_uint = 150;
    pub const NS_THEME_RADIO_CONTAINER: ::std::os::raw::c_uint = 151;
    pub const NS_THEME_CHECKBOX_LABEL: ::std::os::raw::c_uint = 152;
    pub const NS_THEME_RADIO_LABEL: ::std::os::raw::c_uint = 153;
    pub const NS_THEME_BUTTON_FOCUS: ::std::os::raw::c_uint = 154;
    pub const NS_THEME_WINDOW: ::std::os::raw::c_uint = 200;
    pub const NS_THEME_DIALOG: ::std::os::raw::c_uint = 201;
    pub const NS_THEME_MENUBAR: ::std::os::raw::c_uint = 210;
    pub const NS_THEME_MENUPOPUP: ::std::os::raw::c_uint = 211;
    pub const NS_THEME_MENUITEM: ::std::os::raw::c_uint = 212;
    pub const NS_THEME_CHECKMENUITEM: ::std::os::raw::c_uint = 213;
    pub const NS_THEME_RADIOMENUITEM: ::std::os::raw::c_uint = 214;
    pub const NS_THEME_MENUCHECKBOX: ::std::os::raw::c_uint = 215;
    pub const NS_THEME_MENURADIO: ::std::os::raw::c_uint = 216;
    pub const NS_THEME_MENUSEPARATOR: ::std::os::raw::c_uint = 217;
    pub const NS_THEME_MENUARROW: ::std::os::raw::c_uint = 218;
    pub const NS_THEME_MENUIMAGE: ::std::os::raw::c_uint = 219;
    pub const NS_THEME_MENUITEMTEXT: ::std::os::raw::c_uint = 220;
    pub const NS_THEME_WIN_COMMUNICATIONS_TOOLBOX: ::std::os::raw::c_uint =
        221;
    pub const NS_THEME_WIN_MEDIA_TOOLBOX: ::std::os::raw::c_uint = 222;
    pub const NS_THEME_WIN_BROWSERTABBAR_TOOLBOX: ::std::os::raw::c_uint =
        223;
    pub const NS_THEME_MAC_FULLSCREEN_BUTTON: ::std::os::raw::c_uint = 226;
    pub const NS_THEME_MAC_HELP_BUTTON: ::std::os::raw::c_uint = 227;
    pub const NS_THEME_WIN_BORDERLESS_GLASS: ::std::os::raw::c_uint = 229;
    pub const NS_THEME_WIN_GLASS: ::std::os::raw::c_uint = 230;
    pub const NS_THEME_WINDOW_TITLEBAR: ::std::os::raw::c_uint = 231;
    pub const NS_THEME_WINDOW_TITLEBAR_MAXIMIZED: ::std::os::raw::c_uint =
        232;
    pub const NS_THEME_WINDOW_FRAME_LEFT: ::std::os::raw::c_uint = 233;
    pub const NS_THEME_WINDOW_FRAME_RIGHT: ::std::os::raw::c_uint = 234;
    pub const NS_THEME_WINDOW_FRAME_BOTTOM: ::std::os::raw::c_uint = 235;
    pub const NS_THEME_WINDOW_BUTTON_CLOSE: ::std::os::raw::c_uint = 236;
    pub const NS_THEME_WINDOW_BUTTON_MINIMIZE: ::std::os::raw::c_uint = 237;
    pub const NS_THEME_WINDOW_BUTTON_MAXIMIZE: ::std::os::raw::c_uint = 238;
    pub const NS_THEME_WINDOW_BUTTON_RESTORE: ::std::os::raw::c_uint = 239;
    pub const NS_THEME_WINDOW_BUTTON_BOX: ::std::os::raw::c_uint = 240;
    pub const NS_THEME_WINDOW_BUTTON_BOX_MAXIMIZED: ::std::os::raw::c_uint =
        241;
    pub const NS_THEME_WIN_EXCLUDE_GLASS: ::std::os::raw::c_uint = 242;
    pub const NS_THEME_MAC_VIBRANCY_LIGHT: ::std::os::raw::c_uint = 243;
    pub const NS_THEME_MAC_VIBRANCY_DARK: ::std::os::raw::c_uint = 244;
    pub const NS_THEME_MAC_DISCLOSURE_BUTTON_OPEN: ::std::os::raw::c_uint =
        245;
    pub const NS_THEME_MAC_DISCLOSURE_BUTTON_CLOSED: ::std::os::raw::c_uint =
        246;
    pub const NS_THEME_GTK_INFO_BAR: ::std::os::raw::c_uint = 247;
    pub const NS_THEME_MAC_SOURCE_LIST: ::std::os::raw::c_uint = 248;
    pub const NS_THEME_MAC_SOURCE_LIST_SELECTION: ::std::os::raw::c_uint =
        249;
    pub const NS_THEME_MAC_ACTIVE_SOURCE_LIST_SELECTION:
              ::std::os::raw::c_uint =
        250;
    pub const kNameSpaceID_Unknown: ::std::os::raw::c_int = -1;
    pub const kNameSpaceID_XMLNS: ::std::os::raw::c_uint = 1;
    pub const kNameSpaceID_XML: ::std::os::raw::c_uint = 2;
    pub const kNameSpaceID_XHTML: ::std::os::raw::c_uint = 3;
    pub const kNameSpaceID_XLink: ::std::os::raw::c_uint = 4;
    pub const kNameSpaceID_XSLT: ::std::os::raw::c_uint = 5;
    pub const kNameSpaceID_XBL: ::std::os::raw::c_uint = 6;
    pub const kNameSpaceID_MathML: ::std::os::raw::c_uint = 7;
    pub const kNameSpaceID_RDF: ::std::os::raw::c_uint = 8;
    pub const kNameSpaceID_XUL: ::std::os::raw::c_uint = 9;
    pub const kNameSpaceID_SVG: ::std::os::raw::c_uint = 10;
    pub const kNameSpaceID_disabled_MathML: ::std::os::raw::c_uint = 11;
    pub const kNameSpaceID_disabled_SVG: ::std::os::raw::c_uint = 12;
    pub const kNameSpaceID_LastBuiltin: ::std::os::raw::c_uint = 12;
    pub const kNameSpaceID_Wildcard: ::std::os::raw::c_int = -2147483648;
    pub const NS_FONT_VARIANT_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_SMALL_CAPS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_STACK_SIZING_IGNORE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_STACK_SIZING_STRETCH_TO_FIT: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_AZIMUTH_LEFT_SIDE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_AZIMUTH_FAR_LEFT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_AZIMUTH_LEFT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_AZIMUTH_CENTER_LEFT: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_AZIMUTH_CENTER: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_AZIMUTH_CENTER_RIGHT: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_AZIMUTH_RIGHT: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_AZIMUTH_FAR_RIGHT: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_AZIMUTH_RIGHT_SIDE: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_AZIMUTH_BEHIND: ::std::os::raw::c_uint = 128;
    pub const NS_STYLE_AZIMUTH_LEFTWARDS: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_AZIMUTH_RIGHTWARDS: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_ELEVATION_BELOW: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_ELEVATION_LEVEL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_ELEVATION_ABOVE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_ELEVATION_HIGHER: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_ELEVATION_LOWER: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_PITCH_X_LOW: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PITCH_LOW: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_PITCH_MEDIUM: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_PITCH_HIGH: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_PITCH_X_HIGH: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_SPEAK_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SPEAK_NORMAL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SPEAK_SPELL_OUT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_SPEAK_HEADER_ONCE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SPEAK_HEADER_ALWAYS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SPEAK_NUMERAL_DIGITS: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SPEAK_NUMERAL_CONTINUOUS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SPEAK_PUNCTUATION_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SPEAK_PUNCTUATION_CODE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SPEECH_RATE_X_SLOW: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SPEECH_RATE_SLOW: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SPEECH_RATE_MEDIUM: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_SPEECH_RATE_FAST: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_SPEECH_RATE_X_FAST: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_SPEECH_RATE_FASTER: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_SPEECH_RATE_SLOWER: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_VOLUME_SILENT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_VOLUME_X_SOFT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_VOLUME_SOFT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_VOLUME_MEDIUM: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_VOLUME_LOUD: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_VOLUME_X_LOUD: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_COLOR_INHERIT_FROM_BODY: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_WILL_CHANGE_STACKING_CONTEXT: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_WILL_CHANGE_TRANSFORM: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_WILL_CHANGE_SCROLL: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_WILL_CHANGE_OPACITY: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_WILL_CHANGE_FIXPOS_CB: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_WILL_CHANGE_ABSPOS_CB: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_ANIMATION_ITERATION_COUNT_INFINITE:
              ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_ANIMATION_PLAY_STATE_RUNNING: ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_ANIMATION_PLAY_STATE_PAUSED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_IMAGELAYER_ATTACHMENT_SCROLL: ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_IMAGELAYER_ATTACHMENT_FIXED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_IMAGELAYER_ATTACHMENT_LOCAL: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_IMAGELAYER_CLIP_MOZ_ALMOST_PADDING:
              ::std::os::raw::c_uint =
        127;
    pub const NS_STYLE_IMAGELAYER_POSITION_CENTER: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_IMAGELAYER_POSITION_TOP: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_IMAGELAYER_POSITION_BOTTOM: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_IMAGELAYER_POSITION_LEFT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_IMAGELAYER_POSITION_RIGHT: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_IMAGELAYER_REPEAT_NO_REPEAT: ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_IMAGELAYER_REPEAT_REPEAT_X: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_IMAGELAYER_REPEAT_REPEAT_Y: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_IMAGELAYER_REPEAT_REPEAT: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_IMAGELAYER_REPEAT_SPACE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_IMAGELAYER_REPEAT_ROUND: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_IMAGELAYER_SIZE_CONTAIN: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_IMAGELAYER_SIZE_COVER: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_MASK_MODE_ALPHA: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_MASK_MODE_LUMINANCE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_MASK_MODE_MATCH_SOURCE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_BG_INLINE_POLICY_EACH_BOX: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BG_INLINE_POLICY_CONTINUOUS: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_BG_INLINE_POLICY_BOUNDING_BOX: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_BORDER_COLLAPSE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BORDER_SEPARATE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BORDER_WIDTH_THIN: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BORDER_WIDTH_MEDIUM: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BORDER_WIDTH_THICK: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_BORDER_STYLE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BORDER_STYLE_GROOVE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BORDER_STYLE_RIDGE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_BORDER_STYLE_DOTTED: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_BORDER_STYLE_DASHED: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_BORDER_STYLE_SOLID: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_BORDER_STYLE_DOUBLE: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_BORDER_STYLE_INSET: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_BORDER_STYLE_OUTSET: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_BORDER_STYLE_HIDDEN: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_BORDER_STYLE_AUTO: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_BORDER_IMAGE_REPEAT_STRETCH: ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_BORDER_IMAGE_REPEAT_REPEAT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BORDER_IMAGE_REPEAT_ROUND: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_BORDER_IMAGE_REPEAT_SPACE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_BORDER_IMAGE_SLICE_NOFILL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BORDER_IMAGE_SLICE_FILL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CONTENT_OPEN_QUOTE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CONTENT_CLOSE_QUOTE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CONTENT_NO_OPEN_QUOTE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_CONTENT_NO_CLOSE_QUOTE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_CONTENT_ALT_CONTENT: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_CURSOR_AUTO: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CURSOR_CROSSHAIR: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_CURSOR_DEFAULT: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_CURSOR_POINTER: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_CURSOR_MOVE: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_CURSOR_E_RESIZE: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_CURSOR_NE_RESIZE: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_CURSOR_NW_RESIZE: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_CURSOR_N_RESIZE: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_CURSOR_SE_RESIZE: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_CURSOR_SW_RESIZE: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_CURSOR_S_RESIZE: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_CURSOR_W_RESIZE: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_CURSOR_TEXT: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_CURSOR_WAIT: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_CURSOR_HELP: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_CURSOR_COPY: ::std::os::raw::c_uint = 17;
    pub const NS_STYLE_CURSOR_ALIAS: ::std::os::raw::c_uint = 18;
    pub const NS_STYLE_CURSOR_CONTEXT_MENU: ::std::os::raw::c_uint = 19;
    pub const NS_STYLE_CURSOR_CELL: ::std::os::raw::c_uint = 20;
    pub const NS_STYLE_CURSOR_GRAB: ::std::os::raw::c_uint = 21;
    pub const NS_STYLE_CURSOR_GRABBING: ::std::os::raw::c_uint = 22;
    pub const NS_STYLE_CURSOR_SPINNING: ::std::os::raw::c_uint = 23;
    pub const NS_STYLE_CURSOR_ZOOM_IN: ::std::os::raw::c_uint = 24;
    pub const NS_STYLE_CURSOR_ZOOM_OUT: ::std::os::raw::c_uint = 25;
    pub const NS_STYLE_CURSOR_NOT_ALLOWED: ::std::os::raw::c_uint = 26;
    pub const NS_STYLE_CURSOR_COL_RESIZE: ::std::os::raw::c_uint = 27;
    pub const NS_STYLE_CURSOR_ROW_RESIZE: ::std::os::raw::c_uint = 28;
    pub const NS_STYLE_CURSOR_NO_DROP: ::std::os::raw::c_uint = 29;
    pub const NS_STYLE_CURSOR_VERTICAL_TEXT: ::std::os::raw::c_uint = 30;
    pub const NS_STYLE_CURSOR_ALL_SCROLL: ::std::os::raw::c_uint = 31;
    pub const NS_STYLE_CURSOR_NESW_RESIZE: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_CURSOR_NWSE_RESIZE: ::std::os::raw::c_uint = 33;
    pub const NS_STYLE_CURSOR_NS_RESIZE: ::std::os::raw::c_uint = 34;
    pub const NS_STYLE_CURSOR_EW_RESIZE: ::std::os::raw::c_uint = 35;
    pub const NS_STYLE_CURSOR_NONE: ::std::os::raw::c_uint = 36;
    pub const NS_STYLE_DIRECTION_LTR: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_DIRECTION_RTL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WRITING_MODE_HORIZONTAL_TB: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_WRITING_MODE_VERTICAL_RL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WRITING_MODE_VERTICAL_LR: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_WRITING_MODE_SIDEWAYS_MASK: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_WRITING_MODE_SIDEWAYS_RL: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_WRITING_MODE_SIDEWAYS_LR: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_CONTAIN_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CONTAIN_STRICT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CONTAIN_LAYOUT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_CONTAIN_STYLE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_CONTAIN_PAINT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_CONTAIN_ALL_BITS: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_ALIGN_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_ALIGN_NORMAL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_ALIGN_START: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_ALIGN_END: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_ALIGN_FLEX_START: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_ALIGN_FLEX_END: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_ALIGN_CENTER: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_ALIGN_LEFT: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_ALIGN_RIGHT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_ALIGN_BASELINE: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_ALIGN_LAST_BASELINE: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_ALIGN_STRETCH: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_ALIGN_SELF_START: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_ALIGN_SELF_END: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_ALIGN_SPACE_BETWEEN: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_ALIGN_SPACE_AROUND: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_ALIGN_SPACE_EVENLY: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_ALIGN_LEGACY: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_ALIGN_SAFE: ::std::os::raw::c_uint = 64;
    pub const NS_STYLE_ALIGN_UNSAFE: ::std::os::raw::c_uint = 128;
    pub const NS_STYLE_ALIGN_FLAG_BITS: ::std::os::raw::c_uint = 224;
    pub const NS_STYLE_ALIGN_ALL_BITS: ::std::os::raw::c_uint = 255;
    pub const NS_STYLE_ALIGN_ALL_SHIFT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_JUSTIFY_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_JUSTIFY_NORMAL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_JUSTIFY_START: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_JUSTIFY_END: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_JUSTIFY_FLEX_START: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_JUSTIFY_FLEX_END: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_JUSTIFY_CENTER: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_JUSTIFY_LEFT: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_JUSTIFY_RIGHT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_JUSTIFY_BASELINE: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_JUSTIFY_LAST_BASELINE: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_JUSTIFY_STRETCH: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_JUSTIFY_SELF_START: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_JUSTIFY_SELF_END: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_JUSTIFY_SPACE_BETWEEN: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_JUSTIFY_SPACE_AROUND: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_JUSTIFY_SPACE_EVENLY: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_JUSTIFY_LEGACY: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_JUSTIFY_SAFE: ::std::os::raw::c_uint = 64;
    pub const NS_STYLE_JUSTIFY_UNSAFE: ::std::os::raw::c_uint = 128;
    pub const NS_STYLE_JUSTIFY_FLAG_BITS: ::std::os::raw::c_uint = 224;
    pub const NS_STYLE_JUSTIFY_ALL_BITS: ::std::os::raw::c_uint = 255;
    pub const NS_STYLE_JUSTIFY_ALL_SHIFT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_FLEX_DIRECTION_ROW: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FLEX_DIRECTION_ROW_REVERSE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FLEX_DIRECTION_COLUMN: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FLEX_DIRECTION_COLUMN_REVERSE: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_FLEX_WRAP_NOWRAP: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FLEX_WRAP_WRAP: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FLEX_WRAP_WRAP_REVERSE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_ORDER_INITIAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_JUSTIFY_CONTENT_FLEX_START: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_JUSTIFY_CONTENT_FLEX_END: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_JUSTIFY_CONTENT_CENTER: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_JUSTIFY_CONTENT_SPACE_BETWEEN: ::std::os::raw::c_uint =
        14;
    pub const NS_STYLE_JUSTIFY_CONTENT_SPACE_AROUND: ::std::os::raw::c_uint =
        15;
    pub const NS_STYLE_FILTER_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FILTER_URL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FILTER_BLUR: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FILTER_BRIGHTNESS: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_FILTER_CONTRAST: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_FILTER_GRAYSCALE: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_FILTER_INVERT: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_FILTER_OPACITY: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_FILTER_SATURATE: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_FILTER_SEPIA: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_FILTER_HUE_ROTATE: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_FILTER_DROP_SHADOW: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_FONT_STYLE_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FONT_STYLE_ITALIC: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FONT_STYLE_OBLIQUE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FONT_WEIGHT_NORMAL: ::std::os::raw::c_uint = 400;
    pub const NS_STYLE_FONT_WEIGHT_BOLD: ::std::os::raw::c_uint = 700;
    pub const NS_STYLE_FONT_WEIGHT_BOLDER: ::std::os::raw::c_int = -1;
    pub const NS_STYLE_FONT_WEIGHT_LIGHTER: ::std::os::raw::c_int = -2;
    pub const NS_STYLE_FONT_SIZE_XXSMALL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FONT_SIZE_XSMALL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FONT_SIZE_SMALL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FONT_SIZE_MEDIUM: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_FONT_SIZE_LARGE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_FONT_SIZE_XLARGE: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_FONT_SIZE_XXLARGE: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_FONT_SIZE_XXXLARGE: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_FONT_SIZE_LARGER: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_FONT_SIZE_SMALLER: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_FONT_STRETCH_ULTRA_CONDENSED: ::std::os::raw::c_int =
        -4;
    pub const NS_STYLE_FONT_STRETCH_EXTRA_CONDENSED: ::std::os::raw::c_int =
        -3;
    pub const NS_STYLE_FONT_STRETCH_CONDENSED: ::std::os::raw::c_int = -2;
    pub const NS_STYLE_FONT_STRETCH_SEMI_CONDENSED: ::std::os::raw::c_int =
        -1;
    pub const NS_STYLE_FONT_STRETCH_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FONT_STRETCH_SEMI_EXPANDED: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FONT_STRETCH_EXPANDED: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FONT_STRETCH_EXTRA_EXPANDED: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_FONT_STRETCH_ULTRA_EXPANDED: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_FONT_CAPTION: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FONT_ICON: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FONT_MENU: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_FONT_MESSAGE_BOX: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_FONT_SMALL_CAPTION: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_FONT_STATUS_BAR: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_FONT_WINDOW: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_FONT_DOCUMENT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_FONT_WORKSPACE: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_FONT_DESKTOP: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_FONT_INFO: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_FONT_DIALOG: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_FONT_BUTTON: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_FONT_PULL_DOWN_MENU: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_FONT_LIST: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_FONT_FIELD: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_GRID_AUTO_FLOW_ROW: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_GRID_AUTO_FLOW_COLUMN: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_GRID_AUTO_FLOW_DENSE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_GRID_TEMPLATE_SUBGRID: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_GRID_REPEAT_AUTO_FILL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_GRID_REPEAT_AUTO_FIT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WIDTH_MAX_CONTENT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_WIDTH_MIN_CONTENT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WIDTH_FIT_CONTENT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_WIDTH_AVAILABLE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_POSITION_STATIC: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_POSITION_RELATIVE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_POSITION_ABSOLUTE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_POSITION_FIXED: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_POSITION_STICKY: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_CLIP_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CLIP_RECT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CLIP_TYPE_MASK: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_CLIP_LEFT_AUTO: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_CLIP_TOP_AUTO: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_CLIP_RIGHT_AUTO: ::std::os::raw::c_uint = 64;
    pub const NS_STYLE_CLIP_BOTTOM_AUTO: ::std::os::raw::c_uint = 128;
    pub const NS_STYLE_FRAME_YES: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FRAME_NO: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FRAME_0: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FRAME_1: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_FRAME_ON: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_FRAME_OFF: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_FRAME_AUTO: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_FRAME_SCROLL: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_FRAME_NOSCROLL: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_OVERFLOW_VISIBLE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_OVERFLOW_HIDDEN: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_OVERFLOW_SCROLL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_OVERFLOW_AUTO: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_OVERFLOW_CLIP: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_OVERFLOW_SCROLLBARS_HORIZONTAL: ::std::os::raw::c_uint
              =
        5;
    pub const NS_STYLE_OVERFLOW_SCROLLBARS_VERTICAL: ::std::os::raw::c_uint =
        6;
    pub const NS_STYLE_OVERFLOW_CLIP_BOX_PADDING_BOX: ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_OVERFLOW_CLIP_BOX_CONTENT_BOX: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_LIST_STYLE_CUSTOM: ::std::os::raw::c_int = -1;
    pub const NS_STYLE_LIST_STYLE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_LIST_STYLE_DISC: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_LIST_STYLE_CIRCLE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_LIST_STYLE_SQUARE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_LIST_STYLE_DECIMAL: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_LIST_STYLE_HEBREW: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_LIST_STYLE_JAPANESE_INFORMAL: ::std::os::raw::c_uint =
        6;
    pub const NS_STYLE_LIST_STYLE_JAPANESE_FORMAL: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_LIST_STYLE_KOREAN_HANGUL_FORMAL: ::std::os::raw::c_uint
              =
        8;
    pub const NS_STYLE_LIST_STYLE_KOREAN_HANJA_INFORMAL:
              ::std::os::raw::c_uint =
        9;
    pub const NS_STYLE_LIST_STYLE_KOREAN_HANJA_FORMAL: ::std::os::raw::c_uint
              =
        10;
    pub const NS_STYLE_LIST_STYLE_SIMP_CHINESE_INFORMAL:
              ::std::os::raw::c_uint =
        11;
    pub const NS_STYLE_LIST_STYLE_SIMP_CHINESE_FORMAL: ::std::os::raw::c_uint
              =
        12;
    pub const NS_STYLE_LIST_STYLE_TRAD_CHINESE_INFORMAL:
              ::std::os::raw::c_uint =
        13;
    pub const NS_STYLE_LIST_STYLE_TRAD_CHINESE_FORMAL: ::std::os::raw::c_uint
              =
        14;
    pub const NS_STYLE_LIST_STYLE_ETHIOPIC_NUMERIC: ::std::os::raw::c_uint =
        15;
    pub const NS_STYLE_LIST_STYLE_DISCLOSURE_CLOSED: ::std::os::raw::c_uint =
        16;
    pub const NS_STYLE_LIST_STYLE_DISCLOSURE_OPEN: ::std::os::raw::c_uint =
        17;
    pub const NS_STYLE_LIST_STYLE__MAX: ::std::os::raw::c_uint = 18;
    pub const NS_STYLE_LIST_STYLE_LOWER_ROMAN: ::std::os::raw::c_uint = 100;
    pub const NS_STYLE_LIST_STYLE_UPPER_ROMAN: ::std::os::raw::c_uint = 101;
    pub const NS_STYLE_LIST_STYLE_LOWER_ALPHA: ::std::os::raw::c_uint = 102;
    pub const NS_STYLE_LIST_STYLE_UPPER_ALPHA: ::std::os::raw::c_uint = 103;
    pub const NS_STYLE_LIST_STYLE_POSITION_INSIDE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_LIST_STYLE_POSITION_OUTSIDE: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_MARGIN_SIZE_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_POINTER_EVENTS_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_POINTER_EVENTS_VISIBLEPAINTED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_POINTER_EVENTS_VISIBLEFILL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_POINTER_EVENTS_VISIBLESTROKE: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_POINTER_EVENTS_VISIBLE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_POINTER_EVENTS_PAINTED: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_POINTER_EVENTS_FILL: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_POINTER_EVENTS_STROKE: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_POINTER_EVENTS_ALL: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_POINTER_EVENTS_AUTO: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_IMAGE_ORIENTATION_FLIP: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_IMAGE_ORIENTATION_FROM_IMAGE: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_ISOLATION_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_ISOLATION_ISOLATE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_OBJECT_FIT_FILL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_OBJECT_FIT_CONTAIN: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_OBJECT_FIT_COVER: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_OBJECT_FIT_NONE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_OBJECT_FIT_SCALE_DOWN: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_RESIZE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_RESIZE_BOTH: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_RESIZE_HORIZONTAL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_RESIZE_VERTICAL: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_TEXT_ALIGN_START: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_ALIGN_LEFT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_ALIGN_RIGHT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_ALIGN_CENTER: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_TEXT_ALIGN_JUSTIFY: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_TEXT_ALIGN_CHAR: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_TEXT_ALIGN_END: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_TEXT_ALIGN_AUTO: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_TEXT_ALIGN_MOZ_CENTER: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_TEXT_ALIGN_MOZ_RIGHT: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_TEXT_ALIGN_MOZ_LEFT: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_TEXT_ALIGN_MOZ_CENTER_OR_INHERIT:
              ::std::os::raw::c_uint =
        11;
    pub const NS_STYLE_TEXT_ALIGN_UNSAFE: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_TEXT_ALIGN_MATCH_PARENT: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_TEXT_DECORATION_LINE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE: ::std::os::raw::c_uint
              =
        1;
    pub const NS_STYLE_TEXT_DECORATION_LINE_OVERLINE: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH:
              ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_TEXT_DECORATION_LINE_BLINK: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_TEXT_DECORATION_LINE_PREF_ANCHORS:
              ::std::os::raw::c_uint =
        16;
    pub const NS_STYLE_TEXT_DECORATION_LINE_OVERRIDE_ALL:
              ::std::os::raw::c_uint =
        32;
    pub const NS_STYLE_TEXT_DECORATION_LINE_LINES_MASK: ::std::os::raw::c_uint
              =
        7;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_DOTTED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_DASHED: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_SOLID: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_DOUBLE: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_WAVY: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_MAX: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_TEXT_OVERFLOW_CLIP: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_OVERFLOW_ELLIPSIS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_OVERFLOW_STRING: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_TRANSFORM_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_TRANSFORM_CAPITALIZE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_TRANSFORM_LOWERCASE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_TRANSFORM_UPPERCASE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_TEXT_TRANSFORM_FULL_WIDTH: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_TOUCH_ACTION_NONE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TOUCH_ACTION_AUTO: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TOUCH_ACTION_PAN_X: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_TOUCH_ACTION_PAN_Y: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_TOUCH_ACTION_MANIPULATION: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_TOP_LAYER_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TOP_LAYER_TOP: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TRANSFORM_BOX_BORDER_BOX: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TRANSFORM_BOX_FILL_BOX: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TRANSFORM_BOX_VIEW_BOX: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE: ::std::os::raw::c_uint
              =
        0;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_LINEAR:
              ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN:
              ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_OUT:
              ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN_OUT:
              ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_STEP_START:
              ::std::os::raw::c_uint =
        5;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_STEP_END:
              ::std::os::raw::c_uint =
        6;
    pub const NS_STYLE_VERTICAL_ALIGN_BASELINE: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_VERTICAL_ALIGN_SUB: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_VERTICAL_ALIGN_SUPER: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_VERTICAL_ALIGN_TOP: ::std::os::raw::c_uint = 17;
    pub const NS_STYLE_VERTICAL_ALIGN_TEXT_TOP: ::std::os::raw::c_uint = 18;
    pub const NS_STYLE_VERTICAL_ALIGN_MIDDLE: ::std::os::raw::c_uint = 19;
    pub const NS_STYLE_VERTICAL_ALIGN_TEXT_BOTTOM: ::std::os::raw::c_uint =
        20;
    pub const NS_STYLE_VERTICAL_ALIGN_BOTTOM: ::std::os::raw::c_uint = 21;
    pub const NS_STYLE_VERTICAL_ALIGN_MIDDLE_WITH_BASELINE:
              ::std::os::raw::c_uint =
        22;
    pub const NS_STYLE_VISIBILITY_HIDDEN: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_VISIBILITY_VISIBLE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_VISIBILITY_COLLAPSE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TABSIZE_INITIAL: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_WHITESPACE_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_WHITESPACE_PRE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WHITESPACE_NOWRAP: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_WHITESPACE_PRE_WRAP: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_WHITESPACE_PRE_LINE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_WHITESPACE_PRE_SPACE: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_WORDBREAK_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_WORDBREAK_BREAK_ALL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WORDBREAK_KEEP_ALL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_OVERFLOWWRAP_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_OVERFLOWWRAP_BREAK_WORD: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_RUBY_ALIGN_START: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_RUBY_ALIGN_CENTER: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_RUBY_ALIGN_SPACE_BETWEEN: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_RUBY_ALIGN_SPACE_AROUND: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_RUBY_POSITION_OVER: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_RUBY_POSITION_UNDER: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_RUBY_POSITION_INTER_CHARACTER: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_SIZE_ADJUST_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_SIZE_ADJUST_AUTO: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_ORIENTATION_MIXED: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_ORIENTATION_UPRIGHT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_ORIENTATION_SIDEWAYS: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_ALL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_DIGITS_2: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_DIGITS_3: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_DIGITS_4: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_LINE_HEIGHT_BLOCK_HEIGHT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_UNICODE_BIDI_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_UNICODE_BIDI_EMBED: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_UNICODE_BIDI_ISOLATE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_UNICODE_BIDI_BIDI_OVERRIDE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_UNICODE_BIDI_ISOLATE_OVERRIDE: ::std::os::raw::c_uint =
        6;
    pub const NS_STYLE_UNICODE_BIDI_PLAINTEXT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_TABLE_LAYOUT_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TABLE_LAYOUT_FIXED: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TABLE_EMPTY_CELLS_HIDE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TABLE_EMPTY_CELLS_SHOW: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CAPTION_SIDE_TOP: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CAPTION_SIDE_RIGHT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CAPTION_SIDE_BOTTOM: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_CAPTION_SIDE_LEFT: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE: ::std::os::raw::c_uint =
        5;
    pub const NS_STYLE_CELL_SCOPE_ROW: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CELL_SCOPE_COL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CELL_SCOPE_ROWGROUP: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_CELL_SCOPE_COLGROUP: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_PAGE_MARKS_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_PAGE_MARKS_CROP: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PAGE_MARKS_REGISTER: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_PAGE_SIZE_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_PAGE_SIZE_PORTRAIT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PAGE_SIZE_LANDSCAPE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_PAGE_BREAK_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_PAGE_BREAK_ALWAYS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PAGE_BREAK_AVOID: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_PAGE_BREAK_LEFT: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_PAGE_BREAK_RIGHT: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_COLUMN_COUNT_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COLUMN_COUNT_UNLIMITED: ::std::os::raw::c_int = -1;
    pub const NS_STYLE_COLUMN_FILL_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COLUMN_FILL_BALANCE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_IME_MODE_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_IME_MODE_NORMAL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_IME_MODE_ACTIVE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_IME_MODE_DISABLED: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_IME_MODE_INACTIVE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_GRADIENT_SHAPE_LINEAR: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_GRADIENT_SHAPE_ELLIPTICAL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_GRADIENT_SHAPE_CIRCULAR: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_GRADIENT_SIZE_CLOSEST_SIDE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_GRADIENT_SIZE_CLOSEST_CORNER: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_GRADIENT_SIZE_FARTHEST_SIDE: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_GRADIENT_SIZE_FARTHEST_CORNER: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_GRADIENT_SIZE_EXPLICIT_SIZE: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_DOMINANT_BASELINE_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_DOMINANT_BASELINE_USE_SCRIPT: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_DOMINANT_BASELINE_NO_CHANGE: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_DOMINANT_BASELINE_RESET_SIZE: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_DOMINANT_BASELINE_IDEOGRAPHIC: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_DOMINANT_BASELINE_ALPHABETIC: ::std::os::raw::c_uint =
        5;
    pub const NS_STYLE_DOMINANT_BASELINE_HANGING: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_DOMINANT_BASELINE_MATHEMATICAL: ::std::os::raw::c_uint
              =
        7;
    pub const NS_STYLE_DOMINANT_BASELINE_CENTRAL: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_DOMINANT_BASELINE_MIDDLE: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_DOMINANT_BASELINE_TEXT_AFTER_EDGE:
              ::std::os::raw::c_uint =
        10;
    pub const NS_STYLE_DOMINANT_BASELINE_TEXT_BEFORE_EDGE:
              ::std::os::raw::c_uint =
        11;
    pub const NS_STYLE_IMAGE_RENDERING_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_IMAGE_RENDERING_OPTIMIZESPEED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_IMAGE_RENDERING_OPTIMIZEQUALITY: ::std::os::raw::c_uint
              =
        2;
    pub const NS_STYLE_IMAGE_RENDERING_CRISPEDGES: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_MASK_TYPE_LUMINANCE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_MASK_TYPE_ALPHA: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PAINT_ORDER_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_PAINT_ORDER_FILL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PAINT_ORDER_STROKE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_PAINT_ORDER_MARKERS: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_PAINT_ORDER_LAST_VALUE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_PAINT_ORDER_BITWIDTH: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_SHAPE_RENDERING_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SHAPE_RENDERING_OPTIMIZESPEED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_SHAPE_RENDERING_CRISPEDGES: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_SHAPE_RENDERING_GEOMETRICPRECISION:
              ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_STROKE_LINECAP_BUTT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_STROKE_LINECAP_ROUND: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_STROKE_LINECAP_SQUARE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_STROKE_LINEJOIN_MITER: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_STROKE_LINEJOIN_ROUND: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_STROKE_LINEJOIN_BEVEL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_STROKE_PROP_CONTEXT_VALUE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_ANCHOR_START: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_ANCHOR_MIDDLE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_ANCHOR_END: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_OVER: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_UNDER: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_LEFT: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_RIGHT: ::std::os::raw::c_uint =
        8;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_DEFAULT: ::std::os::raw::c_uint
              =
        9;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_DEFAULT_ZH:
              ::std::os::raw::c_uint =
        10;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_FILL_MASK: ::std::os::raw::c_uint =
        8;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_FILLED: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_OPEN: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_SHAPE_MASK: ::std::os::raw::c_uint
              =
        7;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_DOT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_CIRCLE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_DOUBLE_CIRCLE:
              ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_TRIANGLE: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_SESAME: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_STRING: ::std::os::raw::c_uint =
        255;
    pub const NS_STYLE_TEXT_RENDERING_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_RENDERING_OPTIMIZESPEED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_TEXT_RENDERING_OPTIMIZELEGIBILITY:
              ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_RENDERING_GEOMETRICPRECISION:
              ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_COLOR_ADJUST_ECONOMY: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COLOR_ADJUST_EXACT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_COLOR_INTERPOLATION_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COLOR_INTERPOLATION_SRGB: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_COLOR_INTERPOLATION_LINEARRGB: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_VECTOR_EFFECT_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_VECTOR_EFFECT_NON_SCALING_STROKE:
              ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_BACKFACE_VISIBILITY_VISIBLE: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_BACKFACE_VISIBILITY_HIDDEN: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TRANSFORM_STYLE_FLAT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TRANSFORM_STYLE_PRESERVE_3D: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_CONTEXT_FILL_OPACITY: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CONTEXT_STROKE_OPACITY: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BLEND_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BLEND_MULTIPLY: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BLEND_SCREEN: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_BLEND_OVERLAY: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_BLEND_DARKEN: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_BLEND_LIGHTEN: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_BLEND_COLOR_DODGE: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_BLEND_COLOR_BURN: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_BLEND_HARD_LIGHT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_BLEND_SOFT_LIGHT: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_BLEND_DIFFERENCE: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_BLEND_EXCLUSION: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_BLEND_HUE: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_BLEND_SATURATION: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_BLEND_COLOR: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_BLEND_LUMINOSITY: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_MASK_COMPOSITE_ADD: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_MASK_COMPOSITE_SUBTRACT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_MASK_COMPOSITE_INTERSECT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_MASK_COMPOSITE_EXCLUDE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_CONTROL_CHARACTER_VISIBILITY_HIDDEN:
              ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_CONTROL_CHARACTER_VISIBILITY_VISIBLE:
              ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_COUNTER_SYSTEM_CYCLIC: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COUNTER_SYSTEM_NUMERIC: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_COUNTER_SYSTEM_ALPHABETIC: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_COUNTER_SYSTEM_SYMBOLIC: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_COUNTER_SYSTEM_ADDITIVE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_COUNTER_SYSTEM_FIXED: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_COUNTER_SYSTEM_EXTENDS: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_COUNTER_RANGE_INFINITE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COUNTER_SPEAKAS_BULLETS: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COUNTER_SPEAKAS_NUMBERS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_COUNTER_SPEAKAS_WORDS: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_COUNTER_SPEAKAS_SPELL_OUT: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_COUNTER_SPEAKAS_OTHER: ::std::os::raw::c_uint = 255;
    pub const NS_STYLE_SCROLL_BEHAVIOR_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SCROLL_BEHAVIOR_SMOOTH: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SCROLL_SNAP_TYPE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SCROLL_SNAP_TYPE_MANDATORY: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SCROLL_SNAP_TYPE_PROXIMITY: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_ORIENTATION_PORTRAIT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_ORIENTATION_LANDSCAPE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SCAN_PROGRESSIVE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SCAN_INTERLACE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_DISPLAY_MODE_BROWSER: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_DISPLAY_MODE_MINIMAL_UI: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_DISPLAY_MODE_STANDALONE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_INHERIT_MASK: ::std::os::raw::c_uint = 16777215;
    pub const NS_STYLE_HAS_TEXT_DECORATION_LINES: ::std::os::raw::c_uint =
        16777216;
    pub const NS_STYLE_HAS_PSEUDO_ELEMENT_DATA: ::std::os::raw::c_uint =
        33554432;
    pub const NS_STYLE_RELEVANT_LINK_VISITED: ::std::os::raw::c_uint =
        67108864;
    pub const NS_STYLE_IS_STYLE_IF_VISITED: ::std::os::raw::c_uint =
        134217728;
    pub const NS_STYLE_CHILD_USES_GRANDANCESTOR_STYLE: ::std::os::raw::c_uint
              =
        268435456;
    pub const NS_STYLE_IS_SHARED: ::std::os::raw::c_uint = 536870912;
    pub const NS_STYLE_IS_GOING_AWAY: ::std::os::raw::c_uint = 1073741824;
    pub const NS_STYLE_SUPPRESS_LINEBREAK: ::std::os::raw::c_uint =
        2147483648;
    pub const NS_STYLE_IN_DISPLAY_NONE_SUBTREE: ::std::os::raw::c_ulonglong =
        4294967296;
    pub const NS_STYLE_INELIGIBLE_FOR_SHARING: ::std::os::raw::c_ulonglong =
        8589934592;
    pub const NS_STYLE_HAS_CHILD_THAT_USES_RESET_STYLE:
              ::std::os::raw::c_ulonglong =
        17179869184;
    pub const NS_STYLE_IS_TEXT_COMBINED: ::std::os::raw::c_ulonglong =
        34359738368;
    pub const NS_STYLE_CONTEXT_TYPE_SHIFT: ::std::os::raw::c_uint = 36;
    pub mod mozilla {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub const SERVO_PREF_ENABLED_align_content: bool = false;
        pub const SERVO_PREF_ENABLED_align_items: bool = false;
        pub const SERVO_PREF_ENABLED_align_self: bool = false;
        pub const SERVO_PREF_ENABLED_all: bool = true;
        pub const SERVO_PREF_ENABLED_animation: bool = false;
        pub const SERVO_PREF_ENABLED_animation_delay: bool = false;
        pub const SERVO_PREF_ENABLED_animation_direction: bool = false;
        pub const SERVO_PREF_ENABLED_animation_duration: bool = false;
        pub const SERVO_PREF_ENABLED_animation_fill_mode: bool = false;
        pub const SERVO_PREF_ENABLED_animation_iteration_count: bool = false;
        pub const SERVO_PREF_ENABLED_animation_name: bool = false;
        pub const SERVO_PREF_ENABLED_animation_play_state: bool = false;
        pub const SERVO_PREF_ENABLED_animation_timing_function: bool = false;
        pub const SERVO_PREF_ENABLED__moz_appearance: bool = false;
        pub const SERVO_PREF_ENABLED_backface_visibility: bool = false;
        pub const SERVO_PREF_ENABLED_background: bool = false;
        pub const SERVO_PREF_ENABLED_background_attachment: bool = false;
        pub const SERVO_PREF_ENABLED_background_blend_mode: bool = true;
        pub const SERVO_PREF_ENABLED_background_clip: bool = false;
        pub const SERVO_PREF_ENABLED_background_color: bool = false;
        pub const SERVO_PREF_ENABLED_background_image: bool = false;
        pub const SERVO_PREF_ENABLED_background_origin: bool = false;
        pub const SERVO_PREF_ENABLED_background_position: bool = false;
        pub const SERVO_PREF_ENABLED_background_position_x: bool = false;
        pub const SERVO_PREF_ENABLED_background_position_y: bool = false;
        pub const SERVO_PREF_ENABLED_background_repeat: bool = false;
        pub const SERVO_PREF_ENABLED_background_size: bool = false;
        pub const SERVO_PREF_ENABLED__moz_binding: bool = false;
        pub const SERVO_PREF_ENABLED_block_size: bool = false;
        pub const SERVO_PREF_ENABLED_border: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_end: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_end_color: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_end_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_end_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_start: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_start_color: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_start_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_block_start_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_bottom: bool = false;
        pub const SERVO_PREF_ENABLED_border_bottom_color: bool = false;
        pub const SERVO_PREF_ENABLED__moz_border_bottom_colors: bool = false;
        pub const SERVO_PREF_ENABLED_border_bottom_left_radius: bool = false;
        pub const SERVO_PREF_ENABLED_border_bottom_right_radius: bool = false;
        pub const SERVO_PREF_ENABLED_border_bottom_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_bottom_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_collapse: bool = false;
        pub const SERVO_PREF_ENABLED_border_color: bool = false;
        pub const SERVO_PREF_ENABLED_border_image: bool = false;
        pub const SERVO_PREF_ENABLED_border_image_outset: bool = false;
        pub const SERVO_PREF_ENABLED_border_image_repeat: bool = false;
        pub const SERVO_PREF_ENABLED_border_image_slice: bool = false;
        pub const SERVO_PREF_ENABLED_border_image_source: bool = false;
        pub const SERVO_PREF_ENABLED_border_image_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_end: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_end_color: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_end_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_end_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_start: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_start_color: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_start_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_inline_start_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_left: bool = false;
        pub const SERVO_PREF_ENABLED_border_left_color: bool = false;
        pub const SERVO_PREF_ENABLED__moz_border_left_colors: bool = false;
        pub const SERVO_PREF_ENABLED_border_left_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_left_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_radius: bool = false;
        pub const SERVO_PREF_ENABLED_border_right: bool = false;
        pub const SERVO_PREF_ENABLED_border_right_color: bool = false;
        pub const SERVO_PREF_ENABLED__moz_border_right_colors: bool = false;
        pub const SERVO_PREF_ENABLED_border_right_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_right_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_spacing: bool = false;
        pub const SERVO_PREF_ENABLED_border_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_top: bool = false;
        pub const SERVO_PREF_ENABLED_border_top_color: bool = false;
        pub const SERVO_PREF_ENABLED__moz_border_top_colors: bool = false;
        pub const SERVO_PREF_ENABLED_border_top_left_radius: bool = false;
        pub const SERVO_PREF_ENABLED_border_top_right_radius: bool = false;
        pub const SERVO_PREF_ENABLED_border_top_style: bool = false;
        pub const SERVO_PREF_ENABLED_border_top_width: bool = false;
        pub const SERVO_PREF_ENABLED_border_width: bool = false;
        pub const SERVO_PREF_ENABLED_bottom: bool = false;
        pub const SERVO_PREF_ENABLED__moz_box_align: bool = false;
        pub const SERVO_PREF_ENABLED_box_decoration_break: bool = true;
        pub const SERVO_PREF_ENABLED__moz_box_direction: bool = false;
        pub const SERVO_PREF_ENABLED__moz_box_flex: bool = false;
        pub const SERVO_PREF_ENABLED__moz_box_ordinal_group: bool = false;
        pub const SERVO_PREF_ENABLED__moz_box_orient: bool = false;
        pub const SERVO_PREF_ENABLED__moz_box_pack: bool = false;
        pub const SERVO_PREF_ENABLED_box_shadow: bool = false;
        pub const SERVO_PREF_ENABLED_box_sizing: bool = false;
        pub const SERVO_PREF_ENABLED_caption_side: bool = false;
        pub const SERVO_PREF_ENABLED_caret_color: bool = false;
        pub const SERVO_PREF_ENABLED_clear: bool = false;
        pub const SERVO_PREF_ENABLED_clip: bool = false;
        pub const SERVO_PREF_ENABLED_clip_path: bool = false;
        pub const SERVO_PREF_ENABLED_clip_rule: bool = false;
        pub const SERVO_PREF_ENABLED_color: bool = false;
        pub const SERVO_PREF_ENABLED_color_adjust: bool = true;
        pub const SERVO_PREF_ENABLED_color_interpolation: bool = false;
        pub const SERVO_PREF_ENABLED_color_interpolation_filters: bool =
            false;
        pub const SERVO_PREF_ENABLED_column_count: bool = false;
        pub const SERVO_PREF_ENABLED_column_fill: bool = false;
        pub const SERVO_PREF_ENABLED_column_gap: bool = false;
        pub const SERVO_PREF_ENABLED_column_rule: bool = false;
        pub const SERVO_PREF_ENABLED_column_rule_color: bool = false;
        pub const SERVO_PREF_ENABLED_column_rule_style: bool = false;
        pub const SERVO_PREF_ENABLED_column_rule_width: bool = false;
        pub const SERVO_PREF_ENABLED_column_width: bool = false;
        pub const SERVO_PREF_ENABLED_columns: bool = false;
        pub const SERVO_PREF_ENABLED_contain: bool = true;
        pub const SERVO_PREF_ENABLED_content: bool = false;
        pub const SERVO_PREF_ENABLED__moz_control_character_visibility: bool =
            false;
        pub const SERVO_PREF_ENABLED_counter_increment: bool = false;
        pub const SERVO_PREF_ENABLED_counter_reset: bool = false;
        pub const SERVO_PREF_ENABLED_cursor: bool = false;
        pub const SERVO_PREF_ENABLED_direction: bool = false;
        pub const SERVO_PREF_ENABLED_display: bool = false;
        pub const SERVO_PREF_ENABLED_dominant_baseline: bool = false;
        pub const SERVO_PREF_ENABLED_empty_cells: bool = false;
        pub const SERVO_PREF_ENABLED_fill: bool = false;
        pub const SERVO_PREF_ENABLED_fill_opacity: bool = false;
        pub const SERVO_PREF_ENABLED_fill_rule: bool = false;
        pub const SERVO_PREF_ENABLED_filter: bool = false;
        pub const SERVO_PREF_ENABLED_flex: bool = false;
        pub const SERVO_PREF_ENABLED_flex_basis: bool = false;
        pub const SERVO_PREF_ENABLED_flex_direction: bool = false;
        pub const SERVO_PREF_ENABLED_flex_flow: bool = false;
        pub const SERVO_PREF_ENABLED_flex_grow: bool = false;
        pub const SERVO_PREF_ENABLED_flex_shrink: bool = false;
        pub const SERVO_PREF_ENABLED_flex_wrap: bool = false;
        pub const SERVO_PREF_ENABLED_float_: bool = false;
        pub const SERVO_PREF_ENABLED__moz_float_edge: bool = false;
        pub const SERVO_PREF_ENABLED_flood_color: bool = false;
        pub const SERVO_PREF_ENABLED_flood_opacity: bool = false;
        pub const SERVO_PREF_ENABLED_font: bool = false;
        pub const SERVO_PREF_ENABLED_font_family: bool = false;
        pub const SERVO_PREF_ENABLED_font_feature_settings: bool = false;
        pub const SERVO_PREF_ENABLED_font_kerning: bool = false;
        pub const SERVO_PREF_ENABLED_font_language_override: bool = false;
        pub const SERVO_PREF_ENABLED_font_size: bool = false;
        pub const SERVO_PREF_ENABLED_font_size_adjust: bool = false;
        pub const SERVO_PREF_ENABLED_font_stretch: bool = false;
        pub const SERVO_PREF_ENABLED_font_style: bool = false;
        pub const SERVO_PREF_ENABLED_font_synthesis: bool = false;
        pub const SERVO_PREF_ENABLED_font_variant: bool = false;
        pub const SERVO_PREF_ENABLED_font_variant_alternates: bool = false;
        pub const SERVO_PREF_ENABLED_font_variant_caps: bool = false;
        pub const SERVO_PREF_ENABLED_font_variant_east_asian: bool = false;
        pub const SERVO_PREF_ENABLED_font_variant_ligatures: bool = false;
        pub const SERVO_PREF_ENABLED_font_variant_numeric: bool = false;
        pub const SERVO_PREF_ENABLED_font_variant_position: bool = false;
        pub const SERVO_PREF_ENABLED_font_variation_settings: bool = true;
        pub const SERVO_PREF_ENABLED_font_weight: bool = false;
        pub const SERVO_PREF_ENABLED__moz_force_broken_image_icon: bool =
            false;
        pub const SERVO_PREF_ENABLED_grid: bool = true;
        pub const SERVO_PREF_ENABLED_grid_area: bool = true;
        pub const SERVO_PREF_ENABLED_grid_auto_columns: bool = true;
        pub const SERVO_PREF_ENABLED_grid_auto_flow: bool = true;
        pub const SERVO_PREF_ENABLED_grid_auto_rows: bool = true;
        pub const SERVO_PREF_ENABLED_grid_column: bool = true;
        pub const SERVO_PREF_ENABLED_grid_column_end: bool = true;
        pub const SERVO_PREF_ENABLED_grid_column_gap: bool = true;
        pub const SERVO_PREF_ENABLED_grid_column_start: bool = true;
        pub const SERVO_PREF_ENABLED_grid_gap: bool = true;
        pub const SERVO_PREF_ENABLED_grid_row: bool = true;
        pub const SERVO_PREF_ENABLED_grid_row_end: bool = true;
        pub const SERVO_PREF_ENABLED_grid_row_gap: bool = true;
        pub const SERVO_PREF_ENABLED_grid_row_start: bool = true;
        pub const SERVO_PREF_ENABLED_grid_template: bool = true;
        pub const SERVO_PREF_ENABLED_grid_template_areas: bool = true;
        pub const SERVO_PREF_ENABLED_grid_template_columns: bool = true;
        pub const SERVO_PREF_ENABLED_grid_template_rows: bool = true;
        pub const SERVO_PREF_ENABLED_height: bool = false;
        pub const SERVO_PREF_ENABLED_hyphens: bool = false;
        pub const SERVO_PREF_ENABLED_initial_letter: bool = true;
        pub const SERVO_PREF_ENABLED_image_orientation: bool = true;
        pub const SERVO_PREF_ENABLED__moz_image_region: bool = false;
        pub const SERVO_PREF_ENABLED_image_rendering: bool = false;
        pub const SERVO_PREF_ENABLED_ime_mode: bool = false;
        pub const SERVO_PREF_ENABLED_inline_size: bool = false;
        pub const SERVO_PREF_ENABLED_isolation: bool = true;
        pub const SERVO_PREF_ENABLED_justify_content: bool = false;
        pub const SERVO_PREF_ENABLED_justify_items: bool = false;
        pub const SERVO_PREF_ENABLED_justify_self: bool = false;
        pub const SERVO_PREF_ENABLED__x_lang: bool = false;
        pub const SERVO_PREF_ENABLED_left: bool = false;
        pub const SERVO_PREF_ENABLED_letter_spacing: bool = false;
        pub const SERVO_PREF_ENABLED_lighting_color: bool = false;
        pub const SERVO_PREF_ENABLED_line_height: bool = false;
        pub const SERVO_PREF_ENABLED_list_style: bool = false;
        pub const SERVO_PREF_ENABLED_list_style_image: bool = false;
        pub const SERVO_PREF_ENABLED_list_style_position: bool = false;
        pub const SERVO_PREF_ENABLED_list_style_type: bool = false;
        pub const SERVO_PREF_ENABLED_margin: bool = false;
        pub const SERVO_PREF_ENABLED_margin_block_end: bool = false;
        pub const SERVO_PREF_ENABLED_margin_block_start: bool = false;
        pub const SERVO_PREF_ENABLED_margin_bottom: bool = false;
        pub const SERVO_PREF_ENABLED_margin_inline_end: bool = false;
        pub const SERVO_PREF_ENABLED_margin_inline_start: bool = false;
        pub const SERVO_PREF_ENABLED_margin_left: bool = false;
        pub const SERVO_PREF_ENABLED_margin_right: bool = false;
        pub const SERVO_PREF_ENABLED_margin_top: bool = false;
        pub const SERVO_PREF_ENABLED_marker: bool = false;
        pub const SERVO_PREF_ENABLED_marker_end: bool = false;
        pub const SERVO_PREF_ENABLED_marker_mid: bool = false;
        pub const SERVO_PREF_ENABLED_marker_start: bool = false;
        pub const SERVO_PREF_ENABLED_mask: bool = false;
        pub const SERVO_PREF_ENABLED_mask_clip: bool = false;
        pub const SERVO_PREF_ENABLED_mask_composite: bool = false;
        pub const SERVO_PREF_ENABLED_mask_image: bool = false;
        pub const SERVO_PREF_ENABLED_mask_mode: bool = false;
        pub const SERVO_PREF_ENABLED_mask_origin: bool = false;
        pub const SERVO_PREF_ENABLED_mask_position: bool = false;
        pub const SERVO_PREF_ENABLED_mask_position_x: bool = false;
        pub const SERVO_PREF_ENABLED_mask_position_y: bool = false;
        pub const SERVO_PREF_ENABLED_mask_repeat: bool = false;
        pub const SERVO_PREF_ENABLED_mask_size: bool = false;
        pub const SERVO_PREF_ENABLED_mask_type: bool = false;
        pub const SERVO_PREF_ENABLED__moz_math_display: bool = false;
        pub const SERVO_PREF_ENABLED__moz_math_variant: bool = false;
        pub const SERVO_PREF_ENABLED_max_block_size: bool = false;
        pub const SERVO_PREF_ENABLED_max_height: bool = false;
        pub const SERVO_PREF_ENABLED_max_inline_size: bool = false;
        pub const SERVO_PREF_ENABLED_max_width: bool = false;
        pub const SERVO_PREF_ENABLED_min_block_size: bool = false;
        pub const SERVO_PREF_ENABLED__moz_min_font_size_ratio: bool = false;
        pub const SERVO_PREF_ENABLED_min_height: bool = false;
        pub const SERVO_PREF_ENABLED_min_inline_size: bool = false;
        pub const SERVO_PREF_ENABLED_min_width: bool = false;
        pub const SERVO_PREF_ENABLED_mix_blend_mode: bool = true;
        pub const SERVO_PREF_ENABLED_object_fit: bool = true;
        pub const SERVO_PREF_ENABLED_object_position: bool = true;
        pub const SERVO_PREF_ENABLED_offset_block_end: bool = false;
        pub const SERVO_PREF_ENABLED_offset_block_start: bool = false;
        pub const SERVO_PREF_ENABLED_offset_inline_end: bool = false;
        pub const SERVO_PREF_ENABLED_offset_inline_start: bool = false;
        pub const SERVO_PREF_ENABLED_opacity: bool = false;
        pub const SERVO_PREF_ENABLED_order: bool = false;
        pub const SERVO_PREF_ENABLED__moz_orient: bool = false;
        pub const SERVO_PREF_ENABLED__moz_osx_font_smoothing: bool = true;
        pub const SERVO_PREF_ENABLED_outline: bool = false;
        pub const SERVO_PREF_ENABLED_outline_color: bool = false;
        pub const SERVO_PREF_ENABLED_outline_offset: bool = false;
        pub const SERVO_PREF_ENABLED__moz_outline_radius: bool = false;
        pub const SERVO_PREF_ENABLED__moz_outline_radius_bottomleft: bool =
            false;
        pub const SERVO_PREF_ENABLED__moz_outline_radius_bottomright: bool =
            false;
        pub const SERVO_PREF_ENABLED__moz_outline_radius_topleft: bool =
            false;
        pub const SERVO_PREF_ENABLED__moz_outline_radius_topright: bool =
            false;
        pub const SERVO_PREF_ENABLED_outline_style: bool = false;
        pub const SERVO_PREF_ENABLED_outline_width: bool = false;
        pub const SERVO_PREF_ENABLED_overflow: bool = false;
        pub const SERVO_PREF_ENABLED_overflow_clip_box: bool = true;
        pub const SERVO_PREF_ENABLED_overflow_x: bool = false;
        pub const SERVO_PREF_ENABLED_overflow_y: bool = false;
        pub const SERVO_PREF_ENABLED_padding: bool = false;
        pub const SERVO_PREF_ENABLED_padding_block_end: bool = false;
        pub const SERVO_PREF_ENABLED_padding_block_start: bool = false;
        pub const SERVO_PREF_ENABLED_padding_bottom: bool = false;
        pub const SERVO_PREF_ENABLED_padding_inline_end: bool = false;
        pub const SERVO_PREF_ENABLED_padding_inline_start: bool = false;
        pub const SERVO_PREF_ENABLED_padding_left: bool = false;
        pub const SERVO_PREF_ENABLED_padding_right: bool = false;
        pub const SERVO_PREF_ENABLED_padding_top: bool = false;
        pub const SERVO_PREF_ENABLED_page_break_after: bool = false;
        pub const SERVO_PREF_ENABLED_page_break_before: bool = false;
        pub const SERVO_PREF_ENABLED_page_break_inside: bool = false;
        pub const SERVO_PREF_ENABLED_paint_order: bool = true;
        pub const SERVO_PREF_ENABLED_perspective: bool = false;
        pub const SERVO_PREF_ENABLED_perspective_origin: bool = false;
        pub const SERVO_PREF_ENABLED_place_content: bool = false;
        pub const SERVO_PREF_ENABLED_place_items: bool = false;
        pub const SERVO_PREF_ENABLED_place_self: bool = false;
        pub const SERVO_PREF_ENABLED_pointer_events: bool = false;
        pub const SERVO_PREF_ENABLED_position: bool = false;
        pub const SERVO_PREF_ENABLED_quotes: bool = false;
        pub const SERVO_PREF_ENABLED_resize: bool = false;
        pub const SERVO_PREF_ENABLED_right: bool = false;
        pub const SERVO_PREF_ENABLED_ruby_align: bool = false;
        pub const SERVO_PREF_ENABLED_ruby_position: bool = false;
        pub const SERVO_PREF_ENABLED__moz_script_level: bool = false;
        pub const SERVO_PREF_ENABLED__moz_script_min_size: bool = false;
        pub const SERVO_PREF_ENABLED__moz_script_size_multiplier: bool =
            false;
        pub const SERVO_PREF_ENABLED_scroll_behavior: bool = true;
        pub const SERVO_PREF_ENABLED_scroll_snap_coordinate: bool = true;
        pub const SERVO_PREF_ENABLED_scroll_snap_destination: bool = true;
        pub const SERVO_PREF_ENABLED_scroll_snap_points_x: bool = true;
        pub const SERVO_PREF_ENABLED_scroll_snap_points_y: bool = true;
        pub const SERVO_PREF_ENABLED_scroll_snap_type: bool = true;
        pub const SERVO_PREF_ENABLED_scroll_snap_type_x: bool = true;
        pub const SERVO_PREF_ENABLED_scroll_snap_type_y: bool = true;
        pub const SERVO_PREF_ENABLED_shape_outside: bool = true;
        pub const SERVO_PREF_ENABLED_shape_rendering: bool = false;
        pub const SERVO_PREF_ENABLED__x_span: bool = false;
        pub const SERVO_PREF_ENABLED__moz_stack_sizing: bool = false;
        pub const SERVO_PREF_ENABLED_stop_color: bool = false;
        pub const SERVO_PREF_ENABLED_stop_opacity: bool = false;
        pub const SERVO_PREF_ENABLED_stroke: bool = false;
        pub const SERVO_PREF_ENABLED_stroke_dasharray: bool = false;
        pub const SERVO_PREF_ENABLED_stroke_dashoffset: bool = false;
        pub const SERVO_PREF_ENABLED_stroke_linecap: bool = false;
        pub const SERVO_PREF_ENABLED_stroke_linejoin: bool = false;
        pub const SERVO_PREF_ENABLED_stroke_miterlimit: bool = false;
        pub const SERVO_PREF_ENABLED_stroke_opacity: bool = false;
        pub const SERVO_PREF_ENABLED_stroke_width: bool = false;
        pub const SERVO_PREF_ENABLED__x_system_font: bool = false;
        pub const SERVO_PREF_ENABLED__moz_tab_size: bool = false;
        pub const SERVO_PREF_ENABLED_table_layout: bool = false;
        pub const SERVO_PREF_ENABLED_text_align: bool = false;
        pub const SERVO_PREF_ENABLED_text_align_last: bool = false;
        pub const SERVO_PREF_ENABLED_text_anchor: bool = false;
        pub const SERVO_PREF_ENABLED_text_combine_upright: bool = true;
        pub const SERVO_PREF_ENABLED_text_decoration: bool = false;
        pub const SERVO_PREF_ENABLED_text_decoration_color: bool = false;
        pub const SERVO_PREF_ENABLED_text_decoration_line: bool = false;
        pub const SERVO_PREF_ENABLED_text_decoration_style: bool = false;
        pub const SERVO_PREF_ENABLED_text_emphasis: bool = false;
        pub const SERVO_PREF_ENABLED_text_emphasis_color: bool = false;
        pub const SERVO_PREF_ENABLED_text_emphasis_position: bool = false;
        pub const SERVO_PREF_ENABLED_text_emphasis_style: bool = false;
        pub const SERVO_PREF_ENABLED__webkit_text_fill_color: bool = true;
        pub const SERVO_PREF_ENABLED_text_indent: bool = false;
        pub const SERVO_PREF_ENABLED_text_orientation: bool = false;
        pub const SERVO_PREF_ENABLED_text_overflow: bool = false;
        pub const SERVO_PREF_ENABLED_text_rendering: bool = false;
        pub const SERVO_PREF_ENABLED_text_shadow: bool = false;
        pub const SERVO_PREF_ENABLED__moz_text_size_adjust: bool = false;
        pub const SERVO_PREF_ENABLED__webkit_text_stroke: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_text_stroke_color: bool = true;
        pub const SERVO_PREF_ENABLED__webkit_text_stroke_width: bool = true;
        pub const SERVO_PREF_ENABLED_text_transform: bool = false;
        pub const SERVO_PREF_ENABLED__x_text_zoom: bool = false;
        pub const SERVO_PREF_ENABLED_top: bool = false;
        pub const SERVO_PREF_ENABLED__moz_top_layer: bool = false;
        pub const SERVO_PREF_ENABLED_touch_action: bool = true;
        pub const SERVO_PREF_ENABLED_transform: bool = false;
        pub const SERVO_PREF_ENABLED__moz_transform: bool = true;
        pub const SERVO_PREF_ENABLED_transform_box: bool = true;
        pub const SERVO_PREF_ENABLED_transform_origin: bool = false;
        pub const SERVO_PREF_ENABLED_transform_style: bool = false;
        pub const SERVO_PREF_ENABLED_transition: bool = false;
        pub const SERVO_PREF_ENABLED_transition_delay: bool = false;
        pub const SERVO_PREF_ENABLED_transition_duration: bool = false;
        pub const SERVO_PREF_ENABLED_transition_property: bool = false;
        pub const SERVO_PREF_ENABLED_transition_timing_function: bool = false;
        pub const SERVO_PREF_ENABLED_unicode_bidi: bool = false;
        pub const SERVO_PREF_ENABLED__moz_user_focus: bool = false;
        pub const SERVO_PREF_ENABLED__moz_user_input: bool = false;
        pub const SERVO_PREF_ENABLED__moz_user_modify: bool = false;
        pub const SERVO_PREF_ENABLED__moz_user_select: bool = false;
        pub const SERVO_PREF_ENABLED_vector_effect: bool = false;
        pub const SERVO_PREF_ENABLED_vertical_align: bool = false;
        pub const SERVO_PREF_ENABLED_visibility: bool = false;
        pub const SERVO_PREF_ENABLED_white_space: bool = false;
        pub const SERVO_PREF_ENABLED_width: bool = false;
        pub const SERVO_PREF_ENABLED_will_change: bool = false;
        pub const SERVO_PREF_ENABLED__moz_window_dragging: bool = false;
        pub const SERVO_PREF_ENABLED__moz_window_shadow: bool = false;
        pub const SERVO_PREF_ENABLED_word_break: bool = false;
        pub const SERVO_PREF_ENABLED_word_spacing: bool = false;
        pub const SERVO_PREF_ENABLED_overflow_wrap: bool = false;
        pub const SERVO_PREF_ENABLED_writing_mode: bool = false;
        pub const SERVO_PREF_ENABLED_z_index: bool = false;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct fallible_t {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_fallible_t() {
            assert_eq!(::std::mem::size_of::<fallible_t>() , 1usize , concat !
                       ( "Size of: " , stringify ! ( fallible_t ) ));
            assert_eq! (::std::mem::align_of::<fallible_t>() , 1usize , concat
                        ! ( "Alignment of " , stringify ! ( fallible_t ) ));
        }
        impl Clone for fallible_t {
            fn clone(&self) -> Self { *self }
        }
        /** Convenient aliases. */
        pub type TrueType = u8;
        pub type FalseType = u8;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            /**
 * LinkedList supports refcounted elements using this adapter class. Clients
 * using LinkedList<RefPtr<T>> will get a data structure that holds a strong
 * reference to T as long as T is in the list.
 */
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct LinkedListElementTraits<T> {
                pub _address: u8,
                pub _phantom_0: ::std::marker::PhantomData<T>,
            }
            pub type LinkedListElementTraits_RawType<T> = *mut T;
            pub type LinkedListElementTraits_ConstRawType<T> = *mut T;
            pub type LinkedListElementTraits_ClientType<T> = *mut T;
            pub type LinkedListElementTraits_ConstClientType<T> = *mut T;
        }
        pub type MallocSizeOf =
            ::std::option::Option<unsafe extern "C" fn(p:
                                                           *const ::std::os::raw::c_void)
                                      -> ::std::os::raw::c_ulong>;
        #[repr(C)]
        #[derive(Debug)]
        pub struct OwningNonNull<T> {
            pub mPtr: root::RefPtr<T>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StaticRefPtr<T> {
            pub mRawPtr: *mut T,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct LinkedListElement<T> {
            pub mNext: *mut root::mozilla::LinkedListElement<T>,
            pub mPrev: *mut root::mozilla::LinkedListElement<T>,
            pub mIsSentinel: bool,
        }
        pub type LinkedListElement_Traits<T> =
            root::mozilla::detail::LinkedListElementTraits<T>;
        pub type LinkedListElement_RawType<T> =
            root::mozilla::LinkedListElement_Traits<T>;
        pub type LinkedListElement_ConstRawType<T> =
            root::mozilla::LinkedListElement_Traits<T>;
        pub type LinkedListElement_ClientType<T> =
            root::mozilla::LinkedListElement_Traits<T>;
        pub type LinkedListElement_ConstClientType<T> =
            root::mozilla::LinkedListElement_Traits<T>;
        pub const LinkedListElement_NodeKind_Sentinel:
                  root::mozilla::LinkedListElement_NodeKind =
            LinkedListElement_NodeKind::Normal;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LinkedListElement_NodeKind { Normal = 0, }
        #[repr(C)]
        #[derive(Debug)]
        pub struct LinkedList<T> {
            pub sentinel: root::mozilla::LinkedListElement<T>,
        }
        pub type LinkedList_Traits<T> =
            root::mozilla::detail::LinkedListElementTraits<T>;
        pub type LinkedList_RawType<T> = root::mozilla::LinkedList_Traits<T>;
        pub type LinkedList_ConstRawType<T> =
            root::mozilla::LinkedList_Traits<T>;
        pub type LinkedList_ClientType<T> =
            root::mozilla::LinkedList_Traits<T>;
        pub type LinkedList_ConstClientType<T> =
            root::mozilla::LinkedList_Traits<T>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct LinkedList_Iterator<T> {
            pub mCurrent: root::mozilla::LinkedList_RawType<T>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ReverseIterator<IteratorT> {
            pub mCurrent: IteratorT,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AlignedStorage2<T> {
            pub u: root::mozilla::AlignedStorage2_U<T>,
            pub _phantom_0: ::std::marker::PhantomData<T>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AlignedStorage2_U<T> {
            pub mBytes: root::__BindgenUnionField<*mut ::std::os::raw::c_char>,
            pub mDummy: root::__BindgenUnionField<u64>,
            pub bindgen_union_field: u64,
            pub _phantom_0: ::std::marker::PhantomData<T>,
        }
        /**
 * Pair is the logical concatenation of an instance of A with an instance B.
 * Space is conserved when possible.  Neither A nor B may be a final class.
 *
 * It's typically clearer to have individual A and B member fields.  Except if
 * you want the space-conserving qualities of Pair, you're probably better off
 * not using this!
 *
 * No guarantees are provided about the memory layout of A and B, the order of
 * initialization or destruction of A and B, and so on.  (This is approximately
 * required to optimize space usage.)  The first/second names are merely
 * conceptual!
 */
        #[repr(C)]
        pub struct Pair<A, B> {
            pub _address: u8,
            pub _phantom_0: ::std::marker::PhantomData<A>,
            pub _phantom_1: ::std::marker::PhantomData<B>,
        }
        pub type Pair_Base = [u8; 0usize];
        /**
 * A default deletion policy using plain old operator delete.
 *
 * Note that this type can be specialized, but authors should beware of the risk
 * that the specialization may at some point cease to match (either because it
 * gets moved to a different compilation unit or the signature changes). If the
 * non-specialized (|delete|-based) version compiles for that type but does the
 * wrong thing, bad things could happen.
 *
 * This is a non-issue for types which are always incomplete (i.e. opaque handle
 * types), since |delete|-ing such a type will always trigger a compilation
 * error.
 */
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DefaultDelete<T> {
            pub _address: u8,
            pub _phantom_0: ::std::marker::PhantomData<T>,
        }
        pub type TimeStampValue = u64;
        /**
 * Instances of this class represent moments in time, or a special
 * "null" moment. We do not use the non-monotonic system clock or
 * local time, since they can be reset, causing apparent backward
 * travel in time, which can confuse algorithms. Instead we measure
 * elapsed time according to the system.  This time can never go
 * backwards (i.e. it never wraps around, at least not in less than
 * five million years of system elapsed time). It might not advance
 * while the system is sleeping. If TimeStamp::SetNow() is not called
 * at all for hours or days, we might not notice the passage of some
 * of that time.
 *
 * We deliberately do not expose a way to convert TimeStamps to some
 * particular unit. All you can do is compute a difference between two
 * TimeStamps to get a TimeDuration. You can also add a TimeDuration
 * to a TimeStamp to get a new TimeStamp. You can't do something
 * meaningless like add two TimeStamps.
 *
 * Internally this is implemented as either a wrapper around
 *   - high-resolution, monotonic, system clocks if they exist on this
 *     platform
 *   - PRIntervalTime otherwise.  We detect wraparounds of
 *     PRIntervalTime and work around them.
 *
 * This class is similar to C++11's time_point, however it is
 * explicitly nullable and provides an IsNull() method. time_point
 * is initialized to the clock's epoch and provides a
 * time_since_epoch() method that functions similiarly. i.e.
 * t.IsNull() is equivalent to t.time_since_epoch() == decltype(t)::duration::zero();
 */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct TimeStamp {
            /**
   * When built with PRIntervalTime, a value of 0 means this instance
   * is "null". Otherwise, the low 32 bits represent a PRIntervalTime,
   * and the high 32 bits represent a counter of the number of
   * rollovers of PRIntervalTime that we've seen. This counter starts
   * at 1 to avoid a real time colliding with the "null" value.
   *
   * PR_INTERVAL_MAX is set at 100,000 ticks per second. So the minimum
   * time to wrap around is about 2^64/100000 seconds, i.e. about
   * 5,849,424 years.
   *
   * When using a system clock, a value is system dependent.
   */
            pub mValue: root::mozilla::TimeStampValue,
        }
        #[test]
        fn bindgen_test_layout_TimeStamp() {
            assert_eq!(::std::mem::size_of::<TimeStamp>() , 8usize , concat !
                       ( "Size of: " , stringify ! ( TimeStamp ) ));
            assert_eq! (::std::mem::align_of::<TimeStamp>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( TimeStamp ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const TimeStamp ) ) . mValue as * const
                        _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( TimeStamp ) ,
                        "::" , stringify ! ( mValue ) ));
        }
        impl Clone for TimeStamp {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct MallocAllocPolicy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_MallocAllocPolicy() {
            assert_eq!(::std::mem::size_of::<MallocAllocPolicy>() , 1usize ,
                       concat ! (
                       "Size of: " , stringify ! ( MallocAllocPolicy ) ));
            assert_eq! (::std::mem::align_of::<MallocAllocPolicy>() , 1usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( MallocAllocPolicy )
                        ));
        }
        impl Clone for MallocAllocPolicy {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ThreadSafeAutoRefCnt {
            pub mValue: u64,
        }
        pub const ThreadSafeAutoRefCnt_isThreadSafe: bool = true;
        #[test]
        fn bindgen_test_layout_ThreadSafeAutoRefCnt() {
            assert_eq!(::std::mem::size_of::<ThreadSafeAutoRefCnt>() , 8usize
                       , concat ! (
                       "Size of: " , stringify ! ( ThreadSafeAutoRefCnt ) ));
            assert_eq! (::std::mem::align_of::<ThreadSafeAutoRefCnt>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! ( ThreadSafeAutoRefCnt )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ThreadSafeAutoRefCnt ) ) . mValue
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ThreadSafeAutoRefCnt ) , "::" , stringify ! ( mValue )
                        ));
        }
        impl Clone for ThreadSafeAutoRefCnt {
            fn clone(&self) -> Self { *self }
        }
        pub mod gfx {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type IntRegion = [u64; 3usize];
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Color {
                pub _bindgen_opaque_blob: [u32; 4usize],
            }
            #[test]
            fn bindgen_test_layout_Color() {
                assert_eq!(::std::mem::size_of::<Color>() , 16usize , concat !
                           ( "Size of: " , stringify ! ( Color ) ));
                assert_eq! (::std::mem::align_of::<Color>() , 4usize , concat
                            ! ( "Alignment of " , stringify ! ( Color ) ));
            }
            impl Clone for Color {
                fn clone(&self) -> Self { *self }
            }
            pub type IntPoint = [u32; 2usize];
            pub type IntMargin = [u32; 4usize];
            pub type IntRect = [u32; 4usize];
            pub type Matrix4x4 = [u32; 16usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct SourceSurface([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DrawTarget([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Path([u8; 0]);
        }
        pub mod layers {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct LayerManager([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ContainerLayer([u8; 0]);
            /**
 * The viewport and displayport metrics for the painted frame at the
 * time of a layer-tree transaction.  These metrics are especially
 * useful for shadow layers, because the metrics values are updated
 * atomically with new pixels.
 */
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct FrameMetrics {
                pub mScrollId: root::mozilla::layers::FrameMetrics_ViewID,
                pub mPresShellResolution: f32,
                pub mCompositionBounds: root::mozilla::ParentLayerRect,
                pub mDisplayPort: root::mozilla::CSSRect,
                pub mCriticalDisplayPort: root::mozilla::CSSRect,
                pub mScrollableRect: root::mozilla::CSSRect,
                pub mCumulativeResolution: root::mozilla::LayoutDeviceToLayerScale2D,
                pub mDevPixelsPerCSSPixel: root::mozilla::CSSToLayoutDeviceScale,
                pub mScrollOffset: root::mozilla::CSSPoint,
                pub mZoom: root::mozilla::CSSToParentLayerScale2D,
                pub mScrollGeneration: u32,
                pub mSmoothScrollOffset: root::mozilla::CSSPoint,
                pub mRootCompositionSize: root::mozilla::CSSSize,
                pub mDisplayPortMargins: root::mozilla::ScreenMargin,
                pub mPresShellId: u32,
                pub mViewport: root::mozilla::CSSRect,
                pub mExtraResolution: root::mozilla::ScreenToLayerScale2D,
                pub mPaintRequestTime: root::mozilla::TimeStamp,
                pub mScrollUpdateType: root::mozilla::layers::FrameMetrics_ScrollOffsetUpdateType,
                pub _bitfield_1: u8,
                pub __bindgen_padding_0: [u16; 3usize],
            }
            pub type FrameMetrics_ViewID = u64;
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum FrameMetrics_ScrollOffsetUpdateType {
                eNone = 0,
                eMainThread = 1,
                ePending = 2,
                eUserAction = 3,
                eRestore = 4,
                eSentinel = 5,
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla6layers12FrameMetrics14NULL_SCROLL_IDE"]
                pub static FrameMetrics_NULL_SCROLL_ID:
                           root::mozilla::layers::FrameMetrics_ViewID;
            }
            pub const FrameMetrics_START_SCROLL_ID:
                      root::mozilla::layers::FrameMetrics_ViewID =
                2;
            #[test]
            fn bindgen_test_layout_FrameMetrics() {
                assert_eq!(::std::mem::size_of::<FrameMetrics>() , 184usize ,
                           concat ! (
                           "Size of: " , stringify ! ( FrameMetrics ) ));
                assert_eq! (::std::mem::align_of::<FrameMetrics>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( FrameMetrics ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) . mScrollId
                            as * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! ( mScrollId )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mPresShellResolution as * const _ as usize } ,
                            8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mPresShellResolution ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mCompositionBounds as * const _ as usize } ,
                            12usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mCompositionBounds ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mDisplayPort as * const _ as usize } , 28usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! ( mDisplayPort
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mCriticalDisplayPort as * const _ as usize } ,
                            44usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mCriticalDisplayPort ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mScrollableRect as * const _ as usize } , 60usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mScrollableRect ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mCumulativeResolution as * const _ as usize } ,
                            76usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mCumulativeResolution ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mDevPixelsPerCSSPixel as * const _ as usize } ,
                            84usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mDevPixelsPerCSSPixel ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mScrollOffset as * const _ as usize } , 88usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mScrollOffset ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) . mZoom as *
                            const _ as usize } , 96usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! ( mZoom ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mScrollGeneration as * const _ as usize } ,
                            104usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mScrollGeneration ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mSmoothScrollOffset as * const _ as usize } ,
                            108usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mSmoothScrollOffset ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mRootCompositionSize as * const _ as usize } ,
                            116usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mRootCompositionSize ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mDisplayPortMargins as * const _ as usize } ,
                            124usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mDisplayPortMargins ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mPresShellId as * const _ as usize } , 140usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! ( mPresShellId
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) . mViewport
                            as * const _ as usize } , 144usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! ( mViewport )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mExtraResolution as * const _ as usize } ,
                            160usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mExtraResolution ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mPaintRequestTime as * const _ as usize } ,
                            168usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mPaintRequestTime ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FrameMetrics ) ) .
                            mScrollUpdateType as * const _ as usize } ,
                            176usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FrameMetrics ) , "::" , stringify ! (
                            mScrollUpdateType ) ));
            }
            impl Clone for FrameMetrics {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ScrollSnapInfo {
                pub mScrollSnapTypeX: u8,
                pub mScrollSnapTypeY: u8,
                pub mScrollSnapIntervalX: [u32; 2usize],
                pub mScrollSnapIntervalY: [u32; 2usize],
                pub mScrollSnapDestination: root::nsPoint,
                pub mScrollSnapCoordinates: root::nsTArray<root::nsPoint>,
            }
            #[test]
            fn bindgen_test_layout_ScrollSnapInfo() {
                assert_eq!(::std::mem::size_of::<ScrollSnapInfo>() , 40usize ,
                           concat ! (
                           "Size of: " , stringify ! ( ScrollSnapInfo ) ));
                assert_eq! (::std::mem::align_of::<ScrollSnapInfo>() , 8usize
                            , concat ! (
                            "Alignment of " , stringify ! ( ScrollSnapInfo )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollSnapInfo ) ) .
                            mScrollSnapTypeX as * const _ as usize } , 0usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollSnapInfo ) , "::" , stringify ! (
                            mScrollSnapTypeX ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollSnapInfo ) ) .
                            mScrollSnapTypeY as * const _ as usize } , 1usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollSnapInfo ) , "::" , stringify ! (
                            mScrollSnapTypeY ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollSnapInfo ) ) .
                            mScrollSnapIntervalX as * const _ as usize } ,
                            4usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollSnapInfo ) , "::" , stringify ! (
                            mScrollSnapIntervalX ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollSnapInfo ) ) .
                            mScrollSnapIntervalY as * const _ as usize } ,
                            12usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollSnapInfo ) , "::" , stringify ! (
                            mScrollSnapIntervalY ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollSnapInfo ) ) .
                            mScrollSnapDestination as * const _ as usize } ,
                            20usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollSnapInfo ) , "::" , stringify ! (
                            mScrollSnapDestination ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollSnapInfo ) ) .
                            mScrollSnapCoordinates as * const _ as usize } ,
                            32usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollSnapInfo ) , "::" , stringify ! (
                            mScrollSnapCoordinates ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Layer([u8; 0]);
        }
        pub mod dom {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub mod binding_detail {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[repr(C)]
                #[derive(Debug)]
                pub struct FastErrorResult {
                    pub _base: root::mozilla::binding_danger::TErrorResult<root::mozilla::binding_danger::JustAssertCleanupPolicy>,
                }
                #[test]
                fn bindgen_test_layout_FastErrorResult() {
                    assert_eq!(::std::mem::size_of::<FastErrorResult>() ,
                               16usize , concat ! (
                               "Size of: " , stringify ! ( FastErrorResult )
                               ));
                    assert_eq! (::std::mem::align_of::<FastErrorResult>() ,
                                8usize , concat ! (
                                "Alignment of " , stringify ! (
                                FastErrorResult ) ));
                }
                #[repr(C)]
                pub struct FakeString {
                    pub mData: *mut root::nsAString_internal_char_type,
                    pub mLength: root::nsAString_internal_size_type,
                    pub mFlags: u32,
                    pub mInlineStorage: [root::nsAString_internal_char_type; 64usize],
                }
                #[repr(C)]
                #[derive(Debug)]
                pub struct FakeString_StringAsserter {
                    pub _base: ::nsstring::nsStringRepr,
                }
                #[test]
                fn bindgen_test_layout_FakeString_StringAsserter() {
                    assert_eq!(::std::mem::size_of::<FakeString_StringAsserter>()
                               , 16usize , concat ! (
                               "Size of: " , stringify ! (
                               FakeString_StringAsserter ) ));
                    assert_eq! (::std::mem::align_of::<FakeString_StringAsserter>()
                                , 8usize , concat ! (
                                "Alignment of " , stringify ! (
                                FakeString_StringAsserter ) ));
                }
                pub const FakeString_sInlineCapacity: usize = 64;
                #[test]
                fn bindgen_test_layout_FakeString() {
                    assert_eq!(::std::mem::size_of::<FakeString>() , 144usize
                               , concat ! (
                               "Size of: " , stringify ! ( FakeString ) ));
                    assert_eq! (::std::mem::align_of::<FakeString>() , 8usize
                                , concat ! (
                                "Alignment of " , stringify ! ( FakeString )
                                ));
                    assert_eq! (unsafe {
                                & ( * ( 0 as * const FakeString ) ) . mData as
                                * const _ as usize } , 0usize , concat ! (
                                "Alignment of field: " , stringify ! (
                                FakeString ) , "::" , stringify ! ( mData )
                                ));
                    assert_eq! (unsafe {
                                & ( * ( 0 as * const FakeString ) ) . mLength
                                as * const _ as usize } , 8usize , concat ! (
                                "Alignment of field: " , stringify ! (
                                FakeString ) , "::" , stringify ! ( mLength )
                                ));
                    assert_eq! (unsafe {
                                & ( * ( 0 as * const FakeString ) ) . mFlags
                                as * const _ as usize } , 12usize , concat ! (
                                "Alignment of field: " , stringify ! (
                                FakeString ) , "::" , stringify ! ( mFlags )
                                ));
                    assert_eq! (unsafe {
                                & ( * ( 0 as * const FakeString ) ) .
                                mInlineStorage as * const _ as usize } ,
                                16usize , concat ! (
                                "Alignment of field: " , stringify ! (
                                FakeString ) , "::" , stringify ! (
                                mInlineStorage ) ));
                }
                #[repr(C)]
                #[derive(Debug)]
                pub struct FastElementCreationOptions {
                    pub _base: root::mozilla::dom::ElementCreationOptions,
                }
                #[test]
                fn bindgen_test_layout_FastElementCreationOptions() {
                    assert_eq!(::std::mem::size_of::<FastElementCreationOptions>()
                               , 32usize , concat ! (
                               "Size of: " , stringify ! (
                               FastElementCreationOptions ) ));
                    assert_eq! (::std::mem::align_of::<FastElementCreationOptions>()
                                , 8usize , concat ! (
                                "Alignment of " , stringify ! (
                                FastElementCreationOptions ) ));
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct RecordEntry<KeyType, ValueType> {
                    pub mKey: KeyType,
                    pub mValue: ValueType,
                }
            }
            /**
 * A class for representing string return values.  This can be either passed to
 * callees that have an nsString or nsAString out param or passed to a callee
 * that actually knows about this class and can work with it.  Such a callee may
 * call SetStringBuffer or SetEphemeralStringBuffer or SetOwnedString or
 * SetOwnedAtom on this object.  It's only OK to call
 * SetStringBuffer/SetOwnedString/SetOwnedAtom if the caller of the method in
 * question plans to keep holding a strong ref to the stringbuffer involved,
 * whether it's a raw nsStringBuffer, or stored inside the string or atom being
 * passed.  In the string/atom cases that means the caller must own the string
 * or atom, and not mutate it (in the string case) for the lifetime of the
 * DOMString.
 *
 * The proper way to store a value in this class is to either to do nothing
 * (which leaves this as an empty string), to call
 * SetStringBuffer/SetEphemeralStringBuffer with a non-null stringbuffer, to
 * call SetOwnedString, to call SetOwnedAtom, to call SetNull(), or to call
 * AsAString() and set the value in the resulting nsString.  These options are
 * mutually exclusive! Don't do more than one of them.
 *
 * The proper way to extract a value is to check IsNull().  If not null, then
 * check HasStringBuffer().  If that's true, check for a zero length, and if the
 * length is nonzero call StringBuffer().  If the length is zero this is the
 * empty string.  If HasStringBuffer() returns false, call AsAString() and get
 * the value from that.
 */
            #[repr(C)]
            #[derive(Debug)]
            pub struct DOMString {
                pub mString: [u64; 21usize],
                pub mStringBuffer: *mut root::nsStringBuffer,
                pub mLength: u32,
                pub mIsNull: bool,
                pub mStringBufferOwned: bool,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum DOMString_NullHandling {
                eTreatNullAsNull = 0,
                eTreatNullAsEmpty = 1,
                eNullNotExpected = 2,
            }
            #[test]
            fn bindgen_test_layout_DOMString() {
                assert_eq!(::std::mem::size_of::<DOMString>() , 184usize ,
                           concat ! ( "Size of: " , stringify ! ( DOMString )
                           ));
                assert_eq! (::std::mem::align_of::<DOMString>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( DOMString ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const DOMString ) ) . mString as *
                            const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! ( DOMString )
                            , "::" , stringify ! ( mString ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const DOMString ) ) . mStringBuffer
                            as * const _ as usize } , 168usize , concat ! (
                            "Alignment of field: " , stringify ! ( DOMString )
                            , "::" , stringify ! ( mStringBuffer ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const DOMString ) ) . mLength as *
                            const _ as usize } , 176usize , concat ! (
                            "Alignment of field: " , stringify ! ( DOMString )
                            , "::" , stringify ! ( mLength ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const DOMString ) ) . mIsNull as *
                            const _ as usize } , 180usize , concat ! (
                            "Alignment of field: " , stringify ! ( DOMString )
                            , "::" , stringify ! ( mIsNull ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const DOMString ) ) .
                            mStringBufferOwned as * const _ as usize } ,
                            181usize , concat ! (
                            "Alignment of field: " , stringify ! ( DOMString )
                            , "::" , stringify ! ( mStringBufferOwned ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DictionaryBase {
                pub mIsAnyMemberPresent: bool,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DictionaryBase_FastDictionaryInitializer {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_DictionaryBase_FastDictionaryInitializer() {
                assert_eq!(::std::mem::size_of::<DictionaryBase_FastDictionaryInitializer>()
                           , 1usize , concat ! (
                           "Size of: " , stringify ! (
                           DictionaryBase_FastDictionaryInitializer ) ));
                assert_eq! (::std::mem::align_of::<DictionaryBase_FastDictionaryInitializer>()
                            , 1usize , concat ! (
                            "Alignment of " , stringify ! (
                            DictionaryBase_FastDictionaryInitializer ) ));
            }
            impl Clone for DictionaryBase_FastDictionaryInitializer {
                fn clone(&self) -> Self { *self }
            }
            #[test]
            fn bindgen_test_layout_DictionaryBase() {
                assert_eq!(::std::mem::size_of::<DictionaryBase>() , 1usize ,
                           concat ! (
                           "Size of: " , stringify ! ( DictionaryBase ) ));
                assert_eq! (::std::mem::align_of::<DictionaryBase>() , 1usize
                            , concat ! (
                            "Alignment of " , stringify ! ( DictionaryBase )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const DictionaryBase ) ) .
                            mIsAnyMemberPresent as * const _ as usize } ,
                            0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            DictionaryBase ) , "::" , stringify ! (
                            mIsAnyMemberPresent ) ));
            }
            impl Clone for DictionaryBase {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct AllOwningUnionBase {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_AllOwningUnionBase() {
                assert_eq!(::std::mem::size_of::<AllOwningUnionBase>() ,
                           1usize , concat ! (
                           "Size of: " , stringify ! ( AllOwningUnionBase )
                           ));
                assert_eq! (::std::mem::align_of::<AllOwningUnionBase>() ,
                            1usize , concat ! (
                            "Alignment of " , stringify ! ( AllOwningUnionBase
                            ) ));
            }
            impl Clone for AllOwningUnionBase {
                fn clone(&self) -> Self { *self }
            }
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum CallerType { }
            #[repr(C)]
            #[derive(Debug)]
            pub struct GlobalObject {
                pub mGlobalJSObject: [u64; 3usize],
                pub mCx: *mut root::JSContext,
                pub mGlobalObject: *mut root::nsISupports,
            }
            #[test]
            fn bindgen_test_layout_GlobalObject() {
                assert_eq!(::std::mem::size_of::<GlobalObject>() , 40usize ,
                           concat ! (
                           "Size of: " , stringify ! ( GlobalObject ) ));
                assert_eq! (::std::mem::align_of::<GlobalObject>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( GlobalObject ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GlobalObject ) ) .
                            mGlobalJSObject as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GlobalObject ) , "::" , stringify ! (
                            mGlobalJSObject ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GlobalObject ) ) . mCx as *
                            const _ as usize } , 24usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            GlobalObject ) , "::" , stringify ! ( mCx ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GlobalObject ) ) .
                            mGlobalObject as * const _ as usize } , 32usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GlobalObject ) , "::" , stringify ! (
                            mGlobalObject ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct ParentObject {
                pub mObject: *const root::nsISupports,
                pub mWrapperCache: *const root::nsWrapperCache,
                pub mUseXBLScope: bool,
            }
            #[test]
            fn bindgen_test_layout_ParentObject() {
                assert_eq!(::std::mem::size_of::<ParentObject>() , 24usize ,
                           concat ! (
                           "Size of: " , stringify ! ( ParentObject ) ));
                assert_eq! (::std::mem::align_of::<ParentObject>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( ParentObject ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ParentObject ) ) . mObject as
                            * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ParentObject ) , "::" , stringify ! ( mObject )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ParentObject ) ) .
                            mWrapperCache as * const _ as usize } , 8usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ParentObject ) , "::" , stringify ! (
                            mWrapperCache ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ParentObject ) ) .
                            mUseXBLScope as * const _ as usize } , 16usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ParentObject ) , "::" , stringify ! ( mUseXBLScope
                            ) ));
            }
            impl Clone for ParentObject {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Event([u8; 0]);
            #[repr(C)]
            pub struct DispatcherTrait__bindgen_vtable {
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DispatcherTrait {
                pub vtable_: *const DispatcherTrait__bindgen_vtable,
            }
            #[test]
            fn bindgen_test_layout_DispatcherTrait() {
                assert_eq!(::std::mem::size_of::<DispatcherTrait>() , 8usize ,
                           concat ! (
                           "Size of: " , stringify ! ( DispatcherTrait ) ));
                assert_eq! (::std::mem::align_of::<DispatcherTrait>() , 8usize
                            , concat ! (
                            "Alignment of " , stringify ! ( DispatcherTrait )
                            ));
            }
            impl Clone for DispatcherTrait {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct EventTarget {
                pub _base: root::nsIDOMEventTarget,
                pub _base_1: root::nsWrapperCache,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EventTarget_COMTypeInfo<T, U> {
                pub _address: u8,
                pub _phantom_0: ::std::marker::PhantomData<T>,
                pub _phantom_1: ::std::marker::PhantomData<U>,
            }
            #[test]
            fn bindgen_test_layout_EventTarget() {
                assert_eq!(::std::mem::size_of::<EventTarget>() , 32usize ,
                           concat ! (
                           "Size of: " , stringify ! ( EventTarget ) ));
                assert_eq! (::std::mem::align_of::<EventTarget>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( EventTarget ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AddEventListenerOptionsOrBoolean([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EventListener([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EventListenerOptionsOrBoolean([u8; 0]);
            #[repr(C)]
            #[derive(Debug)]
            pub struct EventHandlerNonNull {
                pub _base: root::mozilla::dom::CallbackFunction,
            }
            #[test]
            fn bindgen_test_layout_EventHandlerNonNull() {
                assert_eq!(::std::mem::size_of::<EventHandlerNonNull>() ,
                           48usize , concat ! (
                           "Size of: " , stringify ! ( EventHandlerNonNull )
                           ));
                assert_eq! (::std::mem::align_of::<EventHandlerNonNull>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            EventHandlerNonNull ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AudioContext([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DocGroup([u8; 0]);
            #[repr(C)]
            #[derive(Debug)]
            pub struct Element {
                pub _base: root::mozilla::dom::FragmentOrElement,
                pub mState: root::mozilla::EventStates,
                pub mServoData: ::gecko_bindings::structs::ServoCell<*mut ::gecko_bindings::structs::ServoNodeData>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Element_COMTypeInfo<T, U> {
                pub _address: u8,
                pub _phantom_0: ::std::marker::PhantomData<T>,
                pub _phantom_1: ::std::marker::PhantomData<U>,
            }
            /**
   * StyleStateLocks is used to specify which event states should be locked,
   * and whether they should be locked to on or off.
   */
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Element_StyleStateLocks {
                pub mLocks: root::mozilla::EventStates,
                pub mValues: root::mozilla::EventStates,
            }
            #[test]
            fn bindgen_test_layout_Element_StyleStateLocks() {
                assert_eq!(::std::mem::size_of::<Element_StyleStateLocks>() ,
                           16usize , concat ! (
                           "Size of: " , stringify ! ( Element_StyleStateLocks
                           ) ));
                assert_eq! (::std::mem::align_of::<Element_StyleStateLocks>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            Element_StyleStateLocks ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Element_StyleStateLocks ) ) .
                            mLocks as * const _ as usize } , 0usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            Element_StyleStateLocks ) , "::" , stringify ! (
                            mLocks ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Element_StyleStateLocks ) ) .
                            mValues as * const _ as usize } , 8usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            Element_StyleStateLocks ) , "::" , stringify ! (
                            mValues ) ));
            }
            impl Clone for Element_StyleStateLocks {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Element_MappedAttributeEntry {
                pub attribute: *mut *mut root::nsIAtom,
            }
            #[test]
            fn bindgen_test_layout_Element_MappedAttributeEntry() {
                assert_eq!(::std::mem::size_of::<Element_MappedAttributeEntry>()
                           , 8usize , concat ! (
                           "Size of: " , stringify ! (
                           Element_MappedAttributeEntry ) ));
                assert_eq! (::std::mem::align_of::<Element_MappedAttributeEntry>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            Element_MappedAttributeEntry ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const Element_MappedAttributeEntry ) )
                            . attribute as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            Element_MappedAttributeEntry ) , "::" , stringify
                            ! ( attribute ) ));
            }
            impl Clone for Element_MappedAttributeEntry {
                fn clone(&self) -> Self { *self }
            }
            pub const Element_kFireMutationEvent: bool = true;
            pub const Element_kDontFireMutationEvent: bool = false;
            pub const Element_kNotifyDocumentObservers: bool = true;
            pub const Element_kDontNotifyDocumentObservers: bool = false;
            pub const Element_kCallAfterSetAttr: bool = true;
            pub const Element_kDontCallAfterSetAttr: bool = false;
            #[test]
            fn bindgen_test_layout_Element() {
                assert_eq!(::std::mem::size_of::<Element>() , 128usize ,
                           concat ! ( "Size of: " , stringify ! ( Element )
                           ));
                assert_eq! (::std::mem::align_of::<Element>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( Element ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Element ) ) . mState as *
                            const _ as usize } , 112usize , concat ! (
                            "Alignment of field: " , stringify ! ( Element ) ,
                            "::" , stringify ! ( mState ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const Element ) ) . mServoData as *
                            const _ as usize } , 120usize , concat ! (
                            "Alignment of field: " , stringify ! ( Element ) ,
                            "::" , stringify ! ( mServoData ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Performance([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ServiceWorkerRegistration([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TimeoutManager([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CustomElementRegistry([u8; 0]);
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum LargeAllocStatus {
                NONE = 0,
                SUCCESS = 1,
                NON_GET = 2,
                NON_E10S = 3,
                NOT_ONLY_TOPLEVEL_IN_TABGROUP = 4,
                NON_WIN32 = 5,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct PrefSetting([u8; 0]);
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallbackObject {
                pub _base: root::nsISupports,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mCallback: root::JS::Heap<*mut root::JSObject>,
                pub mCreationStack: root::JS::Heap<*mut root::JSObject>,
                pub mIncumbentGlobal: root::nsCOMPtr<root::nsIGlobalObject>,
                pub mIncumbentJSGlobal: root::JS::TenuredHeap<*mut root::JSObject>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CallbackObject_COMTypeInfo<T, U> {
                pub _address: u8,
                pub _phantom_0: ::std::marker::PhantomData<T>,
                pub _phantom_1: ::std::marker::PhantomData<U>,
            }
            pub type CallbackObject_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct CallbackObject_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_CallbackObject_cycleCollection() {
                assert_eq!(::std::mem::size_of::<CallbackObject_cycleCollection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           CallbackObject_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<CallbackObject_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            CallbackObject_cycleCollection ) ));
            }
            impl Clone for CallbackObject_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum CallbackObject_ExceptionHandling {
                eReportExceptions = 0,
                eRethrowContentExceptions = 1,
                eRethrowExceptions = 2,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallbackObject_JSObjectsDropper {
                pub mHolder: root::RefPtr<root::mozilla::dom::CallbackObject>,
            }
            #[test]
            fn bindgen_test_layout_CallbackObject_JSObjectsDropper() {
                assert_eq!(::std::mem::size_of::<CallbackObject_JSObjectsDropper>()
                           , 8usize , concat ! (
                           "Size of: " , stringify ! (
                           CallbackObject_JSObjectsDropper ) ));
                assert_eq! (::std::mem::align_of::<CallbackObject_JSObjectsDropper>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            CallbackObject_JSObjectsDropper ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const CallbackObject_JSObjectsDropper )
                            ) . mHolder as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_JSObjectsDropper ) , "::" ,
                            stringify ! ( mHolder ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct CallbackObject_FastCallbackConstructor {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_CallbackObject_FastCallbackConstructor() {
                assert_eq!(::std::mem::size_of::<CallbackObject_FastCallbackConstructor>()
                           , 1usize , concat ! (
                           "Size of: " , stringify ! (
                           CallbackObject_FastCallbackConstructor ) ));
                assert_eq! (::std::mem::align_of::<CallbackObject_FastCallbackConstructor>()
                            , 1usize , concat ! (
                            "Alignment of " , stringify ! (
                            CallbackObject_FastCallbackConstructor ) ));
            }
            impl Clone for CallbackObject_FastCallbackConstructor {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallbackObject_CallSetup {
                pub mCx: *mut root::JSContext,
                pub mCompartment: *mut root::JSCompartment,
                pub mAutoEntryScript: [u64; 19usize],
                pub mAutoIncumbentScript: [u64; 5usize],
                pub mRootedCallable: [u64; 4usize],
                pub mAsyncStack: [u64; 4usize],
                pub mAsyncStackSetter: [u64; 7usize],
                pub mAc: [u64; 3usize],
                pub mErrorResult: *mut root::mozilla::ErrorResult,
                pub mExceptionHandling: root::mozilla::dom::CallbackObject_ExceptionHandling,
                pub mIsMainThread: bool,
            }
            #[test]
            fn bindgen_test_layout_CallbackObject_CallSetup() {
                assert_eq!(::std::mem::size_of::<CallbackObject_CallSetup>() ,
                           368usize , concat ! (
                           "Size of: " , stringify ! (
                           CallbackObject_CallSetup ) ));
                assert_eq! (::std::mem::align_of::<CallbackObject_CallSetup>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            CallbackObject_CallSetup ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mCx as * const _ as usize } , 0usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mCx ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mCompartment as * const _ as usize } , 8usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mCompartment ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mAutoEntryScript as * const _ as usize } ,
                            16usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mAutoEntryScript ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mAutoIncumbentScript as * const _ as usize } ,
                            168usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mAutoIncumbentScript ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mRootedCallable as * const _ as usize } ,
                            208usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mRootedCallable ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mAsyncStack as * const _ as usize } , 240usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mAsyncStack ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mAsyncStackSetter as * const _ as usize } ,
                            272usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mAsyncStackSetter ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mAc as * const _ as usize } , 328usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mAc ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mErrorResult as * const _ as usize } , 352usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mErrorResult ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mExceptionHandling as * const _ as usize } ,
                            360usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mExceptionHandling ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject_CallSetup ) )
                            . mIsMainThread as * const _ as usize } , 364usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject_CallSetup ) , "::" , stringify ! (
                            mIsMainThread ) ));
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom14CallbackObject21_cycleCollectorGlobalE"]
                pub static mut CallbackObject__cycleCollectorGlobal:
                           root::mozilla::dom::CallbackObject_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_CallbackObject() {
                assert_eq!(::std::mem::size_of::<CallbackObject>() , 48usize ,
                           concat ! (
                           "Size of: " , stringify ! ( CallbackObject ) ));
                assert_eq! (::std::mem::align_of::<CallbackObject>() , 8usize
                            , concat ! (
                            "Alignment of " , stringify ! ( CallbackObject )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject ) ) . mRefCnt
                            as * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject ) , "::" , stringify ! ( mRefCnt )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject ) ) .
                            mCallback as * const _ as usize } , 16usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject ) , "::" , stringify ! ( mCallback
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject ) ) .
                            mCreationStack as * const _ as usize } , 24usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject ) , "::" , stringify ! (
                            mCreationStack ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject ) ) .
                            mIncumbentGlobal as * const _ as usize } , 32usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject ) , "::" , stringify ! (
                            mIncumbentGlobal ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const CallbackObject ) ) .
                            mIncumbentJSGlobal as * const _ as usize } ,
                            40usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            CallbackObject ) , "::" , stringify ! (
                            mIncumbentJSGlobal ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallbackObjectHolder<WebIDLCallbackT, XPCOMCallbackT> {
                pub mPtrBits: usize,
                pub _phantom_0: ::std::marker::PhantomData<WebIDLCallbackT>,
                pub _phantom_1: ::std::marker::PhantomData<XPCOMCallbackT>,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct CallbackObjectHolderBase {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_CallbackObjectHolderBase() {
                assert_eq!(::std::mem::size_of::<CallbackObjectHolderBase>() ,
                           1usize , concat ! (
                           "Size of: " , stringify ! (
                           CallbackObjectHolderBase ) ));
                assert_eq! (::std::mem::align_of::<CallbackObjectHolderBase>()
                            , 1usize , concat ! (
                            "Alignment of " , stringify ! (
                            CallbackObjectHolderBase ) ));
            }
            impl Clone for CallbackObjectHolderBase {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallbackFunction {
                pub _base: root::mozilla::dom::CallbackObject,
            }
            #[test]
            fn bindgen_test_layout_CallbackFunction() {
                assert_eq!(::std::mem::size_of::<CallbackFunction>() , 48usize
                           , concat ! (
                           "Size of: " , stringify ! ( CallbackFunction ) ));
                assert_eq! (::std::mem::align_of::<CallbackFunction>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! ( CallbackFunction )
                            ));
            }
            pub mod prototypes {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
            pub mod constructors {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
            pub mod namedpropertiesobjects {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct OriginAttributesDictionary {
                pub _base: root::mozilla::dom::DictionaryBase,
                pub mAddonId: ::nsstring::nsStringRepr,
                pub mAppId: u32,
                pub mFirstPartyDomain: ::nsstring::nsStringRepr,
                pub mInIsolatedMozBrowser: bool,
                pub mPrivateBrowsingId: u32,
                pub mUserContextId: u32,
            }
            #[test]
            fn bindgen_test_layout_OriginAttributesDictionary() {
                assert_eq!(::std::mem::size_of::<OriginAttributesDictionary>()
                           , 64usize , concat ! (
                           "Size of: " , stringify ! (
                           OriginAttributesDictionary ) ));
                assert_eq! (::std::mem::align_of::<OriginAttributesDictionary>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            OriginAttributesDictionary ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const OriginAttributesDictionary )
                            ) . mAddonId as * const _ as usize } , 8usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            OriginAttributesDictionary ) , "::" , stringify !
                            ( mAddonId ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const OriginAttributesDictionary )
                            ) . mAppId as * const _ as usize } , 24usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            OriginAttributesDictionary ) , "::" , stringify !
                            ( mAppId ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const OriginAttributesDictionary )
                            ) . mFirstPartyDomain as * const _ as usize } ,
                            32usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            OriginAttributesDictionary ) , "::" , stringify !
                            ( mFirstPartyDomain ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const OriginAttributesDictionary )
                            ) . mInIsolatedMozBrowser as * const _ as usize }
                            , 48usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            OriginAttributesDictionary ) , "::" , stringify !
                            ( mInIsolatedMozBrowser ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const OriginAttributesDictionary )
                            ) . mPrivateBrowsingId as * const _ as usize } ,
                            52usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            OriginAttributesDictionary ) , "::" , stringify !
                            ( mPrivateBrowsingId ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const OriginAttributesDictionary )
                            ) . mUserContextId as * const _ as usize } ,
                            56usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            OriginAttributesDictionary ) , "::" , stringify !
                            ( mUserContextId ) ));
            }
            pub mod workers {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum CSSStyleSheetParsingMode {
                Author = 0,
                User = 1,
                Agent = 2,
                EndGuard_ = 3,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CSSRuleList([u8; 0]);
            #[repr(C)]
            #[derive(Debug)]
            pub struct NodeInfo {
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mDocument: *mut root::nsIDocument,
                pub mInner: root::mozilla::dom::NodeInfo_NodeInfoInner,
                pub mOwnerManager: root::RefPtr<root::nsNodeInfoManager>,
                pub mQualifiedName: ::nsstring::nsStringRepr,
                pub mNodeName: ::nsstring::nsStringRepr,
                pub mLocalName: ::nsstring::nsStringRepr,
            }
            pub type NodeInfo_HasThreadSafeRefCnt = root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct NodeInfo_cycleCollection {
                pub _base: root::nsCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_NodeInfo_cycleCollection() {
                assert_eq!(::std::mem::size_of::<NodeInfo_cycleCollection>() ,
                           16usize , concat ! (
                           "Size of: " , stringify ! (
                           NodeInfo_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<NodeInfo_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            NodeInfo_cycleCollection ) ));
            }
            impl Clone for NodeInfo_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct NodeInfo_NodeInfoInner {
                pub mName: root::nsCOMPtr<root::nsIAtom>,
                pub mPrefix: root::nsCOMPtr<root::nsIAtom>,
                pub mNamespaceID: i32,
                pub mNodeType: u16,
                pub mNameString: *const root::nsAString_internal,
                pub mExtraName: root::nsCOMPtr<root::nsIAtom>,
            }
            #[test]
            fn bindgen_test_layout_NodeInfo_NodeInfoInner() {
                assert_eq!(::std::mem::size_of::<NodeInfo_NodeInfoInner>() ,
                           40usize , concat ! (
                           "Size of: " , stringify ! ( NodeInfo_NodeInfoInner
                           ) ));
                assert_eq! (::std::mem::align_of::<NodeInfo_NodeInfoInner>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            NodeInfo_NodeInfoInner ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) .
                            mName as * const _ as usize } , 0usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            NodeInfo_NodeInfoInner ) , "::" , stringify ! (
                            mName ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) .
                            mPrefix as * const _ as usize } , 8usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            NodeInfo_NodeInfoInner ) , "::" , stringify ! (
                            mPrefix ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) .
                            mNamespaceID as * const _ as usize } , 16usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            NodeInfo_NodeInfoInner ) , "::" , stringify ! (
                            mNamespaceID ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) .
                            mNodeType as * const _ as usize } , 20usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            NodeInfo_NodeInfoInner ) , "::" , stringify ! (
                            mNodeType ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) .
                            mNameString as * const _ as usize } , 24usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            NodeInfo_NodeInfoInner ) , "::" , stringify ! (
                            mNameString ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo_NodeInfoInner ) ) .
                            mExtraName as * const _ as usize } , 32usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            NodeInfo_NodeInfoInner ) , "::" , stringify ! (
                            mExtraName ) ));
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom8NodeInfo21_cycleCollectorGlobalE"]
                pub static mut NodeInfo__cycleCollectorGlobal:
                           root::mozilla::dom::NodeInfo_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_NodeInfo() {
                assert_eq!(::std::mem::size_of::<NodeInfo>() , 112usize ,
                           concat ! ( "Size of: " , stringify ! ( NodeInfo )
                           ));
                assert_eq! (::std::mem::align_of::<NodeInfo>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( NodeInfo ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo ) ) . mRefCnt as *
                            const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! ( NodeInfo )
                            , "::" , stringify ! ( mRefCnt ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo ) ) . mDocument as *
                            const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! ( NodeInfo )
                            , "::" , stringify ! ( mDocument ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo ) ) . mInner as *
                            const _ as usize } , 16usize , concat ! (
                            "Alignment of field: " , stringify ! ( NodeInfo )
                            , "::" , stringify ! ( mInner ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo ) ) . mOwnerManager
                            as * const _ as usize } , 56usize , concat ! (
                            "Alignment of field: " , stringify ! ( NodeInfo )
                            , "::" , stringify ! ( mOwnerManager ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo ) ) . mQualifiedName
                            as * const _ as usize } , 64usize , concat ! (
                            "Alignment of field: " , stringify ! ( NodeInfo )
                            , "::" , stringify ! ( mQualifiedName ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo ) ) . mNodeName as *
                            const _ as usize } , 80usize , concat ! (
                            "Alignment of field: " , stringify ! ( NodeInfo )
                            , "::" , stringify ! ( mNodeName ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const NodeInfo ) ) . mLocalName as
                            * const _ as usize } , 96usize , concat ! (
                            "Alignment of field: " , stringify ! ( NodeInfo )
                            , "::" , stringify ! ( mLocalName ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AccessibleNode([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct BoxQuadOptions([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ConvertCoordinateOptions([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DOMPoint([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DOMQuad([u8; 0]);
            #[repr(C)]
            #[derive(Debug)]
            pub struct DOMRectReadOnly {
                pub _base: root::nsISupports,
                pub _base_1: root::nsWrapperCache,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mParent: root::nsCOMPtr<root::nsISupports>,
            }
            pub type DOMRectReadOnly_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DOMRectReadOnly_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_DOMRectReadOnly_cycleCollection() {
                assert_eq!(::std::mem::size_of::<DOMRectReadOnly_cycleCollection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           DOMRectReadOnly_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<DOMRectReadOnly_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            DOMRectReadOnly_cycleCollection ) ));
            }
            impl Clone for DOMRectReadOnly_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom15DOMRectReadOnly21_cycleCollectorGlobalE"]
                pub static mut DOMRectReadOnly__cycleCollectorGlobal:
                           root::mozilla::dom::DOMRectReadOnly_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_DOMRectReadOnly() {
                assert_eq!(::std::mem::size_of::<DOMRectReadOnly>() , 48usize
                           , concat ! (
                           "Size of: " , stringify ! ( DOMRectReadOnly ) ));
                assert_eq! (::std::mem::align_of::<DOMRectReadOnly>() , 8usize
                            , concat ! (
                            "Alignment of " , stringify ! ( DOMRectReadOnly )
                            ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct OwningNodeOrString {
                pub mType: root::mozilla::dom::OwningNodeOrString_Type,
                pub mValue: root::mozilla::dom::OwningNodeOrString_Value,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum OwningNodeOrString_Type {
                eUninitialized = 0,
                eNode = 1,
                eString = 2,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct OwningNodeOrString_Value {
                pub mNode: root::__BindgenUnionField<root::mozilla::dom::UnionMember<root::mozilla::OwningNonNull<root::nsINode>>>,
                pub mString: root::__BindgenUnionField<root::mozilla::dom::UnionMember<::nsstring::nsStringRepr>>,
                pub bindgen_union_field: [u64; 2usize],
            }
            #[test]
            fn bindgen_test_layout_OwningNodeOrString_Value() {
                assert_eq!(::std::mem::size_of::<OwningNodeOrString_Value>() ,
                           16usize , concat ! (
                           "Size of: " , stringify ! (
                           OwningNodeOrString_Value ) ));
                assert_eq! (::std::mem::align_of::<OwningNodeOrString_Value>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            OwningNodeOrString_Value ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const OwningNodeOrString_Value ) )
                            . mNode as * const _ as usize } , 0usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            OwningNodeOrString_Value ) , "::" , stringify ! (
                            mNode ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const OwningNodeOrString_Value ) )
                            . mString as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            OwningNodeOrString_Value ) , "::" , stringify ! (
                            mString ) ));
            }
            impl Clone for OwningNodeOrString_Value {
                fn clone(&self) -> Self { *self }
            }
            #[test]
            fn bindgen_test_layout_OwningNodeOrString() {
                assert_eq!(::std::mem::size_of::<OwningNodeOrString>() ,
                           24usize , concat ! (
                           "Size of: " , stringify ! ( OwningNodeOrString )
                           ));
                assert_eq! (::std::mem::align_of::<OwningNodeOrString>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! ( OwningNodeOrString
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const OwningNodeOrString ) ) .
                            mType as * const _ as usize } , 0usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            OwningNodeOrString ) , "::" , stringify ! ( mType
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const OwningNodeOrString ) ) .
                            mValue as * const _ as usize } , 8usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            OwningNodeOrString ) , "::" , stringify ! ( mValue
                            ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Text([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TextOrElementOrDocument([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DOMPointInit([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct GetRootNodeOptions([u8; 0]);
            #[repr(C)]
            #[derive(Debug)]
            pub struct UnionMember<T> {
                pub mStorage: root::mozilla::AlignedStorage2<T>,
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum VisibilityState {
                Hidden = 0,
                Visible = 1,
                Prerender = 2,
                EndGuard_ = 3,
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum FlashClassification {
                Unclassified = 0,
                Unknown = 1,
                Allowed = 2,
                Denied = 3,
                EndGuard_ = 4,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ElementCreationOptions {
                pub _base: root::mozilla::dom::DictionaryBase,
                pub mIs: [u64; 3usize],
            }
            #[test]
            fn bindgen_test_layout_ElementCreationOptions() {
                assert_eq!(::std::mem::size_of::<ElementCreationOptions>() ,
                           32usize , concat ! (
                           "Size of: " , stringify ! ( ElementCreationOptions
                           ) ));
                assert_eq! (::std::mem::align_of::<ElementCreationOptions>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            ElementCreationOptions ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ElementCreationOptions ) ) .
                            mIs as * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ElementCreationOptions ) , "::" , stringify ! (
                            mIs ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ElementCreationOptionsOrString {
                pub mType: root::mozilla::dom::ElementCreationOptionsOrString_Type,
                pub mValue: root::mozilla::dom::ElementCreationOptionsOrString_Value,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum ElementCreationOptionsOrString_Type {
                eUninitialized = 0,
                eElementCreationOptions = 1,
                eString = 2,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct ElementCreationOptionsOrString_Value {
                pub mElementCreationOptions: root::__BindgenUnionField<root::mozilla::dom::UnionMember<root::mozilla::dom::binding_detail::FastElementCreationOptions>>,
                pub mString: root::__BindgenUnionField<root::mozilla::dom::UnionMember<root::mozilla::dom::binding_detail::FakeString>>,
                pub bindgen_union_field: [u64; 18usize],
            }
            #[test]
            fn bindgen_test_layout_ElementCreationOptionsOrString_Value() {
                assert_eq!(::std::mem::size_of::<ElementCreationOptionsOrString_Value>()
                           , 144usize , concat ! (
                           "Size of: " , stringify ! (
                           ElementCreationOptionsOrString_Value ) ));
                assert_eq! (::std::mem::align_of::<ElementCreationOptionsOrString_Value>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            ElementCreationOptionsOrString_Value ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const ElementCreationOptionsOrString_Value
                            ) ) . mElementCreationOptions as * const _ as
                            usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ElementCreationOptionsOrString_Value ) , "::" ,
                            stringify ! ( mElementCreationOptions ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const ElementCreationOptionsOrString_Value
                            ) ) . mString as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ElementCreationOptionsOrString_Value ) , "::" ,
                            stringify ! ( mString ) ));
            }
            impl Clone for ElementCreationOptionsOrString_Value {
                fn clone(&self) -> Self { *self }
            }
            #[test]
            fn bindgen_test_layout_ElementCreationOptionsOrString() {
                assert_eq!(::std::mem::size_of::<ElementCreationOptionsOrString>()
                           , 152usize , concat ! (
                           "Size of: " , stringify ! (
                           ElementCreationOptionsOrString ) ));
                assert_eq! (::std::mem::align_of::<ElementCreationOptionsOrString>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            ElementCreationOptionsOrString ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const ElementCreationOptionsOrString )
                            ) . mType as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ElementCreationOptionsOrString ) , "::" ,
                            stringify ! ( mType ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const ElementCreationOptionsOrString )
                            ) . mValue as * const _ as usize } , 8usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ElementCreationOptionsOrString ) , "::" ,
                            stringify ! ( mValue ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Animation([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AnonymousContent([u8; 0]);
            #[repr(C)]
            #[derive(Debug)]
            pub struct Attr {
                pub _base: root::nsIAttribute,
                pub _base_1: root::nsIDOMAttr,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mValue: ::nsstring::nsStringRepr,
            }
            pub type Attr_HasThreadSafeRefCnt = root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Attr_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_Attr_cycleCollection() {
                assert_eq!(::std::mem::size_of::<Attr_cycleCollection>() ,
                           16usize , concat ! (
                           "Size of: " , stringify ! ( Attr_cycleCollection )
                           ));
                assert_eq! (::std::mem::align_of::<Attr_cycleCollection>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            Attr_cycleCollection ) ));
            }
            impl Clone for Attr_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            extern "C" {
                #[link_name = "_ZN7mozilla3dom4Attr21_cycleCollectorGlobalE"]
                pub static mut Attr__cycleCollectorGlobal:
                           root::mozilla::dom::Attr_cycleCollection;
            }
            extern "C" {
                #[link_name = "_ZN7mozilla3dom4Attr12sInitializedE"]
                pub static mut Attr_sInitialized: bool;
            }
            #[test]
            fn bindgen_test_layout_Attr() {
                assert_eq!(::std::mem::size_of::<Attr>() , 136usize , concat !
                           ( "Size of: " , stringify ! ( Attr ) ));
                assert_eq! (::std::mem::align_of::<Attr>() , 8usize , concat !
                            ( "Alignment of " , stringify ! ( Attr ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct BoxObject([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CDATASection([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Comment([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DocumentFragment([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DocumentTimeline([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DocumentType([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DOMImplementation([u8; 0]);
            #[repr(C)]
            #[derive(Debug)]
            pub struct DOMIntersectionObserver {
                pub _base: root::nsISupports,
                pub _base_1: root::nsWrapperCache,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mOwner: root::nsCOMPtr<root::nsPIDOMWindowInner>,
                pub mDocument: root::RefPtr<root::nsIDocument>,
                pub mCallback: root::RefPtr<root::mozilla::dom::IntersectionCallback>,
                pub mRoot: root::RefPtr<root::mozilla::dom::Element>,
                pub mRootMargin: root::nsCSSRect,
                pub mThresholds: root::nsTArray<f64>,
                pub mObservationTargets: [u64; 5usize],
                pub mQueuedEntries: root::nsTArray<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>,
                pub mConnected: bool,
            }
            pub type DOMIntersectionObserver_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DOMIntersectionObserver_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_DOMIntersectionObserver_cycleCollection() {
                assert_eq!(::std::mem::size_of::<DOMIntersectionObserver_cycleCollection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           DOMIntersectionObserver_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<DOMIntersectionObserver_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            DOMIntersectionObserver_cycleCollection ) ));
            }
            impl Clone for DOMIntersectionObserver_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DOMIntersectionObserver_COMTypeInfo<T, U> {
                pub _address: u8,
                pub _phantom_0: ::std::marker::PhantomData<T>,
                pub _phantom_1: ::std::marker::PhantomData<U>,
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom23DOMIntersectionObserver21_cycleCollectorGlobalE"]
                pub static mut DOMIntersectionObserver__cycleCollectorGlobal:
                           root::mozilla::dom::DOMIntersectionObserver_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_DOMIntersectionObserver() {
                assert_eq!(::std::mem::size_of::<DOMIntersectionObserver>() ,
                           200usize , concat ! (
                           "Size of: " , stringify ! ( DOMIntersectionObserver
                           ) ));
                assert_eq! (::std::mem::align_of::<DOMIntersectionObserver>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            DOMIntersectionObserver ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DOMStringList([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ElementRegistrationOptions([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct FontFaceSet([u8; 0]);
            #[repr(C)]
            #[derive(Debug)]
            pub struct FrameRequestCallback {
                pub _base: root::mozilla::dom::CallbackFunction,
            }
            #[test]
            fn bindgen_test_layout_FrameRequestCallback() {
                assert_eq!(::std::mem::size_of::<FrameRequestCallback>() ,
                           48usize , concat ! (
                           "Size of: " , stringify ! ( FrameRequestCallback )
                           ));
                assert_eq! (::std::mem::align_of::<FrameRequestCallback>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            FrameRequestCallback ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct FullscreenRequest([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ImageTracker([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ImportManager([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HTMLBodyElement([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Link([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Location([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct MediaQueryList([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct NodeFilter([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct NodeIterator([u8; 0]);
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum OrientationType { }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ProcessingInstruction([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Promise([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct StyleSheetList([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct SVGSVGElement([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Touch([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TouchList([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TreeWalker([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct XPathEvaluator([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct XPathExpression([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct XPathNSResolver([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct XPathResult([u8; 0]);
            pub type NodeFilterHolder =
                root::mozilla::dom::CallbackObjectHolder<root::mozilla::dom::NodeFilter,
                                                         root::nsIDOMNodeFilter>;
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum FillMode {
                None = 0,
                Forwards = 1,
                Backwards = 2,
                Both = 3,
                Auto = 4,
                EndGuard_ = 5,
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum PlaybackDirection {
                Normal = 0,
                Reverse = 1,
                Alternate = 2,
                Alternate_reverse = 3,
                EndGuard_ = 4,
            }
            /**
 * Struct that stores info on an attribute. The name and value must either both
 * be null or both be non-null.
 *
 * Note that, just as the pointers returned by GetAttrNameAt, the pointers that
 * this struct hold are only valid until the element or its attributes are
 * mutated (directly or via script).
 */
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct BorrowedAttrInfo {
                pub mName: *const root::nsAttrName,
                pub mValue: *const root::nsAttrValue,
            }
            #[test]
            fn bindgen_test_layout_BorrowedAttrInfo() {
                assert_eq!(::std::mem::size_of::<BorrowedAttrInfo>() , 16usize
                           , concat ! (
                           "Size of: " , stringify ! ( BorrowedAttrInfo ) ));
                assert_eq! (::std::mem::align_of::<BorrowedAttrInfo>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! ( BorrowedAttrInfo )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const BorrowedAttrInfo ) ) . mName
                            as * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            BorrowedAttrInfo ) , "::" , stringify ! ( mName )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const BorrowedAttrInfo ) ) . mValue
                            as * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            BorrowedAttrInfo ) , "::" , stringify ! ( mValue )
                            ));
            }
            impl Clone for BorrowedAttrInfo {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ShadowRoot([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CustomElementData([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Selection([u8; 0]);
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum ScrollBehavior {
                Auto = 0,
                Instant = 1,
                Smooth = 2,
                EndGuard_ = 3,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct ScrollOptions {
                pub _base: root::mozilla::dom::DictionaryBase,
                pub mBehavior: root::mozilla::dom::ScrollBehavior,
            }
            #[test]
            fn bindgen_test_layout_ScrollOptions() {
                assert_eq!(::std::mem::size_of::<ScrollOptions>() , 2usize ,
                           concat ! (
                           "Size of: " , stringify ! ( ScrollOptions ) ));
                assert_eq! (::std::mem::align_of::<ScrollOptions>() , 1usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( ScrollOptions )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollOptions ) ) . mBehavior
                            as * const _ as usize } , 1usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollOptions ) , "::" , stringify ! ( mBehavior )
                            ));
            }
            impl Clone for ScrollOptions {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ScrollToOptions {
                pub _base: root::mozilla::dom::ScrollOptions,
                pub mLeft: [u64; 2usize],
                pub mTop: [u64; 2usize],
            }
            #[test]
            fn bindgen_test_layout_ScrollToOptions() {
                assert_eq!(::std::mem::size_of::<ScrollToOptions>() , 40usize
                           , concat ! (
                           "Size of: " , stringify ! ( ScrollToOptions ) ));
                assert_eq! (::std::mem::align_of::<ScrollToOptions>() , 8usize
                            , concat ! (
                            "Alignment of " , stringify ! ( ScrollToOptions )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollToOptions ) ) . mLeft
                            as * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollToOptions ) , "::" , stringify ! ( mLeft )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollToOptions ) ) . mTop as
                            * const _ as usize } , 24usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ScrollToOptions ) , "::" , stringify ! ( mTop )
                            ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct FragmentOrElement {
                pub _base: root::nsIContent,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                /**
   * Array containing all attributes and children for this element
   */
                pub mAttrsAndChildren: root::nsAttrAndChildArray,
            }
            pub type FragmentOrElement_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct FragmentOrElement_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_FragmentOrElement_cycleCollection() {
                assert_eq!(::std::mem::size_of::<FragmentOrElement_cycleCollection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           FragmentOrElement_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<FragmentOrElement_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            FragmentOrElement_cycleCollection ) ));
            }
            impl Clone for FragmentOrElement_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            /**
   * There are a set of DOM- and scripting-specific instance variables
   * that may only be instantiated when a content object is accessed
   * through the DOM. Rather than burn actual slots in the content
   * objects for each of these instance variables, we put them off
   * in a side structure that's only allocated when the content is
   * accessed through the DOM.
   */
            #[repr(C)]
            #[derive(Debug)]
            pub struct FragmentOrElement_nsDOMSlots {
                pub _base: root::nsINode_nsSlots,
                /**
     * The .style attribute (an interface that forwards to the actual
     * style rules)
     * @see nsGenericHTMLElement::GetStyle
     */
                pub mStyle: root::nsCOMPtr<root::nsICSSDeclaration>,
                /**
     * The .dataset attribute.
     * @see nsGenericHTMLElement::GetDataset
     */
                pub mDataset: *mut root::nsDOMStringMap,
                /**
     * SMIL Overridde style rules (for SMIL animation of CSS properties)
     * @see nsIContent::GetSMILOverrideStyle
     */
                pub mSMILOverrideStyle: root::nsCOMPtr<root::nsICSSDeclaration>,
                /**
     * Holds any SMIL override style declaration for this element.
     */
                pub mSMILOverrideStyleDeclaration: root::RefPtr<root::mozilla::DeclarationBlock>,
                /**
     * An object implementing nsIDOMMozNamedAttrMap for this content (attributes)
     * @see FragmentOrElement::GetAttributes
     */
                pub mAttributeMap: root::RefPtr<root::nsDOMAttributeMap>,
                pub __bindgen_anon_1: root::mozilla::dom::FragmentOrElement_nsDOMSlots__bindgen_ty_1,
                /**
     * An object implementing the .children property for this element.
     */
                pub mChildrenList: root::RefPtr<root::nsContentList>,
                /**
     * An object implementing the .classList property for this element.
     */
                pub mClassList: root::RefPtr<root::nsDOMTokenList>,
                /**
     * ShadowRoot bound to the element.
     */
                pub mShadowRoot: root::RefPtr<root::mozilla::dom::ShadowRoot>,
                /**
     * The root ShadowRoot of this element if it is in a shadow tree.
     */
                pub mContainingShadow: root::RefPtr<root::mozilla::dom::ShadowRoot>,
                /**
     * An array of web component insertion points to which this element
     * is distributed.
     */
                pub mDestInsertionPoints: root::nsTArray<*mut root::nsIContent>,
                /**
     * XBL binding installed on the element.
     */
                pub mXBLBinding: root::RefPtr<root::nsXBLBinding>,
                /**
     * XBL binding installed on the lement.
     */
                pub mXBLInsertionParent: root::nsCOMPtr<root::nsIContent>,
                /**
     * Web components custom element data.
     */
                pub mCustomElementData: root::RefPtr<root::mozilla::dom::CustomElementData>,
                /**
     * Registered Intersection Observers on the element.
     */
                pub mRegisteredIntersectionObservers: [u64; 5usize],
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct FragmentOrElement_nsDOMSlots__bindgen_ty_1 {
                /**
      * The nearest enclosing content node with a binding that created us.
      * @see FragmentOrElement::GetBindingParent
      */
                pub mBindingParent: root::__BindgenUnionField<*mut root::nsIContent>,
                /**
      * The controllers of the XUL Element.
      */
                pub mControllers: root::__BindgenUnionField<*mut root::nsIControllers>,
                pub bindgen_union_field: u64,
            }
            #[test]
            fn bindgen_test_layout_FragmentOrElement_nsDOMSlots__bindgen_ty_1() {
                assert_eq!(::std::mem::size_of::<FragmentOrElement_nsDOMSlots__bindgen_ty_1>()
                           , 8usize , concat ! (
                           "Size of: " , stringify ! (
                           FragmentOrElement_nsDOMSlots__bindgen_ty_1 ) ));
                assert_eq! (::std::mem::align_of::<FragmentOrElement_nsDOMSlots__bindgen_ty_1>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            FragmentOrElement_nsDOMSlots__bindgen_ty_1 ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const
                            FragmentOrElement_nsDOMSlots__bindgen_ty_1 ) ) .
                            mBindingParent as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots__bindgen_ty_1 ) ,
                            "::" , stringify ! ( mBindingParent ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const
                            FragmentOrElement_nsDOMSlots__bindgen_ty_1 ) ) .
                            mControllers as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots__bindgen_ty_1 ) ,
                            "::" , stringify ! ( mControllers ) ));
            }
            impl Clone for FragmentOrElement_nsDOMSlots__bindgen_ty_1 {
                fn clone(&self) -> Self { *self }
            }
            #[test]
            fn bindgen_test_layout_FragmentOrElement_nsDOMSlots() {
                assert_eq!(::std::mem::size_of::<FragmentOrElement_nsDOMSlots>()
                           , 200usize , concat ! (
                           "Size of: " , stringify ! (
                           FragmentOrElement_nsDOMSlots ) ));
                assert_eq! (::std::mem::align_of::<FragmentOrElement_nsDOMSlots>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mStyle as * const _ as usize } , 48usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mStyle ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mDataset as * const _ as usize } , 56usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mDataset ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mSMILOverrideStyle as * const _ as usize } ,
                            64usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mSMILOverrideStyle ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mSMILOverrideStyleDeclaration as * const _ as
                            usize } , 72usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mSMILOverrideStyleDeclaration ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mAttributeMap as * const _ as usize } , 80usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mAttributeMap ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mChildrenList as * const _ as usize } , 96usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mChildrenList ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mClassList as * const _ as usize } , 104usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mClassList ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mShadowRoot as * const _ as usize } , 112usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mShadowRoot ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mContainingShadow as * const _ as usize } ,
                            120usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mContainingShadow ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mDestInsertionPoints as * const _ as usize } ,
                            128usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mDestInsertionPoints ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mXBLBinding as * const _ as usize } , 136usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mXBLBinding ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mXBLInsertionParent as * const _ as usize } ,
                            144usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mXBLInsertionParent ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mCustomElementData as * const _ as usize } ,
                            152usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mCustomElementData ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const FragmentOrElement_nsDOMSlots ) )
                            . mRegisteredIntersectionObservers as * const _ as
                            usize } , 160usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement_nsDOMSlots ) , "::" , stringify
                            ! ( mRegisteredIntersectionObservers ) ));
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom17FragmentOrElement21_cycleCollectorGlobalE"]
                pub static mut FragmentOrElement__cycleCollectorGlobal:
                           root::mozilla::dom::FragmentOrElement_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_FragmentOrElement() {
                assert_eq!(::std::mem::size_of::<FragmentOrElement>() ,
                           112usize , concat ! (
                           "Size of: " , stringify ! ( FragmentOrElement ) ));
                assert_eq! (::std::mem::align_of::<FragmentOrElement>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! ( FragmentOrElement
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FragmentOrElement ) ) .
                            mRefCnt as * const _ as usize } , 96usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement ) , "::" , stringify ! ( mRefCnt
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FragmentOrElement ) ) .
                            mAttrsAndChildren as * const _ as usize } ,
                            104usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            FragmentOrElement ) , "::" , stringify ! (
                            mAttrsAndChildren ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct DOMRect {
                pub _base: root::mozilla::dom::DOMRectReadOnly,
                pub _base_1: root::nsIDOMClientRect,
                pub mX: f64,
                pub mY: f64,
                pub mWidth: f64,
                pub mHeight: f64,
            }
            #[test]
            fn bindgen_test_layout_DOMRect() {
                assert_eq!(::std::mem::size_of::<DOMRect>() , 88usize , concat
                           ! ( "Size of: " , stringify ! ( DOMRect ) ));
                assert_eq! (::std::mem::align_of::<DOMRect>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( DOMRect ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct DOMRectList {
                pub _base: root::nsIDOMClientRectList,
                pub _base_1: root::nsWrapperCache,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mArray: root::nsTArray<root::RefPtr<root::mozilla::dom::DOMRect>>,
                pub mParent: root::nsCOMPtr<root::nsISupports>,
            }
            pub type DOMRectList_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DOMRectList_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_DOMRectList_cycleCollection() {
                assert_eq!(::std::mem::size_of::<DOMRectList_cycleCollection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           DOMRectList_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<DOMRectList_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            DOMRectList_cycleCollection ) ));
            }
            impl Clone for DOMRectList_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom11DOMRectList21_cycleCollectorGlobalE"]
                pub static mut DOMRectList__cycleCollectorGlobal:
                           root::mozilla::dom::DOMRectList_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_DOMRectList() {
                assert_eq!(::std::mem::size_of::<DOMRectList>() , 56usize ,
                           concat ! (
                           "Size of: " , stringify ! ( DOMRectList ) ));
                assert_eq! (::std::mem::align_of::<DOMRectList>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( DOMRectList ) ));
            }
            pub type DOMTokenListSupportedToken =
                *const ::std::os::raw::c_char;
            pub type DOMTokenListSupportedTokenArray =
                *mut root::mozilla::dom::DOMTokenListSupportedToken;
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum ScrollLogicalPosition {
                Start = 0,
                End = 1,
                EndGuard_ = 2,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct ScrollIntoViewOptions {
                pub _base: root::mozilla::dom::ScrollOptions,
                pub mBlock: root::mozilla::dom::ScrollLogicalPosition,
            }
            #[test]
            fn bindgen_test_layout_ScrollIntoViewOptions() {
                assert_eq!(::std::mem::size_of::<ScrollIntoViewOptions>() ,
                           3usize , concat ! (
                           "Size of: " , stringify ! ( ScrollIntoViewOptions )
                           ));
                assert_eq! (::std::mem::align_of::<ScrollIntoViewOptions>() ,
                            1usize , concat ! (
                            "Alignment of " , stringify ! (
                            ScrollIntoViewOptions ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ScrollIntoViewOptions ) ) .
                            mBlock as * const _ as usize } , 2usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            ScrollIntoViewOptions ) , "::" , stringify ! (
                            mBlock ) ));
            }
            impl Clone for ScrollIntoViewOptions {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct DOMIntersectionObserverEntry {
                pub _base: root::nsISupports,
                pub _base_1: root::nsWrapperCache,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mOwner: root::nsCOMPtr<root::nsISupports>,
                pub mTime: root::DOMHighResTimeStamp,
                pub mRootBounds: root::RefPtr<root::mozilla::dom::DOMRect>,
                pub mBoundingClientRect: root::RefPtr<root::mozilla::dom::DOMRect>,
                pub mIntersectionRect: root::RefPtr<root::mozilla::dom::DOMRect>,
                pub mTarget: root::RefPtr<root::mozilla::dom::Element>,
                pub mIntersectionRatio: f64,
            }
            pub type DOMIntersectionObserverEntry_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DOMIntersectionObserverEntry_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_DOMIntersectionObserverEntry_cycleCollection() {
                assert_eq!(::std::mem::size_of::<DOMIntersectionObserverEntry_cycleCollection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           DOMIntersectionObserverEntry_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<DOMIntersectionObserverEntry_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            DOMIntersectionObserverEntry_cycleCollection ) ));
            }
            impl Clone for DOMIntersectionObserverEntry_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom28DOMIntersectionObserverEntry21_cycleCollectorGlobalE"]
                pub static mut
                           DOMIntersectionObserverEntry__cycleCollectorGlobal:
                           root::mozilla::dom::DOMIntersectionObserverEntry_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_DOMIntersectionObserverEntry() {
                assert_eq!(::std::mem::size_of::<DOMIntersectionObserverEntry>()
                           , 96usize , concat ! (
                           "Size of: " , stringify ! (
                           DOMIntersectionObserverEntry ) ));
                assert_eq! (::std::mem::align_of::<DOMIntersectionObserverEntry>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            DOMIntersectionObserverEntry ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IntersectionCallback {
                pub _base: root::mozilla::dom::CallbackFunction,
            }
            #[test]
            fn bindgen_test_layout_IntersectionCallback() {
                assert_eq!(::std::mem::size_of::<IntersectionCallback>() ,
                           48usize , concat ! (
                           "Size of: " , stringify ! ( IntersectionCallback )
                           ));
                assert_eq! (::std::mem::align_of::<IntersectionCallback>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            IntersectionCallback ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct OwningDoubleOrDoubleSequence {
                pub mType: root::mozilla::dom::OwningDoubleOrDoubleSequence_Type,
                pub mValue: root::mozilla::dom::OwningDoubleOrDoubleSequence_Value,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum OwningDoubleOrDoubleSequence_Type {
                eUninitialized = 0,
                eDouble = 1,
                eDoubleSequence = 2,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct OwningDoubleOrDoubleSequence_Value {
                pub mDouble: root::__BindgenUnionField<root::mozilla::dom::UnionMember<f64>>,
                pub mDoubleSequence: root::__BindgenUnionField<root::mozilla::dom::UnionMember<u64>>,
                pub bindgen_union_field: u64,
            }
            #[test]
            fn bindgen_test_layout_OwningDoubleOrDoubleSequence_Value() {
                assert_eq!(::std::mem::size_of::<OwningDoubleOrDoubleSequence_Value>()
                           , 8usize , concat ! (
                           "Size of: " , stringify ! (
                           OwningDoubleOrDoubleSequence_Value ) ));
                assert_eq! (::std::mem::align_of::<OwningDoubleOrDoubleSequence_Value>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            OwningDoubleOrDoubleSequence_Value ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const OwningDoubleOrDoubleSequence_Value )
                            ) . mDouble as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            OwningDoubleOrDoubleSequence_Value ) , "::" ,
                            stringify ! ( mDouble ) ));
                assert_eq! (unsafe {
                            & (
                            * (
                            0 as * const OwningDoubleOrDoubleSequence_Value )
                            ) . mDoubleSequence as * const _ as usize } ,
                            0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            OwningDoubleOrDoubleSequence_Value ) , "::" ,
                            stringify ! ( mDoubleSequence ) ));
            }
            impl Clone for OwningDoubleOrDoubleSequence_Value {
                fn clone(&self) -> Self { *self }
            }
            #[test]
            fn bindgen_test_layout_OwningDoubleOrDoubleSequence() {
                assert_eq!(::std::mem::size_of::<OwningDoubleOrDoubleSequence>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           OwningDoubleOrDoubleSequence ) ));
                assert_eq! (::std::mem::align_of::<OwningDoubleOrDoubleSequence>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            OwningDoubleOrDoubleSequence ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const OwningDoubleOrDoubleSequence ) )
                            . mType as * const _ as usize } , 0usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            OwningDoubleOrDoubleSequence ) , "::" , stringify
                            ! ( mType ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const OwningDoubleOrDoubleSequence ) )
                            . mValue as * const _ as usize } , 8usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            OwningDoubleOrDoubleSequence ) , "::" , stringify
                            ! ( mValue ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IntersectionObserverInit {
                pub _base: root::mozilla::dom::DictionaryBase,
                pub mRoot: root::RefPtr<root::mozilla::dom::Element>,
                pub mRootMargin: ::nsstring::nsStringRepr,
                pub mThreshold: root::mozilla::dom::OwningDoubleOrDoubleSequence,
            }
            #[test]
            fn bindgen_test_layout_IntersectionObserverInit() {
                assert_eq!(::std::mem::size_of::<IntersectionObserverInit>() ,
                           48usize , concat ! (
                           "Size of: " , stringify ! (
                           IntersectionObserverInit ) ));
                assert_eq! (::std::mem::align_of::<IntersectionObserverInit>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            IntersectionObserverInit ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const IntersectionObserverInit ) )
                            . mRoot as * const _ as usize } , 8usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            IntersectionObserverInit ) , "::" , stringify ! (
                            mRoot ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const IntersectionObserverInit ) )
                            . mRootMargin as * const _ as usize } , 16usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            IntersectionObserverInit ) , "::" , stringify ! (
                            mRootMargin ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const IntersectionObserverInit ) )
                            . mThreshold as * const _ as usize } , 32usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            IntersectionObserverInit ) , "::" , stringify ! (
                            mThreshold ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AnimationFilter([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct UnrestrictedDoubleOrKeyframeAnimationOptions([u8; 0]);
            #[repr(C)]
            #[derive(Debug)]
            pub struct DestinationInsertionPointList {
                pub _base: root::nsINodeList,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mParent: root::RefPtr<root::mozilla::dom::Element>,
                pub mDestinationPoints: root::nsCOMArray<root::nsIContent>,
            }
            pub type DestinationInsertionPointList_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DestinationInsertionPointList_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_DestinationInsertionPointList_cycleCollection() {
                assert_eq!(::std::mem::size_of::<DestinationInsertionPointList_cycleCollection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           DestinationInsertionPointList_cycleCollection ) ));
                assert_eq! (::std::mem::align_of::<DestinationInsertionPointList_cycleCollection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            DestinationInsertionPointList_cycleCollection )
                            ));
            }
            impl Clone for DestinationInsertionPointList_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom29DestinationInsertionPointList21_cycleCollectorGlobalE"]
                pub static mut
                           DestinationInsertionPointList__cycleCollectorGlobal:
                           root::mozilla::dom::DestinationInsertionPointList_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_DestinationInsertionPointList() {
                assert_eq!(::std::mem::size_of::<DestinationInsertionPointList>()
                           , 56usize , concat ! (
                           "Size of: " , stringify ! (
                           DestinationInsertionPointList ) ));
                assert_eq! (::std::mem::align_of::<DestinationInsertionPointList>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            DestinationInsertionPointList ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const DestinationInsertionPointList ) )
                            . mRefCnt as * const _ as usize } , 32usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            DestinationInsertionPointList ) , "::" , stringify
                            ! ( mRefCnt ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const DestinationInsertionPointList ) )
                            . mParent as * const _ as usize } , 40usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            DestinationInsertionPointList ) , "::" , stringify
                            ! ( mParent ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const DestinationInsertionPointList ) )
                            . mDestinationPoints as * const _ as usize } ,
                            48usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            DestinationInsertionPointList ) , "::" , stringify
                            ! ( mDestinationPoints ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Grid([u8; 0]);
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ErrorResult {
            pub _bindgen_opaque_blob: [u64; 2usize],
        }
        pub type ErrorResult_BaseErrorResult =
            root::mozilla::binding_danger::TErrorResult<root::mozilla::binding_danger::AssertAndSuppressCleanupPolicy>;
        #[test]
        fn bindgen_test_layout_ErrorResult() {
            assert_eq!(::std::mem::size_of::<ErrorResult>() , 16usize , concat
                       ! ( "Size of: " , stringify ! ( ErrorResult ) ));
            assert_eq! (::std::mem::align_of::<ErrorResult>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ErrorResult ) ));
        }
        impl Clone for ErrorResult {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct OOMReporter {
            pub _base: root::mozilla::dom::binding_detail::FastErrorResult,
        }
        #[test]
        fn bindgen_test_layout_OOMReporter() {
            assert_eq!(::std::mem::size_of::<OOMReporter>() , 16usize , concat
                       ! ( "Size of: " , stringify ! ( OOMReporter ) ));
            assert_eq! (::std::mem::align_of::<OOMReporter>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( OOMReporter ) ));
        }
        pub mod binding_danger {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            /**
 * Templated implementation class for various ErrorResult-like things.  The
 * instantiations differ only in terms of their cleanup policies (used in the
 * destructor), which they can specify via the template argument.  Note that
 * this means it's safe to reinterpret_cast between the instantiations unless
 * you plan to invoke the destructor through such a cast pointer.
 *
 * A cleanup policy consists of two booleans: whether to assert that we've been
 * reported or suppressed, and whether to then go ahead and suppress the
 * exception.
 */
            #[repr(C)]
            #[derive(Debug)]
            pub struct TErrorResult<CleanupPolicy> {
                pub mResult: root::nsresult,
                pub __bindgen_anon_1: root::mozilla::binding_danger::TErrorResult__bindgen_ty_1<CleanupPolicy>,
                pub _phantom_0: ::std::marker::PhantomData<CleanupPolicy>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TErrorResult_Message<CleanupPolicy> {
                pub _address: u8,
                pub _phantom_0: ::std::marker::PhantomData<CleanupPolicy>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TErrorResult_DOMExceptionInfo<CleanupPolicy> {
                pub _address: u8,
                pub _phantom_0: ::std::marker::PhantomData<CleanupPolicy>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TErrorResult__bindgen_ty_1<CleanupPolicy> {
                pub mMessage: root::__BindgenUnionField<*mut root::mozilla::binding_danger::TErrorResult_Message<CleanupPolicy>>,
                pub mJSException: root::__BindgenUnionField<root::JS::Value>,
                pub mDOMExceptionInfo: root::__BindgenUnionField<*mut root::mozilla::binding_danger::TErrorResult_DOMExceptionInfo<CleanupPolicy>>,
                pub bindgen_union_field: u64,
                pub _phantom_0: ::std::marker::PhantomData<CleanupPolicy>,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct JustAssertCleanupPolicy {
                pub _address: u8,
            }
            pub const JustAssertCleanupPolicy_assertHandled: bool = true;
            pub const JustAssertCleanupPolicy_suppress: bool = false;
            #[test]
            fn bindgen_test_layout_JustAssertCleanupPolicy() {
                assert_eq!(::std::mem::size_of::<JustAssertCleanupPolicy>() ,
                           1usize , concat ! (
                           "Size of: " , stringify ! ( JustAssertCleanupPolicy
                           ) ));
                assert_eq! (::std::mem::align_of::<JustAssertCleanupPolicy>()
                            , 1usize , concat ! (
                            "Alignment of " , stringify ! (
                            JustAssertCleanupPolicy ) ));
            }
            impl Clone for JustAssertCleanupPolicy {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct AssertAndSuppressCleanupPolicy {
                pub _address: u8,
            }
            pub const AssertAndSuppressCleanupPolicy_assertHandled: bool =
                true;
            pub const AssertAndSuppressCleanupPolicy_suppress: bool = true;
            #[test]
            fn bindgen_test_layout_AssertAndSuppressCleanupPolicy() {
                assert_eq!(::std::mem::size_of::<AssertAndSuppressCleanupPolicy>()
                           , 1usize , concat ! (
                           "Size of: " , stringify ! (
                           AssertAndSuppressCleanupPolicy ) ));
                assert_eq! (::std::mem::align_of::<AssertAndSuppressCleanupPolicy>()
                            , 1usize , concat ! (
                            "Alignment of " , stringify ! (
                            AssertAndSuppressCleanupPolicy ) ));
            }
            impl Clone for AssertAndSuppressCleanupPolicy {
                fn clone(&self) -> Self { *self }
            }
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum TaskCategory {
            UI = 0,
            Network = 1,
            Timer = 2,
            Worker = 3,
            IdleCallback = 4,
            RefreshDriver = 5,
            GarbageCollection = 6,
            Other = 7,
            Count = 8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AbstractThread([u8; 0]);
        #[repr(C)]
        #[derive(Debug)]
        pub struct OriginAttributes {
            pub _base: root::mozilla::dom::OriginAttributesDictionary,
        }
        pub const OriginAttributes_STRIP_FIRST_PARTY_DOMAIN:
                  root::mozilla::OriginAttributes__bindgen_ty_1 =
            OriginAttributes__bindgen_ty_1::STRIP_FIRST_PARTY_DOMAIN;
        pub const OriginAttributes_STRIP_ADDON_ID:
                  root::mozilla::OriginAttributes__bindgen_ty_1 =
            OriginAttributes__bindgen_ty_1::STRIP_ADDON_ID;
        pub const OriginAttributes_STRIP_USER_CONTEXT_ID:
                  root::mozilla::OriginAttributes__bindgen_ty_1 =
            OriginAttributes__bindgen_ty_1::STRIP_USER_CONTEXT_ID;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum OriginAttributes__bindgen_ty_1 {
            STRIP_FIRST_PARTY_DOMAIN = 1,
            STRIP_ADDON_ID = 2,
            STRIP_USER_CONTEXT_ID = 4,
        }
        extern "C" {
            #[link_name =
                  "_ZN7mozilla16OriginAttributes20sFirstPartyIsolationE"]
            pub static mut OriginAttributes_sFirstPartyIsolation: bool;
        }
        extern "C" {
            #[link_name =
                  "_ZN7mozilla16OriginAttributes23sRestrictedOpenerAccessE"]
            pub static mut OriginAttributes_sRestrictedOpenerAccess: bool;
        }
        #[test]
        fn bindgen_test_layout_OriginAttributes() {
            assert_eq!(::std::mem::size_of::<OriginAttributes>() , 64usize ,
                       concat ! (
                       "Size of: " , stringify ! ( OriginAttributes ) ));
            assert_eq! (::std::mem::align_of::<OriginAttributes>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( OriginAttributes ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WidgetEvent([u8; 0]);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WidgetGUIEvent([u8; 0]);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WidgetInputEvent([u8; 0]);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EventFlags([u8; 0]);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ShortcutKeyCandidate([u8; 0]);
        #[repr(C)]
        #[derive(Debug)]
        pub struct Runnable {
            pub _base: root::nsIRunnable,
            pub _base_1: root::nsINamed,
            pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
            pub mName: *const ::std::os::raw::c_char,
        }
        pub type Runnable_HasThreadSafeRefCnt = root::mozilla::TrueType;
        #[test]
        fn bindgen_test_layout_Runnable() {
            assert_eq!(::std::mem::size_of::<Runnable>() , 32usize , concat !
                       ( "Size of: " , stringify ! ( Runnable ) ));
            assert_eq! (::std::mem::align_of::<Runnable>() , 8usize , concat !
                        ( "Alignment of " , stringify ! ( Runnable ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EventChainVisitor([u8; 0]);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EventChainPostVisitor([u8; 0]);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EventChainPreVisitor([u8; 0]);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EventListenerManager([u8; 0]);
        /**
 * BlockingResourceBase
 * Base class of resources that might block clients trying to acquire them.
 * Does debugging and deadlock detection in DEBUG builds.
 **/
        #[repr(C)]
        #[derive(Debug)]
        pub struct BlockingResourceBase {
            pub _address: u8,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum BlockingResourceBase_BlockingResourceType {
            eMutex = 0,
            eReentrantMonitor = 1,
            eCondVar = 2,
        }
        extern "C" {
            #[link_name =
                  "_ZN7mozilla20BlockingResourceBase17kResourceTypeNameE"]
            pub static mut BlockingResourceBase_kResourceTypeName:
                       [*const ::std::os::raw::c_char; 0usize];
        }
        #[test]
        fn bindgen_test_layout_BlockingResourceBase() {
            assert_eq!(::std::mem::size_of::<BlockingResourceBase>() , 1usize
                       , concat ! (
                       "Size of: " , stringify ! ( BlockingResourceBase ) ));
            assert_eq! (::std::mem::align_of::<BlockingResourceBase>() ,
                        1usize , concat ! (
                        "Alignment of " , stringify ! ( BlockingResourceBase )
                        ));
        }
        /**
 * OffTheBooksMutex is identical to Mutex, except that OffTheBooksMutex doesn't
 * include leak checking.  Sometimes you want to intentionally "leak" a mutex
 * until shutdown; in these cases, OffTheBooksMutex is for you.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct OffTheBooksMutex {
            pub mLock: *mut root::PRLock,
        }
        #[test]
        fn bindgen_test_layout_OffTheBooksMutex() {
            assert_eq!(::std::mem::size_of::<OffTheBooksMutex>() , 8usize ,
                       concat ! (
                       "Size of: " , stringify ! ( OffTheBooksMutex ) ));
            assert_eq! (::std::mem::align_of::<OffTheBooksMutex>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( OffTheBooksMutex ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const OffTheBooksMutex ) ) . mLock as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        OffTheBooksMutex ) , "::" , stringify ! ( mLock ) ));
        }
        /**
 * Mutex
 * When possible, use MutexAutoLock/MutexAutoUnlock to lock/unlock this
 * mutex within a scope, instead of calling Lock/Unlock directly.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct Mutex {
            pub _base: root::mozilla::OffTheBooksMutex,
        }
        #[test]
        fn bindgen_test_layout_Mutex() {
            assert_eq!(::std::mem::size_of::<Mutex>() , 8usize , concat ! (
                       "Size of: " , stringify ! ( Mutex ) ));
            assert_eq! (::std::mem::align_of::<Mutex>() , 8usize , concat ! (
                        "Alignment of " , stringify ! ( Mutex ) ));
        }
        pub mod net {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum ReferrerPolicy {
                RP_No_Referrer = 2,
                RP_Origin = 3,
                RP_No_Referrer_When_Downgrade = 1,
                RP_Origin_When_Crossorigin = 4,
                RP_Unsafe_URL = 5,
                RP_Same_Origin = 6,
                RP_Strict_Origin = 7,
                RP_Strict_Origin_When_Cross_Origin = 8,
                RP_Unset = 0,
            }
        }
        pub const FlushType_Frames: root::mozilla::FlushType =
            FlushType::Style;
        #[repr(u8)]
        /**
 * This is the enum used by nsIDocument::FlushPendingNotifications to
 * decide what to flush.
 *
 * Please note that if you change these values, you should sync it with the
 * flushTypeNames array inside PresShell::FlushPendingNotifications.
 */
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum FlushType {
            None = 0,
            Content = 1,
            ContentAndNotify = 2,
            Style = 3,
            InterruptibleLayout = 4,
            Layout = 5,
            Display = 6,
            Count = 7,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ChangesToFlush {
            pub mFlushType: root::mozilla::FlushType,
            pub mFlushAnimations: bool,
        }
        #[test]
        fn bindgen_test_layout_ChangesToFlush() {
            assert_eq!(::std::mem::size_of::<ChangesToFlush>() , 2usize ,
                       concat ! ( "Size of: " , stringify ! ( ChangesToFlush )
                       ));
            assert_eq! (::std::mem::align_of::<ChangesToFlush>() , 1usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ChangesToFlush ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ChangesToFlush ) ) . mFlushType
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( ChangesToFlush
                        ) , "::" , stringify ! ( mFlushType ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ChangesToFlush ) ) .
                        mFlushAnimations as * const _ as usize } , 1usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ChangesToFlush
                        ) , "::" , stringify ! ( mFlushAnimations ) ));
        }
        impl Clone for ChangesToFlush {
            fn clone(&self) -> Self { *self }
        }
        /**
 * EventStates is the class used to represent the event states of nsIContent
 * instances. These states are calculated by IntrinsicState() and
 * ContentStatesChanged() has to be called when one of them changes thus
 * informing the layout/style engine of the change.
 * Event states are associated with pseudo-classes.
 */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct EventStates {
            pub mStates: root::mozilla::EventStates_InternalType,
        }
        pub type EventStates_InternalType = u64;
        pub type EventStates_ServoType = u16;
        #[test]
        fn bindgen_test_layout_EventStates() {
            assert_eq!(::std::mem::size_of::<EventStates>() , 8usize , concat
                       ! ( "Size of: " , stringify ! ( EventStates ) ));
            assert_eq! (::std::mem::align_of::<EventStates>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( EventStates ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const EventStates ) ) . mStates as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( EventStates ) ,
                        "::" , stringify ! ( mStates ) ));
        }
        impl Clone for EventStates {
            fn clone(&self) -> Self { *self }
        }
        pub mod css {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(u32)]
            /**
 * Enum defining the mode in which a sheet is to be parsed.  This is
 * usually, but not always, the same as the cascade level at which the
 * sheet will apply (see nsStyleSet.h).  Most of the Loader APIs only
 * support loading of author sheets.
 *
 * Author sheets are the normal case: styles embedded in or linked
 * from HTML pages.  They are also the most restricted.
 *
 * User sheets can do anything author sheets can do, and also get
 * access to a few CSS extensions that are not yet suitable for
 * exposure on the public Web, but are very useful for expressing
 * user style overrides, such as @-moz-document rules.
 *
 * Agent sheets have access to all author- and user-sheet features
 * plus more extensions that are necessary for internal use but,
 * again, not yet suitable for exposure on the public Web.  Some of
 * these are outright unsafe to expose; in particular, incorrect
 * styling of anonymous box pseudo-elements can violate layout
 * invariants.
 */
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum SheetParsingMode {
                eAuthorSheetFeatures = 0,
                eUserSheetFeatures = 1,
                eAgentSheetFeatures = 2,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ImportRule([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Rule([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Loader([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ImageLoader([u8; 0]);
            #[repr(C)]
            pub struct URLValueData__bindgen_vtable {
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct URLValueData {
                pub vtable_: *const URLValueData__bindgen_vtable,
                pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
                pub mURI: root::nsMainThreadPtrHandle<root::nsIURI>,
                pub mBaseURI: root::nsMainThreadPtrHandle<root::nsIURI>,
                pub mString: root::RefPtr<root::nsStringBuffer>,
                pub mReferrer: root::nsMainThreadPtrHandle<root::nsIURI>,
                pub mOriginPrincipal: root::nsMainThreadPtrHandle<root::nsIPrincipal>,
                pub mURIResolved: bool,
                pub mIsLocalRef: bool,
            }
            pub type URLValueData_HasThreadSafeRefCnt =
                root::mozilla::TrueType;
            #[test]
            fn bindgen_test_layout_URLValueData() {
                assert_eq!(::std::mem::size_of::<URLValueData>() , 64usize ,
                           concat ! (
                           "Size of: " , stringify ! ( URLValueData ) ));
                assert_eq! (::std::mem::align_of::<URLValueData>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( URLValueData ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLValueData ) ) . mRefCnt as
                            * const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            URLValueData ) , "::" , stringify ! ( mRefCnt )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLValueData ) ) . mURI as *
                            const _ as usize } , 16usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            URLValueData ) , "::" , stringify ! ( mURI ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLValueData ) ) . mBaseURI
                            as * const _ as usize } , 24usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            URLValueData ) , "::" , stringify ! ( mBaseURI )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLValueData ) ) . mString as
                            * const _ as usize } , 32usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            URLValueData ) , "::" , stringify ! ( mString )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLValueData ) ) . mReferrer
                            as * const _ as usize } , 40usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            URLValueData ) , "::" , stringify ! ( mReferrer )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLValueData ) ) .
                            mOriginPrincipal as * const _ as usize } , 48usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            URLValueData ) , "::" , stringify ! (
                            mOriginPrincipal ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLValueData ) ) .
                            mURIResolved as * const _ as usize } , 56usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            URLValueData ) , "::" , stringify ! ( mURIResolved
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const URLValueData ) ) .
                            mIsLocalRef as * const _ as usize } , 57usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            URLValueData ) , "::" , stringify ! ( mIsLocalRef
                            ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct URLValue {
                pub _base: root::mozilla::css::URLValueData,
            }
            #[test]
            fn bindgen_test_layout_URLValue() {
                assert_eq!(::std::mem::size_of::<URLValue>() , 64usize ,
                           concat ! ( "Size of: " , stringify ! ( URLValue )
                           ));
                assert_eq! (::std::mem::align_of::<URLValue>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( URLValue ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ImageValue {
                pub _base: root::mozilla::css::URLValueData,
                pub mRequests: [u64; 5usize],
            }
            #[test]
            fn bindgen_test_layout_ImageValue() {
                assert_eq!(::std::mem::size_of::<ImageValue>() , 104usize ,
                           concat ! ( "Size of: " , stringify ! ( ImageValue )
                           ));
                assert_eq! (::std::mem::align_of::<ImageValue>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( ImageValue ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ImageValue ) ) . mRequests as
                            * const _ as usize } , 64usize , concat ! (
                            "Alignment of field: " , stringify ! ( ImageValue
                            ) , "::" , stringify ! ( mRequests ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct GridNamedArea {
                pub mName: ::nsstring::nsStringRepr,
                pub mColumnStart: u32,
                pub mColumnEnd: u32,
                pub mRowStart: u32,
                pub mRowEnd: u32,
            }
            #[test]
            fn bindgen_test_layout_GridNamedArea() {
                assert_eq!(::std::mem::size_of::<GridNamedArea>() , 32usize ,
                           concat ! (
                           "Size of: " , stringify ! ( GridNamedArea ) ));
                assert_eq! (::std::mem::align_of::<GridNamedArea>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( GridNamedArea )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridNamedArea ) ) . mName as
                            * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            GridNamedArea ) , "::" , stringify ! ( mName ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridNamedArea ) ) .
                            mColumnStart as * const _ as usize } , 16usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GridNamedArea ) , "::" , stringify ! (
                            mColumnStart ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridNamedArea ) ) .
                            mColumnEnd as * const _ as usize } , 20usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GridNamedArea ) , "::" , stringify ! ( mColumnEnd
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridNamedArea ) ) . mRowStart
                            as * const _ as usize } , 24usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            GridNamedArea ) , "::" , stringify ! ( mRowStart )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridNamedArea ) ) . mRowEnd
                            as * const _ as usize } , 28usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            GridNamedArea ) , "::" , stringify ! ( mRowEnd )
                            ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct GridTemplateAreasValue {
                pub mNamedAreas: root::nsTArray<root::mozilla::css::GridNamedArea>,
                pub mTemplates: root::nsTArray<::nsstring::nsStringRepr>,
                pub mNColumns: u32,
                pub mRefCnt: root::nsAutoRefCnt,
            }
            pub type GridTemplateAreasValue_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[test]
            fn bindgen_test_layout_GridTemplateAreasValue() {
                assert_eq!(::std::mem::size_of::<GridTemplateAreasValue>() ,
                           32usize , concat ! (
                           "Size of: " , stringify ! ( GridTemplateAreasValue
                           ) ));
                assert_eq! (::std::mem::align_of::<GridTemplateAreasValue>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            GridTemplateAreasValue ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridTemplateAreasValue ) ) .
                            mNamedAreas as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GridTemplateAreasValue ) , "::" , stringify ! (
                            mNamedAreas ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridTemplateAreasValue ) ) .
                            mTemplates as * const _ as usize } , 8usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GridTemplateAreasValue ) , "::" , stringify ! (
                            mTemplates ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridTemplateAreasValue ) ) .
                            mNColumns as * const _ as usize } , 16usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GridTemplateAreasValue ) , "::" , stringify ! (
                            mNColumns ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GridTemplateAreasValue ) ) .
                            mRefCnt as * const _ as usize } , 24usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            GridTemplateAreasValue ) , "::" , stringify ! (
                            mRefCnt ) ));
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct FontFamilyListRefCnt {
                pub _base: root::mozilla::FontFamilyList,
                pub mRefCnt: root::nsAutoRefCnt,
            }
            pub type FontFamilyListRefCnt_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[test]
            fn bindgen_test_layout_FontFamilyListRefCnt() {
                assert_eq!(::std::mem::size_of::<FontFamilyListRefCnt>() ,
                           24usize , concat ! (
                           "Size of: " , stringify ! ( FontFamilyListRefCnt )
                           ));
                assert_eq! (::std::mem::align_of::<FontFamilyListRefCnt>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            FontFamilyListRefCnt ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const FontFamilyListRefCnt ) ) .
                            mRefCnt as * const _ as usize } , 16usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            FontFamilyListRefCnt ) , "::" , stringify ! (
                            mRefCnt ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct RGBAColorData {
                pub mR: f32,
                pub mG: f32,
                pub mB: f32,
                pub mA: f32,
            }
            #[test]
            fn bindgen_test_layout_RGBAColorData() {
                assert_eq!(::std::mem::size_of::<RGBAColorData>() , 16usize ,
                           concat ! (
                           "Size of: " , stringify ! ( RGBAColorData ) ));
                assert_eq! (::std::mem::align_of::<RGBAColorData>() , 4usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( RGBAColorData )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const RGBAColorData ) ) . mR as *
                            const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            RGBAColorData ) , "::" , stringify ! ( mR ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const RGBAColorData ) ) . mG as *
                            const _ as usize } , 4usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            RGBAColorData ) , "::" , stringify ! ( mG ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const RGBAColorData ) ) . mB as *
                            const _ as usize } , 8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            RGBAColorData ) , "::" , stringify ! ( mB ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const RGBAColorData ) ) . mA as *
                            const _ as usize } , 12usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            RGBAColorData ) , "::" , stringify ! ( mA ) ));
            }
            impl Clone for RGBAColorData {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct ComplexColorData {
                pub mColor: root::mozilla::css::RGBAColorData,
                pub mForegroundRatio: f32,
            }
            #[test]
            fn bindgen_test_layout_ComplexColorData() {
                assert_eq!(::std::mem::size_of::<ComplexColorData>() , 20usize
                           , concat ! (
                           "Size of: " , stringify ! ( ComplexColorData ) ));
                assert_eq! (::std::mem::align_of::<ComplexColorData>() ,
                            4usize , concat ! (
                            "Alignment of " , stringify ! ( ComplexColorData )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ComplexColorData ) ) . mColor
                            as * const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ComplexColorData ) , "::" , stringify ! ( mColor )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ComplexColorData ) ) .
                            mForegroundRatio as * const _ as usize } , 16usize
                            , concat ! (
                            "Alignment of field: " , stringify ! (
                            ComplexColorData ) , "::" , stringify ! (
                            mForegroundRatio ) ));
            }
            impl Clone for ComplexColorData {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ComplexColorValue {
                pub _base: root::mozilla::css::ComplexColorData,
                pub mRefCnt: root::nsAutoRefCnt,
            }
            pub type ComplexColorValue_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[test]
            fn bindgen_test_layout_ComplexColorValue() {
                assert_eq!(::std::mem::size_of::<ComplexColorValue>() ,
                           32usize , concat ! (
                           "Size of: " , stringify ! ( ComplexColorValue ) ));
                assert_eq! (::std::mem::align_of::<ComplexColorValue>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! ( ComplexColorValue
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ComplexColorValue ) ) .
                            mRefCnt as * const _ as usize } , 24usize , concat
                            ! (
                            "Alignment of field: " , stringify ! (
                            ComplexColorValue ) , "::" , stringify ! ( mRefCnt
                            ) ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DocumentRule([u8; 0]);
        }
        /**
 * Superclass for data common to CSSStyleSheet and ServoStyleSheet.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct StyleSheet {
            pub _base: root::nsIDOMCSSStyleSheet,
            pub _base_1: root::nsWrapperCache,
            pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
            pub mParent: *mut root::mozilla::StyleSheet,
            pub mTitle: ::nsstring::nsStringRepr,
            pub mDocument: *mut root::nsIDocument,
            pub mOwningNode: *mut root::nsINode,
            pub mMedia: root::RefPtr<root::nsMediaList>,
            pub mNext: root::RefPtr<root::mozilla::StyleSheet>,
            pub mParsingMode: root::mozilla::css::SheetParsingMode,
            pub mType: root::mozilla::StyleBackendType,
            pub mDisabled: bool,
            pub mDocumentAssociationMode: root::mozilla::StyleSheet_DocumentAssociationMode,
            pub mInner: *mut root::mozilla::StyleSheetInfo,
        }
        pub type StyleSheet_HasThreadSafeRefCnt = root::mozilla::FalseType;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleSheet_cycleCollection {
            pub _base: root::nsXPCOMCycleCollectionParticipant,
        }
        #[test]
        fn bindgen_test_layout_StyleSheet_cycleCollection() {
            assert_eq!(::std::mem::size_of::<StyleSheet_cycleCollection>() ,
                       16usize , concat ! (
                       "Size of: " , stringify ! ( StyleSheet_cycleCollection
                       ) ));
            assert_eq! (::std::mem::align_of::<StyleSheet_cycleCollection>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! (
                        StyleSheet_cycleCollection ) ));
        }
        impl Clone for StyleSheet_cycleCollection {
            fn clone(&self) -> Self { *self }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleSheet_DocumentAssociationMode {
            OwnedByDocument = 0,
            NotOwnedByDocument = 1,
        }
        extern "C" {
            #[link_name = "_ZN7mozilla10StyleSheet21_cycleCollectorGlobalE"]
            pub static mut StyleSheet__cycleCollectorGlobal:
                       root::mozilla::StyleSheet_cycleCollection;
        }
        #[test]
        fn bindgen_test_layout_StyleSheet() {
            assert_eq!(::std::mem::size_of::<StyleSheet>() , 120usize , concat
                       ! ( "Size of: " , stringify ! ( StyleSheet ) ));
            assert_eq! (::std::mem::align_of::<StyleSheet>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( StyleSheet ) ));
        }
        #[repr(u8)]
        /**
 * Enumeration that represents one of the two supported style system backends.
 */
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBackendType { None = 0, Gecko = 1, Servo = 2, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum CORSMode {
            CORS_NONE = 0,
            CORS_ANONYMOUS = 1,
            CORS_USE_CREDENTIALS = 2,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ServoStyleSheet([u8; 0]);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StyleSheetInfo([u8; 0]);
        #[repr(i16)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum UseCounter {
            eUseCounter_UNKNOWN = -1,
            eUseCounter_SVGSVGElement_getElementById = 0,
            eUseCounter_SVGSVGElement_currentScale_getter = 1,
            eUseCounter_SVGSVGElement_currentScale_setter = 2,
            eUseCounter_property_Fill = 3,
            eUseCounter_property_FillOpacity = 4,
            eUseCounter_PushManager_subscribe = 5,
            eUseCounter_PushSubscription_unsubscribe = 6,
            eUseCounter_Window_sidebar_getter = 7,
            eUseCounter_Window_sidebar_setter = 8,
            eUseCounter_External_addSearchEngine = 9,
            eUseCounter_OfflineResourceList_swapCache = 10,
            eUseCounter_OfflineResourceList_update = 11,
            eUseCounter_OfflineResourceList_status_getter = 12,
            eUseCounter_OfflineResourceList_status_setter = 13,
            eUseCounter_OfflineResourceList_onchecking_getter = 14,
            eUseCounter_OfflineResourceList_onchecking_setter = 15,
            eUseCounter_OfflineResourceList_onerror_getter = 16,
            eUseCounter_OfflineResourceList_onerror_setter = 17,
            eUseCounter_OfflineResourceList_onnoupdate_getter = 18,
            eUseCounter_OfflineResourceList_onnoupdate_setter = 19,
            eUseCounter_OfflineResourceList_ondownloading_getter = 20,
            eUseCounter_OfflineResourceList_ondownloading_setter = 21,
            eUseCounter_OfflineResourceList_onprogress_getter = 22,
            eUseCounter_OfflineResourceList_onprogress_setter = 23,
            eUseCounter_OfflineResourceList_onupdateready_getter = 24,
            eUseCounter_OfflineResourceList_onupdateready_setter = 25,
            eUseCounter_OfflineResourceList_oncached_getter = 26,
            eUseCounter_OfflineResourceList_oncached_setter = 27,
            eUseCounter_OfflineResourceList_onobsolete_getter = 28,
            eUseCounter_OfflineResourceList_onobsolete_setter = 29,
            eUseCounter_DataTransfer_addElement = 30,
            eUseCounter_DataTransfer_mozItemCount_getter = 31,
            eUseCounter_DataTransfer_mozItemCount_setter = 32,
            eUseCounter_DataTransfer_mozCursor_getter = 33,
            eUseCounter_DataTransfer_mozCursor_setter = 34,
            eUseCounter_DataTransfer_mozTypesAt = 35,
            eUseCounter_DataTransfer_mozClearDataAt = 36,
            eUseCounter_DataTransfer_mozSetDataAt = 37,
            eUseCounter_DataTransfer_mozGetDataAt = 38,
            eUseCounter_DataTransfer_mozUserCancelled_getter = 39,
            eUseCounter_DataTransfer_mozUserCancelled_setter = 40,
            eUseCounter_DataTransfer_mozSourceNode_getter = 41,
            eUseCounter_DataTransfer_mozSourceNode_setter = 42,
            eUseCounter_GetAttributeNode = 43,
            eUseCounter_SetAttributeNode = 44,
            eUseCounter_GetAttributeNodeNS = 45,
            eUseCounter_SetAttributeNodeNS = 46,
            eUseCounter_RemoveAttributeNode = 47,
            eUseCounter_CreateAttribute = 48,
            eUseCounter_CreateAttributeNS = 49,
            eUseCounter_NodeValue = 50,
            eUseCounter_TextContent = 51,
            eUseCounter_EnablePrivilege = 52,
            eUseCounter_DOMExceptionCode = 53,
            eUseCounter_NoExposedProps = 54,
            eUseCounter_MutationEvent = 55,
            eUseCounter_Components = 56,
            eUseCounter_PrefixedVisibilityAPI = 57,
            eUseCounter_NodeIteratorDetach = 58,
            eUseCounter_LenientThis = 59,
            eUseCounter_GetPreventDefault = 60,
            eUseCounter_GetSetUserData = 61,
            eUseCounter_MozGetAsFile = 62,
            eUseCounter_UseOfCaptureEvents = 63,
            eUseCounter_UseOfReleaseEvents = 64,
            eUseCounter_UseOfDOM3LoadMethod = 65,
            eUseCounter_ChromeUseOfDOM3LoadMethod = 66,
            eUseCounter_ShowModalDialog = 67,
            eUseCounter_Window_Content = 68,
            eUseCounter_SyncXMLHttpRequest = 69,
            eUseCounter_DataContainerEvent = 70,
            eUseCounter_Window_Controllers = 71,
            eUseCounter_ImportXULIntoContent = 72,
            eUseCounter_PannerNodeDoppler = 73,
            eUseCounter_NavigatorGetUserMedia = 74,
            eUseCounter_WebrtcDeprecatedPrefix = 75,
            eUseCounter_RTCPeerConnectionGetStreams = 76,
            eUseCounter_AppCache = 77,
            eUseCounter_PrefixedImageSmoothingEnabled = 78,
            eUseCounter_PrefixedFullscreenAPI = 79,
            eUseCounter_LenientSetter = 80,
            eUseCounter_FileLastModifiedDate = 81,
            eUseCounter_ImageBitmapRenderingContext_TransferImageBitmap = 82,
            eUseCounter_URLCreateObjectURL_MediaStream = 83,
            eUseCounter_XMLBaseAttribute = 84,
            eUseCounter_Count = 85,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum Side {
            eSideTop = 0,
            eSideRight = 1,
            eSideBottom = 2,
            eSideLeft = 3,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum HalfCorner {
            eCornerTopLeftX = 0,
            eCornerTopLeftY = 1,
            eCornerTopRightX = 2,
            eCornerTopRightY = 3,
            eCornerBottomRightX = 4,
            eCornerBottomRightY = 5,
            eCornerBottomLeftX = 6,
            eCornerBottomLeftY = 7,
        }
        pub type CSSPoint = [u32; 2usize];
        pub type CSSIntPoint = [u32; 2usize];
        pub type CSSSize = [u32; 2usize];
        pub type CSSRect = [u32; 4usize];
        pub type LayoutDeviceIntPoint = [u32; 2usize];
        pub type LayoutDeviceIntSize = [u32; 2usize];
        pub type LayoutDeviceIntRect = [u32; 4usize];
        pub type ScreenIntSize = ();
        pub type ScreenMargin = [u32; 4usize];
        pub type ParentLayerRect = [u32; 4usize];
        pub type CSSToLayoutDeviceScale = u32;
        pub type CSSToParentLayerScale2D = [u32; 2usize];
        pub type LayoutDeviceToLayerScale2D = [u32; 2usize];
        pub type ScreenToLayerScale2D = [u32; 2usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PendingAnimationTracker([u8; 0]);
        /**
 * Smart pointer class that can hold a pointer to either an nsStyleSet
 * or a ServoStyleSet.
 */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleSetHandle {
            pub mPtr: root::mozilla::StyleSetHandle_Ptr,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleSetHandle_Ptr {
            pub mValue: usize,
        }
        #[test]
        fn bindgen_test_layout_StyleSetHandle_Ptr() {
            assert_eq!(::std::mem::size_of::<StyleSetHandle_Ptr>() , 8usize ,
                       concat ! (
                       "Size of: " , stringify ! ( StyleSetHandle_Ptr ) ));
            assert_eq! (::std::mem::align_of::<StyleSetHandle_Ptr>() , 8usize
                        , concat ! (
                        "Alignment of " , stringify ! ( StyleSetHandle_Ptr )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSetHandle_Ptr ) ) . mValue
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleSetHandle_Ptr ) , "::" , stringify ! ( mValue )
                        ));
        }
        impl Clone for StyleSetHandle_Ptr {
            fn clone(&self) -> Self { *self }
        }
        #[test]
        fn bindgen_test_layout_StyleSetHandle() {
            assert_eq!(::std::mem::size_of::<StyleSetHandle>() , 8usize ,
                       concat ! ( "Size of: " , stringify ! ( StyleSetHandle )
                       ));
            assert_eq! (::std::mem::align_of::<StyleSetHandle>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StyleSetHandle ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleSetHandle ) ) . mPtr as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleSetHandle
                        ) , "::" , stringify ! ( mPtr ) ));
        }
        impl Clone for StyleSetHandle {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SVGAttrAnimationRuleProcessor([u8; 0]);
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum SheetType {
            Agent = 0,
            User = 1,
            PresHint = 2,
            SVGAttrAnimation = 3,
            Doc = 4,
            ScopedDoc = 5,
            StyleAttr = 6,
            Override = 7,
            Animation = 8,
            Transition = 9,
            Count = 10,
            Unknown = 255,
        }
        /**
 * This struct represents a combined color from a numeric color and
 * the current foreground color (currentcolor keyword).
 * Conceptually, the formula is "color * (1 - p) + currentcolor * p"
 * where p is mForegroundRatio. See mozilla::LinearBlendColors for
 * the actual algorithm.
 */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleComplexColor {
            pub mColor: root::nscolor,
            pub mForegroundRatio: u8,
            pub mIsAuto: bool,
        }
        #[test]
        fn bindgen_test_layout_StyleComplexColor() {
            assert_eq!(::std::mem::size_of::<StyleComplexColor>() , 8usize ,
                       concat ! (
                       "Size of: " , stringify ! ( StyleComplexColor ) ));
            assert_eq! (::std::mem::align_of::<StyleComplexColor>() , 4usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StyleComplexColor )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleComplexColor ) ) . mColor as
                        * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleComplexColor ) , "::" , stringify ! ( mColor )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleComplexColor ) ) .
                        mForegroundRatio as * const _ as usize } , 4usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleComplexColor ) , "::" , stringify ! (
                        mForegroundRatio ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleComplexColor ) ) . mIsAuto
                        as * const _ as usize } , 5usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleComplexColor ) , "::" , stringify ! ( mIsAuto )
                        ));
        }
        impl Clone for StyleComplexColor {
            fn clone(&self) -> Self { *self }
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum CSSEnabledState {
            eForAllContent = 0,
            eInUASheets = 1,
            eInChrome = 2,
            eIgnoreEnabledState = 255,
        }
        pub const FontFamilyType_eFamily_generic_first:
                  root::mozilla::FontFamilyType =
            FontFamilyType::eFamily_serif;
        pub const FontFamilyType_eFamily_generic_last:
                  root::mozilla::FontFamilyType =
            FontFamilyType::eFamily_fantasy;
        pub const FontFamilyType_eFamily_generic_count:
                  root::mozilla::FontFamilyType =
            FontFamilyType::eFamily_monospace;
        #[repr(u32)]
        /**
 * type of font family name, either a name (e.g. Helvetica) or a
 * generic (e.g. serif, sans-serif), with the ability to distinguish
 * between unquoted and quoted names for serializaiton
 */
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum FontFamilyType {
            eFamily_none = 0,
            eFamily_named = 1,
            eFamily_named_quoted = 2,
            eFamily_serif = 3,
            eFamily_sans_serif = 4,
            eFamily_monospace = 5,
            eFamily_cursive = 6,
            eFamily_fantasy = 7,
            eFamily_moz_variable = 8,
            eFamily_moz_fixed = 9,
        }
        /**
 * font family name, a string for the name if not a generic and
 * a font type indicated named family or which generic family
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct FontFamilyName {
            pub mType: root::mozilla::FontFamilyType,
            pub mName: ::nsstring::nsStringRepr,
        }
        #[test]
        fn bindgen_test_layout_FontFamilyName() {
            assert_eq!(::std::mem::size_of::<FontFamilyName>() , 24usize ,
                       concat ! ( "Size of: " , stringify ! ( FontFamilyName )
                       ));
            assert_eq! (::std::mem::align_of::<FontFamilyName>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( FontFamilyName ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const FontFamilyName ) ) . mType as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( FontFamilyName
                        ) , "::" , stringify ! ( mType ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const FontFamilyName ) ) . mName as *
                        const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( FontFamilyName
                        ) , "::" , stringify ! ( mName ) ));
        }
        /**
 * font family list, array of font families and a default font type.
 * font family names are either named strings or generics. the default
 * font type is used to preserve the variable font fallback behavior
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct FontFamilyList {
            pub mFontlist: root::nsTArray<root::mozilla::FontFamilyName>,
            pub mDefaultFontType: root::mozilla::FontFamilyType,
        }
        #[test]
        fn bindgen_test_layout_FontFamilyList() {
            assert_eq!(::std::mem::size_of::<FontFamilyList>() , 16usize ,
                       concat ! ( "Size of: " , stringify ! ( FontFamilyList )
                       ));
            assert_eq! (::std::mem::align_of::<FontFamilyList>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( FontFamilyList ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const FontFamilyList ) ) . mFontlist as
                        * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( FontFamilyList
                        ) , "::" , stringify ! ( mFontlist ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const FontFamilyList ) ) .
                        mDefaultFontType as * const _ as usize } , 8usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( FontFamilyList
                        ) , "::" , stringify ! ( mDefaultFontType ) ));
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBasicShapeType {
            Polygon = 0,
            Circle = 1,
            Ellipse = 2,
            Inset = 3,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxAlign {
            Stretch = 0,
            Start = 1,
            Center = 2,
            Baseline = 3,
            End = 4,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxDecorationBreak { Slice = 0, Clone = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxDirection { Normal = 0, Reverse = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxOrient { Horizontal = 0, Vertical = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxPack { Start = 0, Center = 1, End = 2, Justify = 3, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxSizing { Content = 0, Border = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleClear {
            None = 0,
            Left = 1,
            Right = 2,
            InlineStart = 3,
            InlineEnd = 4,
            Both = 5,
            Line = 8,
            Max = 13,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleGeometryBox {
            Content = 0,
            Padding = 1,
            Border = 2,
            Margin = 3,
            Fill = 4,
            Stroke = 5,
            View = 6,
            NoClip = 7,
            Text = 8,
            NoBox = 9,
            MozAlmostPadding = 127,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleFillRule { Nonzero = 0, Evenodd = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleFloat {
            None = 0,
            Left = 1,
            Right = 2,
            InlineStart = 3,
            InlineEnd = 4,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleFloatEdge { ContentBox = 0, MarginBox = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleHyphens { None = 0, Manual = 1, Auto = 2, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleShapeRadius { ClosestSide = 0, FarthestSide = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleShapeSourceType {
            None = 0,
            URL = 1,
            Shape = 2,
            Box = 3,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleUserFocus {
            None = 0,
            Ignore = 1,
            Normal = 2,
            SelectAll = 3,
            SelectBefore = 4,
            SelectAfter = 5,
            SelectSame = 6,
            SelectMenu = 7,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleUserSelect {
            None = 0,
            Text = 1,
            Element = 2,
            Elements = 3,
            All = 4,
            Toggle = 5,
            TriState = 6,
            Auto = 7,
            MozAll = 8,
            MozText = 9,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleUserInput {
            None = 0,
            Enabled = 1,
            Disabled = 2,
            Auto = 3,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleUserModify {
            ReadOnly = 0,
            ReadWrite = 1,
            WriteOnly = 2,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleWindowDragging { Default = 0, Drag = 1, NoDrag = 2, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleOrient {
            Inline = 0,
            Block = 1,
            Horizontal = 2,
            Vertical = 3,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleDisplay {
            None = 0,
            Block = 1,
            FlowRoot = 2,
            Inline = 3,
            InlineBlock = 4,
            ListItem = 5,
            Table = 6,
            InlineTable = 7,
            TableRowGroup = 8,
            TableColumn = 9,
            TableColumnGroup = 10,
            TableHeaderGroup = 11,
            TableFooterGroup = 12,
            TableRow = 13,
            TableCell = 14,
            TableCaption = 15,
            Flex = 16,
            InlineFlex = 17,
            Grid = 18,
            InlineGrid = 19,
            Ruby = 20,
            RubyBase = 21,
            RubyBaseContainer = 22,
            RubyText = 23,
            RubyTextContainer = 24,
            Contents = 25,
            WebkitBox = 26,
            WebkitInlineBox = 27,
            MozBox = 28,
            MozInlineBox = 29,
            MozGrid = 30,
            MozInlineGrid = 31,
            MozGridGroup = 32,
            MozGridLine = 33,
            MozStack = 34,
            MozInlineStack = 35,
            MozDeck = 36,
            MozGroupbox = 37,
            MozPopup = 38,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleGridTrackBreadth { MaxContent = 1, MinContent = 2, }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WritingMode([u8; 0]);
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LogicalSide {
            eLogicalSideBStart = 0,
            eLogicalSideBEnd = 1,
            eLogicalSideIStart = 2,
            eLogicalSideIEnd = 3,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ArenaObjectID {
            eArenaObjectID_DummyBeforeFirstObjectID = 536870911,
            eArenaObjectID_nsLineBox = 536870912,
            eArenaObjectID_nsRuleNode = 536870913,
            eArenaObjectID_nsStyleContext = 536870914,
            eArenaObjectID_nsInheritedStyleData = 536870915,
            eArenaObjectID_nsResetStyleData = 536870916,
            eArenaObjectID_nsConditionalResetStyleData = 536870917,
            eArenaObjectID_nsConditionalResetStyleDataEntry = 536870918,
            eArenaObjectID_nsFrameList = 536870919,
            eArenaObjectID_CustomCounterStyle = 536870920,
            eArenaObjectID_DependentBuiltinCounterStyle = 536870921,
            eArenaObjectID_nsStyleFont = 536870922,
            eArenaObjectID_nsStyleColor = 536870923,
            eArenaObjectID_nsStyleList = 536870924,
            eArenaObjectID_nsStyleText = 536870925,
            eArenaObjectID_nsStyleVisibility = 536870926,
            eArenaObjectID_nsStyleUserInterface = 536870927,
            eArenaObjectID_nsStyleTableBorder = 536870928,
            eArenaObjectID_nsStyleSVG = 536870929,
            eArenaObjectID_nsStyleVariables = 536870930,
            eArenaObjectID_nsStyleBackground = 536870931,
            eArenaObjectID_nsStylePosition = 536870932,
            eArenaObjectID_nsStyleTextReset = 536870933,
            eArenaObjectID_nsStyleDisplay = 536870934,
            eArenaObjectID_nsStyleContent = 536870935,
            eArenaObjectID_nsStyleUIReset = 536870936,
            eArenaObjectID_nsStyleTable = 536870937,
            eArenaObjectID_nsStyleMargin = 536870938,
            eArenaObjectID_nsStylePadding = 536870939,
            eArenaObjectID_nsStyleBorder = 536870940,
            eArenaObjectID_nsStyleOutline = 536870941,
            eArenaObjectID_nsStyleXUL = 536870942,
            eArenaObjectID_nsStyleSVGReset = 536870943,
            eArenaObjectID_nsStyleColumn = 536870944,
            eArenaObjectID_nsStyleEffects = 536870945,
            eArenaObjectID_NON_OBJECT_MARKER = 1073741824,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CSSVariableResolver([u8; 0]);
        #[repr(C)]
        #[derive(Debug)]
        pub struct CSSVariableValues {
            /**
   * Map of variable names to IDs.  Variable IDs are indexes into
   * mVariables.
   */
            pub mVariableIDs: [u64; 5usize],
            /**
   * Array of variables, indexed by variable ID.
   */
            pub mVariables: root::nsTArray<root::mozilla::CSSVariableValues_Variable>,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct CSSVariableValues_Variable {
            pub mVariableName: ::nsstring::nsStringRepr,
            pub mValue: ::nsstring::nsStringRepr,
            pub mFirstToken: root::nsCSSTokenSerializationType,
            pub mLastToken: root::nsCSSTokenSerializationType,
        }
        #[test]
        fn bindgen_test_layout_CSSVariableValues_Variable() {
            assert_eq!(::std::mem::size_of::<CSSVariableValues_Variable>() ,
                       40usize , concat ! (
                       "Size of: " , stringify ! ( CSSVariableValues_Variable
                       ) ));
            assert_eq! (::std::mem::align_of::<CSSVariableValues_Variable>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! (
                        CSSVariableValues_Variable ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSVariableValues_Variable ) ) .
                        mVariableName as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        CSSVariableValues_Variable ) , "::" , stringify ! (
                        mVariableName ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSVariableValues_Variable ) ) .
                        mValue as * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        CSSVariableValues_Variable ) , "::" , stringify ! (
                        mValue ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSVariableValues_Variable ) ) .
                        mFirstToken as * const _ as usize } , 32usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        CSSVariableValues_Variable ) , "::" , stringify ! (
                        mFirstToken ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSVariableValues_Variable ) ) .
                        mLastToken as * const _ as usize } , 36usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        CSSVariableValues_Variable ) , "::" , stringify ! (
                        mLastToken ) ));
        }
        #[test]
        fn bindgen_test_layout_CSSVariableValues() {
            assert_eq!(::std::mem::size_of::<CSSVariableValues>() , 48usize ,
                       concat ! (
                       "Size of: " , stringify ! ( CSSVariableValues ) ));
            assert_eq! (::std::mem::align_of::<CSSVariableValues>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( CSSVariableValues )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSVariableValues ) ) .
                        mVariableIDs as * const _ as usize } , 0usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        CSSVariableValues ) , "::" , stringify ! (
                        mVariableIDs ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CSSVariableValues ) ) .
                        mVariables as * const _ as usize } , 40usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        CSSVariableValues ) , "::" , stringify ! ( mVariables
                        ) ));
        }
        /**
 * Additional data used in conjunction with an nsRestyleHint to control the
 * restyle process.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct RestyleHintData {
            pub mSelectorsForDescendants: root::nsTArray<*mut root::nsCSSSelector>,
        }
        #[test]
        fn bindgen_test_layout_RestyleHintData() {
            assert_eq!(::std::mem::size_of::<RestyleHintData>() , 8usize ,
                       concat ! (
                       "Size of: " , stringify ! ( RestyleHintData ) ));
            assert_eq! (::std::mem::align_of::<RestyleHintData>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( RestyleHintData ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const RestyleHintData ) ) .
                        mSelectorsForDescendants as * const _ as usize } ,
                        0usize , concat ! (
                        "Alignment of field: " , stringify ! ( RestyleHintData
                        ) , "::" , stringify ! ( mSelectorsForDescendants )
                        ));
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum TraversalRootBehavior {
            Normal = 0,
            UnstyledChildrenOnly = 1,
        }
        pub type CSSPseudoElementTypeBase = u8;
        pub const CSSPseudoElementType_AnonBox:
                  root::mozilla::CSSPseudoElementType =
            CSSPseudoElementType::Count;
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum CSSPseudoElementType {
            after = 0,
            before = 1,
            backdrop = 2,
            firstLetter = 3,
            firstLine = 4,
            mozSelection = 5,
            mozFocusInner = 6,
            mozFocusOuter = 7,
            mozListBullet = 8,
            mozListNumber = 9,
            mozMathAnonymous = 10,
            mozNumberWrapper = 11,
            mozNumberText = 12,
            mozNumberSpinBox = 13,
            mozNumberSpinUp = 14,
            mozNumberSpinDown = 15,
            mozProgressBar = 16,
            mozRangeTrack = 17,
            mozRangeProgress = 18,
            mozRangeThumb = 19,
            mozMeterBar = 20,
            mozPlaceholder = 21,
            placeholder = 22,
            mozColorSwatch = 23,
            Count = 24,
            XULTree = 25,
            NotPseudo = 26,
            MAX = 27,
        }
        pub mod widget {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IMEState([u8; 0]);
        }
        pub type RawSelectionType = ::std::os::raw::c_short;
        #[repr(i16)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum SelectionType {
            eInvalid = -1,
            eNone = 0,
            eNormal = 1,
            eSpellCheck = 2,
            eIMERawClause = 4,
            eIMESelectedRawClause = 8,
            eIMEConvertedClause = 16,
            eIMESelectedClause = 32,
            eAccessibility = 64,
            eFind = 128,
            eURLSecondary = 256,
            eURLStrikeout = 512,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AccessibleCaretEventHub([u8; 0]);
        pub mod a11y {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DocAccessible([u8; 0]);
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct FramePropertyDescriptorUntyped {
            pub mDestructor: root::mozilla::FramePropertyDescriptorUntyped_UntypedDestructor,
            pub mDestructorWithFrame: root::mozilla::FramePropertyDescriptorUntyped_UntypedDestructorWithFrame,
        }
        /**
   * mDestructor will be called if it's non-null.
   */
        pub type FramePropertyDescriptorUntyped_UntypedDestructor =
            ::std::option::Option<unsafe extern "C" fn(aPropertyValue:
                                                           *mut ::std::os::raw::c_void)>;
        /**
   * mDestructorWithFrame will be called if it's non-null and mDestructor
   * is null. WARNING: The frame passed to mDestructorWithFrame may
   * be a dangling frame pointer, if this is being called during
   * presshell teardown. Do not use it except to compare against
   * other frame pointers. No frame will have been allocated with
   * the same address yet.
   */
        pub type FramePropertyDescriptorUntyped_UntypedDestructorWithFrame =
            ::std::option::Option<unsafe extern "C" fn(aFrame:
                                                           *const root::nsIFrame,
                                                       aPropertyValue:
                                                           *mut ::std::os::raw::c_void)>;
        #[test]
        fn bindgen_test_layout_FramePropertyDescriptorUntyped() {
            assert_eq!(::std::mem::size_of::<FramePropertyDescriptorUntyped>()
                       , 16usize , concat ! (
                       "Size of: " , stringify ! (
                       FramePropertyDescriptorUntyped ) ));
            assert_eq! (::std::mem::align_of::<FramePropertyDescriptorUntyped>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        FramePropertyDescriptorUntyped ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const FramePropertyDescriptorUntyped )
                        ) . mDestructor as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        FramePropertyDescriptorUntyped ) , "::" , stringify !
                        ( mDestructor ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const FramePropertyDescriptorUntyped )
                        ) . mDestructorWithFrame as * const _ as usize } ,
                        8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        FramePropertyDescriptorUntyped ) , "::" , stringify !
                        ( mDestructorWithFrame ) ));
        }
        impl Clone for FramePropertyDescriptorUntyped {
            fn clone(&self) -> Self { *self }
        }
        /**
 * The FramePropertyTable is optimized for storing 0 or 1 properties on
 * a given frame. Storing very large numbers of properties on a single
 * frame will not be efficient.
 * 
 * Property values are passed as void* but do not actually have to be
 * valid pointers. You can use NS_INT32_TO_PTR/NS_PTR_TO_INT32 to
 * store int32_t values. Null/zero values can be stored and retrieved.
 * Of course, the destructor function (if any) must handle such values
 * correctly.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct FramePropertyTable {
            pub mEntries: [u64; 5usize],
            pub mLastFrame: *const root::nsIFrame,
            pub mLastEntry: *mut root::mozilla::FramePropertyTable_Entry,
        }
        pub type FramePropertyTable_UntypedDescriptor =
            *const root::mozilla::FramePropertyDescriptorUntyped;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct FramePropertyTable_ReinterpretHelper<T> {
            pub _address: u8,
            pub _phantom_0: ::std::marker::PhantomData<T>,
        }
        /**
   * Stores a property descriptor/value pair. It can also be used to
   * store an nsTArray of PropertyValues.
   */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct FramePropertyTable_PropertyValue {
            pub mProperty: root::mozilla::FramePropertyTable_UntypedDescriptor,
            pub mValue: *mut ::std::os::raw::c_void,
        }
        #[test]
        fn bindgen_test_layout_FramePropertyTable_PropertyValue() {
            assert_eq!(::std::mem::size_of::<FramePropertyTable_PropertyValue>()
                       , 16usize , concat ! (
                       "Size of: " , stringify ! (
                       FramePropertyTable_PropertyValue ) ));
            assert_eq! (::std::mem::align_of::<FramePropertyTable_PropertyValue>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        FramePropertyTable_PropertyValue ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const FramePropertyTable_PropertyValue ) )
                        . mProperty as * const _ as usize } , 0usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        FramePropertyTable_PropertyValue ) , "::" , stringify
                        ! ( mProperty ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const FramePropertyTable_PropertyValue ) )
                        . mValue as * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        FramePropertyTable_PropertyValue ) , "::" , stringify
                        ! ( mValue ) ));
        }
        impl Clone for FramePropertyTable_PropertyValue {
            fn clone(&self) -> Self { *self }
        }
        /**
   * Used with an array of PropertyValues to allow lookups that compare
   * only on the FramePropertyDescriptor.
   */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct FramePropertyTable_PropertyComparator {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_FramePropertyTable_PropertyComparator() {
            assert_eq!(::std::mem::size_of::<FramePropertyTable_PropertyComparator>()
                       , 1usize , concat ! (
                       "Size of: " , stringify ! (
                       FramePropertyTable_PropertyComparator ) ));
            assert_eq! (::std::mem::align_of::<FramePropertyTable_PropertyComparator>()
                        , 1usize , concat ! (
                        "Alignment of " , stringify ! (
                        FramePropertyTable_PropertyComparator ) ));
        }
        impl Clone for FramePropertyTable_PropertyComparator {
            fn clone(&self) -> Self { *self }
        }
        /**
   * Our hashtable entry. The key is an nsIFrame*, the value is a
   * PropertyValue representing one or more property/value pairs.
   */
        #[repr(C)]
        #[derive(Debug)]
        pub struct FramePropertyTable_Entry {
            pub _base: root::nsPtrHashKey<root::nsIFrame>,
            pub mProp: root::mozilla::FramePropertyTable_PropertyValue,
        }
        #[test]
        fn bindgen_test_layout_FramePropertyTable_Entry() {
            assert_eq!(::std::mem::size_of::<FramePropertyTable_Entry>() ,
                       32usize , concat ! (
                       "Size of: " , stringify ! ( FramePropertyTable_Entry )
                       ));
            assert_eq! (::std::mem::align_of::<FramePropertyTable_Entry>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! (
                        FramePropertyTable_Entry ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const FramePropertyTable_Entry ) ) .
                        mProp as * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        FramePropertyTable_Entry ) , "::" , stringify ! (
                        mProp ) ));
        }
        #[test]
        fn bindgen_test_layout_FramePropertyTable() {
            assert_eq!(::std::mem::size_of::<FramePropertyTable>() , 56usize ,
                       concat ! (
                       "Size of: " , stringify ! ( FramePropertyTable ) ));
            assert_eq! (::std::mem::align_of::<FramePropertyTable>() , 8usize
                        , concat ! (
                        "Alignment of " , stringify ! ( FramePropertyTable )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const FramePropertyTable ) ) . mEntries
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        FramePropertyTable ) , "::" , stringify ! ( mEntries )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const FramePropertyTable ) ) .
                        mLastFrame as * const _ as usize } , 40usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        FramePropertyTable ) , "::" , stringify ! ( mLastFrame
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const FramePropertyTable ) ) .
                        mLastEntry as * const _ as usize } , 48usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        FramePropertyTable ) , "::" , stringify ! ( mLastEntry
                        ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ScrollbarStyles {
            pub mHorizontal: u8,
            pub mVertical: u8,
            pub mScrollBehavior: u8,
            pub mScrollSnapTypeX: u8,
            pub mScrollSnapTypeY: u8,
            pub mScrollSnapPointsX: root::nsStyleCoord,
            pub mScrollSnapPointsY: root::nsStyleCoord,
            pub mScrollSnapDestinationX: root::nsStyleCoord_CalcValue,
            pub mScrollSnapDestinationY: root::nsStyleCoord_CalcValue,
        }
        #[test]
        fn bindgen_test_layout_ScrollbarStyles() {
            assert_eq!(::std::mem::size_of::<ScrollbarStyles>() , 64usize ,
                       concat ! (
                       "Size of: " , stringify ! ( ScrollbarStyles ) ));
            assert_eq! (::std::mem::align_of::<ScrollbarStyles>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ScrollbarStyles ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) . mHorizontal
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mHorizontal ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) . mVertical
                        as * const _ as usize } , 1usize , concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mVertical ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) .
                        mScrollBehavior as * const _ as usize } , 2usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mScrollBehavior ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) .
                        mScrollSnapTypeX as * const _ as usize } , 3usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mScrollSnapTypeX ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) .
                        mScrollSnapTypeY as * const _ as usize } , 4usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mScrollSnapTypeY ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) .
                        mScrollSnapPointsX as * const _ as usize } , 8usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mScrollSnapPointsX ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) .
                        mScrollSnapPointsY as * const _ as usize } , 24usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mScrollSnapPointsY ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) .
                        mScrollSnapDestinationX as * const _ as usize } ,
                        40usize , concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mScrollSnapDestinationX ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ScrollbarStyles ) ) .
                        mScrollSnapDestinationY as * const _ as usize } ,
                        52usize , concat ! (
                        "Alignment of field: " , stringify ! ( ScrollbarStyles
                        ) , "::" , stringify ! ( mScrollSnapDestinationY ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct LangGroupFontPrefs {
            pub mLangGroup: root::nsCOMPtr<root::nsIAtom>,
            pub mMinimumFontSize: root::nscoord,
            pub mDefaultVariableFont: root::nsFont,
            pub mDefaultFixedFont: root::nsFont,
            pub mDefaultSerifFont: root::nsFont,
            pub mDefaultSansSerifFont: root::nsFont,
            pub mDefaultMonospaceFont: root::nsFont,
            pub mDefaultCursiveFont: root::nsFont,
            pub mDefaultFantasyFont: root::nsFont,
            pub mNext: root::nsAutoPtr<root::mozilla::LangGroupFontPrefs>,
        }
        #[test]
        fn bindgen_test_layout_LangGroupFontPrefs() {
            assert_eq!(::std::mem::size_of::<LangGroupFontPrefs>() , 696usize
                       , concat ! (
                       "Size of: " , stringify ! ( LangGroupFontPrefs ) ));
            assert_eq! (::std::mem::align_of::<LangGroupFontPrefs>() , 8usize
                        , concat ! (
                        "Alignment of " , stringify ! ( LangGroupFontPrefs )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mLangGroup as * const _ as usize } , 0usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! ( mLangGroup
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mMinimumFontSize as * const _ as usize } , 8usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mMinimumFontSize ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mDefaultVariableFont as * const _ as usize } , 16usize
                        , concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mDefaultVariableFont ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mDefaultFixedFont as * const _ as usize } , 112usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mDefaultFixedFont ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mDefaultSerifFont as * const _ as usize } , 208usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mDefaultSerifFont ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mDefaultSansSerifFont as * const _ as usize } ,
                        304usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mDefaultSansSerifFont ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mDefaultMonospaceFont as * const _ as usize } ,
                        400usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mDefaultMonospaceFont ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mDefaultCursiveFont as * const _ as usize } , 496usize
                        , concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mDefaultCursiveFont ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) .
                        mDefaultFantasyFont as * const _ as usize } , 592usize
                        , concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! (
                        mDefaultFantasyFont ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const LangGroupFontPrefs ) ) . mNext as
                        * const _ as usize } , 688usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        LangGroupFontPrefs ) , "::" , stringify ! ( mNext )
                        ));
        }
        /**
 * Some functionality that has historically lived on nsPresContext does not
 * actually need to be per-document. This singleton class serves as a host
 * for that functionality. We delegate to it from nsPresContext where
 * appropriate, and use it standalone in some cases as well.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct StaticPresData {
            pub mLangService: root::nsCOMPtr<root::nsILanguageAtomService>,
            pub mBorderWidthTable: [root::nscoord; 3usize],
            pub mStaticLangGroupFontPrefs: root::mozilla::LangGroupFontPrefs,
        }
        #[test]
        fn bindgen_test_layout_StaticPresData() {
            assert_eq!(::std::mem::size_of::<StaticPresData>() , 720usize ,
                       concat ! ( "Size of: " , stringify ! ( StaticPresData )
                       ));
            assert_eq! (::std::mem::align_of::<StaticPresData>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StaticPresData ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StaticPresData ) ) . mLangService
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( StaticPresData
                        ) , "::" , stringify ! ( mLangService ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StaticPresData ) ) .
                        mBorderWidthTable as * const _ as usize } , 8usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StaticPresData
                        ) , "::" , stringify ! ( mBorderWidthTable ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StaticPresData ) ) .
                        mStaticLangGroupFontPrefs as * const _ as usize } ,
                        24usize , concat ! (
                        "Alignment of field: " , stringify ! ( StaticPresData
                        ) , "::" , stringify ! ( mStaticLangGroupFontPrefs )
                        ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct EffectCompositor {
            pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
            pub mPresContext: *mut root::nsPresContext,
            pub mElementsToRestyle: [u64; 10usize],
            pub mRuleProcessors: [u64; 2usize],
        }
        pub type EffectCompositor_HasThreadSafeRefCnt =
            root::mozilla::FalseType;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct EffectCompositor_cycleCollection {
            pub _base: root::nsCycleCollectionParticipant,
        }
        #[test]
        fn bindgen_test_layout_EffectCompositor_cycleCollection() {
            assert_eq!(::std::mem::size_of::<EffectCompositor_cycleCollection>()
                       , 16usize , concat ! (
                       "Size of: " , stringify ! (
                       EffectCompositor_cycleCollection ) ));
            assert_eq! (::std::mem::align_of::<EffectCompositor_cycleCollection>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        EffectCompositor_cycleCollection ) ));
        }
        impl Clone for EffectCompositor_cycleCollection {
            fn clone(&self) -> Self { *self }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum EffectCompositor_CascadeLevel {
            Animations = 0,
            Transitions = 1,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum EffectCompositor_RestyleType {
            Throttled = 0,
            Standard = 1,
            Layer = 2,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct EffectCompositor_AnimationStyleRuleProcessor {
            pub _base: root::nsIStyleRuleProcessor,
            pub mRefCnt: root::nsAutoRefCnt,
            pub mCompositor: *mut root::mozilla::EffectCompositor,
            pub mCascadeLevel: root::mozilla::EffectCompositor_CascadeLevel,
        }
        pub type EffectCompositor_AnimationStyleRuleProcessor_HasThreadSafeRefCnt
            = root::mozilla::FalseType;
        #[test]
        fn bindgen_test_layout_EffectCompositor_AnimationStyleRuleProcessor() {
            assert_eq!(::std::mem::size_of::<EffectCompositor_AnimationStyleRuleProcessor>()
                       , 32usize , concat ! (
                       "Size of: " , stringify ! (
                       EffectCompositor_AnimationStyleRuleProcessor ) ));
            assert_eq! (::std::mem::align_of::<EffectCompositor_AnimationStyleRuleProcessor>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        EffectCompositor_AnimationStyleRuleProcessor ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const
                        EffectCompositor_AnimationStyleRuleProcessor ) ) .
                        mRefCnt as * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor_AnimationStyleRuleProcessor ) , "::"
                        , stringify ! ( mRefCnt ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const
                        EffectCompositor_AnimationStyleRuleProcessor ) ) .
                        mCompositor as * const _ as usize } , 16usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor_AnimationStyleRuleProcessor ) , "::"
                        , stringify ! ( mCompositor ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const
                        EffectCompositor_AnimationStyleRuleProcessor ) ) .
                        mCascadeLevel as * const _ as usize } , 24usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor_AnimationStyleRuleProcessor ) , "::"
                        , stringify ! ( mCascadeLevel ) ));
        }
        extern "C" {
            #[link_name =
                  "_ZN7mozilla16EffectCompositor21_cycleCollectorGlobalE"]
            pub static mut EffectCompositor__cycleCollectorGlobal:
                       root::mozilla::EffectCompositor_cycleCollection;
        }
        pub const EffectCompositor_kCascadeLevelCount: usize = 2;
        #[test]
        fn bindgen_test_layout_EffectCompositor() {
            assert_eq!(::std::mem::size_of::<EffectCompositor>() , 112usize ,
                       concat ! (
                       "Size of: " , stringify ! ( EffectCompositor ) ));
            assert_eq! (::std::mem::align_of::<EffectCompositor>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( EffectCompositor ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const EffectCompositor ) ) . mRefCnt as
                        * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor ) , "::" , stringify ! ( mRefCnt )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const EffectCompositor ) ) .
                        mPresContext as * const _ as usize } , 8usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor ) , "::" , stringify ! ( mPresContext
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const EffectCompositor ) ) .
                        mElementsToRestyle as * const _ as usize } , 16usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor ) , "::" , stringify ! (
                        mElementsToRestyle ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const EffectCompositor ) ) .
                        mRuleProcessors as * const _ as usize } , 96usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        EffectCompositor ) , "::" , stringify ! (
                        mRuleProcessors ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EventStateManager([u8; 0]);
        #[repr(C)]
        #[derive(Debug)]
        pub struct CounterStyleManager {
            pub mRefCnt: root::nsAutoRefCnt,
            pub mPresContext: *mut root::nsPresContext,
            pub mCacheTable: [u64; 5usize],
        }
        pub type CounterStyleManager_HasThreadSafeRefCnt =
            root::mozilla::FalseType;
        #[test]
        fn bindgen_test_layout_CounterStyleManager() {
            assert_eq!(::std::mem::size_of::<CounterStyleManager>() , 56usize
                       , concat ! (
                       "Size of: " , stringify ! ( CounterStyleManager ) ));
            assert_eq! (::std::mem::align_of::<CounterStyleManager>() , 8usize
                        , concat ! (
                        "Alignment of " , stringify ! ( CounterStyleManager )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CounterStyleManager ) ) . mRefCnt
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        CounterStyleManager ) , "::" , stringify ! ( mRefCnt )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CounterStyleManager ) ) .
                        mPresContext as * const _ as usize } , 8usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        CounterStyleManager ) , "::" , stringify ! (
                        mPresContext ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CounterStyleManager ) ) .
                        mCacheTable as * const _ as usize } , 16usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        CounterStyleManager ) , "::" , stringify ! (
                        mCacheTable ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RestyleManager([u8; 0]);
        pub mod image {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ImageURL([u8; 0]);
            /**
 * An ImageLib cache entry key.
 *
 * We key the cache on the initial URI (before any redirects), with some
 * canonicalization applied. See ComputeHash() for the details.
 * Controlled documents do not share their cache entries with
 * non-controlled documents, or other controlled documents.
 */
            #[repr(C)]
            #[derive(Debug)]
            pub struct ImageCacheKey {
                pub mURI: root::RefPtr<root::mozilla::image::ImageURL>,
                pub mBlobSerial: [u64; 2usize],
                pub mOriginAttributes: root::mozilla::OriginAttributes,
                pub mControlledDocument: *mut ::std::os::raw::c_void,
                pub mHash: u32,
                pub mIsChrome: bool,
            }
            #[test]
            fn bindgen_test_layout_ImageCacheKey() {
                assert_eq!(::std::mem::size_of::<ImageCacheKey>() , 104usize ,
                           concat ! (
                           "Size of: " , stringify ! ( ImageCacheKey ) ));
                assert_eq! (::std::mem::align_of::<ImageCacheKey>() , 8usize ,
                            concat ! (
                            "Alignment of " , stringify ! ( ImageCacheKey )
                            ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ImageCacheKey ) ) . mURI as *
                            const _ as usize } , 0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ImageCacheKey ) , "::" , stringify ! ( mURI ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ImageCacheKey ) ) .
                            mBlobSerial as * const _ as usize } , 8usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            ImageCacheKey ) , "::" , stringify ! ( mBlobSerial
                            ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ImageCacheKey ) ) .
                            mOriginAttributes as * const _ as usize } ,
                            24usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ImageCacheKey ) , "::" , stringify ! (
                            mOriginAttributes ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ImageCacheKey ) ) .
                            mControlledDocument as * const _ as usize } ,
                            88usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ImageCacheKey ) , "::" , stringify ! (
                            mControlledDocument ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ImageCacheKey ) ) . mHash as
                            * const _ as usize } , 96usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ImageCacheKey ) , "::" , stringify ! ( mHash ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const ImageCacheKey ) ) . mIsChrome
                            as * const _ as usize } , 100usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            ImageCacheKey ) , "::" , stringify ! ( mIsChrome )
                            ));
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Image([u8; 0]);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ProgressTracker([u8; 0]);
            #[repr(C)]
            pub struct IProgressObserver__bindgen_vtable {
            }
            /**
 * An interface for observing changes to image state, as reported by
 * ProgressTracker.
 *
 * This is the ImageLib-internal version of imgINotificationObserver,
 * essentially, with implementation details that code outside of ImageLib
 * shouldn't see.
 *
 * XXX(seth): It's preferable to avoid adding anything to this interface if
 * possible.  In the long term, it would be ideal to get to a place where we can
 * just use the imgINotificationObserver interface internally as well.
 */
            #[repr(C)]
            #[derive(Debug)]
            pub struct IProgressObserver {
                pub vtable_: *const IProgressObserver__bindgen_vtable,
                pub _base: u64,
            }
            #[test]
            fn bindgen_test_layout_IProgressObserver() {
                assert_eq!(::std::mem::size_of::<IProgressObserver>() ,
                           16usize , concat ! (
                           "Size of: " , stringify ! ( IProgressObserver ) ));
                assert_eq! (::std::mem::align_of::<IProgressObserver>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! ( IProgressObserver
                            ) ));
            }
        }
        pub type CounterValue = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NegativeType([u8; 0]);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PadType([u8; 0]);
        #[repr(C)]
        pub struct CounterStyle__bindgen_vtable {
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct CounterStyle {
            pub vtable_: *const CounterStyle__bindgen_vtable,
            pub mStyle: i32,
        }
        #[test]
        fn bindgen_test_layout_CounterStyle() {
            assert_eq!(::std::mem::size_of::<CounterStyle>() , 16usize ,
                       concat ! ( "Size of: " , stringify ! ( CounterStyle )
                       ));
            assert_eq! (::std::mem::align_of::<CounterStyle>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( CounterStyle ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const CounterStyle ) ) . mStyle as *
                        const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( CounterStyle )
                        , "::" , stringify ! ( mStyle ) ));
        }
        impl Clone for CounterStyle {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct Position {
            pub mXPosition: root::mozilla::Position_Coord,
            pub mYPosition: root::mozilla::Position_Coord,
        }
        pub type Position_Coord = root::nsStyleCoord_CalcValue;
        #[test]
        fn bindgen_test_layout_Position() {
            assert_eq!(::std::mem::size_of::<Position>() , 24usize , concat !
                       ( "Size of: " , stringify ! ( Position ) ));
            assert_eq! (::std::mem::align_of::<Position>() , 4usize , concat !
                        ( "Alignment of " , stringify ! ( Position ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Position ) ) . mXPosition as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Position ) ,
                        "::" , stringify ! ( mXPosition ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Position ) ) . mYPosition as *
                        const _ as usize } , 12usize , concat ! (
                        "Alignment of field: " , stringify ! ( Position ) ,
                        "::" , stringify ! ( mYPosition ) ));
        }
        impl Clone for Position {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct StyleTransition {
            pub mTimingFunction: root::nsTimingFunction,
            pub mDuration: f32,
            pub mDelay: f32,
            pub mProperty: root::nsCSSPropertyID,
            pub mUnknownProperty: root::nsCOMPtr<root::nsIAtom>,
        }
        #[test]
        fn bindgen_test_layout_StyleTransition() {
            assert_eq!(::std::mem::size_of::<StyleTransition>() , 40usize ,
                       concat ! (
                       "Size of: " , stringify ! ( StyleTransition ) ));
            assert_eq! (::std::mem::align_of::<StyleTransition>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StyleTransition ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleTransition ) ) .
                        mTimingFunction as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StyleTransition
                        ) , "::" , stringify ! ( mTimingFunction ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleTransition ) ) . mDuration
                        as * const _ as usize } , 20usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleTransition
                        ) , "::" , stringify ! ( mDuration ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleTransition ) ) . mDelay as *
                        const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleTransition
                        ) , "::" , stringify ! ( mDelay ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleTransition ) ) . mProperty
                        as * const _ as usize } , 28usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleTransition
                        ) , "::" , stringify ! ( mProperty ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleTransition ) ) .
                        mUnknownProperty as * const _ as usize } , 32usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StyleTransition
                        ) , "::" , stringify ! ( mUnknownProperty ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct StyleAnimation {
            pub mTimingFunction: root::nsTimingFunction,
            pub mDuration: f32,
            pub mDelay: f32,
            pub mName: ::nsstring::nsStringRepr,
            pub mDirection: root::mozilla::dom::PlaybackDirection,
            pub mFillMode: root::mozilla::dom::FillMode,
            pub mPlayState: u8,
            pub mIterationCount: f32,
        }
        #[test]
        fn bindgen_test_layout_StyleAnimation() {
            assert_eq!(::std::mem::size_of::<StyleAnimation>() , 56usize ,
                       concat ! ( "Size of: " , stringify ! ( StyleAnimation )
                       ));
            assert_eq! (::std::mem::align_of::<StyleAnimation>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StyleAnimation ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) .
                        mTimingFunction as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mTimingFunction ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) . mDuration as
                        * const _ as usize } , 20usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mDuration ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) . mDelay as *
                        const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mDelay ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) . mName as *
                        const _ as usize } , 32usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mName ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) . mDirection
                        as * const _ as usize } , 48usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mDirection ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) . mFillMode as
                        * const _ as usize } , 49usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mFillMode ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) . mPlayState
                        as * const _ as usize } , 50usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mPlayState ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleAnimation ) ) .
                        mIterationCount as * const _ as usize } , 52usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StyleAnimation
                        ) , "::" , stringify ! ( mIterationCount ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct StyleBasicShape {
            pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
            pub mType: root::mozilla::StyleBasicShapeType,
            pub mFillRule: root::mozilla::StyleFillRule,
            pub mCoordinates: root::nsTArray<root::nsStyleCoord>,
            pub mPosition: root::mozilla::Position,
            pub mRadius: root::nsStyleCorners,
        }
        pub type StyleBasicShape_HasThreadSafeRefCnt =
            root::mozilla::TrueType;
        #[test]
        fn bindgen_test_layout_StyleBasicShape() {
            assert_eq!(::std::mem::size_of::<StyleBasicShape>() , 120usize ,
                       concat ! (
                       "Size of: " , stringify ! ( StyleBasicShape ) ));
            assert_eq! (::std::mem::align_of::<StyleBasicShape>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StyleBasicShape ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleBasicShape ) ) . mRefCnt as
                        * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleBasicShape
                        ) , "::" , stringify ! ( mRefCnt ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleBasicShape ) ) . mType as *
                        const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleBasicShape
                        ) , "::" , stringify ! ( mType ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleBasicShape ) ) . mFillRule
                        as * const _ as usize } , 9usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleBasicShape
                        ) , "::" , stringify ! ( mFillRule ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleBasicShape ) ) .
                        mCoordinates as * const _ as usize } , 16usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( StyleBasicShape
                        ) , "::" , stringify ! ( mCoordinates ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleBasicShape ) ) . mPosition
                        as * const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleBasicShape
                        ) , "::" , stringify ! ( mPosition ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleBasicShape ) ) . mRadius as
                        * const _ as usize } , 48usize , concat ! (
                        "Alignment of field: " , stringify ! ( StyleBasicShape
                        ) , "::" , stringify ! ( mRadius ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct StyleShapeSource {
            pub __bindgen_anon_1: root::mozilla::StyleShapeSource__bindgen_ty_1,
            pub mType: root::mozilla::StyleShapeSourceType,
            pub mReferenceBox: root::mozilla::StyleGeometryBox,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleShapeSource__bindgen_ty_1 {
            pub mBasicShape: root::__BindgenUnionField<*mut root::mozilla::StyleBasicShape>,
            pub mURL: root::__BindgenUnionField<*mut root::mozilla::css::URLValue>,
            pub bindgen_union_field: u64,
        }
        #[test]
        fn bindgen_test_layout_StyleShapeSource__bindgen_ty_1() {
            assert_eq!(::std::mem::size_of::<StyleShapeSource__bindgen_ty_1>()
                       , 8usize , concat ! (
                       "Size of: " , stringify ! (
                       StyleShapeSource__bindgen_ty_1 ) ));
            assert_eq! (::std::mem::align_of::<StyleShapeSource__bindgen_ty_1>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        StyleShapeSource__bindgen_ty_1 ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleShapeSource__bindgen_ty_1 )
                        ) . mBasicShape as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleShapeSource__bindgen_ty_1 ) , "::" , stringify !
                        ( mBasicShape ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleShapeSource__bindgen_ty_1 )
                        ) . mURL as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleShapeSource__bindgen_ty_1 ) , "::" , stringify !
                        ( mURL ) ));
        }
        impl Clone for StyleShapeSource__bindgen_ty_1 {
            fn clone(&self) -> Self { *self }
        }
        #[test]
        fn bindgen_test_layout_StyleShapeSource() {
            assert_eq!(::std::mem::size_of::<StyleShapeSource>() , 16usize ,
                       concat ! (
                       "Size of: " , stringify ! ( StyleShapeSource ) ));
            assert_eq! (::std::mem::align_of::<StyleShapeSource>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( StyleShapeSource ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleShapeSource ) ) . mType as *
                        const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleShapeSource ) , "::" , stringify ! ( mType ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const StyleShapeSource ) ) .
                        mReferenceBox as * const _ as usize } , 9usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleShapeSource ) , "::" , stringify ! (
                        mReferenceBox ) ));
        }
        /**
 * A property-value pair specified on a keyframe.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct PropertyValuePair {
            pub mProperty: root::nsCSSPropertyID,
            pub mValue: root::nsCSSValue,
            pub mServoDeclarationBlock: root::RefPtr<root::RawServoDeclarationBlock>,
        }
        #[test]
        fn bindgen_test_layout_PropertyValuePair() {
            assert_eq!(::std::mem::size_of::<PropertyValuePair>() , 32usize ,
                       concat ! (
                       "Size of: " , stringify ! ( PropertyValuePair ) ));
            assert_eq! (::std::mem::align_of::<PropertyValuePair>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( PropertyValuePair )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PropertyValuePair ) ) . mProperty
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        PropertyValuePair ) , "::" , stringify ! ( mProperty )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PropertyValuePair ) ) . mValue as
                        * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        PropertyValuePair ) , "::" , stringify ! ( mValue )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PropertyValuePair ) ) .
                        mServoDeclarationBlock as * const _ as usize } ,
                        24usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        PropertyValuePair ) , "::" , stringify ! (
                        mServoDeclarationBlock ) ));
        }
        /**
 * A single keyframe.
 *
 * This is the canonical form in which keyframe effects are stored and
 * corresponds closely to the type of objects returned via the getKeyframes()
 * API.
 *
 * Before computing an output animation value, however, we flatten these frames
 * down to a series of per-property value arrays where we also resolve any
 * overlapping shorthands/longhands, convert specified CSS values to computed
 * values, etc.
 *
 * When the target element or style context changes, however, we rebuild these
 * per-property arrays from the original list of keyframes objects. As a result,
 * these objects represent the master definition of the effect's values.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct Keyframe {
            pub mOffset: [u64; 2usize],
            pub mComputedOffset: f64,
            pub mTimingFunction: [u64; 18usize],
            pub mComposite: [u8; 2usize],
            pub mPropertyValues: root::nsTArray<root::mozilla::PropertyValuePair>,
        }
        pub const Keyframe_kComputedOffsetNotSet: f64 = -1.;
        #[test]
        fn bindgen_test_layout_Keyframe() {
            assert_eq!(::std::mem::size_of::<Keyframe>() , 184usize , concat !
                       ( "Size of: " , stringify ! ( Keyframe ) ));
            assert_eq! (::std::mem::align_of::<Keyframe>() , 8usize , concat !
                        ( "Alignment of " , stringify ! ( Keyframe ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Keyframe ) ) . mOffset as * const
                        _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Keyframe ) ,
                        "::" , stringify ! ( mOffset ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Keyframe ) ) . mComputedOffset as
                        * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! ( Keyframe ) ,
                        "::" , stringify ! ( mComputedOffset ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Keyframe ) ) . mTimingFunction as
                        * const _ as usize } , 24usize , concat ! (
                        "Alignment of field: " , stringify ! ( Keyframe ) ,
                        "::" , stringify ! ( mTimingFunction ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Keyframe ) ) . mComposite as *
                        const _ as usize } , 168usize , concat ! (
                        "Alignment of field: " , stringify ! ( Keyframe ) ,
                        "::" , stringify ! ( mComposite ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Keyframe ) ) . mPropertyValues as
                        * const _ as usize } , 176usize , concat ! (
                        "Alignment of field: " , stringify ! ( Keyframe ) ,
                        "::" , stringify ! ( mPropertyValues ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SVGLengthList([u8; 0]);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SVGNumberList([u8; 0]);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SVGPathData([u8; 0]);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SVGPointList([u8; 0]);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SVGAnimatedPreserveAspectRatio([u8; 0]);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SVGStringList([u8; 0]);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SVGTransformList([u8; 0]);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DeclarationBlock([u8; 0]);
        /**
 * A structure representing a single attribute name and value.
 *
 * This is pretty similar to the private nsAttrAndChildArray::InternalAttr.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct ServoAttrSnapshot {
            pub mName: root::nsAttrName,
            pub mValue: root::nsAttrValue,
        }
        #[test]
        fn bindgen_test_layout_ServoAttrSnapshot() {
            assert_eq!(::std::mem::size_of::<ServoAttrSnapshot>() , 16usize ,
                       concat ! (
                       "Size of: " , stringify ! ( ServoAttrSnapshot ) ));
            assert_eq! (::std::mem::align_of::<ServoAttrSnapshot>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ServoAttrSnapshot )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoAttrSnapshot ) ) . mName as
                        * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoAttrSnapshot ) , "::" , stringify ! ( mName ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoAttrSnapshot ) ) . mValue as
                        * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoAttrSnapshot ) , "::" , stringify ! ( mValue )
                        ));
        }
        #[repr(u8)]
        /**
 * A bitflags enum class used to determine what data does a ServoElementSnapshot
 * contains.
 */
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ServoElementSnapshotFlags {
            State = 1,
            Attributes = 2,
            All = 3,
        }
        /**
 * This class holds all non-tree-structural state of an element that might be
 * used for selector matching eventually.
 *
 * This means the attributes, and the element state, such as :hover, :active,
 * etc...
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct ServoElementSnapshot {
            pub mContains: root::mozilla::ServoElementSnapshot_Flags,
            pub mAttrs: root::nsTArray<root::mozilla::ServoAttrSnapshot>,
            pub mState: root::mozilla::ServoElementSnapshot_ServoStateType,
            pub mIsHTMLElementInHTMLDocument: bool,
            pub mIsInChromeDocument: bool,
        }
        pub type ServoElementSnapshot_BorrowedAttrInfo =
            root::mozilla::dom::BorrowedAttrInfo;
        pub type ServoElementSnapshot_Element = root::mozilla::dom::Element;
        pub type ServoElementSnapshot_ServoStateType =
            root::mozilla::EventStates_ServoType;
        pub use self::super::super::root::mozilla::ServoElementSnapshotFlags
                as ServoElementSnapshot_Flags;
        #[test]
        fn bindgen_test_layout_ServoElementSnapshot() {
            assert_eq!(::std::mem::size_of::<ServoElementSnapshot>() , 24usize
                       , concat ! (
                       "Size of: " , stringify ! ( ServoElementSnapshot ) ));
            assert_eq! (::std::mem::align_of::<ServoElementSnapshot>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! ( ServoElementSnapshot )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoElementSnapshot ) ) .
                        mContains as * const _ as usize } , 0usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        ServoElementSnapshot ) , "::" , stringify ! (
                        mContains ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoElementSnapshot ) ) . mAttrs
                        as * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoElementSnapshot ) , "::" , stringify ! ( mAttrs )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoElementSnapshot ) ) . mState
                        as * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoElementSnapshot ) , "::" , stringify ! ( mState )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoElementSnapshot ) ) .
                        mIsHTMLElementInHTMLDocument as * const _ as usize } ,
                        18usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoElementSnapshot ) , "::" , stringify ! (
                        mIsHTMLElementInHTMLDocument ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ServoElementSnapshot ) ) .
                        mIsInChromeDocument as * const _ as usize } , 19usize
                        , concat ! (
                        "Alignment of field: " , stringify ! (
                        ServoElementSnapshot ) , "::" , stringify ! (
                        mIsInChromeDocument ) ));
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum Directionality {
            eDir_NotSet = 0,
            eDir_RTL = 1,
            eDir_LTR = 2,
            eDir_Auto = 3,
        }
        /**
 * An DisplayItemClip represents the intersection of an optional rectangle
 * with a list of rounded rectangles (which is often empty), all in appunits.
 * It can represent everything CSS clipping can do to an element (except for
 * SVG clip-path), including no clipping at all.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct DisplayItemClip {
            pub mClipRect: root::nsRect,
            pub mRoundedClipRects: root::nsTArray<root::mozilla::DisplayItemClip_RoundedRect>,
            pub mHaveClipRect: bool,
        }
        pub type DisplayItemClip_Color = root::mozilla::gfx::Color;
        pub type DisplayItemClip_DrawTarget = root::mozilla::gfx::DrawTarget;
        pub type DisplayItemClip_Path = root::mozilla::gfx::Path;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct DisplayItemClip_RoundedRect {
            pub mRect: root::nsRect,
            pub mRadii: [root::nscoord; 8usize],
        }
        #[test]
        fn bindgen_test_layout_DisplayItemClip_RoundedRect() {
            assert_eq!(::std::mem::size_of::<DisplayItemClip_RoundedRect>() ,
                       48usize , concat ! (
                       "Size of: " , stringify ! ( DisplayItemClip_RoundedRect
                       ) ));
            assert_eq! (::std::mem::align_of::<DisplayItemClip_RoundedRect>()
                        , 4usize , concat ! (
                        "Alignment of " , stringify ! (
                        DisplayItemClip_RoundedRect ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const DisplayItemClip_RoundedRect ) ) .
                        mRect as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        DisplayItemClip_RoundedRect ) , "::" , stringify ! (
                        mRect ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const DisplayItemClip_RoundedRect ) ) .
                        mRadii as * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        DisplayItemClip_RoundedRect ) , "::" , stringify ! (
                        mRadii ) ));
        }
        impl Clone for DisplayItemClip_RoundedRect {
            fn clone(&self) -> Self { *self }
        }
        #[test]
        fn bindgen_test_layout_DisplayItemClip() {
            assert_eq!(::std::mem::size_of::<DisplayItemClip>() , 32usize ,
                       concat ! (
                       "Size of: " , stringify ! ( DisplayItemClip ) ));
            assert_eq! (::std::mem::align_of::<DisplayItemClip>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( DisplayItemClip ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const DisplayItemClip ) ) . mClipRect
                        as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( DisplayItemClip
                        ) , "::" , stringify ! ( mClipRect ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const DisplayItemClip ) ) .
                        mRoundedClipRects as * const _ as usize } , 16usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( DisplayItemClip
                        ) , "::" , stringify ! ( mRoundedClipRects ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const DisplayItemClip ) ) .
                        mHaveClipRect as * const _ as usize } , 24usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( DisplayItemClip
                        ) , "::" , stringify ! ( mHaveClipRect ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ContainerLayerParameters([u8; 0]);
        #[repr(C)]
        #[derive(Debug)]
        pub struct PropertyStyleAnimationValuePair {
            pub mProperty: root::nsCSSPropertyID,
            pub mValue: root::mozilla::AnimationValue,
        }
        #[test]
        fn bindgen_test_layout_PropertyStyleAnimationValuePair() {
            assert_eq!(::std::mem::size_of::<PropertyStyleAnimationValuePair>()
                       , 32usize , concat ! (
                       "Size of: " , stringify ! (
                       PropertyStyleAnimationValuePair ) ));
            assert_eq! (::std::mem::align_of::<PropertyStyleAnimationValuePair>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        PropertyStyleAnimationValuePair ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PropertyStyleAnimationValuePair )
                        ) . mProperty as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        PropertyStyleAnimationValuePair ) , "::" , stringify !
                        ( mProperty ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const PropertyStyleAnimationValuePair )
                        ) . mValue as * const _ as usize } , 8usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        PropertyStyleAnimationValuePair ) , "::" , stringify !
                        ( mValue ) ));
        }
        #[test]
        fn __bindgen_test_layout_template_1() {
            assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete<root::RawServoStyleSet>>()
                       , 1usize , concat ! (
                       "Size of template specialization: " , stringify ! (
                       root::mozilla::DefaultDelete<root::RawServoStyleSet> )
                       ));
            assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete<root::RawServoStyleSet>>()
                       , 1usize , concat ! (
                       "Alignment of template specialization: " , stringify !
                       ( root::mozilla::DefaultDelete<root::RawServoStyleSet>
                       ) ));
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RestyleTracker([u8; 0]);
        /**
 * Utility class to handle animated style values
 */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleAnimationValue {
            pub _bindgen_opaque_blob: [u64; 2usize],
        }
        #[repr(u32)]
        /**
   * The types and values for the values that we extract and animate.
   */
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleAnimationValue_Unit {
            eUnit_Null = 0,
            eUnit_Normal = 1,
            eUnit_Auto = 2,
            eUnit_None = 3,
            eUnit_Enumerated = 4,
            eUnit_Visibility = 5,
            eUnit_Integer = 6,
            eUnit_Coord = 7,
            eUnit_Percent = 8,
            eUnit_Float = 9,
            eUnit_Color = 10,
            eUnit_CurrentColor = 11,
            eUnit_ComplexColor = 12,
            eUnit_Calc = 13,
            eUnit_ObjectPosition = 14,
            eUnit_URL = 15,
            eUnit_DiscreteCSSValue = 16,
            eUnit_CSSValuePair = 17,
            eUnit_CSSValueTriplet = 18,
            eUnit_CSSRect = 19,
            eUnit_Dasharray = 20,
            eUnit_Shadow = 21,
            eUnit_Shape = 22,
            eUnit_Filter = 23,
            eUnit_Transform = 24,
            eUnit_BackgroundPositionCoord = 25,
            eUnit_CSSValuePairList = 26,
            eUnit_UnparsedString = 27,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleAnimationValue__bindgen_ty_1 {
            pub mInt: root::__BindgenUnionField<i32>,
            pub mCoord: root::__BindgenUnionField<root::nscoord>,
            pub mFloat: root::__BindgenUnionField<f32>,
            pub mCSSValue: root::__BindgenUnionField<*mut root::nsCSSValue>,
            pub mCSSValuePair: root::__BindgenUnionField<*mut root::nsCSSValuePair>,
            pub mCSSValueTriplet: root::__BindgenUnionField<*mut root::nsCSSValueTriplet>,
            pub mCSSRect: root::__BindgenUnionField<*mut root::nsCSSRect>,
            pub mCSSValueArray: root::__BindgenUnionField<*mut root::nsCSSValue_Array>,
            pub mCSSValueList: root::__BindgenUnionField<*mut root::nsCSSValueList>,
            pub mCSSValueSharedList: root::__BindgenUnionField<*mut root::nsCSSValueSharedList>,
            pub mCSSValuePairList: root::__BindgenUnionField<*mut root::nsCSSValuePairList>,
            pub mString: root::__BindgenUnionField<*mut root::nsStringBuffer>,
            pub mComplexColor: root::__BindgenUnionField<*mut root::mozilla::css::ComplexColorValue>,
            pub bindgen_union_field: u64,
        }
        #[test]
        fn bindgen_test_layout_StyleAnimationValue__bindgen_ty_1() {
            assert_eq!(::std::mem::size_of::<StyleAnimationValue__bindgen_ty_1>()
                       , 8usize , concat ! (
                       "Size of: " , stringify ! (
                       StyleAnimationValue__bindgen_ty_1 ) ));
            assert_eq! (::std::mem::align_of::<StyleAnimationValue__bindgen_ty_1>()
                        , 8usize , concat ! (
                        "Alignment of " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mInt as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mInt ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCoord as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCoord ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mFloat as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mFloat ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSValue as * const _ as usize } , 0usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSValue ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSValuePair as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSValuePair ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSValueTriplet as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSValueTriplet ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSRect as * const _ as usize } , 0usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSRect ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSValueArray as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSValueArray ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSValueList as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSValueList ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSValueSharedList as * const _ as usize } , 0usize
                        , concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSValueSharedList ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mCSSValuePairList as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mCSSValuePairList ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mString as * const _ as usize } , 0usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mString ) ));
            assert_eq! (unsafe {
                        & (
                        * ( 0 as * const StyleAnimationValue__bindgen_ty_1 ) )
                        . mComplexColor as * const _ as usize } , 0usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        StyleAnimationValue__bindgen_ty_1 ) , "::" , stringify
                        ! ( mComplexColor ) ));
        }
        impl Clone for StyleAnimationValue__bindgen_ty_1 {
            fn clone(&self) -> Self { *self }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleAnimationValue_IntegerConstructorType {
            IntegerConstructor = 0,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleAnimationValue_CoordConstructorType {
            CoordConstructor = 0,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleAnimationValue_PercentConstructorType {
            PercentConstructor = 0,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleAnimationValue_FloatConstructorType {
            FloatConstructor = 0,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleAnimationValue_ColorConstructorType {
            ColorConstructor = 0,
        }
        #[test]
        fn bindgen_test_layout_StyleAnimationValue() {
            assert_eq!(::std::mem::size_of::<StyleAnimationValue>() , 16usize
                       , concat ! (
                       "Size of: " , stringify ! ( StyleAnimationValue ) ));
            assert_eq! (::std::mem::align_of::<StyleAnimationValue>() , 8usize
                        , concat ! (
                        "Alignment of " , stringify ! ( StyleAnimationValue )
                        ));
        }
        impl Clone for StyleAnimationValue {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ServoAnimationRule([u8; 0]);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AnimationPerformanceWarning([u8; 0]);
        pub type CSSPseudoClassTypeBase = u8;
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum CSSPseudoClassType {
            empty = 0,
            mozOnlyWhitespace = 1,
            mozEmptyExceptChildrenWithLocalname = 2,
            lang = 3,
            mozBoundElement = 4,
            root = 5,
            any = 6,
            firstChild = 7,
            firstNode = 8,
            lastChild = 9,
            lastNode = 10,
            onlyChild = 11,
            firstOfType = 12,
            lastOfType = 13,
            onlyOfType = 14,
            nthChild = 15,
            nthLastChild = 16,
            nthOfType = 17,
            nthLastOfType = 18,
            mozIsHTML = 19,
            unresolved = 20,
            mozNativeAnonymous = 21,
            mozSystemMetric = 22,
            mozLocaleDir = 23,
            mozLWTheme = 24,
            mozLWThemeBrightText = 25,
            mozLWThemeDarkText = 26,
            mozWindowInactive = 27,
            mozTableBorderNonzero = 28,
            mozBrowserFrame = 29,
            scope = 30,
            negation = 31,
            dir = 32,
            link = 33,
            mozAnyLink = 34,
            anyLink = 35,
            visited = 36,
            active = 37,
            checked = 38,
            disabled = 39,
            enabled = 40,
            focus = 41,
            focusWithin = 42,
            hover = 43,
            mozDragOver = 44,
            target = 45,
            indeterminate = 46,
            mozDevtoolsHighlighted = 47,
            mozStyleeditorTransitioning = 48,
            fullscreen = 49,
            mozFullScreen = 50,
            mozFocusRing = 51,
            mozBroken = 52,
            mozLoading = 53,
            mozUserDisabled = 54,
            mozSuppressed = 55,
            mozHandlerClickToPlay = 56,
            mozHandlerVulnerableUpdatable = 57,
            mozHandlerVulnerableNoUpdate = 58,
            mozHandlerDisabled = 59,
            mozHandlerBlocked = 60,
            mozHandlerCrashed = 61,
            mozMathIncrementScriptLevel = 62,
            required = 63,
            optional = 64,
            valid = 65,
            invalid = 66,
            inRange = 67,
            outOfRange = 68,
            defaultPseudo = 69,
            placeholderShown = 70,
            mozReadOnly = 71,
            mozReadWrite = 72,
            mozSubmitInvalid = 73,
            mozUIInvalid = 74,
            mozUIValid = 75,
            mozMeterOptimum = 76,
            mozMeterSubOptimum = 77,
            mozMeterSubSubOptimum = 78,
            mozPlaceholder = 79,
            Count = 80,
            NotPseudo = 81,
            MAX = 82,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AnimationValue {
            pub mGecko: root::mozilla::StyleAnimationValue,
            pub mServo: root::RefPtr<root::RawServoAnimationValue>,
        }
        #[test]
        fn bindgen_test_layout_AnimationValue() {
            assert_eq!(::std::mem::size_of::<AnimationValue>() , 24usize ,
                       concat ! ( "Size of: " , stringify ! ( AnimationValue )
                       ));
            assert_eq! (::std::mem::align_of::<AnimationValue>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( AnimationValue ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnimationValue ) ) . mGecko as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( AnimationValue
                        ) , "::" , stringify ! ( mGecko ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const AnimationValue ) ) . mServo as *
                        const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! ( AnimationValue
                        ) , "::" , stringify ! ( mServo ) ));
        }
        /**
 * <div rustbindgen="true" replaces="mozilla::UniquePtr">
 *
 * TODO(Emilio): This is a workaround and we should be able to get rid of this
 * one.
 */
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct UniquePtr<T, Deleter> {
            pub mPtr: *mut T,
            pub _phantom_1: ::std::marker::PhantomData<Deleter>,
        }
    }
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pair<_T1, _T2> {
            pub first: _T1,
            pub second: _T2,
        }
        pub type pair_first_type<_T1> = _T1;
        pub type pair_second_type<_T2> = _T2;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct input_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_input_iterator_tag() {
            assert_eq!(::std::mem::size_of::<input_iterator_tag>() , 1usize ,
                       concat ! (
                       "Size of: " , stringify ! ( input_iterator_tag ) ));
            assert_eq! (::std::mem::align_of::<input_iterator_tag>() , 1usize
                        , concat ! (
                        "Alignment of " , stringify ! ( input_iterator_tag )
                        ));
        }
        impl Clone for input_iterator_tag {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator<_Category, _Tp, _Distance, _Pointer, _Reference> {
            pub _address: u8,
            pub _phantom_0: ::std::marker::PhantomData<_Category>,
            pub _phantom_1: ::std::marker::PhantomData<_Tp>,
            pub _phantom_2: ::std::marker::PhantomData<_Distance>,
            pub _phantom_3: ::std::marker::PhantomData<_Pointer>,
            pub _phantom_4: ::std::marker::PhantomData<_Reference>,
        }
        pub type iterator_iterator_category<_Category> = _Category;
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        #[repr(C)]
        #[derive(Debug)]
        pub struct atomic<_Tp> {
            pub _M_i: _Tp,
        }
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub type va_list = root::__builtin_va_list;
    /**
 * MozRefCountType is Mozilla's reference count type.
 *
 * We use the same type to represent the refcount of RefCounted objects
 * as well, in order to be able to use the leak detection facilities
 * that are implemented by XPCOM.
 *
 * Note that this type is not in the mozilla namespace so that it is
 * usable for both C and C++ code.
 */
    pub type MozRefCountType = usize;
    pub type MozExternalRefCountType = u32;
    pub const nsresult_NS_ERROR_NO_INTERFACE: root::nsresult =
        nsresult::NS_NOINTERFACE;
    pub const nsresult_NS_ERROR_INVALID_ARG: root::nsresult =
        nsresult::NS_ERROR_ILLEGAL_VALUE;
    pub const nsresult_NS_ERROR_INVALID_POINTER: root::nsresult =
        nsresult::NS_ERROR_ILLEGAL_VALUE;
    pub const nsresult_NS_ERROR_NULL_POINTER: root::nsresult =
        nsresult::NS_ERROR_ILLEGAL_VALUE;
    pub const nsresult_NS_BINDING_SUCCEEDED: root::nsresult = nsresult::NS_OK;
    pub const nsresult_NS_NET_STATUS_RESOLVING_HOST: root::nsresult =
        nsresult::NS_BINDING_REDIRECTED;
    pub const nsresult_NS_NET_STATUS_RESOLVED_HOST: root::nsresult =
        nsresult::NS_ERROR_ALREADY_CONNECTED;
    pub const nsresult_NS_NET_STATUS_CONNECTED_TO: root::nsresult =
        nsresult::NS_BINDING_RETARGETED;
    pub const nsresult_NS_NET_STATUS_WAITING_FOR: root::nsresult =
        nsresult::NS_ERROR_MALFORMED_URI;
    pub const nsresult_NS_STATE_PROPERTY_EXISTS: root::nsresult =
        nsresult::NS_OK;
    pub const nsresult_NS_ERROR_HTMLPARSER_CONTINUE: root::nsresult =
        nsresult::NS_OK;
    pub const nsresult_NS_RDF_ASSERTION_ACCEPTED: root::nsresult =
        nsresult::NS_OK;
    pub const nsresult_NS_EXACT_LENGTH: root::nsresult =
        nsresult::NS_OK_UDEC_EXACTLENGTH;
    pub const nsresult_NS_PARTIAL_MORE_INPUT: root::nsresult =
        nsresult::NS_OK_UDEC_MOREINPUT;
    pub const nsresult_NS_PARTIAL_MORE_OUTPUT: root::nsresult =
        nsresult::NS_OK_UDEC_MOREOUTPUT;
    pub const nsresult_NS_ERROR_ILLEGAL_INPUT: root::nsresult =
        nsresult::NS_ERROR_UDEC_ILLEGALINPUT;
    pub const nsresult_NS_ERROR_XPATH_INVALID_ARG: root::nsresult =
        nsresult::NS_ERROR_ILLEGAL_VALUE;
    pub const nsresult_NS_SUCCESS_RESTART_APP: root::nsresult =
        nsresult::NS_SUCCESS_DONT_FIXUP;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsresult {
        NS_OK = 0,
        NS_ERROR_BASE = 3253927936,
        NS_ERROR_NOT_INITIALIZED = 3253927937,
        NS_ERROR_ALREADY_INITIALIZED = 3253927938,
        NS_ERROR_NOT_IMPLEMENTED = 2147500033,
        NS_NOINTERFACE = 2147500034,
        NS_ERROR_ABORT = 2147500036,
        NS_ERROR_FAILURE = 2147500037,
        NS_ERROR_UNEXPECTED = 2147549183,
        NS_ERROR_OUT_OF_MEMORY = 2147942414,
        NS_ERROR_ILLEGAL_VALUE = 2147942487,
        NS_ERROR_NO_AGGREGATION = 2147746064,
        NS_ERROR_NOT_AVAILABLE = 2147746065,
        NS_ERROR_FACTORY_NOT_REGISTERED = 2147746132,
        NS_ERROR_FACTORY_REGISTER_AGAIN = 2147746133,
        NS_ERROR_FACTORY_NOT_LOADED = 2147746296,
        NS_ERROR_FACTORY_NO_SIGNATURE_SUPPORT = 3253928193,
        NS_ERROR_FACTORY_EXISTS = 3253928192,
        NS_ERROR_CANNOT_CONVERT_DATA = 2152071169,
        NS_ERROR_OBJECT_IS_IMMUTABLE = 2152071170,
        NS_ERROR_LOSS_OF_SIGNIFICANT_DATA = 2152071171,
        NS_ERROR_NOT_SAME_THREAD = 2152071172,
        NS_ERROR_ILLEGAL_DURING_SHUTDOWN = 2152071198,
        NS_ERROR_SERVICE_NOT_AVAILABLE = 2152071190,
        NS_SUCCESS_LOSS_OF_INSIGNIFICANT_DATA = 4587521,
        NS_SUCCESS_INTERRUPTED_TRAVERSE = 4587522,
        NS_ERROR_SERVICE_NOT_FOUND = 4587542,
        NS_ERROR_SERVICE_IN_USE = 4587543,
        NS_BASE_STREAM_CLOSED = 2152136706,
        NS_BASE_STREAM_OSERROR = 2152136707,
        NS_BASE_STREAM_ILLEGAL_ARGS = 2152136708,
        NS_BASE_STREAM_NO_CONVERTER = 2152136709,
        NS_BASE_STREAM_BAD_CONVERSION = 2152136710,
        NS_BASE_STREAM_WOULD_BLOCK = 2152136711,
        NS_ERROR_GFX_PRINTER_NO_PRINTER_AVAILABLE = 2152202241,
        NS_ERROR_GFX_PRINTER_NAME_NOT_FOUND = 2152202242,
        NS_ERROR_GFX_PRINTER_COULD_NOT_OPEN_FILE = 2152202243,
        NS_ERROR_GFX_PRINTER_STARTDOC = 2152202244,
        NS_ERROR_GFX_PRINTER_ENDDOC = 2152202245,
        NS_ERROR_GFX_PRINTER_STARTPAGE = 2152202246,
        NS_ERROR_GFX_PRINTER_DOC_IS_BUSY = 2152202247,
        NS_ERROR_GFX_CMAP_MALFORMED = 2152202291,
        NS_SUCCESS_EVENT_CONSUMED = 4784129,
        NS_SUCCESS_EVENT_HANDLED_ASYNCHRONOUSLY = 4784130,
        NS_BINDING_FAILED = 2152398849,
        NS_BINDING_ABORTED = 2152398850,
        NS_BINDING_REDIRECTED = 2152398851,
        NS_BINDING_RETARGETED = 2152398852,
        NS_ERROR_MALFORMED_URI = 2152398858,
        NS_ERROR_IN_PROGRESS = 2152398863,
        NS_ERROR_NO_CONTENT = 2152398865,
        NS_ERROR_UNKNOWN_PROTOCOL = 2152398866,
        NS_ERROR_INVALID_CONTENT_ENCODING = 2152398875,
        NS_ERROR_CORRUPTED_CONTENT = 2152398877,
        NS_ERROR_INVALID_SIGNATURE = 2152398906,
        NS_ERROR_FIRST_HEADER_FIELD_COMPONENT_EMPTY = 2152398882,
        NS_ERROR_ALREADY_OPENED = 2152398921,
        NS_ERROR_ALREADY_CONNECTED = 2152398859,
        NS_ERROR_NOT_CONNECTED = 2152398860,
        NS_ERROR_CONNECTION_REFUSED = 2152398861,
        NS_ERROR_NET_TIMEOUT = 2152398862,
        NS_ERROR_OFFLINE = 2152398864,
        NS_ERROR_PORT_ACCESS_NOT_ALLOWED = 2152398867,
        NS_ERROR_NET_RESET = 2152398868,
        NS_ERROR_NET_INTERRUPT = 2152398919,
        NS_ERROR_PROXY_CONNECTION_REFUSED = 2152398920,
        NS_ERROR_NET_PARTIAL_TRANSFER = 2152398924,
        NS_ERROR_NET_INADEQUATE_SECURITY = 2152398930,
        NS_ERROR_NOT_RESUMABLE = 2152398873,
        NS_ERROR_REDIRECT_LOOP = 2152398879,
        NS_ERROR_ENTITY_CHANGED = 2152398880,
        NS_ERROR_UNSAFE_CONTENT_TYPE = 2152398922,
        NS_ERROR_REMOTE_XUL = 2152398923,
        NS_ERROR_LOAD_SHOWED_ERRORPAGE = 2152398925,
        NS_ERROR_DOCSHELL_DYING = 2152398926,
        NS_ERROR_FTP_LOGIN = 2152398869,
        NS_ERROR_FTP_CWD = 2152398870,
        NS_ERROR_FTP_PASV = 2152398871,
        NS_ERROR_FTP_PWD = 2152398872,
        NS_ERROR_FTP_LIST = 2152398876,
        NS_ERROR_UNKNOWN_HOST = 2152398878,
        NS_ERROR_DNS_LOOKUP_QUEUE_FULL = 2152398881,
        NS_ERROR_UNKNOWN_PROXY_HOST = 2152398890,
        NS_ERROR_UNKNOWN_SOCKET_TYPE = 2152398899,
        NS_ERROR_SOCKET_CREATE_FAILED = 2152398900,
        NS_ERROR_SOCKET_ADDRESS_NOT_SUPPORTED = 2152398901,
        NS_ERROR_SOCKET_ADDRESS_IN_USE = 2152398902,
        NS_ERROR_CACHE_KEY_NOT_FOUND = 2152398909,
        NS_ERROR_CACHE_DATA_IS_STREAM = 2152398910,
        NS_ERROR_CACHE_DATA_IS_NOT_STREAM = 2152398911,
        NS_ERROR_CACHE_WAIT_FOR_VALIDATION = 2152398912,
        NS_ERROR_CACHE_ENTRY_DOOMED = 2152398913,
        NS_ERROR_CACHE_READ_ACCESS_DENIED = 2152398914,
        NS_ERROR_CACHE_WRITE_ACCESS_DENIED = 2152398915,
        NS_ERROR_CACHE_IN_USE = 2152398916,
        NS_ERROR_DOCUMENT_NOT_CACHED = 2152398918,
        NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS = 2152398928,
        NS_ERROR_HOST_IS_IP_ADDRESS = 2152398929,
        NS_SUCCESS_ADOPTED_DATA = 4915290,
        NS_NET_STATUS_BEGIN_FTP_TRANSACTION = 4915227,
        NS_NET_STATUS_END_FTP_TRANSACTION = 4915228,
        NS_SUCCESS_AUTH_FINISHED = 4915240,
        NS_NET_STATUS_READING = 2152398856,
        NS_NET_STATUS_WRITING = 2152398857,
        NS_NET_STATUS_CONNECTING_TO = 2152398855,
        NS_NET_STATUS_SENDING_TO = 2152398853,
        NS_NET_STATUS_RECEIVING_FROM = 2152398854,
        NS_ERROR_INTERCEPTION_FAILED = 2152398948,
        NS_ERROR_HSTS_PRIMING_TIMEOUT = 2152398958,
        NS_ERROR_PLUGINS_PLUGINSNOTCHANGED = 2152465384,
        NS_ERROR_PLUGIN_DISABLED = 2152465385,
        NS_ERROR_PLUGIN_BLOCKLISTED = 2152465386,
        NS_ERROR_PLUGIN_TIME_RANGE_NOT_SUPPORTED = 2152465387,
        NS_ERROR_PLUGIN_CLICKTOPLAY = 2152465388,
        NS_PLUGIN_INIT_PENDING = 4981741,
        NS_TABLELAYOUT_CELL_NOT_FOUND = 5046272,
        NS_POSITION_BEFORE_TABLE = 5046275,
        NS_STATE_PROPERTY_NOT_THERE = 5046277,
        NS_ERROR_HTMLPARSER_EOF = 2152596456,
        NS_ERROR_HTMLPARSER_UNKNOWN = 2152596457,
        NS_ERROR_HTMLPARSER_CANTPROPAGATE = 2152596458,
        NS_ERROR_HTMLPARSER_CONTEXTMISMATCH = 2152596459,
        NS_ERROR_HTMLPARSER_BADFILENAME = 2152596460,
        NS_ERROR_HTMLPARSER_BADURL = 2152596461,
        NS_ERROR_HTMLPARSER_INVALIDPARSERCONTEXT = 2152596462,
        NS_ERROR_HTMLPARSER_INTERRUPTED = 2152596463,
        NS_ERROR_HTMLPARSER_BLOCK = 2152596464,
        NS_ERROR_HTMLPARSER_BADTOKENIZER = 2152596465,
        NS_ERROR_HTMLPARSER_BADATTRIBUTE = 2152596466,
        NS_ERROR_HTMLPARSER_UNRESOLVEDDTD = 2152596467,
        NS_ERROR_HTMLPARSER_MISPLACEDTABLECONTENT = 2152596468,
        NS_ERROR_HTMLPARSER_BADDTD = 2152596469,
        NS_ERROR_HTMLPARSER_BADCONTEXT = 2152596470,
        NS_ERROR_HTMLPARSER_STOPPARSING = 2152596471,
        NS_ERROR_HTMLPARSER_UNTERMINATEDSTRINGLITERAL = 2152596472,
        NS_ERROR_HTMLPARSER_HIERARCHYTOODEEP = 2152596473,
        NS_ERROR_HTMLPARSER_FAKE_ENDTAG = 2152596474,
        NS_ERROR_HTMLPARSER_INVALID_COMMENT = 2152596475,
        NS_HTMLTOKENS_NOT_AN_ENTITY = 5113808,
        NS_HTMLPARSER_VALID_META_CHARSET = 5114808,
        NS_RDF_CURSOR_EMPTY = 5177345,
        NS_RDF_NO_VALUE = 5177346,
        NS_RDF_ASSERTION_REJECTED = 5177347,
        NS_RDF_STOP_VISIT = 5177348,
        NS_ERROR_UCONV_NOCONV = 2152726529,
        NS_ERROR_UDEC_ILLEGALINPUT = 2152726542,
        NS_SUCCESS_USING_FALLBACK_LOCALE = 5242882,
        NS_OK_UDEC_EXACTLENGTH = 5242891,
        NS_OK_UDEC_MOREINPUT = 5242892,
        NS_OK_UDEC_MOREOUTPUT = 5242893,
        NS_OK_UDEC_NOBOMFOUND = 5242894,
        NS_OK_UENC_EXACTLENGTH = 5242913,
        NS_OK_UENC_MOREOUTPUT = 5242914,
        NS_ERROR_UENC_NOMAPPING = 5242915,
        NS_OK_UENC_MOREINPUT = 5242916,
        NS_ERROR_FILE_UNRECOGNIZED_PATH = 2152857601,
        NS_ERROR_FILE_UNRESOLVABLE_SYMLINK = 2152857602,
        NS_ERROR_FILE_EXECUTION_FAILED = 2152857603,
        NS_ERROR_FILE_UNKNOWN_TYPE = 2152857604,
        NS_ERROR_FILE_DESTINATION_NOT_DIR = 2152857605,
        NS_ERROR_FILE_TARGET_DOES_NOT_EXIST = 2152857606,
        NS_ERROR_FILE_COPY_OR_MOVE_FAILED = 2152857607,
        NS_ERROR_FILE_ALREADY_EXISTS = 2152857608,
        NS_ERROR_FILE_INVALID_PATH = 2152857609,
        NS_ERROR_FILE_DISK_FULL = 2152857610,
        NS_ERROR_FILE_CORRUPTED = 2152857611,
        NS_ERROR_FILE_NOT_DIRECTORY = 2152857612,
        NS_ERROR_FILE_IS_DIRECTORY = 2152857613,
        NS_ERROR_FILE_IS_LOCKED = 2152857614,
        NS_ERROR_FILE_TOO_BIG = 2152857615,
        NS_ERROR_FILE_NO_DEVICE_SPACE = 2152857616,
        NS_ERROR_FILE_NAME_TOO_LONG = 2152857617,
        NS_ERROR_FILE_NOT_FOUND = 2152857618,
        NS_ERROR_FILE_READ_ONLY = 2152857619,
        NS_ERROR_FILE_DIR_NOT_EMPTY = 2152857620,
        NS_ERROR_FILE_ACCESS_DENIED = 2152857621,
        NS_SUCCESS_FILE_DIRECTORY_EMPTY = 5373953,
        NS_SUCCESS_AGGREGATE_RESULT = 5373954,
        NS_ERROR_DOM_INDEX_SIZE_ERR = 2152923137,
        NS_ERROR_DOM_HIERARCHY_REQUEST_ERR = 2152923139,
        NS_ERROR_DOM_WRONG_DOCUMENT_ERR = 2152923140,
        NS_ERROR_DOM_INVALID_CHARACTER_ERR = 2152923141,
        NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR = 2152923143,
        NS_ERROR_DOM_NOT_FOUND_ERR = 2152923144,
        NS_ERROR_DOM_NOT_SUPPORTED_ERR = 2152923145,
        NS_ERROR_DOM_INUSE_ATTRIBUTE_ERR = 2152923146,
        NS_ERROR_DOM_INVALID_STATE_ERR = 2152923147,
        NS_ERROR_DOM_SYNTAX_ERR = 2152923148,
        NS_ERROR_DOM_INVALID_MODIFICATION_ERR = 2152923149,
        NS_ERROR_DOM_NAMESPACE_ERR = 2152923150,
        NS_ERROR_DOM_INVALID_ACCESS_ERR = 2152923151,
        NS_ERROR_DOM_TYPE_MISMATCH_ERR = 2152923153,
        NS_ERROR_DOM_SECURITY_ERR = 2152923154,
        NS_ERROR_DOM_NETWORK_ERR = 2152923155,
        NS_ERROR_DOM_ABORT_ERR = 2152923156,
        NS_ERROR_DOM_URL_MISMATCH_ERR = 2152923157,
        NS_ERROR_DOM_QUOTA_EXCEEDED_ERR = 2152923158,
        NS_ERROR_DOM_TIMEOUT_ERR = 2152923159,
        NS_ERROR_DOM_INVALID_NODE_TYPE_ERR = 2152923160,
        NS_ERROR_DOM_DATA_CLONE_ERR = 2152923161,
        NS_ERROR_TYPE_ERR = 2152923162,
        NS_ERROR_RANGE_ERR = 2152923163,
        NS_ERROR_DOM_ENCODING_NOT_SUPPORTED_ERR = 2152923164,
        NS_ERROR_DOM_INVALID_POINTER_ERR = 2152923165,
        NS_ERROR_DOM_UNKNOWN_ERR = 2152923166,
        NS_ERROR_DOM_DATA_ERR = 2152923167,
        NS_ERROR_DOM_OPERATION_ERR = 2152923168,
        NS_ERROR_DOM_NOT_ALLOWED_ERR = 2152923169,
        NS_ERROR_DOM_SECMAN_ERR = 2152924137,
        NS_ERROR_DOM_WRONG_TYPE_ERR = 2152924138,
        NS_ERROR_DOM_NOT_OBJECT_ERR = 2152924139,
        NS_ERROR_DOM_NOT_XPC_OBJECT_ERR = 2152924140,
        NS_ERROR_DOM_NOT_NUMBER_ERR = 2152924141,
        NS_ERROR_DOM_NOT_BOOLEAN_ERR = 2152924142,
        NS_ERROR_DOM_NOT_FUNCTION_ERR = 2152924143,
        NS_ERROR_DOM_TOO_FEW_PARAMETERS_ERR = 2152924144,
        NS_ERROR_DOM_BAD_DOCUMENT_DOMAIN = 2152924145,
        NS_ERROR_DOM_PROP_ACCESS_DENIED = 2152924146,
        NS_ERROR_DOM_XPCONNECT_ACCESS_DENIED = 2152924147,
        NS_ERROR_DOM_BAD_URI = 2152924148,
        NS_ERROR_DOM_RETVAL_UNDEFINED = 2152924149,
        NS_ERROR_DOM_QUOTA_REACHED = 2152924150,
        NS_ERROR_UNCATCHABLE_EXCEPTION = 2152924151,
        NS_ERROR_DOM_MALFORMED_URI = 2152924152,
        NS_ERROR_DOM_INVALID_HEADER_NAME = 2152924153,
        NS_ERROR_DOM_INVALID_STATE_XHR_HAS_INVALID_CONTEXT = 2152924154,
        NS_ERROR_DOM_INVALID_STATE_XHR_MUST_BE_OPENED = 2152924155,
        NS_ERROR_DOM_INVALID_STATE_XHR_MUST_NOT_BE_SENDING = 2152924156,
        NS_ERROR_DOM_INVALID_STATE_XHR_MUST_NOT_BE_LOADING_OR_DONE =
            2152924157,
        NS_ERROR_DOM_INVALID_STATE_XHR_HAS_WRONG_RESPONSETYPE_FOR_RESPONSEXML
            = 2152924158,
        NS_ERROR_DOM_INVALID_STATE_XHR_HAS_WRONG_RESPONSETYPE_FOR_RESPONSETEXT
            = 2152924159,
        NS_ERROR_DOM_INVALID_STATE_XHR_CHUNKED_RESPONSETYPES_UNSUPPORTED_FOR_SYNC
            = 2152924160,
        NS_ERROR_DOM_INVALID_ACCESS_XHR_TIMEOUT_AND_RESPONSETYPE_UNSUPPORTED_FOR_SYNC
            = 2152924161,
        NS_SUCCESS_DOM_NO_OPERATION = 5439489,
        NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW = 5439490,
        NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW_UNCATCHABLE = 5439491,
        NS_IMAGELIB_SUCCESS_LOAD_FINISHED = 5505024,
        NS_IMAGELIB_CHANGING_OWNER = 5505025,
        NS_IMAGELIB_ERROR_FAILURE = 2152988677,
        NS_IMAGELIB_ERROR_NO_DECODER = 2152988678,
        NS_IMAGELIB_ERROR_NOT_FINISHED = 2152988679,
        NS_IMAGELIB_ERROR_NO_ENCODER = 2152988681,
        NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND = 5636097,
        NS_SUCCESS_EDITOR_FOUND_TARGET = 5636098,
        NS_ERROR_XPC_NOT_ENOUGH_ARGS = 2153185281,
        NS_ERROR_XPC_NEED_OUT_OBJECT = 2153185282,
        NS_ERROR_XPC_CANT_SET_OUT_VAL = 2153185283,
        NS_ERROR_XPC_NATIVE_RETURNED_FAILURE = 2153185284,
        NS_ERROR_XPC_CANT_GET_INTERFACE_INFO = 2153185285,
        NS_ERROR_XPC_CANT_GET_PARAM_IFACE_INFO = 2153185286,
        NS_ERROR_XPC_CANT_GET_METHOD_INFO = 2153185287,
        NS_ERROR_XPC_UNEXPECTED = 2153185288,
        NS_ERROR_XPC_BAD_CONVERT_JS = 2153185289,
        NS_ERROR_XPC_BAD_CONVERT_NATIVE = 2153185290,
        NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF = 2153185291,
        NS_ERROR_XPC_BAD_OP_ON_WN_PROTO = 2153185292,
        NS_ERROR_XPC_CANT_CONVERT_WN_TO_FUN = 2153185293,
        NS_ERROR_XPC_CANT_DEFINE_PROP_ON_WN = 2153185294,
        NS_ERROR_XPC_CANT_WATCH_WN_STATIC = 2153185295,
        NS_ERROR_XPC_CANT_EXPORT_WN_STATIC = 2153185296,
        NS_ERROR_XPC_SCRIPTABLE_CALL_FAILED = 2153185297,
        NS_ERROR_XPC_SCRIPTABLE_CTOR_FAILED = 2153185298,
        NS_ERROR_XPC_CANT_CALL_WO_SCRIPTABLE = 2153185299,
        NS_ERROR_XPC_CANT_CTOR_WO_SCRIPTABLE = 2153185300,
        NS_ERROR_XPC_CI_RETURNED_FAILURE = 2153185301,
        NS_ERROR_XPC_GS_RETURNED_FAILURE = 2153185302,
        NS_ERROR_XPC_BAD_CID = 2153185303,
        NS_ERROR_XPC_BAD_IID = 2153185304,
        NS_ERROR_XPC_CANT_CREATE_WN = 2153185305,
        NS_ERROR_XPC_JS_THREW_EXCEPTION = 2153185306,
        NS_ERROR_XPC_JS_THREW_NATIVE_OBJECT = 2153185307,
        NS_ERROR_XPC_JS_THREW_JS_OBJECT = 2153185308,
        NS_ERROR_XPC_JS_THREW_NULL = 2153185309,
        NS_ERROR_XPC_JS_THREW_STRING = 2153185310,
        NS_ERROR_XPC_JS_THREW_NUMBER = 2153185311,
        NS_ERROR_XPC_JAVASCRIPT_ERROR = 2153185312,
        NS_ERROR_XPC_JAVASCRIPT_ERROR_WITH_DETAILS = 2153185313,
        NS_ERROR_XPC_CANT_CONVERT_PRIMITIVE_TO_ARRAY = 2153185314,
        NS_ERROR_XPC_CANT_CONVERT_OBJECT_TO_ARRAY = 2153185315,
        NS_ERROR_XPC_NOT_ENOUGH_ELEMENTS_IN_ARRAY = 2153185316,
        NS_ERROR_XPC_CANT_GET_ARRAY_INFO = 2153185317,
        NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING = 2153185318,
        NS_ERROR_XPC_SECURITY_MANAGER_VETO = 2153185319,
        NS_ERROR_XPC_INTERFACE_NOT_SCRIPTABLE = 2153185320,
        NS_ERROR_XPC_INTERFACE_NOT_FROM_NSISUPPORTS = 2153185321,
        NS_ERROR_XPC_CANT_GET_JSOBJECT_OF_DOM_OBJECT = 2153185322,
        NS_ERROR_XPC_CANT_SET_READ_ONLY_CONSTANT = 2153185323,
        NS_ERROR_XPC_CANT_SET_READ_ONLY_ATTRIBUTE = 2153185324,
        NS_ERROR_XPC_CANT_SET_READ_ONLY_METHOD = 2153185325,
        NS_ERROR_XPC_CANT_ADD_PROP_TO_WRAPPED_NATIVE = 2153185326,
        NS_ERROR_XPC_CALL_TO_SCRIPTABLE_FAILED = 2153185327,
        NS_ERROR_XPC_JSOBJECT_HAS_NO_FUNCTION_NAMED = 2153185328,
        NS_ERROR_XPC_BAD_ID_STRING = 2153185329,
        NS_ERROR_XPC_BAD_INITIALIZER_NAME = 2153185330,
        NS_ERROR_XPC_HAS_BEEN_SHUTDOWN = 2153185331,
        NS_ERROR_XPC_CANT_MODIFY_PROP_ON_WN = 2153185332,
        NS_ERROR_XPC_BAD_CONVERT_JS_ZERO_ISNOT_NULL = 2153185333,
        NS_ERROR_XPC_CANT_PASS_CPOW_TO_NATIVE = 2153185334,
        NS_ERROR_LAUNCHED_CHILD_PROCESS = 2153251016,
        NS_ERROR_CSP_FORM_ACTION_VIOLATION = 2153381986,
        NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION = 2153381987,
        NS_ERROR_SRI_CORRUPT = 2153382088,
        NS_ERROR_SRI_DISABLED = 2153382089,
        NS_ERROR_SRI_NOT_ELIGIBLE = 2153382090,
        NS_ERROR_SRI_UNEXPECTED_HASH_TYPE = 2153382091,
        NS_ERROR_SRI_IMPORT = 2153382092,
        NS_ERROR_CMS_VERIFY_NOT_SIGNED = 2153382912,
        NS_ERROR_CMS_VERIFY_NO_CONTENT_INFO = 2153382913,
        NS_ERROR_CMS_VERIFY_BAD_DIGEST = 2153382914,
        NS_ERROR_CMS_VERIFY_NOCERT = 2153382916,
        NS_ERROR_CMS_VERIFY_UNTRUSTED = 2153382917,
        NS_ERROR_CMS_VERIFY_ERROR_UNVERIFIED = 2153382919,
        NS_ERROR_CMS_VERIFY_ERROR_PROCESSING = 2153382920,
        NS_ERROR_CMS_VERIFY_BAD_SIGNATURE = 2153382921,
        NS_ERROR_CMS_VERIFY_DIGEST_MISMATCH = 2153382922,
        NS_ERROR_CMS_VERIFY_UNKNOWN_ALGO = 2153382923,
        NS_ERROR_CMS_VERIFY_UNSUPPORTED_ALGO = 2153382924,
        NS_ERROR_CMS_VERIFY_MALFORMED_SIGNATURE = 2153382925,
        NS_ERROR_CMS_VERIFY_HEADER_MISMATCH = 2153382926,
        NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED = 2153382927,
        NS_ERROR_CMS_VERIFY_CERT_WITHOUT_ADDRESS = 2153382928,
        NS_ERROR_CMS_ENCRYPT_NO_BULK_ALG = 2153382944,
        NS_ERROR_CMS_ENCRYPT_INCOMPLETE = 2153382945,
        NS_ERROR_DOM_INVALID_EXPRESSION_ERR = 2153447475,
        NS_ERROR_DOM_TYPE_ERR = 2153447476,
        NS_ERROR_WONT_HANDLE_CONTENT = 2153578497,
        NS_ERROR_MALWARE_URI = 2153578526,
        NS_ERROR_PHISHING_URI = 2153578527,
        NS_ERROR_TRACKING_URI = 2153578530,
        NS_ERROR_UNWANTED_URI = 2153578531,
        NS_ERROR_BLOCKED_URI = 2153578533,
        NS_ERROR_SAVE_LINK_AS_TIMEOUT = 2153578528,
        NS_ERROR_PARSED_DATA_CACHED = 2153578529,
        NS_REFRESHURI_HEADER_FOUND = 6094850,
        NS_ERROR_IMAGE_SRC_CHANGED = 2153644036,
        NS_ERROR_IMAGE_BLOCKED = 2153644037,
        NS_ERROR_CONTENT_BLOCKED = 2153644038,
        NS_ERROR_CONTENT_BLOCKED_SHOW_ALT = 2153644039,
        NS_PROPTABLE_PROP_NOT_THERE = 2153644042,
        NS_ERROR_XBL_BLOCKED = 2153644047,
        NS_ERROR_CONTENT_CRASHED = 2153644048,
        NS_HTML_STYLE_PROPERTY_NOT_THERE = 6160386,
        NS_CONTENT_BLOCKED = 6160392,
        NS_CONTENT_BLOCKED_SHOW_ALT = 6160393,
        NS_PROPTABLE_PROP_OVERWRITTEN = 6160395,
        NS_FINDBROADCASTER_NOT_FOUND = 6160396,
        NS_FINDBROADCASTER_FOUND = 6160397,
        NS_FINDBROADCASTER_AWAIT_OVERLAYS = 6160398,
        NS_ERROR_XSLT_PARSE_FAILURE = 2153775105,
        NS_ERROR_XPATH_PARSE_FAILURE = 2153775106,
        NS_ERROR_XSLT_ALREADY_SET = 2153775107,
        NS_ERROR_XSLT_EXECUTION_FAILURE = 2153775108,
        NS_ERROR_XPATH_UNKNOWN_FUNCTION = 2153775109,
        NS_ERROR_XSLT_BAD_RECURSION = 2153775110,
        NS_ERROR_XSLT_BAD_VALUE = 2153775111,
        NS_ERROR_XSLT_NODESET_EXPECTED = 2153775112,
        NS_ERROR_XSLT_ABORTED = 2153775113,
        NS_ERROR_XSLT_NETWORK_ERROR = 2153775114,
        NS_ERROR_XSLT_WRONG_MIME_TYPE = 2153775115,
        NS_ERROR_XSLT_LOAD_RECURSION = 2153775116,
        NS_ERROR_XPATH_BAD_ARGUMENT_COUNT = 2153775117,
        NS_ERROR_XPATH_BAD_EXTENSION_FUNCTION = 2153775118,
        NS_ERROR_XPATH_PAREN_EXPECTED = 2153775119,
        NS_ERROR_XPATH_INVALID_AXIS = 2153775120,
        NS_ERROR_XPATH_NO_NODE_TYPE_TEST = 2153775121,
        NS_ERROR_XPATH_BRACKET_EXPECTED = 2153775122,
        NS_ERROR_XPATH_INVALID_VAR_NAME = 2153775123,
        NS_ERROR_XPATH_UNEXPECTED_END = 2153775124,
        NS_ERROR_XPATH_OPERATOR_EXPECTED = 2153775125,
        NS_ERROR_XPATH_UNCLOSED_LITERAL = 2153775126,
        NS_ERROR_XPATH_BAD_COLON = 2153775127,
        NS_ERROR_XPATH_BAD_BANG = 2153775128,
        NS_ERROR_XPATH_ILLEGAL_CHAR = 2153775129,
        NS_ERROR_XPATH_BINARY_EXPECTED = 2153775130,
        NS_ERROR_XSLT_LOAD_BLOCKED_ERROR = 2153775131,
        NS_ERROR_XPATH_INVALID_EXPRESSION_EVALUATED = 2153775132,
        NS_ERROR_XPATH_UNBALANCED_CURLY_BRACE = 2153775133,
        NS_ERROR_XSLT_BAD_NODE_NAME = 2153775134,
        NS_ERROR_XSLT_VAR_ALREADY_SET = 2153775135,
        NS_ERROR_XSLT_CALL_TO_KEY_NOT_ALLOWED = 2153775136,
        NS_XSLT_GET_NEW_HANDLER = 6291457,
        NS_ERROR_TRANSPORT_INIT = 2153840641,
        NS_ERROR_DUPLICATE_HANDLE = 2153840642,
        NS_ERROR_BRIDGE_OPEN_PARENT = 2153840643,
        NS_ERROR_BRIDGE_OPEN_CHILD = 2153840644,
        NS_ERROR_DOM_SVG_WRONG_TYPE_ERR = 2153906176,
        NS_ERROR_DOM_SVG_MATRIX_NOT_INVERTABLE = 2153906178,
        NS_ERROR_STORAGE_BUSY = 2153971713,
        NS_ERROR_STORAGE_IOERR = 2153971714,
        NS_ERROR_STORAGE_CONSTRAINT = 2153971715,
        NS_ERROR_DOM_FILE_NOT_FOUND_ERR = 2154102784,
        NS_ERROR_DOM_FILE_NOT_READABLE_ERR = 2154102785,
        NS_ERROR_DOM_FILE_ABORT_ERR = 2154102786,
        NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR = 2154168321,
        NS_ERROR_DOM_INDEXEDDB_NOT_FOUND_ERR = 2154168323,
        NS_ERROR_DOM_INDEXEDDB_CONSTRAINT_ERR = 2154168324,
        NS_ERROR_DOM_INDEXEDDB_DATA_ERR = 2154168325,
        NS_ERROR_DOM_INDEXEDDB_NOT_ALLOWED_ERR = 2154168326,
        NS_ERROR_DOM_INDEXEDDB_TRANSACTION_INACTIVE_ERR = 2154168327,
        NS_ERROR_DOM_INDEXEDDB_ABORT_ERR = 2154168328,
        NS_ERROR_DOM_INDEXEDDB_READ_ONLY_ERR = 2154168329,
        NS_ERROR_DOM_INDEXEDDB_TIMEOUT_ERR = 2154168330,
        NS_ERROR_DOM_INDEXEDDB_QUOTA_ERR = 2154168331,
        NS_ERROR_DOM_INDEXEDDB_VERSION_ERR = 2154168332,
        NS_ERROR_DOM_INDEXEDDB_RECOVERABLE_ERR = 2154169321,
        NS_ERROR_DOM_FILEHANDLE_UNKNOWN_ERR = 2154233857,
        NS_ERROR_DOM_FILEHANDLE_NOT_ALLOWED_ERR = 2154233858,
        NS_ERROR_DOM_FILEHANDLE_INACTIVE_ERR = 2154233859,
        NS_ERROR_DOM_FILEHANDLE_ABORT_ERR = 2154233860,
        NS_ERROR_DOM_FILEHANDLE_READ_ONLY_ERR = 2154233861,
        NS_ERROR_DOM_FILEHANDLE_QUOTA_ERR = 2154233862,
        NS_ERROR_SIGNED_JAR_NOT_SIGNED = 2154299393,
        NS_ERROR_SIGNED_JAR_MODIFIED_ENTRY = 2154299394,
        NS_ERROR_SIGNED_JAR_UNSIGNED_ENTRY = 2154299395,
        NS_ERROR_SIGNED_JAR_ENTRY_MISSING = 2154299396,
        NS_ERROR_SIGNED_JAR_WRONG_SIGNATURE = 2154299397,
        NS_ERROR_SIGNED_JAR_ENTRY_TOO_LARGE = 2154299398,
        NS_ERROR_SIGNED_JAR_ENTRY_INVALID = 2154299399,
        NS_ERROR_SIGNED_JAR_MANIFEST_INVALID = 2154299400,
        NS_ERROR_DOM_FILESYSTEM_INVALID_PATH_ERR = 2154364929,
        NS_ERROR_DOM_FILESYSTEM_INVALID_MODIFICATION_ERR = 2154364930,
        NS_ERROR_DOM_FILESYSTEM_NO_MODIFICATION_ALLOWED_ERR = 2154364931,
        NS_ERROR_DOM_FILESYSTEM_PATH_EXISTS_ERR = 2154364932,
        NS_ERROR_DOM_FILESYSTEM_TYPE_MISMATCH_ERR = 2154364933,
        NS_ERROR_DOM_FILESYSTEM_UNKNOWN_ERR = 2154364934,
        NS_ERROR_SIGNED_APP_MANIFEST_INVALID = 2154496001,
        NS_ERROR_DOM_ANIM_MISSING_PROPS_ERR = 2154561537,
        NS_ERROR_DOM_PUSH_INVALID_REGISTRATION_ERR = 2154627073,
        NS_ERROR_DOM_PUSH_DENIED_ERR = 2154627074,
        NS_ERROR_DOM_PUSH_ABORT_ERR = 2154627075,
        NS_ERROR_DOM_PUSH_SERVICE_UNREACHABLE = 2154627076,
        NS_ERROR_DOM_PUSH_INVALID_KEY_ERR = 2154627077,
        NS_ERROR_DOM_PUSH_MISMATCHED_KEY_ERR = 2154627078,
        NS_ERROR_DOM_MEDIA_ABORT_ERR = 2154692609,
        NS_ERROR_DOM_MEDIA_NOT_ALLOWED_ERR = 2154692610,
        NS_ERROR_DOM_MEDIA_NOT_SUPPORTED_ERR = 2154692611,
        NS_ERROR_DOM_MEDIA_DECODE_ERR = 2154692612,
        NS_ERROR_DOM_MEDIA_FATAL_ERR = 2154692613,
        NS_ERROR_DOM_MEDIA_METADATA_ERR = 2154692614,
        NS_ERROR_DOM_MEDIA_OVERFLOW_ERR = 2154692615,
        NS_ERROR_DOM_MEDIA_END_OF_STREAM = 2154692616,
        NS_ERROR_DOM_MEDIA_WAITING_FOR_DATA = 2154692617,
        NS_ERROR_DOM_MEDIA_CANCELED = 2154692618,
        NS_ERROR_DOM_MEDIA_MEDIASINK_ERR = 2154692619,
        NS_ERROR_DOM_MEDIA_DEMUXER_ERR = 2154692620,
        NS_ERROR_DOM_MEDIA_CDM_ERR = 2154692621,
        NS_ERROR_DOM_MEDIA_NEED_NEW_DECODER = 2154692622,
        NS_ERROR_DOM_MEDIA_INITIALIZING_DECODER = 2154692623,
        NS_ERROR_DOM_MEDIA_CUBEB_INITIALIZATION_ERR = 2154692709,
        NS_ERROR_UC_UPDATE_UNKNOWN = 2154758145,
        NS_ERROR_UC_UPDATE_DUPLICATE_PREFIX = 2154758146,
        NS_ERROR_UC_UPDATE_INFINITE_LOOP = 2154758147,
        NS_ERROR_UC_UPDATE_WRONG_REMOVAL_INDICES = 2154758148,
        NS_ERROR_UC_UPDATE_CHECKSUM_MISMATCH = 2154758149,
        NS_ERROR_UC_UPDATE_MISSING_CHECKSUM = 2154758150,
        NS_ERROR_UC_UPDATE_SHUTDOWNING = 2154758151,
        NS_ERROR_UC_UPDATE_TABLE_NOT_FOUND = 2154758152,
        NS_ERROR_UC_UPDATE_BUILD_PREFIX_FAILURE = 2154758153,
        NS_ERROR_UC_UPDATE_FAIL_TO_WRITE_DISK = 2154758154,
        NS_ERROR_UC_UPDATE_PROTOCOL_PARSER_ERROR = 2154758155,
        NS_ERROR_INTERNAL_ERRORRESULT_JS_EXCEPTION = 2154823681,
        NS_ERROR_INTERNAL_ERRORRESULT_DOMEXCEPTION = 2154823682,
        NS_ERROR_INTERNAL_ERRORRESULT_EXCEPTION_ON_JSCONTEXT = 2154823683,
        NS_ERROR_INTERNAL_ERRORRESULT_TYPEERROR = 2154823684,
        NS_ERROR_INTERNAL_ERRORRESULT_RANGEERROR = 2154823685,
        NS_ERROR_DOWNLOAD_COMPLETE = 2155347969,
        NS_ERROR_DOWNLOAD_NOT_PARTIAL = 2155347970,
        NS_ERROR_UNORM_MOREOUTPUT = 2155348001,
        NS_ERROR_DOCSHELL_REQUEST_REJECTED = 2155348969,
        NS_ERROR_DOCUMENT_IS_PRINTMODE = 2155349969,
        NS_SUCCESS_DONT_FIXUP = 7864321,
        NS_SUCCESS_RESTART_APP_NOT_SAME_PROFILE = 7864323,
        NS_SUCCESS_UNORM_NOTFOUND = 7864337,
        NS_ERROR_NOT_IN_TREE = 2155348006,
        NS_OK_NO_NAME_CLAUSE_HANDLED = 7864354,
    }
    pub type nsrefcnt = root::MozRefCountType;
    /**
 * already_AddRefed cooperates with reference counting smart pointers to enable
 * you to assign in a pointer _without_ |AddRef|ing it.  You might want to use
 * this as a return type from a function that returns an already |AddRef|ed
 * pointer.
 *
 * TODO Move already_AddRefed to namespace mozilla.  This has not yet been done
 * because of the sheer number of usages of already_AddRefed.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct already_AddRefed<T> {
        pub mRawPtr: *mut T,
    }
    pub type already_AddRefed_MatchNullptr =
        ::std::option::Option<unsafe extern "C" fn(arg1: f64, arg2: f32)>;
    #[repr(C)]
    pub struct nsCOMPtr_helper__bindgen_vtable {
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCOMPtr_helper {
        pub vtable_: *const nsCOMPtr_helper__bindgen_vtable,
    }
    #[test]
    fn bindgen_test_layout_nsCOMPtr_helper() {
        assert_eq!(::std::mem::size_of::<nsCOMPtr_helper>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsCOMPtr_helper ) ));
        assert_eq! (::std::mem::align_of::<nsCOMPtr_helper>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCOMPtr_helper ) ));
    }
    impl Clone for nsCOMPtr_helper {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct RefPtr<T> {
        pub mRawPtr: *mut T,
    }
    pub type RefPtr_element_type<T> = T;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RefPtr_Proxy<T, R, Args> {
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<R>,
        pub _phantom_2: ::std::marker::PhantomData<Args>,
    }
    pub type RefPtr_Proxy_member_function = [u8; 0usize];
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RefPtr_ConstRemovingRefPtrTraits<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[repr(C)]
    pub struct nsCycleCollectionTraversalCallback__bindgen_vtable {
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCycleCollectionTraversalCallback {
        pub vtable_: *const nsCycleCollectionTraversalCallback__bindgen_vtable,
        pub mFlags: u32,
    }
    pub const nsCycleCollectionTraversalCallback_WANT_DEBUG_INFO:
              root::nsCycleCollectionTraversalCallback__bindgen_ty_1 =
        nsCycleCollectionTraversalCallback__bindgen_ty_1::WANT_DEBUG_INFO;
    pub const nsCycleCollectionTraversalCallback_WANT_ALL_TRACES:
              root::nsCycleCollectionTraversalCallback__bindgen_ty_1 =
        nsCycleCollectionTraversalCallback__bindgen_ty_1::WANT_ALL_TRACES;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCycleCollectionTraversalCallback__bindgen_ty_1 {
        WANT_DEBUG_INFO = 1,
        WANT_ALL_TRACES = 2,
    }
    #[test]
    fn bindgen_test_layout_nsCycleCollectionTraversalCallback() {
        assert_eq!(::std::mem::size_of::<nsCycleCollectionTraversalCallback>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsCycleCollectionTraversalCallback ) ));
        assert_eq! (::std::mem::align_of::<nsCycleCollectionTraversalCallback>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsCycleCollectionTraversalCallback ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCycleCollectionTraversalCallback )
                    ) . mFlags as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCycleCollectionTraversalCallback ) , "::" , stringify !
                    ( mFlags ) ));
    }
    impl Clone for nsCycleCollectionTraversalCallback {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSContext([u8; 0]);
    pub mod JS {
        #[allow(unused_imports)]
        use self::super::super::root;
        /**
 * JS::Value is the interface for a single JavaScript Engine value.  A few
 * general notes on JS::Value:
 *
 * - JS::Value has setX() and isX() members for X in
 *
 *     { Int32, Double, String, Symbol, Boolean, Undefined, Null, Object, Magic }
 *
 *   JS::Value also contains toX() for each of the non-singleton types.
 *
 * - Magic is a singleton type whose payload contains either a JSWhyMagic "reason" for
 *   the magic value or a uint32_t value. By providing JSWhyMagic values when
 *   creating and checking for magic values, it is possible to assert, at
 *   runtime, that only magic values with the expected reason flow through a
 *   particular value. For example, if cx->exception has a magic value, the
 *   reason must be JS_GENERATOR_CLOSING.
 *
 * - The JS::Value operations are preferred.  The JSVAL_* operations remain for
 *   compatibility; they may be removed at some point.  These operations mostly
 *   provide similar functionality.  But there are a few key differences.  One
 *   is that JS::Value gives null a separate type.
 *   Also, to help prevent mistakenly boxing a nullable JSObject* as an object,
 *   Value::setObject takes a JSObject&. (Conversely, Value::toObject returns a
 *   JSObject&.)  A convenience member Value::setObjectOrNull is provided.
 *
 * - JSVAL_VOID is the same as the singleton value of the Undefined type.
 *
 * - Note that JS::Value is 8 bytes on 32 and 64-bit architectures. Thus, on
 *   32-bit user code should avoid copying jsval/JS::Value as much as possible,
 *   preferring to pass by const Value&.
 */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct Value {
            pub data: root::JS::Value_layout,
        }
        pub type Value_PayloadType = u64;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct Value_layout {
            pub asBits: root::__BindgenUnionField<u64>,
            pub debugView: root::__BindgenUnionField<root::JS::Value_layout__bindgen_ty_1>,
            pub s: root::__BindgenUnionField<root::JS::Value_layout__bindgen_ty_2>,
            pub asDouble: root::__BindgenUnionField<f64>,
            pub asPtr: root::__BindgenUnionField<*mut ::std::os::raw::c_void>,
            pub asWord: root::__BindgenUnionField<usize>,
            pub asUIntPtr: root::__BindgenUnionField<usize>,
            pub bindgen_union_field: u64,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct Value_layout__bindgen_ty_1 {
            pub _bitfield_1: u64,
            pub __bindgen_align: [u64; 0usize],
        }
        #[test]
        fn bindgen_test_layout_Value_layout__bindgen_ty_1() {
            assert_eq!(::std::mem::size_of::<Value_layout__bindgen_ty_1>() ,
                       8usize , concat ! (
                       "Size of: " , stringify ! ( Value_layout__bindgen_ty_1
                       ) ));
            assert_eq! (::std::mem::align_of::<Value_layout__bindgen_ty_1>() ,
                        8usize , concat ! (
                        "Alignment of " , stringify ! (
                        Value_layout__bindgen_ty_1 ) ));
        }
        impl Clone for Value_layout__bindgen_ty_1 {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct Value_layout__bindgen_ty_2 {
            pub payload: root::JS::Value_layout__bindgen_ty_2__bindgen_ty_1,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct Value_layout__bindgen_ty_2__bindgen_ty_1 {
            pub i32: root::__BindgenUnionField<i32>,
            pub u32: root::__BindgenUnionField<u32>,
            pub why: root::__BindgenUnionField<root::JSWhyMagic>,
            pub bindgen_union_field: u32,
        }
        #[test]
        fn bindgen_test_layout_Value_layout__bindgen_ty_2__bindgen_ty_1() {
            assert_eq!(::std::mem::size_of::<Value_layout__bindgen_ty_2__bindgen_ty_1>()
                       , 4usize , concat ! (
                       "Size of: " , stringify ! (
                       Value_layout__bindgen_ty_2__bindgen_ty_1 ) ));
            assert_eq! (::std::mem::align_of::<Value_layout__bindgen_ty_2__bindgen_ty_1>()
                        , 4usize , concat ! (
                        "Alignment of " , stringify ! (
                        Value_layout__bindgen_ty_2__bindgen_ty_1 ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const Value_layout__bindgen_ty_2__bindgen_ty_1
                        ) ) . i32 as * const _ as usize } , 0usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        Value_layout__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                        stringify ! ( i32 ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const Value_layout__bindgen_ty_2__bindgen_ty_1
                        ) ) . u32 as * const _ as usize } , 0usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        Value_layout__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                        stringify ! ( u32 ) ));
            assert_eq! (unsafe {
                        & (
                        * (
                        0 as * const Value_layout__bindgen_ty_2__bindgen_ty_1
                        ) ) . why as * const _ as usize } , 0usize , concat !
                        (
                        "Alignment of field: " , stringify ! (
                        Value_layout__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                        stringify ! ( why ) ));
        }
        impl Clone for Value_layout__bindgen_ty_2__bindgen_ty_1 {
            fn clone(&self) -> Self { *self }
        }
        #[test]
        fn bindgen_test_layout_Value_layout__bindgen_ty_2() {
            assert_eq!(::std::mem::size_of::<Value_layout__bindgen_ty_2>() ,
                       4usize , concat ! (
                       "Size of: " , stringify ! ( Value_layout__bindgen_ty_2
                       ) ));
            assert_eq! (::std::mem::align_of::<Value_layout__bindgen_ty_2>() ,
                        4usize , concat ! (
                        "Alignment of " , stringify ! (
                        Value_layout__bindgen_ty_2 ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout__bindgen_ty_2 ) ) .
                        payload as * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        Value_layout__bindgen_ty_2 ) , "::" , stringify ! (
                        payload ) ));
        }
        impl Clone for Value_layout__bindgen_ty_2 {
            fn clone(&self) -> Self { *self }
        }
        #[test]
        fn bindgen_test_layout_Value_layout() {
            assert_eq!(::std::mem::size_of::<Value_layout>() , 8usize , concat
                       ! ( "Size of: " , stringify ! ( Value_layout ) ));
            assert_eq! (::std::mem::align_of::<Value_layout>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( Value_layout ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout ) ) . asBits as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value_layout )
                        , "::" , stringify ! ( asBits ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout ) ) . debugView as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value_layout )
                        , "::" , stringify ! ( debugView ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout ) ) . s as * const _
                        as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value_layout )
                        , "::" , stringify ! ( s ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout ) ) . asDouble as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value_layout )
                        , "::" , stringify ! ( asDouble ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout ) ) . asPtr as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value_layout )
                        , "::" , stringify ! ( asPtr ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout ) ) . asWord as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value_layout )
                        , "::" , stringify ! ( asWord ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value_layout ) ) . asUIntPtr as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value_layout )
                        , "::" , stringify ! ( asUIntPtr ) ));
        }
        impl Clone for Value_layout {
            fn clone(&self) -> Self { *self }
        }
        #[test]
        fn bindgen_test_layout_Value() {
            assert_eq!(::std::mem::size_of::<Value>() , 8usize , concat ! (
                       "Size of: " , stringify ! ( Value ) ));
            assert_eq! (::std::mem::align_of::<Value>() , 8usize , concat ! (
                        "Alignment of " , stringify ! ( Value ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Value ) ) . data as * const _ as
                        usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Value ) , "::"
                        , stringify ! ( data ) ));
        }
        impl Clone for Value {
            fn clone(&self) -> Self { *self }
        }
        /**
 * Reference to a T that has been rooted elsewhere. This is most useful
 * as a parameter type, which guarantees that the T lvalue is properly
 * rooted. See "Move GC Stack Rooting" above.
 *
 * If you want to add additional methods to Handle for a specific
 * specialization, define a HandleBase<T> specialization containing them.
 */
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Handle<T> {
            pub ptr: *mut T,
        }
        pub type Handle_ElementType<T> = T;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum Handle_Disambiguator {
            DeliberatelyChoosingThisOverload = 0,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum Handle_CallerIdentity {
            ImUsingThisOnlyInFromFromMarkedLocation = 0,
        }
        /**
 * Similar to a handle, but the underlying storage can be changed. This is
 * useful for outparams.
 *
 * If you want to add additional methods to MutableHandle for a specific
 * specialization, define a MutableHandleBase<T> specialization containing
 * them.
 */
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MutableHandle<T> {
            pub ptr: *mut T,
        }
        pub type MutableHandle_ElementType<T> = T;
        pub type HandleValue = root::JS::Handle<root::JS::Value>;
        pub type MutableHandleValue =
            root::JS::MutableHandle<root::JS::Value>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DeletePolicy<T> {
            pub _address: u8,
            pub _phantom_0: ::std::marker::PhantomData<T>,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct FreePolicy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_FreePolicy() {
            assert_eq!(::std::mem::size_of::<FreePolicy>() , 1usize , concat !
                       ( "Size of: " , stringify ! ( FreePolicy ) ));
            assert_eq! (::std::mem::align_of::<FreePolicy>() , 1usize , concat
                        ! ( "Alignment of " , stringify ! ( FreePolicy ) ));
        }
        impl Clone for FreePolicy {
            fn clone(&self) -> Self { *self }
        }
        /**
 * A GC pointer, tagged with the trace kind.
 *
 * In general, a GC pointer should be stored with an exact type. This class
 * is for use when that is not possible because a single pointer must point
 * to several kinds of GC thing.
 */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct GCCellPtr {
            pub ptr: usize,
        }
        #[test]
        fn bindgen_test_layout_GCCellPtr() {
            assert_eq!(::std::mem::size_of::<GCCellPtr>() , 8usize , concat !
                       ( "Size of: " , stringify ! ( GCCellPtr ) ));
            assert_eq! (::std::mem::align_of::<GCCellPtr>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( GCCellPtr ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const GCCellPtr ) ) . ptr as * const _
                        as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( GCCellPtr ) ,
                        "::" , stringify ! ( ptr ) ));
        }
        impl Clone for GCCellPtr {
            fn clone(&self) -> Self { *self }
        }
        pub mod dbg {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug)]
            pub struct GarbageCollectionEvent {
                pub majorGCNumber_: u64,
                pub reason: *const ::std::os::raw::c_char,
                pub nonincrementalReason: *const ::std::os::raw::c_char,
                pub collections: [u64; 3usize],
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct GarbageCollectionEvent_Collection {
                pub startTimestamp: root::mozilla::TimeStamp,
                pub endTimestamp: root::mozilla::TimeStamp,
            }
            #[test]
            fn bindgen_test_layout_GarbageCollectionEvent_Collection() {
                assert_eq!(::std::mem::size_of::<GarbageCollectionEvent_Collection>()
                           , 16usize , concat ! (
                           "Size of: " , stringify ! (
                           GarbageCollectionEvent_Collection ) ));
                assert_eq! (::std::mem::align_of::<GarbageCollectionEvent_Collection>()
                            , 8usize , concat ! (
                            "Alignment of " , stringify ! (
                            GarbageCollectionEvent_Collection ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const GarbageCollectionEvent_Collection
                            ) ) . startTimestamp as * const _ as usize } ,
                            0usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            GarbageCollectionEvent_Collection ) , "::" ,
                            stringify ! ( startTimestamp ) ));
                assert_eq! (unsafe {
                            & (
                            * ( 0 as * const GarbageCollectionEvent_Collection
                            ) ) . endTimestamp as * const _ as usize } ,
                            8usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            GarbageCollectionEvent_Collection ) , "::" ,
                            stringify ! ( endTimestamp ) ));
            }
            impl Clone for GarbageCollectionEvent_Collection {
                fn clone(&self) -> Self { *self }
            }
            pub type GarbageCollectionEvent_Ptr =
                root::mozilla::UniquePtr<root::JS::dbg::GarbageCollectionEvent,
                                         root::JS::DeletePolicy<root::JS::dbg::GarbageCollectionEvent>>;
            #[test]
            fn bindgen_test_layout_GarbageCollectionEvent() {
                assert_eq!(::std::mem::size_of::<GarbageCollectionEvent>() ,
                           48usize , concat ! (
                           "Size of: " , stringify ! ( GarbageCollectionEvent
                           ) ));
                assert_eq! (::std::mem::align_of::<GarbageCollectionEvent>() ,
                            8usize , concat ! (
                            "Alignment of " , stringify ! (
                            GarbageCollectionEvent ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GarbageCollectionEvent ) ) .
                            majorGCNumber_ as * const _ as usize } , 0usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GarbageCollectionEvent ) , "::" , stringify ! (
                            majorGCNumber_ ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GarbageCollectionEvent ) ) .
                            reason as * const _ as usize } , 8usize , concat !
                            (
                            "Alignment of field: " , stringify ! (
                            GarbageCollectionEvent ) , "::" , stringify ! (
                            reason ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GarbageCollectionEvent ) ) .
                            nonincrementalReason as * const _ as usize } ,
                            16usize , concat ! (
                            "Alignment of field: " , stringify ! (
                            GarbageCollectionEvent ) , "::" , stringify ! (
                            nonincrementalReason ) ));
                assert_eq! (unsafe {
                            & ( * ( 0 as * const GarbageCollectionEvent ) ) .
                            collections as * const _ as usize } , 24usize ,
                            concat ! (
                            "Alignment of field: " , stringify ! (
                            GarbageCollectionEvent ) , "::" , stringify ! (
                            collections ) ));
            }
        }
        /**
 * The Heap<T> class is a heap-stored reference to a JS GC thing. All members of
 * heap classes that refer to GC things should use Heap<T> (or possibly
 * TenuredHeap<T>, described below).
 *
 * Heap<T> is an abstraction that hides some of the complexity required to
 * maintain GC invariants for the contained reference. It uses operator
 * overloading to provide a normal pointer interface, but notifies the GC every
 * time the value it contains is updated. This is necessary for generational GC,
 * which keeps track of all pointers into the nursery.
 *
 * Heap<T> instances must be traced when their containing object is traced to
 * keep the pointed-to GC thing alive.
 *
 * Heap<T> objects should only be used on the heap. GC references stored on the
 * C/C++ stack must use Rooted/Handle/MutableHandle instead.
 *
 * Type T must be a public GC pointer type.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct Heap<T> {
            pub ptr: T,
        }
        pub type Heap_ElementType<T> = T;
        /**
 * The TenuredHeap<T> class is similar to the Heap<T> class above in that it
 * encapsulates the GC concerns of an on-heap reference to a JS object. However,
 * it has two important differences:
 *
 *  1) Pointers which are statically known to only reference "tenured" objects
 *     can avoid the extra overhead of SpiderMonkey's write barriers.
 *
 *  2) Objects in the "tenured" heap have stronger alignment restrictions than
 *     those in the "nursery", so it is possible to store flags in the lower
 *     bits of pointers known to be tenured. TenuredHeap wraps a normal tagged
 *     pointer with a nice API for accessing the flag bits and adds various
 *     assertions to ensure that it is not mis-used.
 *
 * GC things are said to be "tenured" when they are located in the long-lived
 * heap: e.g. they have gained tenure as an object by surviving past at least
 * one GC. For performance, SpiderMonkey allocates some things which are known
 * to normally be long lived directly into the tenured generation; for example,
 * global objects. Additionally, SpiderMonkey does not visit individual objects
 * when deleting non-tenured objects, so object with finalizers are also always
 * tenured; for instance, this includes most DOM objects.
 *
 * The considerations to keep in mind when using a TenuredHeap<T> vs a normal
 * Heap<T> are:
 *
 *  - It is invalid for a TenuredHeap<T> to refer to a non-tenured thing.
 *  - It is however valid for a Heap<T> to refer to a tenured thing.
 *  - It is not possible to store flag bits in a Heap<T>.
 */
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TenuredHeap<T> {
            pub bits: usize,
            pub _phantom_0: ::std::marker::PhantomData<T>,
        }
        pub type TenuredHeap_ElementType<T> = T;
        pub const TenuredHeap_maskBits: root::JS::TenuredHeap__bindgen_ty_1 =
            TenuredHeap__bindgen_ty_1::maskBits;
        pub const TenuredHeap_flagsMask: root::JS::TenuredHeap__bindgen_ty_1 =
            TenuredHeap__bindgen_ty_1::maskBits;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum TenuredHeap__bindgen_ty_1 { maskBits = 0, }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ConstUTF8CharsZ {
            pub data_: *const ::std::os::raw::c_char,
        }
        pub type ConstUTF8CharsZ_CharT = ::std::os::raw::c_uchar;
        #[test]
        fn bindgen_test_layout_ConstUTF8CharsZ() {
            assert_eq!(::std::mem::size_of::<ConstUTF8CharsZ>() , 8usize ,
                       concat ! (
                       "Size of: " , stringify ! ( ConstUTF8CharsZ ) ));
            assert_eq! (::std::mem::align_of::<ConstUTF8CharsZ>() , 8usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( ConstUTF8CharsZ ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ConstUTF8CharsZ ) ) . data_ as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( ConstUTF8CharsZ
                        ) , "::" , stringify ! ( data_ ) ));
        }
        impl Clone for ConstUTF8CharsZ {
            fn clone(&self) -> Self { *self }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSFunction([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSObject([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSScript([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSString([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct jsid {
        pub asBits: usize,
    }
    #[test]
    fn bindgen_test_layout_jsid() {
        assert_eq!(::std::mem::size_of::<jsid>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( jsid ) ));
        assert_eq! (::std::mem::align_of::<jsid>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( jsid ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const jsid ) ) . asBits as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( jsid ) , "::" ,
                    stringify ! ( asBits ) ));
    }
    impl Clone for jsid {
        fn clone(&self) -> Self { *self }
    }
    pub mod js {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod gc {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod gcstats {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Statistics([u8; 0]);
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct SystemAllocPolicy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_SystemAllocPolicy() {
            assert_eq!(::std::mem::size_of::<SystemAllocPolicy>() , 1usize ,
                       concat ! (
                       "Size of: " , stringify ! ( SystemAllocPolicy ) ));
            assert_eq! (::std::mem::align_of::<SystemAllocPolicy>() , 1usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( SystemAllocPolicy )
                        ));
        }
        impl Clone for SystemAllocPolicy {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WrappedPtrOperations<Element, Wrapper> {
            pub _address: u8,
            pub _phantom_0: ::std::marker::PhantomData<Element>,
            pub _phantom_1: ::std::marker::PhantomData<Wrapper>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MutableWrappedPtrOperations<Element, Wrapper> {
            pub _address: u8,
            pub _phantom_0: ::std::marker::PhantomData<Element>,
            pub _phantom_1: ::std::marker::PhantomData<Wrapper>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HandleBase<T, Wrapper> {
            pub _address: u8,
            pub _phantom_0: ::std::marker::PhantomData<T>,
            pub _phantom_1: ::std::marker::PhantomData<Wrapper>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MutableHandleBase<T, Wrapper> {
            pub _address: u8,
            pub _phantom_0: ::std::marker::PhantomData<T>,
            pub _phantom_1: ::std::marker::PhantomData<Wrapper>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HeapBase<T, Wrapper> {
            pub _address: u8,
            pub _phantom_0: ::std::marker::PhantomData<T>,
            pub _phantom_1: ::std::marker::PhantomData<Wrapper>,
        }
        #[repr(C)]
        pub struct SourceHook__bindgen_vtable {
        }
        /**
 * A class of objects that return source code on demand.
 *
 * When code is compiled with setSourceIsLazy(true), SpiderMonkey doesn't
 * retain the source code (and doesn't do lazy bytecode generation). If we ever
 * need the source code, say, in response to a call to Function.prototype.
 * toSource or Debugger.Source.prototype.text, then we call the 'load' member
 * function of the instance of this class that has hopefully been registered
 * with the runtime, passing the code's URL, and hope that it will be able to
 * find the source.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct SourceHook {
            pub vtable_: *const SourceHook__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_SourceHook() {
            assert_eq!(::std::mem::size_of::<SourceHook>() , 8usize , concat !
                       ( "Size of: " , stringify ! ( SourceHook ) ));
            assert_eq! (::std::mem::align_of::<SourceHook>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( SourceHook ) ));
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSCompartment([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSRuntime([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct JSTracer {
        pub runtime_: *mut root::JSRuntime,
        pub weakMapAction_: root::WeakMapTraceKind,
        pub tag_: root::JSTracer_TracerKindTag,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSTracer_TracerKindTag {
        Marking = 0,
        WeakMarking = 1,
        Tenuring = 2,
        Callback = 3,
    }
    #[test]
    fn bindgen_test_layout_JSTracer() {
        assert_eq!(::std::mem::size_of::<JSTracer>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( JSTracer ) ));
        assert_eq! (::std::mem::align_of::<JSTracer>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( JSTracer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSTracer ) ) . runtime_ as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSTracer ) , "::" ,
                    stringify ! ( runtime_ ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSTracer ) ) . weakMapAction_ as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSTracer ) , "::" ,
                    stringify ! ( weakMapAction_ ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSTracer ) ) . tag_ as * const _ as
                    usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSTracer ) , "::" ,
                    stringify ! ( tag_ ) ));
    }
    impl Clone for JSTracer {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum WeakMapTraceKind {
        DoNotTraceWeakMaps = 0,
        ExpandWeakMaps = 1,
        TraceWeakMapValues = 2,
        TraceWeakMapKeysValues = 3,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSValueTag {
        JSVAL_TAG_MAX_DOUBLE = 131056,
        JSVAL_TAG_INT32 = 131057,
        JSVAL_TAG_UNDEFINED = 131058,
        JSVAL_TAG_NULL = 131059,
        JSVAL_TAG_BOOLEAN = 131060,
        JSVAL_TAG_MAGIC = 131061,
        JSVAL_TAG_STRING = 131062,
        JSVAL_TAG_SYMBOL = 131063,
        JSVAL_TAG_PRIVATE_GCTHING = 131064,
        JSVAL_TAG_OBJECT = 131068,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSWhyMagic {
        JS_ELEMENTS_HOLE = 0,
        JS_NO_ITER_VALUE = 1,
        JS_GENERATOR_CLOSING = 2,
        JS_NO_CONSTANT = 3,
        JS_THIS_POISON = 4,
        JS_ARG_POISON = 5,
        JS_SERIALIZE_NO_NODE = 6,
        JS_LAZY_ARGUMENTS = 7,
        JS_OPTIMIZED_ARGUMENTS = 8,
        JS_IS_CONSTRUCTING = 9,
        JS_BLOCK_NEEDS_CLONE = 10,
        JS_HASH_KEY_EMPTY = 11,
        JS_ION_ERROR = 12,
        JS_ION_BAILOUT = 13,
        JS_OPTIMIZED_OUT = 14,
        JS_UNINITIALIZED_LEXICAL = 15,
        JS_GENERIC_MAGIC = 16,
        JS_WHY_MAGIC_COUNT = 17,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAString_internal {
        pub mData: *mut root::nsAString_internal_char_type,
        pub mLength: root::nsAString_internal_size_type,
        pub mFlags: u32,
    }
    pub type nsAString_internal_fallible_t = root::mozilla::fallible_t;
    pub type nsAString_internal_char_type = u16;
    pub type nsAString_internal_char_traits = u8;
    pub type nsAString_internal_incompatible_char_type = u8;
    pub type nsAString_internal_self_type = root::nsAString_internal;
    pub type nsAString_internal_abstract_string_type =
        root::nsAString_internal_self_type;
    pub type nsAString_internal_base_string_type =
        root::nsAString_internal_self_type;
    pub type nsAString_internal_substring_type =
        root::nsAString_internal_self_type;
    pub type nsAString_internal_substring_tuple_type = root::nsSubstringTuple;
    pub type nsAString_internal_string_type = ::nsstring::nsStringRepr;
    pub type nsAString_internal_const_iterator = root::nsReadingIterator<u16>;
    pub type nsAString_internal_iterator = root::nsWritingIterator<u16>;
    pub type nsAString_internal_comparator_type = root::nsStringComparator;
    pub type nsAString_internal_char_iterator =
        *mut root::nsAString_internal_char_type;
    pub type nsAString_internal_const_char_iterator =
        *const root::nsAString_internal_char_type;
    pub type nsAString_internal_size_type = u32;
    pub type nsAString_internal_index_type = u32;
    pub const nsAString_internal_F_NONE:
              root::nsAString_internal__bindgen_ty_1 =
        nsAString_internal__bindgen_ty_1::F_NONE;
    pub const nsAString_internal_F_TERMINATED:
              root::nsAString_internal__bindgen_ty_1 =
        nsAString_internal__bindgen_ty_1::F_TERMINATED;
    pub const nsAString_internal_F_VOIDED:
              root::nsAString_internal__bindgen_ty_1 =
        nsAString_internal__bindgen_ty_1::F_VOIDED;
    pub const nsAString_internal_F_SHARED:
              root::nsAString_internal__bindgen_ty_1 =
        nsAString_internal__bindgen_ty_1::F_SHARED;
    pub const nsAString_internal_F_OWNED:
              root::nsAString_internal__bindgen_ty_1 =
        nsAString_internal__bindgen_ty_1::F_OWNED;
    pub const nsAString_internal_F_FIXED:
              root::nsAString_internal__bindgen_ty_1 =
        nsAString_internal__bindgen_ty_1::F_FIXED;
    pub const nsAString_internal_F_LITERAL:
              root::nsAString_internal__bindgen_ty_1 =
        nsAString_internal__bindgen_ty_1::F_LITERAL;
    pub const nsAString_internal_F_CLASS_FIXED:
              root::nsAString_internal__bindgen_ty_1 =
        nsAString_internal__bindgen_ty_1::F_CLASS_FIXED;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsAString_internal__bindgen_ty_1 {
        F_NONE = 0,
        F_TERMINATED = 1,
        F_VOIDED = 2,
        F_SHARED = 4,
        F_OWNED = 8,
        F_FIXED = 16,
        F_LITERAL = 32,
        F_CLASS_FIXED = 65536,
    }
    #[test]
    fn bindgen_test_layout_nsAString_internal() {
        assert_eq!(::std::mem::size_of::<nsAString_internal>() , 16usize ,
                   concat ! ( "Size of: " , stringify ! ( nsAString_internal )
                   ));
        assert_eq! (::std::mem::align_of::<nsAString_internal>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsAString_internal ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAString_internal ) ) . mData as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAString_internal
                    ) , "::" , stringify ! ( mData ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAString_internal ) ) . mLength as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAString_internal
                    ) , "::" , stringify ! ( mLength ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAString_internal ) ) . mFlags as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAString_internal
                    ) , "::" , stringify ! ( mFlags ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsSubstringTuple {
        pub mHead: *const root::nsSubstringTuple_self_type,
        pub mFragA: *const root::nsSubstringTuple_base_string_type,
        pub mFragB: *const root::nsSubstringTuple_base_string_type,
    }
    pub type nsSubstringTuple_char_type = u16;
    pub type nsSubstringTuple_char_traits = root::nsCharTraits<u16>;
    pub type nsSubstringTuple_self_type = root::nsSubstringTuple;
    pub type nsSubstringTuple_substring_type = root::nsAString_internal;
    pub type nsSubstringTuple_base_string_type = root::nsAString_internal;
    pub type nsSubstringTuple_size_type = u32;
    #[test]
    fn bindgen_test_layout_nsSubstringTuple() {
        assert_eq!(::std::mem::size_of::<nsSubstringTuple>() , 24usize ,
                   concat ! ( "Size of: " , stringify ! ( nsSubstringTuple )
                   ));
        assert_eq! (::std::mem::align_of::<nsSubstringTuple>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsSubstringTuple ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSubstringTuple ) ) . mHead as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSubstringTuple )
                    , "::" , stringify ! ( mHead ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSubstringTuple ) ) . mFragA as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSubstringTuple )
                    , "::" , stringify ! ( mFragA ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSubstringTuple ) ) . mFragB as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSubstringTuple )
                    , "::" , stringify ! ( mFragB ) ));
    }
    impl Clone for nsSubstringTuple {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    pub struct nsAutoString {
        pub _base: root::nsFixedString,
        pub mStorage: [root::nsAString_internal_char_type; 64usize],
    }
    pub type nsAutoString_self_type = root::nsAutoString;
    pub const nsAutoString_kDefaultStorageSize:
              root::nsAutoString__bindgen_ty_1 =
        nsAutoString__bindgen_ty_1::kDefaultStorageSize;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsAutoString__bindgen_ty_1 { kDefaultStorageSize = 64, }
    #[test]
    fn bindgen_test_layout_nsAutoString() {
        assert_eq!(::std::mem::size_of::<nsAutoString>() , 160usize , concat !
                   ( "Size of: " , stringify ! ( nsAutoString ) ));
        assert_eq! (::std::mem::align_of::<nsAutoString>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsAutoString ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAutoString ) ) . mStorage as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAutoString ) ,
                    "::" , stringify ! ( mStorage ) ));
    }
    #[repr(C)]
    pub struct nsStringComparator__bindgen_vtable {
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStringComparator {
        pub vtable_: *const nsStringComparator__bindgen_vtable,
    }
    pub type nsStringComparator_char_type = u16;
    #[test]
    fn bindgen_test_layout_nsStringComparator() {
        assert_eq!(::std::mem::size_of::<nsStringComparator>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStringComparator )
                   ));
        assert_eq! (::std::mem::align_of::<nsStringComparator>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStringComparator ) ));
    }
    impl Clone for nsStringComparator {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsACString_internal {
        pub mData: *mut root::nsACString_internal_char_type,
        pub mLength: root::nsACString_internal_size_type,
        pub mFlags: u32,
    }
    pub type nsACString_internal_fallible_t = root::mozilla::fallible_t;
    pub type nsACString_internal_char_type = ::std::os::raw::c_char;
    pub type nsACString_internal_char_traits = u8;
    pub type nsACString_internal_incompatible_char_type = u16;
    pub type nsACString_internal_self_type = root::nsACString_internal;
    pub type nsACString_internal_abstract_string_type =
        root::nsACString_internal_self_type;
    pub type nsACString_internal_base_string_type =
        root::nsACString_internal_self_type;
    pub type nsACString_internal_substring_type =
        root::nsACString_internal_self_type;
    pub type nsACString_internal_substring_tuple_type =
        root::nsCSubstringTuple;
    pub type nsACString_internal_string_type = root::nsCString;
    pub type nsACString_internal_const_iterator =
        root::nsReadingIterator<::std::os::raw::c_char>;
    pub type nsACString_internal_iterator =
        root::nsWritingIterator<::std::os::raw::c_char>;
    pub type nsACString_internal_comparator_type = root::nsCStringComparator;
    pub type nsACString_internal_char_iterator =
        *mut root::nsACString_internal_char_type;
    pub type nsACString_internal_const_char_iterator =
        *const root::nsACString_internal_char_type;
    pub type nsACString_internal_size_type = u32;
    pub type nsACString_internal_index_type = u32;
    pub const nsACString_internal_F_NONE:
              root::nsACString_internal__bindgen_ty_1 =
        nsACString_internal__bindgen_ty_1::F_NONE;
    pub const nsACString_internal_F_TERMINATED:
              root::nsACString_internal__bindgen_ty_1 =
        nsACString_internal__bindgen_ty_1::F_TERMINATED;
    pub const nsACString_internal_F_VOIDED:
              root::nsACString_internal__bindgen_ty_1 =
        nsACString_internal__bindgen_ty_1::F_VOIDED;
    pub const nsACString_internal_F_SHARED:
              root::nsACString_internal__bindgen_ty_1 =
        nsACString_internal__bindgen_ty_1::F_SHARED;
    pub const nsACString_internal_F_OWNED:
              root::nsACString_internal__bindgen_ty_1 =
        nsACString_internal__bindgen_ty_1::F_OWNED;
    pub const nsACString_internal_F_FIXED:
              root::nsACString_internal__bindgen_ty_1 =
        nsACString_internal__bindgen_ty_1::F_FIXED;
    pub const nsACString_internal_F_LITERAL:
              root::nsACString_internal__bindgen_ty_1 =
        nsACString_internal__bindgen_ty_1::F_LITERAL;
    pub const nsACString_internal_F_CLASS_FIXED:
              root::nsACString_internal__bindgen_ty_1 =
        nsACString_internal__bindgen_ty_1::F_CLASS_FIXED;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsACString_internal__bindgen_ty_1 {
        F_NONE = 0,
        F_TERMINATED = 1,
        F_VOIDED = 2,
        F_SHARED = 4,
        F_OWNED = 8,
        F_FIXED = 16,
        F_LITERAL = 32,
        F_CLASS_FIXED = 65536,
    }
    #[test]
    fn bindgen_test_layout_nsACString_internal() {
        assert_eq!(::std::mem::size_of::<nsACString_internal>() , 16usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsACString_internal ) ));
        assert_eq! (::std::mem::align_of::<nsACString_internal>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsACString_internal ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsACString_internal ) ) . mData as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsACString_internal
                    ) , "::" , stringify ! ( mData ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsACString_internal ) ) . mLength as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsACString_internal
                    ) , "::" , stringify ! ( mLength ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsACString_internal ) ) . mFlags as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsACString_internal
                    ) , "::" , stringify ! ( mFlags ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCSubstringTuple {
        pub mHead: *const root::nsCSubstringTuple_self_type,
        pub mFragA: *const root::nsCSubstringTuple_base_string_type,
        pub mFragB: *const root::nsCSubstringTuple_base_string_type,
    }
    pub type nsCSubstringTuple_char_type = ::std::os::raw::c_char;
    pub type nsCSubstringTuple_char_traits =
        root::nsCharTraits<::std::os::raw::c_char>;
    pub type nsCSubstringTuple_self_type = root::nsCSubstringTuple;
    pub type nsCSubstringTuple_substring_type = root::nsACString_internal;
    pub type nsCSubstringTuple_base_string_type = root::nsACString_internal;
    pub type nsCSubstringTuple_size_type = u32;
    #[test]
    fn bindgen_test_layout_nsCSubstringTuple() {
        assert_eq!(::std::mem::size_of::<nsCSubstringTuple>() , 24usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCSubstringTuple )
                   ));
        assert_eq! (::std::mem::align_of::<nsCSubstringTuple>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSubstringTuple ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSubstringTuple ) ) . mHead as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSubstringTuple )
                    , "::" , stringify ! ( mHead ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSubstringTuple ) ) . mFragA as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSubstringTuple )
                    , "::" , stringify ! ( mFragA ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSubstringTuple ) ) . mFragB as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSubstringTuple )
                    , "::" , stringify ! ( mFragB ) ));
    }
    impl Clone for nsCSubstringTuple {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCString {
        pub _base: root::nsACString_internal,
    }
    pub type nsCString_self_type = root::nsCString;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCString_Segment {
        pub mBegin: u32,
        pub mLength: u32,
    }
    #[test]
    fn bindgen_test_layout_nsCString_Segment() {
        assert_eq!(::std::mem::size_of::<nsCString_Segment>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCString_Segment )
                   ));
        assert_eq! (::std::mem::align_of::<nsCString_Segment>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCString_Segment ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCString_Segment ) ) . mBegin as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCString_Segment )
                    , "::" , stringify ! ( mBegin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCString_Segment ) ) . mLength as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCString_Segment )
                    , "::" , stringify ! ( mLength ) ));
    }
    impl Clone for nsCString_Segment {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsCString() {
        assert_eq!(::std::mem::size_of::<nsCString>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsCString ) ));
        assert_eq! (::std::mem::align_of::<nsCString>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsCString ) ));
    }
    #[repr(C)]
    pub struct nsCStringComparator__bindgen_vtable {
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCStringComparator {
        pub vtable_: *const nsCStringComparator__bindgen_vtable,
    }
    pub type nsCStringComparator_char_type = ::std::os::raw::c_char;
    #[test]
    fn bindgen_test_layout_nsCStringComparator() {
        assert_eq!(::std::mem::size_of::<nsCStringComparator>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCStringComparator ) ));
        assert_eq! (::std::mem::align_of::<nsCStringComparator>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCStringComparator ) ));
    }
    impl Clone for nsCStringComparator {
        fn clone(&self) -> Self { *self }
    }
    /**
 * typedefs for backwards compatibility
 */
    pub type nsSubstring = root::nsAString_internal;
    pub type nsAFlatCString = root::nsCString;
    #[repr(C)]
    pub struct nsISupports__bindgen_vtable {
    }
    /**
 * Basic component object model interface. Objects which implement
 * this interface support runtime interface discovery (QueryInterface)
 * and a reference counted memory model (AddRef/Release). This is
 * modelled after the win32 IUnknown API.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsISupports {
        pub vtable_: *const nsISupports__bindgen_vtable,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISupports_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsISupports() {
        assert_eq!(::std::mem::size_of::<nsISupports>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsISupports ) ));
        assert_eq! (::std::mem::align_of::<nsISupports>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsISupports ) ));
    }
    impl Clone for nsISupports {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    pub struct nsCycleCollectionParticipant__bindgen_vtable {
    }
    /**
 * Participant implementation classes
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCycleCollectionParticipant {
        pub vtable_: *const nsCycleCollectionParticipant__bindgen_vtable,
        pub mMightSkip: bool,
        pub mTraverseShouldTrace: bool,
    }
    #[test]
    fn bindgen_test_layout_nsCycleCollectionParticipant() {
        assert_eq!(::std::mem::size_of::<nsCycleCollectionParticipant>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( nsCycleCollectionParticipant )
                   ));
        assert_eq! (::std::mem::align_of::<nsCycleCollectionParticipant>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsCycleCollectionParticipant ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCycleCollectionParticipant ) ) .
                    mMightSkip as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCycleCollectionParticipant ) , "::" , stringify ! (
                    mMightSkip ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCycleCollectionParticipant ) ) .
                    mTraverseShouldTrace as * const _ as usize } , 9usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCycleCollectionParticipant ) , "::" , stringify ! (
                    mTraverseShouldTrace ) ));
    }
    impl Clone for nsCycleCollectionParticipant {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCycleCollectingAutoRefCnt {
        pub mRefCntAndFlags: usize,
    }
    #[test]
    fn bindgen_test_layout_nsCycleCollectingAutoRefCnt() {
        assert_eq!(::std::mem::size_of::<nsCycleCollectingAutoRefCnt>() ,
                   8usize , concat ! (
                   "Size of: " , stringify ! ( nsCycleCollectingAutoRefCnt )
                   ));
        assert_eq! (::std::mem::align_of::<nsCycleCollectingAutoRefCnt>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsCycleCollectingAutoRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCycleCollectingAutoRefCnt ) ) .
                    mRefCntAndFlags as * const _ as usize } , 0usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsCycleCollectingAutoRefCnt ) , "::" , stringify ! (
                    mRefCntAndFlags ) ));
    }
    impl Clone for nsCycleCollectingAutoRefCnt {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsCharTraits<CharT> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<CharT>,
    }
    #[test]
    fn __bindgen_test_layout_template_2() {
        assert_eq!(::std::mem::size_of::<root::nsCharTraits<u16>>() , 1usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCharTraits<u16> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCharTraits<u16>>() , 1usize
                   , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCharTraits<u16> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_3() {
        assert_eq!(::std::mem::size_of::<root::nsCharTraits<::std::os::raw::c_char>>()
                   , 1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCharTraits<::std::os::raw::c_char> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCharTraits<::std::os::raw::c_char>>()
                   , 1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCharTraits<::std::os::raw::c_char> ) ));
    }
    /**
 * @see nsTAString
 */
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsReadingIterator<CharT> {
        pub mStart: *mut CharT,
        pub mEnd: *mut CharT,
        pub mPosition: *mut CharT,
    }
    pub type nsReadingIterator_self_type<CharT> =
        root::nsReadingIterator<CharT>;
    pub type nsReadingIterator_difference_type = isize;
    pub type nsReadingIterator_size_type = usize;
    pub type nsReadingIterator_value_type<CharT> = CharT;
    pub type nsReadingIterator_pointer<CharT> = *mut CharT;
    pub type nsReadingIterator_reference = [u8; 0usize];
    /**
 * @see nsTAString
 */
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsWritingIterator<CharT> {
        pub mStart: *mut CharT,
        pub mEnd: *mut CharT,
        pub mPosition: *mut CharT,
    }
    pub type nsWritingIterator_self_type<CharT> =
        root::nsWritingIterator<CharT>;
    pub type nsWritingIterator_difference_type = isize;
    pub type nsWritingIterator_size_type = usize;
    pub type nsWritingIterator_value_type<CharT> = CharT;
    pub type nsWritingIterator_pointer<CharT> = *mut CharT;
    pub type nsWritingIterator_reference = [u8; 0usize];
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsTSubstringSplitter_CharT {
        pub mStr: *const root::nsAString_internal,
        pub mArray: root::mozilla::UniquePtr<[root::nsAString_internal; 0usize],
                                             root::mozilla::DefaultDelete<[root::nsAString_internal; 0usize]>>,
        pub mArraySize: root::nsAString_internal_size_type,
        pub mDelim: root::nsAString_internal_char_type,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTSubstringSplitter_CharT_nsTSubstringSplit_Iter {
        pub mObj: *const root::nsTSubstringSplitter_CharT,
        pub mPos: root::nsAString_internal_size_type,
    }
    #[test]
    fn bindgen_test_layout_nsTSubstringSplitter_CharT_nsTSubstringSplit_Iter() {
        assert_eq!(::std::mem::size_of::<nsTSubstringSplitter_CharT_nsTSubstringSplit_Iter>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsTSubstringSplitter_CharT_nsTSubstringSplit_Iter ) ));
        assert_eq! (::std::mem::align_of::<nsTSubstringSplitter_CharT_nsTSubstringSplit_Iter>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsTSubstringSplitter_CharT_nsTSubstringSplit_Iter ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const
                    nsTSubstringSplitter_CharT_nsTSubstringSplit_Iter ) ) .
                    mObj as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTSubstringSplitter_CharT_nsTSubstringSplit_Iter ) , "::"
                    , stringify ! ( mObj ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const
                    nsTSubstringSplitter_CharT_nsTSubstringSplit_Iter ) ) .
                    mPos as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTSubstringSplitter_CharT_nsTSubstringSplit_Iter ) , "::"
                    , stringify ! ( mPos ) ));
    }
    impl Clone for nsTSubstringSplitter_CharT_nsTSubstringSplit_Iter {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsTSubstringSplitter_CharT() {
        assert_eq!(::std::mem::size_of::<nsTSubstringSplitter_CharT>() ,
                   24usize , concat ! (
                   "Size of: " , stringify ! ( nsTSubstringSplitter_CharT )
                   ));
        assert_eq! (::std::mem::align_of::<nsTSubstringSplitter_CharT>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsTSubstringSplitter_CharT
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsTSubstringSplitter_CharT ) ) . mStr
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTSubstringSplitter_CharT ) , "::" , stringify ! ( mStr )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsTSubstringSplitter_CharT ) ) .
                    mArray as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTSubstringSplitter_CharT ) , "::" , stringify ! ( mArray
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsTSubstringSplitter_CharT ) ) .
                    mArraySize as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTSubstringSplitter_CharT ) , "::" , stringify ! (
                    mArraySize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsTSubstringSplitter_CharT ) ) .
                    mDelim as * const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTSubstringSplitter_CharT ) , "::" , stringify ! ( mDelim
                    ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSubstringSplitter {
        pub mStr: *const root::nsACString_internal,
        pub mArray: root::mozilla::UniquePtr<[root::nsACString_internal; 0usize],
                                             root::mozilla::DefaultDelete<[root::nsACString_internal; 0usize]>>,
        pub mArraySize: root::nsACString_internal_size_type,
        pub mDelim: root::nsACString_internal_char_type,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCSubstringSplitter_nsTSubstringSplit_Iter {
        pub mObj: *const root::nsCSubstringSplitter,
        pub mPos: root::nsACString_internal_size_type,
    }
    #[test]
    fn bindgen_test_layout_nsCSubstringSplitter_nsTSubstringSplit_Iter() {
        assert_eq!(::std::mem::size_of::<nsCSubstringSplitter_nsTSubstringSplit_Iter>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsCSubstringSplitter_nsTSubstringSplit_Iter ) ));
        assert_eq! (::std::mem::align_of::<nsCSubstringSplitter_nsTSubstringSplit_Iter>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsCSubstringSplitter_nsTSubstringSplit_Iter ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsCSubstringSplitter_nsTSubstringSplit_Iter )
                    ) . mObj as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSubstringSplitter_nsTSubstringSplit_Iter ) , "::" ,
                    stringify ! ( mObj ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsCSubstringSplitter_nsTSubstringSplit_Iter )
                    ) . mPos as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSubstringSplitter_nsTSubstringSplit_Iter ) , "::" ,
                    stringify ! ( mPos ) ));
    }
    impl Clone for nsCSubstringSplitter_nsTSubstringSplit_Iter {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsCSubstringSplitter() {
        assert_eq!(::std::mem::size_of::<nsCSubstringSplitter>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSubstringSplitter ) ));
        assert_eq! (::std::mem::align_of::<nsCSubstringSplitter>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSubstringSplitter ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSubstringSplitter ) ) . mStr as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSubstringSplitter ) , "::" , stringify ! ( mStr ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSubstringSplitter ) ) . mArray as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSubstringSplitter ) , "::" , stringify ! ( mArray ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSubstringSplitter ) ) . mArraySize
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSubstringSplitter ) , "::" , stringify ! ( mArraySize )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSubstringSplitter ) ) . mDelim as
                    * const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSubstringSplitter ) , "::" , stringify ! ( mDelim ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsFixedString {
        pub _base: ::nsstring::nsStringRepr,
        pub mFixedCapacity: root::nsAString_internal_size_type,
        pub mFixedBuf: *mut root::nsAString_internal_char_type,
    }
    pub type nsFixedString_self_type = root::nsFixedString;
    pub type nsFixedString_fixed_string_type = root::nsFixedString;
    #[test]
    fn bindgen_test_layout_nsFixedString() {
        assert_eq!(::std::mem::size_of::<nsFixedString>() , 32usize , concat !
                   ( "Size of: " , stringify ! ( nsFixedString ) ));
        assert_eq! (::std::mem::align_of::<nsFixedString>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsFixedString ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFixedString ) ) . mFixedCapacity as
                    * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFixedString ) ,
                    "::" , stringify ! ( mFixedCapacity ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFixedString ) ) . mFixedBuf as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFixedString ) ,
                    "::" , stringify ! ( mFixedBuf ) ));
    }
    pub type PRUint32 = ::std::os::raw::c_uint;
    pub type PRUintn = ::std::os::raw::c_uint;
    /************************************************************************
** TYPES:       PRSize
** DESCRIPTION:
**  A type for representing the size of objects.
************************************************************************/
    pub type PRSize = usize;
    pub type PRUword = ::std::os::raw::c_ulong;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLHashEntry {
        pub next: *mut root::PLHashEntry,
        pub keyHash: root::PLHashNumber,
        pub key: *const ::std::os::raw::c_void,
        pub value: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_PLHashEntry() {
        assert_eq!(::std::mem::size_of::<PLHashEntry>() , 32usize , concat ! (
                   "Size of: " , stringify ! ( PLHashEntry ) ));
        assert_eq! (::std::mem::align_of::<PLHashEntry>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( PLHashEntry ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashEntry ) ) . next as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashEntry ) ,
                    "::" , stringify ! ( next ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashEntry ) ) . keyHash as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashEntry ) ,
                    "::" , stringify ! ( keyHash ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashEntry ) ) . key as * const _ as
                    usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashEntry ) ,
                    "::" , stringify ! ( key ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashEntry ) ) . value as * const _
                    as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashEntry ) ,
                    "::" , stringify ! ( value ) ));
    }
    impl Clone for PLHashEntry {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLHashTable {
        pub buckets: *mut *mut root::PLHashEntry,
        pub nentries: root::PRUint32,
        pub shift: root::PRUint32,
        pub keyHash: root::PLHashFunction,
        pub keyCompare: root::PLHashComparator,
        pub valueCompare: root::PLHashComparator,
        pub allocOps: *const root::PLHashAllocOps,
        pub allocPriv: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_PLHashTable() {
        assert_eq!(::std::mem::size_of::<PLHashTable>() , 56usize , concat ! (
                   "Size of: " , stringify ! ( PLHashTable ) ));
        assert_eq! (::std::mem::align_of::<PLHashTable>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( PLHashTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . buckets as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( buckets ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . nentries as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( nentries ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . shift as * const _
                    as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( shift ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . keyHash as * const
                    _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( keyHash ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . keyCompare as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( keyCompare ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . valueCompare as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( valueCompare ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . allocOps as * const
                    _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( allocOps ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashTable ) ) . allocPriv as *
                    const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashTable ) ,
                    "::" , stringify ! ( allocPriv ) ));
    }
    impl Clone for PLHashTable {
        fn clone(&self) -> Self { *self }
    }
    pub type PLHashNumber = root::PRUint32;
    pub type PLHashFunction =
        ::std::option::Option<unsafe extern "C" fn(key:
                                                       *const ::std::os::raw::c_void)
                                  -> ::std::os::raw::c_uint>;
    pub type PLHashComparator =
        ::std::option::Option<unsafe extern "C" fn(v1:
                                                       *const ::std::os::raw::c_void,
                                                   v2:
                                                       *const ::std::os::raw::c_void)
                                  -> ::std::os::raw::c_int>;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLHashAllocOps {
        pub allocTable: ::std::option::Option<unsafe extern "C" fn(pool:
                                                                       *mut ::std::os::raw::c_void,
                                                                   size:
                                                                       root::PRSize)
                                                  ->
                                                      *mut ::std::os::raw::c_void>,
        pub freeTable: ::std::option::Option<unsafe extern "C" fn(pool:
                                                                      *mut ::std::os::raw::c_void,
                                                                  item:
                                                                      *mut ::std::os::raw::c_void)>,
        pub allocEntry: ::std::option::Option<unsafe extern "C" fn(pool:
                                                                       *mut ::std::os::raw::c_void,
                                                                   key:
                                                                       *const ::std::os::raw::c_void)
                                                  -> *mut root::PLHashEntry>,
        pub freeEntry: ::std::option::Option<unsafe extern "C" fn(pool:
                                                                      *mut ::std::os::raw::c_void,
                                                                  he:
                                                                      *mut root::PLHashEntry,
                                                                  flag:
                                                                      root::PRUintn)>,
    }
    #[test]
    fn bindgen_test_layout_PLHashAllocOps() {
        assert_eq!(::std::mem::size_of::<PLHashAllocOps>() , 32usize , concat
                   ! ( "Size of: " , stringify ! ( PLHashAllocOps ) ));
        assert_eq! (::std::mem::align_of::<PLHashAllocOps>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( PLHashAllocOps ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashAllocOps ) ) . allocTable as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashAllocOps ) ,
                    "::" , stringify ! ( allocTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashAllocOps ) ) . freeTable as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashAllocOps ) ,
                    "::" , stringify ! ( freeTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashAllocOps ) ) . allocEntry as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashAllocOps ) ,
                    "::" , stringify ! ( allocEntry ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLHashAllocOps ) ) . freeEntry as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLHashAllocOps ) ,
                    "::" , stringify ! ( freeEntry ) ));
    }
    impl Clone for PLHashAllocOps {
        fn clone(&self) -> Self { *self }
    }
    pub type PRTime = i64;
    /**
 * A "unique identifier". This is modeled after OSF DCE UUIDs.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsID {
        pub m0: u32,
        pub m1: u16,
        pub m2: u16,
        pub m3: [u8; 8usize],
    }
    #[test]
    fn bindgen_test_layout_nsID() {
        assert_eq!(::std::mem::size_of::<nsID>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsID ) ));
        assert_eq! (::std::mem::align_of::<nsID>() , 4usize , concat ! (
                    "Alignment of " , stringify ! ( nsID ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsID ) ) . m0 as * const _ as usize }
                    , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsID ) , "::" ,
                    stringify ! ( m0 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsID ) ) . m1 as * const _ as usize }
                    , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsID ) , "::" ,
                    stringify ! ( m1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsID ) ) . m2 as * const _ as usize }
                    , 6usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsID ) , "::" ,
                    stringify ! ( m2 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsID ) ) . m3 as * const _ as usize }
                    , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsID ) , "::" ,
                    stringify ! ( m3 ) ));
    }
    impl Clone for nsID {
        fn clone(&self) -> Self { *self }
    }
    pub type nsCID = root::nsID;
    /**
 * An "interface id" which can be used to uniquely identify a given
 * interface.
 */
    pub type nsIID = root::nsID;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsAutoRefCnt {
        pub mValue: root::nsrefcnt,
    }
    pub const nsAutoRefCnt_isThreadSafe: bool = false;
    #[test]
    fn bindgen_test_layout_nsAutoRefCnt() {
        assert_eq!(::std::mem::size_of::<nsAutoRefCnt>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsAutoRefCnt ) ));
        assert_eq! (::std::mem::align_of::<nsAutoRefCnt>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsAutoRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAutoRefCnt ) ) . mValue as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAutoRefCnt ) ,
                    "::" , stringify ! ( mValue ) ));
    }
    impl Clone for nsAutoRefCnt {
        fn clone(&self) -> Self { *self }
    }
    pub type nsIntRegion = root::mozilla::gfx::IntRegion;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsRegion {
        pub mImpl: root::pixman_region32_t,
    }
    pub type nsRegion_RectType = root::nsRect;
    pub type nsRegion_PointType = root::nsPoint;
    pub type nsRegion_MarginType = root::nsMargin;
    /**
   * VisitEdges is a weird kind of function that we use for padding
   * out surfaces to prevent texture filtering artifacts.
   * It calls the visitFn callback for each of the exterior edges of
   * the regions. The top and bottom edges will be expanded 1 pixel
   * to the left and right if there's an outside corner. The order
   * the edges are visited is not guaranteed.
   *
   * visitFn has a side parameter that can be TOP,BOTTOM,LEFT,RIGHT
   * and specifies which kind of edge is being visited. x1, y1, x2, y2
   * are the coordinates of the line. (x1 == x2) || (y1 == y2)
   */
    pub type nsRegion_visitFn =
        ::std::option::Option<unsafe extern "C" fn(closure:
                                                       *mut ::std::os::raw::c_void,
                                                   side: root::VisitSide,
                                                   x1: ::std::os::raw::c_int,
                                                   y1: ::std::os::raw::c_int,
                                                   x2: ::std::os::raw::c_int,
                                                   y2:
                                                       ::std::os::raw::c_int)>;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsRegion_RectIterator {
        pub mCurrent: ::std::os::raw::c_int,
        pub mLimit: ::std::os::raw::c_int,
        pub mTmp: root::nsRect,
        pub mBoxes: *mut root::pixman_box32_t,
    }
    #[test]
    fn bindgen_test_layout_nsRegion_RectIterator() {
        assert_eq!(::std::mem::size_of::<nsRegion_RectIterator>() , 32usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsRegion_RectIterator ) ));
        assert_eq! (::std::mem::align_of::<nsRegion_RectIterator>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsRegion_RectIterator )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRegion_RectIterator ) ) . mCurrent
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsRegion_RectIterator ) , "::" , stringify ! ( mCurrent )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRegion_RectIterator ) ) . mLimit as
                    * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsRegion_RectIterator ) , "::" , stringify ! ( mLimit )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRegion_RectIterator ) ) . mTmp as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsRegion_RectIterator ) , "::" , stringify ! ( mTmp ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRegion_RectIterator ) ) . mBoxes as
                    * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsRegion_RectIterator ) , "::" , stringify ! ( mBoxes )
                    ));
    }
    impl Clone for nsRegion_RectIterator {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsRegion() {
        assert_eq!(::std::mem::size_of::<nsRegion>() , 24usize , concat ! (
                   "Size of: " , stringify ! ( nsRegion ) ));
        assert_eq! (::std::mem::align_of::<nsRegion>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsRegion ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRegion ) ) . mImpl as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsRegion ) , "::" ,
                    stringify ! ( mImpl ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTArrayHeader {
        pub mLength: u32,
        pub _bitfield_1: u32,
    }
    extern "C" {
        #[link_name = "_ZN14nsTArrayHeader9sEmptyHdrE"]
        pub static mut nsTArrayHeader_sEmptyHdr: root::nsTArrayHeader;
    }
    #[test]
    fn bindgen_test_layout_nsTArrayHeader() {
        assert_eq!(::std::mem::size_of::<nsTArrayHeader>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( nsTArrayHeader ) ));
        assert_eq! (::std::mem::align_of::<nsTArrayHeader>() , 4usize , concat
                    ! ( "Alignment of " , stringify ! ( nsTArrayHeader ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsTArrayHeader ) ) . mLength as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsTArrayHeader ) ,
                    "::" , stringify ! ( mLength ) ));
    }
    impl Clone for nsTArrayHeader {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCOMPtr<T> {
        pub _base: root::nsCOMPtr_base,
        pub _phantom_0: ::std::marker::PhantomData<T>,
    }
    pub type nsCOMPtr_element_type<T> = T;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsQueryInterface {
        pub mRawPtr: *mut root::nsISupports,
    }
    #[test]
    fn bindgen_test_layout_nsQueryInterface() {
        assert_eq!(::std::mem::size_of::<nsQueryInterface>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsQueryInterface ) ));
        assert_eq! (::std::mem::align_of::<nsQueryInterface>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsQueryInterface ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsQueryInterface ) ) . mRawPtr as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsQueryInterface )
                    , "::" , stringify ! ( mRawPtr ) ));
    }
    impl Clone for nsQueryInterface {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsQueryInterfaceWithError {
        pub mRawPtr: *mut root::nsISupports,
        pub mErrorPtr: *mut root::nsresult,
    }
    #[test]
    fn bindgen_test_layout_nsQueryInterfaceWithError() {
        assert_eq!(::std::mem::size_of::<nsQueryInterfaceWithError>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( nsQueryInterfaceWithError ) ));
        assert_eq! (::std::mem::align_of::<nsQueryInterfaceWithError>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsQueryInterfaceWithError
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsQueryInterfaceWithError ) ) .
                    mRawPtr as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsQueryInterfaceWithError ) , "::" , stringify ! ( mRawPtr
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsQueryInterfaceWithError ) ) .
                    mErrorPtr as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsQueryInterfaceWithError ) , "::" , stringify ! (
                    mErrorPtr ) ));
    }
    impl Clone for nsQueryInterfaceWithError {
        fn clone(&self) -> Self { *self }
    }
    ////////////////////////////////////////////////////////////////////////////
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsGetServiceByCID {
        pub mCID: *const root::nsCID,
        pub __bindgen_align: [u64; 0usize],
    }
    #[test]
    fn bindgen_test_layout_nsGetServiceByCID() {
        assert_eq!(::std::mem::size_of::<nsGetServiceByCID>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsGetServiceByCID )
                   ));
        assert_eq! (::std::mem::align_of::<nsGetServiceByCID>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsGetServiceByCID ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsGetServiceByCID ) ) . mCID as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsGetServiceByCID )
                    , "::" , stringify ! ( mCID ) ));
    }
    impl Clone for nsGetServiceByCID {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsGetServiceByCIDWithError {
        pub mCID: *const root::nsCID,
        pub mErrorPtr: *mut root::nsresult,
    }
    #[test]
    fn bindgen_test_layout_nsGetServiceByCIDWithError() {
        assert_eq!(::std::mem::size_of::<nsGetServiceByCIDWithError>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( nsGetServiceByCIDWithError )
                   ));
        assert_eq! (::std::mem::align_of::<nsGetServiceByCIDWithError>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsGetServiceByCIDWithError
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsGetServiceByCIDWithError ) ) . mCID
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsGetServiceByCIDWithError ) , "::" , stringify ! ( mCID )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsGetServiceByCIDWithError ) ) .
                    mErrorPtr as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsGetServiceByCIDWithError ) , "::" , stringify ! (
                    mErrorPtr ) ));
    }
    impl Clone for nsGetServiceByCIDWithError {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsGetServiceByContractID {
        pub mContractID: *const ::std::os::raw::c_char,
    }
    #[test]
    fn bindgen_test_layout_nsGetServiceByContractID() {
        assert_eq!(::std::mem::size_of::<nsGetServiceByContractID>() , 8usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsGetServiceByContractID ) ));
        assert_eq! (::std::mem::align_of::<nsGetServiceByContractID>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsGetServiceByContractID )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsGetServiceByContractID ) ) .
                    mContractID as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsGetServiceByContractID ) , "::" , stringify ! (
                    mContractID ) ));
    }
    impl Clone for nsGetServiceByContractID {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsGetServiceByContractIDWithError {
        pub mContractID: *const ::std::os::raw::c_char,
        pub mErrorPtr: *mut root::nsresult,
    }
    #[test]
    fn bindgen_test_layout_nsGetServiceByContractIDWithError() {
        assert_eq!(::std::mem::size_of::<nsGetServiceByContractIDWithError>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsGetServiceByContractIDWithError ) ));
        assert_eq! (::std::mem::align_of::<nsGetServiceByContractIDWithError>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsGetServiceByContractIDWithError ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsGetServiceByContractIDWithError ) )
                    . mContractID as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsGetServiceByContractIDWithError ) , "::" , stringify ! (
                    mContractID ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsGetServiceByContractIDWithError ) )
                    . mErrorPtr as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsGetServiceByContractIDWithError ) , "::" , stringify ! (
                    mErrorPtr ) ));
    }
    impl Clone for nsGetServiceByContractIDWithError {
        fn clone(&self) -> Self { *self }
    }
    /**
 * Factors implementation for all template versions of nsCOMPtr.
 *
 * Here's the way people normally do things like this:
 *
 *   template<class T> class Foo { ... };
 *   template<> class Foo<void*> { ... };
 *   template<class T> class Foo<T*> : private Foo<void*> { ... };
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCOMPtr_base {
        pub mRawPtr: *mut root::nsISupports,
    }
    #[test]
    fn bindgen_test_layout_nsCOMPtr_base() {
        assert_eq!(::std::mem::size_of::<nsCOMPtr_base>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( nsCOMPtr_base ) ));
        assert_eq! (::std::mem::align_of::<nsCOMPtr_base>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsCOMPtr_base ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCOMPtr_base ) ) . mRawPtr as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCOMPtr_base ) ,
                    "::" , stringify ! ( mRawPtr ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_4() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsISupports>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsISupports> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsISupports>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsISupports> ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAutoPtr<T> {
        pub mRawPtr: *mut T,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsAutoPtr_Ptr<T> {
        pub mPtr: *mut T,
    }
    pub type nsAutoPtr_element_type<T> = T;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsAutoPtr_Proxy<T, R, Args> {
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<R>,
        pub _phantom_2: ::std::marker::PhantomData<Args>,
    }
    pub type nsAutoPtr_Proxy_member_function = [u8; 0usize];
    /**
 * This structure precedes the string buffers "we" allocate.  It may be the
 * case that nsTAString::mData does not point to one of these special
 * buffers.  The mFlags member variable distinguishes the buffer type.
 *
 * When this header is in use, it enables reference counting, and capacity
 * tracking.  NOTE: A string buffer can be modified only if its reference
 * count is 1.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStringBuffer {
        pub mRefCount: u32,
        pub mStorageSize: u32,
    }
    #[test]
    fn bindgen_test_layout_nsStringBuffer() {
        assert_eq!(::std::mem::size_of::<nsStringBuffer>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( nsStringBuffer ) ));
        assert_eq! (::std::mem::align_of::<nsStringBuffer>() , 4usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStringBuffer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStringBuffer ) ) . mRefCount as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStringBuffer ) ,
                    "::" , stringify ! ( mRefCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStringBuffer ) ) . mStorageSize as
                    * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStringBuffer ) ,
                    "::" , stringify ! ( mStorageSize ) ));
    }
    impl Clone for nsStringBuffer {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIAtom {
        pub _base: root::nsISupports,
        pub _bitfield_1: u32,
        pub mHash: u32,
        /**
   * WARNING! There is an invisible constraint on |mString|: the chars it
   * points to must belong to an nsStringBuffer. This is so that the
   * nsStringBuffer::FromData() calls above are valid.
   */
        pub mString: *mut u16,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIAtom_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIAtom() {
        assert_eq!(::std::mem::size_of::<nsIAtom>() , 24usize , concat ! (
                   "Size of: " , stringify ! ( nsIAtom ) ));
        assert_eq! (::std::mem::align_of::<nsIAtom>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIAtom ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIAtom ) ) . mHash as * const _ as
                    usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIAtom ) , "::" ,
                    stringify ! ( mHash ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIAtom ) ) . mString as * const _ as
                    usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIAtom ) , "::" ,
                    stringify ! ( mString ) ));
    }
    impl Clone for nsIAtom {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIPrincipal {
        pub _base: root::nsISerializable,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIPrincipal_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const nsIPrincipal_APP_STATUS_NOT_INSTALLED:
              root::nsIPrincipal__bindgen_ty_1 =
        nsIPrincipal__bindgen_ty_1::APP_STATUS_NOT_INSTALLED;
    pub const nsIPrincipal_APP_STATUS_INSTALLED:
              root::nsIPrincipal__bindgen_ty_1 =
        nsIPrincipal__bindgen_ty_1::APP_STATUS_INSTALLED;
    pub const nsIPrincipal_APP_STATUS_PRIVILEGED:
              root::nsIPrincipal__bindgen_ty_1 =
        nsIPrincipal__bindgen_ty_1::APP_STATUS_PRIVILEGED;
    pub const nsIPrincipal_APP_STATUS_CERTIFIED:
              root::nsIPrincipal__bindgen_ty_1 =
        nsIPrincipal__bindgen_ty_1::APP_STATUS_CERTIFIED;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPrincipal__bindgen_ty_1 {
        APP_STATUS_NOT_INSTALLED = 0,
        APP_STATUS_INSTALLED = 1,
        APP_STATUS_PRIVILEGED = 2,
        APP_STATUS_CERTIFIED = 3,
    }
    #[test]
    fn bindgen_test_layout_nsIPrincipal() {
        assert_eq!(::std::mem::size_of::<nsIPrincipal>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIPrincipal ) ));
        assert_eq! (::std::mem::align_of::<nsIPrincipal>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsIPrincipal ) ));
    }
    impl Clone for nsIPrincipal {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    pub struct nsWrapperCache__bindgen_vtable {
    }
    /**
 * Class to store the wrapper for an object. This can only be used with objects
 * that only have one non-security wrapper at a time (for an XPCWrappedNative
 * this is usually ensured by setting an explicit parent in the PreCreate hook
 * for the class).
 *
 * An instance of nsWrapperCache can be gotten from an object that implements
 * a wrapper cache by calling QueryInterface on it. Note that this breaks XPCOM
 * rules a bit (this object doesn't derive from nsISupports).
 *
 * The cache can store objects other than wrappers. We allow wrappers to use a
 * separate JSObject to store their state (mostly expandos). If the wrapper is
 * collected and we want to preserve this state we actually store the state
 * object in the cache.
 *
 * The cache can store 2 types of objects:
 *
 *  If WRAPPER_IS_NOT_DOM_BINDING is set (IsDOMBinding() returns false):
 *    - the JSObject of an XPCWrappedNative wrapper
 *
 *  If WRAPPER_IS_NOT_DOM_BINDING is not set (IsDOMBinding() returns true):
 *    - a DOM binding object (regular JS object or proxy)
 *
 * The finalizer for the wrapper clears the cache.
 *
 * A compacting GC can move the wrapper object. Pointers to moved objects are
 * usually found and updated by tracing the heap, however non-preserved wrappers
 * are weak references and are not traced, so another approach is
 * necessary. Instead a class hook (objectMovedOp) is provided that is called
 * when an object is moved and is responsible for ensuring pointers are
 * updated. It does this by calling UpdateWrapper() on the wrapper
 * cache. SetWrapper() asserts that the hook is implemented for any wrapper set.
 *
 * A number of the methods are implemented in nsWrapperCacheInlines.h because we
 * have to include some JS headers that don't play nicely with the rest of the
 * codebase. Include nsWrapperCacheInlines.h if you need to call those methods.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsWrapperCache {
        pub vtable_: *const nsWrapperCache__bindgen_vtable,
        pub mWrapper: *mut root::JSObject,
        pub mFlags: root::nsWrapperCache_FlagsType,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsWrapperCache_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub type nsWrapperCache_FlagsType = u32;
    pub const nsWrapperCache_WRAPPER_BIT_PRESERVED:
              root::nsWrapperCache__bindgen_ty_1 =
        nsWrapperCache__bindgen_ty_1::WRAPPER_BIT_PRESERVED;
    #[repr(u32)]
    /**
   * If this bit is set then we're preserving the wrapper, which in effect ties
   * the lifetime of the JS object stored in the cache to the lifetime of the
   * native object. We rely on the cycle collector to break the cycle that this
   * causes between the native object and the JS object, so it is important that
   * any native object that supports preserving of its wrapper
   * traces/traverses/unlinks the cached JS object (see
   * NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER and
   * NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER).
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsWrapperCache__bindgen_ty_1 { WRAPPER_BIT_PRESERVED = 1, }
    pub const nsWrapperCache_WRAPPER_IS_NOT_DOM_BINDING:
              root::nsWrapperCache__bindgen_ty_2 =
        nsWrapperCache__bindgen_ty_2::WRAPPER_IS_NOT_DOM_BINDING;
    #[repr(u32)]
    /**
   * If this bit is set then the wrapper for the native object is not a DOM
   * binding.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsWrapperCache__bindgen_ty_2 { WRAPPER_IS_NOT_DOM_BINDING = 2, }
    pub const nsWrapperCache_kWrapperFlagsMask:
              root::nsWrapperCache__bindgen_ty_3 =
        nsWrapperCache__bindgen_ty_3::kWrapperFlagsMask;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsWrapperCache__bindgen_ty_3 { kWrapperFlagsMask = 3, }
    #[test]
    fn bindgen_test_layout_nsWrapperCache() {
        assert_eq!(::std::mem::size_of::<nsWrapperCache>() , 24usize , concat
                   ! ( "Size of: " , stringify ! ( nsWrapperCache ) ));
        assert_eq! (::std::mem::align_of::<nsWrapperCache>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsWrapperCache ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsWrapperCache ) ) . mWrapper as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsWrapperCache ) ,
                    "::" , stringify ! ( mWrapper ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsWrapperCache ) ) . mFlags as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsWrapperCache ) ,
                    "::" , stringify ! ( mFlags ) ));
    }
    #[repr(C)]
    pub struct TraceCallbacks__bindgen_vtable {
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct TraceCallbacks {
        pub vtable_: *const TraceCallbacks__bindgen_vtable,
    }
    #[test]
    fn bindgen_test_layout_TraceCallbacks() {
        assert_eq!(::std::mem::size_of::<TraceCallbacks>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( TraceCallbacks ) ));
        assert_eq! (::std::mem::align_of::<TraceCallbacks>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( TraceCallbacks ) ));
    }
    impl Clone for TraceCallbacks {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsScriptObjectTracer {
        pub _base: root::nsCycleCollectionParticipant,
    }
    #[test]
    fn bindgen_test_layout_nsScriptObjectTracer() {
        assert_eq!(::std::mem::size_of::<nsScriptObjectTracer>() , 16usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsScriptObjectTracer ) ));
        assert_eq! (::std::mem::align_of::<nsScriptObjectTracer>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsScriptObjectTracer ) ));
    }
    impl Clone for nsScriptObjectTracer {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsXPCOMCycleCollectionParticipant {
        pub _base: root::nsScriptObjectTracer,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsXPCOMCycleCollectionParticipant_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsXPCOMCycleCollectionParticipant() {
        assert_eq!(::std::mem::size_of::<nsXPCOMCycleCollectionParticipant>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsXPCOMCycleCollectionParticipant ) ));
        assert_eq! (::std::mem::align_of::<nsXPCOMCycleCollectionParticipant>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsXPCOMCycleCollectionParticipant ) ));
    }
    impl Clone for nsXPCOMCycleCollectionParticipant {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct JSErrorFormatString {
        /** The error message name in ASCII. */
        pub name: *const ::std::os::raw::c_char,
        /** The error format string in ASCII. */
        pub format: *const ::std::os::raw::c_char,
        /** The number of arguments to expand in the formatted error message. */
        pub argCount: u16,
        /** One of the JSExnType constants above. */
        pub exnType: i16,
    }
    #[test]
    fn bindgen_test_layout_JSErrorFormatString() {
        assert_eq!(::std::mem::size_of::<JSErrorFormatString>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( JSErrorFormatString ) ));
        assert_eq! (::std::mem::align_of::<JSErrorFormatString>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( JSErrorFormatString ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorFormatString ) ) . name as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorFormatString
                    ) , "::" , stringify ! ( name ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorFormatString ) ) . format as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorFormatString
                    ) , "::" , stringify ! ( format ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorFormatString ) ) . argCount as
                    * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorFormatString
                    ) , "::" , stringify ! ( argCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorFormatString ) ) . exnType as
                    * const _ as usize } , 18usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorFormatString
                    ) , "::" , stringify ! ( exnType ) ));
    }
    impl Clone for JSErrorFormatString {
        fn clone(&self) -> Self { *self }
    }
    pub type JSErrorCallback =
        ::std::option::Option<unsafe extern "C" fn(userRef:
                                                       *mut ::std::os::raw::c_void,
                                                   errorNumber:
                                                       ::std::os::raw::c_uint)
                                  -> *const root::JSErrorFormatString>;
    /**
 * Base class that implements parts shared by JSErrorReport and
 * JSErrorNotes::Note.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSErrorBase {
        pub message_: root::JS::ConstUTF8CharsZ,
        pub filename: *const ::std::os::raw::c_char,
        pub lineno: ::std::os::raw::c_uint,
        pub column: ::std::os::raw::c_uint,
        pub errorNumber: ::std::os::raw::c_uint,
        pub _bitfield_1: u8,
        pub __bindgen_padding_0: [u8; 3usize],
    }
    #[test]
    fn bindgen_test_layout_JSErrorBase() {
        assert_eq!(::std::mem::size_of::<JSErrorBase>() , 32usize , concat ! (
                   "Size of: " , stringify ! ( JSErrorBase ) ));
        assert_eq! (::std::mem::align_of::<JSErrorBase>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( JSErrorBase ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorBase ) ) . message_ as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorBase ) ,
                    "::" , stringify ! ( message_ ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorBase ) ) . filename as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorBase ) ,
                    "::" , stringify ! ( filename ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorBase ) ) . lineno as * const _
                    as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorBase ) ,
                    "::" , stringify ! ( lineno ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorBase ) ) . column as * const _
                    as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorBase ) ,
                    "::" , stringify ! ( column ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorBase ) ) . errorNumber as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorBase ) ,
                    "::" , stringify ! ( errorNumber ) ));
    }
    /**
 * Notes associated with JSErrorReport.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSErrorNotes {
        pub notes_: [u64; 4usize],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSErrorNotes_Note {
        pub _base: root::JSErrorBase,
    }
    #[test]
    fn bindgen_test_layout_JSErrorNotes_Note() {
        assert_eq!(::std::mem::size_of::<JSErrorNotes_Note>() , 32usize ,
                   concat ! ( "Size of: " , stringify ! ( JSErrorNotes_Note )
                   ));
        assert_eq! (::std::mem::align_of::<JSErrorNotes_Note>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( JSErrorNotes_Note ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSErrorNotes_iterator {
        pub note_: *mut root::mozilla::UniquePtr<root::JSErrorNotes_Note,
                                                 root::JS::DeletePolicy<root::JSErrorNotes_Note>>,
    }
    #[test]
    fn bindgen_test_layout_JSErrorNotes_iterator() {
        assert_eq!(::std::mem::size_of::<JSErrorNotes_iterator>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( JSErrorNotes_iterator ) ));
        assert_eq! (::std::mem::align_of::<JSErrorNotes_iterator>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( JSErrorNotes_iterator )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorNotes_iterator ) ) . note_ as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    JSErrorNotes_iterator ) , "::" , stringify ! ( note_ ) ));
    }
    #[test]
    fn bindgen_test_layout_JSErrorNotes() {
        assert_eq!(::std::mem::size_of::<JSErrorNotes>() , 32usize , concat !
                   ( "Size of: " , stringify ! ( JSErrorNotes ) ));
        assert_eq! (::std::mem::align_of::<JSErrorNotes>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( JSErrorNotes ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const JSErrorNotes ) ) . notes_ as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( JSErrorNotes ) ,
                    "::" , stringify ! ( notes_ ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIEventTarget {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIEventTarget_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const nsIEventTarget_DISPATCH_NORMAL:
              root::nsIEventTarget__bindgen_ty_1 =
        nsIEventTarget__bindgen_ty_1::DISPATCH_NORMAL;
    pub const nsIEventTarget_DISPATCH_SYNC: root::nsIEventTarget__bindgen_ty_1
              =
        nsIEventTarget__bindgen_ty_1::DISPATCH_SYNC;
    pub const nsIEventTarget_DISPATCH_AT_END:
              root::nsIEventTarget__bindgen_ty_1 =
        nsIEventTarget__bindgen_ty_1::DISPATCH_AT_END;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIEventTarget__bindgen_ty_1 {
        DISPATCH_NORMAL = 0,
        DISPATCH_SYNC = 1,
        DISPATCH_AT_END = 2,
    }
    #[test]
    fn bindgen_test_layout_nsIEventTarget() {
        assert_eq!(::std::mem::size_of::<nsIEventTarget>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( nsIEventTarget ) ));
        assert_eq! (::std::mem::align_of::<nsIEventTarget>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsIEventTarget ) ));
    }
    impl Clone for nsIEventTarget {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIRunnable {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIRunnable_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIRunnable() {
        assert_eq!(::std::mem::size_of::<nsIRunnable>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIRunnable ) ));
        assert_eq! (::std::mem::align_of::<nsIRunnable>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsIRunnable ) ));
    }
    impl Clone for nsIRunnable {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIGlobalObject {
        pub _base: root::nsISupports,
        pub _base_1: root::mozilla::dom::DispatcherTrait,
        pub mHostObjectURIs: root::nsTArray<root::nsCString>,
        pub mIsDying: bool,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIGlobalObject_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIGlobalObject() {
        assert_eq!(::std::mem::size_of::<nsIGlobalObject>() , 32usize , concat
                   ! ( "Size of: " , stringify ! ( nsIGlobalObject ) ));
        assert_eq! (::std::mem::align_of::<nsIGlobalObject>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIGlobalObject ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIObjectInputStream([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIObjectOutputStream([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsISerializable {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISerializable_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsISerializable() {
        assert_eq!(::std::mem::size_of::<nsISerializable>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsISerializable ) ));
        assert_eq! (::std::mem::align_of::<nsISerializable>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsISerializable ) ));
    }
    impl Clone for nsISerializable {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIURI {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIURI_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIURI() {
        assert_eq!(::std::mem::size_of::<nsIURI>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIURI ) ));
        assert_eq! (::std::mem::align_of::<nsIURI>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIURI ) ));
    }
    impl Clone for nsIURI {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIContentSecurityPolicy([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMDocument([u8; 0]);
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPIDOMWindowInner {
        pub _base: [u64; 28usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsPIDOMWindowInner_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsPIDOMWindowInner() {
        assert_eq!(::std::mem::size_of::<nsPIDOMWindowInner>() , 224usize ,
                   concat ! ( "Size of: " , stringify ! ( nsPIDOMWindowInner )
                   ));
        assert_eq! (::std::mem::align_of::<nsPIDOMWindowInner>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsPIDOMWindowInner ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsGlobalWindow([u8; 0]);
    /**
 * It is used by the application to initialize a runtime and run scripts.
 * A script runtime would implement this interface.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIScriptContext {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIScriptContext_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIScriptContext() {
        assert_eq!(::std::mem::size_of::<nsIScriptContext>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsIScriptContext ) ));
        assert_eq! (::std::mem::align_of::<nsIScriptContext>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIScriptContext ) ));
    }
    impl Clone for nsIScriptContext {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIDocument {
        pub _base: root::nsINode,
        pub _base_1: root::mozilla::dom::DispatcherTrait,
        pub mDeprecationWarnedAbout: u64,
        pub mDocWarningWarnedAbout: u64,
        pub mSelectorCache: root::nsIDocument_SelectorCache,
        pub mReferrer: root::nsCString,
        pub mLastModified: ::nsstring::nsStringRepr,
        pub mDocumentURI: root::nsCOMPtr<root::nsIURI>,
        pub mOriginalURI: root::nsCOMPtr<root::nsIURI>,
        pub mChromeXHRDocURI: root::nsCOMPtr<root::nsIURI>,
        pub mDocumentBaseURI: root::nsCOMPtr<root::nsIURI>,
        pub mChromeXHRDocBaseURI: root::nsCOMPtr<root::nsIURI>,
        pub mDocumentLoadGroup: root::nsWeakPtr,
        pub mReferrerPolicySet: bool,
        pub mReferrerPolicy: root::nsIDocument_ReferrerPolicyEnum,
        pub mBlockAllMixedContent: bool,
        pub mBlockAllMixedContentPreloads: bool,
        pub mUpgradeInsecureRequests: bool,
        pub mUpgradeInsecurePreloads: bool,
        pub mHSTSPrimingURIList: [u64; 5usize],
        pub mDocumentContainer: u64,
        pub mCharacterSet: root::nsCString,
        pub mCharacterSetSource: i32,
        pub mParentDocument: *mut root::nsIDocument,
        pub mCachedRootElement: *mut root::mozilla::dom::Element,
        pub mNodeInfoManager: *mut root::nsNodeInfoManager,
        pub mCSSLoader: root::RefPtr<root::mozilla::css::Loader>,
        pub mStyleImageLoader: root::RefPtr<root::mozilla::css::ImageLoader>,
        pub mAttrStyleSheet: root::RefPtr<root::nsHTMLStyleSheet>,
        pub mStyleAttrStyleSheet: root::RefPtr<root::nsHTMLCSSStyleSheet>,
        pub mSVGAttrAnimationRuleProcessor: root::RefPtr<root::mozilla::SVGAttrAnimationRuleProcessor>,
        pub mImageTracker: root::RefPtr<root::mozilla::dom::ImageTracker>,
        pub mActivityObservers: root::nsAutoPtr<()>,
        pub mLinksToUpdate: [u64; 5usize],
        pub mAnimationController: root::RefPtr<root::nsSMILAnimationController>,
        pub mPropertyTable: root::nsPropertyTable,
        pub mExtraPropertyTables: root::nsTArray<root::nsAutoPtr<root::nsPropertyTable>>,
        pub mChildrenCollection: root::nsCOMPtr<root::nsIHTMLCollection>,
        pub mFontFaceSet: root::RefPtr<root::mozilla::dom::FontFaceSet>,
        pub _bitfield_1: u8,
        pub _bitfield_2: u8,
        pub _bitfield_3: u8,
        pub _bitfield_4: u8,
        pub _bitfield_5: u8,
        pub _bitfield_6: u8,
        pub mCompatMode: root::nsCompatibility,
        pub mReadyState: root::nsIDocument_ReadyState,
        pub mStyleBackendType: root::mozilla::StyleBackendType,
        pub mVisibilityState: root::mozilla::dom::VisibilityState,
        pub mType: root::nsIDocument_Type,
        pub mDefaultElementType: u8,
        pub mAllowXULXBL: root::nsIDocument_Tri,
        pub mScriptGlobalObject: root::nsCOMPtr<root::nsIScriptGlobalObject>,
        pub mOriginalDocument: root::nsCOMPtr<root::nsIDocument>,
        pub mBidiOptions: u32,
        pub mSandboxFlags: u32,
        pub mContentLanguage: root::nsCString,
        pub mChannel: root::nsCOMPtr<root::nsIChannel>,
        pub mContentType: root::nsCString,
        pub mId: ::nsstring::nsStringRepr,
        pub mSecurityInfo: root::nsCOMPtr<root::nsISupports>,
        pub mFailedChannel: root::nsCOMPtr<root::nsIChannel>,
        pub mPartID: u32,
        pub mMarkedCCGeneration: u32,
        pub mPresShell: *mut root::nsIPresShell,
        pub mSubtreeModifiedTargets: root::nsCOMArray<root::nsINode>,
        pub mSubtreeModifiedDepth: u32,
        pub mDisplayDocument: root::nsCOMPtr<root::nsIDocument>,
        pub mEventsSuppressed: u32,
        /**
   * The number number of external scripts (ones with the src attribute) that
   * have this document as their owner and that are being evaluated right now.
   */
        pub mExternalScriptsBeingEvaluated: u32,
        /**
   * The current frame request callback handle
   */
        pub mFrameRequestCallbackCounter: i32,
        pub mStaticCloneCount: u32,
        pub mBlockedTrackingNodes: root::nsTArray<root::nsCOMPtr<root::nsIWeakReference>>,
        pub mWindow: *mut root::nsPIDOMWindowInner,
        pub mCachedEncoder: root::nsCOMPtr<root::nsIDocumentEncoder>,
        pub mFrameRequestCallbacks: root::nsTArray<root::nsIDocument_FrameRequest>,
        pub mBFCacheEntry: *mut root::nsIBFCacheEntry,
        pub mBaseTarget: ::nsstring::nsStringRepr,
        pub mStateObjectContainer: root::nsCOMPtr<root::nsIStructuredCloneContainer>,
        pub mStateObjectCached: root::nsCOMPtr<root::nsIVariant>,
        pub mInSyncOperationCount: u32,
        pub mXPathEvaluator: root::RefPtr<root::mozilla::dom::XPathEvaluator>,
        pub mAnonymousContents: root::nsTArray<root::RefPtr<root::mozilla::dom::AnonymousContent>>,
        pub mBlockDOMContentLoaded: u32,
        pub _bitfield_7: u8,
        pub mDOMMediaQueryLists: root::PRCList,
        pub mUseCounters: [u64; 2usize],
        pub mChildDocumentUseCounters: [u64; 2usize],
        pub mNotifiedPageForUseCounter: [u64; 2usize],
        pub mUserHasInteracted: bool,
        pub mPageUnloadingEventTimeStamp: root::mozilla::TimeStamp,
        pub mDocGroup: root::RefPtr<root::mozilla::dom::DocGroup>,
        pub mTrackingScripts: [u64; 5usize],
    }
    pub type nsIDocument_GlobalObject = root::mozilla::dom::GlobalObject;
    pub use self::super::root::mozilla::net::ReferrerPolicy as
            nsIDocument_ReferrerPolicyEnum;
    pub type nsIDocument_Element = root::mozilla::dom::Element;
    pub type nsIDocument_FullscreenRequest =
        root::mozilla::dom::FullscreenRequest;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDocument_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIDocument_PageUnloadingEventTimeStamp {
        pub mDocument: root::nsCOMPtr<root::nsIDocument>,
        pub mSet: bool,
    }
    #[test]
    fn bindgen_test_layout_nsIDocument_PageUnloadingEventTimeStamp() {
        assert_eq!(::std::mem::size_of::<nsIDocument_PageUnloadingEventTimeStamp>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsIDocument_PageUnloadingEventTimeStamp ) ));
        assert_eq! (::std::mem::align_of::<nsIDocument_PageUnloadingEventTimeStamp>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsIDocument_PageUnloadingEventTimeStamp ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsIDocument_PageUnloadingEventTimeStamp )
                    ) . mDocument as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsIDocument_PageUnloadingEventTimeStamp ) , "::" ,
                    stringify ! ( mDocument ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsIDocument_PageUnloadingEventTimeStamp )
                    ) . mSet as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsIDocument_PageUnloadingEventTimeStamp ) , "::" ,
                    stringify ! ( mSet ) ));
    }
    /**
   * This gets fired when the element that an id refers to changes.
   * This fires at difficult times. It is generally not safe to do anything
   * which could modify the DOM in any way. Use
   * nsContentUtils::AddScriptRunner.
   * @return true to keep the callback in the callback set, false
   * to remove it.
   */
    pub type nsIDocument_IDTargetObserver =
        ::std::option::Option<unsafe extern "C" fn(aOldElement:
                                                       *mut root::nsIDocument_Element,
                                                   aNewelement:
                                                       *mut root::nsIDocument_Element,
                                                   aData:
                                                       *mut ::std::os::raw::c_void)
                                  -> bool>;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIDocument_SelectorCacheKey {
        pub mKey: ::nsstring::nsStringRepr,
        pub mState: root::nsExpirationState,
    }
    #[test]
    fn bindgen_test_layout_nsIDocument_SelectorCacheKey() {
        assert_eq!(::std::mem::size_of::<nsIDocument_SelectorCacheKey>() ,
                   24usize , concat ! (
                   "Size of: " , stringify ! ( nsIDocument_SelectorCacheKey )
                   ));
        assert_eq! (::std::mem::align_of::<nsIDocument_SelectorCacheKey>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsIDocument_SelectorCacheKey ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIDocument_SelectorCacheKey ) ) .
                    mKey as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsIDocument_SelectorCacheKey ) , "::" , stringify ! ( mKey
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIDocument_SelectorCacheKey ) ) .
                    mState as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsIDocument_SelectorCacheKey ) , "::" , stringify ! (
                    mState ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDocument_SelectorCacheKeyDeleter([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDocument_SelectorCache {
        pub _bindgen_opaque_blob: [u64; 15usize],
    }
    #[test]
    fn bindgen_test_layout_nsIDocument_SelectorCache() {
        assert_eq!(::std::mem::size_of::<nsIDocument_SelectorCache>() ,
                   120usize , concat ! (
                   "Size of: " , stringify ! ( nsIDocument_SelectorCache ) ));
        assert_eq! (::std::mem::align_of::<nsIDocument_SelectorCache>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIDocument_SelectorCache
                    ) ));
    }
    impl Clone for nsIDocument_SelectorCache {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_additionalSheetType {
        eAgentSheet = 0,
        eUserSheet = 1,
        eAuthorSheet = 2,
        AdditionalSheetTypeCount = 3,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_ReadyState {
        READYSTATE_UNINITIALIZED = 0,
        READYSTATE_LOADING = 1,
        READYSTATE_INTERACTIVE = 3,
        READYSTATE_COMPLETE = 4,
    }
    /**
   * Enumerate all subdocuments.
   * The enumerator callback should return true to continue enumerating, or
   * false to stop.  This will never get passed a null aDocument.
   */
    pub type nsIDocument_nsSubDocEnumFunc =
        ::std::option::Option<unsafe extern "C" fn(aDocument:
                                                       *mut root::nsIDocument,
                                                   aData:
                                                       *mut ::std::os::raw::c_void)
                                  -> bool>;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_ElementsFromPointFlags {
        IGNORE_ROOT_SCROLL_FRAME = 1,
        FLUSH_LAYOUT = 2,
        IS_ELEMENT_FROM_POINT = 4,
    }
    /**
   * A class that represents an external resource load that has begun but
   * doesn't have a document yet.  Observers can be registered on this object,
   * and will be notified after the document is created.  Observers registered
   * after the document has been created will NOT be notified.  When observers
   * are notified, the subject will be the newly-created document, the topic
   * will be "external-resource-document-created", and the data will be null.
   * If document creation fails for some reason, observers will still be
   * notified, with a null document pointer.
   */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIDocument_ExternalResourceLoad {
        pub _base: root::nsISupports,
        pub mObservers: [u64; 10usize],
    }
    #[test]
    fn bindgen_test_layout_nsIDocument_ExternalResourceLoad() {
        assert_eq!(::std::mem::size_of::<nsIDocument_ExternalResourceLoad>() ,
                   88usize , concat ! (
                   "Size of: " , stringify ! (
                   nsIDocument_ExternalResourceLoad ) ));
        assert_eq! (::std::mem::align_of::<nsIDocument_ExternalResourceLoad>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsIDocument_ExternalResourceLoad ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIDocument_ExternalResourceLoad ) )
                    . mObservers as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsIDocument_ExternalResourceLoad ) , "::" , stringify ! (
                    mObservers ) ));
    }
    pub type nsIDocument_ActivityObserverEnumerator =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::nsISupports,
                                                   arg2:
                                                       *mut ::std::os::raw::c_void)>;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_DocumentTheme {
        Doc_Theme_Uninitialized = 0,
        Doc_Theme_None = 1,
        Doc_Theme_Neutral = 2,
        Doc_Theme_Dark = 3,
        Doc_Theme_Bright = 4,
    }
    pub type nsIDocument_FrameRequestCallbackList =
        root::nsTArray<root::RefPtr<root::mozilla::dom::FrameRequestCallback>>;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_DeprecatedOperations {
        eGetAttributeNode = 0,
        eSetAttributeNode = 1,
        eGetAttributeNodeNS = 2,
        eSetAttributeNodeNS = 3,
        eRemoveAttributeNode = 4,
        eCreateAttribute = 5,
        eCreateAttributeNS = 6,
        eNodeValue = 7,
        eTextContent = 8,
        eEnablePrivilege = 9,
        eDOMExceptionCode = 10,
        eNoExposedProps = 11,
        eMutationEvent = 12,
        eComponents = 13,
        ePrefixedVisibilityAPI = 14,
        eNodeIteratorDetach = 15,
        eLenientThis = 16,
        eGetPreventDefault = 17,
        eGetSetUserData = 18,
        eMozGetAsFile = 19,
        eUseOfCaptureEvents = 20,
        eUseOfReleaseEvents = 21,
        eUseOfDOM3LoadMethod = 22,
        eChromeUseOfDOM3LoadMethod = 23,
        eShowModalDialog = 24,
        eWindow_Content = 25,
        eSyncXMLHttpRequest = 26,
        eDataContainerEvent = 27,
        eWindow_Controllers = 28,
        eImportXULIntoContent = 29,
        ePannerNodeDoppler = 30,
        eNavigatorGetUserMedia = 31,
        eWebrtcDeprecatedPrefix = 32,
        eRTCPeerConnectionGetStreams = 33,
        eAppCache = 34,
        ePrefixedImageSmoothingEnabled = 35,
        ePrefixedFullscreenAPI = 36,
        eLenientSetter = 37,
        eFileLastModifiedDate = 38,
        eImageBitmapRenderingContext_TransferImageBitmap = 39,
        eURLCreateObjectURL_MediaStream = 40,
        eXMLBaseAttribute = 41,
        eDeprecatedOperationCount = 42,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_DocumentWarnings {
        eIgnoringWillChangeOverBudget = 0,
        ePreventDefaultFromPassiveListener = 1,
        eDocumentWarningCount = 2,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_ElementCallbackType {
        eCreated = 0,
        eAttached = 1,
        eDetached = 2,
        eAttributeChanged = 3,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_Type {
        eUnknown = 0,
        eHTML = 1,
        eXHTML = 2,
        eGenericXML = 3,
        eSVG = 4,
        eXUL = 5,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_Tri { eTriUnset = 0, eTriFalse = 1, eTriTrue = 2, }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDocument_FrameRequest([u8; 0]);
    #[test]
    fn bindgen_test_layout_nsIDocument() {
        assert_eq!(::std::mem::size_of::<nsIDocument>() , 984usize , concat !
                   ( "Size of: " , stringify ! ( nsIDocument ) ));
        assert_eq! (::std::mem::align_of::<nsIDocument>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsIDocument ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDocShell([u8; 0]);
    /**
 * The global object which keeps a script context for each supported script
 * language. This often used to store per-window global state.
 * This is a heavyweight interface implemented only by DOM globals, and
 * it might go away some time in the future.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIScriptGlobalObject {
        pub _base: root::nsIGlobalObject,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIScriptGlobalObject_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIScriptGlobalObject() {
        assert_eq!(::std::mem::size_of::<nsIScriptGlobalObject>() , 32usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIScriptGlobalObject ) ));
        assert_eq! (::std::mem::align_of::<nsIScriptGlobalObject>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIScriptGlobalObject )
                    ));
    }
    #[repr(u32)]
    /**
 * Return status for event processors.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsEventStatus {
        nsEventStatus_eIgnore = 0,
        nsEventStatus_eConsumeNoDefault = 1,
        nsEventStatus_eConsumeDoDefault = 2,
        nsEventStatus_eSentinel = 3,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIObserver {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIObserver_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIObserver() {
        assert_eq!(::std::mem::size_of::<nsIObserver>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIObserver ) ));
        assert_eq! (::std::mem::align_of::<nsIObserver>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsIObserver ) ));
    }
    impl Clone for nsIObserver {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIVariant {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIVariant_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIVariant() {
        assert_eq!(::std::mem::size_of::<nsIVariant>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIVariant ) ));
        assert_eq! (::std::mem::align_of::<nsIVariant>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIVariant ) ));
    }
    impl Clone for nsIVariant {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISimpleEnumerator([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsINamed {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsINamed_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsINamed() {
        assert_eq!(::std::mem::size_of::<nsINamed>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsINamed ) ));
        assert_eq! (::std::mem::align_of::<nsINamed>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsINamed ) ));
    }
    impl Clone for nsINamed {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsRevocableEventPtr<T> {
        pub mEvent: root::RefPtr<T>,
    }
    pub type DOMHighResTimeStamp = f64;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMAttr {
        pub _base: root::nsIDOMNode,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMAttr_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMAttr() {
        assert_eq!(::std::mem::size_of::<nsIDOMAttr>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIDOMAttr ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMAttr>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIDOMAttr ) ));
    }
    impl Clone for nsIDOMAttr {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMElement {
        pub _base: root::nsIDOMNode,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMElement_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMElement() {
        assert_eq!(::std::mem::size_of::<nsIDOMElement>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( nsIDOMElement ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMElement>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsIDOMElement ) ));
    }
    impl Clone for nsIDOMElement {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMNode {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMNode_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const nsIDOMNode_ELEMENT_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::ELEMENT_NODE;
    pub const nsIDOMNode_ATTRIBUTE_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::ATTRIBUTE_NODE;
    pub const nsIDOMNode_TEXT_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::TEXT_NODE;
    pub const nsIDOMNode_CDATA_SECTION_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::CDATA_SECTION_NODE;
    pub const nsIDOMNode_ENTITY_REFERENCE_NODE: root::nsIDOMNode__bindgen_ty_1
              =
        nsIDOMNode__bindgen_ty_1::ENTITY_REFERENCE_NODE;
    pub const nsIDOMNode_ENTITY_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::ENTITY_NODE;
    pub const nsIDOMNode_PROCESSING_INSTRUCTION_NODE:
              root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::PROCESSING_INSTRUCTION_NODE;
    pub const nsIDOMNode_COMMENT_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::COMMENT_NODE;
    pub const nsIDOMNode_DOCUMENT_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::DOCUMENT_NODE;
    pub const nsIDOMNode_DOCUMENT_TYPE_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::DOCUMENT_TYPE_NODE;
    pub const nsIDOMNode_DOCUMENT_FRAGMENT_NODE:
              root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::DOCUMENT_FRAGMENT_NODE;
    pub const nsIDOMNode_NOTATION_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::NOTATION_NODE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDOMNode__bindgen_ty_1 {
        ELEMENT_NODE = 1,
        ATTRIBUTE_NODE = 2,
        TEXT_NODE = 3,
        CDATA_SECTION_NODE = 4,
        ENTITY_REFERENCE_NODE = 5,
        ENTITY_NODE = 6,
        PROCESSING_INSTRUCTION_NODE = 7,
        COMMENT_NODE = 8,
        DOCUMENT_NODE = 9,
        DOCUMENT_TYPE_NODE = 10,
        DOCUMENT_FRAGMENT_NODE = 11,
        NOTATION_NODE = 12,
    }
    pub const nsIDOMNode_DOCUMENT_POSITION_DISCONNECTED:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_DISCONNECTED;
    pub const nsIDOMNode_DOCUMENT_POSITION_PRECEDING:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_PRECEDING;
    pub const nsIDOMNode_DOCUMENT_POSITION_FOLLOWING:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_FOLLOWING;
    pub const nsIDOMNode_DOCUMENT_POSITION_CONTAINS:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_CONTAINS;
    pub const nsIDOMNode_DOCUMENT_POSITION_CONTAINED_BY:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_CONTAINED_BY;
    pub const nsIDOMNode_DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDOMNode__bindgen_ty_2 {
        DOCUMENT_POSITION_DISCONNECTED = 1,
        DOCUMENT_POSITION_PRECEDING = 2,
        DOCUMENT_POSITION_FOLLOWING = 4,
        DOCUMENT_POSITION_CONTAINS = 8,
        DOCUMENT_POSITION_CONTAINED_BY = 16,
        DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMNode() {
        assert_eq!(::std::mem::size_of::<nsIDOMNode>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIDOMNode ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMNode>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIDOMNode ) ));
    }
    impl Clone for nsIDOMNode {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMNodeList {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMNodeList_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMNodeList() {
        assert_eq!(::std::mem::size_of::<nsIDOMNodeList>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( nsIDOMNodeList ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMNodeList>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsIDOMNodeList ) ));
    }
    impl Clone for nsIDOMNodeList {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMClientRect {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMClientRect_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMClientRect() {
        assert_eq!(::std::mem::size_of::<nsIDOMClientRect>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsIDOMClientRect ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMClientRect>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMClientRect ) ));
    }
    impl Clone for nsIDOMClientRect {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMClientRectList {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMClientRectList_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMClientRectList() {
        assert_eq!(::std::mem::size_of::<nsIDOMClientRectList>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIDOMClientRectList ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMClientRectList>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMClientRectList ) ));
    }
    impl Clone for nsIDOMClientRectList {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMStyleSheet {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMStyleSheet_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMStyleSheet() {
        assert_eq!(::std::mem::size_of::<nsIDOMStyleSheet>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsIDOMStyleSheet ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMStyleSheet>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMStyleSheet ) ));
    }
    impl Clone for nsIDOMStyleSheet {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMMediaList {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMMediaList_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMMediaList() {
        assert_eq!(::std::mem::size_of::<nsIDOMMediaList>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsIDOMMediaList ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMMediaList>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMMediaList ) ));
    }
    impl Clone for nsIDOMMediaList {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMEvent([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMEventTarget {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMEventTarget_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMEventTarget() {
        assert_eq!(::std::mem::size_of::<nsIDOMEventTarget>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsIDOMEventTarget )
                   ));
        assert_eq! (::std::mem::align_of::<nsIDOMEventTarget>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMEventTarget ) ));
    }
    impl Clone for nsIDOMEventTarget {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMEventListener([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMHTMLCollection {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMHTMLCollection_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMHTMLCollection() {
        assert_eq!(::std::mem::size_of::<nsIDOMHTMLCollection>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIDOMHTMLCollection ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMHTMLCollection>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMHTMLCollection ) ));
    }
    impl Clone for nsIDOMHTMLCollection {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMCSSRule([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMCSSRuleList([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMCSSStyleSheet {
        pub _base: root::nsIDOMStyleSheet,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMCSSStyleSheet_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMCSSStyleSheet() {
        assert_eq!(::std::mem::size_of::<nsIDOMCSSStyleSheet>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIDOMCSSStyleSheet ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMCSSStyleSheet>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMCSSStyleSheet ) ));
    }
    impl Clone for nsIDOMCSSStyleSheet {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIControllers([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISelection([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct mozIDOMWindowProxy {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mozIDOMWindowProxy_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_mozIDOMWindowProxy() {
        assert_eq!(::std::mem::size_of::<mozIDOMWindowProxy>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( mozIDOMWindowProxy )
                   ));
        assert_eq! (::std::mem::align_of::<mozIDOMWindowProxy>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( mozIDOMWindowProxy ) ));
    }
    impl Clone for mozIDOMWindowProxy {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPresContext {
        pub _base: root::nsIObserver,
        pub _base_1: u64,
        pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
        pub mType: root::nsPresContext_nsPresContextType,
        pub mShell: *mut root::nsIPresShell,
        pub mDocument: root::nsCOMPtr<root::nsIDocument>,
        pub mDeviceContext: root::RefPtr<root::nsDeviceContext>,
        pub mEventManager: root::RefPtr<root::mozilla::EventStateManager>,
        pub mRefreshDriver: root::RefPtr<root::nsRefreshDriver>,
        pub mEffectCompositor: root::RefPtr<root::mozilla::EffectCompositor>,
        pub mTransitionManager: root::RefPtr<root::nsTransitionManager>,
        pub mAnimationManager: root::RefPtr<root::nsAnimationManager>,
        pub mRestyleManager: root::RefPtr<root::mozilla::RestyleManager>,
        pub mCounterStyleManager: root::RefPtr<root::mozilla::CounterStyleManager>,
        pub mMedium: *mut root::nsIAtom,
        pub mMediaEmulated: root::nsCOMPtr<root::nsIAtom>,
        pub mLinkHandler: *mut root::nsILinkHandler,
        pub mLanguage: root::nsCOMPtr<root::nsIAtom>,
        pub mInflationDisabledForShrinkWrap: bool,
        pub mContainer: u64,
        pub mBaseMinFontSize: i32,
        pub mTextZoom: f32,
        pub mFullZoom: f32,
        pub mOverrideDPPX: f32,
        pub mLastFontInflationScreenSize: root::gfxSize,
        pub mCurAppUnitsPerDevPixel: i32,
        pub mAutoQualityMinFontSizePixelsPref: i32,
        pub mTheme: root::nsCOMPtr<root::nsITheme>,
        pub mLangService: root::nsCOMPtr<root::nsILanguageAtomService>,
        pub mPrintSettings: root::nsCOMPtr<root::nsIPrintSettings>,
        pub mPrefChangedTimer: root::nsCOMPtr<root::nsITimer>,
        pub mPropertyTable: root::nsPresContext_FramePropertyTable,
        pub mTransactions: [u64; 10usize],
        pub mTextPerf: root::nsAutoPtr<root::gfxTextPerfMetrics>,
        pub mMissingFonts: root::nsAutoPtr<root::gfxMissingFontRecorder>,
        pub mVisibleArea: root::nsRect,
        pub mPageSize: root::nsSize,
        pub mPageScale: f32,
        pub mPPScale: f32,
        pub mDefaultColor: root::nscolor,
        pub mBackgroundColor: root::nscolor,
        pub mLinkColor: root::nscolor,
        pub mActiveLinkColor: root::nscolor,
        pub mVisitedLinkColor: root::nscolor,
        pub mFocusBackgroundColor: root::nscolor,
        pub mFocusTextColor: root::nscolor,
        pub mBodyTextColor: root::nscolor,
        pub mViewportStyleScrollbar: root::nsPresContext_ScrollbarStyles,
        pub mFocusRingWidth: u8,
        pub mExistThrottledUpdates: bool,
        pub mImageAnimationMode: u16,
        pub mImageAnimationModePref: u16,
        pub mLangGroupFontPrefs: root::nsPresContext_LangGroupFontPrefs,
        pub mBorderWidthTable: [root::nscoord; 3usize],
        pub mInterruptChecksToSkip: u32,
        pub mElementsRestyled: u64,
        pub mFramesConstructed: u64,
        pub mFramesReflowed: u64,
        pub mReflowStartTime: root::mozilla::TimeStamp,
        pub mFirstNonBlankPaintTime: root::mozilla::TimeStamp,
        pub mFirstClickTime: root::mozilla::TimeStamp,
        pub mFirstKeyTime: root::mozilla::TimeStamp,
        pub mFirstMouseMoveTime: root::mozilla::TimeStamp,
        pub mFirstScrollTime: root::mozilla::TimeStamp,
        pub mInteractionTimeEnabled: bool,
        pub mLastStyleUpdateForAllAnimations: root::mozilla::TimeStamp,
        pub _bitfield_1: [u8; 4usize],
        pub _bitfield_2: [u8; 2usize],
    }
    pub type nsPresContext_FramePropertyTable =
        root::mozilla::FramePropertyTable;
    pub type nsPresContext_LangGroupFontPrefs =
        root::mozilla::LangGroupFontPrefs;
    pub type nsPresContext_ScrollbarStyles = root::mozilla::ScrollbarStyles;
    pub type nsPresContext_StaticPresData = root::mozilla::StaticPresData;
    pub type nsPresContext_HasThreadSafeRefCnt = root::mozilla::FalseType;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsPresContext_cycleCollection {
        pub _base: root::nsXPCOMCycleCollectionParticipant,
    }
    #[test]
    fn bindgen_test_layout_nsPresContext_cycleCollection() {
        assert_eq!(::std::mem::size_of::<nsPresContext_cycleCollection>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( nsPresContext_cycleCollection )
                   ));
        assert_eq! (::std::mem::align_of::<nsPresContext_cycleCollection>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsPresContext_cycleCollection ) ));
    }
    impl Clone for nsPresContext_cycleCollection {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsPresContext_nsPresContextType {
        eContext_Galley = 0,
        eContext_PrintPreview = 1,
        eContext_Print = 2,
        eContext_PageLayout = 3,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsPresContext_InteractionType {
        eClickInteraction = 0,
        eKeyInteraction = 1,
        eMouseMoveInteraction = 2,
        eScrollInteraction = 3,
    }
    /**
   * A class that can be used to temporarily disable reflow interruption.
   */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPresContext_InterruptPreventer {
        pub mCtx: *mut root::nsPresContext,
        pub mInterruptsEnabled: bool,
        pub mHasPendingInterrupt: bool,
    }
    #[test]
    fn bindgen_test_layout_nsPresContext_InterruptPreventer() {
        assert_eq!(::std::mem::size_of::<nsPresContext_InterruptPreventer>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsPresContext_InterruptPreventer ) ));
        assert_eq! (::std::mem::align_of::<nsPresContext_InterruptPreventer>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsPresContext_InterruptPreventer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext_InterruptPreventer ) )
                    . mCtx as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresContext_InterruptPreventer ) , "::" , stringify ! (
                    mCtx ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext_InterruptPreventer ) )
                    . mInterruptsEnabled as * const _ as usize } , 8usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresContext_InterruptPreventer ) , "::" , stringify ! (
                    mInterruptsEnabled ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext_InterruptPreventer ) )
                    . mHasPendingInterrupt as * const _ as usize } , 9usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresContext_InterruptPreventer ) , "::" , stringify ! (
                    mHasPendingInterrupt ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPresContext_TransactionInvalidations {
        pub mTransactionId: u64,
        pub mInvalidations: root::nsTArray<root::nsRect>,
    }
    #[test]
    fn bindgen_test_layout_nsPresContext_TransactionInvalidations() {
        assert_eq!(::std::mem::size_of::<nsPresContext_TransactionInvalidations>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsPresContext_TransactionInvalidations ) ));
        assert_eq! (::std::mem::align_of::<nsPresContext_TransactionInvalidations>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsPresContext_TransactionInvalidations ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsPresContext_TransactionInvalidations )
                    ) . mTransactionId as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresContext_TransactionInvalidations ) , "::" ,
                    stringify ! ( mTransactionId ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsPresContext_TransactionInvalidations )
                    ) . mInvalidations as * const _ as usize } , 8usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresContext_TransactionInvalidations ) , "::" ,
                    stringify ! ( mInvalidations ) ));
    }
    extern "C" {
        #[link_name = "_ZN13nsPresContext21_cycleCollectorGlobalE"]
        pub static mut nsPresContext__cycleCollectorGlobal:
                   root::nsPresContext_cycleCollection;
    }
    #[test]
    fn bindgen_test_layout_nsPresContext() {
        assert_eq!(::std::mem::size_of::<nsPresContext>() , 1328usize , concat
                   ! ( "Size of: " , stringify ! ( nsPresContext ) ));
        assert_eq! (::std::mem::align_of::<nsPresContext>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsPresContext ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mRefCnt as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mType as * const
                    _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mShell as * const
                    _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mShell ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mDocument as *
                    const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mDocument ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mDeviceContext as
                    * const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mDeviceContext ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mEventManager as
                    * const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mEventManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mRefreshDriver as
                    * const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mRefreshDriver ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mEffectCompositor
                    as * const _ as usize } , 72usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mEffectCompositor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mTransitionManager as * const _ as usize } , 80usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mTransitionManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mAnimationManager
                    as * const _ as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mAnimationManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mRestyleManager
                    as * const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mRestyleManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mCounterStyleManager as * const _ as usize } , 104usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mCounterStyleManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mMedium as *
                    const _ as usize } , 112usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mMedium ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mMediaEmulated as
                    * const _ as usize } , 120usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mMediaEmulated ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mLinkHandler as *
                    const _ as usize } , 128usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLinkHandler ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mLanguage as *
                    const _ as usize } , 136usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLanguage ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mInflationDisabledForShrinkWrap as * const _ as usize } ,
                    144usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mInflationDisabledForShrinkWrap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mContainer as *
                    const _ as usize } , 152usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mContainer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mBaseMinFontSize
                    as * const _ as usize } , 160usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mBaseMinFontSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mTextZoom as *
                    const _ as usize } , 164usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mTextZoom ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mFullZoom as *
                    const _ as usize } , 168usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFullZoom ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mOverrideDPPX as
                    * const _ as usize } , 172usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mOverrideDPPX ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mLastFontInflationScreenSize as * const _ as usize } ,
                    176usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLastFontInflationScreenSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mCurAppUnitsPerDevPixel as * const _ as usize } , 192usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mCurAppUnitsPerDevPixel ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mAutoQualityMinFontSizePixelsPref as * const _ as usize }
                    , 196usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mAutoQualityMinFontSizePixelsPref )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mTheme as * const
                    _ as usize } , 200usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mTheme ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mLangService as *
                    const _ as usize } , 208usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLangService ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mPrintSettings as
                    * const _ as usize } , 216usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mPrintSettings ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mPrefChangedTimer
                    as * const _ as usize } , 224usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mPrefChangedTimer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mPropertyTable as
                    * const _ as usize } , 232usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mPropertyTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mTransactions as
                    * const _ as usize } , 288usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mTransactions ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mTextPerf as *
                    const _ as usize } , 368usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mTextPerf ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mMissingFonts as
                    * const _ as usize } , 376usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mMissingFonts ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mVisibleArea as *
                    const _ as usize } , 384usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mVisibleArea ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mPageSize as *
                    const _ as usize } , 400usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mPageSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mPageScale as *
                    const _ as usize } , 408usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mPageScale ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mPPScale as *
                    const _ as usize } , 412usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mPPScale ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mDefaultColor as
                    * const _ as usize } , 416usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mDefaultColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mBackgroundColor
                    as * const _ as usize } , 420usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mBackgroundColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mLinkColor as *
                    const _ as usize } , 424usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLinkColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mActiveLinkColor
                    as * const _ as usize } , 428usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mActiveLinkColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mVisitedLinkColor
                    as * const _ as usize } , 432usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mVisitedLinkColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mFocusBackgroundColor as * const _ as usize } , 436usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFocusBackgroundColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mFocusTextColor
                    as * const _ as usize } , 440usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFocusTextColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mBodyTextColor as
                    * const _ as usize } , 444usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mBodyTextColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mViewportStyleScrollbar as * const _ as usize } , 448usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mViewportStyleScrollbar ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mFocusRingWidth
                    as * const _ as usize } , 512usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFocusRingWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mExistThrottledUpdates as * const _ as usize } , 513usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mExistThrottledUpdates ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mImageAnimationMode as * const _ as usize } , 514usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mImageAnimationMode ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mImageAnimationModePref as * const _ as usize } , 516usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mImageAnimationModePref ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mLangGroupFontPrefs as * const _ as usize } , 520usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLangGroupFontPrefs ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mBorderWidthTable
                    as * const _ as usize } , 1216usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mBorderWidthTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mInterruptChecksToSkip as * const _ as usize } , 1228usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mInterruptChecksToSkip ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mElementsRestyled
                    as * const _ as usize } , 1232usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mElementsRestyled ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mFramesConstructed as * const _ as usize } , 1240usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFramesConstructed ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mFramesReflowed
                    as * const _ as usize } , 1248usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFramesReflowed ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mReflowStartTime
                    as * const _ as usize } , 1256usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mReflowStartTime ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mFirstNonBlankPaintTime as * const _ as usize } ,
                    1264usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFirstNonBlankPaintTime ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mFirstClickTime
                    as * const _ as usize } , 1272usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFirstClickTime ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mFirstKeyTime as
                    * const _ as usize } , 1280usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFirstKeyTime ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mFirstMouseMoveTime as * const _ as usize } , 1288usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFirstMouseMoveTime ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) . mFirstScrollTime
                    as * const _ as usize } , 1296usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mFirstScrollTime ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mInteractionTimeEnabled as * const _ as usize } ,
                    1304usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mInteractionTimeEnabled ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresContext ) ) .
                    mLastStyleUpdateForAllAnimations as * const _ as usize } ,
                    1312usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresContext ) ,
                    "::" , stringify ! ( mLastStyleUpdateForAllAnimations )
                    ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPIDOMWindowOuter {
        pub _base: [u64; 28usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsPIDOMWindowOuter_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsPIDOMWindowOuter() {
        assert_eq!(::std::mem::size_of::<nsPIDOMWindowOuter>() , 224usize ,
                   concat ! ( "Size of: " , stringify ! ( nsPIDOMWindowOuter )
                   ));
        assert_eq! (::std::mem::align_of::<nsPIDOMWindowOuter>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsPIDOMWindowOuter ) ));
    }
    pub type PLDHashNumber = u32;
    #[repr(C)]
    #[derive(Debug)]
    pub struct PLDHashTable {
        pub mOps: *const root::PLDHashTableOps,
        pub mHashShift: i16,
        pub mEntrySize: u32,
        pub mEntryCount: u32,
        pub mRemovedCount: u32,
        pub mEntryStore: root::PLDHashTable_EntryStore,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct PLDHashTable_EntryStore {
        pub mEntryStore: *mut ::std::os::raw::c_char,
        pub mGeneration: u32,
    }
    #[test]
    fn bindgen_test_layout_PLDHashTable_EntryStore() {
        assert_eq!(::std::mem::size_of::<PLDHashTable_EntryStore>() , 16usize
                   , concat ! (
                   "Size of: " , stringify ! ( PLDHashTable_EntryStore ) ));
        assert_eq! (::std::mem::align_of::<PLDHashTable_EntryStore>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( PLDHashTable_EntryStore )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_EntryStore ) ) .
                    mEntryStore as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_EntryStore ) , "::" , stringify ! (
                    mEntryStore ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_EntryStore ) ) .
                    mGeneration as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_EntryStore ) , "::" , stringify ! (
                    mGeneration ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct PLDHashTable_Iterator {
        pub mTable: *mut root::PLDHashTable,
        pub mStart: *mut ::std::os::raw::c_char,
        pub mLimit: *mut ::std::os::raw::c_char,
        pub mCurrent: *mut ::std::os::raw::c_char,
        pub mNexts: u32,
        pub mNextsLimit: u32,
        pub mHaveRemoved: bool,
    }
    #[test]
    fn bindgen_test_layout_PLDHashTable_Iterator() {
        assert_eq!(::std::mem::size_of::<PLDHashTable_Iterator>() , 48usize ,
                   concat ! (
                   "Size of: " , stringify ! ( PLDHashTable_Iterator ) ));
        assert_eq! (::std::mem::align_of::<PLDHashTable_Iterator>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( PLDHashTable_Iterator )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_Iterator ) ) . mTable as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_Iterator ) , "::" , stringify ! ( mTable )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_Iterator ) ) . mStart as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_Iterator ) , "::" , stringify ! ( mStart )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_Iterator ) ) . mLimit as
                    * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_Iterator ) , "::" , stringify ! ( mLimit )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_Iterator ) ) . mCurrent
                    as * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_Iterator ) , "::" , stringify ! ( mCurrent )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_Iterator ) ) . mNexts as
                    * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_Iterator ) , "::" , stringify ! ( mNexts )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_Iterator ) ) .
                    mNextsLimit as * const _ as usize } , 36usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_Iterator ) , "::" , stringify ! ( mNextsLimit
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable_Iterator ) ) .
                    mHaveRemoved as * const _ as usize } , 40usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    PLDHashTable_Iterator ) , "::" , stringify ! (
                    mHaveRemoved ) ));
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum PLDHashTable_SearchReason { ForSearchOrRemove = 0, ForAdd = 1, }
    pub const PLDHashTable_kMaxCapacity: u32 = 67108864;
    pub const PLDHashTable_kMinCapacity: u32 = 8;
    pub const PLDHashTable_kMaxInitialLength: u32 = 33554432;
    pub const PLDHashTable_kDefaultInitialLength: u32 = 4;
    pub const PLDHashTable_kHashBits: u32 = 32;
    pub const PLDHashTable_kGoldenRatio: u32 = 2654435769;
    pub const PLDHashTable_kCollisionFlag: root::PLDHashNumber = 1;
    #[test]
    fn bindgen_test_layout_PLDHashTable() {
        assert_eq!(::std::mem::size_of::<PLDHashTable>() , 40usize , concat !
                   ( "Size of: " , stringify ! ( PLDHashTable ) ));
        assert_eq! (::std::mem::align_of::<PLDHashTable>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( PLDHashTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable ) ) . mOps as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTable ) ,
                    "::" , stringify ! ( mOps ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable ) ) . mHashShift as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTable ) ,
                    "::" , stringify ! ( mHashShift ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable ) ) . mEntrySize as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTable ) ,
                    "::" , stringify ! ( mEntrySize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable ) ) . mEntryCount as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTable ) ,
                    "::" , stringify ! ( mEntryCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable ) ) . mRemovedCount as *
                    const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTable ) ,
                    "::" , stringify ! ( mRemovedCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTable ) ) . mEntryStore as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTable ) ,
                    "::" , stringify ! ( mEntryStore ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLDHashTableOps {
        pub hashKey: root::PLDHashHashKey,
        pub matchEntry: root::PLDHashMatchEntry,
        pub moveEntry: root::PLDHashMoveEntry,
        pub clearEntry: root::PLDHashClearEntry,
        pub initEntry: root::PLDHashInitEntry,
    }
    #[test]
    fn bindgen_test_layout_PLDHashTableOps() {
        assert_eq!(::std::mem::size_of::<PLDHashTableOps>() , 40usize , concat
                   ! ( "Size of: " , stringify ! ( PLDHashTableOps ) ));
        assert_eq! (::std::mem::align_of::<PLDHashTableOps>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( PLDHashTableOps ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTableOps ) ) . hashKey as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTableOps ) ,
                    "::" , stringify ! ( hashKey ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTableOps ) ) . matchEntry as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTableOps ) ,
                    "::" , stringify ! ( matchEntry ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTableOps ) ) . moveEntry as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTableOps ) ,
                    "::" , stringify ! ( moveEntry ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTableOps ) ) . clearEntry as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTableOps ) ,
                    "::" , stringify ! ( clearEntry ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashTableOps ) ) . initEntry as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashTableOps ) ,
                    "::" , stringify ! ( initEntry ) ));
    }
    impl Clone for PLDHashTableOps {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLDHashEntryHdr {
        pub mKeyHash: root::PLDHashNumber,
    }
    #[test]
    fn bindgen_test_layout_PLDHashEntryHdr() {
        assert_eq!(::std::mem::size_of::<PLDHashEntryHdr>() , 4usize , concat
                   ! ( "Size of: " , stringify ! ( PLDHashEntryHdr ) ));
        assert_eq! (::std::mem::align_of::<PLDHashEntryHdr>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( PLDHashEntryHdr ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLDHashEntryHdr ) ) . mKeyHash as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLDHashEntryHdr ) ,
                    "::" , stringify ! ( mKeyHash ) ));
    }
    impl Clone for PLDHashEntryHdr {
        fn clone(&self) -> Self { *self }
    }
    pub type PLDHashHashKey =
        ::std::option::Option<unsafe extern "C" fn(aKey:
                                                       *const ::std::os::raw::c_void)
                                  -> ::std::os::raw::c_uint>;
    pub type PLDHashMatchEntry =
        ::std::option::Option<unsafe extern "C" fn(aEntry:
                                                       *const root::PLDHashEntryHdr,
                                                   aKey:
                                                       *const ::std::os::raw::c_void)
                                  -> bool>;
    pub type PLDHashMoveEntry =
        ::std::option::Option<unsafe extern "C" fn(aTable:
                                                       *mut root::PLDHashTable,
                                                   aFrom:
                                                       *const root::PLDHashEntryHdr,
                                                   aTo:
                                                       *mut root::PLDHashEntryHdr)>;
    pub type PLDHashClearEntry =
        ::std::option::Option<unsafe extern "C" fn(aTable:
                                                       *mut root::PLDHashTable,
                                                   aEntry:
                                                       *mut root::PLDHashEntryHdr)>;
    pub type PLDHashInitEntry =
        ::std::option::Option<unsafe extern "C" fn(aEntry:
                                                       *mut root::PLDHashEntryHdr,
                                                   aKey:
                                                       *const ::std::os::raw::c_void)>;
    /**
 * hashkey wrapper using T* KeyType
 *
 * @see nsTHashtable::EntryType for specification
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPtrHashKey<T> {
        pub _base: root::PLDHashEntryHdr,
        pub mKey: *mut T,
    }
    pub type nsPtrHashKey_KeyType<T> = *mut T;
    pub type nsPtrHashKey_KeyTypePointer<T> = *mut T;
    pub const nsPtrHashKey_ALLOW_MEMMOVE: root::nsPtrHashKey__bindgen_ty_1 =
        nsPtrHashKey__bindgen_ty_1::ALLOW_MEMMOVE;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsPtrHashKey__bindgen_ty_1 { ALLOW_MEMMOVE = 0, }
    /**
 * A node of content in a document's content model. This interface
 * is supported by all content objects.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIContent {
        pub _base: root::nsINode,
    }
    pub type nsIContent_IMEState = root::mozilla::widget::IMEState;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIContent_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const nsIContent_eAllChildren: root::nsIContent__bindgen_ty_1 =
        nsIContent__bindgen_ty_1::eAllChildren;
    pub const nsIContent_eAllButXBL: root::nsIContent__bindgen_ty_1 =
        nsIContent__bindgen_ty_1::eAllButXBL;
    pub const nsIContent_eSkipPlaceholderContent:
              root::nsIContent__bindgen_ty_1 =
        nsIContent__bindgen_ty_1::eSkipPlaceholderContent;
    pub const nsIContent_eSkipDocumentLevelNativeAnonymousContent:
              root::nsIContent__bindgen_ty_1 =
        nsIContent__bindgen_ty_1::eSkipDocumentLevelNativeAnonymousContent;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIContent__bindgen_ty_1 {
        eAllChildren = 0,
        eAllButXBL = 1,
        eSkipPlaceholderContent = 2,
        eSkipDocumentLevelNativeAnonymousContent = 4,
    }
    pub const nsIContent_ATTR_MISSING: root::nsIContent__bindgen_ty_2 =
        nsIContent__bindgen_ty_2::ATTR_MISSING;
    pub const nsIContent_ATTR_VALUE_NO_MATCH: root::nsIContent__bindgen_ty_2 =
        nsIContent__bindgen_ty_2::ATTR_VALUE_NO_MATCH;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIContent__bindgen_ty_2 {
        ATTR_MISSING = -1,
        ATTR_VALUE_NO_MATCH = -2,
    }
    /**
   * Check whether this content node's given attribute has one of a given
   * list of values. If there is a match, we return the index in the list
   * of the first matching value. If there was no attribute at all, then
   * we return ATTR_MISSING. If there was an attribute but it didn't
   * match, we return ATTR_VALUE_NO_MATCH. A non-negative result always
   * indicates a match.
   *
   * @param aNameSpaceID The namespace ID of the attribute.  Must not
   *                     be kNameSpaceID_Unknown.
   * @param aName The name atom of the attribute.  Must not be null.
   * @param aValues a nullptr-terminated array of pointers to atom values to test
   *                against.
   * @param aCaseSensitive Whether to do a case-sensitive compare on the values.
   * @return ATTR_MISSING, ATTR_VALUE_NO_MATCH or the non-negative index
   * indicating the first value of aValues that matched
   */
    pub type nsIContent_AttrValuesArray = *const *const root::nsIAtom;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIContent_FlattenedParentType {
        eNotForStyle = 0,
        eForStyle = 1,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIContent_ETabFocusType {
        eTabFocus_textControlsMask = 1,
        eTabFocus_formElementsMask = 2,
        eTabFocus_linksMask = 4,
        eTabFocus_any = 7,
    }
    extern "C" {
        #[link_name = "_ZN10nsIContent14sTabFocusModelE"]
        pub static mut nsIContent_sTabFocusModel: i32;
    }
    extern "C" {
        #[link_name = "_ZN10nsIContent26sTabFocusModelAppliesToXULE"]
        pub static mut nsIContent_sTabFocusModelAppliesToXUL: bool;
    }
    #[test]
    fn bindgen_test_layout_nsIContent() {
        assert_eq!(::std::mem::size_of::<nsIContent>() , 96usize , concat ! (
                   "Size of: " , stringify ! ( nsIContent ) ));
        assert_eq! (::std::mem::align_of::<nsIContent>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIContent ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsICSSDeclaration([u8; 0]);
    pub type SuspendTypes = u32;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum UIStateChangeType {
        UIStateChangeType_NoChange = 0,
        UIStateChangeType_Set = 1,
        UIStateChangeType_Clear = 2,
        UIStateChangeType_Invalid = 3,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIWeakReference {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIWeakReference_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIWeakReference() {
        assert_eq!(::std::mem::size_of::<nsIWeakReference>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsIWeakReference ) ));
        assert_eq! (::std::mem::align_of::<nsIWeakReference>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIWeakReference ) ));
    }
    impl Clone for nsIWeakReference {
        fn clone(&self) -> Self { *self }
    }
    pub type nsWeakPtr = root::nsCOMPtr<root::nsIWeakReference>;
    pub mod xpc {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug)]
        pub struct ErrorBase {
            pub mErrorMsg: ::nsstring::nsStringRepr,
            pub mFileName: ::nsstring::nsStringRepr,
            pub mLineNumber: u32,
            pub mColumn: u32,
        }
        #[test]
        fn bindgen_test_layout_ErrorBase() {
            assert_eq!(::std::mem::size_of::<ErrorBase>() , 40usize , concat !
                       ( "Size of: " , stringify ! ( ErrorBase ) ));
            assert_eq! (::std::mem::align_of::<ErrorBase>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( ErrorBase ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ErrorBase ) ) . mErrorMsg as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( ErrorBase ) ,
                        "::" , stringify ! ( mErrorMsg ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ErrorBase ) ) . mFileName as *
                        const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! ( ErrorBase ) ,
                        "::" , stringify ! ( mFileName ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ErrorBase ) ) . mLineNumber as *
                        const _ as usize } , 32usize , concat ! (
                        "Alignment of field: " , stringify ! ( ErrorBase ) ,
                        "::" , stringify ! ( mLineNumber ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const ErrorBase ) ) . mColumn as *
                        const _ as usize } , 36usize , concat ! (
                        "Alignment of field: " , stringify ! ( ErrorBase ) ,
                        "::" , stringify ! ( mColumn ) ));
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ErrorNote {
            pub _base: root::xpc::ErrorBase,
        }
        #[test]
        fn bindgen_test_layout_ErrorNote() {
            assert_eq!(::std::mem::size_of::<ErrorNote>() , 40usize , concat !
                       ( "Size of: " , stringify ! ( ErrorNote ) ));
            assert_eq! (::std::mem::align_of::<ErrorNote>() , 8usize , concat
                        ! ( "Alignment of " , stringify ! ( ErrorNote ) ));
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct PRLock([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIChannel {
        pub _base: root::nsIRequest,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIChannel_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const nsIChannel_LOAD_DOCUMENT_URI: root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_DOCUMENT_URI;
    pub const nsIChannel_LOAD_RETARGETED_DOCUMENT_URI:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_RETARGETED_DOCUMENT_URI;
    pub const nsIChannel_LOAD_REPLACE: root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_REPLACE;
    pub const nsIChannel_LOAD_INITIAL_DOCUMENT_URI:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_INITIAL_DOCUMENT_URI;
    pub const nsIChannel_LOAD_TARGETED: root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_TARGETED;
    pub const nsIChannel_LOAD_CALL_CONTENT_SNIFFERS:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_CALL_CONTENT_SNIFFERS;
    pub const nsIChannel_LOAD_CLASSIFY_URI: root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_CLASSIFY_URI;
    pub const nsIChannel_LOAD_MEDIA_SNIFFER_OVERRIDES_CONTENT_TYPE:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_MEDIA_SNIFFER_OVERRIDES_CONTENT_TYPE;
    pub const nsIChannel_LOAD_EXPLICIT_CREDENTIALS:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_EXPLICIT_CREDENTIALS;
    pub const nsIChannel_LOAD_BYPASS_SERVICE_WORKER:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_BYPASS_SERVICE_WORKER;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIChannel__bindgen_ty_1 {
        LOAD_DOCUMENT_URI = 65536,
        LOAD_RETARGETED_DOCUMENT_URI = 131072,
        LOAD_REPLACE = 262144,
        LOAD_INITIAL_DOCUMENT_URI = 524288,
        LOAD_TARGETED = 1048576,
        LOAD_CALL_CONTENT_SNIFFERS = 2097152,
        LOAD_CLASSIFY_URI = 4194304,
        LOAD_MEDIA_SNIFFER_OVERRIDES_CONTENT_TYPE = 8388608,
        LOAD_EXPLICIT_CREDENTIALS = 16777216,
        LOAD_BYPASS_SERVICE_WORKER = 33554432,
    }
    pub const nsIChannel_DISPOSITION_INLINE: root::nsIChannel__bindgen_ty_2 =
        nsIChannel__bindgen_ty_2::DISPOSITION_INLINE;
    pub const nsIChannel_DISPOSITION_ATTACHMENT:
              root::nsIChannel__bindgen_ty_2 =
        nsIChannel__bindgen_ty_2::DISPOSITION_ATTACHMENT;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIChannel__bindgen_ty_2 {
        DISPOSITION_INLINE = 0,
        DISPOSITION_ATTACHMENT = 1,
    }
    #[test]
    fn bindgen_test_layout_nsIChannel() {
        assert_eq!(::std::mem::size_of::<nsIChannel>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIChannel ) ));
        assert_eq! (::std::mem::align_of::<nsIChannel>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIChannel ) ));
    }
    impl Clone for nsIChannel {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsILoadContext {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsILoadContext_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsILoadContext() {
        assert_eq!(::std::mem::size_of::<nsILoadContext>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( nsILoadContext ) ));
        assert_eq! (::std::mem::align_of::<nsILoadContext>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsILoadContext ) ));
    }
    impl Clone for nsILoadContext {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIInterfaceRequestor {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIInterfaceRequestor_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIInterfaceRequestor() {
        assert_eq!(::std::mem::size_of::<nsIInterfaceRequestor>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIInterfaceRequestor ) ));
        assert_eq! (::std::mem::align_of::<nsIInterfaceRequestor>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIInterfaceRequestor )
                    ));
    }
    impl Clone for nsIInterfaceRequestor {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsILoadGroup {
        pub _base: root::nsIRequest,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsILoadGroup_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsILoadGroup() {
        assert_eq!(::std::mem::size_of::<nsILoadGroup>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsILoadGroup ) ));
        assert_eq! (::std::mem::align_of::<nsILoadGroup>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsILoadGroup ) ));
    }
    impl Clone for nsILoadGroup {
        fn clone(&self) -> Self { *self }
    }
    pub type nsLoadFlags = u32;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIRequest {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIRequest_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const nsIRequest_LOAD_REQUESTMASK: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_REQUESTMASK;
    pub const nsIRequest_LOAD_NORMAL: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_NORMAL;
    pub const nsIRequest_LOAD_BACKGROUND: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_BACKGROUND;
    pub const nsIRequest_INHIBIT_PIPELINE: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::INHIBIT_PIPELINE;
    pub const nsIRequest_INHIBIT_CACHING: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::INHIBIT_CACHING;
    pub const nsIRequest_INHIBIT_PERSISTENT_CACHING:
              root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::INHIBIT_PERSISTENT_CACHING;
    pub const nsIRequest_LOAD_BYPASS_CACHE: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_BYPASS_CACHE;
    pub const nsIRequest_LOAD_FROM_CACHE: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_FROM_CACHE;
    pub const nsIRequest_VALIDATE_ALWAYS: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::VALIDATE_ALWAYS;
    pub const nsIRequest_VALIDATE_NEVER: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::VALIDATE_NEVER;
    pub const nsIRequest_VALIDATE_ONCE_PER_SESSION:
              root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::VALIDATE_ONCE_PER_SESSION;
    pub const nsIRequest_LOAD_ANONYMOUS: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_ANONYMOUS;
    pub const nsIRequest_LOAD_FRESH_CONNECTION: root::nsIRequest__bindgen_ty_1
              =
        nsIRequest__bindgen_ty_1::LOAD_FRESH_CONNECTION;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIRequest__bindgen_ty_1 {
        LOAD_REQUESTMASK = 65535,
        LOAD_NORMAL = 0,
        LOAD_BACKGROUND = 1,
        INHIBIT_PIPELINE = 64,
        INHIBIT_CACHING = 128,
        INHIBIT_PERSISTENT_CACHING = 256,
        LOAD_BYPASS_CACHE = 512,
        LOAD_FROM_CACHE = 1024,
        VALIDATE_ALWAYS = 2048,
        VALIDATE_NEVER = 4096,
        VALIDATE_ONCE_PER_SESSION = 8192,
        LOAD_ANONYMOUS = 16384,
        LOAD_FRESH_CONNECTION = 32768,
    }
    #[test]
    fn bindgen_test_layout_nsIRequest() {
        assert_eq!(::std::mem::size_of::<nsIRequest>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsIRequest ) ));
        assert_eq! (::std::mem::align_of::<nsIRequest>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsIRequest ) ));
    }
    impl Clone for nsIRequest {
        fn clone(&self) -> Self { *self }
    }
    pub type nsContentPolicyType = u32;
    /**
 * An internal interface that abstracts some DOMNode-related parts that both
 * nsIContent and nsIDocument share.  An instance of this interface has a list
 * of nsIContent children and provides access to them.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsINode {
        pub _base: root::mozilla::dom::EventTarget,
        pub mNodeInfo: root::RefPtr<root::mozilla::dom::NodeInfo>,
        pub mParent: *mut root::nsINode,
        pub mBoolFlags: u32,
        pub mNextSibling: *mut root::nsIContent,
        pub mPreviousSibling: *mut root::nsIContent,
        pub mFirstChild: *mut root::nsIContent,
        pub __bindgen_anon_1: root::nsINode__bindgen_ty_1,
        pub mSlots: *mut root::nsINode_nsSlots,
    }
    pub type nsINode_BoxQuadOptions = root::mozilla::dom::BoxQuadOptions;
    pub type nsINode_ConvertCoordinateOptions =
        root::mozilla::dom::ConvertCoordinateOptions;
    pub type nsINode_DOMPoint = root::mozilla::dom::DOMPoint;
    pub type nsINode_DOMPointInit = root::mozilla::dom::DOMPointInit;
    pub type nsINode_DOMQuad = root::mozilla::dom::DOMQuad;
    pub type nsINode_DOMRectReadOnly = root::mozilla::dom::DOMRectReadOnly;
    pub type nsINode_OwningNodeOrString =
        root::mozilla::dom::OwningNodeOrString;
    pub type nsINode_TextOrElementOrDocument =
        root::mozilla::dom::TextOrElementOrDocument;
    pub use self::super::root::mozilla::dom::CallerType as nsINode_CallerType;
    pub type nsINode_ErrorResult = root::mozilla::ErrorResult;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsINode_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const nsINode_eCONTENT: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eCONTENT;
    pub const nsINode_eDOCUMENT: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eDOCUMENT;
    pub const nsINode_eATTRIBUTE: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eATTRIBUTE;
    pub const nsINode_eTEXT: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eTEXT;
    pub const nsINode_ePROCESSING_INSTRUCTION: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::ePROCESSING_INSTRUCTION;
    pub const nsINode_eCOMMENT: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eCOMMENT;
    pub const nsINode_eHTML_FORM_CONTROL: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eHTML_FORM_CONTROL;
    pub const nsINode_eDOCUMENT_FRAGMENT: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eDOCUMENT_FRAGMENT;
    pub const nsINode_eDATA_NODE: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eDATA_NODE;
    pub const nsINode_eMEDIA: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eMEDIA;
    pub const nsINode_eANIMATION: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eANIMATION;
    pub const nsINode_eFILTER: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eFILTER;
    #[repr(u32)]
    /**
   * Bit-flags to pass (or'ed together) to IsNodeOfType()
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsINode__bindgen_ty_2 {
        eCONTENT = 1,
        eDOCUMENT = 2,
        eATTRIBUTE = 4,
        eTEXT = 8,
        ePROCESSING_INSTRUCTION = 16,
        eCOMMENT = 32,
        eHTML_FORM_CONTROL = 64,
        eDOCUMENT_FRAGMENT = 128,
        eDATA_NODE = 256,
        eMEDIA = 512,
        eANIMATION = 1024,
        eFILTER = 2048,
    }
    #[repr(C)]
    pub struct nsINode_nsSlots__bindgen_vtable {
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsINode_nsSlots {
        pub vtable_: *const nsINode_nsSlots__bindgen_vtable,
        /**
     * A list of mutation observers
     */
        pub mMutationObservers: [u64; 2usize],
        /**
     * An object implementing nsIDOMNodeList for this content (childNodes)
     * @see nsIDOMNodeList
     * @see nsGenericHTMLElement::GetChildNodes
     */
        pub mChildNodes: root::RefPtr<root::nsChildContentList>,
        /**
     * Weak reference to this node.  This is cleared by the destructor of
     * nsNodeWeakReference.
     */
        pub mWeakReference: *mut root::nsNodeWeakReference,
        /**
     * Number of descendant nodes in the uncomposed document that have been
     * explicitly set as editable.
     */
        pub mEditableDescendantCount: u32,
    }
    #[test]
    fn bindgen_test_layout_nsINode_nsSlots() {
        assert_eq!(::std::mem::size_of::<nsINode_nsSlots>() , 48usize , concat
                   ! ( "Size of: " , stringify ! ( nsINode_nsSlots ) ));
        assert_eq! (::std::mem::align_of::<nsINode_nsSlots>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsINode_nsSlots ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode_nsSlots ) ) .
                    mMutationObservers as * const _ as usize } , 8usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsINode_nsSlots ) ,
                    "::" , stringify ! ( mMutationObservers ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode_nsSlots ) ) . mChildNodes as
                    * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode_nsSlots ) ,
                    "::" , stringify ! ( mChildNodes ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode_nsSlots ) ) . mWeakReference
                    as * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode_nsSlots ) ,
                    "::" , stringify ! ( mWeakReference ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode_nsSlots ) ) .
                    mEditableDescendantCount as * const _ as usize } , 40usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode_nsSlots ) ,
                    "::" , stringify ! ( mEditableDescendantCount ) ));
    }
    #[repr(u32)]
    /**
   * Boolean flags
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsINode_BooleanFlag {
        NodeHasRenderingObservers = 0,
        IsInDocument = 1,
        ParentIsContent = 2,
        NodeIsElement = 3,
        ElementHasID = 4,
        ElementMayHaveClass = 5,
        ElementMayHaveStyle = 6,
        ElementHasName = 7,
        ElementMayHaveContentEditableAttr = 8,
        NodeIsCommonAncestorForRangeInSelection = 9,
        NodeIsDescendantOfCommonAncestorForRangeInSelection = 10,
        NodeIsCCMarkedRoot = 11,
        NodeIsCCBlackTree = 12,
        NodeIsPurpleRoot = 13,
        ElementHasLockedStyleStates = 14,
        ElementHasPointerLock = 15,
        NodeMayHaveDOMMutationObserver = 16,
        NodeIsContent = 17,
        ElementHasAnimations = 18,
        NodeHasValidDirAttribute = 19,
        NodeHasFixedDir = 20,
        NodeHasDirAutoSet = 21,
        NodeHasTextNodeDirectionalityMap = 22,
        NodeHasDirAuto = 23,
        NodeAncestorHasDirAuto = 24,
        ElementIsInStyleScope = 25,
        ElementIsScopedStyleRoot = 26,
        NodeHandlingClick = 27,
        NodeHasRelevantHoverRules = 28,
        ElementHasWeirdParserInsertionMode = 29,
        ParserHasNotified = 30,
        MayBeApzAware = 31,
        BooleanFlagCount = 32,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsINode__bindgen_ty_1 {
        pub mPrimaryFrame: root::__BindgenUnionField<*mut root::nsIFrame>,
        pub mSubtreeRoot: root::__BindgenUnionField<*mut root::nsINode>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsINode__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsINode__bindgen_ty_1>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsINode__bindgen_ty_1 ) ));
        assert_eq! (::std::mem::align_of::<nsINode__bindgen_ty_1>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsINode__bindgen_ty_1 )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode__bindgen_ty_1 ) ) .
                    mPrimaryFrame as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsINode__bindgen_ty_1 ) , "::" , stringify ! (
                    mPrimaryFrame ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode__bindgen_ty_1 ) ) .
                    mSubtreeRoot as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsINode__bindgen_ty_1 ) , "::" , stringify ! (
                    mSubtreeRoot ) ));
    }
    impl Clone for nsINode__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsINode() {
        assert_eq!(::std::mem::size_of::<nsINode>() , 96usize , concat ! (
                   "Size of: " , stringify ! ( nsINode ) ));
        assert_eq! (::std::mem::align_of::<nsINode>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsINode ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode ) ) . mNodeInfo as * const _
                    as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode ) , "::" ,
                    stringify ! ( mNodeInfo ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode ) ) . mParent as * const _ as
                    usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode ) , "::" ,
                    stringify ! ( mParent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode ) ) . mBoolFlags as * const _
                    as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode ) , "::" ,
                    stringify ! ( mBoolFlags ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode ) ) . mNextSibling as * const
                    _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode ) , "::" ,
                    stringify ! ( mNextSibling ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode ) ) . mPreviousSibling as *
                    const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode ) , "::" ,
                    stringify ! ( mPreviousSibling ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode ) ) . mFirstChild as * const
                    _ as usize } , 72usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode ) , "::" ,
                    stringify ! ( mFirstChild ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsINode ) ) . mSlots as * const _ as
                    usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsINode ) , "::" ,
                    stringify ! ( mSlots ) ));
    }
    pub type nsSecurityFlags = u32;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsILoadInfo {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsILoadInfo_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const nsILoadInfo_SEC_NORMAL: root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_NORMAL;
    pub const nsILoadInfo_SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS:
              root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS;
    pub const nsILoadInfo_SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED:
              root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED;
    pub const nsILoadInfo_SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS:
              root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS;
    pub const nsILoadInfo_SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL:
              root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL;
    pub const nsILoadInfo_SEC_REQUIRE_CORS_DATA_INHERITS:
              root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_REQUIRE_CORS_DATA_INHERITS;
    pub const nsILoadInfo_SEC_COOKIES_DEFAULT: root::nsILoadInfo__bindgen_ty_1
              =
        nsILoadInfo__bindgen_ty_1::SEC_NORMAL;
    pub const nsILoadInfo_SEC_COOKIES_INCLUDE: root::nsILoadInfo__bindgen_ty_1
              =
        nsILoadInfo__bindgen_ty_1::SEC_COOKIES_INCLUDE;
    pub const nsILoadInfo_SEC_COOKIES_SAME_ORIGIN:
              root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_COOKIES_SAME_ORIGIN;
    pub const nsILoadInfo_SEC_COOKIES_OMIT: root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_COOKIES_OMIT;
    pub const nsILoadInfo_SEC_FORCE_INHERIT_PRINCIPAL:
              root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_FORCE_INHERIT_PRINCIPAL;
    pub const nsILoadInfo_SEC_SANDBOXED: root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_SANDBOXED;
    pub const nsILoadInfo_SEC_ABOUT_BLANK_INHERITS:
              root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_ABOUT_BLANK_INHERITS;
    pub const nsILoadInfo_SEC_ALLOW_CHROME: root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_ALLOW_CHROME;
    pub const nsILoadInfo_SEC_DISALLOW_SCRIPT: root::nsILoadInfo__bindgen_ty_1
              =
        nsILoadInfo__bindgen_ty_1::SEC_DISALLOW_SCRIPT;
    pub const nsILoadInfo_SEC_DONT_FOLLOW_REDIRECTS:
              root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_DONT_FOLLOW_REDIRECTS;
    pub const nsILoadInfo_SEC_LOAD_ERROR_PAGE: root::nsILoadInfo__bindgen_ty_1
              =
        nsILoadInfo__bindgen_ty_1::SEC_LOAD_ERROR_PAGE;
    pub const nsILoadInfo_SEC_FORCE_INHERIT_PRINCIPAL_OVERRULE_OWNER:
              root::nsILoadInfo__bindgen_ty_1 =
        nsILoadInfo__bindgen_ty_1::SEC_FORCE_INHERIT_PRINCIPAL_OVERRULE_OWNER;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsILoadInfo__bindgen_ty_1 {
        SEC_NORMAL = 0,
        SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS = 1,
        SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED = 2,
        SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS = 4,
        SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL = 8,
        SEC_REQUIRE_CORS_DATA_INHERITS = 16,
        SEC_COOKIES_INCLUDE = 32,
        SEC_COOKIES_SAME_ORIGIN = 64,
        SEC_COOKIES_OMIT = 96,
        SEC_FORCE_INHERIT_PRINCIPAL = 128,
        SEC_SANDBOXED = 256,
        SEC_ABOUT_BLANK_INHERITS = 512,
        SEC_ALLOW_CHROME = 1024,
        SEC_DISALLOW_SCRIPT = 2048,
        SEC_DONT_FOLLOW_REDIRECTS = 4096,
        SEC_LOAD_ERROR_PAGE = 8192,
        SEC_FORCE_INHERIT_PRINCIPAL_OVERRULE_OWNER = 16384,
    }
    pub const nsILoadInfo_TAINTING_BASIC: root::nsILoadInfo__bindgen_ty_2 =
        nsILoadInfo__bindgen_ty_2::TAINTING_BASIC;
    pub const nsILoadInfo_TAINTING_CORS: root::nsILoadInfo__bindgen_ty_2 =
        nsILoadInfo__bindgen_ty_2::TAINTING_CORS;
    pub const nsILoadInfo_TAINTING_OPAQUE: root::nsILoadInfo__bindgen_ty_2 =
        nsILoadInfo__bindgen_ty_2::TAINTING_OPAQUE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsILoadInfo__bindgen_ty_2 {
        TAINTING_BASIC = 0,
        TAINTING_CORS = 1,
        TAINTING_OPAQUE = 2,
    }
    #[test]
    fn bindgen_test_layout_nsILoadInfo() {
        assert_eq!(::std::mem::size_of::<nsILoadInfo>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsILoadInfo ) ));
        assert_eq! (::std::mem::align_of::<nsILoadInfo>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsILoadInfo ) ));
    }
    impl Clone for nsILoadInfo {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIInputStream([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIStreamListener {
        pub _base: root::nsIRequestObserver,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIStreamListener_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIStreamListener() {
        assert_eq!(::std::mem::size_of::<nsIStreamListener>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsIStreamListener )
                   ));
        assert_eq! (::std::mem::align_of::<nsIStreamListener>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIStreamListener ) ));
    }
    impl Clone for nsIStreamListener {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCOMArray_base {
        pub mArray: root::nsTArray<*mut root::nsISupports>,
    }
    pub type nsCOMArray_base_nsBaseArrayEnumFunc =
        ::std::option::Option<unsafe extern "C" fn(aElement:
                                                       *mut ::std::os::raw::c_void,
                                                   aData:
                                                       *mut ::std::os::raw::c_void)
                                  -> bool>;
    pub type nsCOMArray_base_nsBaseArrayComparatorFunc =
        ::std::option::Option<unsafe extern "C" fn(aElement1:
                                                       *mut root::nsISupports,
                                                   aElement2:
                                                       *mut root::nsISupports,
                                                   aData:
                                                       *mut ::std::os::raw::c_void)
                                  -> ::std::os::raw::c_int>;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCOMArray_base_nsCOMArrayComparatorContext {
        pub mComparatorFunc: root::nsCOMArray_base_nsBaseArrayComparatorFunc,
        pub mData: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_nsCOMArray_base_nsCOMArrayComparatorContext() {
        assert_eq!(::std::mem::size_of::<nsCOMArray_base_nsCOMArrayComparatorContext>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsCOMArray_base_nsCOMArrayComparatorContext ) ));
        assert_eq! (::std::mem::align_of::<nsCOMArray_base_nsCOMArrayComparatorContext>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsCOMArray_base_nsCOMArrayComparatorContext ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsCOMArray_base_nsCOMArrayComparatorContext )
                    ) . mComparatorFunc as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCOMArray_base_nsCOMArrayComparatorContext ) , "::" ,
                    stringify ! ( mComparatorFunc ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsCOMArray_base_nsCOMArrayComparatorContext )
                    ) . mData as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCOMArray_base_nsCOMArrayComparatorContext ) , "::" ,
                    stringify ! ( mData ) ));
    }
    impl Clone for nsCOMArray_base_nsCOMArrayComparatorContext {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsCOMArray_base() {
        assert_eq!(::std::mem::size_of::<nsCOMArray_base>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsCOMArray_base ) ));
        assert_eq! (::std::mem::align_of::<nsCOMArray_base>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCOMArray_base ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCOMArray_base ) ) . mArray as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCOMArray_base ) ,
                    "::" , stringify ! ( mArray ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCOMArray<T> {
        pub _base: root::nsCOMArray_base,
        pub _phantom_0: ::std::marker::PhantomData<T>,
    }
    pub type nsCOMArray_nsCOMArrayEnumFunc<T> =
        ::std::option::Option<unsafe extern "C" fn(aElement: *mut T,
                                                   aData:
                                                       *mut ::std::os::raw::c_void)
                                  -> bool>;
    pub type nsCOMArray_nsCOMArrayComparatorFunc<T> =
        ::std::option::Option<unsafe extern "C" fn(aElement1: *mut T,
                                                   aElement2: *mut T,
                                                   aData:
                                                       *mut ::std::os::raw::c_void)
                                  -> ::std::os::raw::c_int>;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCompatibility {
        eCompatibility_FullStandards = 1,
        eCompatibility_AlmostStandards = 2,
        eCompatibility_NavQuirks = 3,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMediaList {
        pub _base: root::nsIDOMMediaList,
        pub _base_1: root::nsWrapperCache,
        pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
        pub mArray: root::nsTArray<root::nsAutoPtr<root::nsMediaQuery>>,
        pub mStyleSheet: *mut root::mozilla::StyleSheet,
    }
    pub type nsMediaList_ErrorResult = root::mozilla::ErrorResult;
    pub type nsMediaList_HasThreadSafeRefCnt = root::mozilla::FalseType;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsMediaList_cycleCollection {
        pub _base: root::nsXPCOMCycleCollectionParticipant,
    }
    #[test]
    fn bindgen_test_layout_nsMediaList_cycleCollection() {
        assert_eq!(::std::mem::size_of::<nsMediaList_cycleCollection>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( nsMediaList_cycleCollection )
                   ));
        assert_eq! (::std::mem::align_of::<nsMediaList_cycleCollection>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsMediaList_cycleCollection ) ));
    }
    impl Clone for nsMediaList_cycleCollection {
        fn clone(&self) -> Self { *self }
    }
    extern "C" {
        #[link_name = "_ZN11nsMediaList21_cycleCollectorGlobalE"]
        pub static mut nsMediaList__cycleCollectorGlobal:
                   root::nsMediaList_cycleCollection;
    }
    #[test]
    fn bindgen_test_layout_nsMediaList() {
        assert_eq!(::std::mem::size_of::<nsMediaList>() , 56usize , concat ! (
                   "Size of: " , stringify ! ( nsMediaList ) ));
        assert_eq! (::std::mem::align_of::<nsMediaList>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsMediaList ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAttrValue {
        pub mBits: usize,
    }
    pub type nsAttrValue_AtomArray =
        root::nsTArray<root::nsCOMPtr<root::nsIAtom>>;
    pub const nsAttrValue_ValueType_eSVGTypesBegin:
              root::nsAttrValue_ValueType =
        nsAttrValue_ValueType::eSVGAngle;
    pub const nsAttrValue_ValueType_eSVGTypesEnd: root::nsAttrValue_ValueType
              =
        nsAttrValue_ValueType::eSVGViewBox;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsAttrValue_ValueType {
        eString = 0,
        eAtom = 2,
        eInteger = 3,
        eColor = 7,
        eEnum = 11,
        ePercent = 15,
        eCSSDeclaration = 16,
        eURL = 17,
        eImage = 18,
        eAtomArray = 19,
        eDoubleValue = 20,
        eIntMarginValue = 21,
        eSVGAngle = 22,
        eSVGIntegerPair = 23,
        eSVGLength = 24,
        eSVGLengthList = 25,
        eSVGNumberList = 26,
        eSVGNumberPair = 27,
        eSVGPathData = 28,
        eSVGPointList = 29,
        eSVGPreserveAspectRatio = 30,
        eSVGStringList = 31,
        eSVGTransformList = 32,
        eSVGViewBox = 33,
    }
    /**
   * Structure for a mapping from int (enum) values to strings.  When you use
   * it you generally create an array of them.
   * Instantiate like this:
   * EnumTable myTable[] = {
   *   { "string1", 1 },
   *   { "string2", 2 },
   *   { nullptr, 0 }
   * }
   */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsAttrValue_EnumTable {
        /** The string the value maps to */
        pub tag: *const ::std::os::raw::c_char,
        /** The enum value that maps to this string */
        pub value: i16,
    }
    #[test]
    fn bindgen_test_layout_nsAttrValue_EnumTable() {
        assert_eq!(::std::mem::size_of::<nsAttrValue_EnumTable>() , 16usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsAttrValue_EnumTable ) ));
        assert_eq! (::std::mem::align_of::<nsAttrValue_EnumTable>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsAttrValue_EnumTable )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrValue_EnumTable ) ) . tag as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrValue_EnumTable ) , "::" , stringify ! ( tag ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrValue_EnumTable ) ) . value as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrValue_EnumTable ) , "::" , stringify ! ( value ) ));
    }
    impl Clone for nsAttrValue_EnumTable {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsAttrValue_ValueBaseType {
        eStringBase = 0,
        eOtherBase = 1,
        eAtomBase = 2,
        eIntegerBase = 3,
    }
    extern "C" {
        #[link_name = "_ZN11nsAttrValue15sEnumTableArrayE"]
        pub static mut nsAttrValue_sEnumTableArray:
                   *mut root::nsTArray<*const root::nsAttrValue_EnumTable>;
    }
    #[test]
    fn bindgen_test_layout_nsAttrValue() {
        assert_eq!(::std::mem::size_of::<nsAttrValue>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsAttrValue ) ));
        assert_eq! (::std::mem::align_of::<nsAttrValue>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsAttrValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrValue ) ) . mBits as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAttrValue ) ,
                    "::" , stringify ! ( mBits ) ));
    }
    /**
 * Information details about a characterdata change.  Basically, we
 * view all changes as replacements of a length of text at some offset
 * with some other text (of possibly some other length).
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct CharacterDataChangeInfo {
        /**
   * True if this character data change is just an append.
   */
        pub mAppend: bool,
        /**
   * The offset in the text where the change occurred.
   */
        pub mChangeStart: u32,
        /**
   * The offset such that mChangeEnd - mChangeStart is equal to the length of
   * the text we removed. If this was a pure insert or append, this is equal to
   * mChangeStart.
   */
        pub mChangeEnd: u32,
        /**
   * The length of the text that was inserted in place of the removed text.  If
   * this was a pure text removal, this is 0.
   */
        pub mReplaceLength: u32,
        /**
   * Used for splitText() and normalize(), otherwise null.
   */
        pub mDetails: *mut root::CharacterDataChangeInfo_Details,
    }
    /**
   * The net result is that mChangeStart characters at the beginning of the
   * text remained as they were.  The next mChangeEnd - mChangeStart characters
   * were removed, and mReplaceLength characters were inserted in their place.
   * The text that used to begin at mChangeEnd now begins at
   * mChangeStart + mReplaceLength.
   */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct CharacterDataChangeInfo_Details {
        pub mType: root::CharacterDataChangeInfo_Details__bindgen_ty_1,
        /**
     * For eMerge it's the text node that will be removed, for eSplit it's the
     * new text node.
     */
        pub mNextSibling: *mut root::nsIContent,
    }
    pub const CharacterDataChangeInfo_Details_eMerge:
              root::CharacterDataChangeInfo_Details__bindgen_ty_1 =
        CharacterDataChangeInfo_Details__bindgen_ty_1::eMerge;
    pub const CharacterDataChangeInfo_Details_eSplit:
              root::CharacterDataChangeInfo_Details__bindgen_ty_1 =
        CharacterDataChangeInfo_Details__bindgen_ty_1::eSplit;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum CharacterDataChangeInfo_Details__bindgen_ty_1 {
        eMerge = 0,
        eSplit = 1,
    }
    #[test]
    fn bindgen_test_layout_CharacterDataChangeInfo_Details() {
        assert_eq!(::std::mem::size_of::<CharacterDataChangeInfo_Details>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( CharacterDataChangeInfo_Details
                   ) ));
        assert_eq! (::std::mem::align_of::<CharacterDataChangeInfo_Details>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    CharacterDataChangeInfo_Details ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CharacterDataChangeInfo_Details ) ) .
                    mType as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CharacterDataChangeInfo_Details ) , "::" , stringify ! (
                    mType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CharacterDataChangeInfo_Details ) ) .
                    mNextSibling as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CharacterDataChangeInfo_Details ) , "::" , stringify ! (
                    mNextSibling ) ));
    }
    impl Clone for CharacterDataChangeInfo_Details {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_CharacterDataChangeInfo() {
        assert_eq!(::std::mem::size_of::<CharacterDataChangeInfo>() , 24usize
                   , concat ! (
                   "Size of: " , stringify ! ( CharacterDataChangeInfo ) ));
        assert_eq! (::std::mem::align_of::<CharacterDataChangeInfo>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( CharacterDataChangeInfo )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CharacterDataChangeInfo ) ) . mAppend
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CharacterDataChangeInfo ) , "::" , stringify ! ( mAppend )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CharacterDataChangeInfo ) ) .
                    mChangeStart as * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CharacterDataChangeInfo ) , "::" , stringify ! (
                    mChangeStart ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CharacterDataChangeInfo ) ) .
                    mChangeEnd as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CharacterDataChangeInfo ) , "::" , stringify ! (
                    mChangeEnd ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CharacterDataChangeInfo ) ) .
                    mReplaceLength as * const _ as usize } , 12usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    CharacterDataChangeInfo ) , "::" , stringify ! (
                    mReplaceLength ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CharacterDataChangeInfo ) ) .
                    mDetails as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CharacterDataChangeInfo ) , "::" , stringify ! ( mDetails
                    ) ));
    }
    impl Clone for CharacterDataChangeInfo {
        fn clone(&self) -> Self { *self }
    }
    /**
 * Mutation observer interface
 *
 * See nsINode::AddMutationObserver, nsINode::RemoveMutationObserver for how to
 * attach or remove your observers.
 *
 * WARNING: During these notifications, you are not allowed to perform
 * any mutations to the current or any other document, or start a
 * network load.  If you need to perform such operations do that
 * during the _last_ nsIDocumentObserver::EndUpdate notification.  The
 * expection for this is ParentChainChanged, where mutations should be
 * done from an async event, as the notification might not be
 * surrounded by BeginUpdate/EndUpdate calls.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIMutationObserver {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIMutationObserver_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIMutationObserver() {
        assert_eq!(::std::mem::size_of::<nsIMutationObserver>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIMutationObserver ) ));
        assert_eq! (::std::mem::align_of::<nsIMutationObserver>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIMutationObserver ) ));
    }
    impl Clone for nsIMutationObserver {
        fn clone(&self) -> Self { *self }
    }
    pub type nsUpdateType = u32;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDocumentObserver {
        pub _base: root::nsIMutationObserver,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDocumentObserver_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIDocumentObserver() {
        assert_eq!(::std::mem::size_of::<nsIDocumentObserver>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIDocumentObserver ) ));
        assert_eq! (::std::mem::align_of::<nsIDocumentObserver>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDocumentObserver ) ));
    }
    impl Clone for nsIDocumentObserver {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIRequestObserver {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIRequestObserver_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIRequestObserver() {
        assert_eq!(::std::mem::size_of::<nsIRequestObserver>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsIRequestObserver )
                   ));
        assert_eq! (::std::mem::align_of::<nsIRequestObserver>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIRequestObserver ) ));
    }
    impl Clone for nsIRequestObserver {
        fn clone(&self) -> Self { *self }
    }
    pub const kNameSpaceID_None: i32 = 0;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsNodeInfoManager {
        pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
        pub mNodeInfoHash: *mut root::PLHashTable,
        pub mDocument: *mut root::nsIDocument,
        pub mNonDocumentNodeInfos: u32,
        pub mPrincipal: root::nsCOMPtr<root::nsIPrincipal>,
        pub mDefaultPrincipal: root::nsCOMPtr<root::nsIPrincipal>,
        pub mTextNodeInfo: *mut root::mozilla::dom::NodeInfo,
        pub mCommentNodeInfo: *mut root::mozilla::dom::NodeInfo,
        pub mDocumentNodeInfo: *mut root::mozilla::dom::NodeInfo,
        pub mBindingManager: root::RefPtr<root::nsBindingManager>,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsNodeInfoManager_cycleCollection {
        pub _base: root::nsCycleCollectionParticipant,
    }
    #[test]
    fn bindgen_test_layout_nsNodeInfoManager_cycleCollection() {
        assert_eq!(::std::mem::size_of::<nsNodeInfoManager_cycleCollection>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsNodeInfoManager_cycleCollection ) ));
        assert_eq! (::std::mem::align_of::<nsNodeInfoManager_cycleCollection>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsNodeInfoManager_cycleCollection ) ));
    }
    impl Clone for nsNodeInfoManager_cycleCollection {
        fn clone(&self) -> Self { *self }
    }
    pub type nsNodeInfoManager_HasThreadSafeRefCnt = root::mozilla::FalseType;
    extern "C" {
        #[link_name = "_ZN17nsNodeInfoManager21_cycleCollectorGlobalE"]
        pub static mut nsNodeInfoManager__cycleCollectorGlobal:
                   root::nsNodeInfoManager_cycleCollection;
    }
    #[test]
    fn bindgen_test_layout_nsNodeInfoManager() {
        assert_eq!(::std::mem::size_of::<nsNodeInfoManager>() , 80usize ,
                   concat ! ( "Size of: " , stringify ! ( nsNodeInfoManager )
                   ));
        assert_eq! (::std::mem::align_of::<nsNodeInfoManager>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsNodeInfoManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) . mRefCnt as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) . mNodeInfoHash
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mNodeInfoHash ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) . mDocument as
                    * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mDocument ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) .
                    mNonDocumentNodeInfos as * const _ as usize } , 24usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mNonDocumentNodeInfos ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) . mPrincipal as
                    * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mPrincipal ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) .
                    mDefaultPrincipal as * const _ as usize } , 40usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mDefaultPrincipal ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) . mTextNodeInfo
                    as * const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mTextNodeInfo ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) .
                    mCommentNodeInfo as * const _ as usize } , 56usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mCommentNodeInfo ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) .
                    mDocumentNodeInfo as * const _ as usize } , 64usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mDocumentNodeInfo ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeInfoManager ) ) .
                    mBindingManager as * const _ as usize } , 72usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsNodeInfoManager )
                    , "::" , stringify ! ( mBindingManager ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsBindingManager([u8; 0]);
    pub type NSPropertyFunc =
        ::std::option::Option<unsafe extern "C" fn(aObject:
                                                       *mut ::std::os::raw::c_void,
                                                   aPropertyName:
                                                       *mut root::nsIAtom,
                                                   aPropertyValue:
                                                       *mut ::std::os::raw::c_void,
                                                   aData:
                                                       *mut ::std::os::raw::c_void)>;
    /**
 * Callback type for property destructors.  |aObject| is the object
 * the property is being removed for, |aPropertyName| is the property
 * being removed, |aPropertyValue| is the value of the property, and |aData|
 * is the opaque destructor data that was passed to SetProperty().
 **/
    pub type NSPropertyDtorFunc = root::NSPropertyFunc;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIFrame([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsPropertyOwner {
        pub mObject: *const ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_nsPropertyOwner() {
        assert_eq!(::std::mem::size_of::<nsPropertyOwner>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsPropertyOwner ) ));
        assert_eq! (::std::mem::align_of::<nsPropertyOwner>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsPropertyOwner ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPropertyOwner ) ) . mObject as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPropertyOwner ) ,
                    "::" , stringify ! ( mObject ) ));
    }
    impl Clone for nsPropertyOwner {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPropertyTable {
        pub mPropertyList: *mut root::nsPropertyTable_PropertyList,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsPropertyTable_PropertyList([u8; 0]);
    #[test]
    fn bindgen_test_layout_nsPropertyTable() {
        assert_eq!(::std::mem::size_of::<nsPropertyTable>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsPropertyTable ) ));
        assert_eq! (::std::mem::align_of::<nsPropertyTable>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsPropertyTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPropertyTable ) ) . mPropertyList
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPropertyTable ) ,
                    "::" , stringify ! ( mPropertyList ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAttrAndChildArray {
        pub mImpl: *mut root::nsAttrAndChildArray_Impl,
    }
    pub type nsAttrAndChildArray_BorrowedAttrInfo =
        root::mozilla::dom::BorrowedAttrInfo;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAttrAndChildArray_InternalAttr {
        pub mName: root::nsAttrName,
        pub mValue: root::nsAttrValue,
    }
    #[test]
    fn bindgen_test_layout_nsAttrAndChildArray_InternalAttr() {
        assert_eq!(::std::mem::size_of::<nsAttrAndChildArray_InternalAttr>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsAttrAndChildArray_InternalAttr ) ));
        assert_eq! (::std::mem::align_of::<nsAttrAndChildArray_InternalAttr>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsAttrAndChildArray_InternalAttr ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrAndChildArray_InternalAttr ) )
                    . mName as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrAndChildArray_InternalAttr ) , "::" , stringify ! (
                    mName ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrAndChildArray_InternalAttr ) )
                    . mValue as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrAndChildArray_InternalAttr ) , "::" , stringify ! (
                    mValue ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsAttrAndChildArray_Impl {
        pub mAttrAndChildCount: u32,
        pub mBufferSize: u32,
        pub mMappedAttrs: *mut root::nsMappedAttributes,
        pub mBuffer: [*mut ::std::os::raw::c_void; 1usize],
    }
    #[test]
    fn bindgen_test_layout_nsAttrAndChildArray_Impl() {
        assert_eq!(::std::mem::size_of::<nsAttrAndChildArray_Impl>() , 24usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsAttrAndChildArray_Impl ) ));
        assert_eq! (::std::mem::align_of::<nsAttrAndChildArray_Impl>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsAttrAndChildArray_Impl )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrAndChildArray_Impl ) ) .
                    mAttrAndChildCount as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrAndChildArray_Impl ) , "::" , stringify ! (
                    mAttrAndChildCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrAndChildArray_Impl ) ) .
                    mBufferSize as * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrAndChildArray_Impl ) , "::" , stringify ! (
                    mBufferSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrAndChildArray_Impl ) ) .
                    mMappedAttrs as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrAndChildArray_Impl ) , "::" , stringify ! (
                    mMappedAttrs ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrAndChildArray_Impl ) ) .
                    mBuffer as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsAttrAndChildArray_Impl ) , "::" , stringify ! ( mBuffer
                    ) ));
    }
    impl Clone for nsAttrAndChildArray_Impl {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsAttrAndChildArray() {
        assert_eq!(::std::mem::size_of::<nsAttrAndChildArray>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsAttrAndChildArray ) ));
        assert_eq! (::std::mem::align_of::<nsAttrAndChildArray>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsAttrAndChildArray ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrAndChildArray ) ) . mImpl as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAttrAndChildArray
                    ) , "::" , stringify ! ( mImpl ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsChildContentList([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsCSSSelectorList([u8; 0]);
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsDOMAttributeMap {
        pub _base: root::nsIDOMMozNamedAttrMap,
        pub _base_1: root::nsWrapperCache,
        pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
        pub mContent: root::nsCOMPtr<root::mozilla::dom::Element>,
        /**
   * Cache of Attrs.
   */
        pub mAttributeCache: root::nsDOMAttributeMap_AttrCache,
    }
    pub type nsDOMAttributeMap_Attr = root::mozilla::dom::Attr;
    pub type nsDOMAttributeMap_Element = root::mozilla::dom::Element;
    pub type nsDOMAttributeMap_ErrorResult = root::mozilla::ErrorResult;
    pub type nsDOMAttributeMap_HasThreadSafeRefCnt = root::mozilla::FalseType;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsDOMAttributeMap_cycleCollection {
        pub _base: root::nsXPCOMCycleCollectionParticipant,
    }
    #[test]
    fn bindgen_test_layout_nsDOMAttributeMap_cycleCollection() {
        assert_eq!(::std::mem::size_of::<nsDOMAttributeMap_cycleCollection>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsDOMAttributeMap_cycleCollection ) ));
        assert_eq! (::std::mem::align_of::<nsDOMAttributeMap_cycleCollection>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsDOMAttributeMap_cycleCollection ) ));
    }
    impl Clone for nsDOMAttributeMap_cycleCollection {
        fn clone(&self) -> Self { *self }
    }
    pub type nsDOMAttributeMap_AttrCache = [u64; 5usize];
    extern "C" {
        #[link_name = "_ZN17nsDOMAttributeMap21_cycleCollectorGlobalE"]
        pub static mut nsDOMAttributeMap__cycleCollectorGlobal:
                   root::nsDOMAttributeMap_cycleCollection;
    }
    #[test]
    fn bindgen_test_layout_nsDOMAttributeMap() {
        assert_eq!(::std::mem::size_of::<nsDOMAttributeMap>() , 88usize ,
                   concat ! ( "Size of: " , stringify ! ( nsDOMAttributeMap )
                   ));
        assert_eq! (::std::mem::align_of::<nsDOMAttributeMap>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsDOMAttributeMap ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIAnimationObserver([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIEditor([u8; 0]);
    /**
 * An internal interface for a reasonably fast indexOf.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsINodeList {
        pub _base: root::nsIDOMNodeList,
        pub _base_1: root::nsWrapperCache,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsINodeList_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsINodeList() {
        assert_eq!(::std::mem::size_of::<nsINodeList>() , 32usize , concat ! (
                   "Size of: " , stringify ! ( nsINodeList ) ));
        assert_eq! (::std::mem::align_of::<nsINodeList>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsINodeList ) ));
    }
    /**
 * Presentation shell interface. Presentation shells are the
 * controlling point for managing the presentation of a document. The
 * presentation shell holds a live reference to the document, the
 * presentation context, the style manager, the style set and the root
 * frame. <p>
 *
 * When this object is Release'd, it will release the document, the
 * presentation context, the style manager, the style set and the root
 * frame.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIPresShell {
        pub _base: root::nsISupports,
        pub mDocument: root::nsCOMPtr<root::nsIDocument>,
        pub mPresContext: root::RefPtr<root::nsPresContext>,
        pub mStyleSet: root::mozilla::StyleSetHandle,
        pub mFrameConstructor: *mut root::nsCSSFrameConstructor,
        pub mViewManager: *mut root::nsViewManager,
        pub mFrameArena: root::nsPresArena,
        pub mSelection: root::RefPtr<root::nsFrameSelection>,
        pub mFrameManager: *mut root::nsFrameManagerBase,
        pub mForwardingContainer: u64,
        pub mDocAccessible: *mut root::mozilla::a11y::DocAccessible,
        pub mReflowContinueTimer: root::nsCOMPtr<root::nsITimer>,
        pub mPaintCount: u64,
        pub mScrollPositionClampingScrollPortSize: root::nsSize,
        pub mWeakFrames: *mut root::nsWeakFrame,
        pub mCanvasBackgroundColor: root::nscolor,
        pub mResolution: [u32; 2usize],
        pub mSelectionFlags: i16,
        pub mRenderFlags: root::nsIPresShell_RenderFlags,
        pub _bitfield_1: u8,
        pub _bitfield_2: u8,
        pub mPresShellId: u32,
        pub mChangedScopeStyleRoots: [u64; 3usize],
        pub mFontSizeInflationEmPerLine: u32,
        pub mFontSizeInflationMinTwips: u32,
        pub mFontSizeInflationLineThreshold: u32,
        pub mFontSizeInflationForceEnabled: bool,
        pub mFontSizeInflationDisabledInMasterProcess: bool,
        pub mFontSizeInflationEnabled: bool,
        pub mPaintingIsFrozen: bool,
        pub mFontSizeInflationEnabledIsDirty: bool,
        pub mIsNeverPainting: bool,
        pub mInFlush: bool,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIPresShell_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub type nsIPresShell_LayerManager = root::mozilla::layers::LayerManager;
    pub type nsIPresShell_SourceSurface = root::mozilla::gfx::SourceSurface;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_eRenderFlag {
        STATE_IGNORING_VIEWPORT_SCROLLING = 1,
        STATE_DRAWWINDOW_NOT_FLUSHING = 2,
    }
    pub type nsIPresShell_RenderFlags = u8;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_ScrollDirection {
        eHorizontal = 0,
        eVertical = 1,
        eEither = 2,
    }
    #[repr(u32)]
    /**
   * Tell the pres shell that a frame needs to be marked dirty and needs
   * Reflow.  It's OK if this is an ancestor of the frame needing reflow as
   * long as the ancestor chain between them doesn't cross a reflow root.
   *
   * The bit to add should be NS_FRAME_IS_DIRTY, NS_FRAME_HAS_DIRTY_CHILDREN
   * or nsFrameState(0); passing 0 means that dirty bits won't be set on the
   * frame or its ancestors/descendants, but that intrinsic widths will still
   * be marked dirty.  Passing aIntrinsicDirty = eResize and aBitToAdd = 0
   * would result in no work being done, so don't do that.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_IntrinsicDirty {
        eResize = 0,
        eTreeChange = 1,
        eStyleChange = 2,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_ReflowRootHandling {
        ePositionOrSizeChange = 0,
        eNoPositionOrSizeChange = 1,
        eInferFromBitToAdd = 2,
    }
    pub const nsIPresShell_SCROLL_TOP: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_TOP;
    pub const nsIPresShell_SCROLL_BOTTOM: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_BOTTOM;
    pub const nsIPresShell_SCROLL_LEFT: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_TOP;
    pub const nsIPresShell_SCROLL_RIGHT: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_BOTTOM;
    pub const nsIPresShell_SCROLL_CENTER: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_CENTER;
    pub const nsIPresShell_SCROLL_MINIMUM: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_MINIMUM;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell__bindgen_ty_1 {
        SCROLL_TOP = 0,
        SCROLL_BOTTOM = 100,
        SCROLL_CENTER = 50,
        SCROLL_MINIMUM = -1,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_WhenToScroll {
        SCROLL_ALWAYS = 0,
        SCROLL_IF_NOT_VISIBLE = 1,
        SCROLL_IF_NOT_FULLY_VISIBLE = 2,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIPresShell_ScrollAxis {
        pub _bindgen_opaque_blob: u32,
    }
    #[test]
    fn bindgen_test_layout_nsIPresShell_ScrollAxis() {
        assert_eq!(::std::mem::size_of::<nsIPresShell_ScrollAxis>() , 4usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIPresShell_ScrollAxis ) ));
        assert_eq! (::std::mem::align_of::<nsIPresShell_ScrollAxis>() , 4usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsIPresShell_ScrollAxis )
                    ));
    }
    impl Clone for nsIPresShell_ScrollAxis {
        fn clone(&self) -> Self { *self }
    }
    pub const nsIPresShell_SCROLL_FIRST_ANCESTOR_ONLY:
              root::nsIPresShell__bindgen_ty_2 =
        nsIPresShell__bindgen_ty_2::SCROLL_FIRST_ANCESTOR_ONLY;
    pub const nsIPresShell_SCROLL_OVERFLOW_HIDDEN:
              root::nsIPresShell__bindgen_ty_2 =
        nsIPresShell__bindgen_ty_2::SCROLL_OVERFLOW_HIDDEN;
    pub const nsIPresShell_SCROLL_NO_PARENT_FRAMES:
              root::nsIPresShell__bindgen_ty_2 =
        nsIPresShell__bindgen_ty_2::SCROLL_NO_PARENT_FRAMES;
    pub const nsIPresShell_SCROLL_SMOOTH: root::nsIPresShell__bindgen_ty_2 =
        nsIPresShell__bindgen_ty_2::SCROLL_SMOOTH;
    pub const nsIPresShell_SCROLL_SMOOTH_AUTO:
              root::nsIPresShell__bindgen_ty_2 =
        nsIPresShell__bindgen_ty_2::SCROLL_SMOOTH_AUTO;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell__bindgen_ty_2 {
        SCROLL_FIRST_ANCESTOR_ONLY = 1,
        SCROLL_OVERFLOW_HIDDEN = 2,
        SCROLL_NO_PARENT_FRAMES = 4,
        SCROLL_SMOOTH = 8,
        SCROLL_SMOOTH_AUTO = 16,
    }
    pub const nsIPresShell_RENDER_IS_UNTRUSTED:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_IS_UNTRUSTED;
    pub const nsIPresShell_RENDER_IGNORE_VIEWPORT_SCROLLING:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_IGNORE_VIEWPORT_SCROLLING;
    pub const nsIPresShell_RENDER_CARET: root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_CARET;
    pub const nsIPresShell_RENDER_USE_WIDGET_LAYERS:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_USE_WIDGET_LAYERS;
    pub const nsIPresShell_RENDER_ASYNC_DECODE_IMAGES:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_ASYNC_DECODE_IMAGES;
    pub const nsIPresShell_RENDER_DOCUMENT_RELATIVE:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_DOCUMENT_RELATIVE;
    pub const nsIPresShell_RENDER_DRAWWINDOW_NOT_FLUSHING:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_DRAWWINDOW_NOT_FLUSHING;
    #[repr(u32)]
    /**
   * Render the document into an arbitrary gfxContext
   * Designed for getting a picture of a document or a piece of a document
   * Note that callers will generally want to call FlushPendingNotifications
   * to get an up-to-date view of the document
   * @param aRect is the region to capture into the offscreen buffer, in the
   * root frame's coordinate system (if aIgnoreViewportScrolling is false)
   * or in the root scrolled frame's coordinate system
   * (if aIgnoreViewportScrolling is true). The coordinates are in appunits.
   * @param aFlags see below;
   *   set RENDER_IS_UNTRUSTED if the contents may be passed to malicious
   * agents. E.g. we might choose not to paint the contents of sensitive widgets
   * such as the file name in a file upload widget, and we might choose not
   * to paint themes.
   *   set RENDER_IGNORE_VIEWPORT_SCROLLING to ignore
   * clipping and scrollbar painting due to scrolling in the viewport
   *   set RENDER_CARET to draw the caret if one would be visible
   * (by default the caret is never drawn)
   *   set RENDER_USE_LAYER_MANAGER to force rendering to go through
   * the layer manager for the window. This may be unexpectedly slow
   * (if the layer manager must read back data from the GPU) or low-quality
   * (if the layer manager reads back pixel data and scales it
   * instead of rendering using the appropriate scaling). It may also
   * slow everything down if the area rendered does not correspond to the
   * normal visible area of the window.
   *   set RENDER_ASYNC_DECODE_IMAGES to avoid having images synchronously
   * decoded during rendering.
   * (by default images decode synchronously with RenderDocument)
   *   set RENDER_DOCUMENT_RELATIVE to render the document as if there has been
   * no scrolling and interpret |aRect| relative to the document instead of the
   * CSS viewport. Only considered if RENDER_IGNORE_VIEWPORT_SCROLLING is set
   * or the document is in ignore viewport scrolling mode
   * (nsIPresShell::SetIgnoreViewportScrolling/IgnoringViewportScrolling).
   * @param aBackgroundColor a background color to render onto
   * @param aRenderedContext the gfxContext to render to. We render so that
   * one CSS pixel in the source document is rendered to one unit in the current
   * transform.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell__bindgen_ty_3 {
        RENDER_IS_UNTRUSTED = 1,
        RENDER_IGNORE_VIEWPORT_SCROLLING = 2,
        RENDER_CARET = 4,
        RENDER_USE_WIDGET_LAYERS = 8,
        RENDER_ASYNC_DECODE_IMAGES = 16,
        RENDER_DOCUMENT_RELATIVE = 32,
        RENDER_DRAWWINDOW_NOT_FLUSHING = 64,
    }
    pub const nsIPresShell_RENDER_IS_IMAGE: root::nsIPresShell__bindgen_ty_4 =
        nsIPresShell__bindgen_ty_4::RENDER_IS_IMAGE;
    pub const nsIPresShell_RENDER_AUTO_SCALE: root::nsIPresShell__bindgen_ty_4
              =
        nsIPresShell__bindgen_ty_4::RENDER_AUTO_SCALE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell__bindgen_ty_4 {
        RENDER_IS_IMAGE = 256,
        RENDER_AUTO_SCALE = 128,
    }
    pub const nsIPresShell_FORCE_DRAW: root::nsIPresShell__bindgen_ty_5 =
        nsIPresShell__bindgen_ty_5::FORCE_DRAW;
    #[repr(u32)]
    /**
   * Add a solid color item to the bottom of aList with frame aFrame and bounds
   * aBounds. Checks first if this needs to be done by checking if aFrame is a
   * canvas frame (if the FORCE_DRAW flag is passed then this check is skipped).
   * aBackstopColor is composed behind the background color of the canvas, it is
   * transparent by default.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell__bindgen_ty_5 { FORCE_DRAW = 1, }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIPresShell_PointerCaptureInfo {
        pub mPendingContent: root::nsCOMPtr<root::nsIContent>,
        pub mOverrideContent: root::nsCOMPtr<root::nsIContent>,
    }
    #[test]
    fn bindgen_test_layout_nsIPresShell_PointerCaptureInfo() {
        assert_eq!(::std::mem::size_of::<nsIPresShell_PointerCaptureInfo>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( nsIPresShell_PointerCaptureInfo
                   ) ));
        assert_eq! (::std::mem::align_of::<nsIPresShell_PointerCaptureInfo>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsIPresShell_PointerCaptureInfo ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell_PointerCaptureInfo ) ) .
                    mPendingContent as * const _ as usize } , 0usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsIPresShell_PointerCaptureInfo ) , "::" , stringify ! (
                    mPendingContent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell_PointerCaptureInfo ) ) .
                    mOverrideContent as * const _ as usize } , 8usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsIPresShell_PointerCaptureInfo ) , "::" , stringify ! (
                    mOverrideContent ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIPresShell_PointerInfo {
        pub mPointerType: u16,
        pub mActiveState: bool,
        pub mPrimaryState: bool,
        pub mPreventMouseEventByContent: bool,
    }
    #[test]
    fn bindgen_test_layout_nsIPresShell_PointerInfo() {
        assert_eq!(::std::mem::size_of::<nsIPresShell_PointerInfo>() , 6usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsIPresShell_PointerInfo ) ));
        assert_eq! (::std::mem::align_of::<nsIPresShell_PointerInfo>() ,
                    2usize , concat ! (
                    "Alignment of " , stringify ! ( nsIPresShell_PointerInfo )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell_PointerInfo ) ) .
                    mPointerType as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsIPresShell_PointerInfo ) , "::" , stringify ! (
                    mPointerType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell_PointerInfo ) ) .
                    mActiveState as * const _ as usize } , 2usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsIPresShell_PointerInfo ) , "::" , stringify ! (
                    mActiveState ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell_PointerInfo ) ) .
                    mPrimaryState as * const _ as usize } , 3usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsIPresShell_PointerInfo ) , "::" , stringify ! (
                    mPrimaryState ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell_PointerInfo ) ) .
                    mPreventMouseEventByContent as * const _ as usize } ,
                    4usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsIPresShell_PointerInfo ) , "::" , stringify ! (
                    mPreventMouseEventByContent ) ));
    }
    impl Clone for nsIPresShell_PointerInfo {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_PaintFlags {
        PAINT_LAYERS = 1,
        PAINT_COMPOSITE = 2,
        PAINT_SYNC_DECODE_IMAGES = 4,
    }
    #[repr(u32)]
    /**
   * Ensures that the refresh driver is running, and schedules a view
   * manager flush on the next tick.
   *
   * @param aType PAINT_DELAYED_COMPRESS : Schedule a paint to be executed after a delay, and
   * put FrameLayerBuilder in 'compressed' mode that avoids short cut optimizations.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_PaintType {
        PAINT_DEFAULT = 0,
        PAINT_DELAYED_COMPRESS = 1,
    }
    extern "C" {
        #[link_name = "_ZN12nsIPresShell12gCaptureInfoE"]
        pub static mut nsIPresShell_gCaptureInfo: root::CapturingContentInfo;
    }
    extern "C" {
        #[link_name = "_ZN12nsIPresShell14gKeyDownTargetE"]
        pub static mut nsIPresShell_gKeyDownTarget: *mut root::nsIContent;
    }
    #[test]
    fn bindgen_test_layout_nsIPresShell() {
        assert_eq!(::std::mem::size_of::<nsIPresShell>() , 320usize , concat !
                   ( "Size of: " , stringify ! ( nsIPresShell ) ));
        assert_eq! (::std::mem::align_of::<nsIPresShell>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsIPresShell ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mDocument as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mDocument ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mPresContext as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mPresContext ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mStyleSet as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mStyleSet ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mFrameConstructor
                    as * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFrameConstructor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mViewManager as *
                    const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mViewManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mFrameArena as *
                    const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFrameArena ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mSelection as *
                    const _ as usize } , 184usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mSelection ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mFrameManager as *
                    const _ as usize } , 192usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFrameManager ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mForwardingContainer as * const _ as usize } , 200usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mForwardingContainer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mDocAccessible as
                    * const _ as usize } , 208usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mDocAccessible ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mReflowContinueTimer as * const _ as usize } , 216usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mReflowContinueTimer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mPaintCount as *
                    const _ as usize } , 224usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mPaintCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mScrollPositionClampingScrollPortSize as * const _ as
                    usize } , 232usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mScrollPositionClampingScrollPortSize
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mWeakFrames as *
                    const _ as usize } , 240usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mWeakFrames ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mCanvasBackgroundColor as * const _ as usize } , 248usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mCanvasBackgroundColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mResolution as *
                    const _ as usize } , 252usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mResolution ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mSelectionFlags as
                    * const _ as usize } , 260usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mSelectionFlags ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mRenderFlags as *
                    const _ as usize } , 262usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mRenderFlags ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mPresShellId as *
                    const _ as usize } , 268usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mPresShellId ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mChangedScopeStyleRoots as * const _ as usize } , 272usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mChangedScopeStyleRoots ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mFontSizeInflationEmPerLine as * const _ as usize } ,
                    296usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFontSizeInflationEmPerLine ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mFontSizeInflationMinTwips as * const _ as usize } ,
                    300usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFontSizeInflationMinTwips ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mFontSizeInflationLineThreshold as * const _ as usize } ,
                    304usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFontSizeInflationLineThreshold ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mFontSizeInflationForceEnabled as * const _ as usize } ,
                    308usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFontSizeInflationForceEnabled ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mFontSizeInflationDisabledInMasterProcess as * const _ as
                    usize } , 309usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! (
                    mFontSizeInflationDisabledInMasterProcess ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mFontSizeInflationEnabled as * const _ as usize } ,
                    310usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFontSizeInflationEnabled ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mPaintingIsFrozen
                    as * const _ as usize } , 311usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mPaintingIsFrozen ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) .
                    mFontSizeInflationEnabledIsDirty as * const _ as usize } ,
                    312usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mFontSizeInflationEnabledIsDirty )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mIsNeverPainting
                    as * const _ as usize } , 313usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mIsNeverPainting ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIPresShell ) ) . mInFlush as *
                    const _ as usize } , 314usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIPresShell ) ,
                    "::" , stringify ! ( mInFlush ) ));
    }
    /**
 * A class that implements nsIWeakReference
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsNodeWeakReference {
        pub _base: root::nsIWeakReference,
        pub mRefCnt: root::nsAutoRefCnt,
        pub mNode: *mut root::nsINode,
    }
    pub type nsNodeWeakReference_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsNodeWeakReference() {
        assert_eq!(::std::mem::size_of::<nsNodeWeakReference>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsNodeWeakReference ) ));
        assert_eq! (::std::mem::align_of::<nsNodeWeakReference>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsNodeWeakReference ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeWeakReference ) ) . mRefCnt as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeWeakReference
                    ) , "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsNodeWeakReference ) ) . mNode as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsNodeWeakReference
                    ) , "::" , stringify ! ( mNode ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDOMMutationObserver([u8; 0]);
    pub const NODE_HAS_LISTENERMANAGER: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_HAS_LISTENERMANAGER;
    pub const NODE_HAS_PROPERTIES: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_HAS_PROPERTIES;
    pub const NODE_IS_ANONYMOUS_ROOT: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_IS_ANONYMOUS_ROOT;
    pub const NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE;
    pub const NODE_IS_NATIVE_ANONYMOUS_ROOT: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_IS_NATIVE_ANONYMOUS_ROOT;
    pub const NODE_FORCE_XBL_BINDINGS: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_FORCE_XBL_BINDINGS;
    pub const NODE_MAY_BE_IN_BINDING_MNGR: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_MAY_BE_IN_BINDING_MNGR;
    pub const NODE_IS_EDITABLE: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_IS_EDITABLE;
    pub const NODE_IS_NATIVE_ANONYMOUS: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_IS_NATIVE_ANONYMOUS;
    pub const NODE_IS_IN_SHADOW_TREE: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_IS_IN_SHADOW_TREE;
    pub const NODE_HAS_EMPTY_SELECTOR: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_HAS_EMPTY_SELECTOR;
    pub const NODE_HAS_SLOW_SELECTOR: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_HAS_SLOW_SELECTOR;
    pub const NODE_HAS_EDGE_CHILD_SELECTOR: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_HAS_EDGE_CHILD_SELECTOR;
    pub const NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS;
    pub const NODE_ALL_SELECTOR_FLAGS: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_ALL_SELECTOR_FLAGS;
    pub const NODE_NEEDS_FRAME: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_NEEDS_FRAME;
    pub const NODE_DESCENDANTS_NEED_FRAMES: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_DESCENDANTS_NEED_FRAMES;
    pub const NODE_HAS_ACCESSKEY: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_HAS_ACCESSKEY;
    pub const NODE_HAS_DIRECTION_RTL: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_HAS_DIRECTION_RTL;
    pub const NODE_HAS_DIRECTION_LTR: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_HAS_DIRECTION_LTR;
    pub const NODE_ALL_DIRECTION_FLAGS: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_ALL_DIRECTION_FLAGS;
    pub const NODE_CHROME_ONLY_ACCESS: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_CHROME_ONLY_ACCESS;
    pub const NODE_IS_ROOT_OF_CHROME_ONLY_ACCESS: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_IS_ROOT_OF_CHROME_ONLY_ACCESS;
    pub const NODE_SHARED_RESTYLE_BIT_1: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_SHARED_RESTYLE_BIT_1;
    pub const NODE_SHARED_RESTYLE_BIT_2: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_SHARED_RESTYLE_BIT_2;
    pub const NODE_HAS_DIRTY_DESCENDANTS_FOR_SERVO: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_SHARED_RESTYLE_BIT_1;
    pub const NODE_TYPE_SPECIFIC_BITS_OFFSET: root::_bindgen_ty_105 =
        _bindgen_ty_105::NODE_TYPE_SPECIFIC_BITS_OFFSET;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum _bindgen_ty_105 {
        NODE_HAS_LISTENERMANAGER = 4,
        NODE_HAS_PROPERTIES = 8,
        NODE_IS_ANONYMOUS_ROOT = 16,
        NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE = 32,
        NODE_IS_NATIVE_ANONYMOUS_ROOT = 64,
        NODE_FORCE_XBL_BINDINGS = 128,
        NODE_MAY_BE_IN_BINDING_MNGR = 256,
        NODE_IS_EDITABLE = 512,
        NODE_IS_NATIVE_ANONYMOUS = 1024,
        NODE_IS_IN_SHADOW_TREE = 2048,
        NODE_HAS_EMPTY_SELECTOR = 4096,
        NODE_HAS_SLOW_SELECTOR = 8192,
        NODE_HAS_EDGE_CHILD_SELECTOR = 16384,
        NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS = 32768,
        NODE_ALL_SELECTOR_FLAGS = 61440,
        NODE_NEEDS_FRAME = 65536,
        NODE_DESCENDANTS_NEED_FRAMES = 131072,
        NODE_HAS_ACCESSKEY = 262144,
        NODE_HAS_DIRECTION_RTL = 524288,
        NODE_HAS_DIRECTION_LTR = 1048576,
        NODE_ALL_DIRECTION_FLAGS = 1572864,
        NODE_CHROME_ONLY_ACCESS = 2097152,
        NODE_IS_ROOT_OF_CHROME_ONLY_ACCESS = 4194304,
        NODE_SHARED_RESTYLE_BIT_1 = 8388608,
        NODE_SHARED_RESTYLE_BIT_2 = 16777216,
        NODE_TYPE_SPECIFIC_BITS_OFFSET = 23,
    }
    pub type nscoord = i32;
    pub type nsIntPoint = root::mozilla::gfx::IntPoint;
    /**
 * Currently needs to be 'double' for Cairo compatibility. Could
 * become 'float', perhaps, in some configurations.
 */
    pub type gfxFloat = f64;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct gfxSize {
        pub _bindgen_opaque_blob: [u64; 2usize],
    }
    pub type gfxSize_Super = [u64; 2usize];
    #[test]
    fn bindgen_test_layout_gfxSize() {
        assert_eq!(::std::mem::size_of::<gfxSize>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( gfxSize ) ));
        assert_eq! (::std::mem::align_of::<gfxSize>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( gfxSize ) ));
    }
    impl Clone for gfxSize {
        fn clone(&self) -> Self { *self }
    }
    pub type nsIntMargin = root::mozilla::gfx::IntMargin;
    pub type nsIntRect = root::mozilla::gfx::IntRect;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct pixman_region32_data {
        pub size: ::std::os::raw::c_long,
        pub numRects: ::std::os::raw::c_long,
    }
    #[test]
    fn bindgen_test_layout_pixman_region32_data() {
        assert_eq!(::std::mem::size_of::<pixman_region32_data>() , 16usize ,
                   concat ! (
                   "Size of: " , stringify ! ( pixman_region32_data ) ));
        assert_eq! (::std::mem::align_of::<pixman_region32_data>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( pixman_region32_data ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const pixman_region32_data ) ) . size as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    pixman_region32_data ) , "::" , stringify ! ( size ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const pixman_region32_data ) ) . numRects
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    pixman_region32_data ) , "::" , stringify ! ( numRects )
                    ));
    }
    impl Clone for pixman_region32_data {
        fn clone(&self) -> Self { *self }
    }
    pub type pixman_region32_data_t = root::pixman_region32_data;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct pixman_box32 {
        pub x1: i32,
        pub y1: i32,
        pub x2: i32,
        pub y2: i32,
    }
    #[test]
    fn bindgen_test_layout_pixman_box32() {
        assert_eq!(::std::mem::size_of::<pixman_box32>() , 16usize , concat !
                   ( "Size of: " , stringify ! ( pixman_box32 ) ));
        assert_eq! (::std::mem::align_of::<pixman_box32>() , 4usize , concat !
                    ( "Alignment of " , stringify ! ( pixman_box32 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const pixman_box32 ) ) . x1 as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( pixman_box32 ) ,
                    "::" , stringify ! ( x1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const pixman_box32 ) ) . y1 as * const _ as
                    usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( pixman_box32 ) ,
                    "::" , stringify ! ( y1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const pixman_box32 ) ) . x2 as * const _ as
                    usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( pixman_box32 ) ,
                    "::" , stringify ! ( x2 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const pixman_box32 ) ) . y2 as * const _ as
                    usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( pixman_box32 ) ,
                    "::" , stringify ! ( y2 ) ));
    }
    impl Clone for pixman_box32 {
        fn clone(&self) -> Self { *self }
    }
    pub type pixman_box32_t = root::pixman_box32;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct pixman_region32 {
        pub extents: root::pixman_box32_t,
        pub data: *mut root::pixman_region32_data_t,
    }
    #[test]
    fn bindgen_test_layout_pixman_region32() {
        assert_eq!(::std::mem::size_of::<pixman_region32>() , 24usize , concat
                   ! ( "Size of: " , stringify ! ( pixman_region32 ) ));
        assert_eq! (::std::mem::align_of::<pixman_region32>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( pixman_region32 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const pixman_region32 ) ) . extents as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( pixman_region32 ) ,
                    "::" , stringify ! ( extents ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const pixman_region32 ) ) . data as * const
                    _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( pixman_region32 ) ,
                    "::" , stringify ! ( data ) ));
    }
    impl Clone for pixman_region32 {
        fn clone(&self) -> Self { *self }
    }
    pub type pixman_region32_t = root::pixman_region32;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum VisitSide { TOP = 0, BOTTOM = 1, LEFT = 2, RIGHT = 3, }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsContentList([u8; 0]);
    /**
 * The signature of the timer callback function passed to initWithFuncCallback.
 * This is the function that will get called when the timer expires if the
 * timer is initialized via initWithFuncCallback.
 *
 * @param aTimer the timer which has expired
 * @param aClosure opaque parameter passed to initWithFuncCallback
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsITimer {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsITimer_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const nsITimer_TYPE_ONE_SHOT: root::nsITimer__bindgen_ty_1 =
        nsITimer__bindgen_ty_1::TYPE_ONE_SHOT;
    pub const nsITimer_TYPE_REPEATING_SLACK: root::nsITimer__bindgen_ty_1 =
        nsITimer__bindgen_ty_1::TYPE_REPEATING_SLACK;
    pub const nsITimer_TYPE_REPEATING_PRECISE: root::nsITimer__bindgen_ty_1 =
        nsITimer__bindgen_ty_1::TYPE_REPEATING_PRECISE;
    pub const nsITimer_TYPE_REPEATING_PRECISE_CAN_SKIP:
              root::nsITimer__bindgen_ty_1 =
        nsITimer__bindgen_ty_1::TYPE_REPEATING_PRECISE_CAN_SKIP;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsITimer__bindgen_ty_1 {
        TYPE_ONE_SHOT = 0,
        TYPE_REPEATING_SLACK = 1,
        TYPE_REPEATING_PRECISE = 2,
        TYPE_REPEATING_PRECISE_CAN_SKIP = 3,
    }
    #[test]
    fn bindgen_test_layout_nsITimer() {
        assert_eq!(::std::mem::size_of::<nsITimer>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsITimer ) ));
        assert_eq! (::std::mem::align_of::<nsITimer>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsITimer ) ));
    }
    impl Clone for nsITimer {
        fn clone(&self) -> Self { *self }
    }
    pub type nsTimerCallbackFunc =
        ::std::option::Option<unsafe extern "C" fn(aTimer:
                                                       *mut root::nsITimer,
                                                   aClosure:
                                                       *mut ::std::os::raw::c_void)>;
    /**
 * The signature of the timer name callback function passed to
 * initWithNameableFuncCallback.
 * This is the function that will get called when timer profiling is enabled
 * via the "TimerFirings" log module.
 *
 * @param aTimer the timer which has expired
 * @param aAnonymize whether the name should avoid including privacy sensitive info
 * @param aClosure opaque parameter passed to initWithFuncCallback
 * @param aBuf a buffer in which to put the name
 * @param aLen the length of the buffer
 */
    pub type nsTimerNameCallbackFunc =
        ::std::option::Option<unsafe extern "C" fn(aTimer:
                                                       *mut root::nsITimer,
                                                   aAnonymize: bool,
                                                   aClosure:
                                                       *mut ::std::os::raw::c_void,
                                                   aBuf:
                                                       *mut ::std::os::raw::c_char,
                                                   aLen: usize)>;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsITimerCallback {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsITimerCallback_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsITimerCallback() {
        assert_eq!(::std::mem::size_of::<nsITimerCallback>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsITimerCallback ) ));
        assert_eq! (::std::mem::align_of::<nsITimerCallback>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsITimerCallback ) ));
    }
    impl Clone for nsITimerCallback {
        fn clone(&self) -> Self { *self }
    }
    /**
 * Data used to track the expiration state of an object. We promise that this
 * is 32 bits so that objects that includes this as a field can pad and align
 * efficiently.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsExpirationState {
        pub _bitfield_1: u32,
        pub __bindgen_align: [u32; 0usize],
    }
    pub const nsExpirationState_NOT_TRACKED:
              root::nsExpirationState__bindgen_ty_1 =
        nsExpirationState__bindgen_ty_1::NOT_TRACKED;
    pub const nsExpirationState_MAX_INDEX_IN_GENERATION:
              root::nsExpirationState__bindgen_ty_1 =
        nsExpirationState__bindgen_ty_1::MAX_INDEX_IN_GENERATION;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsExpirationState__bindgen_ty_1 {
        NOT_TRACKED = 15,
        MAX_INDEX_IN_GENERATION = 268435455,
    }
    #[test]
    fn bindgen_test_layout_nsExpirationState() {
        assert_eq!(::std::mem::size_of::<nsExpirationState>() , 4usize ,
                   concat ! ( "Size of: " , stringify ! ( nsExpirationState )
                   ));
        assert_eq! (::std::mem::align_of::<nsExpirationState>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsExpirationState ) ));
    }
    impl Clone for nsExpirationState {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PRCListStr {
        pub next: *mut root::PRCList,
        pub prev: *mut root::PRCList,
    }
    #[test]
    fn bindgen_test_layout_PRCListStr() {
        assert_eq!(::std::mem::size_of::<PRCListStr>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( PRCListStr ) ));
        assert_eq! (::std::mem::align_of::<PRCListStr>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( PRCListStr ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PRCListStr ) ) . next as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( PRCListStr ) , "::"
                    , stringify ! ( next ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PRCListStr ) ) . prev as * const _ as
                    usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( PRCListStr ) , "::"
                    , stringify ! ( prev ) ));
    }
    impl Clone for PRCListStr {
        fn clone(&self) -> Self { *self }
    }
    pub type PRCList = root::PRCListStr;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct gfxUserFontSet([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct imgIRequest {
        pub _base: root::nsIRequest,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct imgIRequest_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const imgIRequest_STATUS_NONE: root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_NONE;
    pub const imgIRequest_STATUS_SIZE_AVAILABLE:
              root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_SIZE_AVAILABLE;
    pub const imgIRequest_STATUS_LOAD_COMPLETE:
              root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_LOAD_COMPLETE;
    pub const imgIRequest_STATUS_ERROR: root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_ERROR;
    pub const imgIRequest_STATUS_FRAME_COMPLETE:
              root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_FRAME_COMPLETE;
    pub const imgIRequest_STATUS_DECODE_COMPLETE:
              root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_DECODE_COMPLETE;
    pub const imgIRequest_STATUS_IS_ANIMATED: root::imgIRequest__bindgen_ty_1
              =
        imgIRequest__bindgen_ty_1::STATUS_IS_ANIMATED;
    pub const imgIRequest_STATUS_HAS_TRANSPARENCY:
              root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_HAS_TRANSPARENCY;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum imgIRequest__bindgen_ty_1 {
        STATUS_NONE = 0,
        STATUS_SIZE_AVAILABLE = 1,
        STATUS_LOAD_COMPLETE = 2,
        STATUS_ERROR = 4,
        STATUS_FRAME_COMPLETE = 8,
        STATUS_DECODE_COMPLETE = 16,
        STATUS_IS_ANIMATED = 32,
        STATUS_HAS_TRANSPARENCY = 64,
    }
    pub const imgIRequest_CORS_NONE: root::imgIRequest__bindgen_ty_2 =
        imgIRequest__bindgen_ty_2::CORS_NONE;
    pub const imgIRequest_CORS_ANONYMOUS: root::imgIRequest__bindgen_ty_2 =
        imgIRequest__bindgen_ty_2::CORS_ANONYMOUS;
    pub const imgIRequest_CORS_USE_CREDENTIALS:
              root::imgIRequest__bindgen_ty_2 =
        imgIRequest__bindgen_ty_2::CORS_USE_CREDENTIALS;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum imgIRequest__bindgen_ty_2 {
        CORS_NONE = 1,
        CORS_ANONYMOUS = 2,
        CORS_USE_CREDENTIALS = 3,
    }
    #[test]
    fn bindgen_test_layout_imgIRequest() {
        assert_eq!(::std::mem::size_of::<imgIRequest>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( imgIRequest ) ));
        assert_eq! (::std::mem::align_of::<imgIRequest>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( imgIRequest ) ));
    }
    impl Clone for imgIRequest {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDocShell([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDOMNavigationTiming([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsFrameLoader([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsHTMLCSSStyleSheet([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsHTMLStyleSheet([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIBFCacheEntry([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIContentSink([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDocumentEncoder([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMNodeFilter([u8; 0]);
    /**
 * An internal interface
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIHTMLCollection {
        pub _base: root::nsIDOMHTMLCollection,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIHTMLCollection_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIHTMLCollection() {
        assert_eq!(::std::mem::size_of::<nsIHTMLCollection>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsIHTMLCollection )
                   ));
        assert_eq! (::std::mem::align_of::<nsIHTMLCollection>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIHTMLCollection ) ));
    }
    impl Clone for nsIHTMLCollection {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsILayoutHistoryState([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIObjectLoadingContent([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIStructuredCloneContainer([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsViewManager([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsRange([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsScriptLoader([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsSMILAnimationController([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsTextNode([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsWindowSizes([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDOMCaretPosition([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsViewportInfo([u8; 0]);
    pub const nsCSSPropertyID_eCSSProperty_COUNT_DUMMY: root::nsCSSPropertyID
              =
        nsCSSPropertyID::eCSSProperty_z_index;
    pub const nsCSSPropertyID_eCSSProperty_all: root::nsCSSPropertyID =
        nsCSSPropertyID::eCSSProperty_COUNT_no_shorthands;
    pub const nsCSSPropertyID_eCSSProperty_COUNT_DUMMY2: root::nsCSSPropertyID
              =
        nsCSSPropertyID::eCSSProperty_transition;
    pub const nsCSSPropertyID_eCSSPropertyAlias_WordWrap:
              root::nsCSSPropertyID =
        nsCSSPropertyID::eCSSProperty_COUNT;
    pub const nsCSSPropertyID_eCSSProperty_COUNT_DUMMY3: root::nsCSSPropertyID
              =
        nsCSSPropertyID::eCSSPropertyAlias_WebkitMaskSize;
    pub const nsCSSPropertyID_eCSSPropertyExtra_no_properties:
              root::nsCSSPropertyID =
        nsCSSPropertyID::eCSSProperty_COUNT_with_aliases;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSPropertyID {
        eCSSProperty_UNKNOWN = -1,
        eCSSProperty_align_content = 0,
        eCSSProperty_align_items = 1,
        eCSSProperty_align_self = 2,
        eCSSProperty_animation_delay = 3,
        eCSSProperty_animation_direction = 4,
        eCSSProperty_animation_duration = 5,
        eCSSProperty_animation_fill_mode = 6,
        eCSSProperty_animation_iteration_count = 7,
        eCSSProperty_animation_name = 8,
        eCSSProperty_animation_play_state = 9,
        eCSSProperty_animation_timing_function = 10,
        eCSSProperty__moz_appearance = 11,
        eCSSProperty_backface_visibility = 12,
        eCSSProperty_background_attachment = 13,
        eCSSProperty_background_blend_mode = 14,
        eCSSProperty_background_clip = 15,
        eCSSProperty_background_color = 16,
        eCSSProperty_background_image = 17,
        eCSSProperty_background_origin = 18,
        eCSSProperty_background_position_x = 19,
        eCSSProperty_background_position_y = 20,
        eCSSProperty_background_repeat = 21,
        eCSSProperty_background_size = 22,
        eCSSProperty__moz_binding = 23,
        eCSSProperty_block_size = 24,
        eCSSProperty_border_block_end_color = 25,
        eCSSProperty_border_block_end_style = 26,
        eCSSProperty_border_block_end_width = 27,
        eCSSProperty_border_block_start_color = 28,
        eCSSProperty_border_block_start_style = 29,
        eCSSProperty_border_block_start_width = 30,
        eCSSProperty_border_bottom_color = 31,
        eCSSProperty__moz_border_bottom_colors = 32,
        eCSSProperty_border_bottom_left_radius = 33,
        eCSSProperty_border_bottom_right_radius = 34,
        eCSSProperty_border_bottom_style = 35,
        eCSSProperty_border_bottom_width = 36,
        eCSSProperty_border_collapse = 37,
        eCSSProperty_border_image_outset = 38,
        eCSSProperty_border_image_repeat = 39,
        eCSSProperty_border_image_slice = 40,
        eCSSProperty_border_image_source = 41,
        eCSSProperty_border_image_width = 42,
        eCSSProperty_border_inline_end_color = 43,
        eCSSProperty_border_inline_end_style = 44,
        eCSSProperty_border_inline_end_width = 45,
        eCSSProperty_border_inline_start_color = 46,
        eCSSProperty_border_inline_start_style = 47,
        eCSSProperty_border_inline_start_width = 48,
        eCSSProperty_border_left_color = 49,
        eCSSProperty__moz_border_left_colors = 50,
        eCSSProperty_border_left_style = 51,
        eCSSProperty_border_left_width = 52,
        eCSSProperty_border_right_color = 53,
        eCSSProperty__moz_border_right_colors = 54,
        eCSSProperty_border_right_style = 55,
        eCSSProperty_border_right_width = 56,
        eCSSProperty_border_spacing = 57,
        eCSSProperty_border_top_color = 58,
        eCSSProperty__moz_border_top_colors = 59,
        eCSSProperty_border_top_left_radius = 60,
        eCSSProperty_border_top_right_radius = 61,
        eCSSProperty_border_top_style = 62,
        eCSSProperty_border_top_width = 63,
        eCSSProperty_bottom = 64,
        eCSSProperty__moz_box_align = 65,
        eCSSProperty_box_decoration_break = 66,
        eCSSProperty__moz_box_direction = 67,
        eCSSProperty__moz_box_flex = 68,
        eCSSProperty__moz_box_ordinal_group = 69,
        eCSSProperty__moz_box_orient = 70,
        eCSSProperty__moz_box_pack = 71,
        eCSSProperty_box_shadow = 72,
        eCSSProperty_box_sizing = 73,
        eCSSProperty_caption_side = 74,
        eCSSProperty_caret_color = 75,
        eCSSProperty_clear = 76,
        eCSSProperty_clip = 77,
        eCSSProperty_clip_path = 78,
        eCSSProperty_clip_rule = 79,
        eCSSProperty_color = 80,
        eCSSProperty_color_adjust = 81,
        eCSSProperty_color_interpolation = 82,
        eCSSProperty_color_interpolation_filters = 83,
        eCSSProperty_column_count = 84,
        eCSSProperty_column_fill = 85,
        eCSSProperty_column_gap = 86,
        eCSSProperty_column_rule_color = 87,
        eCSSProperty_column_rule_style = 88,
        eCSSProperty_column_rule_width = 89,
        eCSSProperty_column_width = 90,
        eCSSProperty_contain = 91,
        eCSSProperty_content = 92,
        eCSSProperty__moz_control_character_visibility = 93,
        eCSSProperty_counter_increment = 94,
        eCSSProperty_counter_reset = 95,
        eCSSProperty_cursor = 96,
        eCSSProperty_direction = 97,
        eCSSProperty_display = 98,
        eCSSProperty_dominant_baseline = 99,
        eCSSProperty_empty_cells = 100,
        eCSSProperty_fill = 101,
        eCSSProperty_fill_opacity = 102,
        eCSSProperty_fill_rule = 103,
        eCSSProperty_filter = 104,
        eCSSProperty_flex_basis = 105,
        eCSSProperty_flex_direction = 106,
        eCSSProperty_flex_grow = 107,
        eCSSProperty_flex_shrink = 108,
        eCSSProperty_flex_wrap = 109,
        eCSSProperty_float_ = 110,
        eCSSProperty__moz_float_edge = 111,
        eCSSProperty_flood_color = 112,
        eCSSProperty_flood_opacity = 113,
        eCSSProperty_font_family = 114,
        eCSSProperty_font_feature_settings = 115,
        eCSSProperty_font_kerning = 116,
        eCSSProperty_font_language_override = 117,
        eCSSProperty_font_size = 118,
        eCSSProperty_font_size_adjust = 119,
        eCSSProperty_font_stretch = 120,
        eCSSProperty_font_style = 121,
        eCSSProperty_font_synthesis = 122,
        eCSSProperty_font_variant_alternates = 123,
        eCSSProperty_font_variant_caps = 124,
        eCSSProperty_font_variant_east_asian = 125,
        eCSSProperty_font_variant_ligatures = 126,
        eCSSProperty_font_variant_numeric = 127,
        eCSSProperty_font_variant_position = 128,
        eCSSProperty_font_variation_settings = 129,
        eCSSProperty_font_weight = 130,
        eCSSProperty__moz_force_broken_image_icon = 131,
        eCSSProperty_grid_auto_columns = 132,
        eCSSProperty_grid_auto_flow = 133,
        eCSSProperty_grid_auto_rows = 134,
        eCSSProperty_grid_column_end = 135,
        eCSSProperty_grid_column_gap = 136,
        eCSSProperty_grid_column_start = 137,
        eCSSProperty_grid_row_end = 138,
        eCSSProperty_grid_row_gap = 139,
        eCSSProperty_grid_row_start = 140,
        eCSSProperty_grid_template_areas = 141,
        eCSSProperty_grid_template_columns = 142,
        eCSSProperty_grid_template_rows = 143,
        eCSSProperty_height = 144,
        eCSSProperty_hyphens = 145,
        eCSSProperty_initial_letter = 146,
        eCSSProperty_image_orientation = 147,
        eCSSProperty__moz_image_region = 148,
        eCSSProperty_image_rendering = 149,
        eCSSProperty_ime_mode = 150,
        eCSSProperty_inline_size = 151,
        eCSSProperty_isolation = 152,
        eCSSProperty_justify_content = 153,
        eCSSProperty_justify_items = 154,
        eCSSProperty_justify_self = 155,
        eCSSProperty__x_lang = 156,
        eCSSProperty_left = 157,
        eCSSProperty_letter_spacing = 158,
        eCSSProperty_lighting_color = 159,
        eCSSProperty_line_height = 160,
        eCSSProperty_list_style_image = 161,
        eCSSProperty_list_style_position = 162,
        eCSSProperty_list_style_type = 163,
        eCSSProperty_margin_block_end = 164,
        eCSSProperty_margin_block_start = 165,
        eCSSProperty_margin_bottom = 166,
        eCSSProperty_margin_inline_end = 167,
        eCSSProperty_margin_inline_start = 168,
        eCSSProperty_margin_left = 169,
        eCSSProperty_margin_right = 170,
        eCSSProperty_margin_top = 171,
        eCSSProperty_marker_end = 172,
        eCSSProperty_marker_mid = 173,
        eCSSProperty_marker_start = 174,
        eCSSProperty_mask_clip = 175,
        eCSSProperty_mask_composite = 176,
        eCSSProperty_mask_image = 177,
        eCSSProperty_mask_mode = 178,
        eCSSProperty_mask_origin = 179,
        eCSSProperty_mask_position_x = 180,
        eCSSProperty_mask_position_y = 181,
        eCSSProperty_mask_repeat = 182,
        eCSSProperty_mask_size = 183,
        eCSSProperty_mask_type = 184,
        eCSSProperty__moz_math_display = 185,
        eCSSProperty__moz_math_variant = 186,
        eCSSProperty_max_block_size = 187,
        eCSSProperty_max_height = 188,
        eCSSProperty_max_inline_size = 189,
        eCSSProperty_max_width = 190,
        eCSSProperty_min_block_size = 191,
        eCSSProperty__moz_min_font_size_ratio = 192,
        eCSSProperty_min_height = 193,
        eCSSProperty_min_inline_size = 194,
        eCSSProperty_min_width = 195,
        eCSSProperty_mix_blend_mode = 196,
        eCSSProperty_object_fit = 197,
        eCSSProperty_object_position = 198,
        eCSSProperty_offset_block_end = 199,
        eCSSProperty_offset_block_start = 200,
        eCSSProperty_offset_inline_end = 201,
        eCSSProperty_offset_inline_start = 202,
        eCSSProperty_opacity = 203,
        eCSSProperty_order = 204,
        eCSSProperty__moz_orient = 205,
        eCSSProperty__moz_osx_font_smoothing = 206,
        eCSSProperty_outline_color = 207,
        eCSSProperty_outline_offset = 208,
        eCSSProperty__moz_outline_radius_bottomleft = 209,
        eCSSProperty__moz_outline_radius_bottomright = 210,
        eCSSProperty__moz_outline_radius_topleft = 211,
        eCSSProperty__moz_outline_radius_topright = 212,
        eCSSProperty_outline_style = 213,
        eCSSProperty_outline_width = 214,
        eCSSProperty_overflow_clip_box = 215,
        eCSSProperty_overflow_x = 216,
        eCSSProperty_overflow_y = 217,
        eCSSProperty_padding_block_end = 218,
        eCSSProperty_padding_block_start = 219,
        eCSSProperty_padding_bottom = 220,
        eCSSProperty_padding_inline_end = 221,
        eCSSProperty_padding_inline_start = 222,
        eCSSProperty_padding_left = 223,
        eCSSProperty_padding_right = 224,
        eCSSProperty_padding_top = 225,
        eCSSProperty_page_break_after = 226,
        eCSSProperty_page_break_before = 227,
        eCSSProperty_page_break_inside = 228,
        eCSSProperty_paint_order = 229,
        eCSSProperty_perspective = 230,
        eCSSProperty_perspective_origin = 231,
        eCSSProperty_pointer_events = 232,
        eCSSProperty_position = 233,
        eCSSProperty_quotes = 234,
        eCSSProperty_resize = 235,
        eCSSProperty_right = 236,
        eCSSProperty_ruby_align = 237,
        eCSSProperty_ruby_position = 238,
        eCSSProperty__moz_script_level = 239,
        eCSSProperty__moz_script_min_size = 240,
        eCSSProperty__moz_script_size_multiplier = 241,
        eCSSProperty_scroll_behavior = 242,
        eCSSProperty_scroll_snap_coordinate = 243,
        eCSSProperty_scroll_snap_destination = 244,
        eCSSProperty_scroll_snap_points_x = 245,
        eCSSProperty_scroll_snap_points_y = 246,
        eCSSProperty_scroll_snap_type_x = 247,
        eCSSProperty_scroll_snap_type_y = 248,
        eCSSProperty_shape_outside = 249,
        eCSSProperty_shape_rendering = 250,
        eCSSProperty__x_span = 251,
        eCSSProperty__moz_stack_sizing = 252,
        eCSSProperty_stop_color = 253,
        eCSSProperty_stop_opacity = 254,
        eCSSProperty_stroke = 255,
        eCSSProperty_stroke_dasharray = 256,
        eCSSProperty_stroke_dashoffset = 257,
        eCSSProperty_stroke_linecap = 258,
        eCSSProperty_stroke_linejoin = 259,
        eCSSProperty_stroke_miterlimit = 260,
        eCSSProperty_stroke_opacity = 261,
        eCSSProperty_stroke_width = 262,
        eCSSProperty__x_system_font = 263,
        eCSSProperty__moz_tab_size = 264,
        eCSSProperty_table_layout = 265,
        eCSSProperty_text_align = 266,
        eCSSProperty_text_align_last = 267,
        eCSSProperty_text_anchor = 268,
        eCSSProperty_text_combine_upright = 269,
        eCSSProperty_text_decoration_color = 270,
        eCSSProperty_text_decoration_line = 271,
        eCSSProperty_text_decoration_style = 272,
        eCSSProperty_text_emphasis_color = 273,
        eCSSProperty_text_emphasis_position = 274,
        eCSSProperty_text_emphasis_style = 275,
        eCSSProperty__webkit_text_fill_color = 276,
        eCSSProperty_text_indent = 277,
        eCSSProperty_text_orientation = 278,
        eCSSProperty_text_overflow = 279,
        eCSSProperty_text_rendering = 280,
        eCSSProperty_text_shadow = 281,
        eCSSProperty__moz_text_size_adjust = 282,
        eCSSProperty__webkit_text_stroke_color = 283,
        eCSSProperty__webkit_text_stroke_width = 284,
        eCSSProperty_text_transform = 285,
        eCSSProperty__x_text_zoom = 286,
        eCSSProperty_top = 287,
        eCSSProperty__moz_top_layer = 288,
        eCSSProperty_touch_action = 289,
        eCSSProperty_transform = 290,
        eCSSProperty_transform_box = 291,
        eCSSProperty_transform_origin = 292,
        eCSSProperty_transform_style = 293,
        eCSSProperty_transition_delay = 294,
        eCSSProperty_transition_duration = 295,
        eCSSProperty_transition_property = 296,
        eCSSProperty_transition_timing_function = 297,
        eCSSProperty_unicode_bidi = 298,
        eCSSProperty__moz_user_focus = 299,
        eCSSProperty__moz_user_input = 300,
        eCSSProperty__moz_user_modify = 301,
        eCSSProperty__moz_user_select = 302,
        eCSSProperty_vector_effect = 303,
        eCSSProperty_vertical_align = 304,
        eCSSProperty_visibility = 305,
        eCSSProperty_white_space = 306,
        eCSSProperty_width = 307,
        eCSSProperty_will_change = 308,
        eCSSProperty__moz_window_dragging = 309,
        eCSSProperty__moz_window_shadow = 310,
        eCSSProperty_word_break = 311,
        eCSSProperty_word_spacing = 312,
        eCSSProperty_overflow_wrap = 313,
        eCSSProperty_writing_mode = 314,
        eCSSProperty_z_index = 315,
        eCSSProperty_COUNT_no_shorthands = 316,
        eCSSProperty_animation = 317,
        eCSSProperty_background = 318,
        eCSSProperty_background_position = 319,
        eCSSProperty_border = 320,
        eCSSProperty_border_block_end = 321,
        eCSSProperty_border_block_start = 322,
        eCSSProperty_border_bottom = 323,
        eCSSProperty_border_color = 324,
        eCSSProperty_border_image = 325,
        eCSSProperty_border_inline_end = 326,
        eCSSProperty_border_inline_start = 327,
        eCSSProperty_border_left = 328,
        eCSSProperty_border_radius = 329,
        eCSSProperty_border_right = 330,
        eCSSProperty_border_style = 331,
        eCSSProperty_border_top = 332,
        eCSSProperty_border_width = 333,
        eCSSProperty_column_rule = 334,
        eCSSProperty_columns = 335,
        eCSSProperty_flex = 336,
        eCSSProperty_flex_flow = 337,
        eCSSProperty_font = 338,
        eCSSProperty_font_variant = 339,
        eCSSProperty_grid = 340,
        eCSSProperty_grid_area = 341,
        eCSSProperty_grid_column = 342,
        eCSSProperty_grid_gap = 343,
        eCSSProperty_grid_row = 344,
        eCSSProperty_grid_template = 345,
        eCSSProperty_list_style = 346,
        eCSSProperty_margin = 347,
        eCSSProperty_marker = 348,
        eCSSProperty_mask = 349,
        eCSSProperty_mask_position = 350,
        eCSSProperty_outline = 351,
        eCSSProperty__moz_outline_radius = 352,
        eCSSProperty_overflow = 353,
        eCSSProperty_padding = 354,
        eCSSProperty_place_content = 355,
        eCSSProperty_place_items = 356,
        eCSSProperty_place_self = 357,
        eCSSProperty_scroll_snap_type = 358,
        eCSSProperty_text_decoration = 359,
        eCSSProperty_text_emphasis = 360,
        eCSSProperty__webkit_text_stroke = 361,
        eCSSProperty__moz_transform = 362,
        eCSSProperty_transition = 363,
        eCSSProperty_COUNT = 364,
        eCSSPropertyAlias_MozTransformOrigin = 365,
        eCSSPropertyAlias_MozPerspectiveOrigin = 366,
        eCSSPropertyAlias_MozPerspective = 367,
        eCSSPropertyAlias_MozTransformStyle = 368,
        eCSSPropertyAlias_MozBackfaceVisibility = 369,
        eCSSPropertyAlias_MozBorderImage = 370,
        eCSSPropertyAlias_MozTransition = 371,
        eCSSPropertyAlias_MozTransitionDelay = 372,
        eCSSPropertyAlias_MozTransitionDuration = 373,
        eCSSPropertyAlias_MozTransitionProperty = 374,
        eCSSPropertyAlias_MozTransitionTimingFunction = 375,
        eCSSPropertyAlias_MozAnimation = 376,
        eCSSPropertyAlias_MozAnimationDelay = 377,
        eCSSPropertyAlias_MozAnimationDirection = 378,
        eCSSPropertyAlias_MozAnimationDuration = 379,
        eCSSPropertyAlias_MozAnimationFillMode = 380,
        eCSSPropertyAlias_MozAnimationIterationCount = 381,
        eCSSPropertyAlias_MozAnimationName = 382,
        eCSSPropertyAlias_MozAnimationPlayState = 383,
        eCSSPropertyAlias_MozAnimationTimingFunction = 384,
        eCSSPropertyAlias_MozBoxSizing = 385,
        eCSSPropertyAlias_MozFontFeatureSettings = 386,
        eCSSPropertyAlias_MozFontLanguageOverride = 387,
        eCSSPropertyAlias_MozPaddingEnd = 388,
        eCSSPropertyAlias_MozPaddingStart = 389,
        eCSSPropertyAlias_MozMarginEnd = 390,
        eCSSPropertyAlias_MozMarginStart = 391,
        eCSSPropertyAlias_MozBorderEnd = 392,
        eCSSPropertyAlias_MozBorderEndColor = 393,
        eCSSPropertyAlias_MozBorderEndStyle = 394,
        eCSSPropertyAlias_MozBorderEndWidth = 395,
        eCSSPropertyAlias_MozBorderStart = 396,
        eCSSPropertyAlias_MozBorderStartColor = 397,
        eCSSPropertyAlias_MozBorderStartStyle = 398,
        eCSSPropertyAlias_MozBorderStartWidth = 399,
        eCSSPropertyAlias_MozHyphens = 400,
        eCSSPropertyAlias_MozColumnCount = 401,
        eCSSPropertyAlias_MozColumnFill = 402,
        eCSSPropertyAlias_MozColumnGap = 403,
        eCSSPropertyAlias_MozColumnRule = 404,
        eCSSPropertyAlias_MozColumnRuleColor = 405,
        eCSSPropertyAlias_MozColumnRuleStyle = 406,
        eCSSPropertyAlias_MozColumnRuleWidth = 407,
        eCSSPropertyAlias_MozColumnWidth = 408,
        eCSSPropertyAlias_MozColumns = 409,
        eCSSPropertyAlias_WebkitAnimation = 410,
        eCSSPropertyAlias_WebkitAnimationDelay = 411,
        eCSSPropertyAlias_WebkitAnimationDirection = 412,
        eCSSPropertyAlias_WebkitAnimationDuration = 413,
        eCSSPropertyAlias_WebkitAnimationFillMode = 414,
        eCSSPropertyAlias_WebkitAnimationIterationCount = 415,
        eCSSPropertyAlias_WebkitAnimationName = 416,
        eCSSPropertyAlias_WebkitAnimationPlayState = 417,
        eCSSPropertyAlias_WebkitAnimationTimingFunction = 418,
        eCSSPropertyAlias_WebkitFilter = 419,
        eCSSPropertyAlias_WebkitTextSizeAdjust = 420,
        eCSSPropertyAlias_WebkitTransform = 421,
        eCSSPropertyAlias_WebkitTransformOrigin = 422,
        eCSSPropertyAlias_WebkitTransformStyle = 423,
        eCSSPropertyAlias_WebkitBackfaceVisibility = 424,
        eCSSPropertyAlias_WebkitPerspective = 425,
        eCSSPropertyAlias_WebkitPerspectiveOrigin = 426,
        eCSSPropertyAlias_WebkitTransition = 427,
        eCSSPropertyAlias_WebkitTransitionDelay = 428,
        eCSSPropertyAlias_WebkitTransitionDuration = 429,
        eCSSPropertyAlias_WebkitTransitionProperty = 430,
        eCSSPropertyAlias_WebkitTransitionTimingFunction = 431,
        eCSSPropertyAlias_WebkitBorderRadius = 432,
        eCSSPropertyAlias_WebkitBorderTopLeftRadius = 433,
        eCSSPropertyAlias_WebkitBorderTopRightRadius = 434,
        eCSSPropertyAlias_WebkitBorderBottomLeftRadius = 435,
        eCSSPropertyAlias_WebkitBorderBottomRightRadius = 436,
        eCSSPropertyAlias_WebkitBackgroundClip = 437,
        eCSSPropertyAlias_WebkitBackgroundOrigin = 438,
        eCSSPropertyAlias_WebkitBackgroundSize = 439,
        eCSSPropertyAlias_WebkitBorderImage = 440,
        eCSSPropertyAlias_WebkitBoxShadow = 441,
        eCSSPropertyAlias_WebkitBoxSizing = 442,
        eCSSPropertyAlias_WebkitBoxFlex = 443,
        eCSSPropertyAlias_WebkitBoxOrdinalGroup = 444,
        eCSSPropertyAlias_WebkitBoxOrient = 445,
        eCSSPropertyAlias_WebkitBoxDirection = 446,
        eCSSPropertyAlias_WebkitBoxAlign = 447,
        eCSSPropertyAlias_WebkitBoxPack = 448,
        eCSSPropertyAlias_WebkitFlexDirection = 449,
        eCSSPropertyAlias_WebkitFlexWrap = 450,
        eCSSPropertyAlias_WebkitFlexFlow = 451,
        eCSSPropertyAlias_WebkitOrder = 452,
        eCSSPropertyAlias_WebkitFlex = 453,
        eCSSPropertyAlias_WebkitFlexGrow = 454,
        eCSSPropertyAlias_WebkitFlexShrink = 455,
        eCSSPropertyAlias_WebkitFlexBasis = 456,
        eCSSPropertyAlias_WebkitJustifyContent = 457,
        eCSSPropertyAlias_WebkitAlignItems = 458,
        eCSSPropertyAlias_WebkitAlignSelf = 459,
        eCSSPropertyAlias_WebkitAlignContent = 460,
        eCSSPropertyAlias_WebkitUserSelect = 461,
        eCSSPropertyAlias_WebkitMask = 462,
        eCSSPropertyAlias_WebkitMaskClip = 463,
        eCSSPropertyAlias_WebkitMaskComposite = 464,
        eCSSPropertyAlias_WebkitMaskImage = 465,
        eCSSPropertyAlias_WebkitMaskOrigin = 466,
        eCSSPropertyAlias_WebkitMaskPosition = 467,
        eCSSPropertyAlias_WebkitMaskPositionX = 468,
        eCSSPropertyAlias_WebkitMaskPositionY = 469,
        eCSSPropertyAlias_WebkitMaskRepeat = 470,
        eCSSPropertyAlias_WebkitMaskSize = 471,
        eCSSProperty_COUNT_with_aliases = 472,
        eCSSPropertyExtra_all_properties = 473,
        eCSSPropertyExtra_x_none_value = 474,
        eCSSPropertyExtra_x_auto_value = 475,
        eCSSPropertyExtra_variable = 476,
        eCSSProperty_DOM = 477,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSFontDesc {
        eCSSFontDesc_UNKNOWN = -1,
        eCSSFontDesc_Family = 0,
        eCSSFontDesc_Style = 1,
        eCSSFontDesc_Weight = 2,
        eCSSFontDesc_Stretch = 3,
        eCSSFontDesc_Src = 4,
        eCSSFontDesc_UnicodeRange = 5,
        eCSSFontDesc_FontFeatureSettings = 6,
        eCSSFontDesc_FontLanguageOverride = 7,
        eCSSFontDesc_Display = 8,
        eCSSFontDesc_COUNT = 9,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSCounterDesc {
        eCSSCounterDesc_UNKNOWN = -1,
        eCSSCounterDesc_System = 0,
        eCSSCounterDesc_Symbols = 1,
        eCSSCounterDesc_AdditiveSymbols = 2,
        eCSSCounterDesc_Negative = 3,
        eCSSCounterDesc_Prefix = 4,
        eCSSCounterDesc_Suffix = 5,
        eCSSCounterDesc_Range = 6,
        eCSSCounterDesc_Pad = 7,
        eCSSCounterDesc_Fallback = 8,
        eCSSCounterDesc_SpeakAs = 9,
        eCSSCounterDesc_COUNT = 10,
    }
    pub type nscolor = u32;
    #[repr(i16)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSKeyword {
        eCSSKeyword_UNKNOWN = -1,
        eCSSKeyword__moz_activehyperlinktext = 0,
        eCSSKeyword__moz_all = 1,
        eCSSKeyword__moz_alt_content = 2,
        eCSSKeyword__moz_anchor_decoration = 3,
        eCSSKeyword__moz_available = 4,
        eCSSKeyword__moz_box = 5,
        eCSSKeyword__moz_button = 6,
        eCSSKeyword__moz_buttondefault = 7,
        eCSSKeyword__moz_buttonhoverface = 8,
        eCSSKeyword__moz_buttonhovertext = 9,
        eCSSKeyword__moz_cellhighlight = 10,
        eCSSKeyword__moz_cellhighlighttext = 11,
        eCSSKeyword__moz_center = 12,
        eCSSKeyword__moz_combobox = 13,
        eCSSKeyword__moz_comboboxtext = 14,
        eCSSKeyword__moz_block_height = 15,
        eCSSKeyword__moz_deck = 16,
        eCSSKeyword__moz_default_background_color = 17,
        eCSSKeyword__moz_default_color = 18,
        eCSSKeyword__moz_desktop = 19,
        eCSSKeyword__moz_dialog = 20,
        eCSSKeyword__moz_dialogtext = 21,
        eCSSKeyword__moz_document = 22,
        eCSSKeyword__moz_dragtargetzone = 23,
        eCSSKeyword__moz_element = 24,
        eCSSKeyword__moz_eventreerow = 25,
        eCSSKeyword__moz_field = 26,
        eCSSKeyword__moz_fieldtext = 27,
        eCSSKeyword__moz_fit_content = 28,
        eCSSKeyword__moz_fixed = 29,
        eCSSKeyword__moz_grabbing = 30,
        eCSSKeyword__moz_grab = 31,
        eCSSKeyword__moz_grid_group = 32,
        eCSSKeyword__moz_grid_line = 33,
        eCSSKeyword__moz_grid = 34,
        eCSSKeyword__moz_groupbox = 35,
        eCSSKeyword__moz_gtk_info_bar = 36,
        eCSSKeyword__moz_gtk_info_bar_text = 37,
        eCSSKeyword__moz_hidden_unscrollable = 38,
        eCSSKeyword__moz_hyperlinktext = 39,
        eCSSKeyword__moz_html_cellhighlight = 40,
        eCSSKeyword__moz_html_cellhighlighttext = 41,
        eCSSKeyword__moz_image_rect = 42,
        eCSSKeyword__moz_info = 43,
        eCSSKeyword__moz_inline_box = 44,
        eCSSKeyword__moz_inline_grid = 45,
        eCSSKeyword__moz_inline_stack = 46,
        eCSSKeyword__moz_left = 47,
        eCSSKeyword__moz_list = 48,
        eCSSKeyword__moz_mac_buttonactivetext = 49,
        eCSSKeyword__moz_mac_chrome_active = 50,
        eCSSKeyword__moz_mac_chrome_inactive = 51,
        eCSSKeyword__moz_mac_defaultbuttontext = 52,
        eCSSKeyword__moz_mac_focusring = 53,
        eCSSKeyword__moz_mac_fullscreen_button = 54,
        eCSSKeyword__moz_mac_menuselect = 55,
        eCSSKeyword__moz_mac_menushadow = 56,
        eCSSKeyword__moz_mac_menutextdisable = 57,
        eCSSKeyword__moz_mac_menutextselect = 58,
        eCSSKeyword__moz_mac_disabledtoolbartext = 59,
        eCSSKeyword__moz_mac_secondaryhighlight = 60,
        eCSSKeyword__moz_max_content = 61,
        eCSSKeyword__moz_menuhover = 62,
        eCSSKeyword__moz_menuhovertext = 63,
        eCSSKeyword__moz_menubartext = 64,
        eCSSKeyword__moz_menubarhovertext = 65,
        eCSSKeyword__moz_middle_with_baseline = 66,
        eCSSKeyword__moz_min_content = 67,
        eCSSKeyword__moz_nativehyperlinktext = 68,
        eCSSKeyword__moz_none = 69,
        eCSSKeyword__moz_oddtreerow = 70,
        eCSSKeyword__moz_popup = 71,
        eCSSKeyword__moz_pre_space = 72,
        eCSSKeyword__moz_pull_down_menu = 73,
        eCSSKeyword__moz_right = 74,
        eCSSKeyword__moz_scrollbars_horizontal = 75,
        eCSSKeyword__moz_scrollbars_none = 76,
        eCSSKeyword__moz_scrollbars_vertical = 77,
        eCSSKeyword__moz_stack = 78,
        eCSSKeyword__moz_text = 79,
        eCSSKeyword__moz_use_system_font = 80,
        eCSSKeyword__moz_visitedhyperlinktext = 81,
        eCSSKeyword__moz_window = 82,
        eCSSKeyword__moz_workspace = 83,
        eCSSKeyword__moz_zoom_in = 84,
        eCSSKeyword__moz_zoom_out = 85,
        eCSSKeyword__webkit_box = 86,
        eCSSKeyword__webkit_flex = 87,
        eCSSKeyword__webkit_inline_box = 88,
        eCSSKeyword__webkit_inline_flex = 89,
        eCSSKeyword_absolute = 90,
        eCSSKeyword_active = 91,
        eCSSKeyword_activeborder = 92,
        eCSSKeyword_activecaption = 93,
        eCSSKeyword_add = 94,
        eCSSKeyword_additive = 95,
        eCSSKeyword_alias = 96,
        eCSSKeyword_all = 97,
        eCSSKeyword_all_petite_caps = 98,
        eCSSKeyword_all_scroll = 99,
        eCSSKeyword_all_small_caps = 100,
        eCSSKeyword_alpha = 101,
        eCSSKeyword_alternate = 102,
        eCSSKeyword_alternate_reverse = 103,
        eCSSKeyword_always = 104,
        eCSSKeyword_annotation = 105,
        eCSSKeyword_appworkspace = 106,
        eCSSKeyword_auto = 107,
        eCSSKeyword_auto_fill = 108,
        eCSSKeyword_auto_fit = 109,
        eCSSKeyword_auto_flow = 110,
        eCSSKeyword_avoid = 111,
        eCSSKeyword_background = 112,
        eCSSKeyword_backwards = 113,
        eCSSKeyword_balance = 114,
        eCSSKeyword_baseline = 115,
        eCSSKeyword_bidi_override = 116,
        eCSSKeyword_blink = 117,
        eCSSKeyword_block = 118,
        eCSSKeyword_block_axis = 119,
        eCSSKeyword_blur = 120,
        eCSSKeyword_bold = 121,
        eCSSKeyword_bold_fraktur = 122,
        eCSSKeyword_bold_italic = 123,
        eCSSKeyword_bold_sans_serif = 124,
        eCSSKeyword_bold_script = 125,
        eCSSKeyword_bolder = 126,
        eCSSKeyword_border_box = 127,
        eCSSKeyword_both = 128,
        eCSSKeyword_bottom = 129,
        eCSSKeyword_bottom_outside = 130,
        eCSSKeyword_break_all = 131,
        eCSSKeyword_break_word = 132,
        eCSSKeyword_brightness = 133,
        eCSSKeyword_browser = 134,
        eCSSKeyword_bullets = 135,
        eCSSKeyword_button = 136,
        eCSSKeyword_buttonface = 137,
        eCSSKeyword_buttonhighlight = 138,
        eCSSKeyword_buttonshadow = 139,
        eCSSKeyword_buttontext = 140,
        eCSSKeyword_capitalize = 141,
        eCSSKeyword_caption = 142,
        eCSSKeyword_captiontext = 143,
        eCSSKeyword_cell = 144,
        eCSSKeyword_center = 145,
        eCSSKeyword_ch = 146,
        eCSSKeyword_character_variant = 147,
        eCSSKeyword_circle = 148,
        eCSSKeyword_cjk_decimal = 149,
        eCSSKeyword_clip = 150,
        eCSSKeyword_clone = 151,
        eCSSKeyword_close_quote = 152,
        eCSSKeyword_closest_corner = 153,
        eCSSKeyword_closest_side = 154,
        eCSSKeyword_cm = 155,
        eCSSKeyword_col_resize = 156,
        eCSSKeyword_collapse = 157,
        eCSSKeyword_color = 158,
        eCSSKeyword_color_burn = 159,
        eCSSKeyword_color_dodge = 160,
        eCSSKeyword_common_ligatures = 161,
        eCSSKeyword_column = 162,
        eCSSKeyword_column_reverse = 163,
        eCSSKeyword_condensed = 164,
        eCSSKeyword_contain = 165,
        eCSSKeyword_content_box = 166,
        eCSSKeyword_contents = 167,
        eCSSKeyword_context_fill = 168,
        eCSSKeyword_context_fill_opacity = 169,
        eCSSKeyword_context_menu = 170,
        eCSSKeyword_context_stroke = 171,
        eCSSKeyword_context_stroke_opacity = 172,
        eCSSKeyword_context_value = 173,
        eCSSKeyword_continuous = 174,
        eCSSKeyword_contrast = 175,
        eCSSKeyword_copy = 176,
        eCSSKeyword_contextual = 177,
        eCSSKeyword_cover = 178,
        eCSSKeyword_crop = 179,
        eCSSKeyword_cross = 180,
        eCSSKeyword_crosshair = 181,
        eCSSKeyword_currentcolor = 182,
        eCSSKeyword_cursive = 183,
        eCSSKeyword_cyclic = 184,
        eCSSKeyword_darken = 185,
        eCSSKeyword_dashed = 186,
        eCSSKeyword_dense = 187,
        eCSSKeyword_decimal = 188,
        eCSSKeyword_default = 189,
        eCSSKeyword_deg = 190,
        eCSSKeyword_diagonal_fractions = 191,
        eCSSKeyword_dialog = 192,
        eCSSKeyword_difference = 193,
        eCSSKeyword_digits = 194,
        eCSSKeyword_disabled = 195,
        eCSSKeyword_disc = 196,
        eCSSKeyword_disclosure_closed = 197,
        eCSSKeyword_disclosure_open = 198,
        eCSSKeyword_discretionary_ligatures = 199,
        eCSSKeyword_dot = 200,
        eCSSKeyword_dotted = 201,
        eCSSKeyword_double = 202,
        eCSSKeyword_double_circle = 203,
        eCSSKeyword_double_struck = 204,
        eCSSKeyword_drag = 205,
        eCSSKeyword_drop_shadow = 206,
        eCSSKeyword_e_resize = 207,
        eCSSKeyword_ease = 208,
        eCSSKeyword_ease_in = 209,
        eCSSKeyword_ease_in_out = 210,
        eCSSKeyword_ease_out = 211,
        eCSSKeyword_economy = 212,
        eCSSKeyword_element = 213,
        eCSSKeyword_elements = 214,
        eCSSKeyword_ellipse = 215,
        eCSSKeyword_ellipsis = 216,
        eCSSKeyword_em = 217,
        eCSSKeyword_embed = 218,
        eCSSKeyword_enabled = 219,
        eCSSKeyword_end = 220,
        eCSSKeyword_ethiopic_numeric = 221,
        eCSSKeyword_ex = 222,
        eCSSKeyword_exact = 223,
        eCSSKeyword_exclude = 224,
        eCSSKeyword_exclusion = 225,
        eCSSKeyword_expanded = 226,
        eCSSKeyword_extends = 227,
        eCSSKeyword_extra_condensed = 228,
        eCSSKeyword_extra_expanded = 229,
        eCSSKeyword_ew_resize = 230,
        eCSSKeyword_fallback = 231,
        eCSSKeyword_fantasy = 232,
        eCSSKeyword_farthest_side = 233,
        eCSSKeyword_farthest_corner = 234,
        eCSSKeyword_fill = 235,
        eCSSKeyword_filled = 236,
        eCSSKeyword_fill_box = 237,
        eCSSKeyword_first = 238,
        eCSSKeyword_fit_content = 239,
        eCSSKeyword_fixed = 240,
        eCSSKeyword_flat = 241,
        eCSSKeyword_flex = 242,
        eCSSKeyword_flex_end = 243,
        eCSSKeyword_flex_start = 244,
        eCSSKeyword_flip = 245,
        eCSSKeyword_flow_root = 246,
        eCSSKeyword_forwards = 247,
        eCSSKeyword_fraktur = 248,
        eCSSKeyword_from_image = 249,
        eCSSKeyword_full_width = 250,
        eCSSKeyword_fullscreen = 251,
        eCSSKeyword_grab = 252,
        eCSSKeyword_grabbing = 253,
        eCSSKeyword_grad = 254,
        eCSSKeyword_grayscale = 255,
        eCSSKeyword_graytext = 256,
        eCSSKeyword_grid = 257,
        eCSSKeyword_groove = 258,
        eCSSKeyword_hard_light = 259,
        eCSSKeyword_hebrew = 260,
        eCSSKeyword_help = 261,
        eCSSKeyword_hidden = 262,
        eCSSKeyword_hide = 263,
        eCSSKeyword_highlight = 264,
        eCSSKeyword_highlighttext = 265,
        eCSSKeyword_historical_forms = 266,
        eCSSKeyword_historical_ligatures = 267,
        eCSSKeyword_horizontal = 268,
        eCSSKeyword_horizontal_tb = 269,
        eCSSKeyword_hue = 270,
        eCSSKeyword_hue_rotate = 271,
        eCSSKeyword_hz = 272,
        eCSSKeyword_icon = 273,
        eCSSKeyword_ignore = 274,
        eCSSKeyword_in = 275,
        eCSSKeyword_interlace = 276,
        eCSSKeyword_inactive = 277,
        eCSSKeyword_inactiveborder = 278,
        eCSSKeyword_inactivecaption = 279,
        eCSSKeyword_inactivecaptiontext = 280,
        eCSSKeyword_infinite = 281,
        eCSSKeyword_infobackground = 282,
        eCSSKeyword_infotext = 283,
        eCSSKeyword_inherit = 284,
        eCSSKeyword_initial = 285,
        eCSSKeyword_inline = 286,
        eCSSKeyword_inline_axis = 287,
        eCSSKeyword_inline_block = 288,
        eCSSKeyword_inline_end = 289,
        eCSSKeyword_inline_flex = 290,
        eCSSKeyword_inline_grid = 291,
        eCSSKeyword_inline_start = 292,
        eCSSKeyword_inline_table = 293,
        eCSSKeyword_inset = 294,
        eCSSKeyword_inside = 295,
        eCSSKeyword_interpolatematrix = 296,
        eCSSKeyword_accumulatematrix = 297,
        eCSSKeyword_intersect = 298,
        eCSSKeyword_isolate = 299,
        eCSSKeyword_isolate_override = 300,
        eCSSKeyword_invert = 301,
        eCSSKeyword_italic = 302,
        eCSSKeyword_japanese_formal = 303,
        eCSSKeyword_japanese_informal = 304,
        eCSSKeyword_jis78 = 305,
        eCSSKeyword_jis83 = 306,
        eCSSKeyword_jis90 = 307,
        eCSSKeyword_jis04 = 308,
        eCSSKeyword_justify = 309,
        eCSSKeyword_keep_all = 310,
        eCSSKeyword_khz = 311,
        eCSSKeyword_korean_hangul_formal = 312,
        eCSSKeyword_korean_hanja_formal = 313,
        eCSSKeyword_korean_hanja_informal = 314,
        eCSSKeyword_landscape = 315,
        eCSSKeyword_large = 316,
        eCSSKeyword_larger = 317,
        eCSSKeyword_last = 318,
        eCSSKeyword_last_baseline = 319,
        eCSSKeyword_layout = 320,
        eCSSKeyword_left = 321,
        eCSSKeyword_legacy = 322,
        eCSSKeyword_lighten = 323,
        eCSSKeyword_lighter = 324,
        eCSSKeyword_line_through = 325,
        eCSSKeyword_linear = 326,
        eCSSKeyword_lining_nums = 327,
        eCSSKeyword_list_item = 328,
        eCSSKeyword_local = 329,
        eCSSKeyword_logical = 330,
        eCSSKeyword_looped = 331,
        eCSSKeyword_lowercase = 332,
        eCSSKeyword_lr = 333,
        eCSSKeyword_lr_tb = 334,
        eCSSKeyword_ltr = 335,
        eCSSKeyword_luminance = 336,
        eCSSKeyword_luminosity = 337,
        eCSSKeyword_mandatory = 338,
        eCSSKeyword_manipulation = 339,
        eCSSKeyword_manual = 340,
        eCSSKeyword_margin_box = 341,
        eCSSKeyword_markers = 342,
        eCSSKeyword_match_parent = 343,
        eCSSKeyword_match_source = 344,
        eCSSKeyword_matrix = 345,
        eCSSKeyword_matrix3d = 346,
        eCSSKeyword_max_content = 347,
        eCSSKeyword_medium = 348,
        eCSSKeyword_menu = 349,
        eCSSKeyword_menutext = 350,
        eCSSKeyword_message_box = 351,
        eCSSKeyword_middle = 352,
        eCSSKeyword_min_content = 353,
        eCSSKeyword_minmax = 354,
        eCSSKeyword_mix = 355,
        eCSSKeyword_mixed = 356,
        eCSSKeyword_mm = 357,
        eCSSKeyword_monospace = 358,
        eCSSKeyword_move = 359,
        eCSSKeyword_ms = 360,
        eCSSKeyword_multiply = 361,
        eCSSKeyword_n_resize = 362,
        eCSSKeyword_narrower = 363,
        eCSSKeyword_ne_resize = 364,
        eCSSKeyword_nesw_resize = 365,
        eCSSKeyword_no_clip = 366,
        eCSSKeyword_no_close_quote = 367,
        eCSSKeyword_no_common_ligatures = 368,
        eCSSKeyword_no_contextual = 369,
        eCSSKeyword_no_discretionary_ligatures = 370,
        eCSSKeyword_no_drag = 371,
        eCSSKeyword_no_drop = 372,
        eCSSKeyword_no_historical_ligatures = 373,
        eCSSKeyword_no_open_quote = 374,
        eCSSKeyword_no_repeat = 375,
        eCSSKeyword_none = 376,
        eCSSKeyword_normal = 377,
        eCSSKeyword_not_allowed = 378,
        eCSSKeyword_nowrap = 379,
        eCSSKeyword_numeric = 380,
        eCSSKeyword_ns_resize = 381,
        eCSSKeyword_nw_resize = 382,
        eCSSKeyword_nwse_resize = 383,
        eCSSKeyword_oblique = 384,
        eCSSKeyword_oldstyle_nums = 385,
        eCSSKeyword_opacity = 386,
        eCSSKeyword_open = 387,
        eCSSKeyword_open_quote = 388,
        eCSSKeyword_optional = 389,
        eCSSKeyword_ordinal = 390,
        eCSSKeyword_ornaments = 391,
        eCSSKeyword_outset = 392,
        eCSSKeyword_outside = 393,
        eCSSKeyword_over = 394,
        eCSSKeyword_overlay = 395,
        eCSSKeyword_overline = 396,
        eCSSKeyword_paint = 397,
        eCSSKeyword_padding_box = 398,
        eCSSKeyword_painted = 399,
        eCSSKeyword_pan_x = 400,
        eCSSKeyword_pan_y = 401,
        eCSSKeyword_paused = 402,
        eCSSKeyword_pc = 403,
        eCSSKeyword_perspective = 404,
        eCSSKeyword_petite_caps = 405,
        eCSSKeyword_physical = 406,
        eCSSKeyword_plaintext = 407,
        eCSSKeyword_pointer = 408,
        eCSSKeyword_polygon = 409,
        eCSSKeyword_portrait = 410,
        eCSSKeyword_pre = 411,
        eCSSKeyword_pre_wrap = 412,
        eCSSKeyword_pre_line = 413,
        eCSSKeyword_preserve_3d = 414,
        eCSSKeyword_progress = 415,
        eCSSKeyword_progressive = 416,
        eCSSKeyword_proportional_nums = 417,
        eCSSKeyword_proportional_width = 418,
        eCSSKeyword_proximity = 419,
        eCSSKeyword_pt = 420,
        eCSSKeyword_px = 421,
        eCSSKeyword_rad = 422,
        eCSSKeyword_read_only = 423,
        eCSSKeyword_read_write = 424,
        eCSSKeyword_relative = 425,
        eCSSKeyword_repeat = 426,
        eCSSKeyword_repeat_x = 427,
        eCSSKeyword_repeat_y = 428,
        eCSSKeyword_reverse = 429,
        eCSSKeyword_ridge = 430,
        eCSSKeyword_right = 431,
        eCSSKeyword_rl = 432,
        eCSSKeyword_rl_tb = 433,
        eCSSKeyword_rotate = 434,
        eCSSKeyword_rotate3d = 435,
        eCSSKeyword_rotatex = 436,
        eCSSKeyword_rotatey = 437,
        eCSSKeyword_rotatez = 438,
        eCSSKeyword_round = 439,
        eCSSKeyword_row = 440,
        eCSSKeyword_row_resize = 441,
        eCSSKeyword_row_reverse = 442,
        eCSSKeyword_rtl = 443,
        eCSSKeyword_ruby = 444,
        eCSSKeyword_ruby_base = 445,
        eCSSKeyword_ruby_base_container = 446,
        eCSSKeyword_ruby_text = 447,
        eCSSKeyword_ruby_text_container = 448,
        eCSSKeyword_running = 449,
        eCSSKeyword_s = 450,
        eCSSKeyword_s_resize = 451,
        eCSSKeyword_safe = 452,
        eCSSKeyword_saturate = 453,
        eCSSKeyword_saturation = 454,
        eCSSKeyword_scale = 455,
        eCSSKeyword_scale_down = 456,
        eCSSKeyword_scale3d = 457,
        eCSSKeyword_scalex = 458,
        eCSSKeyword_scaley = 459,
        eCSSKeyword_scalez = 460,
        eCSSKeyword_screen = 461,
        eCSSKeyword_script = 462,
        eCSSKeyword_scroll = 463,
        eCSSKeyword_scrollbar = 464,
        eCSSKeyword_scrollbar_small = 465,
        eCSSKeyword_scrollbar_horizontal = 466,
        eCSSKeyword_scrollbar_vertical = 467,
        eCSSKeyword_se_resize = 468,
        eCSSKeyword_select_after = 469,
        eCSSKeyword_select_all = 470,
        eCSSKeyword_select_before = 471,
        eCSSKeyword_select_menu = 472,
        eCSSKeyword_select_same = 473,
        eCSSKeyword_self_end = 474,
        eCSSKeyword_self_start = 475,
        eCSSKeyword_semi_condensed = 476,
        eCSSKeyword_semi_expanded = 477,
        eCSSKeyword_separate = 478,
        eCSSKeyword_sepia = 479,
        eCSSKeyword_serif = 480,
        eCSSKeyword_sesame = 481,
        eCSSKeyword_show = 482,
        eCSSKeyword_sideways = 483,
        eCSSKeyword_sideways_lr = 484,
        eCSSKeyword_sideways_right = 485,
        eCSSKeyword_sideways_rl = 486,
        eCSSKeyword_simp_chinese_formal = 487,
        eCSSKeyword_simp_chinese_informal = 488,
        eCSSKeyword_simplified = 489,
        eCSSKeyword_skew = 490,
        eCSSKeyword_skewx = 491,
        eCSSKeyword_skewy = 492,
        eCSSKeyword_slashed_zero = 493,
        eCSSKeyword_slice = 494,
        eCSSKeyword_small = 495,
        eCSSKeyword_small_caps = 496,
        eCSSKeyword_small_caption = 497,
        eCSSKeyword_smaller = 498,
        eCSSKeyword_smooth = 499,
        eCSSKeyword_soft = 500,
        eCSSKeyword_soft_light = 501,
        eCSSKeyword_solid = 502,
        eCSSKeyword_space_around = 503,
        eCSSKeyword_space_between = 504,
        eCSSKeyword_space_evenly = 505,
        eCSSKeyword_span = 506,
        eCSSKeyword_spell_out = 507,
        eCSSKeyword_square = 508,
        eCSSKeyword_stacked_fractions = 509,
        eCSSKeyword_start = 510,
        eCSSKeyword_static = 511,
        eCSSKeyword_standalone = 512,
        eCSSKeyword_status_bar = 513,
        eCSSKeyword_step_end = 514,
        eCSSKeyword_step_start = 515,
        eCSSKeyword_sticky = 516,
        eCSSKeyword_stretch = 517,
        eCSSKeyword_stretch_to_fit = 518,
        eCSSKeyword_stretched = 519,
        eCSSKeyword_strict = 520,
        eCSSKeyword_stroke = 521,
        eCSSKeyword_stroke_box = 522,
        eCSSKeyword_style = 523,
        eCSSKeyword_styleset = 524,
        eCSSKeyword_stylistic = 525,
        eCSSKeyword_sub = 526,
        eCSSKeyword_subgrid = 527,
        eCSSKeyword_subtract = 528,
        eCSSKeyword_super = 529,
        eCSSKeyword_sw_resize = 530,
        eCSSKeyword_swash = 531,
        eCSSKeyword_swap = 532,
        eCSSKeyword_table = 533,
        eCSSKeyword_table_caption = 534,
        eCSSKeyword_table_cell = 535,
        eCSSKeyword_table_column = 536,
        eCSSKeyword_table_column_group = 537,
        eCSSKeyword_table_footer_group = 538,
        eCSSKeyword_table_header_group = 539,
        eCSSKeyword_table_row = 540,
        eCSSKeyword_table_row_group = 541,
        eCSSKeyword_tabular_nums = 542,
        eCSSKeyword_tailed = 543,
        eCSSKeyword_tb = 544,
        eCSSKeyword_tb_rl = 545,
        eCSSKeyword_text = 546,
        eCSSKeyword_text_bottom = 547,
        eCSSKeyword_text_top = 548,
        eCSSKeyword_thick = 549,
        eCSSKeyword_thin = 550,
        eCSSKeyword_threeddarkshadow = 551,
        eCSSKeyword_threedface = 552,
        eCSSKeyword_threedhighlight = 553,
        eCSSKeyword_threedlightshadow = 554,
        eCSSKeyword_threedshadow = 555,
        eCSSKeyword_titling_caps = 556,
        eCSSKeyword_toggle = 557,
        eCSSKeyword_top = 558,
        eCSSKeyword_top_outside = 559,
        eCSSKeyword_trad_chinese_formal = 560,
        eCSSKeyword_trad_chinese_informal = 561,
        eCSSKeyword_traditional = 562,
        eCSSKeyword_translate = 563,
        eCSSKeyword_translate3d = 564,
        eCSSKeyword_translatex = 565,
        eCSSKeyword_translatey = 566,
        eCSSKeyword_translatez = 567,
        eCSSKeyword_transparent = 568,
        eCSSKeyword_triangle = 569,
        eCSSKeyword_tri_state = 570,
        eCSSKeyword_ultra_condensed = 571,
        eCSSKeyword_ultra_expanded = 572,
        eCSSKeyword_under = 573,
        eCSSKeyword_underline = 574,
        eCSSKeyword_unicase = 575,
        eCSSKeyword_unsafe = 576,
        eCSSKeyword_unset = 577,
        eCSSKeyword_uppercase = 578,
        eCSSKeyword_upright = 579,
        eCSSKeyword_vertical = 580,
        eCSSKeyword_vertical_lr = 581,
        eCSSKeyword_vertical_rl = 582,
        eCSSKeyword_vertical_text = 583,
        eCSSKeyword_view_box = 584,
        eCSSKeyword_visible = 585,
        eCSSKeyword_visiblefill = 586,
        eCSSKeyword_visiblepainted = 587,
        eCSSKeyword_visiblestroke = 588,
        eCSSKeyword_w_resize = 589,
        eCSSKeyword_wait = 590,
        eCSSKeyword_wavy = 591,
        eCSSKeyword_weight = 592,
        eCSSKeyword_wider = 593,
        eCSSKeyword_window = 594,
        eCSSKeyword_windowframe = 595,
        eCSSKeyword_windowtext = 596,
        eCSSKeyword_words = 597,
        eCSSKeyword_wrap = 598,
        eCSSKeyword_wrap_reverse = 599,
        eCSSKeyword_write_only = 600,
        eCSSKeyword_x_large = 601,
        eCSSKeyword_x_small = 602,
        eCSSKeyword_xx_large = 603,
        eCSSKeyword_xx_small = 604,
        eCSSKeyword_zoom_in = 605,
        eCSSKeyword_zoom_out = 606,
        eCSSKeyword_radio = 607,
        eCSSKeyword_checkbox = 608,
        eCSSKeyword_button_bevel = 609,
        eCSSKeyword_toolbox = 610,
        eCSSKeyword_toolbar = 611,
        eCSSKeyword_toolbarbutton = 612,
        eCSSKeyword_toolbargripper = 613,
        eCSSKeyword_dualbutton = 614,
        eCSSKeyword_toolbarbutton_dropdown = 615,
        eCSSKeyword_button_arrow_up = 616,
        eCSSKeyword_button_arrow_down = 617,
        eCSSKeyword_button_arrow_next = 618,
        eCSSKeyword_button_arrow_previous = 619,
        eCSSKeyword_separator = 620,
        eCSSKeyword_splitter = 621,
        eCSSKeyword_statusbar = 622,
        eCSSKeyword_statusbarpanel = 623,
        eCSSKeyword_resizerpanel = 624,
        eCSSKeyword_resizer = 625,
        eCSSKeyword_listbox = 626,
        eCSSKeyword_listitem = 627,
        eCSSKeyword_numbers = 628,
        eCSSKeyword_number_input = 629,
        eCSSKeyword_treeview = 630,
        eCSSKeyword_treeitem = 631,
        eCSSKeyword_treetwisty = 632,
        eCSSKeyword_treetwistyopen = 633,
        eCSSKeyword_treeline = 634,
        eCSSKeyword_treeheader = 635,
        eCSSKeyword_treeheadercell = 636,
        eCSSKeyword_treeheadersortarrow = 637,
        eCSSKeyword_progressbar = 638,
        eCSSKeyword_progressbar_vertical = 639,
        eCSSKeyword_progresschunk = 640,
        eCSSKeyword_progresschunk_vertical = 641,
        eCSSKeyword_tab = 642,
        eCSSKeyword_tabpanels = 643,
        eCSSKeyword_tabpanel = 644,
        eCSSKeyword_tab_scroll_arrow_back = 645,
        eCSSKeyword_tab_scroll_arrow_forward = 646,
        eCSSKeyword_tooltip = 647,
        eCSSKeyword_spinner = 648,
        eCSSKeyword_spinner_upbutton = 649,
        eCSSKeyword_spinner_downbutton = 650,
        eCSSKeyword_spinner_textfield = 651,
        eCSSKeyword_scrollbarbutton_up = 652,
        eCSSKeyword_scrollbarbutton_down = 653,
        eCSSKeyword_scrollbarbutton_left = 654,
        eCSSKeyword_scrollbarbutton_right = 655,
        eCSSKeyword_scrollbartrack_horizontal = 656,
        eCSSKeyword_scrollbartrack_vertical = 657,
        eCSSKeyword_scrollbarthumb_horizontal = 658,
        eCSSKeyword_scrollbarthumb_vertical = 659,
        eCSSKeyword_sheet = 660,
        eCSSKeyword_textfield = 661,
        eCSSKeyword_textfield_multiline = 662,
        eCSSKeyword_caret = 663,
        eCSSKeyword_searchfield = 664,
        eCSSKeyword_menubar = 665,
        eCSSKeyword_menupopup = 666,
        eCSSKeyword_menuitem = 667,
        eCSSKeyword_checkmenuitem = 668,
        eCSSKeyword_radiomenuitem = 669,
        eCSSKeyword_menucheckbox = 670,
        eCSSKeyword_menuradio = 671,
        eCSSKeyword_menuseparator = 672,
        eCSSKeyword_menuarrow = 673,
        eCSSKeyword_menuimage = 674,
        eCSSKeyword_menuitemtext = 675,
        eCSSKeyword_menulist = 676,
        eCSSKeyword_menulist_button = 677,
        eCSSKeyword_menulist_text = 678,
        eCSSKeyword_menulist_textfield = 679,
        eCSSKeyword_meterbar = 680,
        eCSSKeyword_meterchunk = 681,
        eCSSKeyword_minimal_ui = 682,
        eCSSKeyword_range = 683,
        eCSSKeyword_range_thumb = 684,
        eCSSKeyword_sans_serif = 685,
        eCSSKeyword_sans_serif_bold_italic = 686,
        eCSSKeyword_sans_serif_italic = 687,
        eCSSKeyword_scale_horizontal = 688,
        eCSSKeyword_scale_vertical = 689,
        eCSSKeyword_scalethumb_horizontal = 690,
        eCSSKeyword_scalethumb_vertical = 691,
        eCSSKeyword_scalethumbstart = 692,
        eCSSKeyword_scalethumbend = 693,
        eCSSKeyword_scalethumbtick = 694,
        eCSSKeyword_groupbox = 695,
        eCSSKeyword_checkbox_container = 696,
        eCSSKeyword_radio_container = 697,
        eCSSKeyword_checkbox_label = 698,
        eCSSKeyword_radio_label = 699,
        eCSSKeyword_button_focus = 700,
        eCSSKeyword__moz_win_media_toolbox = 701,
        eCSSKeyword__moz_win_communications_toolbox = 702,
        eCSSKeyword__moz_win_browsertabbar_toolbox = 703,
        eCSSKeyword__moz_win_mediatext = 704,
        eCSSKeyword__moz_win_communicationstext = 705,
        eCSSKeyword__moz_win_glass = 706,
        eCSSKeyword__moz_win_borderless_glass = 707,
        eCSSKeyword__moz_window_titlebar = 708,
        eCSSKeyword__moz_window_titlebar_maximized = 709,
        eCSSKeyword__moz_window_frame_left = 710,
        eCSSKeyword__moz_window_frame_right = 711,
        eCSSKeyword__moz_window_frame_bottom = 712,
        eCSSKeyword__moz_window_button_close = 713,
        eCSSKeyword__moz_window_button_minimize = 714,
        eCSSKeyword__moz_window_button_maximize = 715,
        eCSSKeyword__moz_window_button_restore = 716,
        eCSSKeyword__moz_window_button_box = 717,
        eCSSKeyword__moz_window_button_box_maximized = 718,
        eCSSKeyword__moz_mac_help_button = 719,
        eCSSKeyword__moz_win_exclude_glass = 720,
        eCSSKeyword__moz_mac_vibrancy_light = 721,
        eCSSKeyword__moz_mac_vibrancy_dark = 722,
        eCSSKeyword__moz_mac_disclosure_button_closed = 723,
        eCSSKeyword__moz_mac_disclosure_button_open = 724,
        eCSSKeyword__moz_mac_source_list = 725,
        eCSSKeyword__moz_mac_source_list_selection = 726,
        eCSSKeyword__moz_mac_active_source_list_selection = 727,
        eCSSKeyword_alphabetic = 728,
        eCSSKeyword_bevel = 729,
        eCSSKeyword_butt = 730,
        eCSSKeyword_central = 731,
        eCSSKeyword_crispedges = 732,
        eCSSKeyword_evenodd = 733,
        eCSSKeyword_geometricprecision = 734,
        eCSSKeyword_hanging = 735,
        eCSSKeyword_ideographic = 736,
        eCSSKeyword_linearrgb = 737,
        eCSSKeyword_mathematical = 738,
        eCSSKeyword_miter = 739,
        eCSSKeyword_no_change = 740,
        eCSSKeyword_non_scaling_stroke = 741,
        eCSSKeyword_nonzero = 742,
        eCSSKeyword_optimizelegibility = 743,
        eCSSKeyword_optimizequality = 744,
        eCSSKeyword_optimizespeed = 745,
        eCSSKeyword_reset_size = 746,
        eCSSKeyword_srgb = 747,
        eCSSKeyword_symbolic = 748,
        eCSSKeyword_symbols = 749,
        eCSSKeyword_text_after_edge = 750,
        eCSSKeyword_text_before_edge = 751,
        eCSSKeyword_use_script = 752,
        eCSSKeyword__moz_crisp_edges = 753,
        eCSSKeyword_space = 754,
        eCSSKeyword_COUNT = 755,
    }
    pub const nsStyleStructID_nsStyleStructID_DUMMY1: root::nsStyleStructID =
        nsStyleStructID::nsStyleStructID_None;
    pub const nsStyleStructID_eStyleStruct_Font: root::nsStyleStructID =
        nsStyleStructID::nsStyleStructID_Inherited_Start;
    pub const nsStyleStructID_nsStyleStructID_DUMMY2: root::nsStyleStructID =
        nsStyleStructID::eStyleStruct_Variables;
    pub const nsStyleStructID_eStyleStruct_Background: root::nsStyleStructID =
        nsStyleStructID::nsStyleStructID_Reset_Start;
    pub const nsStyleStructID_nsStyleStructID_Inherited_Count:
              root::nsStyleStructID =
        nsStyleStructID::nsStyleStructID_Reset_Start;
    pub const nsStyleStructID_nsStyleStructID_Reset_Count:
              root::nsStyleStructID =
        nsStyleStructID::eStyleStruct_Table;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleStructID {
        nsStyleStructID_None = -1,
        nsStyleStructID_Inherited_Start = 0,
        eStyleStruct_Color = 1,
        eStyleStruct_List = 2,
        eStyleStruct_Text = 3,
        eStyleStruct_Visibility = 4,
        eStyleStruct_UserInterface = 5,
        eStyleStruct_TableBorder = 6,
        eStyleStruct_SVG = 7,
        eStyleStruct_Variables = 8,
        nsStyleStructID_Reset_Start = 9,
        eStyleStruct_Position = 10,
        eStyleStruct_TextReset = 11,
        eStyleStruct_Display = 12,
        eStyleStruct_Content = 13,
        eStyleStruct_UIReset = 14,
        eStyleStruct_Table = 15,
        eStyleStruct_Margin = 16,
        eStyleStruct_Padding = 17,
        eStyleStruct_Border = 18,
        eStyleStruct_Outline = 19,
        eStyleStruct_XUL = 20,
        eStyleStruct_SVGReset = 21,
        eStyleStruct_Column = 22,
        eStyleStruct_Effects = 23,
        nsStyleStructID_Length = 24,
    }
    #[repr(u32)]
    /**
 * Types of animatable values.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleAnimType {
        eStyleAnimType_Custom = 0,
        eStyleAnimType_Coord = 1,
        eStyleAnimType_Sides_Top = 2,
        eStyleAnimType_Sides_Right = 3,
        eStyleAnimType_Sides_Bottom = 4,
        eStyleAnimType_Sides_Left = 5,
        eStyleAnimType_Corner_TopLeft = 6,
        eStyleAnimType_Corner_TopRight = 7,
        eStyleAnimType_Corner_BottomRight = 8,
        eStyleAnimType_Corner_BottomLeft = 9,
        eStyleAnimType_nscoord = 10,
        eStyleAnimType_float = 11,
        eStyleAnimType_Color = 12,
        eStyleAnimType_ComplexColor = 13,
        eStyleAnimType_PaintServer = 14,
        eStyleAnimType_Shadow = 15,
        eStyleAnimType_Discrete = 16,
        eStyleAnimType_None = 17,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCSSProps {
        pub _address: u8,
    }
    pub use self::super::root::mozilla::CSSEnabledState as
            nsCSSProps_EnabledState;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCSSProps_KTableEntry {
        pub mKeyword: root::nsCSSKeyword,
        pub mValue: i16,
    }
    #[test]
    fn bindgen_test_layout_nsCSSProps_KTableEntry() {
        assert_eq!(::std::mem::size_of::<nsCSSProps_KTableEntry>() , 4usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSProps_KTableEntry ) ));
        assert_eq! (::std::mem::align_of::<nsCSSProps_KTableEntry>() , 2usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsCSSProps_KTableEntry )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSProps_KTableEntry ) ) . mKeyword
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSProps_KTableEntry ) , "::" , stringify ! ( mKeyword )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSProps_KTableEntry ) ) . mValue
                    as * const _ as usize } , 2usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSProps_KTableEntry ) , "::" , stringify ! ( mValue )
                    ));
    }
    impl Clone for nsCSSProps_KTableEntry {
        fn clone(&self) -> Self { *self }
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps9kSIDTableE"]
        pub static mut nsCSSProps_kSIDTable:
                   [root::nsStyleStructID; 316usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kKeywordTableTableE"]
        pub static mut nsCSSProps_kKeywordTableTable:
                   [*const root::nsCSSProps_KTableEntry; 316usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kAnimTypeTableE"]
        pub static mut nsCSSProps_kAnimTypeTable:
                   [root::nsStyleAnimType; 316usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kStyleStructOffsetTableE"]
        pub static mut nsCSSProps_kStyleStructOffsetTable: [isize; 316usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps11kFlagsTableE"]
        pub static mut nsCSSProps_kFlagsTable: [u32; 364usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kParserVariantTableE"]
        pub static mut nsCSSProps_kParserVariantTable: [u32; 316usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kSubpropertyTableE"]
        pub static mut nsCSSProps_kSubpropertyTable:
                   [*const root::nsCSSPropertyID; 48usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps26gShorthandsContainingTableE"]
        pub static mut nsCSSProps_gShorthandsContainingTable:
                   [*mut root::nsCSSPropertyID; 316usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25gShorthandsContainingPoolE"]
        pub static mut nsCSSProps_gShorthandsContainingPool:
                   *mut root::nsCSSPropertyID;
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps22gPropertyCountInStructE"]
        pub static mut nsCSSProps_gPropertyCountInStruct: [usize; 24usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps22gPropertyIndexInStructE"]
        pub static mut nsCSSProps_gPropertyIndexInStruct: [usize; 316usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kLogicalGroupTableE"]
        pub static mut nsCSSProps_kLogicalGroupTable:
                   [*const root::nsCSSPropertyID; 9usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16gPropertyEnabledE"]
        pub static mut nsCSSProps_gPropertyEnabled: [bool; 472usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps13kIDLNameTableE"]
        pub static mut nsCSSProps_kIDLNameTable:
                   [*const ::std::os::raw::c_char; 364usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kIDLNameSortPositionTableE"]
        pub static mut nsCSSProps_kIDLNameSortPositionTable: [i32; 364usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19gPropertyUseCounterE"]
        pub static mut nsCSSProps_gPropertyUseCounter:
                   [root::mozilla::UseCounter; 316usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kAnimationDirectionKTableE"]
        pub static mut nsCSSProps_kAnimationDirectionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps24kAnimationFillModeKTableE"]
        pub static mut nsCSSProps_kAnimationFillModeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps30kAnimationIterationCountKTableE"]
        pub static mut nsCSSProps_kAnimationIterationCountKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kAnimationPlayStateKTableE"]
        pub static mut nsCSSProps_kAnimationPlayStateKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps30kAnimationTimingFunctionKTableE"]
        pub static mut nsCSSProps_kAnimationTimingFunctionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kAppearanceKTableE"]
        pub static mut nsCSSProps_kAppearanceKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kAzimuthKTableE"]
        pub static mut nsCSSProps_kAzimuthKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kBackfaceVisibilityKTableE"]
        pub static mut nsCSSProps_kBackfaceVisibilityKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kTransformStyleKTableE"]
        pub static mut nsCSSProps_kTransformStyleKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kImageLayerAttachmentKTableE"]
        pub static mut nsCSSProps_kImageLayerAttachmentKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kBackgroundOriginKTableE"]
        pub static mut nsCSSProps_kBackgroundOriginKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kMaskOriginKTableE"]
        pub static mut nsCSSProps_kMaskOriginKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kImageLayerPositionKTableE"]
        pub static mut nsCSSProps_kImageLayerPositionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kImageLayerRepeatKTableE"]
        pub static mut nsCSSProps_kImageLayerRepeatKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kImageLayerRepeatPartKTableE"]
        pub static mut nsCSSProps_kImageLayerRepeatPartKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kImageLayerSizeKTableE"]
        pub static mut nsCSSProps_kImageLayerSizeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps26kImageLayerCompositeKTableE"]
        pub static mut nsCSSProps_kImageLayerCompositeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kImageLayerModeKTableE"]
        pub static mut nsCSSProps_kImageLayerModeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kBackgroundClipKTableE"]
        pub static mut nsCSSProps_kBackgroundClipKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kMaskClipKTableE"]
        pub static mut nsCSSProps_kMaskClipKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kBlendModeKTableE"]
        pub static mut nsCSSProps_kBlendModeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kBorderCollapseKTableE"]
        pub static mut nsCSSProps_kBorderCollapseKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps24kBorderImageRepeatKTableE"]
        pub static mut nsCSSProps_kBorderImageRepeatKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kBorderImageSliceKTableE"]
        pub static mut nsCSSProps_kBorderImageSliceKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kBorderStyleKTableE"]
        pub static mut nsCSSProps_kBorderStyleKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kBorderWidthKTableE"]
        pub static mut nsCSSProps_kBorderWidthKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kBoxAlignKTableE"]
        pub static mut nsCSSProps_kBoxAlignKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kBoxDecorationBreakKTableE"]
        pub static mut nsCSSProps_kBoxDecorationBreakKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kBoxDirectionKTableE"]
        pub static mut nsCSSProps_kBoxDirectionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kBoxOrientKTableE"]
        pub static mut nsCSSProps_kBoxOrientKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kBoxPackKTableE"]
        pub static mut nsCSSProps_kBoxPackKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps26kClipPathGeometryBoxKTableE"]
        pub static mut nsCSSProps_kClipPathGeometryBoxKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kCounterRangeKTableE"]
        pub static mut nsCSSProps_kCounterRangeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kCounterSpeakAsKTableE"]
        pub static mut nsCSSProps_kCounterSpeakAsKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kCounterSymbolsSystemKTableE"]
        pub static mut nsCSSProps_kCounterSymbolsSystemKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kCounterSystemKTableE"]
        pub static mut nsCSSProps_kCounterSystemKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kDominantBaselineKTableE"]
        pub static mut nsCSSProps_kDominantBaselineKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kShapeRadiusKTableE"]
        pub static mut nsCSSProps_kShapeRadiusKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kFillRuleKTableE"]
        pub static mut nsCSSProps_kFillRuleKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kFilterFunctionKTableE"]
        pub static mut nsCSSProps_kFilterFunctionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kImageRenderingKTableE"]
        pub static mut nsCSSProps_kImageRenderingKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kShapeOutsideShapeBoxKTableE"]
        pub static mut nsCSSProps_kShapeOutsideShapeBoxKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kShapeRenderingKTableE"]
        pub static mut nsCSSProps_kShapeRenderingKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kStrokeLinecapKTableE"]
        pub static mut nsCSSProps_kStrokeLinecapKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kStrokeLinejoinKTableE"]
        pub static mut nsCSSProps_kStrokeLinejoinKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kStrokeContextValueKTableE"]
        pub static mut nsCSSProps_kStrokeContextValueKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kVectorEffectKTableE"]
        pub static mut nsCSSProps_kVectorEffectKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kTextAnchorKTableE"]
        pub static mut nsCSSProps_kTextAnchorKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kTextRenderingKTableE"]
        pub static mut nsCSSProps_kTextRenderingKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kColorAdjustKTableE"]
        pub static mut nsCSSProps_kColorAdjustKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kColorInterpolationKTableE"]
        pub static mut nsCSSProps_kColorInterpolationKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kColumnFillKTableE"]
        pub static mut nsCSSProps_kColumnFillKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kBoxPropSourceKTableE"]
        pub static mut nsCSSProps_kBoxPropSourceKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kBoxShadowTypeKTableE"]
        pub static mut nsCSSProps_kBoxShadowTypeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kBoxSizingKTableE"]
        pub static mut nsCSSProps_kBoxSizingKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kCaptionSideKTableE"]
        pub static mut nsCSSProps_kCaptionSideKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps12kClearKTableE"]
        pub static mut nsCSSProps_kClearKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps12kColorKTableE"]
        pub static mut nsCSSProps_kColorKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kContentKTableE"]
        pub static mut nsCSSProps_kContentKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps33kControlCharacterVisibilityKTableE"]
        pub static mut nsCSSProps_kControlCharacterVisibilityKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps13kCursorKTableE"]
        pub static mut nsCSSProps_kCursorKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kDirectionKTableE"]
        pub static mut nsCSSProps_kDirectionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kDisplayKTableE"]
        pub static mut nsCSSProps_kDisplayKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kElevationKTableE"]
        pub static mut nsCSSProps_kElevationKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kEmptyCellsKTableE"]
        pub static mut nsCSSProps_kEmptyCellsKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kAlignAllKeywordsE"]
        pub static mut nsCSSProps_kAlignAllKeywords:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps22kAlignOverflowPositionE"]
        pub static mut nsCSSProps_kAlignOverflowPosition:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kAlignSelfPositionE"]
        pub static mut nsCSSProps_kAlignSelfPosition:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps12kAlignLegacyE"]
        pub static mut nsCSSProps_kAlignLegacy:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kAlignLegacyPositionE"]
        pub static mut nsCSSProps_kAlignLegacyPosition:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps31kAlignAutoNormalStretchBaselineE"]
        pub static mut nsCSSProps_kAlignAutoNormalStretchBaseline:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kAlignNormalStretchBaselineE"]
        pub static mut nsCSSProps_kAlignNormalStretchBaseline:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kAlignNormalBaselineE"]
        pub static mut nsCSSProps_kAlignNormalBaseline:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kAlignContentDistributionE"]
        pub static mut nsCSSProps_kAlignContentDistribution:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kAlignContentPositionE"]
        pub static mut nsCSSProps_kAlignContentPosition:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps31kAutoCompletionAlignJustifySelfE"]
        pub static mut nsCSSProps_kAutoCompletionAlignJustifySelf:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kAutoCompletionAlignItemsE"]
        pub static mut nsCSSProps_kAutoCompletionAlignItems:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps34kAutoCompletionAlignJustifyContentE"]
        pub static mut nsCSSProps_kAutoCompletionAlignJustifyContent:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kFlexDirectionKTableE"]
        pub static mut nsCSSProps_kFlexDirectionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kFlexWrapKTableE"]
        pub static mut nsCSSProps_kFlexWrapKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps12kFloatKTableE"]
        pub static mut nsCSSProps_kFloatKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kFloatEdgeKTableE"]
        pub static mut nsCSSProps_kFloatEdgeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kFontDisplayKTableE"]
        pub static mut nsCSSProps_kFontDisplayKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps11kFontKTableE"]
        pub static mut nsCSSProps_kFontKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kFontKerningKTableE"]
        pub static mut nsCSSProps_kFontKerningKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kFontSizeKTableE"]
        pub static mut nsCSSProps_kFontSizeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kFontSmoothingKTableE"]
        pub static mut nsCSSProps_kFontSmoothingKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kFontStretchKTableE"]
        pub static mut nsCSSProps_kFontStretchKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kFontStyleKTableE"]
        pub static mut nsCSSProps_kFontStyleKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kFontSynthesisKTableE"]
        pub static mut nsCSSProps_kFontSynthesisKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kFontVariantKTableE"]
        pub static mut nsCSSProps_kFontVariantKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps28kFontVariantAlternatesKTableE"]
        pub static mut nsCSSProps_kFontVariantAlternatesKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps33kFontVariantAlternatesFuncsKTableE"]
        pub static mut nsCSSProps_kFontVariantAlternatesFuncsKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps22kFontVariantCapsKTableE"]
        pub static mut nsCSSProps_kFontVariantCapsKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kFontVariantEastAsianKTableE"]
        pub static mut nsCSSProps_kFontVariantEastAsianKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kFontVariantLigaturesKTableE"]
        pub static mut nsCSSProps_kFontVariantLigaturesKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kFontVariantNumericKTableE"]
        pub static mut nsCSSProps_kFontVariantNumericKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps26kFontVariantPositionKTableE"]
        pub static mut nsCSSProps_kFontVariantPositionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kFontWeightKTableE"]
        pub static mut nsCSSProps_kFontWeightKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kGridAutoFlowKTableE"]
        pub static mut nsCSSProps_kGridAutoFlowKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kGridTrackBreadthKTableE"]
        pub static mut nsCSSProps_kGridTrackBreadthKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kHyphensKTableE"]
        pub static mut nsCSSProps_kHyphensKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kImageOrientationKTableE"]
        pub static mut nsCSSProps_kImageOrientationKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kImageOrientationFlipKTableE"]
        pub static mut nsCSSProps_kImageOrientationFlipKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kIsolationKTableE"]
        pub static mut nsCSSProps_kIsolationKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kIMEModeKTableE"]
        pub static mut nsCSSProps_kIMEModeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kLineHeightKTableE"]
        pub static mut nsCSSProps_kLineHeightKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps24kListStylePositionKTableE"]
        pub static mut nsCSSProps_kListStylePositionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kListStyleKTableE"]
        pub static mut nsCSSProps_kListStyleKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kMaskTypeKTableE"]
        pub static mut nsCSSProps_kMaskTypeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kMathVariantKTableE"]
        pub static mut nsCSSProps_kMathVariantKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kMathDisplayKTableE"]
        pub static mut nsCSSProps_kMathDisplayKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps14kContainKTableE"]
        pub static mut nsCSSProps_kContainKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kContextOpacityKTableE"]
        pub static mut nsCSSProps_kContextOpacityKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kContextPatternKTableE"]
        pub static mut nsCSSProps_kContextPatternKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kObjectFitKTableE"]
        pub static mut nsCSSProps_kObjectFitKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps13kOrientKTableE"]
        pub static mut nsCSSProps_kOrientKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kOutlineStyleKTableE"]
        pub static mut nsCSSProps_kOutlineStyleKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kOverflowKTableE"]
        pub static mut nsCSSProps_kOverflowKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kOverflowSubKTableE"]
        pub static mut nsCSSProps_kOverflowSubKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps22kOverflowClipBoxKTableE"]
        pub static mut nsCSSProps_kOverflowClipBoxKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kOverflowWrapKTableE"]
        pub static mut nsCSSProps_kOverflowWrapKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kPageBreakKTableE"]
        pub static mut nsCSSProps_kPageBreakKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps22kPageBreakInsideKTableE"]
        pub static mut nsCSSProps_kPageBreakInsideKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kPageMarksKTableE"]
        pub static mut nsCSSProps_kPageMarksKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kPageSizeKTableE"]
        pub static mut nsCSSProps_kPageSizeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps12kPitchKTableE"]
        pub static mut nsCSSProps_kPitchKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kPointerEventsKTableE"]
        pub static mut nsCSSProps_kPointerEventsKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kPositionKTableE"]
        pub static mut nsCSSProps_kPositionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps26kRadialGradientShapeKTableE"]
        pub static mut nsCSSProps_kRadialGradientShapeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kRadialGradientSizeKTableE"]
        pub static mut nsCSSProps_kRadialGradientSizeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps31kRadialGradientLegacySizeKTableE"]
        pub static mut nsCSSProps_kRadialGradientLegacySizeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps13kResizeKTableE"]
        pub static mut nsCSSProps_kResizeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kRubyAlignKTableE"]
        pub static mut nsCSSProps_kRubyAlignKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kRubyPositionKTableE"]
        pub static mut nsCSSProps_kRubyPositionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kScrollBehaviorKTableE"]
        pub static mut nsCSSProps_kScrollBehaviorKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kScrollSnapTypeKTableE"]
        pub static mut nsCSSProps_kScrollSnapTypeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps12kSpeakKTableE"]
        pub static mut nsCSSProps_kSpeakKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kSpeakHeaderKTableE"]
        pub static mut nsCSSProps_kSpeakHeaderKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kSpeakNumeralKTableE"]
        pub static mut nsCSSProps_kSpeakNumeralKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps23kSpeakPunctuationKTableE"]
        pub static mut nsCSSProps_kSpeakPunctuationKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kSpeechRateKTableE"]
        pub static mut nsCSSProps_kSpeechRateKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kStackSizingKTableE"]
        pub static mut nsCSSProps_kStackSizingKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kTableLayoutKTableE"]
        pub static mut nsCSSProps_kTableLayoutKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kTextAlignKTableE"]
        pub static mut nsCSSProps_kTextAlignKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kTextAlignLastKTableE"]
        pub static mut nsCSSProps_kTextAlignLastKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kTextCombineUprightKTableE"]
        pub static mut nsCSSProps_kTextCombineUprightKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps25kTextDecorationLineKTableE"]
        pub static mut nsCSSProps_kTextDecorationLineKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps26kTextDecorationStyleKTableE"]
        pub static mut nsCSSProps_kTextDecorationStyleKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps27kTextEmphasisPositionKTableE"]
        pub static mut nsCSSProps_kTextEmphasisPositionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps28kTextEmphasisStyleFillKTableE"]
        pub static mut nsCSSProps_kTextEmphasisStyleFillKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps29kTextEmphasisStyleShapeKTableE"]
        pub static mut nsCSSProps_kTextEmphasisStyleShapeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps22kTextOrientationKTableE"]
        pub static mut nsCSSProps_kTextOrientationKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kTextOverflowKTableE"]
        pub static mut nsCSSProps_kTextOverflowKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kTextTransformKTableE"]
        pub static mut nsCSSProps_kTextTransformKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kTouchActionKTableE"]
        pub static mut nsCSSProps_kTouchActionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps15kTopLayerKTableE"]
        pub static mut nsCSSProps_kTopLayerKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kTransformBoxKTableE"]
        pub static mut nsCSSProps_kTransformBoxKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps31kTransitionTimingFunctionKTableE"]
        pub static mut nsCSSProps_kTransitionTimingFunctionKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kUnicodeBidiKTableE"]
        pub static mut nsCSSProps_kUnicodeBidiKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kUserFocusKTableE"]
        pub static mut nsCSSProps_kUserFocusKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kUserInputKTableE"]
        pub static mut nsCSSProps_kUserInputKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kUserModifyKTableE"]
        pub static mut nsCSSProps_kUserModifyKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kUserSelectKTableE"]
        pub static mut nsCSSProps_kUserSelectKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps20kVerticalAlignKTableE"]
        pub static mut nsCSSProps_kVerticalAlignKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kVisibilityKTableE"]
        pub static mut nsCSSProps_kVisibilityKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps13kVolumeKTableE"]
        pub static mut nsCSSProps_kVolumeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps17kWhitespaceKTableE"]
        pub static mut nsCSSProps_kWhitespaceKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps12kWidthKTableE"]
        pub static mut nsCSSProps_kWidthKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps21kWindowDraggingKTableE"]
        pub static mut nsCSSProps_kWindowDraggingKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps19kWindowShadowKTableE"]
        pub static mut nsCSSProps_kWindowShadowKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps16kWordBreakKTableE"]
        pub static mut nsCSSProps_kWordBreakKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN10nsCSSProps18kWritingModeKTableE"]
        pub static mut nsCSSProps_kWritingModeKTable:
                   [root::nsCSSProps_KTableEntry; 0usize];
    }
    #[test]
    fn bindgen_test_layout_nsCSSProps() {
        assert_eq!(::std::mem::size_of::<nsCSSProps>() , 1usize , concat ! (
                   "Size of: " , stringify ! ( nsCSSProps ) ));
        assert_eq! (::std::mem::align_of::<nsCSSProps>() , 1usize , concat ! (
                    "Alignment of " , stringify ! ( nsCSSProps ) ));
    }
    impl Clone for nsCSSProps {
        fn clone(&self) -> Self { *self }
    }
    /**
 * Class to safely handle main-thread-only pointers off the main thread.
 *
 * Classes like XPCWrappedJS are main-thread-only, which means that it is
 * forbidden to call methods on instances of these classes off the main thread.
 * For various reasons (see bug 771074), this restriction recently began to
 * apply to AddRef/Release as well.
 *
 * This presents a problem for consumers that wish to hold a callback alive
 * on non-main-thread code. A common example of this is the proxy callback
 * pattern, where non-main-thread code holds a strong-reference to the callback
 * object, and dispatches new Runnables (also with a strong reference) to the
 * main thread in order to execute the callback. This involves several AddRef
 * and Release calls on the other thread, which is (now) verboten.
 *
 * The basic idea of this class is to introduce a layer of indirection.
 * nsMainThreadPtrHolder is a threadsafe reference-counted class that internally
 * maintains one strong reference to the main-thread-only object. It must be
 * instantiated on the main thread (so that the AddRef of the underlying object
 * happens on the main thread), but consumers may subsequently pass references
 * to the holder anywhere they please. These references are meant to be opaque
 * when accessed off-main-thread (assertions enforce this).
 *
 * The semantics of RefPtr<nsMainThreadPtrHolder<T> > would be cumbersome, so
 * we also introduce nsMainThreadPtrHandle<T>, which is conceptually identical
 * to the above (though it includes various convenience methods). The basic
 * pattern is as follows.
 *
 * // On the main thread:
 * nsCOMPtr<nsIFooCallback> callback = ...;
 * nsMainThreadPtrHandle<nsIFooCallback> callbackHandle =
 *   new nsMainThreadPtrHolder<nsIFooCallback>(callback);
 * // Pass callbackHandle to structs/classes that might be accessed on other
 * // threads.
 *
 * All structs and classes that might be accessed on other threads should store
 * an nsMainThreadPtrHandle<T> rather than an nsCOMPtr<T>.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMainThreadPtrHolder<T> {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mRawPtr: *mut T,
        pub mStrict: bool,
    }
    pub type nsMainThreadPtrHolder_HasThreadSafeRefCnt =
        root::mozilla::TrueType;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMainThreadPtrHandle<T> {
        pub mPtr: root::RefPtr<root::nsMainThreadPtrHolder<T>>,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct gfxFontFeature {
        pub mTag: u32,
        pub mValue: u32,
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeature() {
        assert_eq!(::std::mem::size_of::<gfxFontFeature>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( gfxFontFeature ) ));
        assert_eq! (::std::mem::align_of::<gfxFontFeature>() , 4usize , concat
                    ! ( "Alignment of " , stringify ! ( gfxFontFeature ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxFontFeature ) ) . mTag as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( gfxFontFeature ) ,
                    "::" , stringify ! ( mTag ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxFontFeature ) ) . mValue as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( gfxFontFeature ) ,
                    "::" , stringify ! ( mValue ) ));
    }
    impl Clone for gfxFontFeature {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxAlternateValue {
        pub alternate: u32,
        pub value: ::nsstring::nsStringRepr,
    }
    #[test]
    fn bindgen_test_layout_gfxAlternateValue() {
        assert_eq!(::std::mem::size_of::<gfxAlternateValue>() , 24usize ,
                   concat ! ( "Size of: " , stringify ! ( gfxAlternateValue )
                   ));
        assert_eq! (::std::mem::align_of::<gfxAlternateValue>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( gfxAlternateValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxAlternateValue ) ) . alternate as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( gfxAlternateValue )
                    , "::" , stringify ! ( alternate ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxAlternateValue ) ) . value as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( gfxAlternateValue )
                    , "::" , stringify ! ( value ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxFontFeatureValueSet {
        pub mRefCnt: root::nsAutoRefCnt,
        pub mFontFeatureValues: [u64; 5usize],
    }
    pub type gfxFontFeatureValueSet_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxFontFeatureValueSet_ValueList {
        pub name: ::nsstring::nsStringRepr,
        pub featureSelectors: root::nsTArray<::std::os::raw::c_uint>,
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeatureValueSet_ValueList() {
        assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet_ValueList>() ,
                   24usize , concat ! (
                   "Size of: " , stringify ! (
                   gfxFontFeatureValueSet_ValueList ) ));
        assert_eq! (::std::mem::align_of::<gfxFontFeatureValueSet_ValueList>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    gfxFontFeatureValueSet_ValueList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxFontFeatureValueSet_ValueList ) )
                    . name as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_ValueList ) , "::" , stringify ! (
                    name ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxFontFeatureValueSet_ValueList ) )
                    . featureSelectors as * const _ as usize } , 16usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_ValueList ) , "::" , stringify ! (
                    featureSelectors ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxFontFeatureValueSet_FeatureValues {
        pub alternate: u32,
        pub valuelist: root::nsTArray<root::gfxFontFeatureValueSet_ValueList>,
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeatureValueSet_FeatureValues() {
        assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet_FeatureValues>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   gfxFontFeatureValueSet_FeatureValues ) ));
        assert_eq! (::std::mem::align_of::<gfxFontFeatureValueSet_FeatureValues>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValues ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const gfxFontFeatureValueSet_FeatureValues ) )
                    . alternate as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValues ) , "::" , stringify
                    ! ( alternate ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const gfxFontFeatureValueSet_FeatureValues ) )
                    . valuelist as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValues ) , "::" , stringify
                    ! ( valuelist ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxFontFeatureValueSet_FeatureValueHashKey {
        pub mFamily: ::nsstring::nsStringRepr,
        pub mPropVal: u32,
        pub mName: ::nsstring::nsStringRepr,
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeatureValueSet_FeatureValueHashKey() {
        assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet_FeatureValueHashKey>()
                   , 40usize , concat ! (
                   "Size of: " , stringify ! (
                   gfxFontFeatureValueSet_FeatureValueHashKey ) ));
        assert_eq! (::std::mem::align_of::<gfxFontFeatureValueSet_FeatureValueHashKey>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValueHashKey ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const gfxFontFeatureValueSet_FeatureValueHashKey )
                    ) . mFamily as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValueHashKey ) , "::" ,
                    stringify ! ( mFamily ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const gfxFontFeatureValueSet_FeatureValueHashKey )
                    ) . mPropVal as * const _ as usize } , 16usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValueHashKey ) , "::" ,
                    stringify ! ( mPropVal ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const gfxFontFeatureValueSet_FeatureValueHashKey )
                    ) . mName as * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValueHashKey ) , "::" ,
                    stringify ! ( mName ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxFontFeatureValueSet_FeatureValueHashEntry {
        pub _base: root::PLDHashEntryHdr,
        pub mKey: root::gfxFontFeatureValueSet_FeatureValueHashKey,
        pub mValues: root::nsTArray<::std::os::raw::c_uint>,
    }
    pub type gfxFontFeatureValueSet_FeatureValueHashEntry_KeyType =
        *const root::gfxFontFeatureValueSet_FeatureValueHashKey;
    pub type gfxFontFeatureValueSet_FeatureValueHashEntry_KeyTypePointer =
        *const root::gfxFontFeatureValueSet_FeatureValueHashKey;
    pub const gfxFontFeatureValueSet_FeatureValueHashEntry_ALLOW_MEMMOVE:
              root::gfxFontFeatureValueSet_FeatureValueHashEntry__bindgen_ty_1
              =
        gfxFontFeatureValueSet_FeatureValueHashEntry__bindgen_ty_1::ALLOW_MEMMOVE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum gfxFontFeatureValueSet_FeatureValueHashEntry__bindgen_ty_1 {
        ALLOW_MEMMOVE = 1,
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeatureValueSet_FeatureValueHashEntry() {
        assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet_FeatureValueHashEntry>()
                   , 56usize , concat ! (
                   "Size of: " , stringify ! (
                   gfxFontFeatureValueSet_FeatureValueHashEntry ) ));
        assert_eq! (::std::mem::align_of::<gfxFontFeatureValueSet_FeatureValueHashEntry>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValueHashEntry ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const gfxFontFeatureValueSet_FeatureValueHashEntry
                    ) ) . mKey as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValueHashEntry ) , "::" ,
                    stringify ! ( mKey ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const gfxFontFeatureValueSet_FeatureValueHashEntry
                    ) ) . mValues as * const _ as usize } , 48usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet_FeatureValueHashEntry ) , "::" ,
                    stringify ! ( mValues ) ));
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeatureValueSet() {
        assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet>() , 48usize ,
                   concat ! (
                   "Size of: " , stringify ! ( gfxFontFeatureValueSet ) ));
        assert_eq! (::std::mem::align_of::<gfxFontFeatureValueSet>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( gfxFontFeatureValueSet )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxFontFeatureValueSet ) ) . mRefCnt
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet ) , "::" , stringify ! ( mRefCnt )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxFontFeatureValueSet ) ) .
                    mFontFeatureValues as * const _ as usize } , 8usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    gfxFontFeatureValueSet ) , "::" , stringify ! (
                    mFontFeatureValues ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct gfxFontVariation {
        pub mTag: u32,
        pub mValue: f32,
    }
    #[test]
    fn bindgen_test_layout_gfxFontVariation() {
        assert_eq!(::std::mem::size_of::<gfxFontVariation>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( gfxFontVariation ) ));
        assert_eq! (::std::mem::align_of::<gfxFontVariation>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( gfxFontVariation ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxFontVariation ) ) . mTag as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( gfxFontVariation )
                    , "::" , stringify ! ( mTag ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const gfxFontVariation ) ) . mValue as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( gfxFontVariation )
                    , "::" , stringify ! ( mValue ) ));
    }
    impl Clone for gfxFontVariation {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct gfxFontStyle([u8; 0]);
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsFont {
        pub fontlist: root::mozilla::FontFamilyList,
        pub style: u8,
        pub systemFont: bool,
        pub variantCaps: u8,
        pub variantNumeric: u8,
        pub variantPosition: u8,
        pub variantWidth: u8,
        pub variantLigatures: u16,
        pub variantEastAsian: u16,
        pub variantAlternates: u16,
        pub smoothing: u8,
        pub weight: u16,
        pub stretch: i16,
        pub kerning: u8,
        pub synthesis: u8,
        pub size: root::nscoord,
        pub sizeAdjust: f32,
        pub alternateValues: root::nsTArray<root::gfxAlternateValue>,
        pub featureValueLookup: root::RefPtr<root::gfxFontFeatureValueSet>,
        pub fontFeatureSettings: root::nsTArray<root::gfxFontFeature>,
        pub fontVariationSettings: root::nsTArray<root::gfxFontVariation>,
        pub languageOverride: ::nsstring::nsStringRepr,
    }
    #[test]
    fn bindgen_test_layout_nsFont() {
        assert_eq!(::std::mem::size_of::<nsFont>() , 96usize , concat ! (
                   "Size of: " , stringify ! ( nsFont ) ));
        assert_eq! (::std::mem::align_of::<nsFont>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsFont ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . fontlist as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( fontlist ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . style as * const _ as
                    usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( style ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . systemFont as * const _
                    as usize } , 17usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( systemFont ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . variantCaps as * const _
                    as usize } , 18usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( variantCaps ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . variantNumeric as *
                    const _ as usize } , 19usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( variantNumeric ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . variantPosition as *
                    const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( variantPosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . variantWidth as * const
                    _ as usize } , 21usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( variantWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . variantLigatures as *
                    const _ as usize } , 22usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( variantLigatures ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . variantEastAsian as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( variantEastAsian ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . variantAlternates as *
                    const _ as usize } , 26usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( variantAlternates ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . smoothing as * const _
                    as usize } , 28usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( smoothing ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . weight as * const _ as
                    usize } , 30usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( weight ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . stretch as * const _ as
                    usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( stretch ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . kerning as * const _ as
                    usize } , 34usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( kerning ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . synthesis as * const _
                    as usize } , 35usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( synthesis ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . size as * const _ as
                    usize } , 36usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( size ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . sizeAdjust as * const _
                    as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( sizeAdjust ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . alternateValues as *
                    const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( alternateValues ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . featureValueLookup as *
                    const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( featureValueLookup ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . fontFeatureSettings as *
                    const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( fontFeatureSettings ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . fontVariationSettings as
                    * const _ as usize } , 72usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( fontVariationSettings ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFont ) ) . languageOverride as *
                    const _ as usize } , 80usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFont ) , "::" ,
                    stringify ! ( languageOverride ) ));
    }
    pub const nsStyleUnit_eStyleUnit_MAX: root::nsStyleUnit =
        nsStyleUnit::eStyleUnit_Calc;
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleUnit {
        eStyleUnit_Null = 0,
        eStyleUnit_Normal = 1,
        eStyleUnit_Auto = 2,
        eStyleUnit_None = 3,
        eStyleUnit_Percent = 10,
        eStyleUnit_Factor = 11,
        eStyleUnit_Degree = 12,
        eStyleUnit_Grad = 13,
        eStyleUnit_Radian = 14,
        eStyleUnit_Turn = 15,
        eStyleUnit_FlexFraction = 16,
        eStyleUnit_Coord = 20,
        eStyleUnit_Integer = 30,
        eStyleUnit_Enumerated = 32,
        eStyleUnit_Calc = 40,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleUnion {
        pub mInt: root::__BindgenUnionField<i32>,
        pub mFloat: root::__BindgenUnionField<f32>,
        pub mPointer: root::__BindgenUnionField<*mut ::std::os::raw::c_void>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsStyleUnion() {
        assert_eq!(::std::mem::size_of::<nsStyleUnion>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleUnion ) ));
        assert_eq! (::std::mem::align_of::<nsStyleUnion>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleUnion ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUnion ) ) . mInt as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUnion ) ,
                    "::" , stringify ! ( mInt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUnion ) ) . mFloat as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUnion ) ,
                    "::" , stringify ! ( mFloat ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUnion ) ) . mPointer as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUnion ) ,
                    "::" , stringify ! ( mPointer ) ));
    }
    impl Clone for nsStyleUnion {
        fn clone(&self) -> Self { *self }
    }
    /**
 * Class that hold a single size specification used by the style
 * system.  The size specification consists of two parts -- a number
 * and a unit.  The number is an integer, a floating point value, an
 * nscoord, or undefined, and the unit is an nsStyleUnit.  Checking
 * the unit is a must before asking for the value in any particular
 * form.
 */
 /** <div rustbindgen private accessor="unsafe"></div> */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleCoord {
        mUnit: root::nsStyleUnit,
        mValue: root::nsStyleUnion,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleCoord_CalcValue {
        pub mLength: root::nscoord,
        pub mPercent: f32,
        pub mHasPercent: bool,
    }
    #[test]
    fn bindgen_test_layout_nsStyleCoord_CalcValue() {
        assert_eq!(::std::mem::size_of::<nsStyleCoord_CalcValue>() , 12usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsStyleCoord_CalcValue ) ));
        assert_eq! (::std::mem::align_of::<nsStyleCoord_CalcValue>() , 4usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsStyleCoord_CalcValue )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCoord_CalcValue ) ) . mLength
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleCoord_CalcValue ) , "::" , stringify ! ( mLength )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCoord_CalcValue ) ) . mPercent
                    as * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleCoord_CalcValue ) , "::" , stringify ! ( mPercent )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCoord_CalcValue ) ) .
                    mHasPercent as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleCoord_CalcValue ) , "::" , stringify ! (
                    mHasPercent ) ));
    }
    impl Clone for nsStyleCoord_CalcValue {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleCoord_Calc {
        pub _base: root::nsStyleCoord_CalcValue,
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
    }
    pub type nsStyleCoord_Calc_HasThreadSafeRefCnt = root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsStyleCoord_Calc() {
        assert_eq!(::std::mem::size_of::<nsStyleCoord_Calc>() , 24usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleCoord_Calc )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleCoord_Calc>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleCoord_Calc ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCoord_Calc ) ) . mRefCnt as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleCoord_Calc )
                    , "::" , stringify ! ( mRefCnt ) ));
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleCoord_CoordConstructorType { CoordConstructor = 0, }
    #[test]
    fn bindgen_test_layout_nsStyleCoord() {
        assert_eq!(::std::mem::size_of::<nsStyleCoord>() , 16usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleCoord ) ));
        assert_eq! (::std::mem::align_of::<nsStyleCoord>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleCoord ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCoord ) ) . mUnit as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleCoord ) ,
                    "::" , stringify ! ( mUnit ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCoord ) ) . mValue as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleCoord ) ,
                    "::" , stringify ! ( mValue ) ));
    }
    impl nsStyleCoord {
        #[inline]
        pub unsafe fn get_mUnit(&self) -> &root::nsStyleUnit { &self.mUnit }
        #[inline]
        pub unsafe fn get_mUnit_mut(&mut self) -> &mut root::nsStyleUnit {
            &mut self.mUnit
        }
        #[inline]
        pub unsafe fn get_mValue(&self) -> &root::nsStyleUnion {
            &self.mValue
        }
        #[inline]
        pub unsafe fn get_mValue_mut(&mut self) -> &mut root::nsStyleUnion {
            &mut self.mValue
        }
    }
    /**
 * Class that represents a set of top/right/bottom/left nsStyleCoords.
 * This is commonly used to hold the widths of the borders, margins,
 * or paddings of a box.
 */
 /** <div rustbindgen private accessor="unsafe"></div> */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleSides {
        mUnits: [root::nsStyleUnit; 4usize],
        mValues: [root::nsStyleUnion; 4usize],
    }
    #[test]
    fn bindgen_test_layout_nsStyleSides() {
        assert_eq!(::std::mem::size_of::<nsStyleSides>() , 40usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleSides ) ));
        assert_eq! (::std::mem::align_of::<nsStyleSides>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleSides ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSides ) ) . mUnits as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSides ) ,
                    "::" , stringify ! ( mUnits ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSides ) ) . mValues as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSides ) ,
                    "::" , stringify ! ( mValues ) ));
    }
    impl nsStyleSides {
        #[inline]
        pub unsafe fn get_mUnits(&self) -> &[root::nsStyleUnit; 4usize] {
            &self.mUnits
        }
        #[inline]
        pub unsafe fn get_mUnits_mut(&mut self)
         -> &mut [root::nsStyleUnit; 4usize] {
            &mut self.mUnits
        }
        #[inline]
        pub unsafe fn get_mValues(&self) -> &[root::nsStyleUnion; 4usize] {
            &self.mValues
        }
        #[inline]
        pub unsafe fn get_mValues_mut(&mut self)
         -> &mut [root::nsStyleUnion; 4usize] {
            &mut self.mValues
        }
    }
    /**
 * Class that represents a set of top-left/top-right/bottom-right/bottom-left
 * nsStyleCoord pairs.  This is used to hold the dimensions of the
 * corners of a box (for, e.g., border-radius and outline-radius).
 */
 /** <div rustbindgen private accessor="unsafe"></div> */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleCorners {
        mUnits: [root::nsStyleUnit; 8usize],
        mValues: [root::nsStyleUnion; 8usize],
    }
    #[test]
    fn bindgen_test_layout_nsStyleCorners() {
        assert_eq!(::std::mem::size_of::<nsStyleCorners>() , 72usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleCorners ) ));
        assert_eq! (::std::mem::align_of::<nsStyleCorners>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleCorners ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCorners ) ) . mUnits as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleCorners ) ,
                    "::" , stringify ! ( mUnits ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCorners ) ) . mValues as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleCorners ) ,
                    "::" , stringify ! ( mValues ) ));
    }
    impl nsStyleCorners {
        #[inline]
        pub unsafe fn get_mUnits(&self) -> &[root::nsStyleUnit; 8usize] {
            &self.mUnits
        }
        #[inline]
        pub unsafe fn get_mUnits_mut(&mut self)
         -> &mut [root::nsStyleUnit; 8usize] {
            &mut self.mUnits
        }
        #[inline]
        pub unsafe fn get_mValues(&self) -> &[root::nsStyleUnion; 8usize] {
            &self.mValues
        }
        #[inline]
        pub unsafe fn get_mValues_mut(&mut self)
         -> &mut [root::nsStyleUnion; 8usize] {
            &mut self.mValues
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct imgRequestProxy {
        pub _base: root::imgIRequest,
        pub _base_1: root::mozilla::image::IProgressObserver,
        pub _base_2: root::nsISupportsPriority,
        pub _base_3: root::nsISecurityInfoProvider,
        pub _base_4: root::nsITimedChannel,
        pub mRefCnt: root::nsAutoRefCnt,
        pub mBehaviour: root::mozilla::UniquePtr<root::ProxyBehaviour,
                                                 root::mozilla::DefaultDelete<root::ProxyBehaviour>>,
        pub mURI: root::RefPtr<root::mozilla::image::ImageURL>,
        pub mListener: *mut root::imgINotificationObserver,
        pub mLoadGroup: root::nsCOMPtr<root::nsILoadGroup>,
        pub mLoadFlags: root::nsLoadFlags,
        pub mLockCount: u32,
        pub mAnimationConsumers: u32,
        pub mCanceled: bool,
        pub mIsInLoadGroup: bool,
        pub mListenerIsStrongRef: bool,
        pub mDecodeRequested: bool,
        pub mDeferNotifications: bool,
    }
    pub type imgRequestProxy_Image = root::mozilla::image::Image;
    pub type imgRequestProxy_ImageURL = root::mozilla::image::ImageURL;
    pub type imgRequestProxy_ProgressTracker =
        root::mozilla::image::ProgressTracker;
    pub type imgRequestProxy_HasThreadSafeRefCnt = root::mozilla::FalseType;
    #[repr(C)]
    #[derive(Debug)]
    pub struct imgRequestProxy_imgCancelRunnable {
        pub _base: root::mozilla::Runnable,
        pub mOwner: root::RefPtr<root::imgRequestProxy>,
        pub mStatus: root::nsresult,
    }
    #[test]
    fn bindgen_test_layout_imgRequestProxy_imgCancelRunnable() {
        assert_eq!(::std::mem::size_of::<imgRequestProxy_imgCancelRunnable>()
                   , 48usize , concat ! (
                   "Size of: " , stringify ! (
                   imgRequestProxy_imgCancelRunnable ) ));
        assert_eq! (::std::mem::align_of::<imgRequestProxy_imgCancelRunnable>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    imgRequestProxy_imgCancelRunnable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const imgRequestProxy_imgCancelRunnable ) )
                    . mOwner as * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    imgRequestProxy_imgCancelRunnable ) , "::" , stringify ! (
                    mOwner ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const imgRequestProxy_imgCancelRunnable ) )
                    . mStatus as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    imgRequestProxy_imgCancelRunnable ) , "::" , stringify ! (
                    mStatus ) ));
    }
    #[test]
    fn bindgen_test_layout_imgRequestProxy() {
        assert_eq!(::std::mem::size_of::<imgRequestProxy>() , 112usize ,
                   concat ! ( "Size of: " , stringify ! ( imgRequestProxy )
                   ));
        assert_eq! (::std::mem::align_of::<imgRequestProxy>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( imgRequestProxy ) ));
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSUnit {
        eCSSUnit_Null = 0,
        eCSSUnit_Auto = 1,
        eCSSUnit_Inherit = 2,
        eCSSUnit_Initial = 3,
        eCSSUnit_Unset = 4,
        eCSSUnit_None = 5,
        eCSSUnit_Normal = 6,
        eCSSUnit_System_Font = 7,
        eCSSUnit_All = 8,
        eCSSUnit_Dummy = 9,
        eCSSUnit_DummyInherit = 10,
        eCSSUnit_String = 11,
        eCSSUnit_Ident = 12,
        eCSSUnit_Attr = 14,
        eCSSUnit_Local_Font = 15,
        eCSSUnit_Font_Format = 16,
        eCSSUnit_Element = 17,
        eCSSUnit_Array = 20,
        eCSSUnit_Counter = 21,
        eCSSUnit_Counters = 22,
        eCSSUnit_Cubic_Bezier = 23,
        eCSSUnit_Steps = 24,
        eCSSUnit_Symbols = 25,
        eCSSUnit_Function = 26,
        eCSSUnit_Calc = 30,
        eCSSUnit_Calc_Plus = 31,
        eCSSUnit_Calc_Minus = 32,
        eCSSUnit_Calc_Times_L = 33,
        eCSSUnit_Calc_Times_R = 34,
        eCSSUnit_Calc_Divided = 35,
        eCSSUnit_URL = 40,
        eCSSUnit_Image = 41,
        eCSSUnit_Gradient = 42,
        eCSSUnit_TokenStream = 43,
        eCSSUnit_GridTemplateAreas = 44,
        eCSSUnit_Pair = 50,
        eCSSUnit_Triplet = 51,
        eCSSUnit_Rect = 52,
        eCSSUnit_List = 53,
        eCSSUnit_ListDep = 54,
        eCSSUnit_SharedList = 55,
        eCSSUnit_PairList = 56,
        eCSSUnit_PairListDep = 57,
        eCSSUnit_FontFamilyList = 58,
        eCSSUnit_Integer = 70,
        eCSSUnit_Enumerated = 71,
        eCSSUnit_EnumColor = 80,
        eCSSUnit_RGBColor = 81,
        eCSSUnit_RGBAColor = 82,
        eCSSUnit_HexColor = 83,
        eCSSUnit_ShortHexColor = 84,
        eCSSUnit_HexColorAlpha = 85,
        eCSSUnit_ShortHexColorAlpha = 86,
        eCSSUnit_PercentageRGBColor = 87,
        eCSSUnit_PercentageRGBAColor = 88,
        eCSSUnit_HSLColor = 89,
        eCSSUnit_HSLAColor = 90,
        eCSSUnit_ComplexColor = 91,
        eCSSUnit_Percent = 100,
        eCSSUnit_Number = 101,
        eCSSUnit_PhysicalMillimeter = 200,
        eCSSUnit_ViewportWidth = 700,
        eCSSUnit_ViewportHeight = 701,
        eCSSUnit_ViewportMin = 702,
        eCSSUnit_ViewportMax = 703,
        eCSSUnit_EM = 800,
        eCSSUnit_XHeight = 801,
        eCSSUnit_Char = 802,
        eCSSUnit_RootEM = 803,
        eCSSUnit_Point = 900,
        eCSSUnit_Inch = 901,
        eCSSUnit_Millimeter = 902,
        eCSSUnit_Centimeter = 903,
        eCSSUnit_Pica = 904,
        eCSSUnit_Quarter = 905,
        eCSSUnit_Pixel = 906,
        eCSSUnit_Degree = 1000,
        eCSSUnit_Grad = 1001,
        eCSSUnit_Radian = 1002,
        eCSSUnit_Turn = 1003,
        eCSSUnit_Hertz = 2000,
        eCSSUnit_Kilohertz = 2001,
        eCSSUnit_Seconds = 3000,
        eCSSUnit_Milliseconds = 3001,
        eCSSUnit_FlexFraction = 4000,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueGradient {
        pub mIsRadial: bool,
        pub mIsRepeating: bool,
        pub mIsLegacySyntax: bool,
        pub mIsExplicitSize: bool,
        pub mBgPos: root::nsCSSValuePair,
        pub mAngle: root::nsCSSValue,
        pub mRadialValues: [root::nsCSSValue; 2usize],
        pub mStops: root::nsTArray<root::nsCSSValueGradientStop>,
        pub mRefCnt: root::nsAutoRefCnt,
    }
    pub type nsCSSValueGradient_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValueGradient() {
        assert_eq!(::std::mem::size_of::<nsCSSValueGradient>() , 104usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCSSValueGradient )
                   ));
        assert_eq! (::std::mem::align_of::<nsCSSValueGradient>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueGradient ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) . mIsRadial as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mIsRadial ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) . mIsRepeating
                    as * const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mIsRepeating ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) .
                    mIsLegacySyntax as * const _ as usize } , 2usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mIsLegacySyntax ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) .
                    mIsExplicitSize as * const _ as usize } , 3usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mIsExplicitSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) . mBgPos as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mBgPos ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) . mAngle as *
                    const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mAngle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) .
                    mRadialValues as * const _ as usize } , 56usize , concat !
                    (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mRadialValues ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) . mStops as *
                    const _ as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mStops ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradient ) ) . mRefCnt as *
                    const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueGradient
                    ) , "::" , stringify ! ( mRefCnt ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValuePair {
        pub mXValue: root::nsCSSValue,
        pub mYValue: root::nsCSSValue,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValuePair() {
        assert_eq!(::std::mem::size_of::<nsCSSValuePair>() , 32usize , concat
                   ! ( "Size of: " , stringify ! ( nsCSSValuePair ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValuePair>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsCSSValuePair ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePair ) ) . mXValue as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValuePair ) ,
                    "::" , stringify ! ( mXValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePair ) ) . mYValue as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValuePair ) ,
                    "::" , stringify ! ( mYValue ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValuePair_heap {
        pub _base: root::nsCSSValuePair,
        pub mRefCnt: root::nsAutoRefCnt,
    }
    pub type nsCSSValuePair_heap_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValuePair_heap() {
        assert_eq!(::std::mem::size_of::<nsCSSValuePair_heap>() , 40usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSValuePair_heap ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValuePair_heap>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValuePair_heap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePair_heap ) ) . mRefCnt as
                    * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValuePair_heap
                    ) , "::" , stringify ! ( mRefCnt ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueTokenStream {
        pub mRefCnt: root::nsAutoRefCnt,
        pub mPropertyID: root::nsCSSPropertyID,
        pub mShorthandPropertyID: root::nsCSSPropertyID,
        pub mTokenStream: ::nsstring::nsStringRepr,
        pub mBaseURI: root::nsCOMPtr<root::nsIURI>,
        pub mSheetURI: root::nsCOMPtr<root::nsIURI>,
        pub mSheetPrincipal: root::nsCOMPtr<root::nsIPrincipal>,
        pub mLineNumber: u32,
        pub mLineOffset: u32,
        pub mLevel: root::mozilla::SheetType,
    }
    pub type nsCSSValueTokenStream_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValueTokenStream() {
        assert_eq!(::std::mem::size_of::<nsCSSValueTokenStream>() , 72usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSValueTokenStream ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValueTokenStream>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueTokenStream )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) . mRefCnt
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! ( mRefCnt )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) .
                    mPropertyID as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! ( mPropertyID
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) .
                    mShorthandPropertyID as * const _ as usize } , 12usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! (
                    mShorthandPropertyID ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) .
                    mTokenStream as * const _ as usize } , 16usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! (
                    mTokenStream ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) . mBaseURI
                    as * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! ( mBaseURI )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) . mSheetURI
                    as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! ( mSheetURI )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) .
                    mSheetPrincipal as * const _ as usize } , 48usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! (
                    mSheetPrincipal ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) .
                    mLineNumber as * const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! ( mLineNumber
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) .
                    mLineOffset as * const _ as usize } , 60usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! ( mLineOffset
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTokenStream ) ) . mLevel as
                    * const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTokenStream ) , "::" , stringify ! ( mLevel )
                    ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSRect {
        pub mTop: root::nsCSSValue,
        pub mRight: root::nsCSSValue,
        pub mBottom: root::nsCSSValue,
        pub mLeft: root::nsCSSValue,
    }
    pub type nsCSSRect_side_type = *mut root::nsCSSValue;
    extern "C" {
        #[link_name = "_ZN9nsCSSRect5sidesE"]
        pub static mut nsCSSRect_sides: [root::nsCSSRect_side_type; 4usize];
    }
    #[test]
    fn bindgen_test_layout_nsCSSRect() {
        assert_eq!(::std::mem::size_of::<nsCSSRect>() , 64usize , concat ! (
                   "Size of: " , stringify ! ( nsCSSRect ) ));
        assert_eq! (::std::mem::align_of::<nsCSSRect>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsCSSRect ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSRect ) ) . mTop as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSRect ) , "::"
                    , stringify ! ( mTop ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSRect ) ) . mRight as * const _
                    as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSRect ) , "::"
                    , stringify ! ( mRight ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSRect ) ) . mBottom as * const _
                    as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSRect ) , "::"
                    , stringify ! ( mBottom ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSRect ) ) . mLeft as * const _ as
                    usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSRect ) , "::"
                    , stringify ! ( mLeft ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSRect_heap {
        pub _base: root::nsCSSRect,
        pub mRefCnt: root::nsAutoRefCnt,
    }
    pub type nsCSSRect_heap_HasThreadSafeRefCnt = root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSRect_heap() {
        assert_eq!(::std::mem::size_of::<nsCSSRect_heap>() , 72usize , concat
                   ! ( "Size of: " , stringify ! ( nsCSSRect_heap ) ));
        assert_eq! (::std::mem::align_of::<nsCSSRect_heap>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsCSSRect_heap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSRect_heap ) ) . mRefCnt as *
                    const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSRect_heap ) ,
                    "::" , stringify ! ( mRefCnt ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueList {
        pub mValue: root::nsCSSValue,
        pub mNext: *mut root::nsCSSValueList,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValueList() {
        assert_eq!(::std::mem::size_of::<nsCSSValueList>() , 24usize , concat
                   ! ( "Size of: " , stringify ! ( nsCSSValueList ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValueList>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsCSSValueList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueList ) ) . mValue as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueList ) ,
                    "::" , stringify ! ( mValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueList ) ) . mNext as * const
                    _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueList ) ,
                    "::" , stringify ! ( mNext ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueList_heap {
        pub _base: root::nsCSSValueList,
        pub mRefCnt: root::nsAutoRefCnt,
    }
    pub type nsCSSValueList_heap_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValueList_heap() {
        assert_eq!(::std::mem::size_of::<nsCSSValueList_heap>() , 32usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSValueList_heap ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValueList_heap>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueList_heap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueList_heap ) ) . mRefCnt as
                    * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueList_heap
                    ) , "::" , stringify ! ( mRefCnt ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueSharedList {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mHead: *mut root::nsCSSValueList,
    }
    pub type nsCSSValueSharedList_HasThreadSafeRefCnt =
        root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsCSSValueSharedList() {
        assert_eq!(::std::mem::size_of::<nsCSSValueSharedList>() , 16usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSValueSharedList ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValueSharedList>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueSharedList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueSharedList ) ) . mRefCnt as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueSharedList ) , "::" , stringify ! ( mRefCnt )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueSharedList ) ) . mHead as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueSharedList ) , "::" , stringify ! ( mHead ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValuePairList {
        pub mXValue: root::nsCSSValue,
        pub mYValue: root::nsCSSValue,
        pub mNext: *mut root::nsCSSValuePairList,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValuePairList() {
        assert_eq!(::std::mem::size_of::<nsCSSValuePairList>() , 40usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCSSValuePairList )
                   ));
        assert_eq! (::std::mem::align_of::<nsCSSValuePairList>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValuePairList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePairList ) ) . mXValue as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValuePairList
                    ) , "::" , stringify ! ( mXValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePairList ) ) . mYValue as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValuePairList
                    ) , "::" , stringify ! ( mYValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePairList ) ) . mNext as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValuePairList
                    ) , "::" , stringify ! ( mNext ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValuePairList_heap {
        pub _base: root::nsCSSValuePairList,
        pub mRefCnt: root::nsAutoRefCnt,
    }
    pub type nsCSSValuePairList_heap_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValuePairList_heap() {
        assert_eq!(::std::mem::size_of::<nsCSSValuePairList_heap>() , 48usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsCSSValuePairList_heap ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValuePairList_heap>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsCSSValuePairList_heap )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValuePairList_heap ) ) . mRefCnt
                    as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValuePairList_heap ) , "::" , stringify ! ( mRefCnt )
                    ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueTriplet {
        pub mXValue: root::nsCSSValue,
        pub mYValue: root::nsCSSValue,
        pub mZValue: root::nsCSSValue,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValueTriplet() {
        assert_eq!(::std::mem::size_of::<nsCSSValueTriplet>() , 48usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCSSValueTriplet )
                   ));
        assert_eq! (::std::mem::align_of::<nsCSSValueTriplet>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueTriplet ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTriplet ) ) . mXValue as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueTriplet )
                    , "::" , stringify ! ( mXValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTriplet ) ) . mYValue as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueTriplet )
                    , "::" , stringify ! ( mYValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTriplet ) ) . mZValue as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValueTriplet )
                    , "::" , stringify ! ( mZValue ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueTriplet_heap {
        pub _base: root::nsCSSValueTriplet,
        pub mRefCnt: root::nsAutoRefCnt,
    }
    pub type nsCSSValueTriplet_heap_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValueTriplet_heap() {
        assert_eq!(::std::mem::size_of::<nsCSSValueTriplet_heap>() , 56usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSValueTriplet_heap ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValueTriplet_heap>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueTriplet_heap )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueTriplet_heap ) ) . mRefCnt
                    as * const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueTriplet_heap ) , "::" , stringify ! ( mRefCnt )
                    ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueFloatColor {
        pub mRefCnt: root::nsAutoRefCnt,
        pub mComponent1: f32,
        pub mComponent2: f32,
        pub mComponent3: f32,
        pub mAlpha: f32,
    }
    pub type nsCSSValueFloatColor_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValueFloatColor() {
        assert_eq!(::std::mem::size_of::<nsCSSValueFloatColor>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSValueFloatColor ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValueFloatColor>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueFloatColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueFloatColor ) ) . mRefCnt as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueFloatColor ) , "::" , stringify ! ( mRefCnt )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueFloatColor ) ) .
                    mComponent1 as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueFloatColor ) , "::" , stringify ! ( mComponent1
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueFloatColor ) ) .
                    mComponent2 as * const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueFloatColor ) , "::" , stringify ! ( mComponent2
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueFloatColor ) ) .
                    mComponent3 as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueFloatColor ) , "::" , stringify ! ( mComponent3
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueFloatColor ) ) . mAlpha as
                    * const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueFloatColor ) , "::" , stringify ! ( mAlpha ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValue {
        pub mUnit: root::nsCSSUnit,
        pub mValue: root::nsCSSValue__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValue_Array {
        pub mRefCnt: usize,
        pub mCount: usize,
        pub mArray: [root::nsCSSValue; 1usize],
    }
    #[test]
    fn bindgen_test_layout_nsCSSValue_Array() {
        assert_eq!(::std::mem::size_of::<nsCSSValue_Array>() , 32usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCSSValue_Array )
                   ));
        assert_eq! (::std::mem::align_of::<nsCSSValue_Array>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSValue_Array ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue_Array ) ) . mRefCnt as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValue_Array )
                    , "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue_Array ) ) . mCount as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValue_Array )
                    , "::" , stringify ! ( mCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue_Array ) ) . mArray as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValue_Array )
                    , "::" , stringify ! ( mArray ) ));
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSValue_Serialization {
        eNormalized = 0,
        eAuthorSpecified = 1,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCSSValue__bindgen_ty_1 {
        pub mInt: root::__BindgenUnionField<i32>,
        pub mFloat: root::__BindgenUnionField<f32>,
        pub mString: root::__BindgenUnionField<*mut root::nsStringBuffer>,
        pub mColor: root::__BindgenUnionField<root::nscolor>,
        pub mArray: root::__BindgenUnionField<*mut root::nsCSSValue_Array>,
        pub mURL: root::__BindgenUnionField<*mut root::mozilla::css::URLValue>,
        pub mImage: root::__BindgenUnionField<*mut root::mozilla::css::ImageValue>,
        pub mGridTemplateAreas: root::__BindgenUnionField<*mut root::mozilla::css::GridTemplateAreasValue>,
        pub mGradient: root::__BindgenUnionField<*mut root::nsCSSValueGradient>,
        pub mTokenStream: root::__BindgenUnionField<*mut root::nsCSSValueTokenStream>,
        pub mPair: root::__BindgenUnionField<*mut root::nsCSSValuePair_heap>,
        pub mRect: root::__BindgenUnionField<*mut root::nsCSSRect_heap>,
        pub mTriplet: root::__BindgenUnionField<*mut root::nsCSSValueTriplet_heap>,
        pub mList: root::__BindgenUnionField<*mut root::nsCSSValueList_heap>,
        pub mListDependent: root::__BindgenUnionField<*mut root::nsCSSValueList>,
        pub mSharedList: root::__BindgenUnionField<*mut root::nsCSSValueSharedList>,
        pub mPairList: root::__BindgenUnionField<*mut root::nsCSSValuePairList_heap>,
        pub mPairListDependent: root::__BindgenUnionField<*mut root::nsCSSValuePairList>,
        pub mFloatColor: root::__BindgenUnionField<*mut root::nsCSSValueFloatColor>,
        pub mFontFamilyList: root::__BindgenUnionField<*mut root::mozilla::css::FontFamilyListRefCnt>,
        pub mComplexColor: root::__BindgenUnionField<*mut root::mozilla::css::ComplexColorValue>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValue__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsCSSValue__bindgen_ty_1>() , 8usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsCSSValue__bindgen_ty_1 ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValue__bindgen_ty_1>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsCSSValue__bindgen_ty_1 )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mInt
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mInt )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mFloat
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mFloat )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mString as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mString
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mColor
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mColor )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mArray
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mArray )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mURL
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mURL )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mImage
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mImage )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mGridTemplateAreas as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mGridTemplateAreas ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mGradient as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mGradient ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mTokenStream as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mTokenStream ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mPair
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mPair )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mRect
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mRect )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mTriplet as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mTriplet
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) . mList
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! ( mList )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mListDependent as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mListDependent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mSharedList as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mSharedList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mPairList as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mPairList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mPairListDependent as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mPairListDependent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mFloatColor as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mFloatColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mFontFamilyList as * const _ as usize } , 0usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mFontFamilyList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue__bindgen_ty_1 ) ) .
                    mComplexColor as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsCSSValue__bindgen_ty_1 ) , "::" , stringify ! (
                    mComplexColor ) ));
    }
    impl Clone for nsCSSValue__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsCSSValue() {
        assert_eq!(::std::mem::size_of::<nsCSSValue>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsCSSValue ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValue>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsCSSValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue ) ) . mUnit as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValue ) , "::"
                    , stringify ! ( mUnit ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValue ) ) . mValue as * const _
                    as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSValue ) , "::"
                    , stringify ! ( mValue ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueGradientStop {
        pub mLocation: root::nsCSSValue,
        pub mColor: root::nsCSSValue,
        pub mIsInterpolationHint: bool,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValueGradientStop() {
        assert_eq!(::std::mem::size_of::<nsCSSValueGradientStop>() , 40usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsCSSValueGradientStop ) ));
        assert_eq! (::std::mem::align_of::<nsCSSValueGradientStop>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsCSSValueGradientStop )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradientStop ) ) .
                    mLocation as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueGradientStop ) , "::" , stringify ! ( mLocation
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradientStop ) ) . mColor
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueGradientStop ) , "::" , stringify ! ( mColor )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSValueGradientStop ) ) .
                    mIsInterpolationHint as * const _ as usize } , 32usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsCSSValueGradientStop ) , "::" , stringify ! (
                    mIsInterpolationHint ) ));
    }
    #[repr(C)]
    pub struct nsQueryFrame__bindgen_vtable {
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsQueryFrame {
        pub vtable_: *const nsQueryFrame__bindgen_vtable,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsQueryFrame_FrameIID {
        BRFrame_id = 0,
        DetailsFrame_id = 1,
        nsAutoRepeatBoxFrame_id = 2,
        nsBCTableCellFrame_id = 3,
        nsBackdropFrame_id = 4,
        nsBlockFrame_id = 5,
        nsBox_id = 6,
        nsBoxFrame_id = 7,
        nsBulletFrame_id = 8,
        nsButtonBoxFrame_id = 9,
        nsCanvasFrame_id = 10,
        nsColorControlFrame_id = 11,
        nsColumnSetFrame_id = 12,
        nsComboboxControlFrame_id = 13,
        nsComboboxDisplayFrame_id = 14,
        nsContainerFrame_id = 15,
        nsContinuingTextFrame_id = 16,
        nsDateTimeControlFrame_id = 17,
        nsDeckFrame_id = 18,
        nsDocElementBoxFrame_id = 19,
        nsFieldSetFrame_id = 20,
        nsFileControlFrame_id = 21,
        nsFirstLetterFrame_id = 22,
        nsFirstLineFrame_id = 23,
        nsFlexContainerFrame_id = 24,
        nsFormControlFrame_id = 25,
        nsFrame_id = 26,
        nsGfxButtonControlFrame_id = 27,
        nsGfxCheckboxControlFrame_id = 28,
        nsGfxRadioControlFrame_id = 29,
        nsGridContainerFrame_id = 30,
        nsGridRowGroupFrame_id = 31,
        nsGridRowLeafFrame_id = 32,
        nsGroupBoxFrame_id = 33,
        nsHTMLButtonControlFrame_id = 34,
        nsHTMLCanvasFrame_id = 35,
        nsHTMLFramesetBlankFrame_id = 36,
        nsHTMLFramesetBorderFrame_id = 37,
        nsHTMLFramesetFrame_id = 38,
        nsHTMLScrollFrame_id = 39,
        nsIAnonymousContentCreator_id = 40,
        nsIComboboxControlFrame_id = 41,
        nsIFormControlFrame_id = 42,
        nsIFrame_id = 43,
        nsIFrameFrame_id = 44,
        nsIListControlFrame_id = 45,
        nsIMathMLFrame_id = 46,
        nsIMenuFrame_id = 47,
        nsIObjectFrame_id = 48,
        nsIPageSequenceFrame_id = 49,
        nsIPercentBSizeObserver_id = 50,
        nsIRootBox_id = 51,
        nsISVGChildFrame_id = 52,
        nsISVGSVGFrame_id = 53,
        nsIScrollableFrame_id = 54,
        nsIScrollbarMediator_id = 55,
        nsISelectControlFrame_id = 56,
        nsIStatefulFrame_id = 57,
        nsITableCellLayout_id = 58,
        nsITableLayout_id = 59,
        nsITextControlFrame_id = 60,
        nsITreeBoxObject_id = 61,
        nsImageBoxFrame_id = 62,
        nsImageControlFrame_id = 63,
        nsImageFrame_id = 64,
        nsInlineFrame_id = 65,
        nsLeafBoxFrame_id = 66,
        nsLeafFrame_id = 67,
        nsLegendFrame_id = 68,
        nsListBoxBodyFrame_id = 69,
        nsListControlFrame_id = 70,
        nsListItemFrame_id = 71,
        nsMathMLContainerFrame_id = 72,
        nsMathMLFrame_id = 73,
        nsMathMLmactionFrame_id = 74,
        nsMathMLmathBlockFrame_id = 75,
        nsMathMLmathInlineFrame_id = 76,
        nsMathMLmencloseFrame_id = 77,
        nsMathMLmfencedFrame_id = 78,
        nsMathMLmfracFrame_id = 79,
        nsMathMLmmultiscriptsFrame_id = 80,
        nsMathMLmoFrame_id = 81,
        nsMathMLmoverFrame_id = 82,
        nsMathMLmpaddedFrame_id = 83,
        nsMathMLmrootFrame_id = 84,
        nsMathMLmrowFrame_id = 85,
        nsMathMLmspaceFrame_id = 86,
        nsMathMLmsqrtFrame_id = 87,
        nsMathMLmstyleFrame_id = 88,
        nsMathMLmtableFrame_id = 89,
        nsMathMLmtableWrapperFrame_id = 90,
        nsMathMLmtdFrame_id = 91,
        nsMathMLmtdInnerFrame_id = 92,
        nsMathMLmtrFrame_id = 93,
        nsMathMLmunderFrame_id = 94,
        nsMathMLmunderoverFrame_id = 95,
        nsMathMLsemanticsFrame_id = 96,
        nsMathMLTokenFrame_id = 97,
        nsMenuBarFrame_id = 98,
        nsMenuFrame_id = 99,
        nsMenuPopupFrame_id = 100,
        nsMeterFrame_id = 101,
        nsNumberControlFrame_id = 102,
        nsPluginFrame_id = 103,
        nsPageBreakFrame_id = 104,
        nsPageContentFrame_id = 105,
        nsPageFrame_id = 106,
        nsPlaceholderFrame_id = 107,
        nsPopupSetFrame_id = 108,
        nsProgressFrame_id = 109,
        nsProgressMeterFrame_id = 110,
        nsRangeFrame_id = 111,
        nsResizerFrame_id = 112,
        nsRootBoxFrame_id = 113,
        nsRubyBaseContainerFrame_id = 114,
        nsRubyBaseFrame_id = 115,
        nsRubyContentFrame_id = 116,
        nsRubyFrame_id = 117,
        nsRubyTextContainerFrame_id = 118,
        nsRubyTextFrame_id = 119,
        nsScrollbarButtonFrame_id = 120,
        nsScrollbarFrame_id = 121,
        nsSelectsAreaFrame_id = 122,
        nsSimplePageSequenceFrame_id = 123,
        nsSliderFrame_id = 124,
        nsSplittableFrame_id = 125,
        nsSplitterFrame_id = 126,
        nsStackFrame_id = 127,
        nsSubDocumentFrame_id = 128,
        nsSVGAFrame_id = 129,
        nsSVGClipPathFrame_id = 130,
        nsSVGContainerFrame_id = 131,
        nsSVGDisplayContainerFrame_id = 132,
        SVGFEContainerFrame_id = 133,
        SVGFEImageFrame_id = 134,
        SVGFELeafFrame_id = 135,
        SVGFEUnstyledLeafFrame_id = 136,
        nsSVGFilterFrame_id = 137,
        nsSVGForeignObjectFrame_id = 138,
        nsSVGGenericContainerFrame_id = 139,
        nsSVGGFrame_id = 140,
        nsSVGGradientFrame_id = 141,
        nsSVGImageFrame_id = 142,
        nsSVGInnerSVGFrame_id = 143,
        nsSVGLinearGradientFrame_id = 144,
        nsSVGMarkerFrame_id = 145,
        nsSVGMarkerAnonChildFrame_id = 146,
        nsSVGMaskFrame_id = 147,
        nsSVGOuterSVGFrame_id = 148,
        nsSVGOuterSVGAnonChildFrame_id = 149,
        nsSVGPaintServerFrame_id = 150,
        SVGGeometryFrame_id = 151,
        nsSVGPatternFrame_id = 152,
        nsSVGRadialGradientFrame_id = 153,
        nsSVGStopFrame_id = 154,
        nsSVGSwitchFrame_id = 155,
        SVGTextFrame_id = 156,
        nsSVGUseFrame_id = 157,
        SVGViewFrame_id = 158,
        nsTableCellFrame_id = 159,
        nsTableColFrame_id = 160,
        nsTableColGroupFrame_id = 161,
        nsTableFrame_id = 162,
        nsTableWrapperFrame_id = 163,
        nsTableRowFrame_id = 164,
        nsTableRowGroupFrame_id = 165,
        nsTextBoxFrame_id = 166,
        nsTextControlFrame_id = 167,
        nsTextFrame_id = 168,
        nsTitleBarFrame_id = 169,
        nsTreeBodyFrame_id = 170,
        nsTreeColFrame_id = 171,
        nsVideoFrame_id = 172,
        nsXULLabelFrame_id = 173,
        nsXULScrollFrame_id = 174,
        ViewportFrame_id = 175,
        NON_FRAME_MARKER = 536870912,
    }
    #[test]
    fn bindgen_test_layout_nsQueryFrame() {
        assert_eq!(::std::mem::size_of::<nsQueryFrame>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsQueryFrame ) ));
        assert_eq! (::std::mem::align_of::<nsQueryFrame>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsQueryFrame ) ));
    }
    impl Clone for nsQueryFrame {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSTokenSerializationType {
        eCSSTokenSerialization_Nothing = 0,
        eCSSTokenSerialization_Whitespace = 1,
        eCSSTokenSerialization_AtKeyword_or_Hash = 2,
        eCSSTokenSerialization_Number = 3,
        eCSSTokenSerialization_Dimension = 4,
        eCSSTokenSerialization_Percentage = 5,
        eCSSTokenSerialization_URange = 6,
        eCSSTokenSerialization_URL_or_BadURL = 7,
        eCSSTokenSerialization_Function = 8,
        eCSSTokenSerialization_Ident = 9,
        eCSSTokenSerialization_CDC = 10,
        eCSSTokenSerialization_DashMatch = 11,
        eCSSTokenSerialization_ContainsMatch = 12,
        eCSSTokenSerialization_Symbol_Hash = 13,
        eCSSTokenSerialization_Symbol_At = 14,
        eCSSTokenSerialization_Symbol_Dot_or_Plus = 15,
        eCSSTokenSerialization_Symbol_Minus = 16,
        eCSSTokenSerialization_Symbol_OpenParen = 17,
        eCSSTokenSerialization_Symbol_Question = 18,
        eCSSTokenSerialization_Symbol_Assorted = 19,
        eCSSTokenSerialization_Symbol_Equals = 20,
        eCSSTokenSerialization_Symbol_Bar = 21,
        eCSSTokenSerialization_Symbol_Slash = 22,
        eCSSTokenSerialization_Symbol_Asterisk = 23,
        eCSSTokenSerialization_Other = 24,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsCSSSelector([u8; 0]);
    pub const nsChangeHint_nsChangeHint_Empty: root::nsChangeHint =
        nsChangeHint(0);
    pub const nsChangeHint_nsChangeHint_RepaintFrame: root::nsChangeHint =
        nsChangeHint(1);
    pub const nsChangeHint_nsChangeHint_NeedReflow: root::nsChangeHint =
        nsChangeHint(2);
    pub const nsChangeHint_nsChangeHint_ClearAncestorIntrinsics:
              root::nsChangeHint =
        nsChangeHint(4);
    pub const nsChangeHint_nsChangeHint_ClearDescendantIntrinsics:
              root::nsChangeHint =
        nsChangeHint(8);
    pub const nsChangeHint_nsChangeHint_NeedDirtyReflow: root::nsChangeHint =
        nsChangeHint(16);
    pub const nsChangeHint_nsChangeHint_SyncFrameView: root::nsChangeHint =
        nsChangeHint(32);
    pub const nsChangeHint_nsChangeHint_UpdateCursor: root::nsChangeHint =
        nsChangeHint(64);
    pub const nsChangeHint_nsChangeHint_UpdateEffects: root::nsChangeHint =
        nsChangeHint(128);
    pub const nsChangeHint_nsChangeHint_UpdateOpacityLayer: root::nsChangeHint
              =
        nsChangeHint(256);
    pub const nsChangeHint_nsChangeHint_UpdateTransformLayer:
              root::nsChangeHint =
        nsChangeHint(512);
    pub const nsChangeHint_nsChangeHint_ReconstructFrame: root::nsChangeHint =
        nsChangeHint(1024);
    pub const nsChangeHint_nsChangeHint_UpdateOverflow: root::nsChangeHint =
        nsChangeHint(2048);
    pub const nsChangeHint_nsChangeHint_UpdateSubtreeOverflow:
              root::nsChangeHint =
        nsChangeHint(4096);
    pub const nsChangeHint_nsChangeHint_UpdatePostTransformOverflow:
              root::nsChangeHint =
        nsChangeHint(8192);
    pub const nsChangeHint_nsChangeHint_UpdateParentOverflow:
              root::nsChangeHint =
        nsChangeHint(16384);
    pub const nsChangeHint_nsChangeHint_ChildrenOnlyTransform:
              root::nsChangeHint =
        nsChangeHint(32768);
    pub const nsChangeHint_nsChangeHint_RecomputePosition: root::nsChangeHint
              =
        nsChangeHint(65536);
    pub const nsChangeHint_nsChangeHint_UpdateContainingBlock:
              root::nsChangeHint =
        nsChangeHint(131072);
    pub const nsChangeHint_nsChangeHint_BorderStyleNoneChange:
              root::nsChangeHint =
        nsChangeHint(262144);
    pub const nsChangeHint_nsChangeHint_UpdateTextPath: root::nsChangeHint =
        nsChangeHint(524288);
    pub const nsChangeHint_nsChangeHint_SchedulePaint: root::nsChangeHint =
        nsChangeHint(1048576);
    pub const nsChangeHint_nsChangeHint_NeutralChange: root::nsChangeHint =
        nsChangeHint(2097152);
    pub const nsChangeHint_nsChangeHint_InvalidateRenderingObservers:
              root::nsChangeHint =
        nsChangeHint(4194304);
    pub const nsChangeHint_nsChangeHint_ReflowChangesSizeOrPosition:
              root::nsChangeHint =
        nsChangeHint(8388608);
    pub const nsChangeHint_nsChangeHint_UpdateComputedBSize:
              root::nsChangeHint =
        nsChangeHint(16777216);
    pub const nsChangeHint_nsChangeHint_UpdateUsesOpacity: root::nsChangeHint
              =
        nsChangeHint(33554432);
    pub const nsChangeHint_nsChangeHint_UpdateBackgroundPosition:
              root::nsChangeHint =
        nsChangeHint(67108864);
    pub const nsChangeHint_nsChangeHint_AddOrRemoveTransform:
              root::nsChangeHint =
        nsChangeHint(134217728);
    pub const nsChangeHint_nsChangeHint_AllHints: root::nsChangeHint =
        nsChangeHint(268435455);
    impl ::std::ops::BitOr<root::nsChangeHint> for root::nsChangeHint {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self { nsChangeHint(self.0 | other.0) }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct nsChangeHint(pub ::std::os::raw::c_uint);
    pub const nsRestyleHint_eRestyle_Self: root::nsRestyleHint =
        nsRestyleHint(1);
    pub const nsRestyleHint_eRestyle_SomeDescendants: root::nsRestyleHint =
        nsRestyleHint(2);
    pub const nsRestyleHint_eRestyle_Subtree: root::nsRestyleHint =
        nsRestyleHint(4);
    pub const nsRestyleHint_eRestyle_LaterSiblings: root::nsRestyleHint =
        nsRestyleHint(8);
    pub const nsRestyleHint_eRestyle_CSSTransitions: root::nsRestyleHint =
        nsRestyleHint(16);
    pub const nsRestyleHint_eRestyle_CSSAnimations: root::nsRestyleHint =
        nsRestyleHint(32);
    pub const nsRestyleHint_eRestyle_SVGAttrAnimations: root::nsRestyleHint =
        nsRestyleHint(64);
    pub const nsRestyleHint_eRestyle_StyleAttribute: root::nsRestyleHint =
        nsRestyleHint(128);
    pub const nsRestyleHint_eRestyle_StyleAttribute_Animations:
              root::nsRestyleHint =
        nsRestyleHint(256);
    pub const nsRestyleHint_eRestyle_Force: root::nsRestyleHint =
        nsRestyleHint(512);
    pub const nsRestyleHint_eRestyle_ForceDescendants: root::nsRestyleHint =
        nsRestyleHint(1024);
    pub const nsRestyleHint_eRestyle_AllHintsWithAnimations:
              root::nsRestyleHint =
        nsRestyleHint(368);
    impl ::std::ops::BitOr<root::nsRestyleHint> for root::nsRestyleHint {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            nsRestyleHint(self.0 | other.0)
        }
    }
    #[repr(C)]
    /**
 * |nsRestyleHint| is a bitfield for the result of
 * |HasStateDependentStyle| and |HasAttributeDependentStyle|.  When no
 * restyling is necessary, use |nsRestyleHint(0)|.
 *
 * Without eRestyle_Force or eRestyle_ForceDescendants, the restyling process
 * can stop processing at a frame when it detects no style changes and it is
 * known that the styles of the subtree beneath it will not change, leaving
 * the old style context on the frame.  eRestyle_Force can be used to skip this
 * optimization on a frame, and to force its new style context to be used.
 *
 * Similarly, eRestyle_ForceDescendants will cause the frame and all of its
 * descendants to be traversed and for the new style contexts that are created
 * to be set on the frames.
 *
 * NOTE: When adding new restyle hints, please also add them to
 * RestyleManager::RestyleHintToString.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct nsRestyleHint(pub ::std::os::raw::c_uint);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsStyleContext([u8; 0]);
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAttrName {
        pub mBits: usize,
    }
    #[test]
    fn bindgen_test_layout_nsAttrName() {
        assert_eq!(::std::mem::size_of::<nsAttrName>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsAttrName ) ));
        assert_eq! (::std::mem::align_of::<nsAttrName>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsAttrName ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsAttrName ) ) . mBits as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsAttrName ) , "::"
                    , stringify ! ( mBits ) ));
    }
    #[repr(u32)]
    /**
 * This is the enum used by functions that need to be told whether to
 * do case-sensitive or case-insensitive string comparisons.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCaseTreatment { eCaseMatters = 0, eIgnoreCase = 1, }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsRuleWalker([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsTextFragment([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsXBLBinding([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsISelectionDisplay {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISelectionDisplay_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const nsISelectionDisplay_DISPLAY_TEXT:
              root::nsISelectionDisplay__bindgen_ty_1 =
        nsISelectionDisplay__bindgen_ty_1::DISPLAY_TEXT;
    pub const nsISelectionDisplay_DISPLAY_IMAGES:
              root::nsISelectionDisplay__bindgen_ty_1 =
        nsISelectionDisplay__bindgen_ty_1::DISPLAY_IMAGES;
    pub const nsISelectionDisplay_DISPLAY_FRAMES:
              root::nsISelectionDisplay__bindgen_ty_1 =
        nsISelectionDisplay__bindgen_ty_1::DISPLAY_FRAMES;
    pub const nsISelectionDisplay_DISPLAY_ALL:
              root::nsISelectionDisplay__bindgen_ty_1 =
        nsISelectionDisplay__bindgen_ty_1::DISPLAY_ALL;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsISelectionDisplay__bindgen_ty_1 {
        DISPLAY_TEXT = 1,
        DISPLAY_IMAGES = 2,
        DISPLAY_FRAMES = 4,
        DISPLAY_ALL = 7,
    }
    #[test]
    fn bindgen_test_layout_nsISelectionDisplay() {
        assert_eq!(::std::mem::size_of::<nsISelectionDisplay>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsISelectionDisplay ) ));
        assert_eq! (::std::mem::align_of::<nsISelectionDisplay>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsISelectionDisplay ) ));
    }
    impl Clone for nsISelectionDisplay {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsISelectionController {
        pub _base: root::nsISelectionDisplay,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISelectionController_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const nsISelectionController_SELECTION_NONE:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_NONE;
    pub const nsISelectionController_SELECTION_NORMAL:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_NORMAL;
    pub const nsISelectionController_SELECTION_SPELLCHECK:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_SPELLCHECK;
    pub const nsISelectionController_SELECTION_IME_RAWINPUT:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_IME_RAWINPUT;
    pub const nsISelectionController_SELECTION_IME_SELECTEDRAWTEXT:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_IME_SELECTEDRAWTEXT;
    pub const nsISelectionController_SELECTION_IME_CONVERTEDTEXT:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_IME_CONVERTEDTEXT;
    pub const nsISelectionController_SELECTION_IME_SELECTEDCONVERTEDTEXT:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_IME_SELECTEDCONVERTEDTEXT;
    pub const nsISelectionController_SELECTION_ACCESSIBILITY:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_ACCESSIBILITY;
    pub const nsISelectionController_SELECTION_FIND:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_FIND;
    pub const nsISelectionController_SELECTION_URLSECONDARY:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_URLSECONDARY;
    pub const nsISelectionController_SELECTION_URLSTRIKEOUT:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_URLSTRIKEOUT;
    pub const nsISelectionController_NUM_SELECTIONTYPES:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::NUM_SELECTIONTYPES;
    pub const nsISelectionController_SELECTION_ANCHOR_REGION:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_NONE;
    pub const nsISelectionController_SELECTION_FOCUS_REGION:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_NORMAL;
    pub const nsISelectionController_SELECTION_WHOLE_SELECTION:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_SPELLCHECK;
    pub const nsISelectionController_NUM_SELECTION_REGIONS:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::NUM_SELECTION_REGIONS;
    pub const nsISelectionController_SELECTION_OFF:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_NONE;
    pub const nsISelectionController_SELECTION_HIDDEN:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_NORMAL;
    pub const nsISelectionController_SELECTION_ON:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_SPELLCHECK;
    pub const nsISelectionController_SELECTION_DISABLED:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::NUM_SELECTION_REGIONS;
    pub const nsISelectionController_SELECTION_ATTENTION:
              root::nsISelectionController__bindgen_ty_1 =
        nsISelectionController__bindgen_ty_1::SELECTION_IME_RAWINPUT;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsISelectionController__bindgen_ty_1 {
        SELECTION_NONE = 0,
        SELECTION_NORMAL = 1,
        SELECTION_SPELLCHECK = 2,
        SELECTION_IME_RAWINPUT = 4,
        SELECTION_IME_SELECTEDRAWTEXT = 8,
        SELECTION_IME_CONVERTEDTEXT = 16,
        SELECTION_IME_SELECTEDCONVERTEDTEXT = 32,
        SELECTION_ACCESSIBILITY = 64,
        SELECTION_FIND = 128,
        SELECTION_URLSECONDARY = 256,
        SELECTION_URLSTRIKEOUT = 512,
        NUM_SELECTIONTYPES = 11,
        NUM_SELECTION_REGIONS = 3,
    }
    pub const nsISelectionController_SCROLL_SYNCHRONOUS:
              root::nsISelectionController__bindgen_ty_2 =
        nsISelectionController__bindgen_ty_2::SCROLL_SYNCHRONOUS;
    pub const nsISelectionController_SCROLL_FIRST_ANCESTOR_ONLY:
              root::nsISelectionController__bindgen_ty_2 =
        nsISelectionController__bindgen_ty_2::SCROLL_FIRST_ANCESTOR_ONLY;
    pub const nsISelectionController_SCROLL_CENTER_VERTICALLY:
              root::nsISelectionController__bindgen_ty_2 =
        nsISelectionController__bindgen_ty_2::SCROLL_CENTER_VERTICALLY;
    pub const nsISelectionController_SCROLL_OVERFLOW_HIDDEN:
              root::nsISelectionController__bindgen_ty_2 =
        nsISelectionController__bindgen_ty_2::SCROLL_OVERFLOW_HIDDEN;
    pub const nsISelectionController_SCROLL_FOR_CARET_MOVE:
              root::nsISelectionController__bindgen_ty_2 =
        nsISelectionController__bindgen_ty_2::SCROLL_FOR_CARET_MOVE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsISelectionController__bindgen_ty_2 {
        SCROLL_SYNCHRONOUS = 2,
        SCROLL_FIRST_ANCESTOR_ONLY = 4,
        SCROLL_CENTER_VERTICALLY = 16,
        SCROLL_OVERFLOW_HIDDEN = 32,
        SCROLL_FOR_CARET_MOVE = 64,
    }
    pub const nsISelectionController_MOVE_LEFT:
              root::nsISelectionController__bindgen_ty_3 =
        nsISelectionController__bindgen_ty_3::MOVE_LEFT;
    pub const nsISelectionController_MOVE_RIGHT:
              root::nsISelectionController__bindgen_ty_3 =
        nsISelectionController__bindgen_ty_3::MOVE_RIGHT;
    pub const nsISelectionController_MOVE_UP:
              root::nsISelectionController__bindgen_ty_3 =
        nsISelectionController__bindgen_ty_3::MOVE_UP;
    pub const nsISelectionController_MOVE_DOWN:
              root::nsISelectionController__bindgen_ty_3 =
        nsISelectionController__bindgen_ty_3::MOVE_DOWN;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsISelectionController__bindgen_ty_3 {
        MOVE_LEFT = 0,
        MOVE_RIGHT = 1,
        MOVE_UP = 2,
        MOVE_DOWN = 3,
    }
    #[test]
    fn bindgen_test_layout_nsISelectionController() {
        assert_eq!(::std::mem::size_of::<nsISelectionController>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsISelectionController ) ));
        assert_eq! (::std::mem::align_of::<nsISelectionController>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsISelectionController )
                    ));
    }
    impl Clone for nsISelectionController {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsFrameManagerBase {
        pub mPresShell: *mut root::nsIPresShell,
        pub mRootFrame: *mut root::nsIFrame,
        pub mPlaceholderMap: root::PLDHashTable,
        pub mUndisplayedMap: *mut root::nsFrameManagerBase_UndisplayedMap,
        pub mDisplayContentsMap: *mut root::nsFrameManagerBase_UndisplayedMap,
        pub mIsDestroyingFrames: bool,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsFrameManagerBase_UndisplayedMap([u8; 0]);
    #[test]
    fn bindgen_test_layout_nsFrameManagerBase() {
        assert_eq!(::std::mem::size_of::<nsFrameManagerBase>() , 80usize ,
                   concat ! ( "Size of: " , stringify ! ( nsFrameManagerBase )
                   ));
        assert_eq! (::std::mem::align_of::<nsFrameManagerBase>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsFrameManagerBase ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFrameManagerBase ) ) . mPresShell
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFrameManagerBase
                    ) , "::" , stringify ! ( mPresShell ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFrameManagerBase ) ) . mRootFrame
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsFrameManagerBase
                    ) , "::" , stringify ! ( mRootFrame ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFrameManagerBase ) ) .
                    mPlaceholderMap as * const _ as usize } , 16usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsFrameManagerBase
                    ) , "::" , stringify ! ( mPlaceholderMap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFrameManagerBase ) ) .
                    mUndisplayedMap as * const _ as usize } , 56usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsFrameManagerBase
                    ) , "::" , stringify ! ( mUndisplayedMap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFrameManagerBase ) ) .
                    mDisplayContentsMap as * const _ as usize } , 64usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsFrameManagerBase
                    ) , "::" , stringify ! ( mDisplayContentsMap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsFrameManagerBase ) ) .
                    mIsDestroyingFrames as * const _ as usize } , 72usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsFrameManagerBase
                    ) , "::" , stringify ! ( mIsDestroyingFrames ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPresArena {
        pub mFreeLists: [u64; 5usize],
        pub mPool: root::PLArenaPool,
        pub mArenaRefPtrs: [u64; 5usize],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPresArena_FreeList {
        pub _base: root::PLDHashEntryHdr,
        pub mEntries: root::nsTArray<*mut ::std::os::raw::c_void>,
        pub mEntrySize: usize,
        pub mEntriesEverAllocated: usize,
        pub mKey: root::nsPresArena_FreeList_KeyTypePointer,
    }
    pub type nsPresArena_FreeList_KeyType = u32;
    pub type nsPresArena_FreeList_KeyTypePointer =
        *const ::std::os::raw::c_void;
    pub const nsPresArena_FreeList_ALLOW_MEMMOVE:
              root::nsPresArena_FreeList__bindgen_ty_1 =
        nsPresArena_FreeList__bindgen_ty_1::ALLOW_MEMMOVE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsPresArena_FreeList__bindgen_ty_1 { ALLOW_MEMMOVE = 0, }
    #[test]
    fn bindgen_test_layout_nsPresArena_FreeList() {
        assert_eq!(::std::mem::size_of::<nsPresArena_FreeList>() , 40usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsPresArena_FreeList ) ));
        assert_eq! (::std::mem::align_of::<nsPresArena_FreeList>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsPresArena_FreeList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresArena_FreeList ) ) . mEntries
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresArena_FreeList ) , "::" , stringify ! ( mEntries )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresArena_FreeList ) ) . mEntrySize
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresArena_FreeList ) , "::" , stringify ! ( mEntrySize )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresArena_FreeList ) ) .
                    mEntriesEverAllocated as * const _ as usize } , 24usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresArena_FreeList ) , "::" , stringify ! (
                    mEntriesEverAllocated ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresArena_FreeList ) ) . mKey as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsPresArena_FreeList ) , "::" , stringify ! ( mKey ) ));
    }
    #[test]
    fn bindgen_test_layout_nsPresArena() {
        assert_eq!(::std::mem::size_of::<nsPresArena>() , 136usize , concat !
                   ( "Size of: " , stringify ! ( nsPresArena ) ));
        assert_eq! (::std::mem::align_of::<nsPresArena>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsPresArena ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresArena ) ) . mFreeLists as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresArena ) ,
                    "::" , stringify ! ( mFreeLists ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresArena ) ) . mPool as * const _
                    as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresArena ) ,
                    "::" , stringify ! ( mPool ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPresArena ) ) . mArenaRefPtrs as *
                    const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPresArena ) ,
                    "::" , stringify ! ( mArenaRefPtrs ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLArena {
        pub next: *mut root::PLArena,
        pub base: root::PRUword,
        pub limit: root::PRUword,
        pub avail: root::PRUword,
    }
    #[test]
    fn bindgen_test_layout_PLArena() {
        assert_eq!(::std::mem::size_of::<PLArena>() , 32usize , concat ! (
                   "Size of: " , stringify ! ( PLArena ) ));
        assert_eq! (::std::mem::align_of::<PLArena>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( PLArena ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLArena ) ) . next as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLArena ) , "::" ,
                    stringify ! ( next ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLArena ) ) . base as * const _ as
                    usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLArena ) , "::" ,
                    stringify ! ( base ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLArena ) ) . limit as * const _ as
                    usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLArena ) , "::" ,
                    stringify ! ( limit ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLArena ) ) . avail as * const _ as
                    usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLArena ) , "::" ,
                    stringify ! ( avail ) ));
    }
    impl Clone for PLArena {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLArenaPool {
        pub first: root::PLArena,
        pub current: *mut root::PLArena,
        pub arenasize: root::PRUint32,
        pub mask: root::PRUword,
    }
    #[test]
    fn bindgen_test_layout_PLArenaPool() {
        assert_eq!(::std::mem::size_of::<PLArenaPool>() , 56usize , concat ! (
                   "Size of: " , stringify ! ( PLArenaPool ) ));
        assert_eq! (::std::mem::align_of::<PLArenaPool>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( PLArenaPool ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLArenaPool ) ) . first as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLArenaPool ) ,
                    "::" , stringify ! ( first ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLArenaPool ) ) . current as * const
                    _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLArenaPool ) ,
                    "::" , stringify ! ( current ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLArenaPool ) ) . arenasize as *
                    const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLArenaPool ) ,
                    "::" , stringify ! ( arenasize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const PLArenaPool ) ) . mask as * const _
                    as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( PLArenaPool ) ,
                    "::" , stringify ! ( mask ) ));
    }
    impl Clone for PLArenaPool {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsArenaMemoryStats([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct imgINotificationObserver {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct imgINotificationObserver_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const imgINotificationObserver_SIZE_AVAILABLE:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::SIZE_AVAILABLE;
    pub const imgINotificationObserver_FRAME_UPDATE:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::FRAME_UPDATE;
    pub const imgINotificationObserver_FRAME_COMPLETE:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::FRAME_COMPLETE;
    pub const imgINotificationObserver_LOAD_COMPLETE:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::LOAD_COMPLETE;
    pub const imgINotificationObserver_DECODE_COMPLETE:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::DECODE_COMPLETE;
    pub const imgINotificationObserver_DISCARD:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::DISCARD;
    pub const imgINotificationObserver_UNLOCKED_DRAW:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::UNLOCKED_DRAW;
    pub const imgINotificationObserver_IS_ANIMATED:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::IS_ANIMATED;
    pub const imgINotificationObserver_HAS_TRANSPARENCY:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::HAS_TRANSPARENCY;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum imgINotificationObserver__bindgen_ty_1 {
        SIZE_AVAILABLE = 1,
        FRAME_UPDATE = 2,
        FRAME_COMPLETE = 3,
        LOAD_COMPLETE = 4,
        DECODE_COMPLETE = 5,
        DISCARD = 6,
        UNLOCKED_DRAW = 7,
        IS_ANIMATED = 8,
        HAS_TRANSPARENCY = 9,
    }
    #[test]
    fn bindgen_test_layout_imgINotificationObserver() {
        assert_eq!(::std::mem::size_of::<imgINotificationObserver>() , 8usize
                   , concat ! (
                   "Size of: " , stringify ! ( imgINotificationObserver ) ));
        assert_eq! (::std::mem::align_of::<imgINotificationObserver>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( imgINotificationObserver )
                    ));
    }
    impl Clone for imgINotificationObserver {
        fn clone(&self) -> Self { *self }
    }
    pub type nsFrameState_size_t = u64;
    pub const nsFrameState_NS_STATE_FLEX_CHILDREN_REORDERED:
              root::nsFrameState =
        nsFrameState::NS_STATE_BOX_CHILD_RESERVED;
    pub const nsFrameState_NS_STATE_FLEX_IS_LEGACY_WEBKIT_BOX:
              root::nsFrameState =
        nsFrameState::NS_STATE_STACK_NOT_POSITIONED;
    pub const nsFrameState_NS_STATE_FLEX_SYNTHESIZE_BASELINE:
              root::nsFrameState =
        nsFrameState::NS_STATE_IS_HORIZONTAL;
    pub const nsFrameState_NS_STATE_GRID_NORMAL_FLOW_CHILDREN_IN_CSS_ORDER:
              root::nsFrameState =
        nsFrameState::NS_STATE_BOX_CHILD_RESERVED;
    pub const nsFrameState_NS_STATE_GRID_DID_PUSH_ITEMS: root::nsFrameState =
        nsFrameState::NS_STATE_STACK_NOT_POSITIONED;
    pub const nsFrameState_NS_STATE_GRID_GENERATE_COMPUTED_VALUES:
              root::nsFrameState =
        nsFrameState::NS_STATE_IS_HORIZONTAL;
    pub const nsFrameState_NS_STATE_GRID_SYNTHESIZE_BASELINE:
              root::nsFrameState =
        nsFrameState::NS_STATE_AUTO_STRETCH;
    pub const nsFrameState_NS_STATE_IS_OUTER_SVG: root::nsFrameState =
        nsFrameState::NS_STATE_BOX_CHILD_RESERVED;
    pub const nsFrameState_NS_STATE_SVG_CLIPPATH_CHILD: root::nsFrameState =
        nsFrameState::NS_STATE_STACK_NOT_POSITIONED;
    pub const nsFrameState_NS_STATE_SVG_POSITIONING_DIRTY: root::nsFrameState
              =
        nsFrameState::NS_STATE_IS_HORIZONTAL;
    pub const nsFrameState_NS_STATE_SVG_POSITIONING_MAY_USE_PERCENTAGES:
              root::nsFrameState =
        nsFrameState::NS_STATE_AUTO_STRETCH;
    pub const nsFrameState_NS_STATE_SVG_TEXT_IN_REFLOW: root::nsFrameState =
        nsFrameState::NS_STATE_IS_ROOT;
    pub const nsFrameState_TEXT_FIRST_LETTER: root::nsFrameState =
        nsFrameState::NS_STATE_BOX_CHILD_RESERVED;
    pub const nsFrameState_TEXT_START_OF_LINE: root::nsFrameState =
        nsFrameState::NS_STATE_STACK_NOT_POSITIONED;
    pub const nsFrameState_TEXT_END_OF_LINE: root::nsFrameState =
        nsFrameState::NS_STATE_IS_HORIZONTAL;
    pub const nsFrameState_TEXT_HYPHEN_BREAK: root::nsFrameState =
        nsFrameState::NS_STATE_AUTO_STRETCH;
    pub const nsFrameState_TEXT_TRIMMED_TRAILING_WHITESPACE:
              root::nsFrameState =
        nsFrameState::NS_STATE_IS_ROOT;
    pub const nsFrameState_TEXT_JUSTIFICATION_ENABLED: root::nsFrameState =
        nsFrameState::NS_STATE_CURRENTLY_IN_DEBUG;
    pub const nsFrameState_TEXT_SELECTION_UNDERLINE_OVERFLOWED:
              root::nsFrameState =
        nsFrameState::NS_STATE_SET_TO_DEBUG;
    pub const nsFrameState_TEXT_IS_ONLY_WHITESPACE: root::nsFrameState =
        nsFrameState::NS_STATE_DEBUG_WAS_SET;
    pub const nsFrameState_TEXT_ISNOT_ONLY_WHITESPACE: root::nsFrameState =
        nsFrameState::NS_STATE_MENU_HAS_POPUP_LIST;
    pub const nsFrameState_TEXT_IN_TEXTRUN_USER_DATA: root::nsFrameState =
        nsFrameState::NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK;
    pub const nsFrameState_TEXT_OFFSETS_NEED_FIXING: root::nsFrameState =
        nsFrameState::NS_STATE_EQUAL_SIZE;
    pub const nsFrameState_TEXT_HAS_NONCOLLAPSED_CHARACTERS:
              root::nsFrameState =
        nsFrameState::NS_STATE_IS_DIRECTION_NORMAL;
    pub const nsFrameState_TEXT_IS_IN_TOKEN_MATHML: root::nsFrameState =
        nsFrameState::NS_FRAME_IS_PUSHED_FLOAT;
    pub const nsFrameState_TEXT_IN_UNINFLATED_TEXTRUN_USER_DATA:
              root::nsFrameState =
        nsFrameState::NS_FRAME_MOUSE_THROUGH_ALWAYS;
    pub const nsFrameState_TEXT_HAS_FONT_INFLATION: root::nsFrameState =
        nsFrameState::NS_FRAME_MOUSE_THROUGH_NEVER;
    pub const nsFrameState_NS_BLOCK_NEEDS_BIDI_RESOLUTION: root::nsFrameState
              =
        nsFrameState::NS_STATE_BOX_CHILD_RESERVED;
    pub const nsFrameState_NS_BLOCK_HAS_PUSHED_FLOATS: root::nsFrameState =
        nsFrameState::NS_STATE_STACK_NOT_POSITIONED;
    pub const nsFrameState_NS_BLOCK_MARGIN_ROOT: root::nsFrameState =
        nsFrameState::NS_STATE_IS_HORIZONTAL;
    pub const nsFrameState_NS_BLOCK_FLOAT_MGR: root::nsFrameState =
        nsFrameState::NS_STATE_AUTO_STRETCH;
    pub const nsFrameState_NS_BLOCK_HAS_LINE_CURSOR: root::nsFrameState =
        nsFrameState::NS_STATE_IS_ROOT;
    pub const nsFrameState_NS_BLOCK_HAS_OVERFLOW_LINES: root::nsFrameState =
        nsFrameState::NS_STATE_CURRENTLY_IN_DEBUG;
    pub const nsFrameState_NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS:
              root::nsFrameState =
        nsFrameState::NS_STATE_SET_TO_DEBUG;
    pub const nsFrameState_NS_BLOCK_HAS_CLEAR_CHILDREN: root::nsFrameState =
        nsFrameState::NS_STATE_DEBUG_WAS_SET;
    pub const nsFrameState_NS_BLOCK_CLIP_PAGINATED_OVERFLOW:
              root::nsFrameState =
        nsFrameState::NS_STATE_MENU_HAS_POPUP_LIST;
    pub const nsFrameState_NS_BLOCK_HAS_FIRST_LETTER_STYLE: root::nsFrameState
              =
        nsFrameState::NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK;
    pub const nsFrameState_NS_BLOCK_FRAME_HAS_OUTSIDE_BULLET:
              root::nsFrameState =
        nsFrameState::NS_STATE_EQUAL_SIZE;
    pub const nsFrameState_NS_BLOCK_FRAME_HAS_INSIDE_BULLET:
              root::nsFrameState =
        nsFrameState::NS_STATE_IS_DIRECTION_NORMAL;
    pub const nsFrameState_NS_BLOCK_LOOK_FOR_DIRTY_FRAMES: root::nsFrameState
              =
        nsFrameState::NS_FRAME_MOUSE_THROUGH_NEVER;
    pub const nsFrameState_NS_BLOCK_FRAME_INTRINSICS_INFLATED:
              root::nsFrameState =
        nsFrameState::TEXT_NO_RENDERED_GLYPHS;
    pub const nsFrameState_NS_BLOCK_HAS_FIRST_LETTER_CHILD: root::nsFrameState
              =
        nsFrameState::TEXT_IN_OFFSET_CACHE;
    pub const nsFrameState_BULLET_FRAME_HAS_FONT_INFLATION: root::nsFrameState
              =
        nsFrameState::TEXT_NO_RENDERED_GLYPHS;
    pub const nsFrameState_BULLET_FRAME_IMAGE_LOADING: root::nsFrameState =
        nsFrameState::TEXT_IN_OFFSET_CACHE;
    pub const nsFrameState_NS_SCROLLFRAME_INVALIDATE_CONTENTS_ON_SCROLL:
              root::nsFrameState =
        nsFrameState::NS_STATE_BOX_CHILD_RESERVED;
    pub const nsFrameState_IMAGE_SIZECONSTRAINED: root::nsFrameState =
        nsFrameState::NS_STATE_BOX_CHILD_RESERVED;
    pub const nsFrameState_IMAGE_GOTINITIALREFLOW: root::nsFrameState =
        nsFrameState::NS_STATE_STACK_NOT_POSITIONED;
    pub const nsFrameState_NS_INLINE_FRAME_BIDI_VISUAL_STATE_IS_SET:
              root::nsFrameState =
        nsFrameState::NS_STATE_STACK_NOT_POSITIONED;
    pub const nsFrameState_NS_INLINE_FRAME_BIDI_VISUAL_IS_FIRST:
              root::nsFrameState =
        nsFrameState::NS_STATE_IS_HORIZONTAL;
    pub const nsFrameState_NS_INLINE_FRAME_BIDI_VISUAL_IS_LAST:
              root::nsFrameState =
        nsFrameState::NS_STATE_AUTO_STRETCH;
    pub const nsFrameState_NS_RUBY_TEXT_FRAME_AUTOHIDE: root::nsFrameState =
        nsFrameState::NS_STATE_IS_ROOT;
    pub const nsFrameState_NS_RUBY_TEXT_CONTAINER_IS_SPAN: root::nsFrameState
              =
        nsFrameState::NS_STATE_BOX_CHILD_RESERVED;
    pub const nsFrameState_PLACEHOLDER_FOR_FLOAT: root::nsFrameState =
        nsFrameState::NS_STATE_BOX_CHILD_RESERVED;
    pub const nsFrameState_PLACEHOLDER_FOR_ABSPOS: root::nsFrameState =
        nsFrameState::NS_STATE_STACK_NOT_POSITIONED;
    pub const nsFrameState_PLACEHOLDER_FOR_FIXEDPOS: root::nsFrameState =
        nsFrameState::NS_STATE_IS_HORIZONTAL;
    pub const nsFrameState_PLACEHOLDER_FOR_POPUP: root::nsFrameState =
        nsFrameState::NS_STATE_AUTO_STRETCH;
    pub const nsFrameState_PLACEHOLDER_FOR_TOPLAYER: root::nsFrameState =
        nsFrameState::NS_STATE_IS_ROOT;
    pub const nsFrameState_PLACEHOLDER_STATICPOS_NEEDS_CSSALIGN:
              root::nsFrameState =
        nsFrameState::NS_STATE_CURRENTLY_IN_DEBUG;
    pub const nsFrameState_NS_TABLE_CELL_HAS_PCT_OVER_BSIZE:
              root::nsFrameState =
        nsFrameState::NS_STATE_MENU_HAS_POPUP_LIST;
    pub const nsFrameState_NS_TABLE_CELL_HAD_SPECIAL_REFLOW:
              root::nsFrameState =
        nsFrameState::NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK;
    pub const nsFrameState_NS_TABLE_CELL_CONTENT_EMPTY: root::nsFrameState =
        nsFrameState::NS_STATE_IS_DIRECTION_NORMAL;
    pub const nsFrameState_NS_REPEATED_ROW_OR_ROWGROUP: root::nsFrameState =
        nsFrameState::NS_STATE_MENU_HAS_POPUP_LIST;
    pub const nsFrameState_NS_ROW_HAS_CELL_WITH_STYLE_BSIZE:
              root::nsFrameState =
        nsFrameState::NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK;
    pub const nsFrameState_NS_TABLE_ROW_HAS_UNPAGINATED_BSIZE:
              root::nsFrameState =
        nsFrameState::NS_STATE_EQUAL_SIZE;
    pub const nsFrameState_NS_ROWGROUP_HAS_ROW_CURSOR: root::nsFrameState =
        nsFrameState::NS_STATE_DEBUG_WAS_SET;
    pub const nsFrameState_NS_ROWGROUP_HAS_STYLE_BSIZE: root::nsFrameState =
        nsFrameState::NS_STATE_EQUAL_SIZE;
    pub const nsFrameState_NS_ROWGROUP_REPEATABLE: root::nsFrameState =
        nsFrameState::NS_STATE_IS_DIRECTION_NORMAL;
    pub const nsFrameState_NS_TABLE_PART_HAS_FIXED_BACKGROUND:
              root::nsFrameState =
        nsFrameState::NS_STATE_MENU_HAS_POPUP_LIST;
    #[repr(u64)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsFrameState {
        NS_FRAME_IN_REFLOW = 1,
        NS_FRAME_FIRST_REFLOW = 2,
        NS_FRAME_IS_FLUID_CONTINUATION = 4,
        NS_FRAME_ANONYMOUSCONTENTCREATOR_CONTENT = 8,
        NS_FRAME_EXTERNAL_REFERENCE = 16,
        NS_FRAME_CONTAINS_RELATIVE_BSIZE = 32,
        NS_FRAME_GENERATED_CONTENT = 64,
        NS_FRAME_IS_OVERFLOW_CONTAINER = 128,
        NS_FRAME_OUT_OF_FLOW = 256,
        NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN = 512,
        NS_FRAME_IS_DIRTY = 1024,
        NS_FRAME_TOO_DEEP_IN_FRAME_TREE = 2048,
        NS_FRAME_HAS_DIRTY_CHILDREN = 4096,
        NS_FRAME_HAS_VIEW = 8192,
        NS_FRAME_INDEPENDENT_SELECTION = 16384,
        NS_FRAME_PART_OF_IBSPLIT = 32768,
        NS_FRAME_MAY_BE_TRANSFORMED = 65536,
        NS_FRAME_IS_BIDI = 131072,
        NS_FRAME_HAS_CHILD_WITH_VIEW = 262144,
        NS_FRAME_REFLOW_ROOT = 524288,
        NS_FRAME_IS_PUSHED_FLOAT = 4294967296,
        NS_FRAME_DRAWING_AS_PAINTSERVER = 8589934592,
        NS_FRAME_DESCENDANT_INTRINSIC_ISIZE_DEPENDS_ON_BSIZE = 17179869184,
        NS_FRAME_SIMPLE_EVENT_REGIONS = 34359738368,
        NS_FRAME_UPDATE_LAYER_TREE = 68719476736,
        NS_FRAME_HAS_ABSPOS_CHILDREN = 137438953472,
        NS_FRAME_PAINTED_THEBES = 274877906944,
        NS_FRAME_IN_CONSTRAINED_BSIZE = 549755813888,
        NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO = 1099511627776,
        NS_FRAME_FONT_INFLATION_CONTAINER = 2199023255552,
        NS_FRAME_FONT_INFLATION_FLOW_ROOT = 4398046511104,
        NS_FRAME_SVG_LAYOUT = 8796093022208,
        NS_FRAME_MAY_HAVE_GENERATED_CONTENT = 17592186044416,
        NS_FRAME_NO_COMPONENT_ALPHA = 35184372088832,
        NS_FRAME_VISIBILITY_IS_TRACKED = 70368744177664,
        NS_FRAME_IS_SVG_TEXT = 140737488355328,
        NS_FRAME_NEEDS_PAINT = 281474976710656,
        NS_FRAME_DESCENDANT_NEEDS_PAINT = 562949953421312,
        NS_FRAME_IN_POPUP = 1125899906842624,
        NS_FRAME_ALL_DESCENDANTS_NEED_PAINT = 2251799813685248,
        NS_FRAME_HAS_INVALID_RECT = 4503599627370496,
        NS_FRAME_IS_NONDISPLAY = 9007199254740992,
        NS_FRAME_HAS_LAYER_ACTIVITY_PROPERTY = 18014398509481984,
        NS_FRAME_MATHML_SCRIPT_DESCENDANT = 288230376151711744,
        NS_FRAME_IS_IN_SINGLE_CHAR_MI = 576460752303423488,
        NS_STATE_BOX_CHILD_RESERVED = 1048576,
        NS_STATE_STACK_NOT_POSITIONED = 2097152,
        NS_STATE_IS_HORIZONTAL = 4194304,
        NS_STATE_AUTO_STRETCH = 8388608,
        NS_STATE_IS_ROOT = 16777216,
        NS_STATE_CURRENTLY_IN_DEBUG = 33554432,
        NS_STATE_SET_TO_DEBUG = 67108864,
        NS_STATE_DEBUG_WAS_SET = 134217728,
        NS_STATE_MENU_HAS_POPUP_LIST = 268435456,
        NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK = 536870912,
        NS_STATE_EQUAL_SIZE = 1073741824,
        NS_STATE_IS_DIRECTION_NORMAL = 2147483648,
        NS_FRAME_MOUSE_THROUGH_ALWAYS = 1152921504606846976,
        NS_FRAME_MOUSE_THROUGH_NEVER = 2305843009213693952,
        TEXT_NO_RENDERED_GLYPHS = 4611686018427387904,
        TEXT_IN_OFFSET_CACHE = 9223372036854775808,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsView([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsRenderingContext([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIPageSequenceFrame([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsCanvasFrame([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsCaret([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsFrameSelection([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIReflowCallback([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsCSSFrameConstructor([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsWeakFrame([u8; 0]);
    /**
 * Interface for frames that are scrollable. This interface exposes
 * APIs for examining scroll state, observing changes to scroll state,
 * and triggering scrolling.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIScrollableFrame {
        pub _base: root::nsIScrollbarMediator,
    }
    pub type nsIScrollableFrame_CSSIntPoint = root::mozilla::CSSIntPoint;
    pub type nsIScrollableFrame_ContainerLayerParameters =
        root::mozilla::ContainerLayerParameters;
    pub type nsIScrollableFrame_FrameMetrics =
        root::mozilla::layers::FrameMetrics;
    pub type nsIScrollableFrame_ScrollSnapInfo =
        root::mozilla::layers::ScrollSnapInfo;
    pub type nsIScrollableFrame_Has_NS_DECL_QUERYFRAME_TARGET =
        root::nsIScrollableFrame;
    pub const nsIScrollableFrame_HORIZONTAL:
              root::nsIScrollableFrame__bindgen_ty_1 =
        nsIScrollableFrame__bindgen_ty_1::HORIZONTAL;
    pub const nsIScrollableFrame_VERTICAL:
              root::nsIScrollableFrame__bindgen_ty_1 =
        nsIScrollableFrame__bindgen_ty_1::VERTICAL;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIScrollableFrame__bindgen_ty_1 {
        HORIZONTAL = 1,
        VERTICAL = 2,
    }
    #[repr(u32)]
    /**
   * When a scroll operation is requested, we ask for instant, smooth,
   * smooth msd, or normal scrolling.
   *
   * SMOOTH scrolls have a symmetrical acceleration and deceleration curve
   * modeled with a set of splines that guarantee that the destination will be 
   * reached over a fixed time interval.  SMOOTH will only be smooth if smooth
   * scrolling is actually enabled.  This behavior is utilized by keyboard and
   * mouse wheel scrolling events.
   *
   * SMOOTH_MSD implements a physically based model that approximates the
   * behavior of a mass-spring-damper system.  SMOOTH_MSD scrolls have a
   * non-symmetrical acceleration and deceleration curve, can potentially
   * overshoot the destination on intermediate frames, and complete over a
   * variable time interval.  SMOOTH_MSD will only be smooth if cssom-view
   * smooth-scrolling is enabled.
   *
   * INSTANT is always synchronous, NORMAL can be asynchronous.
   *
   * If an INSTANT scroll request happens while a SMOOTH or async scroll is
   * already in progress, the async scroll is interrupted and we instantly
   * scroll to the destination.
   *
   * If an INSTANT or SMOOTH scroll request happens while a SMOOTH_MSD scroll
   * is already in progress, the SMOOTH_MSD scroll is interrupted without
   * first scrolling to the destination.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIScrollableFrame_ScrollMode {
        INSTANT = 0,
        SMOOTH = 1,
        SMOOTH_MSD = 2,
        NORMAL = 3,
    }
    #[repr(u32)]
    /**
   * Some platforms (OSX) may generate additional scrolling events even
   * after the user has stopped scrolling, simulating a momentum scrolling
   * effect resulting from fling gestures.
   * SYNTHESIZED_MOMENTUM_EVENT indicates that the scrolling is being requested
   * by such a synthesized event and may be ignored if another scroll has
   * been started since the last actual user input.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIScrollableFrame_ScrollMomentum {
        NOT_MOMENTUM = 0,
        SYNTHESIZED_MOMENTUM_EVENT = 1,
    }
    #[repr(u32)]
    /**
   * When scrolling by a relative amount, we can choose various units.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIScrollableFrame_ScrollUnit {
        DEVICE_PIXELS = 0,
        LINES = 1,
        PAGES = 2,
        WHOLE = 3,
    }
    extern "C" {
        #[link_name = "_ZN18nsIScrollableFrame9kFrameIIDE"]
        pub static nsIScrollableFrame_kFrameIID: root::nsQueryFrame_FrameIID;
    }
    #[test]
    fn bindgen_test_layout_nsIScrollableFrame() {
        assert_eq!(::std::mem::size_of::<nsIScrollableFrame>() , 8usize ,
                   concat ! ( "Size of: " , stringify ! ( nsIScrollableFrame )
                   ));
        assert_eq! (::std::mem::align_of::<nsIScrollableFrame>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIScrollableFrame ) ));
    }
    impl Clone for nsIScrollableFrame {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct gfxContext([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDisplayList([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDisplayListBuilder([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsRefreshDriver([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsARefreshObserver([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsAPostRefreshObserver([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsAccessibilityService([u8; 0]);
    #[repr(C)]
    #[derive(Debug)]
    pub struct CapturingContentInfo {
        pub mAllowed: bool,
        pub mPointerLock: bool,
        pub mRetargetToElement: bool,
        pub mPreventDrag: bool,
        pub mContent: root::mozilla::StaticRefPtr<root::nsIContent>,
    }
    #[test]
    fn bindgen_test_layout_CapturingContentInfo() {
        assert_eq!(::std::mem::size_of::<CapturingContentInfo>() , 16usize ,
                   concat ! (
                   "Size of: " , stringify ! ( CapturingContentInfo ) ));
        assert_eq! (::std::mem::align_of::<CapturingContentInfo>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( CapturingContentInfo ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CapturingContentInfo ) ) . mAllowed
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CapturingContentInfo ) , "::" , stringify ! ( mAllowed )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CapturingContentInfo ) ) .
                    mPointerLock as * const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CapturingContentInfo ) , "::" , stringify ! ( mPointerLock
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CapturingContentInfo ) ) .
                    mRetargetToElement as * const _ as usize } , 2usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    CapturingContentInfo ) , "::" , stringify ! (
                    mRetargetToElement ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CapturingContentInfo ) ) .
                    mPreventDrag as * const _ as usize } , 3usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CapturingContentInfo ) , "::" , stringify ! ( mPreventDrag
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CapturingContentInfo ) ) . mContent
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CapturingContentInfo ) , "::" , stringify ! ( mContent )
                    ));
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsRectVisibility {
        nsRectVisibility_kVisible = 0,
        nsRectVisibility_kAboveViewport = 1,
        nsRectVisibility_kBelowViewport = 2,
        nsRectVisibility_kLeftOfViewport = 3,
        nsRectVisibility_kRightOfViewport = 4,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIWidget([u8; 0]);
    #[repr(u32)]
    /**
 * sizemode is an adjunct to widget size
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsSizeMode {
        nsSizeMode_Normal = 0,
        nsSizeMode_Minimized = 1,
        nsSizeMode_Maximized = 2,
        nsSizeMode_Fullscreen = 3,
        nsSizeMode_Invalid = 4,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleDisplay {
        pub mBinding: root::RefPtr<root::mozilla::css::URLValue>,
        pub mDisplay: root::mozilla::StyleDisplay,
        pub mOriginalDisplay: root::mozilla::StyleDisplay,
        pub mContain: u8,
        pub mAppearance: u8,
        pub mPosition: u8,
        pub mFloat: root::mozilla::StyleFloat,
        pub mOriginalFloat: root::mozilla::StyleFloat,
        pub mBreakType: root::mozilla::StyleClear,
        pub mBreakInside: u8,
        pub mBreakBefore: bool,
        pub mBreakAfter: bool,
        pub mOverflowX: u8,
        pub mOverflowY: u8,
        pub mOverflowClipBox: u8,
        pub mResize: u8,
        pub mOrient: root::mozilla::StyleOrient,
        pub mIsolation: u8,
        pub mTopLayer: u8,
        pub mWillChangeBitField: u8,
        pub mWillChange: root::nsTArray<::nsstring::nsStringRepr>,
        pub mTouchAction: u8,
        pub mScrollBehavior: u8,
        pub mScrollSnapTypeX: u8,
        pub mScrollSnapTypeY: u8,
        pub mScrollSnapPointsX: root::nsStyleCoord,
        pub mScrollSnapPointsY: root::nsStyleCoord,
        pub mScrollSnapDestination: root::mozilla::Position,
        pub mScrollSnapCoordinate: root::nsTArray<root::mozilla::Position>,
        pub mBackfaceVisibility: u8,
        pub mTransformStyle: u8,
        pub mTransformBox: u8,
        pub mSpecifiedTransform: root::RefPtr<root::nsCSSValueSharedList>,
        pub mTransformOrigin: [root::nsStyleCoord; 3usize],
        pub mChildPerspective: root::nsStyleCoord,
        pub mPerspectiveOrigin: [root::nsStyleCoord; 2usize],
        pub mVerticalAlign: root::nsStyleCoord,
        pub mTransitions: root::nsStyleAutoArray<root::mozilla::StyleTransition>,
        pub mTransitionTimingFunctionCount: u32,
        pub mTransitionDurationCount: u32,
        pub mTransitionDelayCount: u32,
        pub mTransitionPropertyCount: u32,
        pub mAnimations: root::nsStyleAutoArray<root::mozilla::StyleAnimation>,
        pub mAnimationTimingFunctionCount: u32,
        pub mAnimationDurationCount: u32,
        pub mAnimationDelayCount: u32,
        pub mAnimationNameCount: u32,
        pub mAnimationDirectionCount: u32,
        pub mAnimationFillModeCount: u32,
        pub mAnimationPlayStateCount: u32,
        pub mAnimationIterationCountCount: u32,
        pub mShapeOutside: root::mozilla::StyleShapeSource,
    }
    #[test]
    fn bindgen_test_layout_nsStyleDisplay() {
        assert_eq!(::std::mem::size_of::<nsStyleDisplay>() , 416usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleDisplay ) ));
        assert_eq! (::std::mem::align_of::<nsStyleDisplay>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleDisplay ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mBinding as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mBinding ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mDisplay as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mDisplay ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mOriginalDisplay
                    as * const _ as usize } , 9usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mOriginalDisplay ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mContain as *
                    const _ as usize } , 10usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mContain ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mAppearance as *
                    const _ as usize } , 11usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAppearance ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mPosition as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mPosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mFloat as *
                    const _ as usize } , 13usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mFloat ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mOriginalFloat
                    as * const _ as usize } , 14usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mOriginalFloat ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mBreakType as *
                    const _ as usize } , 15usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mBreakType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mBreakInside as
                    * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mBreakInside ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mBreakBefore as
                    * const _ as usize } , 17usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mBreakBefore ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mBreakAfter as *
                    const _ as usize } , 18usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mBreakAfter ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mOverflowX as *
                    const _ as usize } , 19usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mOverflowX ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mOverflowY as *
                    const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mOverflowY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mOverflowClipBox
                    as * const _ as usize } , 21usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mOverflowClipBox ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mResize as *
                    const _ as usize } , 22usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mResize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mOrient as *
                    const _ as usize } , 23usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mOrient ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mIsolation as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mIsolation ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mTopLayer as *
                    const _ as usize } , 25usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTopLayer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mWillChangeBitField as * const _ as usize } , 26usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mWillChangeBitField ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mWillChange as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mWillChange ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mTouchAction as
                    * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTouchAction ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mScrollBehavior
                    as * const _ as usize } , 41usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mScrollBehavior ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mScrollSnapTypeX
                    as * const _ as usize } , 42usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mScrollSnapTypeX ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mScrollSnapTypeY
                    as * const _ as usize } , 43usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mScrollSnapTypeY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mScrollSnapPointsX as * const _ as usize } , 48usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mScrollSnapPointsX ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mScrollSnapPointsY as * const _ as usize } , 64usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mScrollSnapPointsY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mScrollSnapDestination as * const _ as usize } , 80usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mScrollSnapDestination ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mScrollSnapCoordinate as * const _ as usize } , 104usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mScrollSnapCoordinate ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mBackfaceVisibility as * const _ as usize } , 112usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mBackfaceVisibility ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mTransformStyle
                    as * const _ as usize } , 113usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransformStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mTransformBox as
                    * const _ as usize } , 114usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransformBox ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mSpecifiedTransform as * const _ as usize } , 120usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mSpecifiedTransform ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mTransformOrigin
                    as * const _ as usize } , 128usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransformOrigin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mChildPerspective as * const _ as usize } , 176usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mChildPerspective ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mPerspectiveOrigin as * const _ as usize } , 192usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mPerspectiveOrigin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mVerticalAlign
                    as * const _ as usize } , 224usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mVerticalAlign ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mTransitions as
                    * const _ as usize } , 240usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransitions ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mTransitionTimingFunctionCount as * const _ as usize } ,
                    288usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransitionTimingFunctionCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mTransitionDurationCount as * const _ as usize } ,
                    292usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransitionDurationCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mTransitionDelayCount as * const _ as usize } , 296usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransitionDelayCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mTransitionPropertyCount as * const _ as usize } ,
                    300usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mTransitionPropertyCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mAnimations as *
                    const _ as usize } , 304usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimations ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationTimingFunctionCount as * const _ as usize } ,
                    368usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationTimingFunctionCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationDurationCount as * const _ as usize } , 372usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationDurationCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationDelayCount as * const _ as usize } , 376usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationDelayCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationNameCount as * const _ as usize } , 380usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationNameCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationDirectionCount as * const _ as usize } ,
                    384usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationDirectionCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationFillModeCount as * const _ as usize } , 388usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationFillModeCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationPlayStateCount as * const _ as usize } ,
                    392usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationPlayStateCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) .
                    mAnimationIterationCountCount as * const _ as usize } ,
                    396usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mAnimationIterationCountCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleDisplay ) ) . mShapeOutside as
                    * const _ as usize } , 400usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleDisplay ) ,
                    "::" , stringify ! ( mShapeOutside ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsILanguageAtomService {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsILanguageAtomService_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsILanguageAtomService() {
        assert_eq!(::std::mem::size_of::<nsILanguageAtomService>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsILanguageAtomService ) ));
        assert_eq! (::std::mem::align_of::<nsILanguageAtomService>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsILanguageAtomService )
                    ));
    }
    impl Clone for nsILanguageAtomService {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIPrintSettings([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsITheme([u8; 0]);
    /**
 * Interface used for handling clicks on links
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsILinkHandler {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsILinkHandler_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsILinkHandler() {
        assert_eq!(::std::mem::size_of::<nsILinkHandler>() , 8usize , concat !
                   ( "Size of: " , stringify ! ( nsILinkHandler ) ));
        assert_eq! (::std::mem::align_of::<nsILinkHandler>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsILinkHandler ) ));
    }
    impl Clone for nsILinkHandler {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct gfxUserFontEntry([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct gfxTextPerfMetrics([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsTransitionManager([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsAnimationManager([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDeviceContext([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct gfxMissingFontRecorder([u8; 0]);
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsRootPresContext {
        pub _base: root::nsPresContext,
        pub mNotifyDidPaintTimers: [u64; 10usize],
        pub mApplyPluginGeometryTimer: root::nsCOMPtr<root::nsITimer>,
        pub mRegisteredPlugins: [u64; 5usize],
        pub mWillPaintObservers: root::nsTArray<root::nsCOMPtr<root::nsIRunnable>>,
        pub mWillPaintFallbackEvent: root::nsRevocableEventPtr<root::nsRootPresContext_RunWillPaintObservers>,
        pub mDOMGeneration: u32,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsRootPresContext_RunWillPaintObservers {
        pub _base: root::mozilla::Runnable,
        pub mPresContext: *mut root::nsRootPresContext,
    }
    #[test]
    fn bindgen_test_layout_nsRootPresContext_RunWillPaintObservers() {
        assert_eq!(::std::mem::size_of::<nsRootPresContext_RunWillPaintObservers>()
                   , 40usize , concat ! (
                   "Size of: " , stringify ! (
                   nsRootPresContext_RunWillPaintObservers ) ));
        assert_eq! (::std::mem::align_of::<nsRootPresContext_RunWillPaintObservers>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsRootPresContext_RunWillPaintObservers ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsRootPresContext_RunWillPaintObservers )
                    ) . mPresContext as * const _ as usize } , 32usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsRootPresContext_RunWillPaintObservers ) , "::" ,
                    stringify ! ( mPresContext ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsRootPresContext_NotifyDidPaintTimer {
        pub mTransactionId: u64,
        pub mTimer: root::nsCOMPtr<root::nsITimer>,
    }
    #[test]
    fn bindgen_test_layout_nsRootPresContext_NotifyDidPaintTimer() {
        assert_eq!(::std::mem::size_of::<nsRootPresContext_NotifyDidPaintTimer>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsRootPresContext_NotifyDidPaintTimer ) ));
        assert_eq! (::std::mem::align_of::<nsRootPresContext_NotifyDidPaintTimer>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsRootPresContext_NotifyDidPaintTimer ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsRootPresContext_NotifyDidPaintTimer ) )
                    . mTransactionId as * const _ as usize } , 0usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsRootPresContext_NotifyDidPaintTimer ) , "::" , stringify
                    ! ( mTransactionId ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsRootPresContext_NotifyDidPaintTimer ) )
                    . mTimer as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsRootPresContext_NotifyDidPaintTimer ) , "::" , stringify
                    ! ( mTimer ) ));
    }
    #[test]
    fn bindgen_test_layout_nsRootPresContext() {
        assert_eq!(::std::mem::size_of::<nsRootPresContext>() , 1480usize ,
                   concat ! ( "Size of: " , stringify ! ( nsRootPresContext )
                   ));
        assert_eq! (::std::mem::align_of::<nsRootPresContext>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsRootPresContext ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRootPresContext ) ) .
                    mNotifyDidPaintTimers as * const _ as usize } , 1328usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsRootPresContext )
                    , "::" , stringify ! ( mNotifyDidPaintTimers ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRootPresContext ) ) .
                    mApplyPluginGeometryTimer as * const _ as usize } ,
                    1408usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsRootPresContext )
                    , "::" , stringify ! ( mApplyPluginGeometryTimer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRootPresContext ) ) .
                    mRegisteredPlugins as * const _ as usize } , 1416usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsRootPresContext )
                    , "::" , stringify ! ( mRegisteredPlugins ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRootPresContext ) ) .
                    mWillPaintObservers as * const _ as usize } , 1456usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsRootPresContext )
                    , "::" , stringify ! ( mWillPaintObservers ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRootPresContext ) ) .
                    mWillPaintFallbackEvent as * const _ as usize } ,
                    1464usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsRootPresContext )
                    , "::" , stringify ! ( mWillPaintFallbackEvent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRootPresContext ) ) .
                    mDOMGeneration as * const _ as usize } , 1472usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsRootPresContext )
                    , "::" , stringify ! ( mDOMGeneration ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct imgIContainer([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsISecurityInfoProvider {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISecurityInfoProvider_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsISecurityInfoProvider() {
        assert_eq!(::std::mem::size_of::<nsISecurityInfoProvider>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsISecurityInfoProvider ) ));
        assert_eq! (::std::mem::align_of::<nsISecurityInfoProvider>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsISecurityInfoProvider )
                    ));
    }
    impl Clone for nsISecurityInfoProvider {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsISupportsPriority {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISupportsPriority_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const nsISupportsPriority_PRIORITY_HIGHEST:
              root::nsISupportsPriority__bindgen_ty_1 =
        nsISupportsPriority__bindgen_ty_1::PRIORITY_HIGHEST;
    pub const nsISupportsPriority_PRIORITY_HIGH:
              root::nsISupportsPriority__bindgen_ty_1 =
        nsISupportsPriority__bindgen_ty_1::PRIORITY_HIGH;
    pub const nsISupportsPriority_PRIORITY_NORMAL:
              root::nsISupportsPriority__bindgen_ty_1 =
        nsISupportsPriority__bindgen_ty_1::PRIORITY_NORMAL;
    pub const nsISupportsPriority_PRIORITY_LOW:
              root::nsISupportsPriority__bindgen_ty_1 =
        nsISupportsPriority__bindgen_ty_1::PRIORITY_LOW;
    pub const nsISupportsPriority_PRIORITY_LOWEST:
              root::nsISupportsPriority__bindgen_ty_1 =
        nsISupportsPriority__bindgen_ty_1::PRIORITY_LOWEST;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsISupportsPriority__bindgen_ty_1 {
        PRIORITY_HIGHEST = -20,
        PRIORITY_HIGH = -10,
        PRIORITY_NORMAL = 0,
        PRIORITY_LOW = 10,
        PRIORITY_LOWEST = 20,
    }
    #[test]
    fn bindgen_test_layout_nsISupportsPriority() {
        assert_eq!(::std::mem::size_of::<nsISupportsPriority>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsISupportsPriority ) ));
        assert_eq! (::std::mem::align_of::<nsISupportsPriority>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsISupportsPriority ) ));
    }
    impl Clone for nsISupportsPriority {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsITimedChannel {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsITimedChannel_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsITimedChannel() {
        assert_eq!(::std::mem::size_of::<nsITimedChannel>() , 8usize , concat
                   ! ( "Size of: " , stringify ! ( nsITimedChannel ) ));
        assert_eq! (::std::mem::align_of::<nsITimedChannel>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsITimedChannel ) ));
    }
    impl Clone for nsITimedChannel {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIAsyncVerifyRedirectCallback {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIAsyncVerifyRedirectCallback_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIAsyncVerifyRedirectCallback() {
        assert_eq!(::std::mem::size_of::<nsIAsyncVerifyRedirectCallback>() ,
                   8usize , concat ! (
                   "Size of: " , stringify ! ( nsIAsyncVerifyRedirectCallback
                   ) ));
        assert_eq! (::std::mem::align_of::<nsIAsyncVerifyRedirectCallback>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsIAsyncVerifyRedirectCallback ) ));
    }
    impl Clone for nsIAsyncVerifyRedirectCallback {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIChannelEventSink {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIChannelEventSink_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const nsIChannelEventSink_REDIRECT_TEMPORARY:
              root::nsIChannelEventSink__bindgen_ty_1 =
        nsIChannelEventSink__bindgen_ty_1::REDIRECT_TEMPORARY;
    pub const nsIChannelEventSink_REDIRECT_PERMANENT:
              root::nsIChannelEventSink__bindgen_ty_1 =
        nsIChannelEventSink__bindgen_ty_1::REDIRECT_PERMANENT;
    pub const nsIChannelEventSink_REDIRECT_INTERNAL:
              root::nsIChannelEventSink__bindgen_ty_1 =
        nsIChannelEventSink__bindgen_ty_1::REDIRECT_INTERNAL;
    pub const nsIChannelEventSink_REDIRECT_STS_UPGRADE:
              root::nsIChannelEventSink__bindgen_ty_1 =
        nsIChannelEventSink__bindgen_ty_1::REDIRECT_STS_UPGRADE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIChannelEventSink__bindgen_ty_1 {
        REDIRECT_TEMPORARY = 1,
        REDIRECT_PERMANENT = 2,
        REDIRECT_INTERNAL = 4,
        REDIRECT_STS_UPGRADE = 8,
    }
    #[test]
    fn bindgen_test_layout_nsIChannelEventSink() {
        assert_eq!(::std::mem::size_of::<nsIChannelEventSink>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIChannelEventSink ) ));
        assert_eq! (::std::mem::align_of::<nsIChannelEventSink>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIChannelEventSink ) ));
    }
    impl Clone for nsIChannelEventSink {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIThreadRetargetableStreamListener {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIThreadRetargetableStreamListener_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIThreadRetargetableStreamListener() {
        assert_eq!(::std::mem::size_of::<nsIThreadRetargetableStreamListener>()
                   , 8usize , concat ! (
                   "Size of: " , stringify ! (
                   nsIThreadRetargetableStreamListener ) ));
        assert_eq! (::std::mem::align_of::<nsIThreadRetargetableStreamListener>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsIThreadRetargetableStreamListener ) ));
    }
    impl Clone for nsIThreadRetargetableStreamListener {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct imgCacheValidator([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct imgLoader([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct imgCacheEntry([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIApplicationCache([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIProperties([u8; 0]);
    #[repr(C)]
    #[derive(Debug)]
    pub struct imgRequest {
        pub _base: root::nsIStreamListener,
        pub _base_1: root::nsIThreadRetargetableStreamListener,
        pub _base_2: root::nsIChannelEventSink,
        pub _base_3: root::nsIInterfaceRequestor,
        pub _base_4: root::nsIAsyncVerifyRedirectCallback,
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mLoader: *mut root::imgLoader,
        pub mRequest: root::nsCOMPtr<root::nsIRequest>,
        pub mURI: root::RefPtr<root::mozilla::image::ImageURL>,
        pub mCurrentURI: root::nsCOMPtr<root::nsIURI>,
        pub mLoadingPrincipal: root::nsCOMPtr<root::nsIPrincipal>,
        pub mPrincipal: root::nsCOMPtr<root::nsIPrincipal>,
        pub mProperties: root::nsCOMPtr<root::nsIProperties>,
        pub mSecurityInfo: root::nsCOMPtr<root::nsISupports>,
        pub mChannel: root::nsCOMPtr<root::nsIChannel>,
        pub mPrevChannelSink: root::nsCOMPtr<root::nsIInterfaceRequestor>,
        pub mApplicationCache: root::nsCOMPtr<root::nsIApplicationCache>,
        pub mTimedChannel: root::nsCOMPtr<root::nsITimedChannel>,
        pub mContentType: root::nsCString,
        pub mCacheEntry: root::RefPtr<root::imgCacheEntry>,
        /// The key under which this imgRequest is stored in the image cache.
        pub mCacheKey: root::imgRequest_ImageCacheKey,
        pub mLoadId: *mut ::std::os::raw::c_void,
        /// Raw pointer to the first proxy that was added to this imgRequest. Use only
  /// pointer comparisons; there's no guarantee this will remain valid.
        pub mFirstProxy: *mut ::std::os::raw::c_void,
        pub mValidator: *mut root::imgCacheValidator,
        pub mRedirectCallback: root::nsCOMPtr<root::nsIAsyncVerifyRedirectCallback>,
        pub mNewRedirectChannel: root::nsCOMPtr<root::nsIChannel>,
        pub mInnerWindowId: u64,
        pub mCORSMode: i32,
        pub mReferrerPolicy: root::imgRequest_ReferrerPolicy,
        pub mImageErrorCode: root::nsresult,
        pub mMutex: root::mozilla::Mutex,
        pub mProgressTracker: root::RefPtr<root::mozilla::image::ProgressTracker>,
        pub mImage: root::RefPtr<root::mozilla::image::Image>,
        pub _bitfield_1: u8,
        pub __bindgen_padding_0: [u8; 7usize],
    }
    pub type imgRequest_Image = root::mozilla::image::Image;
    pub type imgRequest_ImageCacheKey = root::mozilla::image::ImageCacheKey;
    pub type imgRequest_ImageURL = root::mozilla::image::ImageURL;
    pub type imgRequest_ProgressTracker =
        root::mozilla::image::ProgressTracker;
    pub use self::super::root::mozilla::net::ReferrerPolicy as
            imgRequest_ReferrerPolicy;
    pub type imgRequest_HasThreadSafeRefCnt = root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_imgRequest() {
        assert_eq!(::std::mem::size_of::<imgRequest>() , 368usize , concat ! (
                   "Size of: " , stringify ! ( imgRequest ) ));
        assert_eq! (::std::mem::align_of::<imgRequest>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( imgRequest ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ProxyBehaviour([u8; 0]);
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleVisibility {
        pub mImageOrientation: root::nsStyleImageOrientation,
        pub mDirection: u8,
        pub mVisible: u8,
        pub mImageRendering: u8,
        pub mWritingMode: u8,
        pub mTextOrientation: u8,
        pub mColorAdjust: u8,
    }
    #[test]
    fn bindgen_test_layout_nsStyleVisibility() {
        assert_eq!(::std::mem::size_of::<nsStyleVisibility>() , 7usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleVisibility )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleVisibility>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleVisibility ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVisibility ) ) .
                    mImageOrientation as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleVisibility )
                    , "::" , stringify ! ( mImageOrientation ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVisibility ) ) . mDirection as
                    * const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleVisibility )
                    , "::" , stringify ! ( mDirection ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVisibility ) ) . mVisible as *
                    const _ as usize } , 2usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleVisibility )
                    , "::" , stringify ! ( mVisible ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVisibility ) ) .
                    mImageRendering as * const _ as usize } , 3usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleVisibility )
                    , "::" , stringify ! ( mImageRendering ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVisibility ) ) . mWritingMode
                    as * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleVisibility )
                    , "::" , stringify ! ( mWritingMode ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVisibility ) ) .
                    mTextOrientation as * const _ as usize } , 5usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleVisibility )
                    , "::" , stringify ! ( mTextOrientation ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVisibility ) ) . mColorAdjust
                    as * const _ as usize } , 6usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleVisibility )
                    , "::" , stringify ! ( mColorAdjust ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleFont {
        pub mFont: root::nsFont,
        pub mSize: root::nscoord,
        pub mGenericID: u8,
        pub mScriptLevel: i8,
        pub mMathVariant: u8,
        pub mMathDisplay: u8,
        pub mMinFontSizeRatio: u8,
        pub mExplicitLanguage: bool,
        pub mAllowZoom: bool,
        pub mScriptUnconstrainedSize: root::nscoord,
        pub mScriptMinSize: root::nscoord,
        pub mScriptSizeMultiplier: f32,
        pub mLanguage: root::nsCOMPtr<root::nsIAtom>,
    }
    #[test]
    fn bindgen_test_layout_nsStyleFont() {
        assert_eq!(::std::mem::size_of::<nsStyleFont>() , 128usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleFont ) ));
        assert_eq! (::std::mem::align_of::<nsStyleFont>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleFont ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mFont as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mFont ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mSize as * const _
                    as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mGenericID as *
                    const _ as usize } , 100usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mGenericID ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mScriptLevel as *
                    const _ as usize } , 101usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mScriptLevel ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mMathVariant as *
                    const _ as usize } , 102usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mMathVariant ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mMathDisplay as *
                    const _ as usize } , 103usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mMathDisplay ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mMinFontSizeRatio
                    as * const _ as usize } , 104usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mMinFontSizeRatio ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mExplicitLanguage
                    as * const _ as usize } , 105usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mExplicitLanguage ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mAllowZoom as *
                    const _ as usize } , 106usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mAllowZoom ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) .
                    mScriptUnconstrainedSize as * const _ as usize } ,
                    108usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mScriptUnconstrainedSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mScriptMinSize as *
                    const _ as usize } , 112usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mScriptMinSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) .
                    mScriptSizeMultiplier as * const _ as usize } , 116usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mScriptSizeMultiplier ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFont ) ) . mLanguage as *
                    const _ as usize } , 120usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFont ) ,
                    "::" , stringify ! ( mLanguage ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleGradientStop {
        pub mLocation: root::nsStyleCoord,
        pub mColor: root::nscolor,
        pub mIsInterpolationHint: bool,
    }
    #[test]
    fn bindgen_test_layout_nsStyleGradientStop() {
        assert_eq!(::std::mem::size_of::<nsStyleGradientStop>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsStyleGradientStop ) ));
        assert_eq! (::std::mem::align_of::<nsStyleGradientStop>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleGradientStop ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradientStop ) ) . mLocation
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradientStop
                    ) , "::" , stringify ! ( mLocation ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradientStop ) ) . mColor as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradientStop
                    ) , "::" , stringify ! ( mColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradientStop ) ) .
                    mIsInterpolationHint as * const _ as usize } , 20usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradientStop
                    ) , "::" , stringify ! ( mIsInterpolationHint ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleGradient {
        pub mShape: u8,
        pub mSize: u8,
        pub mRepeating: bool,
        pub mLegacySyntax: bool,
        pub mBgPosX: root::nsStyleCoord,
        pub mBgPosY: root::nsStyleCoord,
        pub mAngle: root::nsStyleCoord,
        pub mRadiusX: root::nsStyleCoord,
        pub mRadiusY: root::nsStyleCoord,
        pub mStops: root::nsTArray<root::nsStyleGradientStop>,
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
    }
    pub type nsStyleGradient_HasThreadSafeRefCnt = root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsStyleGradient() {
        assert_eq!(::std::mem::size_of::<nsStyleGradient>() , 104usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleGradient )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleGradient>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleGradient ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mShape as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mShape ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mSize as *
                    const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mRepeating as *
                    const _ as usize } , 2usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mRepeating ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mLegacySyntax
                    as * const _ as usize } , 3usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mLegacySyntax ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mBgPosX as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mBgPosX ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mBgPosY as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mBgPosY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mAngle as *
                    const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mAngle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mRadiusX as *
                    const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mRadiusX ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mRadiusY as *
                    const _ as usize } , 72usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mRadiusY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mStops as *
                    const _ as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mStops ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGradient ) ) . mRefCnt as *
                    const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGradient ) ,
                    "::" , stringify ! ( mRefCnt ) ));
    }
    /**
 * A wrapper for an imgRequestProxy that supports off-main-thread creation
 * and equality comparison.
 *
 * An nsStyleImageRequest can be created in two ways:
 *
 * 1. Using the constructor that takes an imgRequestProxy.  This must
 *    be called from the main thread.  The nsStyleImageRequest is
 *    immediately considered "resolved", and the get() method that
 *    returns the imgRequestProxy can be called.
 *
 * 2. Using the constructor that takes the URL, base URI, referrer
 *    and principal that can be used to inititiate an image load and
 *    produce an imgRequestProxy later.  This can be called from
 *    any thread.  The nsStyleImageRequest is not considered "resolved"
 *    at this point, and the Resolve() method must be called later
 *    to initiate the image load and make calls to get() valid.
 *
 * Calls to TrackImage(), UntrackImage(), LockImage(), UnlockImage() and
 * RequestDiscard() are made to the imgRequestProxy and ImageTracker as
 * appropriate, according to the mode flags passed in to the constructor.
 *
 * The main thread constructor takes a pointer to the css::ImageValue that
 * is the specified url() value, while the off-main-thread constructor
 * creates a new css::ImageValue to represent the url() information passed
 * to the constructor.  This ImageValue is held on to for the comparisons done
 * in DefinitelyEquals(), so that we don't need to call into the non-OMT-safe
 * Equals() on the nsIURI objects returned from imgRequestProxy::GetURI().
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleImageRequest {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mRequestProxy: root::RefPtr<root::imgRequestProxy>,
        pub mImageValue: root::RefPtr<root::mozilla::css::ImageValue>,
        pub mImageTracker: root::RefPtr<root::mozilla::dom::ImageTracker>,
        pub mModeFlags: root::nsStyleImageRequest_Mode,
        pub mResolved: bool,
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageRequest_Mode { Track = 1, Discard = 2, }
    pub type nsStyleImageRequest_HasThreadSafeRefCnt =
        root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsStyleImageRequest() {
        assert_eq!(::std::mem::size_of::<nsStyleImageRequest>() , 40usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsStyleImageRequest ) ));
        assert_eq! (::std::mem::align_of::<nsStyleImageRequest>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleImageRequest ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageRequest ) ) . mRefCnt as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageRequest
                    ) , "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageRequest ) ) .
                    mRequestProxy as * const _ as usize } , 8usize , concat !
                    (
                    "Alignment of field: " , stringify ! ( nsStyleImageRequest
                    ) , "::" , stringify ! ( mRequestProxy ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageRequest ) ) . mImageValue
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageRequest
                    ) , "::" , stringify ! ( mImageValue ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageRequest ) ) .
                    mImageTracker as * const _ as usize } , 24usize , concat !
                    (
                    "Alignment of field: " , stringify ! ( nsStyleImageRequest
                    ) , "::" , stringify ! ( mImageTracker ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageRequest ) ) . mModeFlags
                    as * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageRequest
                    ) , "::" , stringify ! ( mModeFlags ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageRequest ) ) . mResolved
                    as * const _ as usize } , 33usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageRequest
                    ) , "::" , stringify ! ( mResolved ) ));
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageType {
        eStyleImageType_Null = 0,
        eStyleImageType_Image = 1,
        eStyleImageType_Gradient = 2,
        eStyleImageType_Element = 3,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct CachedBorderImageData {
        pub mCachedSVGViewportSize: [u32; 3usize],
        pub mSubImages: root::nsCOMArray<root::imgIContainer>,
    }
    #[test]
    fn bindgen_test_layout_CachedBorderImageData() {
        assert_eq!(::std::mem::size_of::<CachedBorderImageData>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( CachedBorderImageData ) ));
        assert_eq! (::std::mem::align_of::<CachedBorderImageData>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( CachedBorderImageData )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CachedBorderImageData ) ) .
                    mCachedSVGViewportSize as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    CachedBorderImageData ) , "::" , stringify ! (
                    mCachedSVGViewportSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const CachedBorderImageData ) ) .
                    mSubImages as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    CachedBorderImageData ) , "::" , stringify ! ( mSubImages
                    ) ));
    }
    /**
 * Represents a paintable image of one of the following types.
 * (1) A real image loaded from an external source.
 * (2) A CSS linear or radial gradient.
 * (3) An element within a document, or an <img>, <video>, or <canvas> element
 *     not in a document.
 * (*) Optionally a crop rect can be set to paint a partial (rectangular)
 * region of an image. (Currently, this feature is only supported with an
 * image of type (1)).
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleImage {
        pub mCachedBIData: root::mozilla::UniquePtr<root::CachedBorderImageData,
                                                    root::mozilla::DefaultDelete<root::CachedBorderImageData>>,
        pub mType: root::nsStyleImageType,
        pub __bindgen_anon_1: root::nsStyleImage__bindgen_ty_1,
        pub mCropRect: root::mozilla::UniquePtr<root::nsStyleSides,
                                                root::mozilla::DefaultDelete<root::nsStyleSides>>,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleImage__bindgen_ty_1 {
        pub mImage: root::__BindgenUnionField<*mut root::nsStyleImageRequest>,
        pub mGradient: root::__BindgenUnionField<*mut root::nsStyleGradient>,
        pub mElementId: root::__BindgenUnionField<*mut u16>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsStyleImage__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleImage__bindgen_ty_1>() ,
                   8usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleImage__bindgen_ty_1 )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleImage__bindgen_ty_1>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsStyleImage__bindgen_ty_1
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImage__bindgen_ty_1 ) ) .
                    mImage as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImage__bindgen_ty_1 ) , "::" , stringify ! ( mImage
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImage__bindgen_ty_1 ) ) .
                    mGradient as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImage__bindgen_ty_1 ) , "::" , stringify ! (
                    mGradient ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImage__bindgen_ty_1 ) ) .
                    mElementId as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImage__bindgen_ty_1 ) , "::" , stringify ! (
                    mElementId ) ));
    }
    impl Clone for nsStyleImage__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsStyleImage() {
        assert_eq!(::std::mem::size_of::<nsStyleImage>() , 32usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleImage ) ));
        assert_eq! (::std::mem::align_of::<nsStyleImage>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleImage ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImage ) ) . mCachedBIData as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImage ) ,
                    "::" , stringify ! ( mCachedBIData ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImage ) ) . mType as * const _
                    as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImage ) ,
                    "::" , stringify ! ( mType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImage ) ) . mCropRect as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImage ) ,
                    "::" , stringify ! ( mCropRect ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleColor {
        pub mColor: root::nscolor,
    }
    #[test]
    fn bindgen_test_layout_nsStyleColor() {
        assert_eq!(::std::mem::size_of::<nsStyleColor>() , 4usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleColor ) ));
        assert_eq! (::std::mem::align_of::<nsStyleColor>() , 4usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColor ) ) . mColor as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColor ) ,
                    "::" , stringify ! ( mColor ) ));
    }
    /**
 * An array of objects, similar to AutoTArray<T,1> but which is memmovable. It
 * always has length >= 1.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleAutoArray<T> {
        pub mFirstElement: T,
        pub mOtherElements: root::nsTArray<T>,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleAutoArray_WithSingleInitialElement {
        WITH_SINGLE_INITIAL_ELEMENT = 0,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleImageLayers {
        pub mAttachmentCount: u32,
        pub mClipCount: u32,
        pub mOriginCount: u32,
        pub mRepeatCount: u32,
        pub mPositionXCount: u32,
        pub mPositionYCount: u32,
        pub mImageCount: u32,
        pub mSizeCount: u32,
        pub mMaskModeCount: u32,
        pub mBlendModeCount: u32,
        pub mCompositeCount: u32,
        pub mLayers: root::nsStyleAutoArray<root::nsStyleImageLayers_Layer>,
    }
    pub const nsStyleImageLayers_shorthand:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::shorthand;
    pub const nsStyleImageLayers_color: root::nsStyleImageLayers__bindgen_ty_1
              =
        nsStyleImageLayers__bindgen_ty_1::color;
    pub const nsStyleImageLayers_image: root::nsStyleImageLayers__bindgen_ty_1
              =
        nsStyleImageLayers__bindgen_ty_1::image;
    pub const nsStyleImageLayers_repeat:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::repeat;
    pub const nsStyleImageLayers_positionX:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::positionX;
    pub const nsStyleImageLayers_positionY:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::positionY;
    pub const nsStyleImageLayers_clip: root::nsStyleImageLayers__bindgen_ty_1
              =
        nsStyleImageLayers__bindgen_ty_1::clip;
    pub const nsStyleImageLayers_origin:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::origin;
    pub const nsStyleImageLayers_size: root::nsStyleImageLayers__bindgen_ty_1
              =
        nsStyleImageLayers__bindgen_ty_1::size;
    pub const nsStyleImageLayers_attachment:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::attachment;
    pub const nsStyleImageLayers_maskMode:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::maskMode;
    pub const nsStyleImageLayers_composite:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::composite;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageLayers__bindgen_ty_1 {
        shorthand = 0,
        color = 1,
        image = 2,
        repeat = 3,
        positionX = 4,
        positionY = 5,
        clip = 6,
        origin = 7,
        size = 8,
        attachment = 9,
        maskMode = 10,
        composite = 11,
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageLayers_LayerType { Background = 0, Mask = 1, }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleImageLayers_Size {
        pub mWidth: root::nsStyleImageLayers_Size_Dimension,
        pub mHeight: root::nsStyleImageLayers_Size_Dimension,
        pub mWidthType: u8,
        pub mHeightType: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleImageLayers_Size_Dimension {
        pub _base: root::nsStyleCoord_CalcValue,
    }
    #[test]
    fn bindgen_test_layout_nsStyleImageLayers_Size_Dimension() {
        assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Size_Dimension>()
                   , 12usize , concat ! (
                   "Size of: " , stringify ! (
                   nsStyleImageLayers_Size_Dimension ) ));
        assert_eq! (::std::mem::align_of::<nsStyleImageLayers_Size_Dimension>()
                    , 4usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsStyleImageLayers_Size_Dimension ) ));
    }
    impl Clone for nsStyleImageLayers_Size_Dimension {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageLayers_Size_DimensionType {
        eContain = 0,
        eCover = 1,
        eAuto = 2,
        eLengthPercentage = 3,
        eDimensionType_COUNT = 4,
    }
    #[test]
    fn bindgen_test_layout_nsStyleImageLayers_Size() {
        assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Size>() , 28usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsStyleImageLayers_Size ) ));
        assert_eq! (::std::mem::align_of::<nsStyleImageLayers_Size>() , 4usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsStyleImageLayers_Size )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Size ) ) . mWidth
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Size ) , "::" , stringify ! ( mWidth )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Size ) ) . mHeight
                    as * const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Size ) , "::" , stringify ! ( mHeight )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Size ) ) .
                    mWidthType as * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Size ) , "::" , stringify ! (
                    mWidthType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Size ) ) .
                    mHeightType as * const _ as usize } , 25usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Size ) , "::" , stringify ! (
                    mHeightType ) ));
    }
    impl Clone for nsStyleImageLayers_Size {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleImageLayers_Repeat {
        pub mXRepeat: u8,
        pub mYRepeat: u8,
    }
    #[test]
    fn bindgen_test_layout_nsStyleImageLayers_Repeat() {
        assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Repeat>() , 2usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsStyleImageLayers_Repeat ) ));
        assert_eq! (::std::mem::align_of::<nsStyleImageLayers_Repeat>() ,
                    1usize , concat ! (
                    "Alignment of " , stringify ! ( nsStyleImageLayers_Repeat
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Repeat ) ) .
                    mXRepeat as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Repeat ) , "::" , stringify ! (
                    mXRepeat ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Repeat ) ) .
                    mYRepeat as * const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Repeat ) , "::" , stringify ! (
                    mYRepeat ) ));
    }
    impl Clone for nsStyleImageLayers_Repeat {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleImageLayers_Layer {
        pub mImage: root::nsStyleImage,
        pub mSourceURI: root::RefPtr<root::mozilla::css::URLValueData>,
        pub mPosition: root::mozilla::Position,
        pub mSize: root::nsStyleImageLayers_Size,
        pub mClip: root::nsStyleImageLayers_Layer_StyleGeometryBox,
        pub mOrigin: root::nsStyleImageLayers_Layer_StyleGeometryBox,
        pub mAttachment: u8,
        pub mBlendMode: u8,
        pub mComposite: u8,
        pub mMaskMode: u8,
        pub mRepeat: root::nsStyleImageLayers_Repeat,
    }
    pub use self::super::root::mozilla::StyleGeometryBox as
            nsStyleImageLayers_Layer_StyleGeometryBox;
    #[test]
    fn bindgen_test_layout_nsStyleImageLayers_Layer() {
        assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Layer>() ,
                   104usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleImageLayers_Layer ) ));
        assert_eq! (::std::mem::align_of::<nsStyleImageLayers_Layer>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsStyleImageLayers_Layer )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) . mImage
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! ( mImage )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) .
                    mSourceURI as * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! (
                    mSourceURI ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) .
                    mPosition as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! (
                    mPosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) . mSize
                    as * const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! ( mSize )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) . mClip
                    as * const _ as usize } , 92usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! ( mClip )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) .
                    mOrigin as * const _ as usize } , 93usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! ( mOrigin
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) .
                    mAttachment as * const _ as usize } , 94usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! (
                    mAttachment ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) .
                    mBlendMode as * const _ as usize } , 95usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! (
                    mBlendMode ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) .
                    mComposite as * const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! (
                    mComposite ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) .
                    mMaskMode as * const _ as usize } , 97usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! (
                    mMaskMode ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers_Layer ) ) .
                    mRepeat as * const _ as usize } , 98usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageLayers_Layer ) , "::" , stringify ! ( mRepeat
                    ) ));
    }
    extern "C" {
        #[link_name = "_ZN18nsStyleImageLayers21kBackgroundLayerTableE"]
        pub static mut nsStyleImageLayers_kBackgroundLayerTable:
                   [root::nsCSSPropertyID; 0usize];
    }
    extern "C" {
        #[link_name = "_ZN18nsStyleImageLayers15kMaskLayerTableE"]
        pub static mut nsStyleImageLayers_kMaskLayerTable:
                   [root::nsCSSPropertyID; 0usize];
    }
    #[test]
    fn bindgen_test_layout_nsStyleImageLayers() {
        assert_eq!(::std::mem::size_of::<nsStyleImageLayers>() , 160usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleImageLayers )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleImageLayers>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleImageLayers ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) .
                    mAttachmentCount as * const _ as usize } , 0usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mAttachmentCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) . mClipCount
                    as * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mClipCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) . mOriginCount
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mOriginCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) . mRepeatCount
                    as * const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mRepeatCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) .
                    mPositionXCount as * const _ as usize } , 16usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mPositionXCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) .
                    mPositionYCount as * const _ as usize } , 20usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mPositionYCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) . mImageCount
                    as * const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mImageCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) . mSizeCount
                    as * const _ as usize } , 28usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mSizeCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) .
                    mMaskModeCount as * const _ as usize } , 32usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mMaskModeCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) .
                    mBlendModeCount as * const _ as usize } , 36usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mBlendModeCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) .
                    mCompositeCount as * const _ as usize } , 40usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mCompositeCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageLayers ) ) . mLayers as *
                    const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleImageLayers
                    ) , "::" , stringify ! ( mLayers ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleBackground {
        pub mImage: root::nsStyleImageLayers,
        pub mBackgroundColor: root::mozilla::StyleComplexColor,
    }
    #[test]
    fn bindgen_test_layout_nsStyleBackground() {
        assert_eq!(::std::mem::size_of::<nsStyleBackground>() , 168usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleBackground )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleBackground>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleBackground ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBackground ) ) . mImage as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBackground )
                    , "::" , stringify ! ( mImage ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBackground ) ) .
                    mBackgroundColor as * const _ as usize } , 160usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBackground )
                    , "::" , stringify ! ( mBackgroundColor ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleMargin {
        pub mMargin: root::nsStyleSides,
    }
    #[test]
    fn bindgen_test_layout_nsStyleMargin() {
        assert_eq!(::std::mem::size_of::<nsStyleMargin>() , 40usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleMargin ) ));
        assert_eq! (::std::mem::align_of::<nsStyleMargin>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleMargin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleMargin ) ) . mMargin as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleMargin ) ,
                    "::" , stringify ! ( mMargin ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStylePadding {
        pub mPadding: root::nsStyleSides,
    }
    #[test]
    fn bindgen_test_layout_nsStylePadding() {
        assert_eq!(::std::mem::size_of::<nsStylePadding>() , 40usize , concat
                   ! ( "Size of: " , stringify ! ( nsStylePadding ) ));
        assert_eq! (::std::mem::align_of::<nsStylePadding>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStylePadding ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePadding ) ) . mPadding as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePadding ) ,
                    "::" , stringify ! ( mPadding ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsBorderColors {
        pub mNext: *mut root::nsBorderColors,
        pub mColor: root::nscolor,
    }
    #[test]
    fn bindgen_test_layout_nsBorderColors() {
        assert_eq!(::std::mem::size_of::<nsBorderColors>() , 16usize , concat
                   ! ( "Size of: " , stringify ! ( nsBorderColors ) ));
        assert_eq! (::std::mem::align_of::<nsBorderColors>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsBorderColors ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsBorderColors ) ) . mNext as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsBorderColors ) ,
                    "::" , stringify ! ( mNext ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsBorderColors ) ) . mColor as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsBorderColors ) ,
                    "::" , stringify ! ( mColor ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSShadowItem {
        pub mXOffset: root::nscoord,
        pub mYOffset: root::nscoord,
        pub mRadius: root::nscoord,
        pub mSpread: root::nscoord,
        pub mColor: root::nscolor,
        pub mHasColor: bool,
        pub mInset: bool,
    }
    #[test]
    fn bindgen_test_layout_nsCSSShadowItem() {
        assert_eq!(::std::mem::size_of::<nsCSSShadowItem>() , 24usize , concat
                   ! ( "Size of: " , stringify ! ( nsCSSShadowItem ) ));
        assert_eq! (::std::mem::align_of::<nsCSSShadowItem>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSShadowItem ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowItem ) ) . mXOffset as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowItem ) ,
                    "::" , stringify ! ( mXOffset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowItem ) ) . mYOffset as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowItem ) ,
                    "::" , stringify ! ( mYOffset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowItem ) ) . mRadius as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowItem ) ,
                    "::" , stringify ! ( mRadius ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowItem ) ) . mSpread as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowItem ) ,
                    "::" , stringify ! ( mSpread ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowItem ) ) . mColor as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowItem ) ,
                    "::" , stringify ! ( mColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowItem ) ) . mHasColor as *
                    const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowItem ) ,
                    "::" , stringify ! ( mHasColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowItem ) ) . mInset as *
                    const _ as usize } , 21usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowItem ) ,
                    "::" , stringify ! ( mInset ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSShadowArray {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mLength: u32,
        pub mArray: [root::nsCSSShadowItem; 1usize],
    }
    pub type nsCSSShadowArray_HasThreadSafeRefCnt = root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsCSSShadowArray() {
        assert_eq!(::std::mem::size_of::<nsCSSShadowArray>() , 40usize ,
                   concat ! ( "Size of: " , stringify ! ( nsCSSShadowArray )
                   ));
        assert_eq! (::std::mem::align_of::<nsCSSShadowArray>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsCSSShadowArray ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowArray ) ) . mRefCnt as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowArray )
                    , "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowArray ) ) . mLength as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowArray )
                    , "::" , stringify ! ( mLength ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCSSShadowArray ) ) . mArray as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCSSShadowArray )
                    , "::" , stringify ! ( mArray ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleBorder {
        pub mBorderColors: *mut *mut root::nsBorderColors,
        pub mBorderRadius: root::nsStyleCorners,
        pub mBorderImageSource: root::nsStyleImage,
        pub mBorderImageSlice: root::nsStyleSides,
        pub mBorderImageWidth: root::nsStyleSides,
        pub mBorderImageOutset: root::nsStyleSides,
        pub mBorderImageFill: u8,
        pub mBorderImageRepeatH: u8,
        pub mBorderImageRepeatV: u8,
        pub mFloatEdge: root::mozilla::StyleFloatEdge,
        pub mBoxDecorationBreak: root::mozilla::StyleBoxDecorationBreak,
        pub mBorderStyle: [u8; 4usize],
        pub __bindgen_anon_1: root::nsStyleBorder__bindgen_ty_1,
        pub mComputedBorder: root::nsMargin,
        pub mBorder: root::nsMargin,
        pub mTwipsPerPixel: root::nscoord,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleBorder__bindgen_ty_1 {
        pub __bindgen_anon_1: root::__BindgenUnionField<root::nsStyleBorder__bindgen_ty_1__bindgen_ty_1>,
        pub mBorderColor: root::__BindgenUnionField<[root::mozilla::StyleComplexColor; 4usize]>,
        pub bindgen_union_field: [u32; 8usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleBorder__bindgen_ty_1__bindgen_ty_1 {
        pub mBorderTopColor: root::mozilla::StyleComplexColor,
        pub mBorderRightColor: root::mozilla::StyleComplexColor,
        pub mBorderBottomColor: root::mozilla::StyleComplexColor,
        pub mBorderLeftColor: root::mozilla::StyleComplexColor,
    }
    #[test]
    fn bindgen_test_layout_nsStyleBorder__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleBorder__bindgen_ty_1__bindgen_ty_1>()
                   , 32usize , concat ! (
                   "Size of: " , stringify ! (
                   nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) ));
        assert_eq! (::std::mem::align_of::<nsStyleBorder__bindgen_ty_1__bindgen_ty_1>()
                    , 4usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsStyleBorder__bindgen_ty_1__bindgen_ty_1
                    ) ) . mBorderTopColor as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mBorderTopColor ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsStyleBorder__bindgen_ty_1__bindgen_ty_1
                    ) ) . mBorderRightColor as * const _ as usize } , 8usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mBorderRightColor ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsStyleBorder__bindgen_ty_1__bindgen_ty_1
                    ) ) . mBorderBottomColor as * const _ as usize } , 16usize
                    , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mBorderBottomColor ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsStyleBorder__bindgen_ty_1__bindgen_ty_1
                    ) ) . mBorderLeftColor as * const _ as usize } , 24usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleBorder__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mBorderLeftColor ) ));
    }
    impl Clone for nsStyleBorder__bindgen_ty_1__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsStyleBorder__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleBorder__bindgen_ty_1>() ,
                   32usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleBorder__bindgen_ty_1 )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleBorder__bindgen_ty_1>() ,
                    4usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsStyleBorder__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder__bindgen_ty_1 ) ) .
                    mBorderColor as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleBorder__bindgen_ty_1 ) , "::" , stringify ! (
                    mBorderColor ) ));
    }
    impl Clone for nsStyleBorder__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsStyleBorder() {
        assert_eq!(::std::mem::size_of::<nsStyleBorder>() , 312usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleBorder ) ));
        assert_eq! (::std::mem::align_of::<nsStyleBorder>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleBorder ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mBorderColors as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderColors ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mBorderRadius as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderRadius ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) .
                    mBorderImageSource as * const _ as usize } , 80usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderImageSource ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mBorderImageSlice
                    as * const _ as usize } , 112usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderImageSlice ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mBorderImageWidth
                    as * const _ as usize } , 152usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderImageWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) .
                    mBorderImageOutset as * const _ as usize } , 192usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderImageOutset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mBorderImageFill
                    as * const _ as usize } , 232usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderImageFill ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) .
                    mBorderImageRepeatH as * const _ as usize } , 233usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderImageRepeatH ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) .
                    mBorderImageRepeatV as * const _ as usize } , 234usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderImageRepeatV ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mFloatEdge as *
                    const _ as usize } , 235usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mFloatEdge ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) .
                    mBoxDecorationBreak as * const _ as usize } , 236usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBoxDecorationBreak ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mBorderStyle as *
                    const _ as usize } , 237usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorderStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mComputedBorder
                    as * const _ as usize } , 276usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mComputedBorder ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mBorder as *
                    const _ as usize } , 292usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mBorder ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleBorder ) ) . mTwipsPerPixel as
                    * const _ as usize } , 308usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleBorder ) ,
                    "::" , stringify ! ( mTwipsPerPixel ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleOutline {
        pub mOutlineRadius: root::nsStyleCorners,
        pub mOutlineWidth: root::nscoord,
        pub mOutlineOffset: root::nscoord,
        pub mOutlineColor: root::mozilla::StyleComplexColor,
        pub mOutlineStyle: u8,
        pub mActualOutlineWidth: root::nscoord,
        pub mTwipsPerPixel: root::nscoord,
    }
    #[test]
    fn bindgen_test_layout_nsStyleOutline() {
        assert_eq!(::std::mem::size_of::<nsStyleOutline>() , 104usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleOutline ) ));
        assert_eq! (::std::mem::align_of::<nsStyleOutline>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleOutline ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleOutline ) ) . mOutlineRadius
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleOutline ) ,
                    "::" , stringify ! ( mOutlineRadius ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleOutline ) ) . mOutlineWidth as
                    * const _ as usize } , 72usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleOutline ) ,
                    "::" , stringify ! ( mOutlineWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleOutline ) ) . mOutlineOffset
                    as * const _ as usize } , 76usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleOutline ) ,
                    "::" , stringify ! ( mOutlineOffset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleOutline ) ) . mOutlineColor as
                    * const _ as usize } , 80usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleOutline ) ,
                    "::" , stringify ! ( mOutlineColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleOutline ) ) . mOutlineStyle as
                    * const _ as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleOutline ) ,
                    "::" , stringify ! ( mOutlineStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleOutline ) ) .
                    mActualOutlineWidth as * const _ as usize } , 92usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleOutline ) ,
                    "::" , stringify ! ( mActualOutlineWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleOutline ) ) . mTwipsPerPixel
                    as * const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleOutline ) ,
                    "::" , stringify ! ( mTwipsPerPixel ) ));
    }
    /**
 * An object that allows sharing of arrays that store 'quotes' property
 * values.  This is particularly important for inheritance, where we want
 * to share the same 'quotes' value with a parent style context.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleQuoteValues {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mQuotePairs: root::nsStyleQuoteValues_QuotePairArray,
    }
    pub type nsStyleQuoteValues_QuotePairArray =
        root::nsTArray<root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr>>;
    pub type nsStyleQuoteValues_HasThreadSafeRefCnt = root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsStyleQuoteValues() {
        assert_eq!(::std::mem::size_of::<nsStyleQuoteValues>() , 16usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleQuoteValues )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleQuoteValues>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleQuoteValues ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleQuoteValues ) ) . mRefCnt as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleQuoteValues
                    ) , "::" , stringify ! ( mRefCnt ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleQuoteValues ) ) . mQuotePairs
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleQuoteValues
                    ) , "::" , stringify ! ( mQuotePairs ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_5() {
        assert_eq!(::std::mem::size_of::<root::mozilla::StaticRefPtr<root::nsStyleQuoteValues>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::StaticRefPtr<root::nsStyleQuoteValues> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::StaticRefPtr<root::nsStyleQuoteValues>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::StaticRefPtr<root::nsStyleQuoteValues> ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleList {
        pub mListStylePosition: u8,
        pub mListStyleImage: root::RefPtr<root::nsStyleImageRequest>,
        pub mCounterStyle: root::RefPtr<root::mozilla::CounterStyle>,
        pub mQuotes: root::RefPtr<root::nsStyleQuoteValues>,
        pub mImageRegion: root::nsRect,
    }
    extern "C" {
        #[link_name = "_ZN11nsStyleList14sInitialQuotesE"]
        pub static mut nsStyleList_sInitialQuotes:
                   root::mozilla::StaticRefPtr<root::nsStyleQuoteValues>;
    }
    extern "C" {
        #[link_name = "_ZN11nsStyleList11sNoneQuotesE"]
        pub static mut nsStyleList_sNoneQuotes:
                   root::mozilla::StaticRefPtr<root::nsStyleQuoteValues>;
    }
    #[test]
    fn bindgen_test_layout_nsStyleList() {
        assert_eq!(::std::mem::size_of::<nsStyleList>() , 48usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleList ) ));
        assert_eq! (::std::mem::align_of::<nsStyleList>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleList ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleList ) ) . mListStylePosition
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleList ) ,
                    "::" , stringify ! ( mListStylePosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleList ) ) . mListStyleImage as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleList ) ,
                    "::" , stringify ! ( mListStyleImage ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleList ) ) . mCounterStyle as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleList ) ,
                    "::" , stringify ! ( mCounterStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleList ) ) . mQuotes as * const
                    _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleList ) ,
                    "::" , stringify ! ( mQuotes ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleList ) ) . mImageRegion as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleList ) ,
                    "::" , stringify ! ( mImageRegion ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleGridLine {
        pub mHasSpan: bool,
        pub mInteger: i32,
        pub mLineName: ::nsstring::nsStringRepr,
    }
    pub const nsStyleGridLine_kMinLine: i32 = -10000;
    pub const nsStyleGridLine_kMaxLine: i32 = 10000;
    #[test]
    fn bindgen_test_layout_nsStyleGridLine() {
        assert_eq!(::std::mem::size_of::<nsStyleGridLine>() , 24usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleGridLine ) ));
        assert_eq! (::std::mem::align_of::<nsStyleGridLine>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleGridLine ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridLine ) ) . mHasSpan as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridLine ) ,
                    "::" , stringify ! ( mHasSpan ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridLine ) ) . mInteger as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridLine ) ,
                    "::" , stringify ! ( mInteger ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridLine ) ) . mLineName as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridLine ) ,
                    "::" , stringify ! ( mLineName ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleGridTemplate {
        pub mLineNameLists: root::nsTArray<root::nsTArray<::nsstring::nsStringRepr>>,
        pub mMinTrackSizingFunctions: root::nsTArray<root::nsStyleCoord>,
        pub mMaxTrackSizingFunctions: root::nsTArray<root::nsStyleCoord>,
        pub mRepeatAutoLineNameListBefore: root::nsTArray<::nsstring::nsStringRepr>,
        pub mRepeatAutoLineNameListAfter: root::nsTArray<::nsstring::nsStringRepr>,
        pub mRepeatAutoIndex: i16,
        pub _bitfield_1: u8,
        pub __bindgen_padding_0: [u8; 5usize],
    }
    #[test]
    fn bindgen_test_layout_nsStyleGridTemplate() {
        assert_eq!(::std::mem::size_of::<nsStyleGridTemplate>() , 48usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsStyleGridTemplate ) ));
        assert_eq! (::std::mem::align_of::<nsStyleGridTemplate>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleGridTemplate ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridTemplate ) ) .
                    mLineNameLists as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! ( nsStyleGridTemplate
                    ) , "::" , stringify ! ( mLineNameLists ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridTemplate ) ) .
                    mMinTrackSizingFunctions as * const _ as usize } , 8usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridTemplate
                    ) , "::" , stringify ! ( mMinTrackSizingFunctions ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridTemplate ) ) .
                    mMaxTrackSizingFunctions as * const _ as usize } , 16usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridTemplate
                    ) , "::" , stringify ! ( mMaxTrackSizingFunctions ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridTemplate ) ) .
                    mRepeatAutoLineNameListBefore as * const _ as usize } ,
                    24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridTemplate
                    ) , "::" , stringify ! ( mRepeatAutoLineNameListBefore )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridTemplate ) ) .
                    mRepeatAutoLineNameListAfter as * const _ as usize } ,
                    32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridTemplate
                    ) , "::" , stringify ! ( mRepeatAutoLineNameListAfter )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleGridTemplate ) ) .
                    mRepeatAutoIndex as * const _ as usize } , 40usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleGridTemplate
                    ) , "::" , stringify ! ( mRepeatAutoIndex ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStylePosition {
        pub mObjectPosition: root::mozilla::Position,
        pub mOffset: root::nsStyleSides,
        pub mWidth: root::nsStyleCoord,
        pub mMinWidth: root::nsStyleCoord,
        pub mMaxWidth: root::nsStyleCoord,
        pub mHeight: root::nsStyleCoord,
        pub mMinHeight: root::nsStyleCoord,
        pub mMaxHeight: root::nsStyleCoord,
        pub mFlexBasis: root::nsStyleCoord,
        pub mGridAutoColumnsMin: root::nsStyleCoord,
        pub mGridAutoColumnsMax: root::nsStyleCoord,
        pub mGridAutoRowsMin: root::nsStyleCoord,
        pub mGridAutoRowsMax: root::nsStyleCoord,
        pub mGridAutoFlow: u8,
        pub mBoxSizing: root::mozilla::StyleBoxSizing,
        pub mAlignContent: u16,
        pub mAlignItems: u8,
        pub mAlignSelf: u8,
        pub mJustifyContent: u16,
        pub mJustifyItems: u8,
        pub mJustifySelf: u8,
        pub mFlexDirection: u8,
        pub mFlexWrap: u8,
        pub mObjectFit: u8,
        pub mOrder: i32,
        pub mFlexGrow: f32,
        pub mFlexShrink: f32,
        pub mZIndex: root::nsStyleCoord,
        pub mGridTemplateColumns: root::nsStyleGridTemplate,
        pub mGridTemplateRows: root::nsStyleGridTemplate,
        pub mGridTemplateAreas: root::RefPtr<root::mozilla::css::GridTemplateAreasValue>,
        pub mGridColumnStart: root::nsStyleGridLine,
        pub mGridColumnEnd: root::nsStyleGridLine,
        pub mGridRowStart: root::nsStyleGridLine,
        pub mGridRowEnd: root::nsStyleGridLine,
        pub mGridColumnGap: root::nsStyleCoord,
        pub mGridRowGap: root::nsStyleCoord,
    }
    #[test]
    fn bindgen_test_layout_nsStylePosition() {
        assert_eq!(::std::mem::size_of::<nsStylePosition>() , 520usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStylePosition )
                   ));
        assert_eq! (::std::mem::align_of::<nsStylePosition>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStylePosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mObjectPosition
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mObjectPosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mOffset as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mOffset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mWidth as *
                    const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mMinWidth as *
                    const _ as usize } , 80usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mMinWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mMaxWidth as *
                    const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mMaxWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mHeight as *
                    const _ as usize } , 112usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mHeight ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mMinHeight as *
                    const _ as usize } , 128usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mMinHeight ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mMaxHeight as *
                    const _ as usize } , 144usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mMaxHeight ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mFlexBasis as *
                    const _ as usize } , 160usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mFlexBasis ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridAutoColumnsMin as * const _ as usize } , 176usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridAutoColumnsMin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridAutoColumnsMax as * const _ as usize } , 192usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridAutoColumnsMax ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridAutoRowsMin as * const _ as usize } , 208usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridAutoRowsMin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridAutoRowsMax as * const _ as usize } , 224usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridAutoRowsMax ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mGridAutoFlow
                    as * const _ as usize } , 240usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridAutoFlow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mBoxSizing as *
                    const _ as usize } , 241usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mBoxSizing ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mAlignContent
                    as * const _ as usize } , 242usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mAlignContent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mAlignItems as
                    * const _ as usize } , 244usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mAlignItems ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mAlignSelf as *
                    const _ as usize } , 245usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mAlignSelf ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mJustifyContent
                    as * const _ as usize } , 246usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mJustifyContent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mJustifyItems
                    as * const _ as usize } , 248usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mJustifyItems ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mJustifySelf as
                    * const _ as usize } , 249usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mJustifySelf ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mFlexDirection
                    as * const _ as usize } , 250usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mFlexDirection ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mFlexWrap as *
                    const _ as usize } , 251usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mFlexWrap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mObjectFit as *
                    const _ as usize } , 252usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mObjectFit ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mOrder as *
                    const _ as usize } , 256usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mOrder ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mFlexGrow as *
                    const _ as usize } , 260usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mFlexGrow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mFlexShrink as
                    * const _ as usize } , 264usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mFlexShrink ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mZIndex as *
                    const _ as usize } , 272usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mZIndex ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridTemplateColumns as * const _ as usize } , 288usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridTemplateColumns ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridTemplateRows as * const _ as usize } , 336usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridTemplateRows ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridTemplateAreas as * const _ as usize } , 384usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridTemplateAreas ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) .
                    mGridColumnStart as * const _ as usize } , 392usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridColumnStart ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mGridColumnEnd
                    as * const _ as usize } , 416usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridColumnEnd ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mGridRowStart
                    as * const _ as usize } , 440usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridRowStart ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mGridRowEnd as
                    * const _ as usize } , 464usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridRowEnd ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mGridColumnGap
                    as * const _ as usize } , 488usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridColumnGap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStylePosition ) ) . mGridRowGap as
                    * const _ as usize } , 504usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStylePosition ) ,
                    "::" , stringify ! ( mGridRowGap ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleTextOverflowSide {
        pub mString: ::nsstring::nsStringRepr,
        pub mType: u8,
    }
    #[test]
    fn bindgen_test_layout_nsStyleTextOverflowSide() {
        assert_eq!(::std::mem::size_of::<nsStyleTextOverflowSide>() , 24usize
                   , concat ! (
                   "Size of: " , stringify ! ( nsStyleTextOverflowSide ) ));
        assert_eq! (::std::mem::align_of::<nsStyleTextOverflowSide>() , 8usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsStyleTextOverflowSide )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextOverflowSide ) ) . mString
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleTextOverflowSide ) , "::" , stringify ! ( mString )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextOverflowSide ) ) . mType
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleTextOverflowSide ) , "::" , stringify ! ( mType )
                    ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleTextOverflow {
        pub mLeft: root::nsStyleTextOverflowSide,
        pub mRight: root::nsStyleTextOverflowSide,
        pub mLogicalDirections: bool,
    }
    #[test]
    fn bindgen_test_layout_nsStyleTextOverflow() {
        assert_eq!(::std::mem::size_of::<nsStyleTextOverflow>() , 56usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsStyleTextOverflow ) ));
        assert_eq! (::std::mem::align_of::<nsStyleTextOverflow>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleTextOverflow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextOverflow ) ) . mLeft as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextOverflow
                    ) , "::" , stringify ! ( mLeft ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextOverflow ) ) . mRight as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextOverflow
                    ) , "::" , stringify ! ( mRight ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextOverflow ) ) .
                    mLogicalDirections as * const _ as usize } , 48usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextOverflow
                    ) , "::" , stringify ! ( mLogicalDirections ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleTextReset {
        pub mTextOverflow: root::nsStyleTextOverflow,
        pub mTextDecorationLine: u8,
        pub mTextDecorationStyle: u8,
        pub mUnicodeBidi: u8,
        pub mInitialLetterSink: root::nscoord,
        pub mInitialLetterSize: f32,
        pub mTextDecorationColor: root::mozilla::StyleComplexColor,
    }
    #[test]
    fn bindgen_test_layout_nsStyleTextReset() {
        assert_eq!(::std::mem::size_of::<nsStyleTextReset>() , 80usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleTextReset )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleTextReset>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleTextReset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextReset ) ) . mTextOverflow
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextReset )
                    , "::" , stringify ! ( mTextOverflow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextReset ) ) .
                    mTextDecorationLine as * const _ as usize } , 56usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextReset )
                    , "::" , stringify ! ( mTextDecorationLine ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextReset ) ) .
                    mTextDecorationStyle as * const _ as usize } , 57usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextReset )
                    , "::" , stringify ! ( mTextDecorationStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextReset ) ) . mUnicodeBidi
                    as * const _ as usize } , 58usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextReset )
                    , "::" , stringify ! ( mUnicodeBidi ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextReset ) ) .
                    mInitialLetterSink as * const _ as usize } , 60usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextReset )
                    , "::" , stringify ! ( mInitialLetterSink ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextReset ) ) .
                    mInitialLetterSize as * const _ as usize } , 64usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextReset )
                    , "::" , stringify ! ( mInitialLetterSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTextReset ) ) .
                    mTextDecorationColor as * const _ as usize } , 68usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTextReset )
                    , "::" , stringify ! ( mTextDecorationColor ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleText {
        pub mTextAlign: u8,
        pub mTextAlignLast: u8,
        pub _bitfield_1: u8,
        pub mTextTransform: u8,
        pub mWhiteSpace: u8,
        pub mWordBreak: u8,
        pub mOverflowWrap: u8,
        pub mHyphens: root::mozilla::StyleHyphens,
        pub mRubyAlign: u8,
        pub mRubyPosition: u8,
        pub mTextSizeAdjust: u8,
        pub mTextCombineUpright: u8,
        pub mControlCharacterVisibility: u8,
        pub mTextEmphasisPosition: u8,
        pub mTextEmphasisStyle: u8,
        pub mTextRendering: u8,
        pub mTextEmphasisColor: root::mozilla::StyleComplexColor,
        pub mWebkitTextFillColor: root::mozilla::StyleComplexColor,
        pub mWebkitTextStrokeColor: root::mozilla::StyleComplexColor,
        pub mTabSize: root::nsStyleCoord,
        pub mWordSpacing: root::nsStyleCoord,
        pub mLetterSpacing: root::nsStyleCoord,
        pub mLineHeight: root::nsStyleCoord,
        pub mTextIndent: root::nsStyleCoord,
        pub mWebkitTextStrokeWidth: root::nscoord,
        pub mTextShadow: root::RefPtr<root::nsCSSShadowArray>,
        pub mTextEmphasisStyleString: ::nsstring::nsStringRepr,
    }
    #[test]
    fn bindgen_test_layout_nsStyleText() {
        assert_eq!(::std::mem::size_of::<nsStyleText>() , 152usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleText ) ));
        assert_eq! (::std::mem::align_of::<nsStyleText>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleText ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextAlign as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextAlign ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextAlignLast as *
                    const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextAlignLast ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextTransform as *
                    const _ as usize } , 3usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextTransform ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mWhiteSpace as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mWhiteSpace ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mWordBreak as *
                    const _ as usize } , 5usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mWordBreak ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mOverflowWrap as *
                    const _ as usize } , 6usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mOverflowWrap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mHyphens as * const
                    _ as usize } , 7usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mHyphens ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mRubyAlign as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mRubyAlign ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mRubyPosition as *
                    const _ as usize } , 9usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mRubyPosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextSizeAdjust as
                    * const _ as usize } , 10usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextSizeAdjust ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextCombineUpright
                    as * const _ as usize } , 11usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextCombineUpright ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) .
                    mControlCharacterVisibility as * const _ as usize } ,
                    12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mControlCharacterVisibility ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) .
                    mTextEmphasisPosition as * const _ as usize } , 13usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextEmphasisPosition ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextEmphasisStyle
                    as * const _ as usize } , 14usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextEmphasisStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextRendering as *
                    const _ as usize } , 15usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextRendering ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextEmphasisColor
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextEmphasisColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) .
                    mWebkitTextFillColor as * const _ as usize } , 24usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mWebkitTextFillColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) .
                    mWebkitTextStrokeColor as * const _ as usize } , 32usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mWebkitTextStrokeColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTabSize as * const
                    _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTabSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mWordSpacing as *
                    const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mWordSpacing ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mLetterSpacing as *
                    const _ as usize } , 72usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mLetterSpacing ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mLineHeight as *
                    const _ as usize } , 88usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mLineHeight ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextIndent as *
                    const _ as usize } , 104usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextIndent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) .
                    mWebkitTextStrokeWidth as * const _ as usize } , 120usize
                    , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mWebkitTextStrokeWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) . mTextShadow as *
                    const _ as usize } , 128usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextShadow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleText ) ) .
                    mTextEmphasisStyleString as * const _ as usize } ,
                    136usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleText ) ,
                    "::" , stringify ! ( mTextEmphasisStyleString ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleImageOrientation {
        pub mOrientation: u8,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageOrientation_Bits {
        ORIENTATION_MASK = 3,
        FLIP_MASK = 4,
        FROM_IMAGE_MASK = 8,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageOrientation_Angles {
        ANGLE_0 = 0,
        ANGLE_90 = 1,
        ANGLE_180 = 2,
        ANGLE_270 = 3,
    }
    #[test]
    fn bindgen_test_layout_nsStyleImageOrientation() {
        assert_eq!(::std::mem::size_of::<nsStyleImageOrientation>() , 1usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsStyleImageOrientation ) ));
        assert_eq! (::std::mem::align_of::<nsStyleImageOrientation>() , 1usize
                    , concat ! (
                    "Alignment of " , stringify ! ( nsStyleImageOrientation )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleImageOrientation ) ) .
                    mOrientation as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleImageOrientation ) , "::" , stringify ! (
                    mOrientation ) ));
    }
    impl Clone for nsStyleImageOrientation {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTimingFunction {
        pub mType: root::nsTimingFunction_Type,
        pub __bindgen_anon_1: root::nsTimingFunction__bindgen_ty_1,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsTimingFunction_Type {
        Ease = 0,
        Linear = 1,
        EaseIn = 2,
        EaseOut = 3,
        EaseInOut = 4,
        StepStart = 5,
        StepEnd = 6,
        CubicBezier = 7,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsTimingFunction_Keyword { Implicit = 0, Explicit = 1, }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTimingFunction__bindgen_ty_1 {
        pub mFunc: root::__BindgenUnionField<root::nsTimingFunction__bindgen_ty_1__bindgen_ty_1>,
        pub __bindgen_anon_1: root::__BindgenUnionField<root::nsTimingFunction__bindgen_ty_1__bindgen_ty_2>,
        pub bindgen_union_field: [u32; 4usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTimingFunction__bindgen_ty_1__bindgen_ty_1 {
        pub mX1: f32,
        pub mY1: f32,
        pub mX2: f32,
        pub mY2: f32,
    }
    #[test]
    fn bindgen_test_layout_nsTimingFunction__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsTimingFunction__bindgen_ty_1__bindgen_ty_1>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) ));
        assert_eq! (::std::mem::align_of::<nsTimingFunction__bindgen_ty_1__bindgen_ty_1>()
                    , 4usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsTimingFunction__bindgen_ty_1__bindgen_ty_1
                    ) ) . mX1 as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mX1 ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsTimingFunction__bindgen_ty_1__bindgen_ty_1
                    ) ) . mY1 as * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mY1 ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsTimingFunction__bindgen_ty_1__bindgen_ty_1
                    ) ) . mX2 as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mX2 ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsTimingFunction__bindgen_ty_1__bindgen_ty_1
                    ) ) . mY2 as * const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTimingFunction__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                    stringify ! ( mY2 ) ));
    }
    impl Clone for nsTimingFunction__bindgen_ty_1__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTimingFunction__bindgen_ty_1__bindgen_ty_2 {
        pub mSteps: u32,
    }
    #[test]
    fn bindgen_test_layout_nsTimingFunction__bindgen_ty_1__bindgen_ty_2() {
        assert_eq!(::std::mem::size_of::<nsTimingFunction__bindgen_ty_1__bindgen_ty_2>()
                   , 4usize , concat ! (
                   "Size of: " , stringify ! (
                   nsTimingFunction__bindgen_ty_1__bindgen_ty_2 ) ));
        assert_eq! (::std::mem::align_of::<nsTimingFunction__bindgen_ty_1__bindgen_ty_2>()
                    , 4usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsTimingFunction__bindgen_ty_1__bindgen_ty_2 ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsTimingFunction__bindgen_ty_1__bindgen_ty_2
                    ) ) . mSteps as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTimingFunction__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                    stringify ! ( mSteps ) ));
    }
    impl Clone for nsTimingFunction__bindgen_ty_1__bindgen_ty_2 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsTimingFunction__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsTimingFunction__bindgen_ty_1>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( nsTimingFunction__bindgen_ty_1
                   ) ));
        assert_eq! (::std::mem::align_of::<nsTimingFunction__bindgen_ty_1>() ,
                    4usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsTimingFunction__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsTimingFunction__bindgen_ty_1 ) ) .
                    mFunc as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsTimingFunction__bindgen_ty_1 ) , "::" , stringify ! (
                    mFunc ) ));
    }
    impl Clone for nsTimingFunction__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsTimingFunction() {
        assert_eq!(::std::mem::size_of::<nsTimingFunction>() , 20usize ,
                   concat ! ( "Size of: " , stringify ! ( nsTimingFunction )
                   ));
        assert_eq! (::std::mem::align_of::<nsTimingFunction>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsTimingFunction ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsTimingFunction ) ) . mType as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsTimingFunction )
                    , "::" , stringify ! ( mType ) ));
    }
    impl Clone for nsTimingFunction {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleTable {
        pub mLayoutStrategy: u8,
        pub mSpan: i32,
    }
    #[test]
    fn bindgen_test_layout_nsStyleTable() {
        assert_eq!(::std::mem::size_of::<nsStyleTable>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleTable ) ));
        assert_eq! (::std::mem::align_of::<nsStyleTable>() , 4usize , concat !
                    ( "Alignment of " , stringify ! ( nsStyleTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTable ) ) . mLayoutStrategy as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTable ) ,
                    "::" , stringify ! ( mLayoutStrategy ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTable ) ) . mSpan as * const _
                    as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTable ) ,
                    "::" , stringify ! ( mSpan ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleTableBorder {
        pub mBorderSpacingCol: root::nscoord,
        pub mBorderSpacingRow: root::nscoord,
        pub mBorderCollapse: u8,
        pub mCaptionSide: u8,
        pub mEmptyCells: u8,
    }
    #[test]
    fn bindgen_test_layout_nsStyleTableBorder() {
        assert_eq!(::std::mem::size_of::<nsStyleTableBorder>() , 12usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleTableBorder )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleTableBorder>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleTableBorder ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTableBorder ) ) .
                    mBorderSpacingCol as * const _ as usize } , 0usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTableBorder
                    ) , "::" , stringify ! ( mBorderSpacingCol ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTableBorder ) ) .
                    mBorderSpacingRow as * const _ as usize } , 4usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTableBorder
                    ) , "::" , stringify ! ( mBorderSpacingRow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTableBorder ) ) .
                    mBorderCollapse as * const _ as usize } , 8usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( nsStyleTableBorder
                    ) , "::" , stringify ! ( mBorderCollapse ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTableBorder ) ) . mCaptionSide
                    as * const _ as usize } , 9usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTableBorder
                    ) , "::" , stringify ! ( mCaptionSide ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleTableBorder ) ) . mEmptyCells
                    as * const _ as usize } , 10usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleTableBorder
                    ) , "::" , stringify ! ( mEmptyCells ) ));
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleContentType {
        eStyleContentType_String = 1,
        eStyleContentType_Image = 10,
        eStyleContentType_Attr = 20,
        eStyleContentType_Counter = 30,
        eStyleContentType_Counters = 31,
        eStyleContentType_OpenQuote = 40,
        eStyleContentType_CloseQuote = 41,
        eStyleContentType_NoOpenQuote = 42,
        eStyleContentType_NoCloseQuote = 43,
        eStyleContentType_AltContent = 50,
        eStyleContentType_Uninitialized = 51,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleContentData {
        pub mType: root::nsStyleContentType,
        pub mContent: root::nsStyleContentData__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleContentData__bindgen_ty_1 {
        pub mString: root::__BindgenUnionField<*mut u16>,
        pub mImage: root::__BindgenUnionField<*mut root::nsStyleImageRequest>,
        pub mCounters: root::__BindgenUnionField<*mut root::nsCSSValue_Array>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsStyleContentData__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleContentData__bindgen_ty_1>() ,
                   8usize , concat ! (
                   "Size of: " , stringify ! (
                   nsStyleContentData__bindgen_ty_1 ) ));
        assert_eq! (::std::mem::align_of::<nsStyleContentData__bindgen_ty_1>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsStyleContentData__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData__bindgen_ty_1 ) )
                    . mString as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleContentData__bindgen_ty_1 ) , "::" , stringify ! (
                    mString ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData__bindgen_ty_1 ) )
                    . mImage as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleContentData__bindgen_ty_1 ) , "::" , stringify ! (
                    mImage ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData__bindgen_ty_1 ) )
                    . mCounters as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleContentData__bindgen_ty_1 ) , "::" , stringify ! (
                    mCounters ) ));
    }
    impl Clone for nsStyleContentData__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsStyleContentData() {
        assert_eq!(::std::mem::size_of::<nsStyleContentData>() , 16usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleContentData )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleContentData>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleContentData ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData ) ) . mType as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleContentData
                    ) , "::" , stringify ! ( mType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContentData ) ) . mContent as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleContentData
                    ) , "::" , stringify ! ( mContent ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleCounterData {
        pub mCounter: ::nsstring::nsStringRepr,
        pub mValue: i32,
    }
    #[test]
    fn bindgen_test_layout_nsStyleCounterData() {
        assert_eq!(::std::mem::size_of::<nsStyleCounterData>() , 24usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleCounterData )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleCounterData>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleCounterData ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCounterData ) ) . mCounter as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleCounterData
                    ) , "::" , stringify ! ( mCounter ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleCounterData ) ) . mValue as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleCounterData
                    ) , "::" , stringify ! ( mValue ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleContent {
        pub mContents: root::nsTArray<root::nsStyleContentData>,
        pub mIncrements: root::nsTArray<root::nsStyleCounterData>,
        pub mResets: root::nsTArray<root::nsStyleCounterData>,
    }
    #[test]
    fn bindgen_test_layout_nsStyleContent() {
        assert_eq!(::std::mem::size_of::<nsStyleContent>() , 24usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleContent ) ));
        assert_eq! (::std::mem::align_of::<nsStyleContent>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleContent ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContent ) ) . mContents as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleContent ) ,
                    "::" , stringify ! ( mContents ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContent ) ) . mIncrements as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleContent ) ,
                    "::" , stringify ! ( mIncrements ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleContent ) ) . mResets as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleContent ) ,
                    "::" , stringify ! ( mResets ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleUIReset {
        pub mUserSelect: root::mozilla::StyleUserSelect,
        pub mForceBrokenImageIcon: u8,
        pub mIMEMode: u8,
        pub mWindowDragging: root::mozilla::StyleWindowDragging,
        pub mWindowShadow: u8,
    }
    #[test]
    fn bindgen_test_layout_nsStyleUIReset() {
        assert_eq!(::std::mem::size_of::<nsStyleUIReset>() , 5usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleUIReset ) ));
        assert_eq! (::std::mem::align_of::<nsStyleUIReset>() , 1usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleUIReset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUIReset ) ) . mUserSelect as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUIReset ) ,
                    "::" , stringify ! ( mUserSelect ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUIReset ) ) .
                    mForceBrokenImageIcon as * const _ as usize } , 1usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUIReset ) ,
                    "::" , stringify ! ( mForceBrokenImageIcon ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUIReset ) ) . mIMEMode as *
                    const _ as usize } , 2usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUIReset ) ,
                    "::" , stringify ! ( mIMEMode ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUIReset ) ) . mWindowDragging
                    as * const _ as usize } , 3usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUIReset ) ,
                    "::" , stringify ! ( mWindowDragging ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUIReset ) ) . mWindowShadow as
                    * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleUIReset ) ,
                    "::" , stringify ! ( mWindowShadow ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCursorImage {
        pub mHaveHotspot: bool,
        pub mHotspotX: f32,
        pub mHotspotY: f32,
        pub mImage: root::RefPtr<root::nsStyleImageRequest>,
    }
    #[test]
    fn bindgen_test_layout_nsCursorImage() {
        assert_eq!(::std::mem::size_of::<nsCursorImage>() , 24usize , concat !
                   ( "Size of: " , stringify ! ( nsCursorImage ) ));
        assert_eq! (::std::mem::align_of::<nsCursorImage>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsCursorImage ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCursorImage ) ) . mHaveHotspot as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCursorImage ) ,
                    "::" , stringify ! ( mHaveHotspot ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCursorImage ) ) . mHotspotX as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCursorImage ) ,
                    "::" , stringify ! ( mHotspotX ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCursorImage ) ) . mHotspotY as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCursorImage ) ,
                    "::" , stringify ! ( mHotspotY ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsCursorImage ) ) . mImage as * const
                    _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsCursorImage ) ,
                    "::" , stringify ! ( mImage ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleUserInterface {
        pub mUserInput: root::mozilla::StyleUserInput,
        pub mUserModify: root::mozilla::StyleUserModify,
        pub mUserFocus: root::mozilla::StyleUserFocus,
        pub mPointerEvents: u8,
        pub mCursor: u8,
        pub mCursorImages: root::nsTArray<root::nsCursorImage>,
        pub mCaretColor: root::mozilla::StyleComplexColor,
    }
    #[test]
    fn bindgen_test_layout_nsStyleUserInterface() {
        assert_eq!(::std::mem::size_of::<nsStyleUserInterface>() , 24usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsStyleUserInterface ) ));
        assert_eq! (::std::mem::align_of::<nsStyleUserInterface>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleUserInterface ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUserInterface ) ) . mUserInput
                    as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleUserInterface ) , "::" , stringify ! ( mUserInput )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUserInterface ) ) .
                    mUserModify as * const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleUserInterface ) , "::" , stringify ! ( mUserModify
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUserInterface ) ) . mUserFocus
                    as * const _ as usize } , 2usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleUserInterface ) , "::" , stringify ! ( mUserFocus )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUserInterface ) ) .
                    mPointerEvents as * const _ as usize } , 3usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsStyleUserInterface ) , "::" , stringify ! (
                    mPointerEvents ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUserInterface ) ) . mCursor as
                    * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleUserInterface ) , "::" , stringify ! ( mCursor )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUserInterface ) ) .
                    mCursorImages as * const _ as usize } , 8usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsStyleUserInterface ) , "::" , stringify ! (
                    mCursorImages ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleUserInterface ) ) .
                    mCaretColor as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleUserInterface ) , "::" , stringify ! ( mCaretColor
                    ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleXUL {
        pub mBoxFlex: f32,
        pub mBoxOrdinal: u32,
        pub mBoxAlign: root::mozilla::StyleBoxAlign,
        pub mBoxDirection: root::mozilla::StyleBoxDirection,
        pub mBoxOrient: root::mozilla::StyleBoxOrient,
        pub mBoxPack: root::mozilla::StyleBoxPack,
        pub mStretchStack: bool,
    }
    #[test]
    fn bindgen_test_layout_nsStyleXUL() {
        assert_eq!(::std::mem::size_of::<nsStyleXUL>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleXUL ) ));
        assert_eq! (::std::mem::align_of::<nsStyleXUL>() , 4usize , concat ! (
                    "Alignment of " , stringify ! ( nsStyleXUL ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleXUL ) ) . mBoxFlex as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::"
                    , stringify ! ( mBoxFlex ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleXUL ) ) . mBoxOrdinal as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::"
                    , stringify ! ( mBoxOrdinal ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleXUL ) ) . mBoxAlign as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::"
                    , stringify ! ( mBoxAlign ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleXUL ) ) . mBoxDirection as *
                    const _ as usize } , 9usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::"
                    , stringify ! ( mBoxDirection ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleXUL ) ) . mBoxOrient as *
                    const _ as usize } , 10usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::"
                    , stringify ! ( mBoxOrient ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleXUL ) ) . mBoxPack as * const
                    _ as usize } , 11usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::"
                    , stringify ! ( mBoxPack ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleXUL ) ) . mStretchStack as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleXUL ) , "::"
                    , stringify ! ( mStretchStack ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleColumn {
        pub mColumnCount: u32,
        pub mColumnWidth: root::nsStyleCoord,
        pub mColumnGap: root::nsStyleCoord,
        pub mColumnRuleColor: root::mozilla::StyleComplexColor,
        pub mColumnRuleStyle: u8,
        pub mColumnFill: u8,
        pub mColumnRuleWidth: root::nscoord,
        pub mTwipsPerPixel: root::nscoord,
    }
    pub const nsStyleColumn_kMaxColumnCount: u32 = 1000;
    #[test]
    fn bindgen_test_layout_nsStyleColumn() {
        assert_eq!(::std::mem::size_of::<nsStyleColumn>() , 64usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleColumn ) ));
        assert_eq! (::std::mem::align_of::<nsStyleColumn>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleColumn ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnCount as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnCount ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnWidth as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnGap as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnGap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnRuleColor
                    as * const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnRuleColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnRuleStyle
                    as * const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnRuleStyle ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnFill as *
                    const _ as usize } , 49usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnFill ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mColumnRuleWidth
                    as * const _ as usize } , 52usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mColumnRuleWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleColumn ) ) . mTwipsPerPixel as
                    * const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleColumn ) ,
                    "::" , stringify ! ( mTwipsPerPixel ) ));
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleSVGPaintType {
        eStyleSVGPaintType_None = 1,
        eStyleSVGPaintType_Color = 2,
        eStyleSVGPaintType_Server = 3,
        eStyleSVGPaintType_ContextFill = 4,
        eStyleSVGPaintType_ContextStroke = 5,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleSVGPaint {
        pub mPaint: root::nsStyleSVGPaint__bindgen_ty_1,
        pub mType: root::nsStyleSVGPaintType,
        pub mFallbackColor: root::nscolor,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleSVGPaint__bindgen_ty_1 {
        pub mColor: root::__BindgenUnionField<root::nscolor>,
        pub mPaintServer: root::__BindgenUnionField<*mut root::mozilla::css::URLValue>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsStyleSVGPaint__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleSVGPaint__bindgen_ty_1>() ,
                   8usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleSVGPaint__bindgen_ty_1 )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleSVGPaint__bindgen_ty_1>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsStyleSVGPaint__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGPaint__bindgen_ty_1 ) ) .
                    mColor as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleSVGPaint__bindgen_ty_1 ) , "::" , stringify ! (
                    mColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGPaint__bindgen_ty_1 ) ) .
                    mPaintServer as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleSVGPaint__bindgen_ty_1 ) , "::" , stringify ! (
                    mPaintServer ) ));
    }
    impl Clone for nsStyleSVGPaint__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsStyleSVGPaint() {
        assert_eq!(::std::mem::size_of::<nsStyleSVGPaint>() , 16usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleSVGPaint ) ));
        assert_eq! (::std::mem::align_of::<nsStyleSVGPaint>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleSVGPaint ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGPaint ) ) . mPaint as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGPaint ) ,
                    "::" , stringify ! ( mPaint ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGPaint ) ) . mType as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGPaint ) ,
                    "::" , stringify ! ( mType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGPaint ) ) . mFallbackColor
                    as * const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGPaint ) ,
                    "::" , stringify ! ( mFallbackColor ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleSVG {
        pub mFill: root::nsStyleSVGPaint,
        pub mStroke: root::nsStyleSVGPaint,
        pub mMarkerEnd: root::RefPtr<root::mozilla::css::URLValue>,
        pub mMarkerMid: root::RefPtr<root::mozilla::css::URLValue>,
        pub mMarkerStart: root::RefPtr<root::mozilla::css::URLValue>,
        pub mStrokeDasharray: root::nsTArray<root::nsStyleCoord>,
        pub mStrokeDashoffset: root::nsStyleCoord,
        pub mStrokeWidth: root::nsStyleCoord,
        pub mFillOpacity: f32,
        pub mStrokeMiterlimit: f32,
        pub mStrokeOpacity: f32,
        pub mClipRule: root::mozilla::StyleFillRule,
        pub mColorInterpolation: u8,
        pub mColorInterpolationFilters: u8,
        pub mFillRule: root::mozilla::StyleFillRule,
        pub mPaintOrder: u8,
        pub mShapeRendering: u8,
        pub mStrokeLinecap: u8,
        pub mStrokeLinejoin: u8,
        pub mTextAnchor: u8,
        pub mContextFlags: u8,
    }
    pub const nsStyleSVG_FILL_OPACITY_SOURCE_MASK:
              root::nsStyleSVG__bindgen_ty_1 =
        nsStyleSVG__bindgen_ty_1::FILL_OPACITY_SOURCE_MASK;
    pub const nsStyleSVG_STROKE_OPACITY_SOURCE_MASK:
              root::nsStyleSVG__bindgen_ty_1 =
        nsStyleSVG__bindgen_ty_1::STROKE_OPACITY_SOURCE_MASK;
    pub const nsStyleSVG_STROKE_DASHARRAY_CONTEXT:
              root::nsStyleSVG__bindgen_ty_1 =
        nsStyleSVG__bindgen_ty_1::STROKE_DASHARRAY_CONTEXT;
    pub const nsStyleSVG_STROKE_DASHOFFSET_CONTEXT:
              root::nsStyleSVG__bindgen_ty_1 =
        nsStyleSVG__bindgen_ty_1::STROKE_DASHOFFSET_CONTEXT;
    pub const nsStyleSVG_STROKE_WIDTH_CONTEXT: root::nsStyleSVG__bindgen_ty_1
              =
        nsStyleSVG__bindgen_ty_1::STROKE_WIDTH_CONTEXT;
    pub const nsStyleSVG_FILL_OPACITY_SOURCE_SHIFT:
              root::nsStyleSVG__bindgen_ty_1 =
        nsStyleSVG__bindgen_ty_1::FILL_OPACITY_SOURCE_SHIFT;
    pub const nsStyleSVG_STROKE_OPACITY_SOURCE_SHIFT:
              root::nsStyleSVG__bindgen_ty_1 =
        nsStyleSVG__bindgen_ty_1::STROKE_OPACITY_SOURCE_SHIFT;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleSVG__bindgen_ty_1 {
        FILL_OPACITY_SOURCE_MASK = 3,
        STROKE_OPACITY_SOURCE_MASK = 12,
        STROKE_DASHARRAY_CONTEXT = 16,
        STROKE_DASHOFFSET_CONTEXT = 32,
        STROKE_WIDTH_CONTEXT = 64,
        FILL_OPACITY_SOURCE_SHIFT = 0,
        STROKE_OPACITY_SOURCE_SHIFT = 2,
    }
    #[test]
    fn bindgen_test_layout_nsStyleSVG() {
        assert_eq!(::std::mem::size_of::<nsStyleSVG>() , 120usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleSVG ) ));
        assert_eq! (::std::mem::align_of::<nsStyleSVG>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( nsStyleSVG ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mFill as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mFill ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStroke as * const _
                    as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStroke ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mMarkerEnd as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mMarkerEnd ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mMarkerMid as *
                    const _ as usize } , 40usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mMarkerMid ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mMarkerStart as *
                    const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mMarkerStart ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeDasharray as
                    * const _ as usize } , 56usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStrokeDasharray ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeDashoffset as
                    * const _ as usize } , 64usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStrokeDashoffset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeWidth as *
                    const _ as usize } , 80usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStrokeWidth ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mFillOpacity as *
                    const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mFillOpacity ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeMiterlimit as
                    * const _ as usize } , 100usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStrokeMiterlimit ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeOpacity as *
                    const _ as usize } , 104usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStrokeOpacity ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mClipRule as * const
                    _ as usize } , 108usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mClipRule ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mColorInterpolation
                    as * const _ as usize } , 109usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mColorInterpolation ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) .
                    mColorInterpolationFilters as * const _ as usize } ,
                    110usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mColorInterpolationFilters ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mFillRule as * const
                    _ as usize } , 111usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mFillRule ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mPaintOrder as *
                    const _ as usize } , 112usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mPaintOrder ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mShapeRendering as *
                    const _ as usize } , 113usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mShapeRendering ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeLinecap as *
                    const _ as usize } , 114usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStrokeLinecap ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mStrokeLinejoin as *
                    const _ as usize } , 115usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mStrokeLinejoin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mTextAnchor as *
                    const _ as usize } , 116usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mTextAnchor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVG ) ) . mContextFlags as *
                    const _ as usize } , 117usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVG ) , "::"
                    , stringify ! ( mContextFlags ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleFilter {
        pub mType: u32,
        pub mFilterParameter: root::nsStyleCoord,
        pub __bindgen_anon_1: root::nsStyleFilter__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleFilter__bindgen_ty_1 {
        pub mURL: root::__BindgenUnionField<*mut root::mozilla::css::URLValue>,
        pub mDropShadow: root::__BindgenUnionField<*mut root::nsCSSShadowArray>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsStyleFilter__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleFilter__bindgen_ty_1>() ,
                   8usize , concat ! (
                   "Size of: " , stringify ! ( nsStyleFilter__bindgen_ty_1 )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleFilter__bindgen_ty_1>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsStyleFilter__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFilter__bindgen_ty_1 ) ) .
                    mURL as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleFilter__bindgen_ty_1 ) , "::" , stringify ! ( mURL
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFilter__bindgen_ty_1 ) ) .
                    mDropShadow as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsStyleFilter__bindgen_ty_1 ) , "::" , stringify ! (
                    mDropShadow ) ));
    }
    impl Clone for nsStyleFilter__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsStyleFilter() {
        assert_eq!(::std::mem::size_of::<nsStyleFilter>() , 32usize , concat !
                   ( "Size of: " , stringify ! ( nsStyleFilter ) ));
        assert_eq! (::std::mem::align_of::<nsStyleFilter>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleFilter ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFilter ) ) . mType as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFilter ) ,
                    "::" , stringify ! ( mType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleFilter ) ) . mFilterParameter
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleFilter ) ,
                    "::" , stringify ! ( mFilterParameter ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleSVGReset {
        pub mMask: root::nsStyleImageLayers,
        pub mClipPath: root::mozilla::StyleShapeSource,
        pub mStopColor: root::nscolor,
        pub mFloodColor: root::nscolor,
        pub mLightingColor: root::nscolor,
        pub mStopOpacity: f32,
        pub mFloodOpacity: f32,
        pub mDominantBaseline: u8,
        pub mVectorEffect: u8,
        pub mMaskType: u8,
    }
    #[test]
    fn bindgen_test_layout_nsStyleSVGReset() {
        assert_eq!(::std::mem::size_of::<nsStyleSVGReset>() , 200usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleSVGReset )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleSVGReset>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleSVGReset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mMask as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mMask ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mClipPath as *
                    const _ as usize } , 160usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mClipPath ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mStopColor as *
                    const _ as usize } , 176usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mStopColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mFloodColor as
                    * const _ as usize } , 180usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mFloodColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mLightingColor
                    as * const _ as usize } , 184usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mLightingColor ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mStopOpacity as
                    * const _ as usize } , 188usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mStopOpacity ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mFloodOpacity
                    as * const _ as usize } , 192usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mFloodOpacity ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) .
                    mDominantBaseline as * const _ as usize } , 196usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mDominantBaseline ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mVectorEffect
                    as * const _ as usize } , 197usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mVectorEffect ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleSVGReset ) ) . mMaskType as *
                    const _ as usize } , 198usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleSVGReset ) ,
                    "::" , stringify ! ( mMaskType ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleVariables {
        pub mVariables: root::mozilla::CSSVariableValues,
    }
    #[test]
    fn bindgen_test_layout_nsStyleVariables() {
        assert_eq!(::std::mem::size_of::<nsStyleVariables>() , 48usize ,
                   concat ! ( "Size of: " , stringify ! ( nsStyleVariables )
                   ));
        assert_eq! (::std::mem::align_of::<nsStyleVariables>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsStyleVariables ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleVariables ) ) . mVariables as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleVariables )
                    , "::" , stringify ! ( mVariables ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleEffects {
        pub mFilters: root::nsTArray<root::nsStyleFilter>,
        pub mBoxShadow: root::RefPtr<root::nsCSSShadowArray>,
        pub mClip: root::nsRect,
        pub mOpacity: f32,
        pub mClipFlags: u8,
        pub mMixBlendMode: u8,
    }
    #[test]
    fn bindgen_test_layout_nsStyleEffects() {
        assert_eq!(::std::mem::size_of::<nsStyleEffects>() , 40usize , concat
                   ! ( "Size of: " , stringify ! ( nsStyleEffects ) ));
        assert_eq! (::std::mem::align_of::<nsStyleEffects>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsStyleEffects ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleEffects ) ) . mFilters as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleEffects ) ,
                    "::" , stringify ! ( mFilters ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleEffects ) ) . mBoxShadow as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleEffects ) ,
                    "::" , stringify ! ( mBoxShadow ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleEffects ) ) . mClip as * const
                    _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleEffects ) ,
                    "::" , stringify ! ( mClip ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleEffects ) ) . mOpacity as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleEffects ) ,
                    "::" , stringify ! ( mOpacity ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleEffects ) ) . mClipFlags as *
                    const _ as usize } , 36usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleEffects ) ,
                    "::" , stringify ! ( mClipFlags ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsStyleEffects ) ) . mMixBlendMode as
                    * const _ as usize } , 37usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsStyleEffects ) ,
                    "::" , stringify ! ( mMixBlendMode ) ));
    }
    /**
 * These *_Simple types are used to map Gecko types to layout-equivalent but
 * simpler Rust types, to aid Rust binding generation.
 *
 * If something in this types or the assertions below needs to change, ask
 * bholley, heycam or emilio before!
 *
 * <div rustbindgen="true" replaces="nsPoint">
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsPoint {
        pub x: root::nscoord,
        pub y: root::nscoord,
    }
    #[test]
    fn bindgen_test_layout_nsPoint() {
        assert_eq!(::std::mem::size_of::<nsPoint>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsPoint ) ));
        assert_eq! (::std::mem::align_of::<nsPoint>() , 4usize , concat ! (
                    "Alignment of " , stringify ! ( nsPoint ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPoint ) ) . x as * const _ as usize
                    } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPoint ) , "::" ,
                    stringify ! ( x ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsPoint ) ) . y as * const _ as usize
                    } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsPoint ) , "::" ,
                    stringify ! ( y ) ));
    }
    impl Clone for nsPoint {
        fn clone(&self) -> Self { *self }
    }
    /**
 * <div rustbindgen="true" replaces="nsMargin">
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsMargin {
        pub top: root::nscoord,
        pub right: root::nscoord,
        pub bottom: root::nscoord,
        pub left: root::nscoord,
    }
    #[test]
    fn bindgen_test_layout_nsMargin() {
        assert_eq!(::std::mem::size_of::<nsMargin>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsMargin ) ));
        assert_eq! (::std::mem::align_of::<nsMargin>() , 4usize , concat ! (
                    "Alignment of " , stringify ! ( nsMargin ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMargin ) ) . top as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMargin ) , "::" ,
                    stringify ! ( top ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMargin ) ) . right as * const _ as
                    usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMargin ) , "::" ,
                    stringify ! ( right ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMargin ) ) . bottom as * const _ as
                    usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMargin ) , "::" ,
                    stringify ! ( bottom ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMargin ) ) . left as * const _ as
                    usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMargin ) , "::" ,
                    stringify ! ( left ) ));
    }
    impl Clone for nsMargin {
        fn clone(&self) -> Self { *self }
    }
    /**
 * <div rustbindgen="true" replaces="nsRect">
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsRect {
        pub x: root::nscoord,
        pub y: root::nscoord,
        pub width: root::nscoord,
        pub height: root::nscoord,
    }
    #[test]
    fn bindgen_test_layout_nsRect() {
        assert_eq!(::std::mem::size_of::<nsRect>() , 16usize , concat ! (
                   "Size of: " , stringify ! ( nsRect ) ));
        assert_eq! (::std::mem::align_of::<nsRect>() , 4usize , concat ! (
                    "Alignment of " , stringify ! ( nsRect ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRect ) ) . x as * const _ as usize
                    } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsRect ) , "::" ,
                    stringify ! ( x ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRect ) ) . y as * const _ as usize
                    } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsRect ) , "::" ,
                    stringify ! ( y ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRect ) ) . width as * const _ as
                    usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsRect ) , "::" ,
                    stringify ! ( width ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsRect ) ) . height as * const _ as
                    usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsRect ) , "::" ,
                    stringify ! ( height ) ));
    }
    impl Clone for nsRect {
        fn clone(&self) -> Self { *self }
    }
    /**
 * <div rustbindgen="true" replaces="nsSize">
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsSize {
        pub width: root::nscoord,
        pub height: root::nscoord,
    }
    #[test]
    fn bindgen_test_layout_nsSize() {
        assert_eq!(::std::mem::size_of::<nsSize>() , 8usize , concat ! (
                   "Size of: " , stringify ! ( nsSize ) ));
        assert_eq! (::std::mem::align_of::<nsSize>() , 4usize , concat ! (
                    "Alignment of " , stringify ! ( nsSize ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSize ) ) . width as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSize ) , "::" ,
                    stringify ! ( width ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsSize ) ) . height as * const _ as
                    usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsSize ) , "::" ,
                    stringify ! ( height ) ));
    }
    impl Clone for nsSize {
        fn clone(&self) -> Self { *self }
    }
    /**
 * <div rustbindgen replaces="nsTArray"></div>
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsTArray<T> {
        pub mBuffer: *mut T,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RawServoDeclarationBlock([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsSVGAngle([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsSVGIntegerPair([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsSVGLength2([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsSVGNumberPair([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsSVGViewBox([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsStyledElement([u8; 0]);
    /**
 * A class used to construct a nsString from a nsStringBuffer (we might
 * want to move this to nsString at some point).
 *
 * WARNING: Note that nsCheapString doesn't take an explicit length -- it
 * assumes the string is maximally large, given the nsStringBuffer's storage
 * size.  This means the given string buffer *must* be sized exactly correctly
 * for the string it contains (including one byte for a null terminator).  If
 * it has any unused storage space, then that will result in bogus characters
 * at the end of our nsCheapString.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCheapString {
        pub _base: ::nsstring::nsStringRepr,
    }
    #[test]
    fn bindgen_test_layout_nsCheapString() {
        assert_eq!(::std::mem::size_of::<nsCheapString>() , 16usize , concat !
                   ( "Size of: " , stringify ! ( nsCheapString ) ));
        assert_eq! (::std::mem::align_of::<nsCheapString>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsCheapString ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsMappedAttributes([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsMappedAttributeElement([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDOMTokenList([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsDOMStringMap([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMMozNamedAttrMap {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMMozNamedAttrMap_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMMozNamedAttrMap() {
        assert_eq!(::std::mem::size_of::<nsIDOMMozNamedAttrMap>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIDOMMozNamedAttrMap ) ));
        assert_eq! (::std::mem::align_of::<nsIDOMMozNamedAttrMap>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIDOMMozNamedAttrMap )
                    ));
    }
    impl Clone for nsIDOMMozNamedAttrMap {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIAttribute {
        pub _base: root::nsINode,
        pub mAttrMap: root::RefPtr<root::nsDOMAttributeMap>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIAttribute_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIAttribute() {
        assert_eq!(::std::mem::size_of::<nsIAttribute>() , 104usize , concat !
                   ( "Size of: " , stringify ! ( nsIAttribute ) ));
        assert_eq! (::std::mem::align_of::<nsIAttribute>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsIAttribute ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsIAttribute ) ) . mAttrMap as *
                    const _ as usize } , 96usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsIAttribute ) ,
                    "::" , stringify ! ( mAttrMap ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsScrollbarFrame([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIScrollbarMediator {
        pub _base: root::nsQueryFrame,
    }
    pub type nsIScrollbarMediator_Has_NS_DECL_QUERYFRAME_TARGET =
        root::nsIScrollbarMediator;
    #[repr(u32)]
    /**
   * When set to ENABLE_SNAP, additional scrolling will be performed after the
   * scroll operation to maintain the constraints set by CSS Scroll snapping.
   * The additional scrolling may include asynchronous smooth scrolls that
   * continue to animate after the initial scroll position has been set.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIScrollbarMediator_ScrollSnapMode {
        DISABLE_SNAP = 0,
        ENABLE_SNAP = 1,
    }
    extern "C" {
        #[link_name = "_ZN20nsIScrollbarMediator9kFrameIIDE"]
        pub static nsIScrollbarMediator_kFrameIID:
                   root::nsQueryFrame_FrameIID;
    }
    #[test]
    fn bindgen_test_layout_nsIScrollbarMediator() {
        assert_eq!(::std::mem::size_of::<nsIScrollbarMediator>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIScrollbarMediator ) ));
        assert_eq! (::std::mem::align_of::<nsIScrollbarMediator>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIScrollbarMediator ) ));
    }
    impl Clone for nsIScrollbarMediator {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsBoxLayoutState([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIScrollPositionListener([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsAttrValueOrString([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RawServoAnimationValue([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RawServoStyleSet([u8; 0]);
    pub type RawGeckoNode = root::nsINode;
    pub type RawGeckoElement = root::mozilla::dom::Element;
    pub type RawGeckoDocument = root::nsIDocument;
    pub type RawGeckoPresContext = root::nsPresContext;
    pub type RawGeckoKeyframeList = root::nsTArray<root::mozilla::Keyframe>;
    pub type RawGeckoComputedKeyframeValuesList =
        root::nsTArray<root::nsTArray<root::mozilla::PropertyStyleAnimationValuePair>>;
    pub type RawGeckoAnimationValueList =
        root::nsTArray<root::mozilla::PropertyStyleAnimationValuePair>;
    pub type RawServoAnimationValueBorrowedList =
        root::nsTArray<*const root::RawServoAnimationValue>;
    pub type RawGeckoNodeBorrowed = *const root::RawGeckoNode;
    pub type RawGeckoNodeBorrowedOrNull = *const root::RawGeckoNode;
    pub type RawGeckoElementBorrowed = *const root::RawGeckoElement;
    pub type RawGeckoElementBorrowedOrNull = *const root::RawGeckoElement;
    pub type RawGeckoDocumentBorrowed = *const root::RawGeckoDocument;
    pub type RawGeckoDocumentBorrowedOrNull = *const root::RawGeckoDocument;
    pub type RawGeckoPresContextOwned = *mut root::RawGeckoPresContext;
    pub type RawGeckoPresContextBorrowed = *const root::RawGeckoPresContext;
    pub type RawGeckoPresContextBorrowedMut = *mut root::RawGeckoPresContext;
    pub type RawGeckoAnimationValueListBorrowedMut =
        *mut root::RawGeckoAnimationValueList;
    pub type RawServoAnimationValueBorrowedListBorrowed =
        *const root::RawServoAnimationValueBorrowedList;
    pub type RawGeckoKeyframeListBorrowedMut =
        *mut root::RawGeckoKeyframeList;
    pub type RawGeckoKeyframeListBorrowed = *const root::RawGeckoKeyframeList;
    pub type RawGeckoComputedKeyframeValuesListBorrowedMut =
        *mut root::RawGeckoComputedKeyframeValuesList;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ElementRuleProcessorData([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct PseudoElementRuleProcessorData([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AnonBoxRuleProcessorData([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct XULTreeRuleProcessorData([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct StateRuleProcessorData([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct PseudoElementStateRuleProcessorData([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AttributeRuleProcessorData([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIStyleRuleProcessor {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIStyleRuleProcessor_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub type nsIStyleRuleProcessor_EnumFunc =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::nsIStyleRuleProcessor,
                                                   arg2:
                                                       *mut ::std::os::raw::c_void)
                                  -> bool>;
    #[test]
    fn bindgen_test_layout_nsIStyleRuleProcessor() {
        assert_eq!(::std::mem::size_of::<nsIStyleRuleProcessor>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( nsIStyleRuleProcessor ) ));
        assert_eq! (::std::mem::align_of::<nsIStyleRuleProcessor>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsIStyleRuleProcessor )
                    ));
    }
    impl Clone for nsIStyleRuleProcessor {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIStyleRule([u8; 0]);
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsMediaFeature {
        pub mName: *mut *mut root::nsIAtom,
        pub mRangeType: root::nsMediaFeature_RangeType,
        pub mValueType: root::nsMediaFeature_ValueType,
        pub mReqFlags: u8,
        pub mData: root::nsMediaFeature__bindgen_ty_1,
        pub mGetter: root::nsMediaFeatureValueGetter,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsMediaFeature_RangeType {
        eMinMaxAllowed = 0,
        eMinMaxNotAllowed = 1,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsMediaFeature_ValueType {
        eLength = 0,
        eInteger = 1,
        eFloat = 2,
        eBoolInteger = 3,
        eIntRatio = 4,
        eResolution = 5,
        eEnumerated = 6,
        eIdent = 7,
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsMediaFeature_RequirementFlags {
        eNoRequirements = 0,
        eHasWebkitPrefix = 1,
        eWebkitDevicePixelRatioPrefEnabled = 2,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsMediaFeature__bindgen_ty_1 {
        pub mInitializer_: root::__BindgenUnionField<*const ::std::os::raw::c_void>,
        pub mKeywordTable: root::__BindgenUnionField<*const root::nsCSSProps_KTableEntry>,
        pub mMetric: root::__BindgenUnionField<*const *const root::nsIAtom>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsMediaFeature__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsMediaFeature__bindgen_ty_1>() ,
                   8usize , concat ! (
                   "Size of: " , stringify ! ( nsMediaFeature__bindgen_ty_1 )
                   ));
        assert_eq! (::std::mem::align_of::<nsMediaFeature__bindgen_ty_1>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsMediaFeature__bindgen_ty_1 ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature__bindgen_ty_1 ) ) .
                    mInitializer_ as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsMediaFeature__bindgen_ty_1 ) , "::" , stringify ! (
                    mInitializer_ ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature__bindgen_ty_1 ) ) .
                    mKeywordTable as * const _ as usize } , 0usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsMediaFeature__bindgen_ty_1 ) , "::" , stringify ! (
                    mKeywordTable ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature__bindgen_ty_1 ) ) .
                    mMetric as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsMediaFeature__bindgen_ty_1 ) , "::" , stringify ! (
                    mMetric ) ));
    }
    impl Clone for nsMediaFeature__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsMediaFeature() {
        assert_eq!(::std::mem::size_of::<nsMediaFeature>() , 40usize , concat
                   ! ( "Size of: " , stringify ! ( nsMediaFeature ) ));
        assert_eq! (::std::mem::align_of::<nsMediaFeature>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( nsMediaFeature ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature ) ) . mName as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaFeature ) ,
                    "::" , stringify ! ( mName ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature ) ) . mRangeType as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaFeature ) ,
                    "::" , stringify ! ( mRangeType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature ) ) . mValueType as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaFeature ) ,
                    "::" , stringify ! ( mValueType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature ) ) . mReqFlags as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaFeature ) ,
                    "::" , stringify ! ( mReqFlags ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature ) ) . mData as * const
                    _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaFeature ) ,
                    "::" , stringify ! ( mData ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaFeature ) ) . mGetter as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaFeature ) ,
                    "::" , stringify ! ( mGetter ) ));
    }
    impl Clone for nsMediaFeature {
        fn clone(&self) -> Self { *self }
    }
    pub type ThreadSafePrincipalHolder =
        root::nsMainThreadPtrHolder<root::nsIPrincipal>;
    pub type ThreadSafeURIHolder = root::nsMainThreadPtrHolder<root::nsIURI>;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct ServoBundledURI {
        pub mURLString: *const u8,
        pub mURLStringLength: u32,
        pub mBaseURI: *mut root::ThreadSafeURIHolder,
        pub mReferrer: *mut root::ThreadSafeURIHolder,
        pub mPrincipal: *mut root::ThreadSafePrincipalHolder,
    }
    #[test]
    fn bindgen_test_layout_ServoBundledURI() {
        assert_eq!(::std::mem::size_of::<ServoBundledURI>() , 40usize , concat
                   ! ( "Size of: " , stringify ! ( ServoBundledURI ) ));
        assert_eq! (::std::mem::align_of::<ServoBundledURI>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( ServoBundledURI ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoBundledURI ) ) . mURLString as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoBundledURI ) ,
                    "::" , stringify ! ( mURLString ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoBundledURI ) ) .
                    mURLStringLength as * const _ as usize } , 8usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( ServoBundledURI ) ,
                    "::" , stringify ! ( mURLStringLength ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoBundledURI ) ) . mBaseURI as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoBundledURI ) ,
                    "::" , stringify ! ( mBaseURI ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoBundledURI ) ) . mReferrer as *
                    const _ as usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoBundledURI ) ,
                    "::" , stringify ! ( mReferrer ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ServoBundledURI ) ) . mPrincipal as *
                    const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( ServoBundledURI ) ,
                    "::" , stringify ! ( mPrincipal ) ));
    }
    impl Clone for ServoBundledURI {
        fn clone(&self) -> Self { *self }
    }
    pub type nsMediaFeatureValueGetter =
        ::std::option::Option<unsafe extern "C" fn(aPresContext:
                                                       *mut root::nsPresContext,
                                                   aFeature:
                                                       *const root::nsMediaFeature,
                                                   aResult:
                                                       *mut root::nsCSSValue)>;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsMediaFeatures {
        pub _address: u8,
    }
    extern "C" {
        #[link_name = "_ZN15nsMediaFeatures8featuresE"]
        pub static mut nsMediaFeatures_features:
                   [root::nsMediaFeature; 0usize];
    }
    #[test]
    fn bindgen_test_layout_nsMediaFeatures() {
        assert_eq!(::std::mem::size_of::<nsMediaFeatures>() , 1usize , concat
                   ! ( "Size of: " , stringify ! ( nsMediaFeatures ) ));
        assert_eq! (::std::mem::align_of::<nsMediaFeatures>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsMediaFeatures ) ));
    }
    impl Clone for nsMediaFeatures {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMediaExpression {
        pub mFeature: *const root::nsMediaFeature,
        pub mRange: root::nsMediaExpression_Range,
        pub mValue: root::nsCSSValue,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsMediaExpression_Range { eMin = 0, eMax = 1, eEqual = 2, }
    #[test]
    fn bindgen_test_layout_nsMediaExpression() {
        assert_eq!(::std::mem::size_of::<nsMediaExpression>() , 32usize ,
                   concat ! ( "Size of: " , stringify ! ( nsMediaExpression )
                   ));
        assert_eq! (::std::mem::align_of::<nsMediaExpression>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( nsMediaExpression ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaExpression ) ) . mFeature as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaExpression )
                    , "::" , stringify ! ( mFeature ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaExpression ) ) . mRange as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaExpression )
                    , "::" , stringify ! ( mRange ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaExpression ) ) . mValue as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaExpression )
                    , "::" , stringify ! ( mValue ) ));
    }
    /**
 * An nsMediaQueryResultCacheKey records what feature/value combinations
 * a set of media query results are valid for.  This allows the caller
 * to quickly learn whether a prior result of media query evaluation is
 * still valid (e.g., due to a window size change) without rerunning all
 * of the evaluation and rebuilding the list of rules.
 *
 * This object may not be used after any media rules in any of the
 * sheets it was given to have been modified.  However, this is
 * generally not a problem since ClearRuleCascades is called on the
 * sheet whenever this happens, and these objects are stored inside the
 * rule cascades.  (FIXME: We're not actually doing this all the time.)
 *
 * The implementation could be further optimized in the future to store
 * ranges (combinations of less-than, less-than-or-equal, greater-than,
 * greater-than-or-equal, equal, not-equal, present, not-present) for
 * each feature rather than simply storing the list of expressions.
 * However, this requires combining any such ranges.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMediaQueryResultCacheKey {
        pub mMedium: root::nsCOMPtr<root::nsIAtom>,
        pub mFeatureCache: root::nsTArray<root::nsMediaQueryResultCacheKey_FeatureEntry>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMediaQueryResultCacheKey_ExpressionEntry {
        pub mExpression: root::nsMediaExpression,
        pub mExpressionMatches: bool,
    }
    #[test]
    fn bindgen_test_layout_nsMediaQueryResultCacheKey_ExpressionEntry() {
        assert_eq!(::std::mem::size_of::<nsMediaQueryResultCacheKey_ExpressionEntry>()
                   , 40usize , concat ! (
                   "Size of: " , stringify ! (
                   nsMediaQueryResultCacheKey_ExpressionEntry ) ));
        assert_eq! (::std::mem::align_of::<nsMediaQueryResultCacheKey_ExpressionEntry>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsMediaQueryResultCacheKey_ExpressionEntry ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsMediaQueryResultCacheKey_ExpressionEntry )
                    ) . mExpression as * const _ as usize } , 0usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsMediaQueryResultCacheKey_ExpressionEntry ) , "::" ,
                    stringify ! ( mExpression ) ));
        assert_eq! (unsafe {
                    & (
                    * (
                    0 as * const nsMediaQueryResultCacheKey_ExpressionEntry )
                    ) . mExpressionMatches as * const _ as usize } , 32usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! (
                    nsMediaQueryResultCacheKey_ExpressionEntry ) , "::" ,
                    stringify ! ( mExpressionMatches ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMediaQueryResultCacheKey_FeatureEntry {
        pub mFeature: *const root::nsMediaFeature,
        pub mExpressions: root::nsTArray<root::nsMediaQueryResultCacheKey_ExpressionEntry>,
    }
    #[test]
    fn bindgen_test_layout_nsMediaQueryResultCacheKey_FeatureEntry() {
        assert_eq!(::std::mem::size_of::<nsMediaQueryResultCacheKey_FeatureEntry>()
                   , 16usize , concat ! (
                   "Size of: " , stringify ! (
                   nsMediaQueryResultCacheKey_FeatureEntry ) ));
        assert_eq! (::std::mem::align_of::<nsMediaQueryResultCacheKey_FeatureEntry>()
                    , 8usize , concat ! (
                    "Alignment of " , stringify ! (
                    nsMediaQueryResultCacheKey_FeatureEntry ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsMediaQueryResultCacheKey_FeatureEntry )
                    ) . mFeature as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsMediaQueryResultCacheKey_FeatureEntry ) , "::" ,
                    stringify ! ( mFeature ) ));
        assert_eq! (unsafe {
                    & (
                    * ( 0 as * const nsMediaQueryResultCacheKey_FeatureEntry )
                    ) . mExpressions as * const _ as usize } , 8usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    nsMediaQueryResultCacheKey_FeatureEntry ) , "::" ,
                    stringify ! ( mExpressions ) ));
    }
    #[test]
    fn bindgen_test_layout_nsMediaQueryResultCacheKey() {
        assert_eq!(::std::mem::size_of::<nsMediaQueryResultCacheKey>() ,
                   16usize , concat ! (
                   "Size of: " , stringify ! ( nsMediaQueryResultCacheKey )
                   ));
        assert_eq! (::std::mem::align_of::<nsMediaQueryResultCacheKey>() ,
                    8usize , concat ! (
                    "Alignment of " , stringify ! ( nsMediaQueryResultCacheKey
                    ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaQueryResultCacheKey ) ) .
                    mMedium as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    nsMediaQueryResultCacheKey ) , "::" , stringify ! (
                    mMedium ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaQueryResultCacheKey ) ) .
                    mFeatureCache as * const _ as usize } , 8usize , concat !
                    (
                    "Alignment of field: " , stringify ! (
                    nsMediaQueryResultCacheKey ) , "::" , stringify ! (
                    mFeatureCache ) ));
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMediaQuery {
        pub mNegated: bool,
        pub mHasOnly: bool,
        pub mTypeOmitted: bool,
        pub mHadUnknownExpression: bool,
        pub mMediaType: root::nsCOMPtr<root::nsIAtom>,
        pub mExpressions: root::nsTArray<root::nsMediaExpression>,
    }
    #[test]
    fn bindgen_test_layout_nsMediaQuery() {
        assert_eq!(::std::mem::size_of::<nsMediaQuery>() , 24usize , concat !
                   ( "Size of: " , stringify ! ( nsMediaQuery ) ));
        assert_eq! (::std::mem::align_of::<nsMediaQuery>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( nsMediaQuery ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaQuery ) ) . mNegated as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaQuery ) ,
                    "::" , stringify ! ( mNegated ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaQuery ) ) . mHasOnly as *
                    const _ as usize } , 1usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaQuery ) ,
                    "::" , stringify ! ( mHasOnly ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaQuery ) ) . mTypeOmitted as *
                    const _ as usize } , 2usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaQuery ) ,
                    "::" , stringify ! ( mTypeOmitted ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaQuery ) ) .
                    mHadUnknownExpression as * const _ as usize } , 3usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaQuery ) ,
                    "::" , stringify ! ( mHadUnknownExpression ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaQuery ) ) . mMediaType as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaQuery ) ,
                    "::" , stringify ! ( mMediaType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const nsMediaQuery ) ) . mExpressions as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( nsMediaQuery ) ,
                    "::" , stringify ! ( mExpressions ) ));
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct __va_list_tag {
        pub gp_offset: ::std::os::raw::c_uint,
        pub fp_offset: ::std::os::raw::c_uint,
        pub overflow_arg_area: *mut ::std::os::raw::c_void,
        pub reg_save_area: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout___va_list_tag() {
        assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat !
                   ( "Size of: " , stringify ! ( __va_list_tag ) ));
        assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat
                    ! ( "Alignment of " , stringify ! ( __va_list_tag ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( __va_list_tag ) ,
                    "::" , stringify ! ( gp_offset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( __va_list_tag ) ,
                    "::" , stringify ! ( fp_offset ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area
                    as * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( __va_list_tag ) ,
                    "::" , stringify ! ( overflow_arg_area ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as
                    * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( __va_list_tag ) ,
                    "::" , stringify ! ( reg_save_area ) ));
    }
    impl Clone for __va_list_tag {
        fn clone(&self) -> Self { *self }
    }
    pub type __builtin_va_list = [root::__va_list_tag; 1usize];
    #[test]
    fn __bindgen_test_layout_template_6() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_7() {
        assert_eq!(::std::mem::size_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Handle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Handle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_8() {
        assert_eq!(::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::MutableHandle<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::MutableHandle<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_9() {
        assert_eq!(::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::MutableHandle<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_10() {
        assert_eq!(::std::mem::size_of::<[u64; 3usize]>() , 24usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u64; 3usize] ) ));
        assert_eq!(::std::mem::align_of::<[u64; 3usize]>() , 8usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u64; 3usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_11() {
        assert_eq!(::std::mem::size_of::<root::JS::DeletePolicy<root::JSErrorNotes>>()
                   , 1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::DeletePolicy<root::JSErrorNotes> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::DeletePolicy<root::JSErrorNotes>>()
                   , 1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::DeletePolicy<root::JSErrorNotes> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_12() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<[::std::os::raw::c_char; 0usize],
                                               root::JS::FreePolicy>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<[::std::os::raw::c_char; 0usize],
                         root::JS::FreePolicy>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<[::std::os::raw::c_char; 0usize],
                                                root::JS::FreePolicy>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<[::std::os::raw::c_char; 0usize],
                         root::JS::FreePolicy>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_13() {
        assert_eq!(::std::mem::size_of::<root::JS::TenuredHeap<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::TenuredHeap<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::TenuredHeap<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::TenuredHeap<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_14() {
        assert_eq!(::std::mem::size_of::<root::JS::Heap<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Heap<*mut root::JSObject> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Heap<*mut root::JSObject>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Heap<*mut root::JSObject> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_15() {
        assert_eq!(::std::mem::size_of::<root::JS::Heap<*mut root::JSScript>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Heap<*mut root::JSScript> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Heap<*mut root::JSScript>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Heap<*mut root::JSScript> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_16() {
        assert_eq!(::std::mem::size_of::<root::nsReadingIterator<u16>>() ,
                   24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsReadingIterator<u16> ) ));
        assert_eq!(::std::mem::align_of::<root::nsReadingIterator<u16>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsReadingIterator<u16> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_17() {
        assert_eq!(::std::mem::size_of::<root::nsWritingIterator<u16>>() ,
                   24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsWritingIterator<u16> ) ));
        assert_eq!(::std::mem::align_of::<root::nsWritingIterator<u16>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsWritingIterator<u16> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_18() {
        assert_eq!(::std::mem::size_of::<root::nsReadingIterator<::std::os::raw::c_char>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsReadingIterator<::std::os::raw::c_char> ) ));
        assert_eq!(::std::mem::align_of::<root::nsReadingIterator<::std::os::raw::c_char>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsReadingIterator<::std::os::raw::c_char> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_19() {
        assert_eq!(::std::mem::size_of::<root::nsWritingIterator<::std::os::raw::c_char>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsWritingIterator<::std::os::raw::c_char> ) ));
        assert_eq!(::std::mem::align_of::<root::nsWritingIterator<::std::os::raw::c_char>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsWritingIterator<::std::os::raw::c_char> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_20() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete<[root::nsAString_internal; 0usize]>>()
                   , 1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete<[root::nsAString_internal; 0usize]>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete<[root::nsAString_internal; 0usize]>>()
                   , 1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete<[root::nsAString_internal; 0usize]>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_21() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete<[root::nsACString_internal; 0usize]>>()
                   , 1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete<[root::nsACString_internal; 0usize]>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete<[root::nsACString_internal; 0usize]>>()
                   , 1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete<[root::nsACString_internal; 0usize]>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_22() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCString>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCString> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCString>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCString> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_23() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_24() {
        assert_eq!(::std::mem::size_of::<root::mozilla::binding_danger::TErrorResult<root::mozilla::binding_danger::JustAssertCleanupPolicy>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::binding_danger::TErrorResult<root::mozilla::binding_danger::JustAssertCleanupPolicy>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::binding_danger::TErrorResult<root::mozilla::binding_danger::JustAssertCleanupPolicy>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::binding_danger::TErrorResult<root::mozilla::binding_danger::JustAssertCleanupPolicy>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_25() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsStringBuffer>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsStringBuffer> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsStringBuffer>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsStringBuffer> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_26() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIAtom>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIAtom> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIAtom>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIAtom> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_27() {
        assert_eq!(::std::mem::size_of::<root::JS::Heap<root::JS::Value>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::Heap<root::JS::Value> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::Heap<root::JS::Value>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::Heap<root::JS::Value> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_28() {
        assert_eq!(::std::mem::size_of::<root::JS::DeletePolicy<root::JSErrorNotes_Note>>()
                   , 1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::JS::DeletePolicy<root::JSErrorNotes_Note> ) ));
        assert_eq!(::std::mem::align_of::<root::JS::DeletePolicy<root::JSErrorNotes_Note>>()
                   , 1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::JS::DeletePolicy<root::JSErrorNotes_Note> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_29() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note,
                                               root::JS::DeletePolicy<root::JSErrorNotes_Note>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note,
                         root::JS::DeletePolicy<root::JSErrorNotes_Note>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::JSErrorNotes_Note,
                                                root::JS::DeletePolicy<root::JSErrorNotes_Note>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::JSErrorNotes_Note,
                         root::JS::DeletePolicy<root::JSErrorNotes_Note>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_30() {
        assert_eq!(::std::mem::size_of::<root::std::iterator<root::std::input_iterator_tag,
                                          root::mozilla::UniquePtr<root::JSErrorNotes_Note,
                                                                   root::JS::DeletePolicy<root::JSErrorNotes_Note>>,
                                          ::std::os::raw::c_long,
                                          *mut root::mozilla::UniquePtr<root::JSErrorNotes_Note,
                                                                        root::JS::DeletePolicy<root::JSErrorNotes_Note>>,
                                          *mut root::mozilla::UniquePtr<root::JSErrorNotes_Note,
                                                                        root::JS::DeletePolicy<root::JSErrorNotes_Note>>>>()
                   , 1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::iterator<root::std::input_iterator_tag,
                    root::mozilla::UniquePtr<root::JSErrorNotes_Note,
                                             root::JS::DeletePolicy<root::JSErrorNotes_Note>>,
                    ::std::os::raw::c_long,
                    *mut root::mozilla::UniquePtr<root::JSErrorNotes_Note,
                                                  root::JS::DeletePolicy<root::JSErrorNotes_Note>>,
                    *mut root::mozilla::UniquePtr<root::JSErrorNotes_Note,
                                                  root::JS::DeletePolicy<root::JSErrorNotes_Note>>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::std::iterator<root::std::input_iterator_tag,
                                           root::mozilla::UniquePtr<root::JSErrorNotes_Note,
                                                                    root::JS::DeletePolicy<root::JSErrorNotes_Note>>,
                                           ::std::os::raw::c_long,
                                           *mut root::mozilla::UniquePtr<root::JSErrorNotes_Note,
                                                                         root::JS::DeletePolicy<root::JSErrorNotes_Note>>,
                                           *mut root::mozilla::UniquePtr<root::JSErrorNotes_Note,
                                                                         root::JS::DeletePolicy<root::JSErrorNotes_Note>>>>()
                   , 1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::iterator<root::std::input_iterator_tag,
                    root::mozilla::UniquePtr<root::JSErrorNotes_Note,
                                             root::JS::DeletePolicy<root::JSErrorNotes_Note>>,
                    ::std::os::raw::c_long,
                    *mut root::mozilla::UniquePtr<root::JSErrorNotes_Note,
                                                  root::JS::DeletePolicy<root::JSErrorNotes_Note>>,
                    *mut root::mozilla::UniquePtr<root::JSErrorNotes_Note,
                                                  root::JS::DeletePolicy<root::JSErrorNotes_Note>>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_31() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIRunnable> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIRunnable> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_32() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIPrincipal>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIPrincipal> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIPrincipal>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIPrincipal> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_33() {
        assert_eq!(::std::mem::size_of::<[u64; 28usize]>() , 224usize , concat
                   ! (
                   "Size of template specialization: " , stringify ! (
                   [u64; 28usize] ) ));
        assert_eq!(::std::mem::align_of::<[u64; 28usize]>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   [u64; 28usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_34() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_35() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::AnonymousContent>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::AnonymousContent>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::AnonymousContent>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::AnonymousContent>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_36() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::StyleSheet>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::StyleSheet> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_37() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::Element> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::Element>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::Element> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_38() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::Element>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::Element>> )
                   ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::Element>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::Element>> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_template_39() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIObserver>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIObserver> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIObserver>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIObserver> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_40() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCOMPtr<root::nsIObserver>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr<root::nsIObserver>> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCOMPtr<root::nsIObserver>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsCOMPtr<root::nsIObserver>> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_41() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIDocument>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIDocument> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIDocument>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIDocument> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_42() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsContentList>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsContentList> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsContentList>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsContentList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_43() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsINode>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsINode> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsINode>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsINode> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_44() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIWeakReference>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIWeakReference> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIWeakReference>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIWeakReference> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_45() {
        assert_eq!(::std::mem::size_of::<u64>() , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! ( u64 )
                   ));
        assert_eq!(::std::mem::align_of::<u64>() , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   u64 ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_46() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsRect>>() ,
                   8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::nsRect> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsRect>>() ,
                   8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::nsRect> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_47() {
        assert_eq!(::std::mem::size_of::<[u64; 28usize]>() , 224usize , concat
                   ! (
                   "Size of template specialization: " , stringify ! (
                   [u64; 28usize] ) ));
        assert_eq!(::std::mem::align_of::<[u64; 28usize]>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   [u64; 28usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_48() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::mozilla::dom::NodeInfo>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::NodeInfo> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::mozilla::dom::NodeInfo>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::mozilla::dom::NodeInfo> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_49() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_50() {
        assert_eq!(::std::mem::size_of::<[u64; 5usize]>() , 40usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u64; 5usize] ) ));
        assert_eq!(::std::mem::align_of::<[u64; 5usize]>() , 8usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u64; 5usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_51() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete<root::mozilla::dom::TimeoutManager>>()
                   , 1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete<root::mozilla::dom::TimeoutManager>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete<root::mozilla::dom::TimeoutManager>>()
                   , 1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete<root::mozilla::dom::TimeoutManager>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_52() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsISupports>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsISupports> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsISupports>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsISupports> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_53() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIRunnable> ) ));
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIRunnable>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsCOMPtr<root::nsIRunnable> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_54() {
        assert_eq!(::std::mem::size_of::<root::nsAutoPtr<root::nsMediaQuery>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsAutoPtr<root::nsMediaQuery> ) ));
        assert_eq!(::std::mem::align_of::<root::nsAutoPtr<root::nsMediaQuery>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsAutoPtr<root::nsMediaQuery> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_55() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsIContent>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIContent> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsIContent>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsIContent> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_56() {
        assert_eq!(::std::mem::size_of::<[u64; 5usize]>() , 40usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u64; 5usize] ) ));
        assert_eq!(::std::mem::align_of::<[u64; 5usize]>() , 8usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u64; 5usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_57() {
        assert_eq!(::std::mem::size_of::<root::mozilla::OwningNonNull<root::nsINode>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::OwningNonNull<root::nsINode> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::OwningNonNull<root::nsINode>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::OwningNonNull<root::nsINode> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_58() {
        assert_eq!(::std::mem::size_of::<[u32; 2usize]>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 2usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_59() {
        assert_eq!(::std::mem::size_of::<[u32; 2usize]>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 2usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_60() {
        assert_eq!(::std::mem::size_of::<[u32; 2usize]>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 2usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_61() {
        assert_eq!(::std::mem::size_of::<[u32; 4usize]>() , 16usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 4usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 4usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 4usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_62() {
        assert_eq!(::std::mem::size_of::<[u32; 2usize]>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 2usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_63() {
        assert_eq!(::std::mem::size_of::<[u32; 2usize]>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 2usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_64() {
        assert_eq!(::std::mem::size_of::<[u32; 4usize]>() , 16usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 4usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 4usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 4usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_65() {
        assert_eq!(::std::mem::size_of::<[u32; 4usize]>() , 16usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 4usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 4usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 4usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_66() {
        assert_eq!(::std::mem::size_of::<[u32; 4usize]>() , 16usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 4usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 4usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 4usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_67() {
        assert_eq!(::std::mem::size_of::<u32>() , 4usize , concat ! (
                   "Size of template specialization: " , stringify ! ( u32 )
                   ));
        assert_eq!(::std::mem::align_of::<u32>() , 4usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   u32 ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_68() {
        assert_eq!(::std::mem::size_of::<[u32; 2usize]>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 2usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_69() {
        assert_eq!(::std::mem::size_of::<[u32; 2usize]>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 2usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_70() {
        assert_eq!(::std::mem::size_of::<[u32; 2usize]>() , 8usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 2usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 2usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_71() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<f64>>() , 8usize ,
                   concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<f64> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<f64>>() , 8usize ,
                   concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<f64> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_72() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_73() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_74() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::mozilla::FontFamilyName>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::FontFamilyName> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::mozilla::FontFamilyName>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::FontFamilyName> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_75() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::std::os::raw::c_uint>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<::std::os::raw::c_uint> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<::std::os::raw::c_uint>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<::std::os::raw::c_uint> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_76() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete<root::ProxyBehaviour>>()
                   , 1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete<root::ProxyBehaviour> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete<root::ProxyBehaviour>>()
                   , 1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete<root::ProxyBehaviour> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_77() {
        assert_eq!(::std::mem::size_of::<root::nsMainThreadPtrHolder<root::nsIURI>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsMainThreadPtrHolder<root::nsIURI> ) ));
        assert_eq!(::std::mem::align_of::<root::nsMainThreadPtrHolder<root::nsIURI>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsMainThreadPtrHolder<root::nsIURI> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_78() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsMainThreadPtrHolder<root::nsIURI>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsMainThreadPtrHolder<root::nsIURI>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsMainThreadPtrHolder<root::nsIURI>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsMainThreadPtrHolder<root::nsIURI>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_79() {
        assert_eq!(::std::mem::size_of::<root::nsMainThreadPtrHolder<root::nsIPrincipal>>()
                   , 24usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsMainThreadPtrHolder<root::nsIPrincipal> ) ));
        assert_eq!(::std::mem::align_of::<root::nsMainThreadPtrHolder<root::nsIPrincipal>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsMainThreadPtrHolder<root::nsIPrincipal> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_80() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsMainThreadPtrHolder<root::nsIPrincipal>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsMainThreadPtrHolder<root::nsIPrincipal>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsMainThreadPtrHolder<root::nsIPrincipal>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsMainThreadPtrHolder<root::nsIPrincipal>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_81() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete<root::nsCSSValueList>>()
                   , 1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete<root::nsCSSValueList> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete<root::nsCSSValueList>>()
                   , 1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete<root::nsCSSValueList> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_82() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsCSSValueList,
                                               root::mozilla::DefaultDelete<root::nsCSSValueList>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsCSSValueList,
                         root::mozilla::DefaultDelete<root::nsCSSValueList>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsCSSValueList,
                                                root::mozilla::DefaultDelete<root::nsCSSValueList>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsCSSValueList,
                         root::mozilla::DefaultDelete<root::nsCSSValueList>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_83() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete<root::nsCSSValuePairList>>()
                   , 1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete<root::nsCSSValuePairList> )
                   ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete<root::nsCSSValuePairList>>()
                   , 1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete<root::nsCSSValuePairList> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_template_84() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsCSSValuePairList,
                                               root::mozilla::DefaultDelete<root::nsCSSValuePairList>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsCSSValuePairList,
                         root::mozilla::DefaultDelete<root::nsCSSValuePairList>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsCSSValuePairList,
                                                root::mozilla::DefaultDelete<root::nsCSSValuePairList>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsCSSValuePairList,
                         root::mozilla::DefaultDelete<root::nsCSSValuePairList>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_85() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::mozilla::FramePropertyTable_PropertyValue>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::FramePropertyTable_PropertyValue>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::mozilla::FramePropertyTable_PropertyValue>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::FramePropertyTable_PropertyValue>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_86() {
        assert_eq!(::std::mem::size_of::<root::nsPtrHashKey<root::nsIFrame>>()
                   , 16usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsPtrHashKey<root::nsIFrame> ) ));
        assert_eq!(::std::mem::align_of::<root::nsPtrHashKey<root::nsIFrame>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsPtrHashKey<root::nsIFrame> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_87() {
        assert_eq!(::std::mem::size_of::<[u64; 5usize]>() , 40usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u64; 5usize] ) ));
        assert_eq!(::std::mem::align_of::<[u64; 5usize]>() , 8usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u64; 5usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_88() {
        assert_eq!(::std::mem::size_of::<root::mozilla::OwningNonNull<root::mozilla::EffectCompositor_AnimationStyleRuleProcessor>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::OwningNonNull<root::mozilla::EffectCompositor_AnimationStyleRuleProcessor>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::OwningNonNull<root::mozilla::EffectCompositor_AnimationStyleRuleProcessor>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::OwningNonNull<root::mozilla::EffectCompositor_AnimationStyleRuleProcessor>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_89() {
        assert_eq!(::std::mem::size_of::<[u64; 2usize]>() , 16usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u64; 2usize] ) ));
        assert_eq!(::std::mem::align_of::<[u64; 2usize]>() , 8usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u64; 2usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_90() {
        assert_eq!(::std::mem::size_of::<u64>() , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! ( u64 )
                   ));
        assert_eq!(::std::mem::align_of::<u64>() , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   u64 ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_91() {
        assert_eq!(::std::mem::size_of::<[u32; 3usize]>() , 12usize , concat !
                   (
                   "Size of template specialization: " , stringify ! (
                   [u32; 3usize] ) ));
        assert_eq!(::std::mem::align_of::<[u32; 3usize]>() , 4usize , concat !
                   (
                   "Alignment of template specialization: " , stringify ! (
                   [u32; 3usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_92() {
        assert_eq!(::std::mem::size_of::<root::already_AddRefed<root::nsStyleImageRequest>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsStyleImageRequest> ) ));
        assert_eq!(::std::mem::align_of::<root::already_AddRefed<root::nsStyleImageRequest>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::already_AddRefed<root::nsStyleImageRequest> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_93() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete<root::nsStyleSides>>()
                   , 1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete<root::nsStyleSides> ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete<root::nsStyleSides>>()
                   , 1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete<root::nsStyleSides> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_94() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsStyleSides,
                                               root::mozilla::DefaultDelete<root::nsStyleSides>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsStyleSides,
                         root::mozilla::DefaultDelete<root::nsStyleSides>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsStyleSides,
                                                root::mozilla::DefaultDelete<root::nsStyleSides>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::UniquePtr<root::nsStyleSides,
                         root::mozilla::DefaultDelete<root::nsStyleSides>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_95() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete<root::CachedBorderImageData>>()
                   , 1usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete<root::CachedBorderImageData> )
                   ));
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete<root::CachedBorderImageData>>()
                   , 1usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::mozilla::DefaultDelete<root::CachedBorderImageData> )
                   ));
    }
    #[test]
    fn __bindgen_test_layout_template_96() {
        assert_eq!(::std::mem::size_of::<root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr>>()
                   , 32usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr> ) ));
        assert_eq!(::std::mem::align_of::<root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_97() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::std::pair<::nsstring::nsStringRepr,
                                                     ::nsstring::nsStringRepr>>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr>>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::std::pair<::nsstring::nsStringRepr,
                                                      ::nsstring::nsStringRepr>>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr>>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_98() {
        assert_eq!(::std::mem::size_of::<[u64; 18usize]>() , 144usize , concat
                   ! (
                   "Size of template specialization: " , stringify ! (
                   [u64; 18usize] ) ));
        assert_eq!(::std::mem::align_of::<[u64; 18usize]>() , 8usize , concat
                   ! (
                   "Alignment of template specialization: " , stringify ! (
                   [u64; 18usize] ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_99() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::mozilla::DisplayItemClip_RoundedRect>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::DisplayItemClip_RoundedRect>
                   ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::mozilla::DisplayItemClip_RoundedRect>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<root::mozilla::DisplayItemClip_RoundedRect>
                   ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_100() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::DOMRect>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DOMRect> ) ));
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::DOMRect>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::RefPtr<root::mozilla::dom::DOMRect> ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_101() {
        assert_eq!(::std::mem::size_of::<u64>() , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! ( u64 )
                   ));
        assert_eq!(::std::mem::align_of::<u64>() , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   u64 ) ));
    }
    #[test]
    fn __bindgen_test_layout_template_102() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::mozilla::css::DocumentRule>>()
                   , 8usize , concat ! (
                   "Size of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::css::DocumentRule> ) ));
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::mozilla::css::DocumentRule>>()
                   , 8usize , concat ! (
                   "Alignment of template specialization: " , stringify ! (
                   root::nsTArray<*mut root::mozilla::css::DocumentRule> ) ));
    }
}
