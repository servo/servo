/* automatically generated by rust-bindgen */

pub use self::root::*;
pub use self::root::mozilla::*;
pub use self::root::mozilla::css::*;
pub use self::root::mozilla::dom::*;
use atomic_refcell::AtomicRefCell;
use data::ElementData;
pub type ServoUnsafeCell<T> = ::std::cell::UnsafeCell<T>;
pub type ServoCell<T> = ::std::cell::Cell<T>;
pub type ServoNodeData = AtomicRefCell<ElementData>;

pub mod root {
    #[repr(C)]
    pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
    impl <T> __BindgenUnionField<T> {
        #[inline]
        pub fn new() -> Self {
            __BindgenUnionField(::std::marker::PhantomData)
        }
        #[inline]
        pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
        #[inline]
        pub unsafe fn as_mut(&mut self) -> &mut T {
            ::std::mem::transmute(self)
        }
    }
    impl <T> ::std::default::Default for __BindgenUnionField<T> {
        #[inline]
        fn default() -> Self { Self::new() }
    }
    impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
        #[inline]
        fn clone(&self) -> Self { Self::new() }
    }
    impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
    impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            fmt.write_str("__BindgenUnionField")
        }
    }
    #[allow(unused_imports)]
    use self::super::root;
    pub const NS_FONT_STYLE_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_STYLE_ITALIC: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_STYLE_OBLIQUE: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_WEIGHT_NORMAL: ::std::os::raw::c_uint = 400;
    pub const NS_FONT_WEIGHT_BOLD: ::std::os::raw::c_uint = 700;
    pub const NS_FONT_WEIGHT_THIN: ::std::os::raw::c_uint = 100;
    pub const NS_FONT_STRETCH_ULTRA_CONDENSED: ::std::os::raw::c_int = -4;
    pub const NS_FONT_STRETCH_EXTRA_CONDENSED: ::std::os::raw::c_int = -3;
    pub const NS_FONT_STRETCH_CONDENSED: ::std::os::raw::c_int = -2;
    pub const NS_FONT_STRETCH_SEMI_CONDENSED: ::std::os::raw::c_int = -1;
    pub const NS_FONT_STRETCH_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_STRETCH_SEMI_EXPANDED: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_STRETCH_EXPANDED: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_STRETCH_EXTRA_EXPANDED: ::std::os::raw::c_uint = 3;
    pub const NS_FONT_STRETCH_ULTRA_EXPANDED: ::std::os::raw::c_uint = 4;
    pub const NS_FONT_SMOOTHING_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_SMOOTHING_GRAYSCALE: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_KERNING_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_KERNING_NONE: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_KERNING_NORMAL: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_SYNTHESIS_WEIGHT: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_SYNTHESIS_STYLE: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_DISPLAY_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_DISPLAY_BLOCK: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_DISPLAY_SWAP: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_DISPLAY_FALLBACK: ::std::os::raw::c_uint = 3;
    pub const NS_FONT_DISPLAY_OPTIONAL: ::std::os::raw::c_uint = 4;
    pub const NS_FONT_VARIANT_CAPS_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_CAPS_SMALLCAPS: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_VARIANT_CAPS_ALLSMALL: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_VARIANT_CAPS_PETITECAPS: ::std::os::raw::c_uint = 3;
    pub const NS_FONT_VARIANT_CAPS_ALLPETITE: ::std::os::raw::c_uint = 4;
    pub const NS_FONT_VARIANT_CAPS_TITLING: ::std::os::raw::c_uint = 5;
    pub const NS_FONT_VARIANT_CAPS_UNICASE: ::std::os::raw::c_uint = 6;
    pub const NS_FONT_VARIANT_POSITION_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_POSITION_SUPER: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_VARIANT_POSITION_SUB: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_VARIANT_WIDTH_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_WIDTH_FULL: ::std::os::raw::c_uint = 1;
    pub const NS_FONT_VARIANT_WIDTH_HALF: ::std::os::raw::c_uint = 2;
    pub const NS_FONT_VARIANT_WIDTH_THIRD: ::std::os::raw::c_uint = 3;
    pub const NS_FONT_VARIANT_WIDTH_QUARTER: ::std::os::raw::c_uint = 4;
    pub const NS_FONT_SUBSCRIPT_OFFSET_RATIO: f32 = 0.2;
    pub const NS_FONT_SUPERSCRIPT_OFFSET_RATIO: f32 = 0.34;
    pub const NS_FONT_SUB_SUPER_SIZE_RATIO_SMALL: f32 = 0.82;
    pub const NS_FONT_SUB_SUPER_SIZE_RATIO_LARGE: f32 = 0.667;
    pub const NS_FONT_SUB_SUPER_SMALL_SIZE: f32 = 20.;
    pub const NS_FONT_SUB_SUPER_LARGE_SIZE: f32 = 45.;
    pub const NS_THEME_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_THEME_BUTTON: ::std::os::raw::c_uint = 1;
    pub const NS_THEME_RADIO: ::std::os::raw::c_uint = 2;
    pub const NS_THEME_CHECKBOX: ::std::os::raw::c_uint = 3;
    pub const NS_THEME_BUTTON_BEVEL: ::std::os::raw::c_uint = 7;
    pub const NS_THEME_FOCUS_OUTLINE: ::std::os::raw::c_uint = 8;
    pub const NS_THEME_TOOLBOX: ::std::os::raw::c_uint = 11;
    pub const NS_THEME_TOOLBAR: ::std::os::raw::c_uint = 12;
    pub const NS_THEME_TOOLBARBUTTON: ::std::os::raw::c_uint = 13;
    pub const NS_THEME_DUALBUTTON: ::std::os::raw::c_uint = 14;
    pub const NS_THEME_TOOLBARBUTTON_DROPDOWN: ::std::os::raw::c_uint = 15;
    pub const NS_THEME_BUTTON_ARROW_UP: ::std::os::raw::c_uint = 16;
    pub const NS_THEME_BUTTON_ARROW_DOWN: ::std::os::raw::c_uint = 17;
    pub const NS_THEME_BUTTON_ARROW_NEXT: ::std::os::raw::c_uint = 18;
    pub const NS_THEME_BUTTON_ARROW_PREVIOUS: ::std::os::raw::c_uint = 19;
    pub const NS_THEME_SEPARATOR: ::std::os::raw::c_uint = 20;
    pub const NS_THEME_TOOLBARGRIPPER: ::std::os::raw::c_uint = 21;
    pub const NS_THEME_SPLITTER: ::std::os::raw::c_uint = 22;
    pub const NS_THEME_STATUSBAR: ::std::os::raw::c_uint = 23;
    pub const NS_THEME_STATUSBARPANEL: ::std::os::raw::c_uint = 24;
    pub const NS_THEME_RESIZERPANEL: ::std::os::raw::c_uint = 25;
    pub const NS_THEME_RESIZER: ::std::os::raw::c_uint = 26;
    pub const NS_THEME_LISTBOX: ::std::os::raw::c_uint = 31;
    pub const NS_THEME_LISTITEM: ::std::os::raw::c_uint = 32;
    pub const NS_THEME_TREEVIEW: ::std::os::raw::c_uint = 41;
    pub const NS_THEME_TREEITEM: ::std::os::raw::c_uint = 42;
    pub const NS_THEME_TREETWISTY: ::std::os::raw::c_uint = 43;
    pub const NS_THEME_TREELINE: ::std::os::raw::c_uint = 44;
    pub const NS_THEME_TREEHEADER: ::std::os::raw::c_uint = 45;
    pub const NS_THEME_TREEHEADERCELL: ::std::os::raw::c_uint = 46;
    pub const NS_THEME_TREEHEADERSORTARROW: ::std::os::raw::c_uint = 47;
    pub const NS_THEME_TREETWISTYOPEN: ::std::os::raw::c_uint = 48;
    pub const NS_THEME_PROGRESSBAR: ::std::os::raw::c_uint = 51;
    pub const NS_THEME_PROGRESSCHUNK: ::std::os::raw::c_uint = 52;
    pub const NS_THEME_PROGRESSBAR_VERTICAL: ::std::os::raw::c_uint = 53;
    pub const NS_THEME_PROGRESSCHUNK_VERTICAL: ::std::os::raw::c_uint = 54;
    pub const NS_THEME_METERBAR: ::std::os::raw::c_uint = 55;
    pub const NS_THEME_METERCHUNK: ::std::os::raw::c_uint = 56;
    pub const NS_THEME_TAB: ::std::os::raw::c_uint = 61;
    pub const NS_THEME_TABPANEL: ::std::os::raw::c_uint = 62;
    pub const NS_THEME_TABPANELS: ::std::os::raw::c_uint = 65;
    pub const NS_THEME_TAB_SCROLL_ARROW_BACK: ::std::os::raw::c_uint = 66;
    pub const NS_THEME_TAB_SCROLL_ARROW_FORWARD: ::std::os::raw::c_uint = 67;
    pub const NS_THEME_TOOLTIP: ::std::os::raw::c_uint = 71;
    pub const NS_THEME_SPINNER: ::std::os::raw::c_uint = 72;
    pub const NS_THEME_SPINNER_UPBUTTON: ::std::os::raw::c_uint = 73;
    pub const NS_THEME_SPINNER_DOWNBUTTON: ::std::os::raw::c_uint = 74;
    pub const NS_THEME_SPINNER_TEXTFIELD: ::std::os::raw::c_uint = 75;
    pub const NS_THEME_NUMBER_INPUT: ::std::os::raw::c_uint = 76;
    pub const NS_THEME_SCROLLBAR: ::std::os::raw::c_uint = 80;
    pub const NS_THEME_SCROLLBAR_SMALL: ::std::os::raw::c_uint = 81;
    pub const NS_THEME_SCROLLBAR_HORIZONTAL: ::std::os::raw::c_uint = 82;
    pub const NS_THEME_SCROLLBAR_VERTICAL: ::std::os::raw::c_uint = 83;
    pub const NS_THEME_SCROLLBARBUTTON_UP: ::std::os::raw::c_uint = 84;
    pub const NS_THEME_SCROLLBARBUTTON_DOWN: ::std::os::raw::c_uint = 85;
    pub const NS_THEME_SCROLLBARBUTTON_LEFT: ::std::os::raw::c_uint = 86;
    pub const NS_THEME_SCROLLBARBUTTON_RIGHT: ::std::os::raw::c_uint = 87;
    pub const NS_THEME_SCROLLBARTRACK_HORIZONTAL: ::std::os::raw::c_uint = 88;
    pub const NS_THEME_SCROLLBARTRACK_VERTICAL: ::std::os::raw::c_uint = 89;
    pub const NS_THEME_SCROLLBARTHUMB_HORIZONTAL: ::std::os::raw::c_uint = 90;
    pub const NS_THEME_SCROLLBARTHUMB_VERTICAL: ::std::os::raw::c_uint = 91;
    pub const NS_THEME_SCROLLBAR_NON_DISAPPEARING: ::std::os::raw::c_uint =
        92;
    pub const NS_THEME_TEXTFIELD: ::std::os::raw::c_uint = 95;
    pub const NS_THEME_CARET: ::std::os::raw::c_uint = 96;
    pub const NS_THEME_TEXTFIELD_MULTILINE: ::std::os::raw::c_uint = 97;
    pub const NS_THEME_SEARCHFIELD: ::std::os::raw::c_uint = 98;
    pub const NS_THEME_MENULIST: ::std::os::raw::c_uint = 101;
    pub const NS_THEME_MENULIST_BUTTON: ::std::os::raw::c_uint = 102;
    pub const NS_THEME_MENULIST_TEXT: ::std::os::raw::c_uint = 103;
    pub const NS_THEME_MENULIST_TEXTFIELD: ::std::os::raw::c_uint = 104;
    pub const NS_THEME_SCALE_HORIZONTAL: ::std::os::raw::c_uint = 111;
    pub const NS_THEME_SCALE_VERTICAL: ::std::os::raw::c_uint = 112;
    pub const NS_THEME_SCALETHUMB_HORIZONTAL: ::std::os::raw::c_uint = 113;
    pub const NS_THEME_SCALETHUMB_VERTICAL: ::std::os::raw::c_uint = 114;
    pub const NS_THEME_SCALETHUMBSTART: ::std::os::raw::c_uint = 115;
    pub const NS_THEME_SCALETHUMBEND: ::std::os::raw::c_uint = 116;
    pub const NS_THEME_SCALETHUMBTICK: ::std::os::raw::c_uint = 117;
    pub const NS_THEME_RANGE: ::std::os::raw::c_uint = 120;
    pub const NS_THEME_RANGE_THUMB: ::std::os::raw::c_uint = 121;
    pub const NS_THEME_GROUPBOX: ::std::os::raw::c_uint = 149;
    pub const NS_THEME_CHECKBOX_CONTAINER: ::std::os::raw::c_uint = 150;
    pub const NS_THEME_RADIO_CONTAINER: ::std::os::raw::c_uint = 151;
    pub const NS_THEME_CHECKBOX_LABEL: ::std::os::raw::c_uint = 152;
    pub const NS_THEME_RADIO_LABEL: ::std::os::raw::c_uint = 153;
    pub const NS_THEME_BUTTON_FOCUS: ::std::os::raw::c_uint = 154;
    pub const NS_THEME_WINDOW: ::std::os::raw::c_uint = 200;
    pub const NS_THEME_DIALOG: ::std::os::raw::c_uint = 201;
    pub const NS_THEME_MENUBAR: ::std::os::raw::c_uint = 210;
    pub const NS_THEME_MENUPOPUP: ::std::os::raw::c_uint = 211;
    pub const NS_THEME_MENUITEM: ::std::os::raw::c_uint = 212;
    pub const NS_THEME_CHECKMENUITEM: ::std::os::raw::c_uint = 213;
    pub const NS_THEME_RADIOMENUITEM: ::std::os::raw::c_uint = 214;
    pub const NS_THEME_MENUCHECKBOX: ::std::os::raw::c_uint = 215;
    pub const NS_THEME_MENURADIO: ::std::os::raw::c_uint = 216;
    pub const NS_THEME_MENUSEPARATOR: ::std::os::raw::c_uint = 217;
    pub const NS_THEME_MENUARROW: ::std::os::raw::c_uint = 218;
    pub const NS_THEME_MENUIMAGE: ::std::os::raw::c_uint = 219;
    pub const NS_THEME_MENUITEMTEXT: ::std::os::raw::c_uint = 220;
    pub const NS_THEME_WIN_COMMUNICATIONS_TOOLBOX: ::std::os::raw::c_uint =
        221;
    pub const NS_THEME_WIN_MEDIA_TOOLBOX: ::std::os::raw::c_uint = 222;
    pub const NS_THEME_WIN_BROWSERTABBAR_TOOLBOX: ::std::os::raw::c_uint =
        223;
    pub const NS_THEME_MAC_FULLSCREEN_BUTTON: ::std::os::raw::c_uint = 226;
    pub const NS_THEME_MAC_HELP_BUTTON: ::std::os::raw::c_uint = 227;
    pub const NS_THEME_WIN_BORDERLESS_GLASS: ::std::os::raw::c_uint = 229;
    pub const NS_THEME_WIN_GLASS: ::std::os::raw::c_uint = 230;
    pub const NS_THEME_WINDOW_TITLEBAR: ::std::os::raw::c_uint = 231;
    pub const NS_THEME_WINDOW_TITLEBAR_MAXIMIZED: ::std::os::raw::c_uint =
        232;
    pub const NS_THEME_WINDOW_FRAME_LEFT: ::std::os::raw::c_uint = 233;
    pub const NS_THEME_WINDOW_FRAME_RIGHT: ::std::os::raw::c_uint = 234;
    pub const NS_THEME_WINDOW_FRAME_BOTTOM: ::std::os::raw::c_uint = 235;
    pub const NS_THEME_WINDOW_BUTTON_CLOSE: ::std::os::raw::c_uint = 236;
    pub const NS_THEME_WINDOW_BUTTON_MINIMIZE: ::std::os::raw::c_uint = 237;
    pub const NS_THEME_WINDOW_BUTTON_MAXIMIZE: ::std::os::raw::c_uint = 238;
    pub const NS_THEME_WINDOW_BUTTON_RESTORE: ::std::os::raw::c_uint = 239;
    pub const NS_THEME_WINDOW_BUTTON_BOX: ::std::os::raw::c_uint = 240;
    pub const NS_THEME_WINDOW_BUTTON_BOX_MAXIMIZED: ::std::os::raw::c_uint =
        241;
    pub const NS_THEME_WIN_EXCLUDE_GLASS: ::std::os::raw::c_uint = 242;
    pub const NS_THEME_MAC_VIBRANCY_LIGHT: ::std::os::raw::c_uint = 243;
    pub const NS_THEME_MAC_VIBRANCY_DARK: ::std::os::raw::c_uint = 244;
    pub const NS_THEME_MAC_DISCLOSURE_BUTTON_OPEN: ::std::os::raw::c_uint =
        245;
    pub const NS_THEME_MAC_DISCLOSURE_BUTTON_CLOSED: ::std::os::raw::c_uint =
        246;
    pub const NS_THEME_GTK_INFO_BAR: ::std::os::raw::c_uint = 247;
    pub const NS_THEME_MAC_SOURCE_LIST: ::std::os::raw::c_uint = 248;
    pub const NS_THEME_MAC_SOURCE_LIST_SELECTION: ::std::os::raw::c_uint =
        249;
    pub const NS_THEME_MAC_ACTIVE_SOURCE_LIST_SELECTION:
              ::std::os::raw::c_uint =
        250;
    pub const NS_FONT_VARIANT_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_FONT_VARIANT_SMALL_CAPS: ::std::os::raw::c_uint = 1;
    pub const NS_CORNER_TOP_LEFT_X: ::std::os::raw::c_uint = 0;
    pub const NS_CORNER_TOP_LEFT_Y: ::std::os::raw::c_uint = 1;
    pub const NS_CORNER_TOP_RIGHT_X: ::std::os::raw::c_uint = 2;
    pub const NS_CORNER_TOP_RIGHT_Y: ::std::os::raw::c_uint = 3;
    pub const NS_CORNER_BOTTOM_RIGHT_X: ::std::os::raw::c_uint = 4;
    pub const NS_CORNER_BOTTOM_RIGHT_Y: ::std::os::raw::c_uint = 5;
    pub const NS_CORNER_BOTTOM_LEFT_X: ::std::os::raw::c_uint = 6;
    pub const NS_CORNER_BOTTOM_LEFT_Y: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_STACK_SIZING_IGNORE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_STACK_SIZING_STRETCH_TO_FIT: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_AZIMUTH_LEFT_SIDE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_AZIMUTH_FAR_LEFT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_AZIMUTH_LEFT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_AZIMUTH_CENTER_LEFT: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_AZIMUTH_CENTER: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_AZIMUTH_CENTER_RIGHT: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_AZIMUTH_RIGHT: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_AZIMUTH_FAR_RIGHT: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_AZIMUTH_RIGHT_SIDE: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_AZIMUTH_BEHIND: ::std::os::raw::c_uint = 128;
    pub const NS_STYLE_AZIMUTH_LEFTWARDS: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_AZIMUTH_RIGHTWARDS: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_ELEVATION_BELOW: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_ELEVATION_LEVEL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_ELEVATION_ABOVE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_ELEVATION_HIGHER: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_ELEVATION_LOWER: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_PITCH_X_LOW: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PITCH_LOW: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_PITCH_MEDIUM: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_PITCH_HIGH: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_PITCH_X_HIGH: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_SPEAK_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SPEAK_NORMAL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SPEAK_SPELL_OUT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_SPEAK_HEADER_ONCE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SPEAK_HEADER_ALWAYS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SPEAK_NUMERAL_DIGITS: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SPEAK_NUMERAL_CONTINUOUS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SPEAK_PUNCTUATION_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SPEAK_PUNCTUATION_CODE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SPEECH_RATE_X_SLOW: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SPEECH_RATE_SLOW: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SPEECH_RATE_MEDIUM: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_SPEECH_RATE_FAST: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_SPEECH_RATE_X_FAST: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_SPEECH_RATE_FASTER: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_SPEECH_RATE_SLOWER: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_VOLUME_SILENT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_VOLUME_X_SOFT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_VOLUME_SOFT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_VOLUME_MEDIUM: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_VOLUME_LOUD: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_VOLUME_X_LOUD: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_COLOR_INHERIT_FROM_BODY: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_WILL_CHANGE_STACKING_CONTEXT: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_WILL_CHANGE_TRANSFORM: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_WILL_CHANGE_SCROLL: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_WILL_CHANGE_OPACITY: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_WILL_CHANGE_FIXPOS_CB: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_WILL_CHANGE_ABSPOS_CB: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_ANIMATION_ITERATION_COUNT_INFINITE:
              ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_ANIMATION_PLAY_STATE_RUNNING: ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_ANIMATION_PLAY_STATE_PAUSED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_IMAGELAYER_ATTACHMENT_SCROLL: ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_IMAGELAYER_ATTACHMENT_FIXED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_IMAGELAYER_ATTACHMENT_LOCAL: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_IMAGELAYER_CLIP_MOZ_ALMOST_PADDING:
              ::std::os::raw::c_uint =
        127;
    pub const NS_STYLE_IMAGELAYER_POSITION_CENTER: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_IMAGELAYER_POSITION_TOP: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_IMAGELAYER_POSITION_BOTTOM: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_IMAGELAYER_POSITION_LEFT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_IMAGELAYER_POSITION_RIGHT: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_IMAGELAYER_REPEAT_NO_REPEAT: ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_IMAGELAYER_REPEAT_REPEAT_X: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_IMAGELAYER_REPEAT_REPEAT_Y: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_IMAGELAYER_REPEAT_REPEAT: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_IMAGELAYER_REPEAT_SPACE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_IMAGELAYER_REPEAT_ROUND: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_IMAGELAYER_SIZE_CONTAIN: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_IMAGELAYER_SIZE_COVER: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_MASK_MODE_ALPHA: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_MASK_MODE_LUMINANCE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_MASK_MODE_MATCH_SOURCE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_BG_INLINE_POLICY_EACH_BOX: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BG_INLINE_POLICY_CONTINUOUS: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_BG_INLINE_POLICY_BOUNDING_BOX: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_BORDER_COLLAPSE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BORDER_SEPARATE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BORDER_WIDTH_THIN: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BORDER_WIDTH_MEDIUM: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BORDER_WIDTH_THICK: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_BORDER_STYLE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BORDER_STYLE_GROOVE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BORDER_STYLE_RIDGE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_BORDER_STYLE_DOTTED: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_BORDER_STYLE_DASHED: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_BORDER_STYLE_SOLID: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_BORDER_STYLE_DOUBLE: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_BORDER_STYLE_INSET: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_BORDER_STYLE_OUTSET: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_BORDER_STYLE_HIDDEN: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_BORDER_STYLE_AUTO: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_BORDER_IMAGE_REPEAT_STRETCH: ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_BORDER_IMAGE_REPEAT_REPEAT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BORDER_IMAGE_REPEAT_ROUND: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_BORDER_IMAGE_REPEAT_SPACE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_BORDER_IMAGE_SLICE_NOFILL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BORDER_IMAGE_SLICE_FILL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CONTENT_OPEN_QUOTE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CONTENT_CLOSE_QUOTE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CONTENT_NO_OPEN_QUOTE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_CONTENT_NO_CLOSE_QUOTE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_CONTENT_ALT_CONTENT: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_CURSOR_AUTO: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CURSOR_CROSSHAIR: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_CURSOR_DEFAULT: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_CURSOR_POINTER: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_CURSOR_MOVE: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_CURSOR_E_RESIZE: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_CURSOR_NE_RESIZE: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_CURSOR_NW_RESIZE: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_CURSOR_N_RESIZE: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_CURSOR_SE_RESIZE: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_CURSOR_SW_RESIZE: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_CURSOR_S_RESIZE: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_CURSOR_W_RESIZE: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_CURSOR_TEXT: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_CURSOR_WAIT: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_CURSOR_HELP: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_CURSOR_COPY: ::std::os::raw::c_uint = 17;
    pub const NS_STYLE_CURSOR_ALIAS: ::std::os::raw::c_uint = 18;
    pub const NS_STYLE_CURSOR_CONTEXT_MENU: ::std::os::raw::c_uint = 19;
    pub const NS_STYLE_CURSOR_CELL: ::std::os::raw::c_uint = 20;
    pub const NS_STYLE_CURSOR_GRAB: ::std::os::raw::c_uint = 21;
    pub const NS_STYLE_CURSOR_GRABBING: ::std::os::raw::c_uint = 22;
    pub const NS_STYLE_CURSOR_SPINNING: ::std::os::raw::c_uint = 23;
    pub const NS_STYLE_CURSOR_ZOOM_IN: ::std::os::raw::c_uint = 24;
    pub const NS_STYLE_CURSOR_ZOOM_OUT: ::std::os::raw::c_uint = 25;
    pub const NS_STYLE_CURSOR_NOT_ALLOWED: ::std::os::raw::c_uint = 26;
    pub const NS_STYLE_CURSOR_COL_RESIZE: ::std::os::raw::c_uint = 27;
    pub const NS_STYLE_CURSOR_ROW_RESIZE: ::std::os::raw::c_uint = 28;
    pub const NS_STYLE_CURSOR_NO_DROP: ::std::os::raw::c_uint = 29;
    pub const NS_STYLE_CURSOR_VERTICAL_TEXT: ::std::os::raw::c_uint = 30;
    pub const NS_STYLE_CURSOR_ALL_SCROLL: ::std::os::raw::c_uint = 31;
    pub const NS_STYLE_CURSOR_NESW_RESIZE: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_CURSOR_NWSE_RESIZE: ::std::os::raw::c_uint = 33;
    pub const NS_STYLE_CURSOR_NS_RESIZE: ::std::os::raw::c_uint = 34;
    pub const NS_STYLE_CURSOR_EW_RESIZE: ::std::os::raw::c_uint = 35;
    pub const NS_STYLE_CURSOR_NONE: ::std::os::raw::c_uint = 36;
    pub const NS_STYLE_DIRECTION_LTR: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_DIRECTION_RTL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WRITING_MODE_HORIZONTAL_TB: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_WRITING_MODE_VERTICAL_RL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WRITING_MODE_VERTICAL_LR: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_WRITING_MODE_SIDEWAYS_MASK: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_WRITING_MODE_SIDEWAYS_RL: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_WRITING_MODE_SIDEWAYS_LR: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_CONTAIN_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CONTAIN_STRICT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CONTAIN_LAYOUT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_CONTAIN_STYLE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_CONTAIN_PAINT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_CONTAIN_ALL_BITS: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_ALIGN_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_ALIGN_NORMAL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_ALIGN_START: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_ALIGN_END: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_ALIGN_FLEX_START: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_ALIGN_FLEX_END: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_ALIGN_CENTER: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_ALIGN_LEFT: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_ALIGN_RIGHT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_ALIGN_BASELINE: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_ALIGN_LAST_BASELINE: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_ALIGN_STRETCH: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_ALIGN_SELF_START: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_ALIGN_SELF_END: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_ALIGN_SPACE_BETWEEN: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_ALIGN_SPACE_AROUND: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_ALIGN_SPACE_EVENLY: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_ALIGN_LEGACY: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_ALIGN_SAFE: ::std::os::raw::c_uint = 64;
    pub const NS_STYLE_ALIGN_UNSAFE: ::std::os::raw::c_uint = 128;
    pub const NS_STYLE_ALIGN_FLAG_BITS: ::std::os::raw::c_uint = 224;
    pub const NS_STYLE_ALIGN_ALL_BITS: ::std::os::raw::c_uint = 255;
    pub const NS_STYLE_ALIGN_ALL_SHIFT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_JUSTIFY_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_JUSTIFY_NORMAL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_JUSTIFY_START: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_JUSTIFY_END: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_JUSTIFY_FLEX_START: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_JUSTIFY_FLEX_END: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_JUSTIFY_CENTER: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_JUSTIFY_LEFT: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_JUSTIFY_RIGHT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_JUSTIFY_BASELINE: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_JUSTIFY_LAST_BASELINE: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_JUSTIFY_STRETCH: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_JUSTIFY_SELF_START: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_JUSTIFY_SELF_END: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_JUSTIFY_SPACE_BETWEEN: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_JUSTIFY_SPACE_AROUND: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_JUSTIFY_SPACE_EVENLY: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_JUSTIFY_LEGACY: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_JUSTIFY_SAFE: ::std::os::raw::c_uint = 64;
    pub const NS_STYLE_JUSTIFY_UNSAFE: ::std::os::raw::c_uint = 128;
    pub const NS_STYLE_JUSTIFY_FLAG_BITS: ::std::os::raw::c_uint = 224;
    pub const NS_STYLE_JUSTIFY_ALL_BITS: ::std::os::raw::c_uint = 255;
    pub const NS_STYLE_JUSTIFY_ALL_SHIFT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_FLEX_DIRECTION_ROW: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FLEX_DIRECTION_ROW_REVERSE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FLEX_DIRECTION_COLUMN: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FLEX_DIRECTION_COLUMN_REVERSE: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_FLEX_WRAP_NOWRAP: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FLEX_WRAP_WRAP: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FLEX_WRAP_WRAP_REVERSE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_ORDER_INITIAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_JUSTIFY_CONTENT_FLEX_START: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_JUSTIFY_CONTENT_FLEX_END: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_JUSTIFY_CONTENT_CENTER: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_JUSTIFY_CONTENT_SPACE_BETWEEN: ::std::os::raw::c_uint =
        14;
    pub const NS_STYLE_JUSTIFY_CONTENT_SPACE_AROUND: ::std::os::raw::c_uint =
        15;
    pub const NS_STYLE_FILTER_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FILTER_URL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FILTER_BLUR: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FILTER_BRIGHTNESS: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_FILTER_CONTRAST: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_FILTER_GRAYSCALE: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_FILTER_INVERT: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_FILTER_OPACITY: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_FILTER_SATURATE: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_FILTER_SEPIA: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_FILTER_HUE_ROTATE: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_FILTER_DROP_SHADOW: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_FONT_STYLE_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FONT_STYLE_ITALIC: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FONT_STYLE_OBLIQUE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FONT_WEIGHT_NORMAL: ::std::os::raw::c_uint = 400;
    pub const NS_STYLE_FONT_WEIGHT_BOLD: ::std::os::raw::c_uint = 700;
    pub const NS_STYLE_FONT_WEIGHT_BOLDER: ::std::os::raw::c_int = -1;
    pub const NS_STYLE_FONT_WEIGHT_LIGHTER: ::std::os::raw::c_int = -2;
    pub const NS_STYLE_FONT_SIZE_XXSMALL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FONT_SIZE_XSMALL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FONT_SIZE_SMALL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FONT_SIZE_MEDIUM: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_FONT_SIZE_LARGE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_FONT_SIZE_XLARGE: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_FONT_SIZE_XXLARGE: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_FONT_SIZE_XXXLARGE: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_FONT_SIZE_LARGER: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_FONT_SIZE_SMALLER: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_FONT_STRETCH_ULTRA_CONDENSED: ::std::os::raw::c_int =
        -4;
    pub const NS_STYLE_FONT_STRETCH_EXTRA_CONDENSED: ::std::os::raw::c_int =
        -3;
    pub const NS_STYLE_FONT_STRETCH_CONDENSED: ::std::os::raw::c_int = -2;
    pub const NS_STYLE_FONT_STRETCH_SEMI_CONDENSED: ::std::os::raw::c_int =
        -1;
    pub const NS_STYLE_FONT_STRETCH_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FONT_STRETCH_SEMI_EXPANDED: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FONT_STRETCH_EXPANDED: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FONT_STRETCH_EXTRA_EXPANDED: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_FONT_STRETCH_ULTRA_EXPANDED: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_FONT_CAPTION: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FONT_ICON: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FONT_MENU: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_FONT_MESSAGE_BOX: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_FONT_SMALL_CAPTION: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_FONT_STATUS_BAR: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_FONT_WINDOW: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_FONT_DOCUMENT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_FONT_WORKSPACE: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_FONT_DESKTOP: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_FONT_INFO: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_FONT_DIALOG: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_FONT_BUTTON: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_FONT_PULL_DOWN_MENU: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_FONT_LIST: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_FONT_FIELD: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_GRID_AUTO_FLOW_ROW: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_GRID_AUTO_FLOW_COLUMN: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_GRID_AUTO_FLOW_DENSE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_GRID_TEMPLATE_SUBGRID: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_GRID_TRACK_BREADTH_MAX_CONTENT: ::std::os::raw::c_uint
              =
        1;
    pub const NS_STYLE_GRID_TRACK_BREADTH_MIN_CONTENT: ::std::os::raw::c_uint
              =
        2;
    pub const NS_STYLE_GRID_REPEAT_AUTO_FILL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_GRID_REPEAT_AUTO_FIT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WIDTH_MAX_CONTENT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_WIDTH_MIN_CONTENT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WIDTH_FIT_CONTENT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_WIDTH_AVAILABLE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_POSITION_STATIC: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_POSITION_RELATIVE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_POSITION_ABSOLUTE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_POSITION_FIXED: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_POSITION_STICKY: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_CLIP_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CLIP_RECT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CLIP_TYPE_MASK: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_CLIP_LEFT_AUTO: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_CLIP_TOP_AUTO: ::std::os::raw::c_uint = 32;
    pub const NS_STYLE_CLIP_RIGHT_AUTO: ::std::os::raw::c_uint = 64;
    pub const NS_STYLE_CLIP_BOTTOM_AUTO: ::std::os::raw::c_uint = 128;
    pub const NS_STYLE_FRAME_YES: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_FRAME_NO: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_FRAME_0: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_FRAME_1: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_FRAME_ON: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_FRAME_OFF: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_FRAME_AUTO: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_FRAME_SCROLL: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_FRAME_NOSCROLL: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_OVERFLOW_VISIBLE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_OVERFLOW_HIDDEN: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_OVERFLOW_SCROLL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_OVERFLOW_AUTO: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_OVERFLOW_CLIP: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_OVERFLOW_SCROLLBARS_HORIZONTAL: ::std::os::raw::c_uint
              =
        5;
    pub const NS_STYLE_OVERFLOW_SCROLLBARS_VERTICAL: ::std::os::raw::c_uint =
        6;
    pub const NS_STYLE_OVERFLOW_CLIP_BOX_PADDING_BOX: ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_OVERFLOW_CLIP_BOX_CONTENT_BOX: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_LIST_STYLE_CUSTOM: ::std::os::raw::c_int = -1;
    pub const NS_STYLE_LIST_STYLE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_LIST_STYLE_DISC: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_LIST_STYLE_CIRCLE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_LIST_STYLE_SQUARE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_LIST_STYLE_DECIMAL: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_LIST_STYLE_HEBREW: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_LIST_STYLE_JAPANESE_INFORMAL: ::std::os::raw::c_uint =
        6;
    pub const NS_STYLE_LIST_STYLE_JAPANESE_FORMAL: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_LIST_STYLE_KOREAN_HANGUL_FORMAL: ::std::os::raw::c_uint
              =
        8;
    pub const NS_STYLE_LIST_STYLE_KOREAN_HANJA_INFORMAL:
              ::std::os::raw::c_uint =
        9;
    pub const NS_STYLE_LIST_STYLE_KOREAN_HANJA_FORMAL: ::std::os::raw::c_uint
              =
        10;
    pub const NS_STYLE_LIST_STYLE_SIMP_CHINESE_INFORMAL:
              ::std::os::raw::c_uint =
        11;
    pub const NS_STYLE_LIST_STYLE_SIMP_CHINESE_FORMAL: ::std::os::raw::c_uint
              =
        12;
    pub const NS_STYLE_LIST_STYLE_TRAD_CHINESE_INFORMAL:
              ::std::os::raw::c_uint =
        13;
    pub const NS_STYLE_LIST_STYLE_TRAD_CHINESE_FORMAL: ::std::os::raw::c_uint
              =
        14;
    pub const NS_STYLE_LIST_STYLE_ETHIOPIC_NUMERIC: ::std::os::raw::c_uint =
        15;
    pub const NS_STYLE_LIST_STYLE_DISCLOSURE_CLOSED: ::std::os::raw::c_uint =
        16;
    pub const NS_STYLE_LIST_STYLE_DISCLOSURE_OPEN: ::std::os::raw::c_uint =
        17;
    pub const NS_STYLE_LIST_STYLE__MAX: ::std::os::raw::c_uint = 18;
    pub const NS_STYLE_LIST_STYLE_LOWER_ROMAN: ::std::os::raw::c_uint = 100;
    pub const NS_STYLE_LIST_STYLE_UPPER_ROMAN: ::std::os::raw::c_uint = 101;
    pub const NS_STYLE_LIST_STYLE_LOWER_ALPHA: ::std::os::raw::c_uint = 102;
    pub const NS_STYLE_LIST_STYLE_UPPER_ALPHA: ::std::os::raw::c_uint = 103;
    pub const NS_STYLE_LIST_STYLE_POSITION_INSIDE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_LIST_STYLE_POSITION_OUTSIDE: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_MARGIN_SIZE_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_POINTER_EVENTS_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_POINTER_EVENTS_VISIBLEPAINTED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_POINTER_EVENTS_VISIBLEFILL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_POINTER_EVENTS_VISIBLESTROKE: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_POINTER_EVENTS_VISIBLE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_POINTER_EVENTS_PAINTED: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_POINTER_EVENTS_FILL: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_POINTER_EVENTS_STROKE: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_POINTER_EVENTS_ALL: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_POINTER_EVENTS_AUTO: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_IMAGE_ORIENTATION_FLIP: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_IMAGE_ORIENTATION_FROM_IMAGE: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_ISOLATION_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_ISOLATION_ISOLATE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_OBJECT_FIT_FILL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_OBJECT_FIT_CONTAIN: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_OBJECT_FIT_COVER: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_OBJECT_FIT_NONE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_OBJECT_FIT_SCALE_DOWN: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_RESIZE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_RESIZE_BOTH: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_RESIZE_HORIZONTAL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_RESIZE_VERTICAL: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_TEXT_ALIGN_START: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_ALIGN_LEFT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_ALIGN_RIGHT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_ALIGN_CENTER: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_TEXT_ALIGN_JUSTIFY: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_TEXT_ALIGN_CHAR: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_TEXT_ALIGN_END: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_TEXT_ALIGN_AUTO: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_TEXT_ALIGN_MOZ_CENTER: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_TEXT_ALIGN_MOZ_RIGHT: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_TEXT_ALIGN_MOZ_LEFT: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_TEXT_ALIGN_MOZ_CENTER_OR_INHERIT:
              ::std::os::raw::c_uint =
        11;
    pub const NS_STYLE_TEXT_ALIGN_UNSAFE: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_TEXT_ALIGN_MATCH_PARENT: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_TEXT_DECORATION_LINE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE: ::std::os::raw::c_uint
              =
        1;
    pub const NS_STYLE_TEXT_DECORATION_LINE_OVERLINE: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH:
              ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_TEXT_DECORATION_LINE_BLINK: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_TEXT_DECORATION_LINE_PREF_ANCHORS:
              ::std::os::raw::c_uint =
        16;
    pub const NS_STYLE_TEXT_DECORATION_LINE_OVERRIDE_ALL:
              ::std::os::raw::c_uint =
        32;
    pub const NS_STYLE_TEXT_DECORATION_LINE_LINES_MASK: ::std::os::raw::c_uint
              =
        7;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_DOTTED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_DASHED: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_SOLID: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_DOUBLE: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_WAVY: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_TEXT_DECORATION_STYLE_MAX: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_TEXT_OVERFLOW_CLIP: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_OVERFLOW_ELLIPSIS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_OVERFLOW_STRING: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_TRANSFORM_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_TRANSFORM_CAPITALIZE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_TRANSFORM_LOWERCASE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_TRANSFORM_UPPERCASE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_TEXT_TRANSFORM_FULL_WIDTH: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_TOUCH_ACTION_NONE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TOUCH_ACTION_AUTO: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TOUCH_ACTION_PAN_X: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_TOUCH_ACTION_PAN_Y: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_TOUCH_ACTION_MANIPULATION: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_TOP_LAYER_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TOP_LAYER_TOP: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TRANSFORM_BOX_BORDER_BOX: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TRANSFORM_BOX_FILL_BOX: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TRANSFORM_BOX_VIEW_BOX: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE: ::std::os::raw::c_uint
              =
        0;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_LINEAR:
              ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN:
              ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_OUT:
              ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN_OUT:
              ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_STEP_START:
              ::std::os::raw::c_uint =
        5;
    pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_STEP_END:
              ::std::os::raw::c_uint =
        6;
    pub const NS_STYLE_VERTICAL_ALIGN_BASELINE: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_VERTICAL_ALIGN_SUB: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_VERTICAL_ALIGN_SUPER: ::std::os::raw::c_uint = 16;
    pub const NS_STYLE_VERTICAL_ALIGN_TOP: ::std::os::raw::c_uint = 17;
    pub const NS_STYLE_VERTICAL_ALIGN_TEXT_TOP: ::std::os::raw::c_uint = 18;
    pub const NS_STYLE_VERTICAL_ALIGN_MIDDLE: ::std::os::raw::c_uint = 19;
    pub const NS_STYLE_VERTICAL_ALIGN_TEXT_BOTTOM: ::std::os::raw::c_uint =
        20;
    pub const NS_STYLE_VERTICAL_ALIGN_BOTTOM: ::std::os::raw::c_uint = 21;
    pub const NS_STYLE_VERTICAL_ALIGN_MIDDLE_WITH_BASELINE:
              ::std::os::raw::c_uint =
        22;
    pub const NS_STYLE_VISIBILITY_HIDDEN: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_VISIBILITY_VISIBLE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_VISIBILITY_COLLAPSE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TABSIZE_INITIAL: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_WHITESPACE_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_WHITESPACE_PRE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WHITESPACE_NOWRAP: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_WHITESPACE_PRE_WRAP: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_WHITESPACE_PRE_LINE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_WHITESPACE_PRE_SPACE: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_WORDBREAK_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_WORDBREAK_BREAK_ALL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_WORDBREAK_KEEP_ALL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_OVERFLOWWRAP_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_OVERFLOWWRAP_BREAK_WORD: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_HYPHENS_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_HYPHENS_MANUAL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_HYPHENS_AUTO: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_RUBY_ALIGN_START: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_RUBY_ALIGN_CENTER: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_RUBY_ALIGN_SPACE_BETWEEN: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_RUBY_ALIGN_SPACE_AROUND: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_RUBY_POSITION_OVER: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_RUBY_POSITION_UNDER: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_RUBY_POSITION_INTER_CHARACTER: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_SIZE_ADJUST_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_SIZE_ADJUST_AUTO: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_ORIENTATION_MIXED: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_ORIENTATION_UPRIGHT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_ORIENTATION_SIDEWAYS: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_ALL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_DIGITS_2: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_DIGITS_3: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_DIGITS_4: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_LINE_HEIGHT_BLOCK_HEIGHT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_UNICODE_BIDI_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_UNICODE_BIDI_EMBED: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_UNICODE_BIDI_ISOLATE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_UNICODE_BIDI_BIDI_OVERRIDE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_UNICODE_BIDI_ISOLATE_OVERRIDE: ::std::os::raw::c_uint =
        6;
    pub const NS_STYLE_UNICODE_BIDI_PLAINTEXT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_TABLE_LAYOUT_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TABLE_LAYOUT_FIXED: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TABLE_EMPTY_CELLS_HIDE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TABLE_EMPTY_CELLS_SHOW: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CAPTION_SIDE_TOP: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CAPTION_SIDE_RIGHT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CAPTION_SIDE_BOTTOM: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_CAPTION_SIDE_LEFT: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE: ::std::os::raw::c_uint =
        5;
    pub const NS_STYLE_CELL_SCOPE_ROW: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CELL_SCOPE_COL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_CELL_SCOPE_ROWGROUP: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_CELL_SCOPE_COLGROUP: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_PAGE_MARKS_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_PAGE_MARKS_CROP: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PAGE_MARKS_REGISTER: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_PAGE_SIZE_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_PAGE_SIZE_PORTRAIT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PAGE_SIZE_LANDSCAPE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_PAGE_BREAK_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_PAGE_BREAK_ALWAYS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PAGE_BREAK_AVOID: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_PAGE_BREAK_LEFT: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_PAGE_BREAK_RIGHT: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_COLUMN_COUNT_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COLUMN_COUNT_UNLIMITED: ::std::os::raw::c_int = -1;
    pub const NS_STYLE_COLUMN_FILL_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COLUMN_FILL_BALANCE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_IME_MODE_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_IME_MODE_NORMAL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_IME_MODE_ACTIVE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_IME_MODE_DISABLED: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_IME_MODE_INACTIVE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_GRADIENT_SHAPE_LINEAR: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_GRADIENT_SHAPE_ELLIPTICAL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_GRADIENT_SHAPE_CIRCULAR: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_GRADIENT_SIZE_CLOSEST_SIDE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_GRADIENT_SIZE_CLOSEST_CORNER: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_GRADIENT_SIZE_FARTHEST_SIDE: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_GRADIENT_SIZE_FARTHEST_CORNER: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_GRADIENT_SIZE_EXPLICIT_SIZE: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_DOMINANT_BASELINE_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_DOMINANT_BASELINE_USE_SCRIPT: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_DOMINANT_BASELINE_NO_CHANGE: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_DOMINANT_BASELINE_RESET_SIZE: ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_DOMINANT_BASELINE_IDEOGRAPHIC: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_DOMINANT_BASELINE_ALPHABETIC: ::std::os::raw::c_uint =
        5;
    pub const NS_STYLE_DOMINANT_BASELINE_HANGING: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_DOMINANT_BASELINE_MATHEMATICAL: ::std::os::raw::c_uint
              =
        7;
    pub const NS_STYLE_DOMINANT_BASELINE_CENTRAL: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_DOMINANT_BASELINE_MIDDLE: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_DOMINANT_BASELINE_TEXT_AFTER_EDGE:
              ::std::os::raw::c_uint =
        10;
    pub const NS_STYLE_DOMINANT_BASELINE_TEXT_BEFORE_EDGE:
              ::std::os::raw::c_uint =
        11;
    pub const NS_STYLE_IMAGE_RENDERING_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_IMAGE_RENDERING_OPTIMIZESPEED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_IMAGE_RENDERING_OPTIMIZEQUALITY: ::std::os::raw::c_uint
              =
        2;
    pub const NS_STYLE_IMAGE_RENDERING_CRISPEDGES: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_MASK_TYPE_LUMINANCE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_MASK_TYPE_ALPHA: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PAINT_ORDER_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_PAINT_ORDER_FILL: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_PAINT_ORDER_STROKE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_PAINT_ORDER_MARKERS: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_PAINT_ORDER_LAST_VALUE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_PAINT_ORDER_BITWIDTH: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_SHAPE_RENDERING_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SHAPE_RENDERING_OPTIMIZESPEED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_SHAPE_RENDERING_CRISPEDGES: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_SHAPE_RENDERING_GEOMETRICPRECISION:
              ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_STROKE_LINECAP_BUTT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_STROKE_LINECAP_ROUND: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_STROKE_LINECAP_SQUARE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_STROKE_LINEJOIN_MITER: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_STROKE_LINEJOIN_ROUND: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_STROKE_LINEJOIN_BEVEL: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_STROKE_PROP_CONTEXT_VALUE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_ANCHOR_START: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_ANCHOR_MIDDLE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_ANCHOR_END: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_OVER: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_UNDER: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_LEFT: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_RIGHT: ::std::os::raw::c_uint =
        8;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_DEFAULT: ::std::os::raw::c_uint
              =
        9;
    pub const NS_STYLE_TEXT_EMPHASIS_POSITION_DEFAULT_ZH:
              ::std::os::raw::c_uint =
        10;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_FILL_MASK: ::std::os::raw::c_uint =
        8;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_FILLED: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_OPEN: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_SHAPE_MASK: ::std::os::raw::c_uint
              =
        7;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_DOT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_CIRCLE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_DOUBLE_CIRCLE:
              ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_TRIANGLE: ::std::os::raw::c_uint =
        4;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_SESAME: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_TEXT_EMPHASIS_STYLE_STRING: ::std::os::raw::c_uint =
        255;
    pub const NS_STYLE_TEXT_RENDERING_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TEXT_RENDERING_OPTIMIZESPEED: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_TEXT_RENDERING_OPTIMIZELEGIBILITY:
              ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_TEXT_RENDERING_GEOMETRICPRECISION:
              ::std::os::raw::c_uint =
        3;
    pub const NS_STYLE_COLOR_ADJUST_ECONOMY: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COLOR_ADJUST_EXACT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_COLOR_INTERPOLATION_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COLOR_INTERPOLATION_SRGB: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_COLOR_INTERPOLATION_LINEARRGB: ::std::os::raw::c_uint =
        2;
    pub const NS_STYLE_VECTOR_EFFECT_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_VECTOR_EFFECT_NON_SCALING_STROKE:
              ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_BACKFACE_VISIBILITY_VISIBLE: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_BACKFACE_VISIBILITY_HIDDEN: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TRANSFORM_STYLE_FLAT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_TRANSFORM_STYLE_PRESERVE_3D: ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_CONTEXT_FILL_OPACITY: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_CONTEXT_STROKE_OPACITY: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BLEND_NORMAL: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_BLEND_MULTIPLY: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_BLEND_SCREEN: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_BLEND_OVERLAY: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_BLEND_DARKEN: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_BLEND_LIGHTEN: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_BLEND_COLOR_DODGE: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_BLEND_COLOR_BURN: ::std::os::raw::c_uint = 7;
    pub const NS_STYLE_BLEND_HARD_LIGHT: ::std::os::raw::c_uint = 8;
    pub const NS_STYLE_BLEND_SOFT_LIGHT: ::std::os::raw::c_uint = 9;
    pub const NS_STYLE_BLEND_DIFFERENCE: ::std::os::raw::c_uint = 10;
    pub const NS_STYLE_BLEND_EXCLUSION: ::std::os::raw::c_uint = 11;
    pub const NS_STYLE_BLEND_HUE: ::std::os::raw::c_uint = 12;
    pub const NS_STYLE_BLEND_SATURATION: ::std::os::raw::c_uint = 13;
    pub const NS_STYLE_BLEND_COLOR: ::std::os::raw::c_uint = 14;
    pub const NS_STYLE_BLEND_LUMINOSITY: ::std::os::raw::c_uint = 15;
    pub const NS_STYLE_MASK_COMPOSITE_ADD: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_MASK_COMPOSITE_SUBTRACT: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_MASK_COMPOSITE_INTERSECT: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_MASK_COMPOSITE_EXCLUDE: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_CONTROL_CHARACTER_VISIBILITY_HIDDEN:
              ::std::os::raw::c_uint =
        0;
    pub const NS_STYLE_CONTROL_CHARACTER_VISIBILITY_VISIBLE:
              ::std::os::raw::c_uint =
        1;
    pub const NS_STYLE_COUNTER_SYSTEM_CYCLIC: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COUNTER_SYSTEM_NUMERIC: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_COUNTER_SYSTEM_ALPHABETIC: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_COUNTER_SYSTEM_SYMBOLIC: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_COUNTER_SYSTEM_ADDITIVE: ::std::os::raw::c_uint = 4;
    pub const NS_STYLE_COUNTER_SYSTEM_FIXED: ::std::os::raw::c_uint = 5;
    pub const NS_STYLE_COUNTER_SYSTEM_EXTENDS: ::std::os::raw::c_uint = 6;
    pub const NS_STYLE_COUNTER_RANGE_INFINITE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COUNTER_SPEAKAS_BULLETS: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_COUNTER_SPEAKAS_NUMBERS: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_COUNTER_SPEAKAS_WORDS: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_COUNTER_SPEAKAS_SPELL_OUT: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_COUNTER_SPEAKAS_OTHER: ::std::os::raw::c_uint = 255;
    pub const NS_STYLE_SCROLL_BEHAVIOR_AUTO: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SCROLL_BEHAVIOR_SMOOTH: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SCROLL_SNAP_TYPE_NONE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SCROLL_SNAP_TYPE_MANDATORY: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SCROLL_SNAP_TYPE_PROXIMITY: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_ORIENTATION_PORTRAIT: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_ORIENTATION_LANDSCAPE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_SCAN_PROGRESSIVE: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_SCAN_INTERLACE: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_DISPLAY_MODE_BROWSER: ::std::os::raw::c_uint = 0;
    pub const NS_STYLE_DISPLAY_MODE_MINIMAL_UI: ::std::os::raw::c_uint = 1;
    pub const NS_STYLE_DISPLAY_MODE_STANDALONE: ::std::os::raw::c_uint = 2;
    pub const NS_STYLE_DISPLAY_MODE_FULLSCREEN: ::std::os::raw::c_uint = 3;
    pub const NS_STYLE_INHERIT_MASK: ::std::os::raw::c_uint = 16777215;
    pub const NS_STYLE_HAS_TEXT_DECORATION_LINES: ::std::os::raw::c_uint =
        16777216;
    pub const NS_STYLE_HAS_PSEUDO_ELEMENT_DATA: ::std::os::raw::c_uint =
        33554432;
    pub const NS_STYLE_RELEVANT_LINK_VISITED: ::std::os::raw::c_uint =
        67108864;
    pub const NS_STYLE_IS_STYLE_IF_VISITED: ::std::os::raw::c_uint =
        134217728;
    pub const NS_STYLE_CHILD_USES_GRANDANCESTOR_STYLE: ::std::os::raw::c_uint
              =
        268435456;
    pub const NS_STYLE_IS_SHARED: ::std::os::raw::c_uint = 536870912;
    pub const NS_STYLE_IS_GOING_AWAY: ::std::os::raw::c_uint = 1073741824;
    pub const NS_STYLE_SUPPRESS_LINEBREAK: ::std::os::raw::c_uint =
        2147483648;
    pub const NS_STYLE_IN_DISPLAY_NONE_SUBTREE: ::std::os::raw::c_ulonglong =
        4294967296;
    pub const NS_STYLE_INELIGIBLE_FOR_SHARING: ::std::os::raw::c_ulonglong =
        8589934592;
    pub const NS_STYLE_HAS_CHILD_THAT_USES_RESET_STYLE:
              ::std::os::raw::c_ulonglong =
        17179869184;
    pub const NS_STYLE_IS_TEXT_COMBINED: ::std::os::raw::c_ulonglong =
        34359738368;
    pub const NS_STYLE_CONTEXT_TYPE_SHIFT: ::std::os::raw::c_uint = 36;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pair<_T1, _T2> {
            pub first: _T1,
            pub second: _T2,
        }
        pub type pair_first_type<_T1> = _T1;
        pub type pair_second_type<_T2> = _T2;
        pub mod namespace {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct atomic<_Tp> {
            pub _M_i: _Tp,
        }
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub mod mozilla {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct fallible_t {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_fallible_t() {
            assert_eq!(::std::mem::size_of::<fallible_t>() , 1usize);
            assert_eq!(::std::mem::align_of::<fallible_t>() , 1usize);
        }
        impl Clone for fallible_t {
            fn clone(&self) -> Self { *self }
        }
        /** Convenient aliases. */
        pub type TrueType = u8;
        pub type FalseType = u8;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct OwningNonNull<T> {
            pub mPtr: root::RefPtr<T>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StaticRefPtr<T> {
            pub mRawPtr: *mut T,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AlignedStorage2<T> {
            pub u: root::mozilla::AlignedStorage2_U<T>,
            pub _phantom_0: ::std::marker::PhantomData<T>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AlignedStorage2_U<T> {
            pub mBytes: root::__BindgenUnionField<*mut ::std::os::raw::c_char>,
            pub mDummy: root::__BindgenUnionField<u64>,
            pub bindgen_union_field: u64,
            pub _phantom_0: ::std::marker::PhantomData<T>,
        }
        /**
 * Pair is the logical concatenation of an instance of A with an instance B.
 * Space is conserved when possible.  Neither A nor B may be a final class.
 *
 * It's typically clearer to have individual A and B member fields.  Except if
 * you want the space-conserving qualities of Pair, you're probably better off
 * not using this!
 *
 * No guarantees are provided about the memory layout of A and B, the order of
 * initialization or destruction of A and B, and so on.  (This is approximately
 * required to optimize space usage.)  The first/second names are merely
 * conceptual!
 */
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Pair<A, B> {
            pub _address: u8,
            pub _phantom_0: ::std::marker::PhantomData<A>,
            pub _phantom_1: ::std::marker::PhantomData<B>,
        }
        pub type Pair_Base = [u8; 0usize];
        /**
 * A default deletion policy using plain old operator delete.
 *
 * Note that this type can be specialized, but authors should beware of the risk
 * that the specialization may at some point cease to match (either because it
 * gets moved to a different compilation unit or the signature changes). If the
 * non-specialized (|delete|-based) version compiles for that type but does the
 * wrong thing, bad things could happen.
 *
 * This is a non-issue for types which are always incomplete (i.e. opaque handle
 * types), since |delete|-ing such a type will always trigger a compilation
 * error.
 */
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DefaultDelete<T> {
            pub _address: u8,
            pub _phantom_0: ::std::marker::PhantomData<T>,
        }
        pub type TimeStampValue = u64;
        /**
 * Instances of this class represent moments in time, or a special
 * "null" moment. We do not use the non-monotonic system clock or
 * local time, since they can be reset, causing apparent backward
 * travel in time, which can confuse algorithms. Instead we measure
 * elapsed time according to the system.  This time can never go
 * backwards (i.e. it never wraps around, at least not in less than
 * five million years of system elapsed time). It might not advance
 * while the system is sleeping. If TimeStamp::SetNow() is not called
 * at all for hours or days, we might not notice the passage of some
 * of that time.
 *
 * We deliberately do not expose a way to convert TimeStamps to some
 * particular unit. All you can do is compute a difference between two
 * TimeStamps to get a TimeDuration. You can also add a TimeDuration
 * to a TimeStamp to get a new TimeStamp. You can't do something
 * meaningless like add two TimeStamps.
 *
 * Internally this is implemented as either a wrapper around
 *   - high-resolution, monotonic, system clocks if they exist on this
 *     platform
 *   - PRIntervalTime otherwise.  We detect wraparounds of
 *     PRIntervalTime and work around them.
 *
 * This class is similar to C++11's time_point, however it is
 * explicitly nullable and provides an IsNull() method. time_point
 * is initialized to the clock's epoch and provides a
 * time_since_epoch() method that functions similiarly. i.e.
 * t.IsNull() is equivalent to t.time_since_epoch() == decltype(t)::duration::zero();
 */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct TimeStamp {
            /**
   * When built with PRIntervalTime, a value of 0 means this instance
   * is "null". Otherwise, the low 32 bits represent a PRIntervalTime,
   * and the high 32 bits represent a counter of the number of
   * rollovers of PRIntervalTime that we've seen. This counter starts
   * at 1 to avoid a real time colliding with the "null" value.
   *
   * PR_INTERVAL_MAX is set at 100,000 ticks per second. So the minimum
   * time to wrap around is about 2^64/100000 seconds, i.e. about
   * 5,849,424 years.
   *
   * When using a system clock, a value is system dependent.
   */
            pub mValue: root::mozilla::TimeStampValue,
        }
        #[test]
        fn bindgen_test_layout_TimeStamp() {
            assert_eq!(::std::mem::size_of::<TimeStamp>() , 8usize);
            assert_eq!(::std::mem::align_of::<TimeStamp>() , 8usize);
        }
        impl Clone for TimeStamp {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct MallocAllocPolicy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_MallocAllocPolicy() {
            assert_eq!(::std::mem::size_of::<MallocAllocPolicy>() , 1usize);
            assert_eq!(::std::mem::align_of::<MallocAllocPolicy>() , 1usize);
        }
        impl Clone for MallocAllocPolicy {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ThreadSafeAutoRefCnt {
            pub mValue: u64,
        }
        pub const ThreadSafeAutoRefCnt_isThreadSafe: bool = true;
        #[test]
        fn bindgen_test_layout_ThreadSafeAutoRefCnt() {
            assert_eq!(::std::mem::size_of::<ThreadSafeAutoRefCnt>() ,
                       8usize);
            assert_eq!(::std::mem::align_of::<ThreadSafeAutoRefCnt>() ,
                       8usize);
        }
        impl Clone for ThreadSafeAutoRefCnt {
            fn clone(&self) -> Self { *self }
        }
        pub mod gfx {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type Float = f32;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Color {
                pub r: root::mozilla::gfx::Float,
                pub g: root::mozilla::gfx::Float,
                pub b: root::mozilla::gfx::Float,
                pub a: root::mozilla::gfx::Float,
            }
            #[test]
            fn bindgen_test_layout_Color() {
                assert_eq!(::std::mem::size_of::<Color>() , 16usize);
                assert_eq!(::std::mem::align_of::<Color>() , 4usize);
            }
            impl Clone for Color {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct SourceSurface {
                pub _address: u8,
            }
            impl Clone for SourceSurface {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DrawTarget {
                pub _address: u8,
            }
            impl Clone for DrawTarget {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Path {
                pub _address: u8,
            }
            impl Clone for Path {
                fn clone(&self) -> Self { *self }
            }
        }
        pub mod layers {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct LayerManager {
                pub _address: u8,
            }
            impl Clone for LayerManager {
                fn clone(&self) -> Self { *self }
            }
        }
        pub mod dom {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct AllOwningUnionBase {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_AllOwningUnionBase() {
                assert_eq!(::std::mem::size_of::<AllOwningUnionBase>() ,
                           1usize);
                assert_eq!(::std::mem::align_of::<AllOwningUnionBase>() ,
                           1usize);
            }
            impl Clone for AllOwningUnionBase {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct GlobalObject {
                pub mGlobalJSObject: [u64; 3usize],
                pub mCx: *mut root::JSContext,
                pub mGlobalObject: *mut root::nsISupports,
            }
            #[test]
            fn bindgen_test_layout_GlobalObject() {
                assert_eq!(::std::mem::size_of::<GlobalObject>() , 40usize);
                assert_eq!(::std::mem::align_of::<GlobalObject>() , 8usize);
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DocGroup {
                pub _address: u8,
            }
            impl Clone for DocGroup {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            pub struct DispatcherTrait__bindgen_vtable {
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DispatcherTrait {
                pub vtable_: *const DispatcherTrait__bindgen_vtable,
            }
            #[test]
            fn bindgen_test_layout_DispatcherTrait() {
                assert_eq!(::std::mem::size_of::<DispatcherTrait>() , 8usize);
                assert_eq!(::std::mem::align_of::<DispatcherTrait>() ,
                           8usize);
            }
            impl Clone for DispatcherTrait {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct EventTarget {
                pub _base: root::nsIDOMEventTarget,
                pub _base_1: root::nsWrapperCache,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EventTarget_COMTypeInfo<T, U> {
                pub _address: u8,
                pub _phantom_0: ::std::marker::PhantomData<T>,
                pub _phantom_1: ::std::marker::PhantomData<U>,
            }
            #[test]
            fn bindgen_test_layout_EventTarget() {
                assert_eq!(::std::mem::size_of::<EventTarget>() , 32usize);
                assert_eq!(::std::mem::align_of::<EventTarget>() , 8usize);
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct AudioContext {
                pub _address: u8,
            }
            impl Clone for AudioContext {
                fn clone(&self) -> Self { *self }
            }
            pub const ReferrerPolicy_RP_Default:
                      root::mozilla::dom::ReferrerPolicy =
                ReferrerPolicy::RP_No_Referrer_When_Downgrade;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum ReferrerPolicy {
                RP_No_Referrer = 2,
                RP_Origin = 3,
                RP_No_Referrer_When_Downgrade = 1,
                RP_Origin_When_Crossorigin = 4,
                RP_Unsafe_URL = 5,
                RP_Same_Origin = 6,
                RP_Strict_Origin = 7,
                RP_Strict_Origin_When_Cross_Origin = 8,
                RP_Unset = 0,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct Element {
                pub _base: root::mozilla::dom::FragmentOrElement,
                pub mState: root::EventStates,
                pub mServoData: ::gecko_bindings::structs::ServoCell<*mut ::gecko_bindings::structs::ServoNodeData>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Element_COMTypeInfo<T, U> {
                pub _address: u8,
                pub _phantom_0: ::std::marker::PhantomData<T>,
                pub _phantom_1: ::std::marker::PhantomData<U>,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Element_MappedAttributeEntry {
                pub attribute: *mut *mut root::nsIAtom,
            }
            #[test]
            fn bindgen_test_layout_Element_MappedAttributeEntry() {
                assert_eq!(::std::mem::size_of::<Element_MappedAttributeEntry>()
                           , 8usize);
                assert_eq!(::std::mem::align_of::<Element_MappedAttributeEntry>()
                           , 8usize);
            }
            impl Clone for Element_MappedAttributeEntry {
                fn clone(&self) -> Self { *self }
            }
            pub const Element_kFireMutationEvent: bool = true;
            pub const Element_kDontFireMutationEvent: bool = false;
            pub const Element_kNotifyDocumentObservers: bool = true;
            pub const Element_kDontNotifyDocumentObservers: bool = false;
            pub const Element_kCallAfterSetAttr: bool = true;
            pub const Element_kDontCallAfterSetAttr: bool = false;
            #[test]
            fn bindgen_test_layout_Element() {
                assert_eq!(::std::mem::size_of::<Element>() , 128usize);
                assert_eq!(::std::mem::align_of::<Element>() , 8usize);
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct TimeoutManager {
                pub _address: u8,
            }
            impl Clone for TimeoutManager {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct PrefSetting {
                pub _address: u8,
            }
            impl Clone for PrefSetting {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallbackObject {
                pub _base: root::nsISupports,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mCallback: root::JS::Heap<*mut root::JSObject>,
                pub mCreationStack: root::JS::Heap<*mut root::JSObject>,
                pub mIncumbentGlobal: root::nsCOMPtr<root::nsIGlobalObject>,
                pub mIncumbentJSGlobal: root::JS::TenuredHeap<*mut root::JSObject>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CallbackObject_COMTypeInfo<T, U> {
                pub _address: u8,
                pub _phantom_0: ::std::marker::PhantomData<T>,
                pub _phantom_1: ::std::marker::PhantomData<U>,
            }
            pub type CallbackObject_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct CallbackObject_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_CallbackObject_cycleCollection() {
                assert_eq!(::std::mem::size_of::<CallbackObject_cycleCollection>()
                           , 16usize);
                assert_eq!(::std::mem::align_of::<CallbackObject_cycleCollection>()
                           , 8usize);
            }
            impl Clone for CallbackObject_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum CallbackObject_ExceptionHandling {
                eReportExceptions = 0,
                eRethrowContentExceptions = 1,
                eRethrowExceptions = 2,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct CallbackObject_FastCallbackConstructor {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_CallbackObject_FastCallbackConstructor() {
                assert_eq!(::std::mem::size_of::<CallbackObject_FastCallbackConstructor>()
                           , 1usize);
                assert_eq!(::std::mem::align_of::<CallbackObject_FastCallbackConstructor>()
                           , 1usize);
            }
            impl Clone for CallbackObject_FastCallbackConstructor {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallbackObject_CallSetup {
                pub mCx: *mut root::JSContext,
                pub mCompartment: *mut root::JSCompartment,
                pub mAutoEntryScript: [u64; 19usize],
                pub mAutoIncumbentScript: [u64; 5usize],
                pub mRootedCallable: [u64; 4usize],
                pub mAsyncStack: [u64; 4usize],
                pub mAsyncStackSetter: [u64; 7usize],
                pub mAc: [u64; 3usize],
                pub mErrorResult: *mut [u64; 2usize],
                pub mExceptionHandling: root::mozilla::dom::CallbackObject_ExceptionHandling,
                pub mIsMainThread: bool,
            }
            #[test]
            fn bindgen_test_layout_CallbackObject_CallSetup() {
                assert_eq!(::std::mem::size_of::<CallbackObject_CallSetup>() ,
                           368usize);
                assert_eq!(::std::mem::align_of::<CallbackObject_CallSetup>()
                           , 8usize);
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom14CallbackObject21_cycleCollectorGlobalE"]
                pub static mut CallbackObject__cycleCollectorGlobal:
                           root::mozilla::dom::CallbackObject_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_CallbackObject() {
                assert_eq!(::std::mem::size_of::<CallbackObject>() , 48usize);
                assert_eq!(::std::mem::align_of::<CallbackObject>() , 8usize);
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallbackFunction {
                pub _base: root::mozilla::dom::CallbackObject,
            }
            #[test]
            fn bindgen_test_layout_CallbackFunction() {
                assert_eq!(::std::mem::size_of::<CallbackFunction>() ,
                           48usize);
                assert_eq!(::std::mem::align_of::<CallbackFunction>() ,
                           8usize);
            }
            pub mod prototypes {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
            pub mod constructors {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
            pub mod namedpropertiesobjects {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
            pub mod workers {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct NodeInfo {
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mDocument: *mut root::nsIDocument,
                pub mInner: root::mozilla::dom::NodeInfo_NodeInfoInner,
                pub mOwnerManager: root::RefPtr<root::nsNodeInfoManager>,
                pub mQualifiedName: ::nsstring::nsStringRepr,
                pub mNodeName: ::nsstring::nsStringRepr,
                pub mLocalName: ::nsstring::nsStringRepr,
            }
            pub type NodeInfo_HasThreadSafeRefCnt = root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct NodeInfo_cycleCollection {
                pub _base: root::nsCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_NodeInfo_cycleCollection() {
                assert_eq!(::std::mem::size_of::<NodeInfo_cycleCollection>() ,
                           16usize);
                assert_eq!(::std::mem::align_of::<NodeInfo_cycleCollection>()
                           , 8usize);
            }
            impl Clone for NodeInfo_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct NodeInfo_NodeInfoInner {
                pub mName: root::nsCOMPtr<root::nsIAtom>,
                pub mPrefix: root::nsCOMPtr<root::nsIAtom>,
                pub mNamespaceID: i32,
                pub mNodeType: u16,
                pub mNameString: *const root::nsAString_internal,
                pub mExtraName: root::nsCOMPtr<root::nsIAtom>,
            }
            #[test]
            fn bindgen_test_layout_NodeInfo_NodeInfoInner() {
                assert_eq!(::std::mem::size_of::<NodeInfo_NodeInfoInner>() ,
                           40usize);
                assert_eq!(::std::mem::align_of::<NodeInfo_NodeInfoInner>() ,
                           8usize);
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom8NodeInfo21_cycleCollectorGlobalE"]
                pub static mut NodeInfo__cycleCollectorGlobal:
                           root::mozilla::dom::NodeInfo_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_NodeInfo() {
                assert_eq!(::std::mem::size_of::<NodeInfo>() , 112usize);
                assert_eq!(::std::mem::align_of::<NodeInfo>() , 8usize);
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct BoxQuadOptions {
                pub _address: u8,
            }
            impl Clone for BoxQuadOptions {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct ConvertCoordinateOptions {
                pub _address: u8,
            }
            impl Clone for ConvertCoordinateOptions {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DOMPoint {
                pub _address: u8,
            }
            impl Clone for DOMPoint {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DOMQuad {
                pub _address: u8,
            }
            impl Clone for DOMQuad {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct DOMRectReadOnly {
                pub _base: root::nsISupports,
                pub _base_1: root::nsWrapperCache,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mParent: root::nsCOMPtr<root::nsISupports>,
            }
            pub type DOMRectReadOnly_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DOMRectReadOnly_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_DOMRectReadOnly_cycleCollection() {
                assert_eq!(::std::mem::size_of::<DOMRectReadOnly_cycleCollection>()
                           , 16usize);
                assert_eq!(::std::mem::align_of::<DOMRectReadOnly_cycleCollection>()
                           , 8usize);
            }
            impl Clone for DOMRectReadOnly_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom15DOMRectReadOnly21_cycleCollectorGlobalE"]
                pub static mut DOMRectReadOnly__cycleCollectorGlobal:
                           root::mozilla::dom::DOMRectReadOnly_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_DOMRectReadOnly() {
                assert_eq!(::std::mem::size_of::<DOMRectReadOnly>() ,
                           48usize);
                assert_eq!(::std::mem::align_of::<DOMRectReadOnly>() ,
                           8usize);
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct OwningNodeOrString {
                pub mType: root::mozilla::dom::OwningNodeOrString_Type,
                pub mValue: root::mozilla::dom::OwningNodeOrString_Value,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum OwningNodeOrString_Type {
                eUninitialized = 0,
                eNode = 1,
                eString = 2,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct OwningNodeOrString_Value {
                pub mNode: root::__BindgenUnionField<root::mozilla::dom::UnionMember<root::mozilla::OwningNonNull<root::nsINode>>>,
                pub mString: root::__BindgenUnionField<root::mozilla::dom::UnionMember<::nsstring::nsStringRepr>>,
                pub bindgen_union_field: [u64; 2usize],
            }
            #[test]
            fn bindgen_test_layout_OwningNodeOrString_Value() {
                assert_eq!(::std::mem::size_of::<OwningNodeOrString_Value>() ,
                           16usize);
                assert_eq!(::std::mem::align_of::<OwningNodeOrString_Value>()
                           , 8usize);
            }
            impl Clone for OwningNodeOrString_Value {
                fn clone(&self) -> Self { *self }
            }
            #[test]
            fn bindgen_test_layout_OwningNodeOrString() {
                assert_eq!(::std::mem::size_of::<OwningNodeOrString>() ,
                           24usize);
                assert_eq!(::std::mem::align_of::<OwningNodeOrString>() ,
                           8usize);
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct TextOrElementOrDocument {
                pub _address: u8,
            }
            impl Clone for TextOrElementOrDocument {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DOMPointInit {
                pub _address: u8,
            }
            impl Clone for DOMPointInit {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct UnionMember<T> {
                pub mStorage: root::mozilla::AlignedStorage2<T>,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum VisibilityState {
                Hidden = 0,
                Visible = 1,
                Prerender = 2,
                EndGuard_ = 3,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Animation {
                pub _address: u8,
            }
            impl Clone for Animation {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct AnonymousContent {
                pub _address: u8,
            }
            impl Clone for AnonymousContent {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct Attr {
                pub _base: root::nsIAttribute,
                pub _base_1: root::nsIDOMAttr,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mValue: ::nsstring::nsStringRepr,
            }
            pub type Attr_HasThreadSafeRefCnt = root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Attr_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_Attr_cycleCollection() {
                assert_eq!(::std::mem::size_of::<Attr_cycleCollection>() ,
                           16usize);
                assert_eq!(::std::mem::align_of::<Attr_cycleCollection>() ,
                           8usize);
            }
            impl Clone for Attr_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            extern "C" {
                #[link_name = "_ZN7mozilla3dom4Attr21_cycleCollectorGlobalE"]
                pub static mut Attr__cycleCollectorGlobal:
                           root::mozilla::dom::Attr_cycleCollection;
            }
            extern "C" {
                #[link_name = "_ZN7mozilla3dom4Attr12sInitializedE"]
                pub static mut Attr_sInitialized: bool;
            }
            #[test]
            fn bindgen_test_layout_Attr() {
                assert_eq!(::std::mem::size_of::<Attr>() , 136usize);
                assert_eq!(::std::mem::align_of::<Attr>() , 8usize);
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct FontFaceSet {
                pub _address: u8,
            }
            impl Clone for FontFaceSet {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct FrameRequestCallback {
                pub _base: root::mozilla::dom::CallbackFunction,
            }
            #[test]
            fn bindgen_test_layout_FrameRequestCallback() {
                assert_eq!(::std::mem::size_of::<FrameRequestCallback>() ,
                           48usize);
                assert_eq!(::std::mem::align_of::<FrameRequestCallback>() ,
                           8usize);
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct FullscreenRequest {
                pub _address: u8,
            }
            impl Clone for FullscreenRequest {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct ImageTracker {
                pub _address: u8,
            }
            impl Clone for ImageTracker {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct XPathEvaluator {
                pub _address: u8,
            }
            impl Clone for XPathEvaluator {
                fn clone(&self) -> Self { *self }
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum FillMode {
                None = 0,
                Forwards = 1,
                Backwards = 2,
                Both = 3,
                Auto = 4,
                EndGuard_ = 5,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum PlaybackDirection {
                Normal = 0,
                Reverse = 1,
                Alternate = 2,
                Alternate_reverse = 3,
                EndGuard_ = 4,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct ShadowRoot {
                pub _address: u8,
            }
            impl Clone for ShadowRoot {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct CustomElementData {
                pub _address: u8,
            }
            impl Clone for CustomElementData {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct FragmentOrElement {
                pub _base: root::nsIContent,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                /**
   * Array containing all attributes and children for this element
   */
                pub mAttrsAndChildren: root::nsAttrAndChildArray,
            }
            pub type FragmentOrElement_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct FragmentOrElement_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_FragmentOrElement_cycleCollection() {
                assert_eq!(::std::mem::size_of::<FragmentOrElement_cycleCollection>()
                           , 16usize);
                assert_eq!(::std::mem::align_of::<FragmentOrElement_cycleCollection>()
                           , 8usize);
            }
            impl Clone for FragmentOrElement_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            /**
   * There are a set of DOM- and scripting-specific instance variables
   * that may only be instantiated when a content object is accessed
   * through the DOM. Rather than burn actual slots in the content
   * objects for each of these instance variables, we put them off
   * in a side structure that's only allocated when the content is
   * accessed through the DOM.
   */
            #[repr(C)]
            #[derive(Debug)]
            pub struct FragmentOrElement_nsDOMSlots {
                pub _base: root::nsINode_nsSlots,
                /**
     * The .style attribute (an interface that forwards to the actual
     * style rules)
     * @see nsGenericHTMLElement::GetStyle
     */
                pub mStyle: root::nsCOMPtr<root::nsICSSDeclaration>,
                /**
     * The .dataset attribute.
     * @see nsGenericHTMLElement::GetDataset
     */
                pub mDataset: *mut root::nsDOMStringMap,
                /**
     * SMIL Overridde style rules (for SMIL animation of CSS properties)
     * @see nsIContent::GetSMILOverrideStyle
     */
                pub mSMILOverrideStyle: root::nsCOMPtr<root::nsICSSDeclaration>,
                /**
     * Holds any SMIL override style declaration for this element.
     */
                pub mSMILOverrideStyleDeclaration: root::RefPtr<root::mozilla::DeclarationBlock>,
                /**
     * An object implementing nsIDOMMozNamedAttrMap for this content (attributes)
     * @see FragmentOrElement::GetAttributes
     */
                pub mAttributeMap: root::RefPtr<root::nsDOMAttributeMap>,
                pub __bindgen_anon_1: root::mozilla::dom::FragmentOrElement_nsDOMSlots__bindgen_ty_1,
                /**
     * An object implementing the .children property for this element.
     */
                pub mChildrenList: root::RefPtr<root::nsContentList>,
                /**
     * An object implementing the .classList property for this element.
     */
                pub mClassList: root::RefPtr<root::nsDOMTokenList>,
                /**
     * ShadowRoot bound to the element.
     */
                pub mShadowRoot: root::RefPtr<root::mozilla::dom::ShadowRoot>,
                /**
     * The root ShadowRoot of this element if it is in a shadow tree.
     */
                pub mContainingShadow: root::RefPtr<root::mozilla::dom::ShadowRoot>,
                /**
     * An array of web component insertion points to which this element
     * is distributed.
     */
                pub mDestInsertionPoints: root::nsTArray<*mut root::nsIContent>,
                /**
     * XBL binding installed on the element.
     */
                pub mXBLBinding: root::RefPtr<root::nsXBLBinding>,
                /**
     * XBL binding installed on the lement.
     */
                pub mXBLInsertionParent: root::nsCOMPtr<root::nsIContent>,
                /**
     * Web components custom element data.
     */
                pub mCustomElementData: root::RefPtr<root::mozilla::dom::CustomElementData>,
                /**
     * Registered Intersection Observers on the element.
     */
                pub mRegisteredIntersectionObservers: [u64; 5usize],
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct FragmentOrElement_nsDOMSlots__bindgen_ty_1 {
                /**
      * The nearest enclosing content node with a binding that created us.
      * @see FragmentOrElement::GetBindingParent
      */
                pub mBindingParent: root::__BindgenUnionField<*mut root::nsIContent>,
                /**
      * The controllers of the XUL Element.
      */
                pub mControllers: root::__BindgenUnionField<*mut root::nsIControllers>,
                pub bindgen_union_field: u64,
            }
            #[test]
            fn bindgen_test_layout_FragmentOrElement_nsDOMSlots__bindgen_ty_1() {
                assert_eq!(::std::mem::size_of::<FragmentOrElement_nsDOMSlots__bindgen_ty_1>()
                           , 8usize);
                assert_eq!(::std::mem::align_of::<FragmentOrElement_nsDOMSlots__bindgen_ty_1>()
                           , 8usize);
            }
            impl Clone for FragmentOrElement_nsDOMSlots__bindgen_ty_1 {
                fn clone(&self) -> Self { *self }
            }
            #[test]
            fn bindgen_test_layout_FragmentOrElement_nsDOMSlots() {
                assert_eq!(::std::mem::size_of::<FragmentOrElement_nsDOMSlots>()
                           , 200usize);
                assert_eq!(::std::mem::align_of::<FragmentOrElement_nsDOMSlots>()
                           , 8usize);
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom17FragmentOrElement21_cycleCollectorGlobalE"]
                pub static mut FragmentOrElement__cycleCollectorGlobal:
                           root::mozilla::dom::FragmentOrElement_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_FragmentOrElement() {
                assert_eq!(::std::mem::size_of::<FragmentOrElement>() ,
                           112usize);
                assert_eq!(::std::mem::align_of::<FragmentOrElement>() ,
                           8usize);
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct DOMRect {
                pub _base: root::mozilla::dom::DOMRectReadOnly,
                pub _base_1: root::nsIDOMClientRect,
                pub mX: f64,
                pub mY: f64,
                pub mWidth: f64,
                pub mHeight: f64,
            }
            #[test]
            fn bindgen_test_layout_DOMRect() {
                assert_eq!(::std::mem::size_of::<DOMRect>() , 88usize);
                assert_eq!(::std::mem::align_of::<DOMRect>() , 8usize);
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct DOMIntersectionObserverEntry {
                pub _base: root::nsISupports,
                pub _base_1: root::nsWrapperCache,
                pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
                pub mOwner: root::nsCOMPtr<root::nsISupports>,
                pub mTime: root::DOMHighResTimeStamp,
                pub mRootBounds: root::RefPtr<root::mozilla::dom::DOMRect>,
                pub mBoundingClientRect: root::RefPtr<root::mozilla::dom::DOMRect>,
                pub mIntersectionRect: root::RefPtr<root::mozilla::dom::DOMRect>,
                pub mTarget: root::RefPtr<root::mozilla::dom::Element>,
                pub mIntersectionRatio: f64,
            }
            pub type DOMIntersectionObserverEntry_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DOMIntersectionObserverEntry_cycleCollection {
                pub _base: root::nsXPCOMCycleCollectionParticipant,
            }
            #[test]
            fn bindgen_test_layout_DOMIntersectionObserverEntry_cycleCollection() {
                assert_eq!(::std::mem::size_of::<DOMIntersectionObserverEntry_cycleCollection>()
                           , 16usize);
                assert_eq!(::std::mem::align_of::<DOMIntersectionObserverEntry_cycleCollection>()
                           , 8usize);
            }
            impl Clone for DOMIntersectionObserverEntry_cycleCollection {
                fn clone(&self) -> Self { *self }
            }
            extern "C" {
                #[link_name =
                      "_ZN7mozilla3dom28DOMIntersectionObserverEntry21_cycleCollectorGlobalE"]
                pub static mut
                           DOMIntersectionObserverEntry__cycleCollectorGlobal:
                           root::mozilla::dom::DOMIntersectionObserverEntry_cycleCollection;
            }
            #[test]
            fn bindgen_test_layout_DOMIntersectionObserverEntry() {
                assert_eq!(::std::mem::size_of::<DOMIntersectionObserverEntry>()
                           , 96usize);
                assert_eq!(::std::mem::align_of::<DOMIntersectionObserverEntry>()
                           , 8usize);
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Grid {
                pub _address: u8,
            }
            impl Clone for Grid {
                fn clone(&self) -> Self { *self }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ShortcutKeyCandidate {
            pub _address: u8,
        }
        impl Clone for ShortcutKeyCandidate {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Runnable {
            pub _base: root::nsIRunnable,
            pub _base_1: root::nsINamed,
            pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
            pub mName: *const ::std::os::raw::c_char,
        }
        pub type Runnable_HasThreadSafeRefCnt = root::mozilla::TrueType;
        #[test]
        fn bindgen_test_layout_Runnable() {
            assert_eq!(::std::mem::size_of::<Runnable>() , 32usize);
            assert_eq!(::std::mem::align_of::<Runnable>() , 8usize);
        }
        pub mod css {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(u32)]
            /**
 * Enum defining the mode in which a sheet is to be parsed.  This is
 * usually, but not always, the same as the cascade level at which the
 * sheet will apply (see nsStyleSet.h).  Most of the Loader APIs only
 * support loading of author sheets.
 *
 * Author sheets are the normal case: styles embedded in or linked
 * from HTML pages.  They are also the most restricted.
 *
 * User sheets can do anything author sheets can do, and also get
 * access to a few CSS extensions that are not yet suitable for
 * exposure on the public Web, but are very useful for expressing
 * user style overrides, such as @-moz-document rules.
 *
 * Agent sheets have access to all author- and user-sheet features
 * plus more extensions that are necessary for internal use but,
 * again, not yet suitable for exposure on the public Web.  Some of
 * these are outright unsafe to expose; in particular, incorrect
 * styling of anonymous box pseudo-elements can violate layout
 * invariants.
 */
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum SheetParsingMode {
                eAuthorSheetFeatures = 0,
                eUserSheetFeatures = 1,
                eAgentSheetFeatures = 2,
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Loader {
                pub _address: u8,
            }
            impl Clone for Loader {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct ImageLoader {
                pub _address: u8,
            }
            impl Clone for ImageLoader {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct URLValue {
                pub _base: root::mozilla::css::URLValueData,
            }
            #[test]
            fn bindgen_test_layout_URLValue() {
                assert_eq!(::std::mem::size_of::<URLValue>() , 64usize);
                assert_eq!(::std::mem::align_of::<URLValue>() , 8usize);
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ImageValue {
                pub _base: root::mozilla::css::URLValueData,
                pub mRequests: [u64; 5usize],
            }
            #[test]
            fn bindgen_test_layout_ImageValue() {
                assert_eq!(::std::mem::size_of::<ImageValue>() , 104usize);
                assert_eq!(::std::mem::align_of::<ImageValue>() , 8usize);
            }
            #[repr(C)]
            pub struct URLValueData__bindgen_vtable {
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct URLValueData {
                pub vtable_: *const URLValueData__bindgen_vtable,
                pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
                pub mURI: root::nsMainThreadPtrHandle<root::nsIURI>,
                pub mBaseURI: root::nsMainThreadPtrHandle<root::nsIURI>,
                pub mString: root::RefPtr<root::nsStringBuffer>,
                pub mReferrer: root::nsMainThreadPtrHandle<root::nsIURI>,
                pub mOriginPrincipal: root::nsMainThreadPtrHandle<root::nsIPrincipal>,
                pub mURIResolved: bool,
                pub mIsLocalRef: bool,
            }
            pub type URLValueData_HasThreadSafeRefCnt =
                root::mozilla::TrueType;
            #[test]
            fn bindgen_test_layout_URLValueData() {
                assert_eq!(::std::mem::size_of::<URLValueData>() , 64usize);
                assert_eq!(::std::mem::align_of::<URLValueData>() , 8usize);
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct GridNamedArea {
                pub mName: ::nsstring::nsStringRepr,
                pub mColumnStart: u32,
                pub mColumnEnd: u32,
                pub mRowStart: u32,
                pub mRowEnd: u32,
            }
            #[test]
            fn bindgen_test_layout_GridNamedArea() {
                assert_eq!(::std::mem::size_of::<GridNamedArea>() , 32usize);
                assert_eq!(::std::mem::align_of::<GridNamedArea>() , 8usize);
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct GridTemplateAreasValue {
                pub mNamedAreas: root::nsTArray<root::mozilla::css::GridNamedArea>,
                pub mTemplates: root::nsTArray<::nsstring::nsStringRepr>,
                pub mNColumns: u32,
                pub mRefCnt: root::nsAutoRefCnt,
            }
            pub type GridTemplateAreasValue_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[test]
            fn bindgen_test_layout_GridTemplateAreasValue() {
                assert_eq!(::std::mem::size_of::<GridTemplateAreasValue>() ,
                           32usize);
                assert_eq!(::std::mem::align_of::<GridTemplateAreasValue>() ,
                           8usize);
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct FontFamilyListRefCnt {
                pub _base: root::mozilla::FontFamilyList,
                pub mRefCnt: root::nsAutoRefCnt,
            }
            pub type FontFamilyListRefCnt_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[test]
            fn bindgen_test_layout_FontFamilyListRefCnt() {
                assert_eq!(::std::mem::size_of::<FontFamilyListRefCnt>() ,
                           24usize);
                assert_eq!(::std::mem::align_of::<FontFamilyListRefCnt>() ,
                           8usize);
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct RGBAColorData {
                pub mR: f32,
                pub mG: f32,
                pub mB: f32,
                pub mA: f32,
            }
            #[test]
            fn bindgen_test_layout_RGBAColorData() {
                assert_eq!(::std::mem::size_of::<RGBAColorData>() , 16usize);
                assert_eq!(::std::mem::align_of::<RGBAColorData>() , 4usize);
            }
            impl Clone for RGBAColorData {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct ComplexColorData {
                pub mColor: root::mozilla::css::RGBAColorData,
                pub mForegroundRatio: f32,
            }
            #[test]
            fn bindgen_test_layout_ComplexColorData() {
                assert_eq!(::std::mem::size_of::<ComplexColorData>() ,
                           20usize);
                assert_eq!(::std::mem::align_of::<ComplexColorData>() ,
                           4usize);
            }
            impl Clone for ComplexColorData {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ComplexColorValue {
                pub _base: root::mozilla::css::ComplexColorData,
                pub mRefCnt: root::nsAutoRefCnt,
            }
            pub type ComplexColorValue_HasThreadSafeRefCnt =
                root::mozilla::FalseType;
            #[test]
            fn bindgen_test_layout_ComplexColorValue() {
                assert_eq!(::std::mem::size_of::<ComplexColorValue>() ,
                           32usize);
                assert_eq!(::std::mem::align_of::<ComplexColorValue>() ,
                           8usize);
            }
        }
        /**
 * Superclass for data common to CSSStyleSheet and ServoStyleSheet.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct StyleSheet {
            pub _base: root::nsIDOMCSSStyleSheet,
            pub _base_1: root::nsWrapperCache,
            pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
            pub mTitle: ::nsstring::nsStringRepr,
            pub mDocument: *mut root::nsIDocument,
            pub mOwningNode: *mut root::nsINode,
            pub mParsingMode: root::mozilla::css::SheetParsingMode,
            pub mType: root::StyleBackendType,
            pub mDisabled: bool,
        }
        pub type StyleSheet_HasThreadSafeRefCnt = root::mozilla::FalseType;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleSheet_cycleCollection {
            pub _base: root::nsXPCOMCycleCollectionParticipant,
        }
        #[test]
        fn bindgen_test_layout_StyleSheet_cycleCollection() {
            assert_eq!(::std::mem::size_of::<StyleSheet_cycleCollection>() ,
                       16usize);
            assert_eq!(::std::mem::align_of::<StyleSheet_cycleCollection>() ,
                       8usize);
        }
        impl Clone for StyleSheet_cycleCollection {
            fn clone(&self) -> Self { *self }
        }
        extern "C" {
            #[link_name = "_ZN7mozilla10StyleSheet21_cycleCollectorGlobalE"]
            pub static mut StyleSheet__cycleCollectorGlobal:
                       root::mozilla::StyleSheet_cycleCollection;
        }
        #[test]
        fn bindgen_test_layout_StyleSheet() {
            assert_eq!(::std::mem::size_of::<StyleSheet>() , 80usize);
            assert_eq!(::std::mem::align_of::<StyleSheet>() , 8usize);
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct ServoStyleSheet {
            pub _address: u8,
        }
        impl Clone for ServoStyleSheet {
            fn clone(&self) -> Self { *self }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum Side {
            eSideTop = 0,
            eSideRight = 1,
            eSideBottom = 2,
            eSideLeft = 3,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct SVGAttrAnimationRuleProcessor {
            pub _address: u8,
        }
        impl Clone for SVGAttrAnimationRuleProcessor {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct DeclarationBlock {
            pub _address: u8,
        }
        impl Clone for DeclarationBlock {
            fn clone(&self) -> Self { *self }
        }
        /**
 * A structure representing a single attribute name and value.
 *
 * This is pretty similar to the private nsAttrAndChildArray::InternalAttr.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct ServoAttrSnapshot {
            pub mName: root::nsAttrName,
            pub mValue: root::nsAttrValue,
        }
        #[test]
        fn bindgen_test_layout_ServoAttrSnapshot() {
            assert_eq!(::std::mem::size_of::<ServoAttrSnapshot>() , 16usize);
            assert_eq!(::std::mem::align_of::<ServoAttrSnapshot>() , 8usize);
        }
        #[repr(u8)]
        /**
 * A bitflags enum class used to determine what data does a ServoElementSnapshot
 * contains.
 */
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ServoElementSnapshotFlags {
            State = 1,
            Attributes = 2,
            All = 3,
        }
        /**
 * This class holds all non-tree-structural state of an element that might be
 * used for selector matching eventually.
 *
 * This means the attributes, and the element state, such as :hover, :active,
 * etc...
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct ServoElementSnapshot {
            pub mContains: root::mozilla::ServoElementSnapshot_Flags,
            pub mAttrs: root::nsTArray<root::mozilla::ServoAttrSnapshot>,
            pub mState: root::mozilla::ServoElementSnapshot_ServoStateType,
            pub mIsHTMLElementInHTMLDocument: bool,
            pub mIsInChromeDocument: bool,
        }
        pub type ServoElementSnapshot_BorrowedAttrInfo =
            root::BorrowedAttrInfo;
        pub type ServoElementSnapshot_Element = root::mozilla::dom::Element;
        pub type ServoElementSnapshot_ServoStateType =
            root::EventStates_ServoType;
        pub type ServoElementSnapshot_Flags =
            root::mozilla::ServoElementSnapshotFlags;
        #[test]
        fn bindgen_test_layout_ServoElementSnapshot() {
            assert_eq!(::std::mem::size_of::<ServoElementSnapshot>() ,
                       24usize);
            assert_eq!(::std::mem::align_of::<ServoElementSnapshot>() ,
                       8usize);
        }
        pub mod widget {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct IMEState {
                pub _address: u8,
            }
            impl Clone for IMEState {
                fn clone(&self) -> Self { *self }
            }
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ConsumeStyleBehavior { Consume = 0, DontConsume = 1, }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum TraversalRootBehavior {
            Normal = 0,
            UnstyledChildrenOnly = 1,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum SheetType {
            Agent = 0,
            User = 1,
            PresHint = 2,
            SVGAttrAnimation = 3,
            Doc = 4,
            ScopedDoc = 5,
            StyleAttr = 6,
            Override = 7,
            Animation = 8,
            Transition = 9,
            Count = 10,
            Unknown = 255,
        }
        pub mod a11y {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct DocAccessible {
                pub _address: u8,
            }
            impl Clone for DocAccessible {
                fn clone(&self) -> Self { *self }
            }
        }
        pub const FontFamilyType_eFamily_generic_first:
                  root::mozilla::FontFamilyType =
            FontFamilyType::eFamily_serif;
        pub const FontFamilyType_eFamily_generic_last:
                  root::mozilla::FontFamilyType =
            FontFamilyType::eFamily_fantasy;
        pub const FontFamilyType_eFamily_generic_count:
                  root::mozilla::FontFamilyType =
            FontFamilyType::eFamily_monospace;
        #[repr(u32)]
        /**
 * type of font family name, either a name (e.g. Helvetica) or a
 * generic (e.g. serif, sans-serif), with the ability to distinguish
 * between unquoted and quoted names for serializaiton
 */
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum FontFamilyType {
            eFamily_none = 0,
            eFamily_named = 1,
            eFamily_named_quoted = 2,
            eFamily_serif = 3,
            eFamily_sans_serif = 4,
            eFamily_monospace = 5,
            eFamily_cursive = 6,
            eFamily_fantasy = 7,
            eFamily_moz_variable = 8,
            eFamily_moz_fixed = 9,
        }
        /**
 * font family name, a string for the name if not a generic and
 * a font type indicated named family or which generic family
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct FontFamilyName {
            pub mType: root::mozilla::FontFamilyType,
            pub mName: ::nsstring::nsStringRepr,
        }
        #[test]
        fn bindgen_test_layout_FontFamilyName() {
            assert_eq!(::std::mem::size_of::<FontFamilyName>() , 24usize);
            assert_eq!(::std::mem::align_of::<FontFamilyName>() , 8usize);
        }
        /**
 * font family list, array of font families and a default font type.
 * font family names are either named strings or generics. the default
 * font type is used to preserve the variable font fallback behavior
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct FontFamilyList {
            pub mFontlist: root::nsTArray<root::mozilla::FontFamilyName>,
            pub mDefaultFontType: root::mozilla::FontFamilyType,
        }
        #[test]
        fn bindgen_test_layout_FontFamilyList() {
            assert_eq!(::std::mem::size_of::<FontFamilyList>() , 16usize);
            assert_eq!(::std::mem::align_of::<FontFamilyList>() , 8usize);
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct FramePropertyDescriptorUntyped {
            pub mDestructor: root::mozilla::FramePropertyDescriptorUntyped_UntypedDestructor,
            pub mDestructorWithFrame: root::mozilla::FramePropertyDescriptorUntyped_UntypedDestructorWithFrame,
        }
        /**
   * mDestructor will be called if it's non-null.
   */
        pub type FramePropertyDescriptorUntyped_UntypedDestructor =
            ::std::option::Option<unsafe extern "C" fn(aPropertyValue:
                                                           *mut ::std::os::raw::c_void)>;
        /**
   * mDestructorWithFrame will be called if it's non-null and mDestructor
   * is null. WARNING: The frame passed to mDestructorWithFrame may
   * be a dangling frame pointer, if this is being called during
   * presshell teardown. Do not use it except to compare against
   * other frame pointers. No frame will have been allocated with
   * the same address yet.
   */
        pub type FramePropertyDescriptorUntyped_UntypedDestructorWithFrame =
            ::std::option::Option<unsafe extern "C" fn(aFrame:
                                                           *const root::nsIFrame,
                                                       aPropertyValue:
                                                           *mut ::std::os::raw::c_void)>;
        #[test]
        fn bindgen_test_layout_FramePropertyDescriptorUntyped() {
            assert_eq!(::std::mem::size_of::<FramePropertyDescriptorUntyped>()
                       , 16usize);
            assert_eq!(::std::mem::align_of::<FramePropertyDescriptorUntyped>()
                       , 8usize);
        }
        impl Clone for FramePropertyDescriptorUntyped {
            fn clone(&self) -> Self { *self }
        }
        /**
 * The FramePropertyTable is optimized for storing 0 or 1 properties on
 * a given frame. Storing very large numbers of properties on a single
 * frame will not be efficient.
 *
 * Property values are passed as void* but do not actually have to be
 * valid pointers. You can use NS_INT32_TO_PTR/NS_PTR_TO_INT32 to
 * store int32_t values. Null/zero values can be stored and retrieved.
 * Of course, the destructor function (if any) must handle such values
 * correctly.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct FramePropertyTable {
            pub mEntries: [u64; 5usize],
            pub mLastFrame: *const root::nsIFrame,
            pub mLastEntry: *mut root::mozilla::FramePropertyTable_Entry,
        }
        pub type FramePropertyTable_UntypedDescriptor =
            *const root::mozilla::FramePropertyDescriptorUntyped;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct FramePropertyTable_ReinterpretHelper<T> {
            pub _address: u8,
            pub _phantom_0: ::std::marker::PhantomData<T>,
        }
        /**
   * Stores a property descriptor/value pair. It can also be used to
   * store an nsTArray of PropertyValues.
   */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct FramePropertyTable_PropertyValue {
            pub mProperty: root::mozilla::FramePropertyTable_UntypedDescriptor,
            pub mValue: *mut ::std::os::raw::c_void,
        }
        #[test]
        fn bindgen_test_layout_FramePropertyTable_PropertyValue() {
            assert_eq!(::std::mem::size_of::<FramePropertyTable_PropertyValue>()
                       , 16usize);
            assert_eq!(::std::mem::align_of::<FramePropertyTable_PropertyValue>()
                       , 8usize);
        }
        impl Clone for FramePropertyTable_PropertyValue {
            fn clone(&self) -> Self { *self }
        }
        /**
   * Used with an array of PropertyValues to allow lookups that compare
   * only on the FramePropertyDescriptor.
   */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct FramePropertyTable_PropertyComparator {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_FramePropertyTable_PropertyComparator() {
            assert_eq!(::std::mem::size_of::<FramePropertyTable_PropertyComparator>()
                       , 1usize);
            assert_eq!(::std::mem::align_of::<FramePropertyTable_PropertyComparator>()
                       , 1usize);
        }
        impl Clone for FramePropertyTable_PropertyComparator {
            fn clone(&self) -> Self { *self }
        }
        /**
   * Our hashtable entry. The key is an nsIFrame*, the value is a
   * PropertyValue representing one or more property/value pairs.
   */
        #[repr(C)]
        #[derive(Debug)]
        pub struct FramePropertyTable_Entry {
            pub _base: root::nsPtrHashKey<root::nsIFrame>,
            pub mProp: root::mozilla::FramePropertyTable_PropertyValue,
        }
        #[test]
        fn bindgen_test_layout_FramePropertyTable_Entry() {
            assert_eq!(::std::mem::size_of::<FramePropertyTable_Entry>() ,
                       32usize);
            assert_eq!(::std::mem::align_of::<FramePropertyTable_Entry>() ,
                       8usize);
        }
        #[test]
        fn bindgen_test_layout_FramePropertyTable() {
            assert_eq!(::std::mem::size_of::<FramePropertyTable>() , 56usize);
            assert_eq!(::std::mem::align_of::<FramePropertyTable>() , 8usize);
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBasicShapeType {
            Polygon = 0,
            Circle = 1,
            Ellipse = 2,
            Inset = 3,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxAlign {
            Stretch = 0,
            Start = 1,
            Center = 2,
            Baseline = 3,
            End = 4,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxDecorationBreak { Slice = 0, Clone = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxDirection { Normal = 0, Reverse = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxOrient { Horizontal = 0, Vertical = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxPack { Start = 0, Center = 1, End = 2, Justify = 3, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleBoxSizing { Content = 0, Border = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleClear {
            None = 0,
            Left = 1,
            Right = 2,
            InlineStart = 3,
            InlineEnd = 4,
            Both = 5,
            Line = 8,
            Max = 13,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleGeometryBox {
            Content = 0,
            Padding = 1,
            Border = 2,
            Margin = 3,
            Fill = 4,
            Stroke = 5,
            View = 6,
            NoClip = 7,
            Text = 8,
            NoBox = 9,
            MozAlmostPadding = 127,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleFillRule { Nonzero = 0, Evenodd = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleFloat {
            None = 0,
            Left = 1,
            Right = 2,
            InlineStart = 3,
            InlineEnd = 4,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleFloatEdge { ContentBox = 0, MarginBox = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleShapeOutsideShapeBox {
            NoBox = 0,
            Content = 1,
            Padding = 2,
            Border = 3,
            Margin = 4,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleShapeRadius { FarthestSide = 0, ClosestSide = 1, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleShapeSourceType {
            None = 0,
            URL = 1,
            Shape = 2,
            Box = 3,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleUserFocus {
            None = 0,
            Ignore = 1,
            Normal = 2,
            SelectAll = 3,
            SelectBefore = 4,
            SelectAfter = 5,
            SelectSame = 6,
            SelectMenu = 7,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleUserSelect {
            None = 0,
            Text = 1,
            Element = 2,
            Elements = 3,
            All = 4,
            Toggle = 5,
            TriState = 6,
            Auto = 7,
            MozAll = 8,
            MozText = 9,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleUserInput {
            None = 0,
            Enabled = 1,
            Disabled = 2,
            Auto = 3,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleUserModify {
            ReadOnly = 0,
            ReadWrite = 1,
            WriteOnly = 2,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleWindowDragging { Default = 0, Drag = 1, NoDrag = 2, }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleOrient {
            Inline = 0,
            Block = 1,
            Horizontal = 2,
            Vertical = 3,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StyleDisplay {
            None = 0,
            Block = 1,
            FlowRoot = 2,
            Inline = 3,
            InlineBlock = 4,
            ListItem = 5,
            Table = 6,
            InlineTable = 7,
            TableRowGroup = 8,
            TableColumn = 9,
            TableColumnGroup = 10,
            TableHeaderGroup = 11,
            TableFooterGroup = 12,
            TableRow = 13,
            TableCell = 14,
            TableCaption = 15,
            Flex = 16,
            InlineFlex = 17,
            Grid = 18,
            InlineGrid = 19,
            Ruby = 20,
            RubyBase = 21,
            RubyBaseContainer = 22,
            RubyText = 23,
            RubyTextContainer = 24,
            Contents = 25,
            WebkitBox = 26,
            WebkitInlineBox = 27,
            MozBox = 28,
            MozInlineBox = 29,
            MozGrid = 30,
            MozInlineGrid = 31,
            MozGridGroup = 32,
            MozGridLine = 33,
            MozStack = 34,
            MozInlineStack = 35,
            MozDeck = 36,
            MozGroupbox = 37,
            MozPopup = 38,
        }
        /**
 * A class for holding strong references to handle-managed objects.
 *
 * This is intended for use with objects like RestyleManagerHandle,
 * where the handle type is not a pointer but which can still have
 * ->AddRef() and ->Release() called on it.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct HandleRefPtr<T> {
            pub mHandle: T,
        }
        /**
 * Smart pointer class that can hold a pointer to either a RestyleManager
 * or a ServoRestyleManager.
 */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct RestyleManagerHandle {
            pub mPtr: root::mozilla::RestyleManagerHandle_Ptr,
        }
        pub type RestyleManagerHandle_RefPtr =
            root::mozilla::HandleRefPtr<root::mozilla::RestyleManagerHandle>;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct RestyleManagerHandle_Ptr {
            pub mValue: usize,
        }
        #[test]
        fn bindgen_test_layout_RestyleManagerHandle_Ptr() {
            assert_eq!(::std::mem::size_of::<RestyleManagerHandle_Ptr>() ,
                       8usize);
            assert_eq!(::std::mem::align_of::<RestyleManagerHandle_Ptr>() ,
                       8usize);
        }
        impl Clone for RestyleManagerHandle_Ptr {
            fn clone(&self) -> Self { *self }
        }
        #[test]
        fn bindgen_test_layout_RestyleManagerHandle() {
            assert_eq!(::std::mem::size_of::<RestyleManagerHandle>() ,
                       8usize);
            assert_eq!(::std::mem::align_of::<RestyleManagerHandle>() ,
                       8usize);
        }
        impl Clone for RestyleManagerHandle {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct LangGroupFontPrefs {
            pub mLangGroup: root::nsCOMPtr<root::nsIAtom>,
            pub mMinimumFontSize: root::nscoord,
            pub mDefaultVariableFont: root::nsFont,
            pub mDefaultFixedFont: root::nsFont,
            pub mDefaultSerifFont: root::nsFont,
            pub mDefaultSansSerifFont: root::nsFont,
            pub mDefaultMonospaceFont: root::nsFont,
            pub mDefaultCursiveFont: root::nsFont,
            pub mDefaultFantasyFont: root::nsFont,
            pub mNext: root::nsAutoPtr<root::mozilla::LangGroupFontPrefs>,
        }
        #[test]
        fn bindgen_test_layout_LangGroupFontPrefs() {
            assert_eq!(::std::mem::size_of::<LangGroupFontPrefs>() ,
                       696usize);
            assert_eq!(::std::mem::align_of::<LangGroupFontPrefs>() , 8usize);
        }
        /**
 * Some functionality that has historically lived on nsPresContext does not
 * actually need to be per-document. This singleton class serves as a host
 * for that functionality. We delegate to it from nsPresContext where
 * appropriate, and use it standalone in some cases as well.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct StaticPresData {
            pub mLangService: root::nsCOMPtr<root::nsILanguageAtomService>,
            pub mBorderWidthTable: [root::nscoord; 3usize],
            pub mStaticLangGroupFontPrefs: root::mozilla::LangGroupFontPrefs,
        }
        #[test]
        fn bindgen_test_layout_StaticPresData() {
            assert_eq!(::std::mem::size_of::<StaticPresData>() , 720usize);
            assert_eq!(::std::mem::align_of::<StaticPresData>() , 8usize);
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct EffectCompositor {
            pub _address: u8,
        }
        impl Clone for EffectCompositor {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct EventStateManager {
            pub _address: u8,
        }
        impl Clone for EventStateManager {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct CounterStyleManager {
            pub mRefCnt: root::nsAutoRefCnt,
            pub mPresContext: *mut root::nsPresContext,
            pub mCacheTable: [u64; 5usize],
        }
        pub type CounterStyleManager_HasThreadSafeRefCnt =
            root::mozilla::FalseType;
        #[test]
        fn bindgen_test_layout_CounterStyleManager() {
            assert_eq!(::std::mem::size_of::<CounterStyleManager>() ,
                       56usize);
            assert_eq!(::std::mem::align_of::<CounterStyleManager>() ,
                       8usize);
        }
        /**
 * An DisplayItemClip represents the intersection of an optional rectangle
 * with a list of rounded rectangles (which is often empty), all in appunits.
 * It can represent everything CSS clipping can do to an element (except for
 * SVG clip-path), including no clipping at all.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct DisplayItemClip {
            pub mClipRect: root::nsRect,
            pub mRoundedClipRects: root::nsTArray<root::mozilla::DisplayItemClip_RoundedRect>,
            pub mHaveClipRect: bool,
        }
        pub type DisplayItemClip_Color = root::mozilla::gfx::Color;
        pub type DisplayItemClip_DrawTarget = root::mozilla::gfx::DrawTarget;
        pub type DisplayItemClip_Path = root::mozilla::gfx::Path;
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct DisplayItemClip_RoundedRect {
            pub mRect: root::nsRect,
            pub mRadii: [root::nscoord; 8usize],
        }
        #[test]
        fn bindgen_test_layout_DisplayItemClip_RoundedRect() {
            assert_eq!(::std::mem::size_of::<DisplayItemClip_RoundedRect>() ,
                       48usize);
            assert_eq!(::std::mem::align_of::<DisplayItemClip_RoundedRect>() ,
                       4usize);
        }
        impl Clone for DisplayItemClip_RoundedRect {
            fn clone(&self) -> Self { *self }
        }
        #[test]
        fn bindgen_test_layout_DisplayItemClip() {
            assert_eq!(::std::mem::size_of::<DisplayItemClip>() , 32usize);
            assert_eq!(::std::mem::align_of::<DisplayItemClip>() , 8usize);
        }
        /**
 * This struct represents a combined color from a numeric color and
 * the current foreground color (currentcolor keyword).
 * Conceptually, the formula is "color * (1 - p) + currentcolor * p"
 * where p is mForegroundRatio. See mozilla::LinearBlendColors for
 * the actual algorithm.
 */
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct StyleComplexColor {
            pub mColor: root::nscolor,
            pub mForegroundRatio: u8,
            pub mIsAuto: bool,
        }
        #[test]
        fn bindgen_test_layout_StyleComplexColor() {
            assert_eq!(::std::mem::size_of::<StyleComplexColor>() , 8usize);
            assert_eq!(::std::mem::align_of::<StyleComplexColor>() , 4usize);
        }
        impl Clone for StyleComplexColor {
            fn clone(&self) -> Self { *self }
        }
        #[test]
        fn __bindgen_test_layout_template_1() {
            assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete<root::RawServoStyleSet>>()
                       , 1usize);
            assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete<root::RawServoStyleSet>>()
                       , 1usize);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct CSSVariableValues {
            /**
   * Map of variable names to IDs.  Variable IDs are indexes into
   * mVariables.
   */
            pub mVariableIDs: [u64; 5usize],
            /**
   * Array of variables, indexed by variable ID.
   */
            pub mVariables: root::nsTArray<root::mozilla::CSSVariableValues_Variable>,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct CSSVariableValues_Variable {
            pub mVariableName: ::nsstring::nsStringRepr,
            pub mValue: ::nsstring::nsStringRepr,
            pub mFirstToken: root::nsCSSTokenSerializationType,
            pub mLastToken: root::nsCSSTokenSerializationType,
        }
        #[test]
        fn bindgen_test_layout_CSSVariableValues_Variable() {
            assert_eq!(::std::mem::size_of::<CSSVariableValues_Variable>() ,
                       40usize);
            assert_eq!(::std::mem::align_of::<CSSVariableValues_Variable>() ,
                       8usize);
        }
        #[test]
        fn bindgen_test_layout_CSSVariableValues() {
            assert_eq!(::std::mem::size_of::<CSSVariableValues>() , 48usize);
            assert_eq!(::std::mem::align_of::<CSSVariableValues>() , 8usize);
        }
        #[repr(C)]
        pub struct CounterStyle__bindgen_vtable {
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct CounterStyle {
            pub vtable_: *const CounterStyle__bindgen_vtable,
            pub mStyle: i32,
        }
        #[test]
        fn bindgen_test_layout_CounterStyle() {
            assert_eq!(::std::mem::size_of::<CounterStyle>() , 16usize);
            assert_eq!(::std::mem::align_of::<CounterStyle>() , 8usize);
        }
        impl Clone for CounterStyle {
            fn clone(&self) -> Self { *self }
        }
        pub mod image {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct ImageURL {
                pub _address: u8,
            }
            impl Clone for ImageURL {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct Image {
                pub _address: u8,
            }
            impl Clone for Image {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct ProgressTracker {
                pub _address: u8,
            }
            impl Clone for ProgressTracker {
                fn clone(&self) -> Self { *self }
            }
            #[repr(C)]
            pub struct IProgressObserver__bindgen_vtable {
            }
            /**
 * An interface for observing changes to image state, as reported by
 * ProgressTracker.
 *
 * This is the ImageLib-internal version of imgINotificationObserver,
 * essentially, with implementation details that code outside of ImageLib
 * shouldn't see.
 *
 * XXX(seth): It's preferable to avoid adding anything to this interface if
 * possible.  In the long term, it would be ideal to get to a place where we can
 * just use the imgINotificationObserver interface internally as well.
 */
            #[repr(C)]
            #[derive(Debug)]
            pub struct IProgressObserver {
                pub vtable_: *const IProgressObserver__bindgen_vtable,
                pub _base: u64,
            }
            #[test]
            fn bindgen_test_layout_IProgressObserver() {
                assert_eq!(::std::mem::size_of::<IProgressObserver>() ,
                           16usize);
                assert_eq!(::std::mem::align_of::<IProgressObserver>() ,
                           8usize);
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct Position {
            pub mXPosition: root::mozilla::Position_Coord,
            pub mYPosition: root::mozilla::Position_Coord,
        }
        pub type Position_Coord = root::nsStyleCoord_CalcValue;
        #[test]
        fn bindgen_test_layout_Position() {
            assert_eq!(::std::mem::size_of::<Position>() , 24usize);
            assert_eq!(::std::mem::align_of::<Position>() , 4usize);
        }
        impl Clone for Position {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct StyleTransition {
            pub mTimingFunction: root::nsTimingFunction,
            pub mDuration: f32,
            pub mDelay: f32,
            pub mProperty: root::nsCSSPropertyID,
            pub mUnknownProperty: root::nsCOMPtr<root::nsIAtom>,
        }
        #[test]
        fn bindgen_test_layout_StyleTransition() {
            assert_eq!(::std::mem::size_of::<StyleTransition>() , 40usize);
            assert_eq!(::std::mem::align_of::<StyleTransition>() , 8usize);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct StyleAnimation {
            pub mTimingFunction: root::nsTimingFunction,
            pub mDuration: f32,
            pub mDelay: f32,
            pub mName: ::nsstring::nsStringRepr,
            pub mDirection: root::mozilla::dom::PlaybackDirection,
            pub mFillMode: root::mozilla::dom::FillMode,
            pub mPlayState: u8,
            pub mIterationCount: f32,
        }
        #[test]
        fn bindgen_test_layout_StyleAnimation() {
            assert_eq!(::std::mem::size_of::<StyleAnimation>() , 64usize);
            assert_eq!(::std::mem::align_of::<StyleAnimation>() , 8usize);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct StyleBasicShape {
            pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
            pub mType: root::mozilla::StyleBasicShapeType,
            pub mFillRule: root::mozilla::StyleFillRule,
            pub mCoordinates: root::nsTArray<root::nsStyleCoord>,
            pub mPosition: root::mozilla::Position,
            pub mRadius: root::nsStyleCorners,
        }
        pub type StyleBasicShape_HasThreadSafeRefCnt =
            root::mozilla::TrueType;
        #[test]
        fn bindgen_test_layout_StyleBasicShape() {
            assert_eq!(::std::mem::size_of::<StyleBasicShape>() , 120usize);
            assert_eq!(::std::mem::align_of::<StyleBasicShape>() , 8usize);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct StyleShapeSource<ReferenceBox> {
            pub __bindgen_anon_1: root::mozilla::StyleShapeSource__bindgen_ty_1<ReferenceBox>,
            pub mType: root::mozilla::StyleShapeSourceType,
            pub mReferenceBox: ReferenceBox,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StyleShapeSource__bindgen_ty_1<ReferenceBox> {
            pub mBasicShape: root::__BindgenUnionField<*mut root::mozilla::StyleBasicShape>,
            pub mURL: root::__BindgenUnionField<*mut root::mozilla::css::URLValue>,
            pub bindgen_union_field: u64,
            pub _phantom_0: ::std::marker::PhantomData<ReferenceBox>,
        }
        pub type StyleClipPath =
            root::mozilla::StyleShapeSource<root::mozilla::StyleGeometryBox>;
        pub type StyleShapeOutside =
            root::mozilla::StyleShapeSource<root::mozilla::StyleShapeOutsideShapeBox>;
        #[test]
        fn __bindgen_test_layout_template_2() {
            assert_eq!(::std::mem::size_of::<root::mozilla::StyleShapeSource<root::mozilla::StyleGeometryBox>>()
                       , 16usize);
            assert_eq!(::std::mem::align_of::<root::mozilla::StyleShapeSource<root::mozilla::StyleGeometryBox>>()
                       , 8usize);
        }
        #[test]
        fn __bindgen_test_layout_template_3() {
            assert_eq!(::std::mem::size_of::<root::mozilla::StyleShapeSource<root::mozilla::StyleShapeOutsideShapeBox>>()
                       , 16usize);
            assert_eq!(::std::mem::align_of::<root::mozilla::StyleShapeSource<root::mozilla::StyleShapeOutsideShapeBox>>()
                       , 8usize);
        }
        /**
 * <div rustbindgen="true" replaces="mozilla::UniquePtr">
 *
 * TODO(Emilio): This is a workaround and we should be able to get rid of this
 * one.
 */
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct UniquePtr<T, Deleter> {
            pub mPtr: *mut T,
            pub _phantom_1: ::std::marker::PhantomData<Deleter>,
        }
    }
    /**
 * MozRefCountType is Mozilla's reference count type.
 *
 * We use the same type to represent the refcount of RefCounted objects
 * as well, in order to be able to use the leak detection facilities
 * that are implemented by XPCOM.
 *
 * Note that this type is not in the mozilla namespace so that it is
 * usable for both C and C++ code.
 */
    pub type MozRefCountType = usize;
    pub const nsresult_NS_ERROR_NO_INTERFACE: root::nsresult =
        nsresult::NS_NOINTERFACE;
    pub const nsresult_NS_ERROR_INVALID_ARG: root::nsresult =
        nsresult::NS_ERROR_ILLEGAL_VALUE;
    pub const nsresult_NS_ERROR_INVALID_POINTER: root::nsresult =
        nsresult::NS_ERROR_ILLEGAL_VALUE;
    pub const nsresult_NS_ERROR_NULL_POINTER: root::nsresult =
        nsresult::NS_ERROR_ILLEGAL_VALUE;
    pub const nsresult_NS_BINDING_SUCCEEDED: root::nsresult = nsresult::NS_OK;
    pub const nsresult_NS_NET_STATUS_RESOLVING_HOST: root::nsresult =
        nsresult::NS_BINDING_REDIRECTED;
    pub const nsresult_NS_NET_STATUS_RESOLVED_HOST: root::nsresult =
        nsresult::NS_ERROR_ALREADY_CONNECTED;
    pub const nsresult_NS_NET_STATUS_CONNECTED_TO: root::nsresult =
        nsresult::NS_BINDING_RETARGETED;
    pub const nsresult_NS_NET_STATUS_WAITING_FOR: root::nsresult =
        nsresult::NS_ERROR_MALFORMED_URI;
    pub const nsresult_NS_STATE_PROPERTY_EXISTS: root::nsresult =
        nsresult::NS_OK;
    pub const nsresult_NS_ERROR_HTMLPARSER_CONTINUE: root::nsresult =
        nsresult::NS_OK;
    pub const nsresult_NS_RDF_ASSERTION_ACCEPTED: root::nsresult =
        nsresult::NS_OK;
    pub const nsresult_NS_EXACT_LENGTH: root::nsresult =
        nsresult::NS_OK_UDEC_EXACTLENGTH;
    pub const nsresult_NS_PARTIAL_MORE_INPUT: root::nsresult =
        nsresult::NS_OK_UDEC_MOREINPUT;
    pub const nsresult_NS_PARTIAL_MORE_OUTPUT: root::nsresult =
        nsresult::NS_OK_UDEC_MOREOUTPUT;
    pub const nsresult_NS_ERROR_ILLEGAL_INPUT: root::nsresult =
        nsresult::NS_ERROR_UDEC_ILLEGALINPUT;
    pub const nsresult_NS_ERROR_XPATH_INVALID_ARG: root::nsresult =
        nsresult::NS_ERROR_ILLEGAL_VALUE;
    pub const nsresult_NS_SUCCESS_RESTART_APP: root::nsresult =
        nsresult::NS_SUCCESS_DONT_FIXUP;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsresult {
        NS_OK = 0,
        NS_ERROR_BASE = 3253927936,
        NS_ERROR_NOT_INITIALIZED = 3253927937,
        NS_ERROR_ALREADY_INITIALIZED = 3253927938,
        NS_ERROR_NOT_IMPLEMENTED = 2147500033,
        NS_NOINTERFACE = 2147500034,
        NS_ERROR_ABORT = 2147500036,
        NS_ERROR_FAILURE = 2147500037,
        NS_ERROR_UNEXPECTED = 2147549183,
        NS_ERROR_OUT_OF_MEMORY = 2147942414,
        NS_ERROR_ILLEGAL_VALUE = 2147942487,
        NS_ERROR_NO_AGGREGATION = 2147746064,
        NS_ERROR_NOT_AVAILABLE = 2147746065,
        NS_ERROR_FACTORY_NOT_REGISTERED = 2147746132,
        NS_ERROR_FACTORY_REGISTER_AGAIN = 2147746133,
        NS_ERROR_FACTORY_NOT_LOADED = 2147746296,
        NS_ERROR_FACTORY_NO_SIGNATURE_SUPPORT = 3253928193,
        NS_ERROR_FACTORY_EXISTS = 3253928192,
        NS_ERROR_CANNOT_CONVERT_DATA = 2152071169,
        NS_ERROR_OBJECT_IS_IMMUTABLE = 2152071170,
        NS_ERROR_LOSS_OF_SIGNIFICANT_DATA = 2152071171,
        NS_ERROR_NOT_SAME_THREAD = 2152071172,
        NS_ERROR_ILLEGAL_DURING_SHUTDOWN = 2152071198,
        NS_ERROR_SERVICE_NOT_AVAILABLE = 2152071190,
        NS_SUCCESS_LOSS_OF_INSIGNIFICANT_DATA = 4587521,
        NS_SUCCESS_INTERRUPTED_TRAVERSE = 4587522,
        NS_ERROR_SERVICE_NOT_FOUND = 4587542,
        NS_ERROR_SERVICE_IN_USE = 4587543,
        NS_BASE_STREAM_CLOSED = 2152136706,
        NS_BASE_STREAM_OSERROR = 2152136707,
        NS_BASE_STREAM_ILLEGAL_ARGS = 2152136708,
        NS_BASE_STREAM_NO_CONVERTER = 2152136709,
        NS_BASE_STREAM_BAD_CONVERSION = 2152136710,
        NS_BASE_STREAM_WOULD_BLOCK = 2152136711,
        NS_ERROR_GFX_PRINTER_NO_PRINTER_AVAILABLE = 2152202241,
        NS_ERROR_GFX_PRINTER_NAME_NOT_FOUND = 2152202242,
        NS_ERROR_GFX_PRINTER_COULD_NOT_OPEN_FILE = 2152202243,
        NS_ERROR_GFX_PRINTER_STARTDOC = 2152202244,
        NS_ERROR_GFX_PRINTER_ENDDOC = 2152202245,
        NS_ERROR_GFX_PRINTER_STARTPAGE = 2152202246,
        NS_ERROR_GFX_PRINTER_DOC_IS_BUSY = 2152202247,
        NS_ERROR_GFX_CMAP_MALFORMED = 2152202291,
        NS_SUCCESS_EVENT_CONSUMED = 4784129,
        NS_SUCCESS_EVENT_HANDLED_ASYNCHRONOUSLY = 4784130,
        NS_BINDING_FAILED = 2152398849,
        NS_BINDING_ABORTED = 2152398850,
        NS_BINDING_REDIRECTED = 2152398851,
        NS_BINDING_RETARGETED = 2152398852,
        NS_ERROR_MALFORMED_URI = 2152398858,
        NS_ERROR_IN_PROGRESS = 2152398863,
        NS_ERROR_NO_CONTENT = 2152398865,
        NS_ERROR_UNKNOWN_PROTOCOL = 2152398866,
        NS_ERROR_INVALID_CONTENT_ENCODING = 2152398875,
        NS_ERROR_CORRUPTED_CONTENT = 2152398877,
        NS_ERROR_INVALID_SIGNATURE = 2152398906,
        NS_ERROR_FIRST_HEADER_FIELD_COMPONENT_EMPTY = 2152398882,
        NS_ERROR_ALREADY_OPENED = 2152398921,
        NS_ERROR_ALREADY_CONNECTED = 2152398859,
        NS_ERROR_NOT_CONNECTED = 2152398860,
        NS_ERROR_CONNECTION_REFUSED = 2152398861,
        NS_ERROR_NET_TIMEOUT = 2152398862,
        NS_ERROR_OFFLINE = 2152398864,
        NS_ERROR_PORT_ACCESS_NOT_ALLOWED = 2152398867,
        NS_ERROR_NET_RESET = 2152398868,
        NS_ERROR_NET_INTERRUPT = 2152398919,
        NS_ERROR_PROXY_CONNECTION_REFUSED = 2152398920,
        NS_ERROR_NET_PARTIAL_TRANSFER = 2152398924,
        NS_ERROR_NET_INADEQUATE_SECURITY = 2152398930,
        NS_ERROR_NOT_RESUMABLE = 2152398873,
        NS_ERROR_REDIRECT_LOOP = 2152398879,
        NS_ERROR_ENTITY_CHANGED = 2152398880,
        NS_ERROR_UNSAFE_CONTENT_TYPE = 2152398922,
        NS_ERROR_REMOTE_XUL = 2152398923,
        NS_ERROR_LOAD_SHOWED_ERRORPAGE = 2152398925,
        NS_ERROR_FTP_LOGIN = 2152398869,
        NS_ERROR_FTP_CWD = 2152398870,
        NS_ERROR_FTP_PASV = 2152398871,
        NS_ERROR_FTP_PWD = 2152398872,
        NS_ERROR_FTP_LIST = 2152398876,
        NS_ERROR_UNKNOWN_HOST = 2152398878,
        NS_ERROR_DNS_LOOKUP_QUEUE_FULL = 2152398881,
        NS_ERROR_UNKNOWN_PROXY_HOST = 2152398890,
        NS_ERROR_UNKNOWN_SOCKET_TYPE = 2152398899,
        NS_ERROR_SOCKET_CREATE_FAILED = 2152398900,
        NS_ERROR_SOCKET_ADDRESS_NOT_SUPPORTED = 2152398901,
        NS_ERROR_SOCKET_ADDRESS_IN_USE = 2152398902,
        NS_ERROR_CACHE_KEY_NOT_FOUND = 2152398909,
        NS_ERROR_CACHE_DATA_IS_STREAM = 2152398910,
        NS_ERROR_CACHE_DATA_IS_NOT_STREAM = 2152398911,
        NS_ERROR_CACHE_WAIT_FOR_VALIDATION = 2152398912,
        NS_ERROR_CACHE_ENTRY_DOOMED = 2152398913,
        NS_ERROR_CACHE_READ_ACCESS_DENIED = 2152398914,
        NS_ERROR_CACHE_WRITE_ACCESS_DENIED = 2152398915,
        NS_ERROR_CACHE_IN_USE = 2152398916,
        NS_ERROR_DOCUMENT_NOT_CACHED = 2152398918,
        NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS = 2152398928,
        NS_ERROR_HOST_IS_IP_ADDRESS = 2152398929,
        NS_SUCCESS_ADOPTED_DATA = 4915290,
        NS_NET_STATUS_BEGIN_FTP_TRANSACTION = 4915227,
        NS_NET_STATUS_END_FTP_TRANSACTION = 4915228,
        NS_SUCCESS_AUTH_FINISHED = 4915240,
        NS_NET_STATUS_READING = 2152398856,
        NS_NET_STATUS_WRITING = 2152398857,
        NS_NET_STATUS_CONNECTING_TO = 2152398855,
        NS_NET_STATUS_SENDING_TO = 2152398853,
        NS_NET_STATUS_RECEIVING_FROM = 2152398854,
        NS_ERROR_INTERCEPTION_FAILED = 2152398948,
        NS_ERROR_PLUGINS_PLUGINSNOTCHANGED = 2152465384,
        NS_ERROR_PLUGIN_DISABLED = 2152465385,
        NS_ERROR_PLUGIN_BLOCKLISTED = 2152465386,
        NS_ERROR_PLUGIN_TIME_RANGE_NOT_SUPPORTED = 2152465387,
        NS_ERROR_PLUGIN_CLICKTOPLAY = 2152465388,
        NS_PLUGIN_INIT_PENDING = 4981741,
        NS_TABLELAYOUT_CELL_NOT_FOUND = 5046272,
        NS_POSITION_BEFORE_TABLE = 5046275,
        NS_STATE_PROPERTY_NOT_THERE = 5046277,
        NS_ERROR_HTMLPARSER_EOF = 2152596456,
        NS_ERROR_HTMLPARSER_UNKNOWN = 2152596457,
        NS_ERROR_HTMLPARSER_CANTPROPAGATE = 2152596458,
        NS_ERROR_HTMLPARSER_CONTEXTMISMATCH = 2152596459,
        NS_ERROR_HTMLPARSER_BADFILENAME = 2152596460,
        NS_ERROR_HTMLPARSER_BADURL = 2152596461,
        NS_ERROR_HTMLPARSER_INVALIDPARSERCONTEXT = 2152596462,
        NS_ERROR_HTMLPARSER_INTERRUPTED = 2152596463,
        NS_ERROR_HTMLPARSER_BLOCK = 2152596464,
        NS_ERROR_HTMLPARSER_BADTOKENIZER = 2152596465,
        NS_ERROR_HTMLPARSER_BADATTRIBUTE = 2152596466,
        NS_ERROR_HTMLPARSER_UNRESOLVEDDTD = 2152596467,
        NS_ERROR_HTMLPARSER_MISPLACEDTABLECONTENT = 2152596468,
        NS_ERROR_HTMLPARSER_BADDTD = 2152596469,
        NS_ERROR_HTMLPARSER_BADCONTEXT = 2152596470,
        NS_ERROR_HTMLPARSER_STOPPARSING = 2152596471,
        NS_ERROR_HTMLPARSER_UNTERMINATEDSTRINGLITERAL = 2152596472,
        NS_ERROR_HTMLPARSER_HIERARCHYTOODEEP = 2152596473,
        NS_ERROR_HTMLPARSER_FAKE_ENDTAG = 2152596474,
        NS_ERROR_HTMLPARSER_INVALID_COMMENT = 2152596475,
        NS_HTMLTOKENS_NOT_AN_ENTITY = 5113808,
        NS_HTMLPARSER_VALID_META_CHARSET = 5114808,
        NS_RDF_CURSOR_EMPTY = 5177345,
        NS_RDF_NO_VALUE = 5177346,
        NS_RDF_ASSERTION_REJECTED = 5177347,
        NS_RDF_STOP_VISIT = 5177348,
        NS_ERROR_UCONV_NOCONV = 2152726529,
        NS_ERROR_UDEC_ILLEGALINPUT = 2152726542,
        NS_SUCCESS_USING_FALLBACK_LOCALE = 5242882,
        NS_OK_UDEC_EXACTLENGTH = 5242891,
        NS_OK_UDEC_MOREINPUT = 5242892,
        NS_OK_UDEC_MOREOUTPUT = 5242893,
        NS_OK_UDEC_NOBOMFOUND = 5242894,
        NS_OK_UENC_EXACTLENGTH = 5242913,
        NS_OK_UENC_MOREOUTPUT = 5242914,
        NS_ERROR_UENC_NOMAPPING = 5242915,
        NS_OK_UENC_MOREINPUT = 5242916,
        NS_ERROR_FILE_UNRECOGNIZED_PATH = 2152857601,
        NS_ERROR_FILE_UNRESOLVABLE_SYMLINK = 2152857602,
        NS_ERROR_FILE_EXECUTION_FAILED = 2152857603,
        NS_ERROR_FILE_UNKNOWN_TYPE = 2152857604,
        NS_ERROR_FILE_DESTINATION_NOT_DIR = 2152857605,
        NS_ERROR_FILE_TARGET_DOES_NOT_EXIST = 2152857606,
        NS_ERROR_FILE_COPY_OR_MOVE_FAILED = 2152857607,
        NS_ERROR_FILE_ALREADY_EXISTS = 2152857608,
        NS_ERROR_FILE_INVALID_PATH = 2152857609,
        NS_ERROR_FILE_DISK_FULL = 2152857610,
        NS_ERROR_FILE_CORRUPTED = 2152857611,
        NS_ERROR_FILE_NOT_DIRECTORY = 2152857612,
        NS_ERROR_FILE_IS_DIRECTORY = 2152857613,
        NS_ERROR_FILE_IS_LOCKED = 2152857614,
        NS_ERROR_FILE_TOO_BIG = 2152857615,
        NS_ERROR_FILE_NO_DEVICE_SPACE = 2152857616,
        NS_ERROR_FILE_NAME_TOO_LONG = 2152857617,
        NS_ERROR_FILE_NOT_FOUND = 2152857618,
        NS_ERROR_FILE_READ_ONLY = 2152857619,
        NS_ERROR_FILE_DIR_NOT_EMPTY = 2152857620,
        NS_ERROR_FILE_ACCESS_DENIED = 2152857621,
        NS_SUCCESS_FILE_DIRECTORY_EMPTY = 5373953,
        NS_SUCCESS_AGGREGATE_RESULT = 5373954,
        NS_ERROR_DOM_INDEX_SIZE_ERR = 2152923137,
        NS_ERROR_DOM_HIERARCHY_REQUEST_ERR = 2152923139,
        NS_ERROR_DOM_WRONG_DOCUMENT_ERR = 2152923140,
        NS_ERROR_DOM_INVALID_CHARACTER_ERR = 2152923141,
        NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR = 2152923143,
        NS_ERROR_DOM_NOT_FOUND_ERR = 2152923144,
        NS_ERROR_DOM_NOT_SUPPORTED_ERR = 2152923145,
        NS_ERROR_DOM_INUSE_ATTRIBUTE_ERR = 2152923146,
        NS_ERROR_DOM_INVALID_STATE_ERR = 2152923147,
        NS_ERROR_DOM_SYNTAX_ERR = 2152923148,
        NS_ERROR_DOM_INVALID_MODIFICATION_ERR = 2152923149,
        NS_ERROR_DOM_NAMESPACE_ERR = 2152923150,
        NS_ERROR_DOM_INVALID_ACCESS_ERR = 2152923151,
        NS_ERROR_DOM_TYPE_MISMATCH_ERR = 2152923153,
        NS_ERROR_DOM_SECURITY_ERR = 2152923154,
        NS_ERROR_DOM_NETWORK_ERR = 2152923155,
        NS_ERROR_DOM_ABORT_ERR = 2152923156,
        NS_ERROR_DOM_URL_MISMATCH_ERR = 2152923157,
        NS_ERROR_DOM_QUOTA_EXCEEDED_ERR = 2152923158,
        NS_ERROR_DOM_TIMEOUT_ERR = 2152923159,
        NS_ERROR_DOM_INVALID_NODE_TYPE_ERR = 2152923160,
        NS_ERROR_DOM_DATA_CLONE_ERR = 2152923161,
        NS_ERROR_TYPE_ERR = 2152923162,
        NS_ERROR_RANGE_ERR = 2152923163,
        NS_ERROR_DOM_ENCODING_NOT_SUPPORTED_ERR = 2152923164,
        NS_ERROR_DOM_INVALID_POINTER_ERR = 2152923165,
        NS_ERROR_DOM_UNKNOWN_ERR = 2152923166,
        NS_ERROR_DOM_DATA_ERR = 2152923167,
        NS_ERROR_DOM_OPERATION_ERR = 2152923168,
        NS_ERROR_DOM_NOT_ALLOWED_ERR = 2152923169,
        NS_ERROR_DOM_SECMAN_ERR = 2152924137,
        NS_ERROR_DOM_WRONG_TYPE_ERR = 2152924138,
        NS_ERROR_DOM_NOT_OBJECT_ERR = 2152924139,
        NS_ERROR_DOM_NOT_XPC_OBJECT_ERR = 2152924140,
        NS_ERROR_DOM_NOT_NUMBER_ERR = 2152924141,
        NS_ERROR_DOM_NOT_BOOLEAN_ERR = 2152924142,
        NS_ERROR_DOM_NOT_FUNCTION_ERR = 2152924143,
        NS_ERROR_DOM_TOO_FEW_PARAMETERS_ERR = 2152924144,
        NS_ERROR_DOM_BAD_DOCUMENT_DOMAIN = 2152924145,
        NS_ERROR_DOM_PROP_ACCESS_DENIED = 2152924146,
        NS_ERROR_DOM_XPCONNECT_ACCESS_DENIED = 2152924147,
        NS_ERROR_DOM_BAD_URI = 2152924148,
        NS_ERROR_DOM_RETVAL_UNDEFINED = 2152924149,
        NS_ERROR_DOM_QUOTA_REACHED = 2152924150,
        NS_ERROR_DOM_JS_EXCEPTION = 2152924151,
        NS_ERROR_UNCATCHABLE_EXCEPTION = 2152924152,
        NS_ERROR_DOM_DOMEXCEPTION = 2152924153,
        NS_ERROR_DOM_EXCEPTION_ON_JSCONTEXT = 2152924154,
        NS_ERROR_DOM_MALFORMED_URI = 2152924155,
        NS_ERROR_DOM_INVALID_HEADER_NAME = 2152924156,
        NS_ERROR_DOM_INVALID_STATE_XHR_HAS_INVALID_CONTEXT = 2152924157,
        NS_ERROR_DOM_INVALID_STATE_XHR_MUST_BE_OPENED = 2152924158,
        NS_ERROR_DOM_INVALID_STATE_XHR_MUST_NOT_BE_SENDING = 2152924159,
        NS_ERROR_DOM_INVALID_STATE_XHR_MUST_NOT_BE_LOADING_OR_DONE =
            2152924160,
        NS_ERROR_DOM_INVALID_STATE_XHR_HAS_WRONG_RESPONSETYPE_FOR_RESPONSEXML
            = 2152924161,
        NS_ERROR_DOM_INVALID_STATE_XHR_HAS_WRONG_RESPONSETYPE_FOR_RESPONSETEXT
            = 2152924162,
        NS_ERROR_DOM_INVALID_STATE_XHR_CHUNKED_RESPONSETYPES_UNSUPPORTED_FOR_SYNC
            = 2152924163,
        NS_ERROR_DOM_INVALID_ACCESS_XHR_TIMEOUT_AND_RESPONSETYPE_UNSUPPORTED_FOR_SYNC
            = 2152924164,
        NS_SUCCESS_DOM_NO_OPERATION = 5439489,
        NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW = 5439490,
        NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW_UNCATCHABLE = 5439491,
        NS_IMAGELIB_SUCCESS_LOAD_FINISHED = 5505024,
        NS_IMAGELIB_CHANGING_OWNER = 5505025,
        NS_IMAGELIB_ERROR_FAILURE = 2152988677,
        NS_IMAGELIB_ERROR_NO_DECODER = 2152988678,
        NS_IMAGELIB_ERROR_NOT_FINISHED = 2152988679,
        NS_IMAGELIB_ERROR_NO_ENCODER = 2152988681,
        NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND = 5636097,
        NS_SUCCESS_EDITOR_FOUND_TARGET = 5636098,
        NS_ERROR_XPC_NOT_ENOUGH_ARGS = 2153185281,
        NS_ERROR_XPC_NEED_OUT_OBJECT = 2153185282,
        NS_ERROR_XPC_CANT_SET_OUT_VAL = 2153185283,
        NS_ERROR_XPC_NATIVE_RETURNED_FAILURE = 2153185284,
        NS_ERROR_XPC_CANT_GET_INTERFACE_INFO = 2153185285,
        NS_ERROR_XPC_CANT_GET_PARAM_IFACE_INFO = 2153185286,
        NS_ERROR_XPC_CANT_GET_METHOD_INFO = 2153185287,
        NS_ERROR_XPC_UNEXPECTED = 2153185288,
        NS_ERROR_XPC_BAD_CONVERT_JS = 2153185289,
        NS_ERROR_XPC_BAD_CONVERT_NATIVE = 2153185290,
        NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF = 2153185291,
        NS_ERROR_XPC_BAD_OP_ON_WN_PROTO = 2153185292,
        NS_ERROR_XPC_CANT_CONVERT_WN_TO_FUN = 2153185293,
        NS_ERROR_XPC_CANT_DEFINE_PROP_ON_WN = 2153185294,
        NS_ERROR_XPC_CANT_WATCH_WN_STATIC = 2153185295,
        NS_ERROR_XPC_CANT_EXPORT_WN_STATIC = 2153185296,
        NS_ERROR_XPC_SCRIPTABLE_CALL_FAILED = 2153185297,
        NS_ERROR_XPC_SCRIPTABLE_CTOR_FAILED = 2153185298,
        NS_ERROR_XPC_CANT_CALL_WO_SCRIPTABLE = 2153185299,
        NS_ERROR_XPC_CANT_CTOR_WO_SCRIPTABLE = 2153185300,
        NS_ERROR_XPC_CI_RETURNED_FAILURE = 2153185301,
        NS_ERROR_XPC_GS_RETURNED_FAILURE = 2153185302,
        NS_ERROR_XPC_BAD_CID = 2153185303,
        NS_ERROR_XPC_BAD_IID = 2153185304,
        NS_ERROR_XPC_CANT_CREATE_WN = 2153185305,
        NS_ERROR_XPC_JS_THREW_EXCEPTION = 2153185306,
        NS_ERROR_XPC_JS_THREW_NATIVE_OBJECT = 2153185307,
        NS_ERROR_XPC_JS_THREW_JS_OBJECT = 2153185308,
        NS_ERROR_XPC_JS_THREW_NULL = 2153185309,
        NS_ERROR_XPC_JS_THREW_STRING = 2153185310,
        NS_ERROR_XPC_JS_THREW_NUMBER = 2153185311,
        NS_ERROR_XPC_JAVASCRIPT_ERROR = 2153185312,
        NS_ERROR_XPC_JAVASCRIPT_ERROR_WITH_DETAILS = 2153185313,
        NS_ERROR_XPC_CANT_CONVERT_PRIMITIVE_TO_ARRAY = 2153185314,
        NS_ERROR_XPC_CANT_CONVERT_OBJECT_TO_ARRAY = 2153185315,
        NS_ERROR_XPC_NOT_ENOUGH_ELEMENTS_IN_ARRAY = 2153185316,
        NS_ERROR_XPC_CANT_GET_ARRAY_INFO = 2153185317,
        NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING = 2153185318,
        NS_ERROR_XPC_SECURITY_MANAGER_VETO = 2153185319,
        NS_ERROR_XPC_INTERFACE_NOT_SCRIPTABLE = 2153185320,
        NS_ERROR_XPC_INTERFACE_NOT_FROM_NSISUPPORTS = 2153185321,
        NS_ERROR_XPC_CANT_GET_JSOBJECT_OF_DOM_OBJECT = 2153185322,
        NS_ERROR_XPC_CANT_SET_READ_ONLY_CONSTANT = 2153185323,
        NS_ERROR_XPC_CANT_SET_READ_ONLY_ATTRIBUTE = 2153185324,
        NS_ERROR_XPC_CANT_SET_READ_ONLY_METHOD = 2153185325,
        NS_ERROR_XPC_CANT_ADD_PROP_TO_WRAPPED_NATIVE = 2153185326,
        NS_ERROR_XPC_CALL_TO_SCRIPTABLE_FAILED = 2153185327,
        NS_ERROR_XPC_JSOBJECT_HAS_NO_FUNCTION_NAMED = 2153185328,
        NS_ERROR_XPC_BAD_ID_STRING = 2153185329,
        NS_ERROR_XPC_BAD_INITIALIZER_NAME = 2153185330,
        NS_ERROR_XPC_HAS_BEEN_SHUTDOWN = 2153185331,
        NS_ERROR_XPC_CANT_MODIFY_PROP_ON_WN = 2153185332,
        NS_ERROR_XPC_BAD_CONVERT_JS_ZERO_ISNOT_NULL = 2153185333,
        NS_ERROR_XPC_CANT_PASS_CPOW_TO_NATIVE = 2153185334,
        NS_ERROR_LAUNCHED_CHILD_PROCESS = 2153251016,
        NS_ERROR_CSP_FORM_ACTION_VIOLATION = 2153381986,
        NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION = 2153381987,
        NS_ERROR_SRI_CORRUPT = 2153382088,
        NS_ERROR_SRI_DISABLED = 2153382089,
        NS_ERROR_SRI_NOT_ELIGIBLE = 2153382090,
        NS_ERROR_SRI_UNEXPECTED_HASH_TYPE = 2153382091,
        NS_ERROR_SRI_IMPORT = 2153382092,
        NS_ERROR_CMS_VERIFY_NOT_SIGNED = 2153382912,
        NS_ERROR_CMS_VERIFY_NO_CONTENT_INFO = 2153382913,
        NS_ERROR_CMS_VERIFY_BAD_DIGEST = 2153382914,
        NS_ERROR_CMS_VERIFY_NOCERT = 2153382916,
        NS_ERROR_CMS_VERIFY_UNTRUSTED = 2153382917,
        NS_ERROR_CMS_VERIFY_ERROR_UNVERIFIED = 2153382919,
        NS_ERROR_CMS_VERIFY_ERROR_PROCESSING = 2153382920,
        NS_ERROR_CMS_VERIFY_BAD_SIGNATURE = 2153382921,
        NS_ERROR_CMS_VERIFY_DIGEST_MISMATCH = 2153382922,
        NS_ERROR_CMS_VERIFY_UNKNOWN_ALGO = 2153382923,
        NS_ERROR_CMS_VERIFY_UNSUPPORTED_ALGO = 2153382924,
        NS_ERROR_CMS_VERIFY_MALFORMED_SIGNATURE = 2153382925,
        NS_ERROR_CMS_VERIFY_HEADER_MISMATCH = 2153382926,
        NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED = 2153382927,
        NS_ERROR_CMS_VERIFY_CERT_WITHOUT_ADDRESS = 2153382928,
        NS_ERROR_CMS_ENCRYPT_NO_BULK_ALG = 2153382944,
        NS_ERROR_CMS_ENCRYPT_INCOMPLETE = 2153382945,
        NS_ERROR_DOM_INVALID_EXPRESSION_ERR = 2153447475,
        NS_ERROR_DOM_TYPE_ERR = 2153447476,
        NS_ERROR_WONT_HANDLE_CONTENT = 2153578497,
        NS_ERROR_MALWARE_URI = 2153578526,
        NS_ERROR_PHISHING_URI = 2153578527,
        NS_ERROR_TRACKING_URI = 2153578530,
        NS_ERROR_UNWANTED_URI = 2153578531,
        NS_ERROR_BLOCKED_URI = 2153578533,
        NS_ERROR_SAVE_LINK_AS_TIMEOUT = 2153578528,
        NS_ERROR_PARSED_DATA_CACHED = 2153578529,
        NS_REFRESHURI_HEADER_FOUND = 6094850,
        NS_ERROR_IMAGE_SRC_CHANGED = 2153644036,
        NS_ERROR_IMAGE_BLOCKED = 2153644037,
        NS_ERROR_CONTENT_BLOCKED = 2153644038,
        NS_ERROR_CONTENT_BLOCKED_SHOW_ALT = 2153644039,
        NS_PROPTABLE_PROP_NOT_THERE = 2153644042,
        NS_ERROR_XBL_BLOCKED = 2153644047,
        NS_ERROR_CONTENT_CRASHED = 2153644048,
        NS_HTML_STYLE_PROPERTY_NOT_THERE = 6160386,
        NS_CONTENT_BLOCKED = 6160392,
        NS_CONTENT_BLOCKED_SHOW_ALT = 6160393,
        NS_PROPTABLE_PROP_OVERWRITTEN = 6160395,
        NS_FINDBROADCASTER_NOT_FOUND = 6160396,
        NS_FINDBROADCASTER_FOUND = 6160397,
        NS_FINDBROADCASTER_AWAIT_OVERLAYS = 6160398,
        NS_ERROR_XSLT_PARSE_FAILURE = 2153775105,
        NS_ERROR_XPATH_PARSE_FAILURE = 2153775106,
        NS_ERROR_XSLT_ALREADY_SET = 2153775107,
        NS_ERROR_XSLT_EXECUTION_FAILURE = 2153775108,
        NS_ERROR_XPATH_UNKNOWN_FUNCTION = 2153775109,
        NS_ERROR_XSLT_BAD_RECURSION = 2153775110,
        NS_ERROR_XSLT_BAD_VALUE = 2153775111,
        NS_ERROR_XSLT_NODESET_EXPECTED = 2153775112,
        NS_ERROR_XSLT_ABORTED = 2153775113,
        NS_ERROR_XSLT_NETWORK_ERROR = 2153775114,
        NS_ERROR_XSLT_WRONG_MIME_TYPE = 2153775115,
        NS_ERROR_XSLT_LOAD_RECURSION = 2153775116,
        NS_ERROR_XPATH_BAD_ARGUMENT_COUNT = 2153775117,
        NS_ERROR_XPATH_BAD_EXTENSION_FUNCTION = 2153775118,
        NS_ERROR_XPATH_PAREN_EXPECTED = 2153775119,
        NS_ERROR_XPATH_INVALID_AXIS = 2153775120,
        NS_ERROR_XPATH_NO_NODE_TYPE_TEST = 2153775121,
        NS_ERROR_XPATH_BRACKET_EXPECTED = 2153775122,
        NS_ERROR_XPATH_INVALID_VAR_NAME = 2153775123,
        NS_ERROR_XPATH_UNEXPECTED_END = 2153775124,
        NS_ERROR_XPATH_OPERATOR_EXPECTED = 2153775125,
        NS_ERROR_XPATH_UNCLOSED_LITERAL = 2153775126,
        NS_ERROR_XPATH_BAD_COLON = 2153775127,
        NS_ERROR_XPATH_BAD_BANG = 2153775128,
        NS_ERROR_XPATH_ILLEGAL_CHAR = 2153775129,
        NS_ERROR_XPATH_BINARY_EXPECTED = 2153775130,
        NS_ERROR_XSLT_LOAD_BLOCKED_ERROR = 2153775131,
        NS_ERROR_XPATH_INVALID_EXPRESSION_EVALUATED = 2153775132,
        NS_ERROR_XPATH_UNBALANCED_CURLY_BRACE = 2153775133,
        NS_ERROR_XSLT_BAD_NODE_NAME = 2153775134,
        NS_ERROR_XSLT_VAR_ALREADY_SET = 2153775135,
        NS_ERROR_XSLT_CALL_TO_KEY_NOT_ALLOWED = 2153775136,
        NS_XSLT_GET_NEW_HANDLER = 6291457,
        NS_ERROR_TRANSPORT_INIT = 2153840641,
        NS_ERROR_DUPLICATE_HANDLE = 2153840642,
        NS_ERROR_BRIDGE_OPEN_PARENT = 2153840643,
        NS_ERROR_BRIDGE_OPEN_CHILD = 2153840644,
        NS_ERROR_DOM_SVG_WRONG_TYPE_ERR = 2153906176,
        NS_ERROR_DOM_SVG_MATRIX_NOT_INVERTABLE = 2153906178,
        NS_ERROR_STORAGE_BUSY = 2153971713,
        NS_ERROR_STORAGE_IOERR = 2153971714,
        NS_ERROR_STORAGE_CONSTRAINT = 2153971715,
        NS_ERROR_DOM_FILE_NOT_FOUND_ERR = 2154102784,
        NS_ERROR_DOM_FILE_NOT_READABLE_ERR = 2154102785,
        NS_ERROR_DOM_FILE_ABORT_ERR = 2154102786,
        NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR = 2154168321,
        NS_ERROR_DOM_INDEXEDDB_NOT_FOUND_ERR = 2154168323,
        NS_ERROR_DOM_INDEXEDDB_CONSTRAINT_ERR = 2154168324,
        NS_ERROR_DOM_INDEXEDDB_DATA_ERR = 2154168325,
        NS_ERROR_DOM_INDEXEDDB_NOT_ALLOWED_ERR = 2154168326,
        NS_ERROR_DOM_INDEXEDDB_TRANSACTION_INACTIVE_ERR = 2154168327,
        NS_ERROR_DOM_INDEXEDDB_ABORT_ERR = 2154168328,
        NS_ERROR_DOM_INDEXEDDB_READ_ONLY_ERR = 2154168329,
        NS_ERROR_DOM_INDEXEDDB_TIMEOUT_ERR = 2154168330,
        NS_ERROR_DOM_INDEXEDDB_QUOTA_ERR = 2154168331,
        NS_ERROR_DOM_INDEXEDDB_VERSION_ERR = 2154168332,
        NS_ERROR_DOM_INDEXEDDB_RECOVERABLE_ERR = 2154169321,
        NS_ERROR_DOM_FILEHANDLE_UNKNOWN_ERR = 2154233857,
        NS_ERROR_DOM_FILEHANDLE_NOT_ALLOWED_ERR = 2154233858,
        NS_ERROR_DOM_FILEHANDLE_INACTIVE_ERR = 2154233859,
        NS_ERROR_DOM_FILEHANDLE_ABORT_ERR = 2154233860,
        NS_ERROR_DOM_FILEHANDLE_READ_ONLY_ERR = 2154233861,
        NS_ERROR_DOM_FILEHANDLE_QUOTA_ERR = 2154233862,
        NS_ERROR_SIGNED_JAR_NOT_SIGNED = 2154299393,
        NS_ERROR_SIGNED_JAR_MODIFIED_ENTRY = 2154299394,
        NS_ERROR_SIGNED_JAR_UNSIGNED_ENTRY = 2154299395,
        NS_ERROR_SIGNED_JAR_ENTRY_MISSING = 2154299396,
        NS_ERROR_SIGNED_JAR_WRONG_SIGNATURE = 2154299397,
        NS_ERROR_SIGNED_JAR_ENTRY_TOO_LARGE = 2154299398,
        NS_ERROR_SIGNED_JAR_ENTRY_INVALID = 2154299399,
        NS_ERROR_SIGNED_JAR_MANIFEST_INVALID = 2154299400,
        NS_ERROR_DOM_FILESYSTEM_INVALID_PATH_ERR = 2154364929,
        NS_ERROR_DOM_FILESYSTEM_INVALID_MODIFICATION_ERR = 2154364930,
        NS_ERROR_DOM_FILESYSTEM_NO_MODIFICATION_ALLOWED_ERR = 2154364931,
        NS_ERROR_DOM_FILESYSTEM_PATH_EXISTS_ERR = 2154364932,
        NS_ERROR_DOM_FILESYSTEM_TYPE_MISMATCH_ERR = 2154364933,
        NS_ERROR_DOM_FILESYSTEM_UNKNOWN_ERR = 2154364934,
        NS_ERROR_SIGNED_APP_MANIFEST_INVALID = 2154496001,
        NS_ERROR_DOM_ANIM_MISSING_PROPS_ERR = 2154561537,
        NS_ERROR_DOM_PUSH_INVALID_REGISTRATION_ERR = 2154627073,
        NS_ERROR_DOM_PUSH_DENIED_ERR = 2154627074,
        NS_ERROR_DOM_PUSH_ABORT_ERR = 2154627075,
        NS_ERROR_DOM_PUSH_SERVICE_UNREACHABLE = 2154627076,
        NS_ERROR_DOM_PUSH_INVALID_KEY_ERR = 2154627077,
        NS_ERROR_DOM_PUSH_MISMATCHED_KEY_ERR = 2154627078,
        NS_ERROR_DOM_MEDIA_ABORT_ERR = 2154692609,
        NS_ERROR_DOM_MEDIA_NOT_ALLOWED_ERR = 2154692610,
        NS_ERROR_DOM_MEDIA_NOT_SUPPORTED_ERR = 2154692611,
        NS_ERROR_DOM_MEDIA_DECODE_ERR = 2154692612,
        NS_ERROR_DOM_MEDIA_FATAL_ERR = 2154692613,
        NS_ERROR_DOM_MEDIA_METADATA_ERR = 2154692614,
        NS_ERROR_DOM_MEDIA_OVERFLOW_ERR = 2154692615,
        NS_ERROR_DOM_MEDIA_END_OF_STREAM = 2154692616,
        NS_ERROR_DOM_MEDIA_WAITING_FOR_DATA = 2154692617,
        NS_ERROR_DOM_MEDIA_CANCELED = 2154692618,
        NS_ERROR_DOM_MEDIA_MEDIASINK_ERR = 2154692619,
        NS_ERROR_DOM_MEDIA_DEMUXER_ERR = 2154692620,
        NS_ERROR_DOM_MEDIA_CDM_ERR = 2154692621,
        NS_ERROR_DOM_MEDIA_NEED_NEW_DECODER = 2154692622,
        NS_ERROR_DOM_MEDIA_CUBEB_INITIALIZATION_ERR = 2154692709,
        NS_ERROR_UC_UPDATE_UNKNOWN = 2154758145,
        NS_ERROR_UC_UPDATE_DUPLICATE_PREFIX = 2154758146,
        NS_ERROR_UC_UPDATE_INFINITE_LOOP = 2154758147,
        NS_ERROR_UC_UPDATE_WRONG_REMOVAL_INDICES = 2154758148,
        NS_ERROR_UC_UPDATE_CHECKSUM_MISMATCH = 2154758149,
        NS_ERROR_UC_UPDATE_MISSING_CHECKSUM = 2154758150,
        NS_ERROR_DOWNLOAD_COMPLETE = 2155347969,
        NS_ERROR_DOWNLOAD_NOT_PARTIAL = 2155347970,
        NS_ERROR_UNORM_MOREOUTPUT = 2155348001,
        NS_ERROR_DOCSHELL_REQUEST_REJECTED = 2155348969,
        NS_ERROR_DOCUMENT_IS_PRINTMODE = 2155349969,
        NS_SUCCESS_DONT_FIXUP = 7864321,
        NS_SUCCESS_RESTART_APP_NOT_SAME_PROFILE = 7864323,
        NS_SUCCESS_UNORM_NOTFOUND = 7864337,
        NS_ERROR_NOT_IN_TREE = 2155348006,
        NS_OK_NO_NAME_CLAUSE_HANDLED = 7864354,
    }
    pub type nsrefcnt = root::MozRefCountType;
    #[repr(C)]
    #[derive(Debug)]
    pub struct RefPtr<T> {
        pub mRawPtr: *mut T,
    }
    pub type RefPtr_element_type<T> = T;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RefPtr_Proxy<T, R, Args> {
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<R>,
        pub _phantom_2: ::std::marker::PhantomData<Args>,
    }
    pub type RefPtr_Proxy_member_function = [u8; 0usize];
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RefPtr_ConstRemovingRefPtrTraits<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct JSContext {
        pub _address: u8,
    }
    impl Clone for JSContext {
        fn clone(&self) -> Self { *self }
    }
    pub mod JS {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DeletePolicy<T> {
            pub _address: u8,
            pub _phantom_0: ::std::marker::PhantomData<T>,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct FreePolicy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_FreePolicy() {
            assert_eq!(::std::mem::size_of::<FreePolicy>() , 1usize);
            assert_eq!(::std::mem::align_of::<FreePolicy>() , 1usize);
        }
        impl Clone for FreePolicy {
            fn clone(&self) -> Self { *self }
        }
        pub mod dbg {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug)]
            pub struct GarbageCollectionEvent {
                pub majorGCNumber_: u64,
                pub reason: *const ::std::os::raw::c_char,
                pub nonincrementalReason: *const ::std::os::raw::c_char,
                pub collections: [u64; 4usize],
            }
            #[repr(C)]
            #[derive(Debug, Copy)]
            pub struct GarbageCollectionEvent_Collection {
                pub startTimestamp: root::mozilla::TimeStamp,
                pub endTimestamp: root::mozilla::TimeStamp,
            }
            #[test]
            fn bindgen_test_layout_GarbageCollectionEvent_Collection() {
                assert_eq!(::std::mem::size_of::<GarbageCollectionEvent_Collection>()
                           , 16usize);
                assert_eq!(::std::mem::align_of::<GarbageCollectionEvent_Collection>()
                           , 8usize);
            }
            impl Clone for GarbageCollectionEvent_Collection {
                fn clone(&self) -> Self { *self }
            }
            pub type GarbageCollectionEvent_Ptr =
                root::mozilla::UniquePtr<root::JS::dbg::GarbageCollectionEvent,
                                         root::JS::DeletePolicy<root::JS::dbg::GarbageCollectionEvent>>;
            #[test]
            fn bindgen_test_layout_GarbageCollectionEvent() {
                assert_eq!(::std::mem::size_of::<GarbageCollectionEvent>() ,
                           56usize);
                assert_eq!(::std::mem::align_of::<GarbageCollectionEvent>() ,
                           8usize);
            }
        }
        /**
 * The Heap<T> class is a heap-stored reference to a JS GC thing. All members of
 * heap classes that refer to GC things should use Heap<T> (or possibly
 * TenuredHeap<T>, described below).
 *
 * Heap<T> is an abstraction that hides some of the complexity required to
 * maintain GC invariants for the contained reference. It uses operator
 * overloading to provide a normal pointer interface, but notifies the GC every
 * time the value it contains is updated. This is necessary for generational GC,
 * which keeps track of all pointers into the nursery.
 *
 * Heap<T> instances must be traced when their containing object is traced to
 * keep the pointed-to GC thing alive.
 *
 * Heap<T> objects should only be used on the heap. GC references stored on the
 * C/C++ stack must use Rooted/Handle/MutableHandle instead.
 *
 * Type T must be a public GC pointer type.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct Heap<T> {
            pub ptr: T,
        }
        pub type Heap_ElementType<T> = T;
        /**
 * The TenuredHeap<T> class is similar to the Heap<T> class above in that it
 * encapsulates the GC concerns of an on-heap reference to a JS object. However,
 * it has two important differences:
 *
 *  1) Pointers which are statically known to only reference "tenured" objects
 *     can avoid the extra overhead of SpiderMonkey's write barriers.
 *
 *  2) Objects in the "tenured" heap have stronger alignment restrictions than
 *     those in the "nursery", so it is possible to store flags in the lower
 *     bits of pointers known to be tenured. TenuredHeap wraps a normal tagged
 *     pointer with a nice API for accessing the flag bits and adds various
 *     assertions to ensure that it is not mis-used.
 *
 * GC things are said to be "tenured" when they are located in the long-lived
 * heap: e.g. they have gained tenure as an object by surviving past at least
 * one GC. For performance, SpiderMonkey allocates some things which are known
 * to normally be long lived directly into the tenured generation; for example,
 * global objects. Additionally, SpiderMonkey does not visit individual objects
 * when deleting non-tenured objects, so object with finalizers are also always
 * tenured; for instance, this includes most DOM objects.
 *
 * The considerations to keep in mind when using a TenuredHeap<T> vs a normal
 * Heap<T> are:
 *
 *  - It is invalid for a TenuredHeap<T> to refer to a non-tenured thing.
 *  - It is however valid for a Heap<T> to refer to a tenured thing.
 *  - It is not possible to store flag bits in a Heap<T>.
 */
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TenuredHeap<T> {
            pub bits: usize,
            pub _phantom_0: ::std::marker::PhantomData<T>,
        }
        pub type TenuredHeap_ElementType<T> = T;
        pub const TenuredHeap_maskBits: root::JS::TenuredHeap__bindgen_ty_1 =
            TenuredHeap__bindgen_ty_1::maskBits;
        pub const TenuredHeap_flagsMask: root::JS::TenuredHeap__bindgen_ty_1 =
            TenuredHeap__bindgen_ty_1::maskBits;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum TenuredHeap__bindgen_ty_1 { maskBits = 0, }
        #[test]
        fn __bindgen_test_layout_template_4() {
            assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<*mut ::std::os::raw::c_char,
                                               root::JS::FreePolicy>>()
                       , 8usize);
            assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<*mut ::std::os::raw::c_char,
                                                root::JS::FreePolicy>>()
                       , 8usize);
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct JSObject {
        pub _address: u8,
    }
    impl Clone for JSObject {
        fn clone(&self) -> Self { *self }
    }
    pub mod js {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod gc {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HeapBase<T> {
            pub _address: u8,
            pub _phantom_0: ::std::marker::PhantomData<T>,
        }
        #[repr(C)]
        pub struct SourceHook__bindgen_vtable {
        }
        /**
 * A class of objects that return source code on demand.
 *
 * When code is compiled with setSourceIsLazy(true), SpiderMonkey doesn't
 * retain the source code (and doesn't do lazy bytecode generation). If we ever
 * need the source code, say, in response to a call to Function.prototype.
 * toSource or Debugger.Source.prototype.text, then we call the 'load' member
 * function of the instance of this class that has hopefully been registered
 * with the runtime, passing the code's URL, and hope that it will be able to
 * find the source.
 */
        #[repr(C)]
        #[derive(Debug)]
        pub struct SourceHook {
            pub vtable_: *const SourceHook__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_SourceHook() {
            assert_eq!(::std::mem::size_of::<SourceHook>() , 8usize);
            assert_eq!(::std::mem::align_of::<SourceHook>() , 8usize);
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct JSCompartment {
        pub _address: u8,
    }
    impl Clone for JSCompartment {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAString_internal {
        pub mData: *mut root::nsAString_internal_char_type,
        pub mLength: root::nsAString_internal_size_type,
        pub mFlags: u32,
    }
    pub type nsAString_internal_fallible_t = root::mozilla::fallible_t;
    pub type nsAString_internal_char_type = u16;
    pub type nsAString_internal_char_traits = u8;
    pub type nsAString_internal_incompatible_char_type = u8;
    pub type nsAString_internal_self_type = root::nsAString_internal;
    pub type nsAString_internal_abstract_string_type =
        root::nsAString_internal_self_type;
    pub type nsAString_internal_base_string_type =
        root::nsAString_internal_self_type;
    pub type nsAString_internal_substring_type =
        root::nsAString_internal_self_type;
    pub type nsAString_internal_substring_tuple_type = root::nsSubstringTuple;
    pub type nsAString_internal_string_type = ::nsstring::nsStringRepr;
    pub type nsAString_internal_const_iterator = root::nsReadingIterator<u16>;
    pub type nsAString_internal_iterator = root::nsWritingIterator<u16>;
    pub type nsAString_internal_comparator_type = root::nsStringComparator;
    pub type nsAString_internal_char_iterator =
        *mut root::nsAString_internal_char_type;
    pub type nsAString_internal_const_char_iterator =
        *const root::nsAString_internal_char_type;
    pub type nsAString_internal_size_type = u32;
    pub type nsAString_internal_index_type = u32;
    pub const nsAString_internal_F_NONE:
              root::nsAString_internal__bindgen_ty_1 =
        nsAString_internal__bindgen_ty_1::F_NONE;
    pub const nsAString_internal_F_TERMINATED:
              root::nsAString_internal__bindgen_ty_1 =
        nsAString_internal__bindgen_ty_1::F_TERMINATED;
    pub const nsAString_internal_F_VOIDED:
              root::nsAString_internal__bindgen_ty_1 =
        nsAString_internal__bindgen_ty_1::F_VOIDED;
    pub const nsAString_internal_F_SHARED:
              root::nsAString_internal__bindgen_ty_1 =
        nsAString_internal__bindgen_ty_1::F_SHARED;
    pub const nsAString_internal_F_OWNED:
              root::nsAString_internal__bindgen_ty_1 =
        nsAString_internal__bindgen_ty_1::F_OWNED;
    pub const nsAString_internal_F_FIXED:
              root::nsAString_internal__bindgen_ty_1 =
        nsAString_internal__bindgen_ty_1::F_FIXED;
    pub const nsAString_internal_F_LITERAL:
              root::nsAString_internal__bindgen_ty_1 =
        nsAString_internal__bindgen_ty_1::F_LITERAL;
    pub const nsAString_internal_F_CLASS_FIXED:
              root::nsAString_internal__bindgen_ty_1 =
        nsAString_internal__bindgen_ty_1::F_CLASS_FIXED;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsAString_internal__bindgen_ty_1 {
        F_NONE = 0,
        F_TERMINATED = 1,
        F_VOIDED = 2,
        F_SHARED = 4,
        F_OWNED = 8,
        F_FIXED = 16,
        F_LITERAL = 32,
        F_CLASS_FIXED = 65536,
    }
    #[test]
    fn bindgen_test_layout_nsAString_internal() {
        assert_eq!(::std::mem::size_of::<nsAString_internal>() , 16usize);
        assert_eq!(::std::mem::align_of::<nsAString_internal>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsSubstringTuple {
        pub mHead: *const root::nsSubstringTuple_self_type,
        pub mFragA: *const root::nsSubstringTuple_base_string_type,
        pub mFragB: *const root::nsSubstringTuple_base_string_type,
    }
    pub type nsSubstringTuple_char_type = u16;
    pub type nsSubstringTuple_char_traits = root::nsCharTraits<u16>;
    pub type nsSubstringTuple_self_type = root::nsSubstringTuple;
    pub type nsSubstringTuple_substring_type = root::nsAString_internal;
    pub type nsSubstringTuple_base_string_type = root::nsAString_internal;
    pub type nsSubstringTuple_size_type = u32;
    #[test]
    fn bindgen_test_layout_nsSubstringTuple() {
        assert_eq!(::std::mem::size_of::<nsSubstringTuple>() , 24usize);
        assert_eq!(::std::mem::align_of::<nsSubstringTuple>() , 8usize);
    }
    impl Clone for nsSubstringTuple {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    pub struct nsStringComparator__bindgen_vtable {
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStringComparator {
        pub vtable_: *const nsStringComparator__bindgen_vtable,
    }
    pub type nsStringComparator_char_type = u16;
    #[test]
    fn bindgen_test_layout_nsStringComparator() {
        assert_eq!(::std::mem::size_of::<nsStringComparator>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsStringComparator>() , 8usize);
    }
    impl Clone for nsStringComparator {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsACString_internal {
        pub mData: *mut root::nsACString_internal_char_type,
        pub mLength: root::nsACString_internal_size_type,
        pub mFlags: u32,
    }
    pub type nsACString_internal_fallible_t = root::mozilla::fallible_t;
    pub type nsACString_internal_char_type = ::std::os::raw::c_char;
    pub type nsACString_internal_char_traits = u8;
    pub type nsACString_internal_incompatible_char_type = u16;
    pub type nsACString_internal_self_type = root::nsACString_internal;
    pub type nsACString_internal_abstract_string_type =
        root::nsACString_internal_self_type;
    pub type nsACString_internal_base_string_type =
        root::nsACString_internal_self_type;
    pub type nsACString_internal_substring_type =
        root::nsACString_internal_self_type;
    pub type nsACString_internal_substring_tuple_type =
        root::nsCSubstringTuple;
    pub type nsACString_internal_string_type = root::nsCString;
    pub type nsACString_internal_const_iterator =
        root::nsReadingIterator<::std::os::raw::c_char>;
    pub type nsACString_internal_iterator =
        root::nsWritingIterator<::std::os::raw::c_char>;
    pub type nsACString_internal_comparator_type = root::nsCStringComparator;
    pub type nsACString_internal_char_iterator =
        *mut root::nsACString_internal_char_type;
    pub type nsACString_internal_const_char_iterator =
        *const root::nsACString_internal_char_type;
    pub type nsACString_internal_size_type = u32;
    pub type nsACString_internal_index_type = u32;
    pub const nsACString_internal_F_NONE:
              root::nsACString_internal__bindgen_ty_1 =
        nsACString_internal__bindgen_ty_1::F_NONE;
    pub const nsACString_internal_F_TERMINATED:
              root::nsACString_internal__bindgen_ty_1 =
        nsACString_internal__bindgen_ty_1::F_TERMINATED;
    pub const nsACString_internal_F_VOIDED:
              root::nsACString_internal__bindgen_ty_1 =
        nsACString_internal__bindgen_ty_1::F_VOIDED;
    pub const nsACString_internal_F_SHARED:
              root::nsACString_internal__bindgen_ty_1 =
        nsACString_internal__bindgen_ty_1::F_SHARED;
    pub const nsACString_internal_F_OWNED:
              root::nsACString_internal__bindgen_ty_1 =
        nsACString_internal__bindgen_ty_1::F_OWNED;
    pub const nsACString_internal_F_FIXED:
              root::nsACString_internal__bindgen_ty_1 =
        nsACString_internal__bindgen_ty_1::F_FIXED;
    pub const nsACString_internal_F_LITERAL:
              root::nsACString_internal__bindgen_ty_1 =
        nsACString_internal__bindgen_ty_1::F_LITERAL;
    pub const nsACString_internal_F_CLASS_FIXED:
              root::nsACString_internal__bindgen_ty_1 =
        nsACString_internal__bindgen_ty_1::F_CLASS_FIXED;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsACString_internal__bindgen_ty_1 {
        F_NONE = 0,
        F_TERMINATED = 1,
        F_VOIDED = 2,
        F_SHARED = 4,
        F_OWNED = 8,
        F_FIXED = 16,
        F_LITERAL = 32,
        F_CLASS_FIXED = 65536,
    }
    #[test]
    fn bindgen_test_layout_nsACString_internal() {
        assert_eq!(::std::mem::size_of::<nsACString_internal>() , 16usize);
        assert_eq!(::std::mem::align_of::<nsACString_internal>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCSubstringTuple {
        pub mHead: *const root::nsCSubstringTuple_self_type,
        pub mFragA: *const root::nsCSubstringTuple_base_string_type,
        pub mFragB: *const root::nsCSubstringTuple_base_string_type,
    }
    pub type nsCSubstringTuple_char_type = ::std::os::raw::c_char;
    pub type nsCSubstringTuple_char_traits =
        root::nsCharTraits<::std::os::raw::c_char>;
    pub type nsCSubstringTuple_self_type = root::nsCSubstringTuple;
    pub type nsCSubstringTuple_substring_type = root::nsACString_internal;
    pub type nsCSubstringTuple_base_string_type = root::nsACString_internal;
    pub type nsCSubstringTuple_size_type = u32;
    #[test]
    fn bindgen_test_layout_nsCSubstringTuple() {
        assert_eq!(::std::mem::size_of::<nsCSubstringTuple>() , 24usize);
        assert_eq!(::std::mem::align_of::<nsCSubstringTuple>() , 8usize);
    }
    impl Clone for nsCSubstringTuple {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCString {
        pub _base: root::nsACString_internal,
    }
    pub type nsCString_self_type = root::nsCString;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCString_Segment {
        pub mBegin: u32,
        pub mLength: u32,
    }
    #[test]
    fn bindgen_test_layout_nsCString_Segment() {
        assert_eq!(::std::mem::size_of::<nsCString_Segment>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsCString_Segment>() , 4usize);
    }
    impl Clone for nsCString_Segment {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsCString() {
        assert_eq!(::std::mem::size_of::<nsCString>() , 16usize);
        assert_eq!(::std::mem::align_of::<nsCString>() , 8usize);
    }
    #[repr(C)]
    pub struct nsCStringComparator__bindgen_vtable {
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCStringComparator {
        pub vtable_: *const nsCStringComparator__bindgen_vtable,
    }
    pub type nsCStringComparator_char_type = ::std::os::raw::c_char;
    #[test]
    fn bindgen_test_layout_nsCStringComparator() {
        assert_eq!(::std::mem::size_of::<nsCStringComparator>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsCStringComparator>() , 8usize);
    }
    impl Clone for nsCStringComparator {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    pub struct nsISupports__bindgen_vtable {
    }
    /**
 * Basic component object model interface. Objects which implement
 * this interface support runtime interface discovery (QueryInterface)
 * and a reference counted memory model (AddRef/Release). This is
 * modelled after the win32 IUnknown API.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsISupports {
        pub vtable_: *const nsISupports__bindgen_vtable,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISupports_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsISupports() {
        assert_eq!(::std::mem::size_of::<nsISupports>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsISupports>() , 8usize);
    }
    impl Clone for nsISupports {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    pub struct nsCycleCollectionParticipant__bindgen_vtable {
    }
    /**
 * Participant implementation classes
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCycleCollectionParticipant {
        pub vtable_: *const nsCycleCollectionParticipant__bindgen_vtable,
        pub mMightSkip: bool,
    }
    #[test]
    fn bindgen_test_layout_nsCycleCollectionParticipant() {
        assert_eq!(::std::mem::size_of::<nsCycleCollectionParticipant>() ,
                   16usize);
        assert_eq!(::std::mem::align_of::<nsCycleCollectionParticipant>() ,
                   8usize);
    }
    impl Clone for nsCycleCollectionParticipant {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCycleCollectingAutoRefCnt {
        pub mRefCntAndFlags: usize,
    }
    #[test]
    fn bindgen_test_layout_nsCycleCollectingAutoRefCnt() {
        assert_eq!(::std::mem::size_of::<nsCycleCollectingAutoRefCnt>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<nsCycleCollectingAutoRefCnt>() ,
                   8usize);
    }
    impl Clone for nsCycleCollectingAutoRefCnt {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsCharTraits<CharT> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<CharT>,
    }
    #[test]
    fn __bindgen_test_layout_template_5() {
        assert_eq!(::std::mem::size_of::<root::nsCharTraits<u16>>() , 1usize);
        assert_eq!(::std::mem::align_of::<root::nsCharTraits<u16>>() ,
                   1usize);
    }
    #[test]
    fn __bindgen_test_layout_template_6() {
        assert_eq!(::std::mem::size_of::<root::nsCharTraits<::std::os::raw::c_char>>()
                   , 1usize);
        assert_eq!(::std::mem::align_of::<root::nsCharTraits<::std::os::raw::c_char>>()
                   , 1usize);
    }
    /**
 * @see nsTAString
 */
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsReadingIterator<CharT> {
        pub mStart: *mut CharT,
        pub mEnd: *mut CharT,
        pub mPosition: *mut CharT,
    }
    pub type nsReadingIterator_self_type<CharT> =
        root::nsReadingIterator<CharT>;
    pub type nsReadingIterator_difference_type = isize;
    pub type nsReadingIterator_size_type = usize;
    pub type nsReadingIterator_value_type<CharT> = CharT;
    pub type nsReadingIterator_pointer<CharT> = *mut CharT;
    pub type nsReadingIterator_reference = [u8; 0usize];
    /**
 * @see nsTAString
 */
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsWritingIterator<CharT> {
        pub mStart: *mut CharT,
        pub mEnd: *mut CharT,
        pub mPosition: *mut CharT,
    }
    pub type nsWritingIterator_self_type<CharT> =
        root::nsWritingIterator<CharT>;
    pub type nsWritingIterator_difference_type = isize;
    pub type nsWritingIterator_size_type = usize;
    pub type nsWritingIterator_value_type<CharT> = CharT;
    pub type nsWritingIterator_pointer<CharT> = *mut CharT;
    pub type nsWritingIterator_reference = [u8; 0usize];
    pub type PRUint32 = ::std::os::raw::c_uint;
    pub type PRUintn = ::std::os::raw::c_uint;
    /************************************************************************
** TYPES:       PRSize
** DESCRIPTION:
**  A type for representing the size of objects.
************************************************************************/
    pub type PRSize = usize;
    pub type PRUword = ::std::os::raw::c_ulong;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLHashEntry {
        pub next: *mut root::PLHashEntry,
        pub keyHash: root::PLHashNumber,
        pub key: *const ::std::os::raw::c_void,
        pub value: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_PLHashEntry() {
        assert_eq!(::std::mem::size_of::<PLHashEntry>() , 32usize);
        assert_eq!(::std::mem::align_of::<PLHashEntry>() , 8usize);
    }
    impl Clone for PLHashEntry {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLHashTable {
        pub buckets: *mut *mut root::PLHashEntry,
        pub nentries: root::PRUint32,
        pub shift: root::PRUint32,
        pub keyHash: root::PLHashFunction,
        pub keyCompare: root::PLHashComparator,
        pub valueCompare: root::PLHashComparator,
        pub allocOps: *const root::PLHashAllocOps,
        pub allocPriv: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_PLHashTable() {
        assert_eq!(::std::mem::size_of::<PLHashTable>() , 56usize);
        assert_eq!(::std::mem::align_of::<PLHashTable>() , 8usize);
    }
    impl Clone for PLHashTable {
        fn clone(&self) -> Self { *self }
    }
    pub type PLHashNumber = root::PRUint32;
    pub type PLHashFunction =
        ::std::option::Option<unsafe extern "C" fn(key:
                                                       *const ::std::os::raw::c_void)
                                  -> ::std::os::raw::c_uint>;
    pub type PLHashComparator =
        ::std::option::Option<unsafe extern "C" fn(v1:
                                                       *const ::std::os::raw::c_void,
                                                   v2:
                                                       *const ::std::os::raw::c_void)
                                  -> ::std::os::raw::c_int>;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLHashAllocOps {
        pub allocTable: ::std::option::Option<unsafe extern "C" fn(pool:
                                                                       *mut ::std::os::raw::c_void,
                                                                   size:
                                                                       root::PRSize)
                                                  ->
                                                      *mut ::std::os::raw::c_void>,
        pub freeTable: ::std::option::Option<unsafe extern "C" fn(pool:
                                                                      *mut ::std::os::raw::c_void,
                                                                  item:
                                                                      *mut ::std::os::raw::c_void)>,
        pub allocEntry: ::std::option::Option<unsafe extern "C" fn(pool:
                                                                       *mut ::std::os::raw::c_void,
                                                                   key:
                                                                       *const ::std::os::raw::c_void)
                                                  -> *mut root::PLHashEntry>,
        pub freeEntry: ::std::option::Option<unsafe extern "C" fn(pool:
                                                                      *mut ::std::os::raw::c_void,
                                                                  he:
                                                                      *mut root::PLHashEntry,
                                                                  flag:
                                                                      root::PRUintn)>,
    }
    #[test]
    fn bindgen_test_layout_PLHashAllocOps() {
        assert_eq!(::std::mem::size_of::<PLHashAllocOps>() , 32usize);
        assert_eq!(::std::mem::align_of::<PLHashAllocOps>() , 8usize);
    }
    impl Clone for PLHashAllocOps {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsAutoRefCnt {
        pub mValue: root::nsrefcnt,
    }
    pub const nsAutoRefCnt_isThreadSafe: bool = false;
    #[test]
    fn bindgen_test_layout_nsAutoRefCnt() {
        assert_eq!(::std::mem::size_of::<nsAutoRefCnt>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsAutoRefCnt>() , 8usize);
    }
    impl Clone for nsAutoRefCnt {
        fn clone(&self) -> Self { *self }
    }
    pub type nscoord = i32;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTArrayHeader {
        pub mLength: u32,
        pub _bitfield_1: u32,
    }
    extern "C" {
        #[link_name = "_ZN14nsTArrayHeader9sEmptyHdrE"]
        pub static mut nsTArrayHeader_sEmptyHdr: root::nsTArrayHeader;
    }
    #[test]
    fn bindgen_test_layout_nsTArrayHeader() {
        assert_eq!(::std::mem::size_of::<nsTArrayHeader>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsTArrayHeader>() , 4usize);
    }
    impl Clone for nsTArrayHeader {
        fn clone(&self) -> Self { *self }
    }
    impl nsTArrayHeader {
        #[inline]
        pub fn mCapacity(&self) -> u32 {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (2147483647usize as u32)) >> 0u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_mCapacity(&mut self, val: u32) {
            self._bitfield_1 &= !(2147483647usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 0u32) & (2147483647usize as u32);
        }
        #[inline]
        pub fn mIsAutoArray(&self) -> u32 {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (2147483648usize as u32)) >>
                                           31u32) as u32)
            }
        }
        #[inline]
        pub fn set_mIsAutoArray(&mut self, val: u32) {
            self._bitfield_1 &= !(2147483648usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 31u32) & (2147483648usize as u32);
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCOMPtr<T> {
        pub _base: root::nsCOMPtr_base,
        pub _phantom_0: ::std::marker::PhantomData<T>,
    }
    pub type nsCOMPtr_element_type<T> = T;
    /**
 * Factors implementation for all template versions of nsCOMPtr.
 *
 * Here's the way people normally do things like this:
 *
 *   template<class T> class Foo { ... };
 *   template<> class Foo<void*> { ... };
 *   template<class T> class Foo<T*> : private Foo<void*> { ... };
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCOMPtr_base {
        pub mRawPtr: *mut root::nsISupports,
    }
    #[test]
    fn __bindgen_test_layout_template_7() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsISupports>>()
                   , 8usize);
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsISupports>>()
                   , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAutoPtr<T> {
        pub mRawPtr: *mut T,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsAutoPtr_Ptr<T> {
        pub mPtr: *mut T,
    }
    pub type nsAutoPtr_element_type<T> = T;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsAutoPtr_Proxy<T, R, Args> {
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<R>,
        pub _phantom_2: ::std::marker::PhantomData<Args>,
    }
    pub type nsAutoPtr_Proxy_member_function = [u8; 0usize];
    /**
 * This structure precedes the string buffers "we" allocate.  It may be the
 * case that nsTAString::mData does not point to one of these special
 * buffers.  The mFlags member variable distinguishes the buffer type.
 *
 * When this header is in use, it enables reference counting, and capacity
 * tracking.  NOTE: A string buffer can be modified only if its reference
 * count is 1.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStringBuffer {
        pub mRefCount: u32,
        pub mStorageSize: u32,
    }
    #[test]
    fn bindgen_test_layout_nsStringBuffer() {
        assert_eq!(::std::mem::size_of::<nsStringBuffer>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsStringBuffer>() , 4usize);
    }
    impl Clone for nsStringBuffer {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIAtom {
        pub _base: root::nsISupports,
        pub _bitfield_1: u32,
        pub mHash: u32,
        /**
   * WARNING! There is an invisible constraint on |mString|: the chars it
   * points to must belong to an nsStringBuffer. This is so that the
   * nsStringBuffer::FromData() calls above are valid.
   */
        pub mString: *mut u16,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIAtom_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIAtom() {
        assert_eq!(::std::mem::size_of::<nsIAtom>() , 24usize);
        assert_eq!(::std::mem::align_of::<nsIAtom>() , 8usize);
    }
    impl Clone for nsIAtom {
        fn clone(&self) -> Self { *self }
    }
    impl nsIAtom {
        #[inline]
        pub fn mLength(&self) -> u32 {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (2147483647usize as u32)) >> 0u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_mLength(&mut self, val: u32) {
            self._bitfield_1 &= !(2147483647usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 0u32) & (2147483647usize as u32);
        }
        #[inline]
        pub fn mIsStatic(&self) -> u32 {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (2147483648usize as u32)) >>
                                           31u32) as u32)
            }
        }
        #[inline]
        pub fn set_mIsStatic(&mut self, val: u32) {
            self._bitfield_1 &= !(2147483648usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 31u32) & (2147483648usize as u32);
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIPrincipal {
        pub _base: root::nsISerializable,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIPrincipal_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const nsIPrincipal_APP_STATUS_NOT_INSTALLED:
              root::nsIPrincipal__bindgen_ty_1 =
        nsIPrincipal__bindgen_ty_1::APP_STATUS_NOT_INSTALLED;
    pub const nsIPrincipal_APP_STATUS_INSTALLED:
              root::nsIPrincipal__bindgen_ty_1 =
        nsIPrincipal__bindgen_ty_1::APP_STATUS_INSTALLED;
    pub const nsIPrincipal_APP_STATUS_PRIVILEGED:
              root::nsIPrincipal__bindgen_ty_1 =
        nsIPrincipal__bindgen_ty_1::APP_STATUS_PRIVILEGED;
    pub const nsIPrincipal_APP_STATUS_CERTIFIED:
              root::nsIPrincipal__bindgen_ty_1 =
        nsIPrincipal__bindgen_ty_1::APP_STATUS_CERTIFIED;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPrincipal__bindgen_ty_1 {
        APP_STATUS_NOT_INSTALLED = 0,
        APP_STATUS_INSTALLED = 1,
        APP_STATUS_PRIVILEGED = 2,
        APP_STATUS_CERTIFIED = 3,
    }
    #[test]
    fn bindgen_test_layout_nsIPrincipal() {
        assert_eq!(::std::mem::size_of::<nsIPrincipal>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsIPrincipal>() , 8usize);
    }
    impl Clone for nsIPrincipal {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    pub struct nsWrapperCache__bindgen_vtable {
    }
    /**
 * Class to store the wrapper for an object. This can only be used with objects
 * that only have one non-security wrapper at a time (for an XPCWrappedNative
 * this is usually ensured by setting an explicit parent in the PreCreate hook
 * for the class).
 *
 * An instance of nsWrapperCache can be gotten from an object that implements
 * a wrapper cache by calling QueryInterface on it. Note that this breaks XPCOM
 * rules a bit (this object doesn't derive from nsISupports).
 *
 * The cache can store objects other than wrappers. We allow wrappers to use a
 * separate JSObject to store their state (mostly expandos). If the wrapper is
 * collected and we want to preserve this state we actually store the state
 * object in the cache.
 *
 * The cache can store 2 types of objects:
 *
 *  If WRAPPER_IS_NOT_DOM_BINDING is set (IsDOMBinding() returns false):
 *    - the JSObject of an XPCWrappedNative wrapper
 *
 *  If WRAPPER_IS_NOT_DOM_BINDING is not set (IsDOMBinding() returns true):
 *    - a DOM binding object (regular JS object or proxy)
 *
 * The finalizer for the wrapper clears the cache.
 *
 * A compacting GC can move the wrapper object. Pointers to moved objects are
 * usually found and updated by tracing the heap, however non-preserved wrappers
 * are weak references and are not traced, so another approach is
 * necessary. Instead a class hook (objectMovedOp) is provided that is called
 * when an object is moved and is responsible for ensuring pointers are
 * updated. It does this by calling UpdateWrapper() on the wrapper
 * cache. SetWrapper() asserts that the hook is implemented for any wrapper set.
 *
 * A number of the methods are implemented in nsWrapperCacheInlines.h because we
 * have to include some JS headers that don't play nicely with the rest of the
 * codebase. Include nsWrapperCacheInlines.h if you need to call those methods.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsWrapperCache {
        pub vtable_: *const nsWrapperCache__bindgen_vtable,
        pub mWrapper: *mut root::JSObject,
        pub mFlags: root::nsWrapperCache_FlagsType,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsWrapperCache_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub type nsWrapperCache_FlagsType = u32;
    pub const nsWrapperCache_WRAPPER_BIT_PRESERVED:
              root::nsWrapperCache__bindgen_ty_1 =
        nsWrapperCache__bindgen_ty_1::WRAPPER_BIT_PRESERVED;
    #[repr(u32)]
    /**
   * If this bit is set then we're preserving the wrapper, which in effect ties
   * the lifetime of the JS object stored in the cache to the lifetime of the
   * native object. We rely on the cycle collector to break the cycle that this
   * causes between the native object and the JS object, so it is important that
   * any native object that supports preserving of its wrapper
   * traces/traverses/unlinks the cached JS object (see
   * NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER,
   * NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS and
   * NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER).
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsWrapperCache__bindgen_ty_1 { WRAPPER_BIT_PRESERVED = 1, }
    pub const nsWrapperCache_WRAPPER_IS_NOT_DOM_BINDING:
              root::nsWrapperCache__bindgen_ty_2 =
        nsWrapperCache__bindgen_ty_2::WRAPPER_IS_NOT_DOM_BINDING;
    #[repr(u32)]
    /**
   * If this bit is set then the wrapper for the native object is not a DOM
   * binding.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsWrapperCache__bindgen_ty_2 { WRAPPER_IS_NOT_DOM_BINDING = 2, }
    pub const nsWrapperCache_kWrapperFlagsMask:
              root::nsWrapperCache__bindgen_ty_3 =
        nsWrapperCache__bindgen_ty_3::kWrapperFlagsMask;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsWrapperCache__bindgen_ty_3 { kWrapperFlagsMask = 3, }
    #[test]
    fn bindgen_test_layout_nsWrapperCache() {
        assert_eq!(::std::mem::size_of::<nsWrapperCache>() , 24usize);
        assert_eq!(::std::mem::align_of::<nsWrapperCache>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsScriptObjectTracer {
        pub _base: root::nsCycleCollectionParticipant,
    }
    #[test]
    fn bindgen_test_layout_nsScriptObjectTracer() {
        assert_eq!(::std::mem::size_of::<nsScriptObjectTracer>() , 16usize);
        assert_eq!(::std::mem::align_of::<nsScriptObjectTracer>() , 8usize);
    }
    impl Clone for nsScriptObjectTracer {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsXPCOMCycleCollectionParticipant {
        pub _base: root::nsScriptObjectTracer,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsXPCOMCycleCollectionParticipant_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsXPCOMCycleCollectionParticipant() {
        assert_eq!(::std::mem::size_of::<nsXPCOMCycleCollectionParticipant>()
                   , 16usize);
        assert_eq!(::std::mem::align_of::<nsXPCOMCycleCollectionParticipant>()
                   , 8usize);
    }
    impl Clone for nsXPCOMCycleCollectionParticipant {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIRunnable {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIRunnable_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIRunnable() {
        assert_eq!(::std::mem::size_of::<nsIRunnable>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsIRunnable>() , 8usize);
    }
    impl Clone for nsIRunnable {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIGlobalObject {
        pub _base: root::nsISupports,
        pub _base_1: root::mozilla::dom::DispatcherTrait,
        pub mHostObjectURIs: root::nsTArray<root::nsCString>,
        pub mIsDying: bool,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIGlobalObject_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIGlobalObject() {
        assert_eq!(::std::mem::size_of::<nsIGlobalObject>() , 32usize);
        assert_eq!(::std::mem::align_of::<nsIGlobalObject>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsISerializable {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISerializable_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsISerializable() {
        assert_eq!(::std::mem::size_of::<nsISerializable>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsISerializable>() , 8usize);
    }
    impl Clone for nsISerializable {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIURI {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIURI_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIURI() {
        assert_eq!(::std::mem::size_of::<nsIURI>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsIURI>() , 8usize);
    }
    impl Clone for nsIURI {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPIDOMWindowInner {
        pub _base: [u64; 28usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsPIDOMWindowInner_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsPIDOMWindowInner() {
        assert_eq!(::std::mem::size_of::<nsPIDOMWindowInner>() , 224usize);
        assert_eq!(::std::mem::align_of::<nsPIDOMWindowInner>() , 8usize);
    }
    /**
 * Smart pointer class that can hold a pointer to either an nsStyleSet
 * or a ServoStyleSet.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct StyleSetHandle {
        pub mPtr: root::StyleSetHandle_Ptr,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct StyleSetHandle_Ptr {
        pub mValue: usize,
    }
    #[test]
    fn bindgen_test_layout_StyleSetHandle_Ptr() {
        assert_eq!(::std::mem::size_of::<StyleSetHandle_Ptr>() , 8usize);
        assert_eq!(::std::mem::align_of::<StyleSetHandle_Ptr>() , 8usize);
    }
    impl Clone for StyleSetHandle_Ptr {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_StyleSetHandle() {
        assert_eq!(::std::mem::size_of::<StyleSetHandle>() , 8usize);
        assert_eq!(::std::mem::align_of::<StyleSetHandle>() , 8usize);
    }
    impl Clone for StyleSetHandle {
        fn clone(&self) -> Self { *self }
    }
    /**
 * EventStates is the class used to represent the event states of nsIContent
 * instances. These states are calculated by IntrinsicState() and
 * ContentStatesChanged() has to be called when one of them changes thus
 * informing the layout/style engine of the change.
 * Event states are associated with pseudo-classes.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct EventStates {
        pub mStates: root::EventStates_InternalType,
    }
    pub type EventStates_InternalType = u64;
    pub type EventStates_ServoType = u8;
    #[test]
    fn bindgen_test_layout_EventStates() {
        assert_eq!(::std::mem::size_of::<EventStates>() , 8usize);
        assert_eq!(::std::mem::align_of::<EventStates>() , 8usize);
    }
    impl Clone for EventStates {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIDocument {
        pub _base: root::nsINode,
        pub _base_1: root::mozilla::dom::DispatcherTrait,
        pub mDeprecationWarnedAbout: u64,
        pub mDocWarningWarnedAbout: u64,
        pub mSelectorCache: [u64; 15usize],
        pub mReferrer: root::nsCString,
        pub mLastModified: ::nsstring::nsStringRepr,
        pub mDocumentURI: root::nsCOMPtr<root::nsIURI>,
        pub mOriginalURI: root::nsCOMPtr<root::nsIURI>,
        pub mChromeXHRDocURI: root::nsCOMPtr<root::nsIURI>,
        pub mDocumentBaseURI: root::nsCOMPtr<root::nsIURI>,
        pub mChromeXHRDocBaseURI: root::nsCOMPtr<root::nsIURI>,
        pub mDocumentLoadGroup: root::nsWeakPtr,
        pub mReferrerPolicySet: bool,
        pub mReferrerPolicy: root::nsIDocument_ReferrerPolicyEnum,
        pub mBlockAllMixedContent: bool,
        pub mBlockAllMixedContentPreloads: bool,
        pub mUpgradeInsecureRequests: bool,
        pub mUpgradeInsecurePreloads: bool,
        pub mHSTSPrimingURIList: [u64; 5usize],
        pub mDocumentContainer: u64,
        pub mCharacterSet: root::nsCString,
        pub mCharacterSetSource: i32,
        pub mParentDocument: *mut root::nsIDocument,
        pub mCachedRootElement: *mut root::mozilla::dom::Element,
        pub mNodeInfoManager: *mut root::nsNodeInfoManager,
        pub mCSSLoader: root::RefPtr<root::mozilla::css::Loader>,
        pub mStyleImageLoader: root::RefPtr<root::mozilla::css::ImageLoader>,
        pub mAttrStyleSheet: root::RefPtr<root::nsHTMLStyleSheet>,
        pub mStyleAttrStyleSheet: root::RefPtr<root::nsHTMLCSSStyleSheet>,
        pub mSVGAttrAnimationRuleProcessor: root::RefPtr<root::mozilla::SVGAttrAnimationRuleProcessor>,
        pub mImageTracker: root::RefPtr<root::mozilla::dom::ImageTracker>,
        pub mActivityObservers: root::nsAutoPtr<()>,
        pub mLinksToUpdate: [u64; 5usize],
        pub mAnimationController: root::RefPtr<root::nsSMILAnimationController>,
        pub mPropertyTable: root::nsPropertyTable,
        pub mExtraPropertyTables: root::nsTArray<root::nsAutoPtr<root::nsPropertyTable>>,
        pub mChildrenCollection: root::nsCOMPtr<root::nsIHTMLCollection>,
        pub mFontFaceSet: root::RefPtr<root::mozilla::dom::FontFaceSet>,
        pub mCompatMode: root::nsCompatibility,
        pub mReadyState: root::nsIDocument_ReadyState,
        pub mStyleBackendType: root::StyleBackendType,
        pub mVisibilityState: root::mozilla::dom::VisibilityState,
        pub _bitfield_1: u64,
        pub mType: root::nsIDocument_Type,
        pub mDefaultElementType: u8,
        pub mAllowXULXBL: root::nsIDocument_Tri,
        pub mScriptGlobalObject: root::nsCOMPtr<root::nsIScriptGlobalObject>,
        pub mOriginalDocument: root::nsCOMPtr<root::nsIDocument>,
        pub mBidiOptions: u32,
        pub mSandboxFlags: u32,
        pub mContentLanguage: root::nsCString,
        pub mChannel: root::nsCOMPtr<root::nsIChannel>,
        pub mContentType: root::nsCString,
        pub mId: ::nsstring::nsStringRepr,
        pub mSecurityInfo: root::nsCOMPtr<root::nsISupports>,
        pub mFailedChannel: root::nsCOMPtr<root::nsIChannel>,
        pub mPartID: u32,
        pub mMarkedCCGeneration: u32,
        pub mPresShell: *mut root::nsIPresShell,
        pub mSubtreeModifiedTargets: root::nsCOMArray<root::nsINode>,
        pub mSubtreeModifiedDepth: u32,
        pub mDisplayDocument: root::nsCOMPtr<root::nsIDocument>,
        pub mEventsSuppressed: u32,
        pub mAnimationsPaused: u32,
        /**
   * The number number of external scripts (ones with the src attribute) that
   * have this document as their owner and that are being evaluated right now.
   */
        pub mExternalScriptsBeingEvaluated: u32,
        /**
   * The current frame request callback handle
   */
        pub mFrameRequestCallbackCounter: i32,
        pub mStaticCloneCount: u32,
        pub mBlockedTrackingNodes: root::nsTArray<root::nsCOMPtr<root::nsIWeakReference>>,
        pub mWindow: *mut root::nsPIDOMWindowInner,
        pub mCachedEncoder: root::nsCOMPtr<root::nsIDocumentEncoder>,
        pub mFrameRequestCallbacks: root::nsTArray<root::nsIDocument_FrameRequest>,
        pub mBFCacheEntry: *mut root::nsIBFCacheEntry,
        pub mBaseTarget: ::nsstring::nsStringRepr,
        pub mStateObjectContainer: root::nsCOMPtr<root::nsIStructuredCloneContainer>,
        pub mStateObjectCached: root::nsCOMPtr<root::nsIVariant>,
        pub mInSyncOperationCount: u32,
        pub mXPathEvaluator: root::RefPtr<root::mozilla::dom::XPathEvaluator>,
        pub mAnonymousContents: root::nsTArray<root::RefPtr<root::mozilla::dom::AnonymousContent>>,
        pub mBlockDOMContentLoaded: u32,
        pub _bitfield_2: u8,
        pub mDOMMediaQueryLists: root::PRCList,
        pub mUseCounters: [u64; 2usize],
        pub mChildDocumentUseCounters: [u64; 2usize],
        pub mNotifiedPageForUseCounter: [u64; 2usize],
        pub mUserHasInteracted: bool,
        pub mPageUnloadingEventTimeStamp: root::mozilla::TimeStamp,
        pub mDocGroup: root::RefPtr<root::mozilla::dom::DocGroup>,
        pub mTrackingScripts: [u64; 5usize],
    }
    pub type nsIDocument_GlobalObject = root::mozilla::dom::GlobalObject;
    pub type nsIDocument_ReferrerPolicyEnum =
        root::mozilla::dom::ReferrerPolicy;
    pub type nsIDocument_Element = root::mozilla::dom::Element;
    pub type nsIDocument_FullscreenRequest =
        root::mozilla::dom::FullscreenRequest;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDocument_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIDocument_PageUnloadingEventTimeStamp {
        pub mDocument: root::nsCOMPtr<root::nsIDocument>,
        pub mSet: bool,
    }
    #[test]
    fn bindgen_test_layout_nsIDocument_PageUnloadingEventTimeStamp() {
        assert_eq!(::std::mem::size_of::<nsIDocument_PageUnloadingEventTimeStamp>()
                   , 16usize);
        assert_eq!(::std::mem::align_of::<nsIDocument_PageUnloadingEventTimeStamp>()
                   , 8usize);
    }
    /**
   * This gets fired when the element that an id refers to changes.
   * This fires at difficult times. It is generally not safe to do anything
   * which could modify the DOM in any way. Use
   * nsContentUtils::AddScriptRunner.
   * @return true to keep the callback in the callback set, false
   * to remove it.
   */
    pub type nsIDocument_IDTargetObserver =
        ::std::option::Option<unsafe extern "C" fn(aOldElement:
                                                       *mut root::nsIDocument_Element,
                                                   aNewelement:
                                                       *mut root::nsIDocument_Element,
                                                   aData:
                                                       *mut ::std::os::raw::c_void)
                                  -> bool>;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIDocument_SelectorCacheKey {
        pub mKey: ::nsstring::nsStringRepr,
        pub mState: root::nsExpirationState,
    }
    #[test]
    fn bindgen_test_layout_nsIDocument_SelectorCacheKey() {
        assert_eq!(::std::mem::size_of::<nsIDocument_SelectorCacheKey>() ,
                   24usize);
        assert_eq!(::std::mem::align_of::<nsIDocument_SelectorCacheKey>() ,
                   8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDocument_SelectorCacheKeyDeleter {
        pub _address: u8,
    }
    impl Clone for nsIDocument_SelectorCacheKeyDeleter {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIDocument_SelectorCache {
        pub _bindgen_opaque_blob: [u64; 15usize],
    }
    #[test]
    fn bindgen_test_layout_nsIDocument_SelectorCache() {
        assert_eq!(::std::mem::size_of::<nsIDocument_SelectorCache>() ,
                   120usize);
        assert_eq!(::std::mem::align_of::<nsIDocument_SelectorCache>() ,
                   8usize);
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_additionalSheetType {
        eAgentSheet = 0,
        eUserSheet = 1,
        eAuthorSheet = 2,
        AdditionalSheetTypeCount = 3,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_ReadyState {
        READYSTATE_UNINITIALIZED = 0,
        READYSTATE_LOADING = 1,
        READYSTATE_INTERACTIVE = 3,
        READYSTATE_COMPLETE = 4,
    }
    /**
   * Enumerate all subdocuments.
   * The enumerator callback should return true to continue enumerating, or
   * false to stop.  This will never get passed a null aDocument.
   */
    pub type nsIDocument_nsSubDocEnumFunc =
        ::std::option::Option<unsafe extern "C" fn(aDocument:
                                                       *mut root::nsIDocument,
                                                   aData:
                                                       *mut ::std::os::raw::c_void)
                                  -> bool>;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_ElementsFromPointFlags {
        IGNORE_ROOT_SCROLL_FRAME = 1,
        FLUSH_LAYOUT = 2,
        IS_ELEMENT_FROM_POINT = 4,
    }
    /**
   * A class that represents an external resource load that has begun but
   * doesn't have a document yet.  Observers can be registered on this object,
   * and will be notified after the document is created.  Observers registered
   * after the document has been created will NOT be notified.  When observers
   * are notified, the subject will be the newly-created document, the topic
   * will be "external-resource-document-created", and the data will be null.
   * If document creation fails for some reason, observers will still be
   * notified, with a null document pointer.
   */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIDocument_ExternalResourceLoad {
        pub _base: root::nsISupports,
        pub mObservers: [u64; 10usize],
    }
    #[test]
    fn bindgen_test_layout_nsIDocument_ExternalResourceLoad() {
        assert_eq!(::std::mem::size_of::<nsIDocument_ExternalResourceLoad>() ,
                   88usize);
        assert_eq!(::std::mem::align_of::<nsIDocument_ExternalResourceLoad>()
                   , 8usize);
    }
    pub type nsIDocument_ActivityObserverEnumerator =
        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                       *mut root::nsISupports,
                                                   arg2:
                                                       *mut ::std::os::raw::c_void)>;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_SuppressionType { eAnimationsOnly = 1, eEvents = 3, }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_DocumentTheme {
        Doc_Theme_Uninitialized = 0,
        Doc_Theme_None = 1,
        Doc_Theme_Neutral = 2,
        Doc_Theme_Dark = 3,
        Doc_Theme_Bright = 4,
    }
    pub type nsIDocument_FrameRequestCallbackList =
        root::nsTArray<root::RefPtr<root::mozilla::dom::FrameRequestCallback>>;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_DeprecatedOperations {
        eGetAttributeNode = 0,
        eSetAttributeNode = 1,
        eGetAttributeNodeNS = 2,
        eSetAttributeNodeNS = 3,
        eRemoveAttributeNode = 4,
        eCreateAttribute = 5,
        eCreateAttributeNS = 6,
        eNodeValue = 7,
        eTextContent = 8,
        eEnablePrivilege = 9,
        eDOMExceptionCode = 10,
        eNoExposedProps = 11,
        eMutationEvent = 12,
        eComponents = 13,
        ePrefixedVisibilityAPI = 14,
        eNodeIteratorDetach = 15,
        eLenientThis = 16,
        eGetPreventDefault = 17,
        eGetSetUserData = 18,
        eMozGetAsFile = 19,
        eUseOfCaptureEvents = 20,
        eUseOfReleaseEvents = 21,
        eUseOfDOM3LoadMethod = 22,
        eChromeUseOfDOM3LoadMethod = 23,
        eShowModalDialog = 24,
        eWindow_Content = 25,
        eSyncXMLHttpRequest = 26,
        eDataContainerEvent = 27,
        eWindow_Controllers = 28,
        eImportXULIntoContent = 29,
        ePannerNodeDoppler = 30,
        eNavigatorGetUserMedia = 31,
        eWebrtcDeprecatedPrefix = 32,
        eRTCPeerConnectionGetStreams = 33,
        eAppCache = 34,
        ePrefixedImageSmoothingEnabled = 35,
        ePrefixedFullscreenAPI = 36,
        eLenientSetter = 37,
        eFileLastModifiedDate = 38,
        eImageBitmapRenderingContext_TransferImageBitmap = 39,
        eDeprecatedOperationCount = 40,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_DocumentWarnings {
        eIgnoringWillChangeOverBudget = 0,
        ePreventDefaultFromPassiveListener = 1,
        eDocumentWarningCount = 2,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_ElementCallbackType {
        eCreated = 0,
        eAttached = 1,
        eDetached = 2,
        eAttributeChanged = 3,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_Type {
        eUnknown = 0,
        eHTML = 1,
        eXHTML = 2,
        eGenericXML = 3,
        eSVG = 4,
        eXUL = 5,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDocument_Tri { eTriUnset = 0, eTriFalse = 1, eTriTrue = 2, }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDocument_FrameRequest {
        pub _address: u8,
    }
    impl Clone for nsIDocument_FrameRequest {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsIDocument() {
        assert_eq!(::std::mem::size_of::<nsIDocument>() , 1000usize);
        assert_eq!(::std::mem::align_of::<nsIDocument>() , 8usize);
    }
    impl nsIDocument {
        #[inline]
        pub fn mBidiEnabled(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (1usize as u64)) >>
                                           0u32) as u8)
            }
        }
        #[inline]
        pub fn set_mBidiEnabled(&mut self, val: bool) {
            self._bitfield_1 &= !(1usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 0u32) & (1usize as u64);
        }
        #[inline]
        pub fn mMathMLEnabled(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (2usize as u64)) >>
                                           1u32) as u8)
            }
        }
        #[inline]
        pub fn set_mMathMLEnabled(&mut self, val: bool) {
            self._bitfield_1 &= !(2usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 1u32) & (2usize as u64);
        }
        #[inline]
        pub fn mIsInitialDocumentInWindow(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (4usize as u64)) >>
                                           2u32) as u8)
            }
        }
        #[inline]
        pub fn set_mIsInitialDocumentInWindow(&mut self, val: bool) {
            self._bitfield_1 &= !(4usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 2u32) & (4usize as u64);
        }
        #[inline]
        pub fn mLoadedAsData(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (8usize as u64)) >>
                                           3u32) as u8)
            }
        }
        #[inline]
        pub fn set_mLoadedAsData(&mut self, val: bool) {
            self._bitfield_1 &= !(8usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 3u32) & (8usize as u64);
        }
        #[inline]
        pub fn mLoadedAsInteractiveData(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (16usize as u64))
                                           >> 4u32) as u8)
            }
        }
        #[inline]
        pub fn set_mLoadedAsInteractiveData(&mut self, val: bool) {
            self._bitfield_1 &= !(16usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 4u32) & (16usize as u64);
        }
        #[inline]
        pub fn mMayStartLayout(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (32usize as u64))
                                           >> 5u32) as u8)
            }
        }
        #[inline]
        pub fn set_mMayStartLayout(&mut self, val: bool) {
            self._bitfield_1 &= !(32usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 5u32) & (32usize as u64);
        }
        #[inline]
        pub fn mHaveFiredTitleChange(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (64usize as u64))
                                           >> 6u32) as u8)
            }
        }
        #[inline]
        pub fn set_mHaveFiredTitleChange(&mut self, val: bool) {
            self._bitfield_1 &= !(64usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 6u32) & (64usize as u64);
        }
        #[inline]
        pub fn mIsShowing(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (128usize as u64))
                                           >> 7u32) as u8)
            }
        }
        #[inline]
        pub fn set_mIsShowing(&mut self, val: bool) {
            self._bitfield_1 &= !(128usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 7u32) & (128usize as u64);
        }
        #[inline]
        pub fn mVisible(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (256usize as u64))
                                           >> 8u32) as u8)
            }
        }
        #[inline]
        pub fn set_mVisible(&mut self, val: bool) {
            self._bitfield_1 &= !(256usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 8u32) & (256usize as u64);
        }
        #[inline]
        pub fn mRemovedFromDocShell(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (512usize as u64))
                                           >> 9u32) as u8)
            }
        }
        #[inline]
        pub fn set_mRemovedFromDocShell(&mut self, val: bool) {
            self._bitfield_1 &= !(512usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 9u32) & (512usize as u64);
        }
        #[inline]
        pub fn mAllowDNSPrefetch(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (1024usize as u64))
                                           >> 10u32) as u8)
            }
        }
        #[inline]
        pub fn set_mAllowDNSPrefetch(&mut self, val: bool) {
            self._bitfield_1 &= !(1024usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 10u32) & (1024usize as u64);
        }
        #[inline]
        pub fn mIsStaticDocument(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (2048usize as u64))
                                           >> 11u32) as u8)
            }
        }
        #[inline]
        pub fn set_mIsStaticDocument(&mut self, val: bool) {
            self._bitfield_1 &= !(2048usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 11u32) & (2048usize as u64);
        }
        #[inline]
        pub fn mCreatingStaticClone(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (4096usize as u64))
                                           >> 12u32) as u8)
            }
        }
        #[inline]
        pub fn set_mCreatingStaticClone(&mut self, val: bool) {
            self._bitfield_1 &= !(4096usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 12u32) & (4096usize as u64);
        }
        #[inline]
        pub fn mInUnlinkOrDeletion(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (8192usize as u64))
                                           >> 13u32) as u8)
            }
        }
        #[inline]
        pub fn set_mInUnlinkOrDeletion(&mut self, val: bool) {
            self._bitfield_1 &= !(8192usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 13u32) & (8192usize as u64);
        }
        #[inline]
        pub fn mHasHadScriptHandlingObject(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (16384usize as u64)) >> 14u32) as
                                          u8)
            }
        }
        #[inline]
        pub fn set_mHasHadScriptHandlingObject(&mut self, val: bool) {
            self._bitfield_1 &= !(16384usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 14u32) & (16384usize as u64);
        }
        #[inline]
        pub fn mIsBeingUsedAsImage(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (32768usize as u64)) >> 15u32) as
                                          u8)
            }
        }
        #[inline]
        pub fn set_mIsBeingUsedAsImage(&mut self, val: bool) {
            self._bitfield_1 &= !(32768usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 15u32) & (32768usize as u64);
        }
        #[inline]
        pub fn mIsSyntheticDocument(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (65536usize as u64)) >> 16u32) as
                                          u8)
            }
        }
        #[inline]
        pub fn set_mIsSyntheticDocument(&mut self, val: bool) {
            self._bitfield_1 &= !(65536usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 16u32) & (65536usize as u64);
        }
        #[inline]
        pub fn mHasLinksToUpdate(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (131072usize as u64)) >> 17u32) as
                                          u8)
            }
        }
        #[inline]
        pub fn set_mHasLinksToUpdate(&mut self, val: bool) {
            self._bitfield_1 &= !(131072usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 17u32) & (131072usize as u64);
        }
        #[inline]
        pub fn mNeedLayoutFlush(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (262144usize as u64)) >> 18u32) as
                                          u8)
            }
        }
        #[inline]
        pub fn set_mNeedLayoutFlush(&mut self, val: bool) {
            self._bitfield_1 &= !(262144usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 18u32) & (262144usize as u64);
        }
        #[inline]
        pub fn mNeedStyleFlush(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (524288usize as u64)) >> 19u32) as
                                          u8)
            }
        }
        #[inline]
        pub fn set_mNeedStyleFlush(&mut self, val: bool) {
            self._bitfield_1 &= !(524288usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 19u32) & (524288usize as u64);
        }
        #[inline]
        pub fn mMayHaveDOMMutationObservers(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (1048576usize as u64)) >> 20u32)
                                          as u8)
            }
        }
        #[inline]
        pub fn set_mMayHaveDOMMutationObservers(&mut self, val: bool) {
            self._bitfield_1 &= !(1048576usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 20u32) & (1048576usize as u64);
        }
        #[inline]
        pub fn mMayHaveAnimationObservers(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (2097152usize as u64)) >> 21u32)
                                          as u8)
            }
        }
        #[inline]
        pub fn set_mMayHaveAnimationObservers(&mut self, val: bool) {
            self._bitfield_1 &= !(2097152usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 21u32) & (2097152usize as u64);
        }
        #[inline]
        pub fn mHasMixedActiveContentLoaded(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (4194304usize as u64)) >> 22u32)
                                          as u8)
            }
        }
        #[inline]
        pub fn set_mHasMixedActiveContentLoaded(&mut self, val: bool) {
            self._bitfield_1 &= !(4194304usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 22u32) & (4194304usize as u64);
        }
        #[inline]
        pub fn mHasMixedActiveContentBlocked(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (8388608usize as u64)) >> 23u32)
                                          as u8)
            }
        }
        #[inline]
        pub fn set_mHasMixedActiveContentBlocked(&mut self, val: bool) {
            self._bitfield_1 &= !(8388608usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 23u32) & (8388608usize as u64);
        }
        #[inline]
        pub fn mHasMixedDisplayContentLoaded(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (16777216usize as u64)) >> 24u32)
                                          as u8)
            }
        }
        #[inline]
        pub fn set_mHasMixedDisplayContentLoaded(&mut self, val: bool) {
            self._bitfield_1 &= !(16777216usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 24u32) & (16777216usize as u64);
        }
        #[inline]
        pub fn mHasMixedDisplayContentBlocked(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (33554432usize as u64)) >> 25u32)
                                          as u8)
            }
        }
        #[inline]
        pub fn set_mHasMixedDisplayContentBlocked(&mut self, val: bool) {
            self._bitfield_1 &= !(33554432usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 25u32) & (33554432usize as u64);
        }
        #[inline]
        pub fn mHasMixedContentObjectSubrequest(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (67108864usize as u64)) >> 26u32)
                                          as u8)
            }
        }
        #[inline]
        pub fn set_mHasMixedContentObjectSubrequest(&mut self, val: bool) {
            self._bitfield_1 &= !(67108864usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 26u32) & (67108864usize as u64);
        }
        #[inline]
        pub fn mHasCSP(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (134217728usize as u64)) >> 27u32)
                                          as u8)
            }
        }
        #[inline]
        pub fn set_mHasCSP(&mut self, val: bool) {
            self._bitfield_1 &= !(134217728usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 27u32) & (134217728usize as u64);
        }
        #[inline]
        pub fn mHasUnsafeEvalCSP(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (268435456usize as u64)) >> 28u32)
                                          as u8)
            }
        }
        #[inline]
        pub fn set_mHasUnsafeEvalCSP(&mut self, val: bool) {
            self._bitfield_1 &= !(268435456usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 28u32) & (268435456usize as u64);
        }
        #[inline]
        pub fn mHasUnsafeInlineCSP(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (536870912usize as u64)) >> 29u32)
                                          as u8)
            }
        }
        #[inline]
        pub fn set_mHasUnsafeInlineCSP(&mut self, val: bool) {
            self._bitfield_1 &= !(536870912usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 29u32) & (536870912usize as u64);
        }
        #[inline]
        pub fn mHasTrackingContentBlocked(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (1073741824usize as u64)) >>
                                           30u32) as u8)
            }
        }
        #[inline]
        pub fn set_mHasTrackingContentBlocked(&mut self, val: bool) {
            self._bitfield_1 &= !(1073741824usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 30u32) & (1073741824usize as u64);
        }
        #[inline]
        pub fn mHasTrackingContentLoaded(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (2147483648usize as u64)) >>
                                           31u32) as u8)
            }
        }
        #[inline]
        pub fn set_mHasTrackingContentLoaded(&mut self, val: bool) {
            self._bitfield_1 &= !(2147483648usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 31u32) & (2147483648usize as u64);
        }
        #[inline]
        pub fn mBFCacheDisallowed(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (4294967296usize as u64)) >>
                                           32u32) as u8)
            }
        }
        #[inline]
        pub fn set_mBFCacheDisallowed(&mut self, val: bool) {
            self._bitfield_1 &= !(4294967296usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 32u32) & (4294967296usize as u64);
        }
        #[inline]
        pub fn mHasHadDefaultView(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (8589934592usize as u64)) >>
                                           33u32) as u8)
            }
        }
        #[inline]
        pub fn set_mHasHadDefaultView(&mut self, val: bool) {
            self._bitfield_1 &= !(8589934592usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 33u32) & (8589934592usize as u64);
        }
        #[inline]
        pub fn mStyleSheetChangeEventsEnabled(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (17179869184usize as u64)) >>
                                           34u32) as u8)
            }
        }
        #[inline]
        pub fn set_mStyleSheetChangeEventsEnabled(&mut self, val: bool) {
            self._bitfield_1 &= !(17179869184usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 34u32) & (17179869184usize as u64);
        }
        #[inline]
        pub fn mIsSrcdocDocument(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (34359738368usize as u64)) >>
                                           35u32) as u8)
            }
        }
        #[inline]
        pub fn set_mIsSrcdocDocument(&mut self, val: bool) {
            self._bitfield_1 &= !(34359738368usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 35u32) & (34359738368usize as u64);
        }
        #[inline]
        pub fn mDidDocumentOpen(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (68719476736usize as u64)) >>
                                           36u32) as u8)
            }
        }
        #[inline]
        pub fn set_mDidDocumentOpen(&mut self, val: bool) {
            self._bitfield_1 &= !(68719476736usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 36u32) & (68719476736usize as u64);
        }
        #[inline]
        pub fn mHasDisplayDocument(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (137438953472usize as u64)) >>
                                           37u32) as u8)
            }
        }
        #[inline]
        pub fn set_mHasDisplayDocument(&mut self, val: bool) {
            self._bitfield_1 &= !(137438953472usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 37u32) & (137438953472usize as u64);
        }
        #[inline]
        pub fn mFontFaceSetDirty(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (274877906944usize as u64)) >>
                                           38u32) as u8)
            }
        }
        #[inline]
        pub fn set_mFontFaceSetDirty(&mut self, val: bool) {
            self._bitfield_1 &= !(274877906944usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 38u32) & (274877906944usize as u64);
        }
        #[inline]
        pub fn mGetUserFontSetCalled(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (549755813888usize as u64)) >>
                                           39u32) as u8)
            }
        }
        #[inline]
        pub fn set_mGetUserFontSetCalled(&mut self, val: bool) {
            self._bitfield_1 &= !(549755813888usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 39u32) & (549755813888usize as u64);
        }
        #[inline]
        pub fn mPostedFlushUserFontSet(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (1099511627776usize as u64)) >>
                                           40u32) as u8)
            }
        }
        #[inline]
        pub fn set_mPostedFlushUserFontSet(&mut self, val: bool) {
            self._bitfield_1 &= !(1099511627776usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 40u32) & (1099511627776usize as u64);
        }
        #[inline]
        pub fn mEverInForeground(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (2199023255552usize as u64)) >>
                                           41u32) as u8)
            }
        }
        #[inline]
        pub fn set_mEverInForeground(&mut self, val: bool) {
            self._bitfield_1 &= !(2199023255552usize as u64);
            self._bitfield_1 |=
                ((val as u8 as u64) << 41u32) & (2199023255552usize as u64);
        }
        #[inline]
        pub fn mDidFireDOMContentLoaded(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_2 & (1usize as u8)) >>
                                           0u32) as u8)
            }
        }
        #[inline]
        pub fn set_mDidFireDOMContentLoaded(&mut self, val: bool) {
            self._bitfield_2 &= !(1usize as u8);
            self._bitfield_2 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
        }
        #[inline]
        pub fn mHasScrollLinkedEffect(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_2 & (2usize as u8)) >>
                                           1u32) as u8)
            }
        }
        #[inline]
        pub fn set_mHasScrollLinkedEffect(&mut self, val: bool) {
            self._bitfield_2 &= !(2usize as u8);
            self._bitfield_2 |= ((val as u8 as u8) << 1u32) & (2usize as u8);
        }
    }
    /**
 * The global object which keeps a script context for each supported script
 * language. This often used to store per-window global state.
 * This is a heavyweight interface implemented only by DOM globals, and
 * it might go away some time in the future.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIScriptGlobalObject {
        pub _base: root::nsIGlobalObject,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIScriptGlobalObject_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIScriptGlobalObject() {
        assert_eq!(::std::mem::size_of::<nsIScriptGlobalObject>() , 32usize);
        assert_eq!(::std::mem::align_of::<nsIScriptGlobalObject>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIObserver {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIObserver_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIObserver() {
        assert_eq!(::std::mem::size_of::<nsIObserver>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsIObserver>() , 8usize);
    }
    impl Clone for nsIObserver {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIVariant {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIVariant_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIVariant() {
        assert_eq!(::std::mem::size_of::<nsIVariant>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsIVariant>() , 8usize);
    }
    impl Clone for nsIVariant {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsINamed {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsINamed_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsINamed() {
        assert_eq!(::std::mem::size_of::<nsINamed>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsINamed>() , 8usize);
    }
    impl Clone for nsINamed {
        fn clone(&self) -> Self { *self }
    }
    pub type DOMHighResTimeStamp = f64;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMAttr {
        pub _base: root::nsIDOMNode,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMAttr_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMAttr() {
        assert_eq!(::std::mem::size_of::<nsIDOMAttr>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsIDOMAttr>() , 8usize);
    }
    impl Clone for nsIDOMAttr {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMNode {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMNode_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const nsIDOMNode_ELEMENT_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::ELEMENT_NODE;
    pub const nsIDOMNode_ATTRIBUTE_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::ATTRIBUTE_NODE;
    pub const nsIDOMNode_TEXT_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::TEXT_NODE;
    pub const nsIDOMNode_CDATA_SECTION_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::CDATA_SECTION_NODE;
    pub const nsIDOMNode_ENTITY_REFERENCE_NODE: root::nsIDOMNode__bindgen_ty_1
              =
        nsIDOMNode__bindgen_ty_1::ENTITY_REFERENCE_NODE;
    pub const nsIDOMNode_ENTITY_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::ENTITY_NODE;
    pub const nsIDOMNode_PROCESSING_INSTRUCTION_NODE:
              root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::PROCESSING_INSTRUCTION_NODE;
    pub const nsIDOMNode_COMMENT_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::COMMENT_NODE;
    pub const nsIDOMNode_DOCUMENT_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::DOCUMENT_NODE;
    pub const nsIDOMNode_DOCUMENT_TYPE_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::DOCUMENT_TYPE_NODE;
    pub const nsIDOMNode_DOCUMENT_FRAGMENT_NODE:
              root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::DOCUMENT_FRAGMENT_NODE;
    pub const nsIDOMNode_NOTATION_NODE: root::nsIDOMNode__bindgen_ty_1 =
        nsIDOMNode__bindgen_ty_1::NOTATION_NODE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDOMNode__bindgen_ty_1 {
        ELEMENT_NODE = 1,
        ATTRIBUTE_NODE = 2,
        TEXT_NODE = 3,
        CDATA_SECTION_NODE = 4,
        ENTITY_REFERENCE_NODE = 5,
        ENTITY_NODE = 6,
        PROCESSING_INSTRUCTION_NODE = 7,
        COMMENT_NODE = 8,
        DOCUMENT_NODE = 9,
        DOCUMENT_TYPE_NODE = 10,
        DOCUMENT_FRAGMENT_NODE = 11,
        NOTATION_NODE = 12,
    }
    pub const nsIDOMNode_DOCUMENT_POSITION_DISCONNECTED:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_DISCONNECTED;
    pub const nsIDOMNode_DOCUMENT_POSITION_PRECEDING:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_PRECEDING;
    pub const nsIDOMNode_DOCUMENT_POSITION_FOLLOWING:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_FOLLOWING;
    pub const nsIDOMNode_DOCUMENT_POSITION_CONTAINS:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_CONTAINS;
    pub const nsIDOMNode_DOCUMENT_POSITION_CONTAINED_BY:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_CONTAINED_BY;
    pub const nsIDOMNode_DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC:
              root::nsIDOMNode__bindgen_ty_2 =
        nsIDOMNode__bindgen_ty_2::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIDOMNode__bindgen_ty_2 {
        DOCUMENT_POSITION_DISCONNECTED = 1,
        DOCUMENT_POSITION_PRECEDING = 2,
        DOCUMENT_POSITION_FOLLOWING = 4,
        DOCUMENT_POSITION_CONTAINS = 8,
        DOCUMENT_POSITION_CONTAINED_BY = 16,
        DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMNode() {
        assert_eq!(::std::mem::size_of::<nsIDOMNode>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsIDOMNode>() , 8usize);
    }
    impl Clone for nsIDOMNode {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMClientRect {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMClientRect_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMClientRect() {
        assert_eq!(::std::mem::size_of::<nsIDOMClientRect>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsIDOMClientRect>() , 8usize);
    }
    impl Clone for nsIDOMClientRect {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMStyleSheet {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMStyleSheet_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMStyleSheet() {
        assert_eq!(::std::mem::size_of::<nsIDOMStyleSheet>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsIDOMStyleSheet>() , 8usize);
    }
    impl Clone for nsIDOMStyleSheet {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMEventTarget {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMEventTarget_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMEventTarget() {
        assert_eq!(::std::mem::size_of::<nsIDOMEventTarget>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsIDOMEventTarget>() , 8usize);
    }
    impl Clone for nsIDOMEventTarget {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMHTMLCollection {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMHTMLCollection_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMHTMLCollection() {
        assert_eq!(::std::mem::size_of::<nsIDOMHTMLCollection>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsIDOMHTMLCollection>() , 8usize);
    }
    impl Clone for nsIDOMHTMLCollection {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMCSSStyleSheet {
        pub _base: root::nsIDOMStyleSheet,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMCSSStyleSheet_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMCSSStyleSheet() {
        assert_eq!(::std::mem::size_of::<nsIDOMCSSStyleSheet>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsIDOMCSSStyleSheet>() , 8usize);
    }
    impl Clone for nsIDOMCSSStyleSheet {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIControllers {
        pub _address: u8,
    }
    impl Clone for nsIControllers {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u8)]
    /**
 * Enumeration that represents one of the two supported style system backends.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum StyleBackendType { Gecko = 1, Servo = 2, }
    pub const nsChangeHint_nsChangeHint_Empty: root::nsChangeHint =
        nsChangeHint(0);
    pub const nsChangeHint_nsChangeHint_RepaintFrame: root::nsChangeHint =
        nsChangeHint(1);
    pub const nsChangeHint_nsChangeHint_NeedReflow: root::nsChangeHint =
        nsChangeHint(2);
    pub const nsChangeHint_nsChangeHint_ClearAncestorIntrinsics:
              root::nsChangeHint =
        nsChangeHint(4);
    pub const nsChangeHint_nsChangeHint_ClearDescendantIntrinsics:
              root::nsChangeHint =
        nsChangeHint(8);
    pub const nsChangeHint_nsChangeHint_NeedDirtyReflow: root::nsChangeHint =
        nsChangeHint(16);
    pub const nsChangeHint_nsChangeHint_SyncFrameView: root::nsChangeHint =
        nsChangeHint(32);
    pub const nsChangeHint_nsChangeHint_UpdateCursor: root::nsChangeHint =
        nsChangeHint(64);
    pub const nsChangeHint_nsChangeHint_UpdateEffects: root::nsChangeHint =
        nsChangeHint(128);
    pub const nsChangeHint_nsChangeHint_UpdateOpacityLayer: root::nsChangeHint
              =
        nsChangeHint(256);
    pub const nsChangeHint_nsChangeHint_UpdateTransformLayer:
              root::nsChangeHint =
        nsChangeHint(512);
    pub const nsChangeHint_nsChangeHint_ReconstructFrame: root::nsChangeHint =
        nsChangeHint(1024);
    pub const nsChangeHint_nsChangeHint_UpdateOverflow: root::nsChangeHint =
        nsChangeHint(2048);
    pub const nsChangeHint_nsChangeHint_UpdateSubtreeOverflow:
              root::nsChangeHint =
        nsChangeHint(4096);
    pub const nsChangeHint_nsChangeHint_UpdatePostTransformOverflow:
              root::nsChangeHint =
        nsChangeHint(8192);
    pub const nsChangeHint_nsChangeHint_UpdateParentOverflow:
              root::nsChangeHint =
        nsChangeHint(16384);
    pub const nsChangeHint_nsChangeHint_ChildrenOnlyTransform:
              root::nsChangeHint =
        nsChangeHint(32768);
    pub const nsChangeHint_nsChangeHint_RecomputePosition: root::nsChangeHint
              =
        nsChangeHint(65536);
    pub const nsChangeHint_nsChangeHint_UpdateContainingBlock:
              root::nsChangeHint =
        nsChangeHint(131072);
    pub const nsChangeHint_nsChangeHint_BorderStyleNoneChange:
              root::nsChangeHint =
        nsChangeHint(262144);
    pub const nsChangeHint_nsChangeHint_UpdateTextPath: root::nsChangeHint =
        nsChangeHint(524288);
    pub const nsChangeHint_nsChangeHint_SchedulePaint: root::nsChangeHint =
        nsChangeHint(1048576);
    pub const nsChangeHint_nsChangeHint_NeutralChange: root::nsChangeHint =
        nsChangeHint(2097152);
    pub const nsChangeHint_nsChangeHint_InvalidateRenderingObservers:
              root::nsChangeHint =
        nsChangeHint(4194304);
    pub const nsChangeHint_nsChangeHint_ReflowChangesSizeOrPosition:
              root::nsChangeHint =
        nsChangeHint(8388608);
    pub const nsChangeHint_nsChangeHint_UpdateComputedBSize:
              root::nsChangeHint =
        nsChangeHint(16777216);
    pub const nsChangeHint_nsChangeHint_UpdateUsesOpacity: root::nsChangeHint
              =
        nsChangeHint(33554432);
    pub const nsChangeHint_nsChangeHint_UpdateBackgroundPosition:
              root::nsChangeHint =
        nsChangeHint(67108864);
    pub const nsChangeHint_nsChangeHint_AddOrRemoveTransform:
              root::nsChangeHint =
        nsChangeHint(134217728);
    pub const nsChangeHint_nsChangeHint_AllHints: root::nsChangeHint =
        nsChangeHint(268435455);
    impl ::std::ops::BitOr<root::nsChangeHint> for root::nsChangeHint {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self { nsChangeHint(self.0 | other.0) }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct nsChangeHint(pub u32);
    pub const nsRestyleHint_eRestyle_Self: root::nsRestyleHint =
        nsRestyleHint(1);
    pub const nsRestyleHint_eRestyle_SomeDescendants: root::nsRestyleHint =
        nsRestyleHint(2);
    pub const nsRestyleHint_eRestyle_Subtree: root::nsRestyleHint =
        nsRestyleHint(4);
    pub const nsRestyleHint_eRestyle_LaterSiblings: root::nsRestyleHint =
        nsRestyleHint(8);
    pub const nsRestyleHint_eRestyle_CSSTransitions: root::nsRestyleHint =
        nsRestyleHint(16);
    pub const nsRestyleHint_eRestyle_CSSAnimations: root::nsRestyleHint =
        nsRestyleHint(32);
    pub const nsRestyleHint_eRestyle_SVGAttrAnimations: root::nsRestyleHint =
        nsRestyleHint(64);
    pub const nsRestyleHint_eRestyle_StyleAttribute: root::nsRestyleHint =
        nsRestyleHint(128);
    pub const nsRestyleHint_eRestyle_StyleAttribute_Animations:
              root::nsRestyleHint =
        nsRestyleHint(256);
    pub const nsRestyleHint_eRestyle_Force: root::nsRestyleHint =
        nsRestyleHint(512);
    pub const nsRestyleHint_eRestyle_ForceDescendants: root::nsRestyleHint =
        nsRestyleHint(1024);
    pub const nsRestyleHint_eRestyle_AllHintsWithAnimations:
              root::nsRestyleHint =
        nsRestyleHint(368);
    impl ::std::ops::BitOr<root::nsRestyleHint> for root::nsRestyleHint {
        type
        Output
        =
        Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            nsRestyleHint(self.0 | other.0)
        }
    }
    #[repr(C)]
    /**
 * |nsRestyleHint| is a bitfield for the result of
 * |HasStateDependentStyle| and |HasAttributeDependentStyle|.  When no
 * restyling is necessary, use |nsRestyleHint(0)|.
 *
 * Without eRestyle_Force or eRestyle_ForceDescendants, the restyling process
 * can stop processing at a frame when it detects no style changes and it is
 * known that the styles of the subtree beneath it will not change, leaving
 * the old style context on the frame.  eRestyle_Force can be used to skip this
 * optimization on a frame, and to force its new style context to be used.
 *
 * Similarly, eRestyle_ForceDescendants will cause the frame and all of its
 * descendants to be traversed and for the new style contexts that are created
 * to be set on the frames.
 *
 * NOTE: When adding new restyle hints, please also add them to
 * RestyleManager::RestyleHintToString.
 */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct nsRestyleHint(pub u32);
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCompatibility {
        eCompatibility_FullStandards = 1,
        eCompatibility_AlmostStandards = 2,
        eCompatibility_NavQuirks = 3,
    }
    pub type nscolor = u32;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPresContext {
        pub _base: root::nsIObserver,
        pub _base_1: u64,
        pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
        pub mType: root::nsPresContext_nsPresContextType,
        pub mShell: *mut root::nsIPresShell,
        pub mDocument: root::nsCOMPtr<root::nsIDocument>,
        pub mDeviceContext: root::RefPtr<root::nsDeviceContext>,
        pub mEventManager: root::RefPtr<root::mozilla::EventStateManager>,
        pub mRefreshDriver: root::RefPtr<root::nsRefreshDriver>,
        pub mEffectCompositor: root::RefPtr<root::mozilla::EffectCompositor>,
        pub mTransitionManager: root::RefPtr<root::nsTransitionManager>,
        pub mAnimationManager: root::RefPtr<root::nsAnimationManager>,
        pub mRestyleManager: root::mozilla::RestyleManagerHandle_RefPtr,
        pub mCounterStyleManager: root::RefPtr<root::mozilla::CounterStyleManager>,
        pub mMedium: *mut root::nsIAtom,
        pub mMediaEmulated: root::nsCOMPtr<root::nsIAtom>,
        pub mLinkHandler: *mut root::nsILinkHandler,
        pub mLanguage: root::nsCOMPtr<root::nsIAtom>,
        pub mInflationDisabledForShrinkWrap: bool,
        pub mContainer: u64,
        pub mBaseMinFontSize: i32,
        pub mTextZoom: f32,
        pub mFullZoom: f32,
        pub mOverrideDPPX: f32,
        pub mLastFontInflationScreenSize: [u64; 2usize],
        pub mCurAppUnitsPerDevPixel: i32,
        pub mAutoQualityMinFontSizePixelsPref: i32,
        pub mTheme: root::nsCOMPtr<root::nsITheme>,
        pub mLangService: root::nsCOMPtr<root::nsILanguageAtomService>,
        pub mPrintSettings: root::nsCOMPtr<root::nsIPrintSettings>,
        pub mPrefChangedTimer: root::nsCOMPtr<root::nsITimer>,
        pub mPropertyTable: root::nsPresContext_FramePropertyTable,
        pub mInvalidateRequestsSinceLastPaint: root::nsInvalidateRequestList,
        pub mUndeliveredInvalidateRequestsBeforeLastPaint: root::nsInvalidateRequestList,
        pub mTextPerf: root::nsAutoPtr<root::gfxTextPerfMetrics>,
        pub mMissingFonts: root::nsAutoPtr<root::gfxMissingFontRecorder>,
        pub mVisibleArea: root::nsRect,
        pub mPageSize: root::nsSize,
        pub mPageScale: f32,
        pub mPPScale: f32,
        pub mDefaultColor: root::nscolor,
        pub mBackgroundColor: root::nscolor,
        pub mLinkColor: root::nscolor,
        pub mActiveLinkColor: root::nscolor,
        pub mVisitedLinkColor: root::nscolor,
        pub mFocusBackgroundColor: root::nscolor,
        pub mFocusTextColor: root::nscolor,
        pub mBodyTextColor: root::nscolor,
        pub mViewportStyleScrollbar: root::nsPresContext_ScrollbarStyles,
        pub mFocusRingWidth: u8,
        pub mExistThrottledUpdates: bool,
        pub mImageAnimationMode: u16,
        pub mImageAnimationModePref: u16,
        pub mLangGroupFontPrefs: root::nsPresContext_LangGroupFontPrefs,
        pub mBorderWidthTable: [root::nscoord; 3usize],
        pub mInterruptChecksToSkip: u32,
        pub mElementsRestyled: u64,
        pub mFramesConstructed: u64,
        pub mFramesReflowed: u64,
        pub mReflowStartTime: root::mozilla::TimeStamp,
        pub mLastStyleUpdateForAllAnimations: root::mozilla::TimeStamp,
        pub _bitfield_1: u64,
    }
    pub type nsPresContext_FramePropertyTable =
        root::mozilla::FramePropertyTable;
    pub type nsPresContext_LangGroupFontPrefs =
        root::mozilla::LangGroupFontPrefs;
    pub type nsPresContext_ScrollbarStyles = root::ScrollbarStyles;
    pub type nsPresContext_StaticPresData = root::mozilla::StaticPresData;
    pub type nsPresContext_HasThreadSafeRefCnt = root::mozilla::FalseType;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsPresContext_cycleCollection {
        pub _base: root::nsXPCOMCycleCollectionParticipant,
    }
    #[test]
    fn bindgen_test_layout_nsPresContext_cycleCollection() {
        assert_eq!(::std::mem::size_of::<nsPresContext_cycleCollection>() ,
                   16usize);
        assert_eq!(::std::mem::align_of::<nsPresContext_cycleCollection>() ,
                   8usize);
    }
    impl Clone for nsPresContext_cycleCollection {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsPresContext_nsPresContextType {
        eContext_Galley = 0,
        eContext_PrintPreview = 1,
        eContext_Print = 2,
        eContext_PageLayout = 3,
    }
    /**
   * A class that can be used to temporarily disable reflow interruption.
   */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPresContext_InterruptPreventer {
        pub mCtx: *mut root::nsPresContext,
        pub mInterruptsEnabled: bool,
        pub mHasPendingInterrupt: bool,
    }
    #[test]
    fn bindgen_test_layout_nsPresContext_InterruptPreventer() {
        assert_eq!(::std::mem::size_of::<nsPresContext_InterruptPreventer>() ,
                   16usize);
        assert_eq!(::std::mem::align_of::<nsPresContext_InterruptPreventer>()
                   , 8usize);
    }
    extern "C" {
        #[link_name = "_ZN13nsPresContext21_cycleCollectorGlobalE"]
        pub static mut nsPresContext__cycleCollectorGlobal:
                   root::nsPresContext_cycleCollection;
    }
    #[test]
    fn bindgen_test_layout_nsPresContext() {
        assert_eq!(::std::mem::size_of::<nsPresContext>() , 1216usize);
        assert_eq!(::std::mem::align_of::<nsPresContext>() , 8usize);
    }
    impl nsPresContext {
        #[inline]
        pub fn mHasPendingInterrupt(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (1usize as u64)) >>
                                           0u32) as u32)
            }
        }
        #[inline]
        pub fn set_mHasPendingInterrupt(&mut self,
                                        val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(1usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 0u32) & (1usize as u64);
        }
        #[inline]
        pub fn mPendingInterruptFromTest(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (2usize as u64)) >>
                                           1u32) as u32)
            }
        }
        #[inline]
        pub fn set_mPendingInterruptFromTest(&mut self,
                                             val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(2usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 1u32) & (2usize as u64);
        }
        #[inline]
        pub fn mInterruptsEnabled(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (4usize as u64)) >>
                                           2u32) as u32)
            }
        }
        #[inline]
        pub fn set_mInterruptsEnabled(&mut self,
                                      val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(4usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 2u32) & (4usize as u64);
        }
        #[inline]
        pub fn mUseDocumentFonts(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (8usize as u64)) >>
                                           3u32) as u32)
            }
        }
        #[inline]
        pub fn set_mUseDocumentFonts(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(8usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 3u32) & (8usize as u64);
        }
        #[inline]
        pub fn mUseDocumentColors(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (16usize as u64))
                                           >> 4u32) as u32)
            }
        }
        #[inline]
        pub fn set_mUseDocumentColors(&mut self,
                                      val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(16usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 4u32) & (16usize as u64);
        }
        #[inline]
        pub fn mUnderlineLinks(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (32usize as u64))
                                           >> 5u32) as u32)
            }
        }
        #[inline]
        pub fn set_mUnderlineLinks(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(32usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 5u32) & (32usize as u64);
        }
        #[inline]
        pub fn mSendAfterPaintToContent(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (64usize as u64))
                                           >> 6u32) as u32)
            }
        }
        #[inline]
        pub fn set_mSendAfterPaintToContent(&mut self,
                                            val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(64usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 6u32) & (64usize as u64);
        }
        #[inline]
        pub fn mUseFocusColors(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (128usize as u64))
                                           >> 7u32) as u32)
            }
        }
        #[inline]
        pub fn set_mUseFocusColors(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(128usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 7u32) & (128usize as u64);
        }
        #[inline]
        pub fn mFocusRingOnAnything(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (256usize as u64))
                                           >> 8u32) as u32)
            }
        }
        #[inline]
        pub fn set_mFocusRingOnAnything(&mut self,
                                        val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(256usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 8u32) & (256usize as u64);
        }
        #[inline]
        pub fn mFocusRingStyle(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (512usize as u64))
                                           >> 9u32) as u32)
            }
        }
        #[inline]
        pub fn set_mFocusRingStyle(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(512usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 9u32) & (512usize as u64);
        }
        #[inline]
        pub fn mDrawImageBackground(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (1024usize as u64))
                                           >> 10u32) as u32)
            }
        }
        #[inline]
        pub fn set_mDrawImageBackground(&mut self,
                                        val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(1024usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 10u32) & (1024usize as u64);
        }
        #[inline]
        pub fn mDrawColorBackground(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (2048usize as u64))
                                           >> 11u32) as u32)
            }
        }
        #[inline]
        pub fn set_mDrawColorBackground(&mut self,
                                        val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(2048usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 11u32) & (2048usize as u64);
        }
        #[inline]
        pub fn mNeverAnimate(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (4096usize as u64))
                                           >> 12u32) as u32)
            }
        }
        #[inline]
        pub fn set_mNeverAnimate(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(4096usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 12u32) & (4096usize as u64);
        }
        #[inline]
        pub fn mIsRenderingOnlySelection(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (8192usize as u64))
                                           >> 13u32) as u32)
            }
        }
        #[inline]
        pub fn set_mIsRenderingOnlySelection(&mut self,
                                             val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(8192usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 13u32) & (8192usize as u64);
        }
        #[inline]
        pub fn mPaginated(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (16384usize as u64)) >> 14u32) as
                                          u32)
            }
        }
        #[inline]
        pub fn set_mPaginated(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(16384usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 14u32) & (16384usize as u64);
        }
        #[inline]
        pub fn mCanPaginatedScroll(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (32768usize as u64)) >> 15u32) as
                                          u32)
            }
        }
        #[inline]
        pub fn set_mCanPaginatedScroll(&mut self,
                                       val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(32768usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 15u32) & (32768usize as u64);
        }
        #[inline]
        pub fn mDoScaledTwips(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (65536usize as u64)) >> 16u32) as
                                          u32)
            }
        }
        #[inline]
        pub fn set_mDoScaledTwips(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(65536usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 16u32) & (65536usize as u64);
        }
        #[inline]
        pub fn mIsRootPaginatedDocument(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (131072usize as u64)) >> 17u32) as
                                          u32)
            }
        }
        #[inline]
        pub fn set_mIsRootPaginatedDocument(&mut self,
                                            val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(131072usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 17u32) & (131072usize as u64);
        }
        #[inline]
        pub fn mPrefBidiDirection(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (262144usize as u64)) >> 18u32) as
                                          u32)
            }
        }
        #[inline]
        pub fn set_mPrefBidiDirection(&mut self,
                                      val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(262144usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 18u32) & (262144usize as u64);
        }
        #[inline]
        pub fn mPrefScrollbarSide(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (1572864usize as u64)) >> 19u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_mPrefScrollbarSide(&mut self,
                                      val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(1572864usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 19u32) & (1572864usize as u64);
        }
        #[inline]
        pub fn mPendingSysColorChanged(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (2097152usize as u64)) >> 21u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_mPendingSysColorChanged(&mut self,
                                           val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(2097152usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 21u32) & (2097152usize as u64);
        }
        #[inline]
        pub fn mPendingThemeChanged(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (4194304usize as u64)) >> 22u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_mPendingThemeChanged(&mut self,
                                        val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(4194304usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 22u32) & (4194304usize as u64);
        }
        #[inline]
        pub fn mPendingUIResolutionChanged(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (8388608usize as u64)) >> 23u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_mPendingUIResolutionChanged(&mut self,
                                               val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(8388608usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 23u32) & (8388608usize as u64);
        }
        #[inline]
        pub fn mPendingMediaFeatureValuesChanged(&self)
         -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (16777216usize as u64)) >> 24u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_mPendingMediaFeatureValuesChanged(&mut self,
                                                     val:
                                                         ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(16777216usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 24u32) & (16777216usize as u64);
        }
        #[inline]
        pub fn mPrefChangePendingNeedsReflow(&self)
         -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (33554432usize as u64)) >> 25u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_mPrefChangePendingNeedsReflow(&mut self,
                                                 val:
                                                     ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(33554432usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 25u32) & (33554432usize as u64);
        }
        #[inline]
        pub fn mIsEmulatingMedia(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (67108864usize as u64)) >> 26u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_mIsEmulatingMedia(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(67108864usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 26u32) & (67108864usize as u64);
        }
        #[inline]
        pub fn mAllInvalidated(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (134217728usize as u64)) >> 27u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_mAllInvalidated(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(134217728usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 27u32) & (134217728usize as u64);
        }
        #[inline]
        pub fn mIsGlyph(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (268435456usize as u64)) >> 28u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_mIsGlyph(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(268435456usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 28u32) & (268435456usize as u64);
        }
        #[inline]
        pub fn mUsesRootEMUnits(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (536870912usize as u64)) >> 29u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_mUsesRootEMUnits(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(536870912usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 29u32) & (536870912usize as u64);
        }
        #[inline]
        pub fn mUsesExChUnits(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (1073741824usize as u64)) >>
                                           30u32) as u32)
            }
        }
        #[inline]
        pub fn set_mUsesExChUnits(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(1073741824usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 30u32) & (1073741824usize as u64);
        }
        #[inline]
        pub fn mUsesViewportUnits(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (2147483648usize as u64)) >>
                                           31u32) as u32)
            }
        }
        #[inline]
        pub fn set_mUsesViewportUnits(&mut self,
                                      val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(2147483648usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 31u32) & (2147483648usize as u64);
        }
        #[inline]
        pub fn mPendingViewportChange(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (4294967296usize as u64)) >>
                                           32u32) as u32)
            }
        }
        #[inline]
        pub fn set_mPendingViewportChange(&mut self,
                                          val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(4294967296usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 32u32) & (4294967296usize as u64);
        }
        #[inline]
        pub fn mCounterStylesDirty(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (8589934592usize as u64)) >>
                                           33u32) as u32)
            }
        }
        #[inline]
        pub fn set_mCounterStylesDirty(&mut self,
                                       val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(8589934592usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 33u32) & (8589934592usize as u64);
        }
        #[inline]
        pub fn mPostedFlushCounterStyles(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (17179869184usize as u64)) >>
                                           34u32) as u32)
            }
        }
        #[inline]
        pub fn set_mPostedFlushCounterStyles(&mut self,
                                             val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(17179869184usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 34u32) & (17179869184usize as u64);
        }
        #[inline]
        pub fn mSuppressResizeReflow(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (34359738368usize as u64)) >>
                                           35u32) as u32)
            }
        }
        #[inline]
        pub fn set_mSuppressResizeReflow(&mut self,
                                         val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(34359738368usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 35u32) & (34359738368usize as u64);
        }
        #[inline]
        pub fn mIsVisual(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (68719476736usize as u64)) >>
                                           36u32) as u32)
            }
        }
        #[inline]
        pub fn set_mIsVisual(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(68719476736usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 36u32) & (68719476736usize as u64);
        }
        #[inline]
        pub fn mFireAfterPaintEvents(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (137438953472usize as u64)) >>
                                           37u32) as u32)
            }
        }
        #[inline]
        pub fn set_mFireAfterPaintEvents(&mut self,
                                         val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(137438953472usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 37u32) & (137438953472usize as u64);
        }
        #[inline]
        pub fn mIsChrome(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (274877906944usize as u64)) >>
                                           38u32) as u32)
            }
        }
        #[inline]
        pub fn set_mIsChrome(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(274877906944usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 38u32) & (274877906944usize as u64);
        }
        #[inline]
        pub fn mIsChromeOriginImage(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (549755813888usize as u64)) >>
                                           39u32) as u32)
            }
        }
        #[inline]
        pub fn set_mIsChromeOriginImage(&mut self,
                                        val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(549755813888usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 39u32) & (549755813888usize as u64);
        }
        #[inline]
        pub fn mPaintFlashing(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (1099511627776usize as u64)) >>
                                           40u32) as u32)
            }
        }
        #[inline]
        pub fn set_mPaintFlashing(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(1099511627776usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 40u32) & (1099511627776usize as u64);
        }
        #[inline]
        pub fn mPaintFlashingInitialized(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (2199023255552usize as u64)) >>
                                           41u32) as u32)
            }
        }
        #[inline]
        pub fn set_mPaintFlashingInitialized(&mut self,
                                             val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(2199023255552usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 41u32) & (2199023255552usize as u64);
        }
        #[inline]
        pub fn mHasWarnedAboutPositionedTableParts(&self)
         -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (4398046511104usize as u64)) >>
                                           42u32) as u32)
            }
        }
        #[inline]
        pub fn set_mHasWarnedAboutPositionedTableParts(&mut self,
                                                       val:
                                                           ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(4398046511104usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 42u32) & (4398046511104usize as u64);
        }
        #[inline]
        pub fn mHasWarnedAboutTooLargeDashedOrDottedRadius(&self)
         -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (8796093022208usize as u64)) >>
                                           43u32) as u32)
            }
        }
        #[inline]
        pub fn set_mHasWarnedAboutTooLargeDashedOrDottedRadius(&mut self,
                                                               val:
                                                                   ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(8796093022208usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 43u32) & (8796093022208usize as u64);
        }
        #[inline]
        pub fn mQuirkSheetAdded(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (17592186044416usize as u64)) >>
                                           44u32) as u32)
            }
        }
        #[inline]
        pub fn set_mQuirkSheetAdded(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(17592186044416usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 44u32) & (17592186044416usize as u64);
        }
        #[inline]
        pub fn mNeedsPrefUpdate(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (35184372088832usize as u64)) >>
                                           45u32) as u32)
            }
        }
        #[inline]
        pub fn set_mNeedsPrefUpdate(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(35184372088832usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 45u32) & (35184372088832usize as u64);
        }
        #[inline]
        pub fn mHadNonBlankPaint(&self) -> ::std::os::raw::c_uint {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (70368744177664usize as u64)) >>
                                           46u32) as u32)
            }
        }
        #[inline]
        pub fn set_mHadNonBlankPaint(&mut self, val: ::std::os::raw::c_uint) {
            self._bitfield_1 &= !(70368744177664usize as u64);
            self._bitfield_1 |=
                ((val as u32 as u64) << 46u32) & (70368744177664usize as u64);
        }
    }
    pub type PLDHashNumber = u32;
    #[repr(C)]
    #[derive(Debug)]
    pub struct PLDHashTable {
        pub mOps: *const root::PLDHashTableOps,
        pub mHashShift: i16,
        pub mEntrySize: u32,
        pub mEntryCount: u32,
        pub mRemovedCount: u32,
        pub mEntryStore: root::PLDHashTable_EntryStore,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct PLDHashTable_EntryStore {
        pub mEntryStore: *mut ::std::os::raw::c_char,
        pub mGeneration: u32,
    }
    #[test]
    fn bindgen_test_layout_PLDHashTable_EntryStore() {
        assert_eq!(::std::mem::size_of::<PLDHashTable_EntryStore>() ,
                   16usize);
        assert_eq!(::std::mem::align_of::<PLDHashTable_EntryStore>() ,
                   8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct PLDHashTable_Iterator {
        pub mTable: *mut root::PLDHashTable,
        pub mStart: *mut ::std::os::raw::c_char,
        pub mLimit: *mut ::std::os::raw::c_char,
        pub mCurrent: *mut ::std::os::raw::c_char,
        pub mNexts: u32,
        pub mNextsLimit: u32,
        pub mHaveRemoved: bool,
    }
    #[test]
    fn bindgen_test_layout_PLDHashTable_Iterator() {
        assert_eq!(::std::mem::size_of::<PLDHashTable_Iterator>() , 48usize);
        assert_eq!(::std::mem::align_of::<PLDHashTable_Iterator>() , 8usize);
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum PLDHashTable_SearchReason { ForSearchOrRemove = 0, ForAdd = 1, }
    pub const PLDHashTable_kMaxCapacity: u32 = 67108864;
    pub const PLDHashTable_kMinCapacity: u32 = 8;
    pub const PLDHashTable_kMaxInitialLength: u32 = 33554432;
    pub const PLDHashTable_kDefaultInitialLength: u32 = 4;
    pub const PLDHashTable_kHashBits: u32 = 32;
    pub const PLDHashTable_kGoldenRatio: u32 = 2654435769;
    pub const PLDHashTable_kCollisionFlag: root::PLDHashNumber = 1;
    #[test]
    fn bindgen_test_layout_PLDHashTable() {
        assert_eq!(::std::mem::size_of::<PLDHashTable>() , 40usize);
        assert_eq!(::std::mem::align_of::<PLDHashTable>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLDHashTableOps {
        pub hashKey: root::PLDHashHashKey,
        pub matchEntry: root::PLDHashMatchEntry,
        pub moveEntry: root::PLDHashMoveEntry,
        pub clearEntry: root::PLDHashClearEntry,
        pub initEntry: root::PLDHashInitEntry,
    }
    #[test]
    fn bindgen_test_layout_PLDHashTableOps() {
        assert_eq!(::std::mem::size_of::<PLDHashTableOps>() , 40usize);
        assert_eq!(::std::mem::align_of::<PLDHashTableOps>() , 8usize);
    }
    impl Clone for PLDHashTableOps {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLDHashEntryHdr {
        pub mKeyHash: root::PLDHashNumber,
    }
    #[test]
    fn bindgen_test_layout_PLDHashEntryHdr() {
        assert_eq!(::std::mem::size_of::<PLDHashEntryHdr>() , 4usize);
        assert_eq!(::std::mem::align_of::<PLDHashEntryHdr>() , 4usize);
    }
    impl Clone for PLDHashEntryHdr {
        fn clone(&self) -> Self { *self }
    }
    pub type PLDHashHashKey =
        ::std::option::Option<unsafe extern "C" fn(aKey:
                                                       *const ::std::os::raw::c_void)
                                  -> ::std::os::raw::c_uint>;
    pub type PLDHashMatchEntry =
        ::std::option::Option<unsafe extern "C" fn(aEntry:
                                                       *const root::PLDHashEntryHdr,
                                                   aKey:
                                                       *const ::std::os::raw::c_void)
                                  -> bool>;
    pub type PLDHashMoveEntry =
        ::std::option::Option<unsafe extern "C" fn(aTable:
                                                       *mut root::PLDHashTable,
                                                   aFrom:
                                                       *const root::PLDHashEntryHdr,
                                                   aTo:
                                                       *mut root::PLDHashEntryHdr)>;
    pub type PLDHashClearEntry =
        ::std::option::Option<unsafe extern "C" fn(aTable:
                                                       *mut root::PLDHashTable,
                                                   aEntry:
                                                       *mut root::PLDHashEntryHdr)>;
    pub type PLDHashInitEntry =
        ::std::option::Option<unsafe extern "C" fn(aEntry:
                                                       *mut root::PLDHashEntryHdr,
                                                   aKey:
                                                       *const ::std::os::raw::c_void)>;
    /**
 * hashkey wrapper using T* KeyType
 *
 * @see nsTHashtable::EntryType for specification
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPtrHashKey<T> {
        pub _base: root::PLDHashEntryHdr,
        pub mKey: *mut T,
    }
    pub type nsPtrHashKey_KeyType<T> = *mut T;
    pub type nsPtrHashKey_KeyTypePointer<T> = *mut T;
    pub const nsPtrHashKey_ALLOW_MEMMOVE: root::nsPtrHashKey__bindgen_ty_1 =
        nsPtrHashKey__bindgen_ty_1::ALLOW_MEMMOVE;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsPtrHashKey__bindgen_ty_1 { ALLOW_MEMMOVE = 0, }
    /**
 * Struct that stores info on an attribute. The name and value must either both
 * be null or both be non-null.
 *
 * Note that, just as the pointers returned by GetAttrNameAt, the pointers that
 * this struct hold are only valid until the element or its attributes are
 * mutated (directly or via script).
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct BorrowedAttrInfo {
        pub mName: *const root::nsAttrName,
        pub mValue: *const root::nsAttrValue,
    }
    #[test]
    fn bindgen_test_layout_BorrowedAttrInfo() {
        assert_eq!(::std::mem::size_of::<BorrowedAttrInfo>() , 16usize);
        assert_eq!(::std::mem::align_of::<BorrowedAttrInfo>() , 8usize);
    }
    impl Clone for BorrowedAttrInfo {
        fn clone(&self) -> Self { *self }
    }
    /**
 * A node of content in a document's content model. This interface
 * is supported by all content objects.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIContent {
        pub _base: root::nsINode,
    }
    pub type nsIContent_IMEState = root::mozilla::widget::IMEState;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIContent_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const nsIContent_eAllChildren: root::nsIContent__bindgen_ty_1 =
        nsIContent__bindgen_ty_1::eAllChildren;
    pub const nsIContent_eAllButXBL: root::nsIContent__bindgen_ty_1 =
        nsIContent__bindgen_ty_1::eAllButXBL;
    pub const nsIContent_eSkipPlaceholderContent:
              root::nsIContent__bindgen_ty_1 =
        nsIContent__bindgen_ty_1::eSkipPlaceholderContent;
    pub const nsIContent_eSkipDocumentLevelNativeAnonymousContent:
              root::nsIContent__bindgen_ty_1 =
        nsIContent__bindgen_ty_1::eSkipDocumentLevelNativeAnonymousContent;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIContent__bindgen_ty_1 {
        eAllChildren = 0,
        eAllButXBL = 1,
        eSkipPlaceholderContent = 2,
        eSkipDocumentLevelNativeAnonymousContent = 4,
    }
    pub const nsIContent_ATTR_MISSING: root::nsIContent__bindgen_ty_2 =
        nsIContent__bindgen_ty_2::ATTR_MISSING;
    pub const nsIContent_ATTR_VALUE_NO_MATCH: root::nsIContent__bindgen_ty_2 =
        nsIContent__bindgen_ty_2::ATTR_VALUE_NO_MATCH;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIContent__bindgen_ty_2 {
        ATTR_MISSING = -1,
        ATTR_VALUE_NO_MATCH = -2,
    }
    /**
   * Check whether this content node's given attribute has one of a given
   * list of values. If there is a match, we return the index in the list
   * of the first matching value. If there was no attribute at all, then
   * we return ATTR_MISSING. If there was an attribute but it didn't
   * match, we return ATTR_VALUE_NO_MATCH. A non-negative result always
   * indicates a match.
   *
   * @param aNameSpaceID The namespace ID of the attribute.  Must not
   *                     be kNameSpaceID_Unknown.
   * @param aName The name atom of the attribute.  Must not be null.
   * @param aValues a nullptr-terminated array of pointers to atom values to test
   *                against.
   * @param aCaseSensitive Whether to do a case-sensitive compare on the values.
   * @return ATTR_MISSING, ATTR_VALUE_NO_MATCH or the non-negative index
   * indicating the first value of aValues that matched
   */
    pub type nsIContent_AttrValuesArray = *const *const root::nsIAtom;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIContent_FlattenedParentType {
        eNotForStyle = 0,
        eForStyle = 1,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIContent_ETabFocusType {
        eTabFocus_textControlsMask = 1,
        eTabFocus_formElementsMask = 2,
        eTabFocus_linksMask = 4,
        eTabFocus_any = 7,
    }
    extern "C" {
        #[link_name = "_ZN10nsIContent14sTabFocusModelE"]
        pub static mut nsIContent_sTabFocusModel: i32;
    }
    extern "C" {
        #[link_name = "_ZN10nsIContent26sTabFocusModelAppliesToXULE"]
        pub static mut nsIContent_sTabFocusModelAppliesToXUL: bool;
    }
    #[test]
    fn bindgen_test_layout_nsIContent() {
        assert_eq!(::std::mem::size_of::<nsIContent>() , 96usize);
        assert_eq!(::std::mem::align_of::<nsIContent>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsICSSDeclaration {
        pub _address: u8,
    }
    impl Clone for nsICSSDeclaration {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIWeakReference {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIWeakReference_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIWeakReference() {
        assert_eq!(::std::mem::size_of::<nsIWeakReference>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsIWeakReference>() , 8usize);
    }
    impl Clone for nsIWeakReference {
        fn clone(&self) -> Self { *self }
    }
    pub type nsWeakPtr = root::nsCOMPtr<root::nsIWeakReference>;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIChannel {
        pub _base: root::nsIRequest,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIChannel_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const nsIChannel_LOAD_DOCUMENT_URI: root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_DOCUMENT_URI;
    pub const nsIChannel_LOAD_RETARGETED_DOCUMENT_URI:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_RETARGETED_DOCUMENT_URI;
    pub const nsIChannel_LOAD_REPLACE: root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_REPLACE;
    pub const nsIChannel_LOAD_INITIAL_DOCUMENT_URI:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_INITIAL_DOCUMENT_URI;
    pub const nsIChannel_LOAD_TARGETED: root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_TARGETED;
    pub const nsIChannel_LOAD_CALL_CONTENT_SNIFFERS:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_CALL_CONTENT_SNIFFERS;
    pub const nsIChannel_LOAD_CLASSIFY_URI: root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_CLASSIFY_URI;
    pub const nsIChannel_LOAD_MEDIA_SNIFFER_OVERRIDES_CONTENT_TYPE:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_MEDIA_SNIFFER_OVERRIDES_CONTENT_TYPE;
    pub const nsIChannel_LOAD_EXPLICIT_CREDENTIALS:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_EXPLICIT_CREDENTIALS;
    pub const nsIChannel_LOAD_BYPASS_SERVICE_WORKER:
              root::nsIChannel__bindgen_ty_1 =
        nsIChannel__bindgen_ty_1::LOAD_BYPASS_SERVICE_WORKER;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIChannel__bindgen_ty_1 {
        LOAD_DOCUMENT_URI = 65536,
        LOAD_RETARGETED_DOCUMENT_URI = 131072,
        LOAD_REPLACE = 262144,
        LOAD_INITIAL_DOCUMENT_URI = 524288,
        LOAD_TARGETED = 1048576,
        LOAD_CALL_CONTENT_SNIFFERS = 2097152,
        LOAD_CLASSIFY_URI = 4194304,
        LOAD_MEDIA_SNIFFER_OVERRIDES_CONTENT_TYPE = 8388608,
        LOAD_EXPLICIT_CREDENTIALS = 16777216,
        LOAD_BYPASS_SERVICE_WORKER = 33554432,
    }
    pub const nsIChannel_DISPOSITION_INLINE: root::nsIChannel__bindgen_ty_2 =
        nsIChannel__bindgen_ty_2::DISPOSITION_INLINE;
    pub const nsIChannel_DISPOSITION_ATTACHMENT:
              root::nsIChannel__bindgen_ty_2 =
        nsIChannel__bindgen_ty_2::DISPOSITION_ATTACHMENT;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIChannel__bindgen_ty_2 {
        DISPOSITION_INLINE = 0,
        DISPOSITION_ATTACHMENT = 1,
    }
    #[test]
    fn bindgen_test_layout_nsIChannel() {
        assert_eq!(::std::mem::size_of::<nsIChannel>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsIChannel>() , 8usize);
    }
    impl Clone for nsIChannel {
        fn clone(&self) -> Self { *self }
    }
    pub type nsLoadFlags = u32;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsILoadGroup {
        pub _base: root::nsIRequest,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsILoadGroup_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsILoadGroup() {
        assert_eq!(::std::mem::size_of::<nsILoadGroup>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsILoadGroup>() , 8usize);
    }
    impl Clone for nsILoadGroup {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIRequest {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIRequest_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const nsIRequest_LOAD_REQUESTMASK: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_REQUESTMASK;
    pub const nsIRequest_LOAD_NORMAL: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_NORMAL;
    pub const nsIRequest_LOAD_BACKGROUND: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_BACKGROUND;
    pub const nsIRequest_INHIBIT_PIPELINE: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::INHIBIT_PIPELINE;
    pub const nsIRequest_INHIBIT_CACHING: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::INHIBIT_CACHING;
    pub const nsIRequest_INHIBIT_PERSISTENT_CACHING:
              root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::INHIBIT_PERSISTENT_CACHING;
    pub const nsIRequest_LOAD_BYPASS_CACHE: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_BYPASS_CACHE;
    pub const nsIRequest_LOAD_FROM_CACHE: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_FROM_CACHE;
    pub const nsIRequest_VALIDATE_ALWAYS: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::VALIDATE_ALWAYS;
    pub const nsIRequest_VALIDATE_NEVER: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::VALIDATE_NEVER;
    pub const nsIRequest_VALIDATE_ONCE_PER_SESSION:
              root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::VALIDATE_ONCE_PER_SESSION;
    pub const nsIRequest_LOAD_ANONYMOUS: root::nsIRequest__bindgen_ty_1 =
        nsIRequest__bindgen_ty_1::LOAD_ANONYMOUS;
    pub const nsIRequest_LOAD_FRESH_CONNECTION: root::nsIRequest__bindgen_ty_1
              =
        nsIRequest__bindgen_ty_1::LOAD_FRESH_CONNECTION;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIRequest__bindgen_ty_1 {
        LOAD_REQUESTMASK = 65535,
        LOAD_NORMAL = 0,
        LOAD_BACKGROUND = 1,
        INHIBIT_PIPELINE = 64,
        INHIBIT_CACHING = 128,
        INHIBIT_PERSISTENT_CACHING = 256,
        LOAD_BYPASS_CACHE = 512,
        LOAD_FROM_CACHE = 1024,
        VALIDATE_ALWAYS = 2048,
        VALIDATE_NEVER = 4096,
        VALIDATE_ONCE_PER_SESSION = 8192,
        LOAD_ANONYMOUS = 16384,
        LOAD_FRESH_CONNECTION = 32768,
    }
    #[test]
    fn bindgen_test_layout_nsIRequest() {
        assert_eq!(::std::mem::size_of::<nsIRequest>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsIRequest>() , 8usize);
    }
    impl Clone for nsIRequest {
        fn clone(&self) -> Self { *self }
    }
    /**
 * An internal interface that abstracts some DOMNode-related parts that both
 * nsIContent and nsIDocument share.  An instance of this interface has a list
 * of nsIContent children and provides access to them.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsINode {
        pub _base: root::mozilla::dom::EventTarget,
        pub mNodeInfo: root::RefPtr<root::mozilla::dom::NodeInfo>,
        pub mParent: *mut root::nsINode,
        pub mBoolFlags: u32,
        pub mNextSibling: *mut root::nsIContent,
        pub mPreviousSibling: *mut root::nsIContent,
        pub mFirstChild: *mut root::nsIContent,
        pub __bindgen_anon_1: root::nsINode__bindgen_ty_1,
        pub mSlots: *mut root::nsINode_nsSlots,
    }
    pub type nsINode_BoxQuadOptions = root::mozilla::dom::BoxQuadOptions;
    pub type nsINode_ConvertCoordinateOptions =
        root::mozilla::dom::ConvertCoordinateOptions;
    pub type nsINode_DOMPoint = root::mozilla::dom::DOMPoint;
    pub type nsINode_DOMPointInit = root::mozilla::dom::DOMPointInit;
    pub type nsINode_DOMQuad = root::mozilla::dom::DOMQuad;
    pub type nsINode_DOMRectReadOnly = root::mozilla::dom::DOMRectReadOnly;
    pub type nsINode_OwningNodeOrString =
        root::mozilla::dom::OwningNodeOrString;
    pub type nsINode_TextOrElementOrDocument =
        root::mozilla::dom::TextOrElementOrDocument;
    pub type nsINode_ErrorResult = [u64; 2usize];
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsINode_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const nsINode_eCONTENT: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eCONTENT;
    pub const nsINode_eDOCUMENT: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eDOCUMENT;
    pub const nsINode_eATTRIBUTE: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eATTRIBUTE;
    pub const nsINode_eTEXT: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eTEXT;
    pub const nsINode_ePROCESSING_INSTRUCTION: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::ePROCESSING_INSTRUCTION;
    pub const nsINode_eCOMMENT: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eCOMMENT;
    pub const nsINode_eHTML_FORM_CONTROL: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eHTML_FORM_CONTROL;
    pub const nsINode_eDOCUMENT_FRAGMENT: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eDOCUMENT_FRAGMENT;
    pub const nsINode_eDATA_NODE: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eDATA_NODE;
    pub const nsINode_eMEDIA: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eMEDIA;
    pub const nsINode_eANIMATION: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eANIMATION;
    pub const nsINode_eFILTER: root::nsINode__bindgen_ty_2 =
        nsINode__bindgen_ty_2::eFILTER;
    #[repr(u32)]
    /**
   * Bit-flags to pass (or'ed together) to IsNodeOfType()
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsINode__bindgen_ty_2 {
        eCONTENT = 1,
        eDOCUMENT = 2,
        eATTRIBUTE = 4,
        eTEXT = 8,
        ePROCESSING_INSTRUCTION = 16,
        eCOMMENT = 32,
        eHTML_FORM_CONTROL = 64,
        eDOCUMENT_FRAGMENT = 128,
        eDATA_NODE = 256,
        eMEDIA = 512,
        eANIMATION = 1024,
        eFILTER = 2048,
    }
    #[repr(C)]
    pub struct nsINode_nsSlots__bindgen_vtable {
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsINode_nsSlots {
        pub vtable_: *const nsINode_nsSlots__bindgen_vtable,
        /**
     * A list of mutation observers
     */
        pub mMutationObservers: [u64; 2usize],
        /**
     * An object implementing nsIDOMNodeList for this content (childNodes)
     * @see nsIDOMNodeList
     * @see nsGenericHTMLElement::GetChildNodes
     */
        pub mChildNodes: root::RefPtr<root::nsChildContentList>,
        /**
     * Weak reference to this node.  This is cleared by the destructor of
     * nsNodeWeakReference.
     */
        pub mWeakReference: *mut root::nsNodeWeakReference,
        /**
     * Number of descendant nodes in the uncomposed document that have been
     * explicitly set as editable.
     */
        pub mEditableDescendantCount: u32,
    }
    #[test]
    fn bindgen_test_layout_nsINode_nsSlots() {
        assert_eq!(::std::mem::size_of::<nsINode_nsSlots>() , 48usize);
        assert_eq!(::std::mem::align_of::<nsINode_nsSlots>() , 8usize);
    }
    #[repr(u32)]
    /**
   * Boolean flags
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsINode_BooleanFlag {
        NodeHasRenderingObservers = 0,
        IsInDocument = 1,
        ParentIsContent = 2,
        NodeIsElement = 3,
        ElementHasID = 4,
        ElementMayHaveStyle = 5,
        ElementHasName = 6,
        ElementMayHaveContentEditableAttr = 7,
        NodeIsCommonAncestorForRangeInSelection = 8,
        NodeIsDescendantOfCommonAncestorForRangeInSelection = 9,
        NodeIsCCMarkedRoot = 10,
        NodeIsCCBlackTree = 11,
        NodeIsPurpleRoot = 12,
        NodeHasExplicitBaseURI = 13,
        ElementHasLockedStyleStates = 14,
        ElementHasPointerLock = 15,
        NodeMayHaveDOMMutationObserver = 16,
        NodeIsContent = 17,
        ElementHasAnimations = 18,
        NodeHasValidDirAttribute = 19,
        NodeHasFixedDir = 20,
        NodeHasDirAutoSet = 21,
        NodeHasTextNodeDirectionalityMap = 22,
        NodeHasDirAuto = 23,
        NodeAncestorHasDirAuto = 24,
        ElementIsInStyleScope = 25,
        ElementIsScopedStyleRoot = 26,
        NodeHandlingClick = 27,
        NodeHasRelevantHoverRules = 28,
        ElementHasWeirdParserInsertionMode = 29,
        ParserHasNotified = 30,
        MayBeApzAware = 31,
        BooleanFlagCount = 32,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsINode__bindgen_ty_1 {
        pub mPrimaryFrame: root::__BindgenUnionField<*mut root::nsIFrame>,
        pub mSubtreeRoot: root::__BindgenUnionField<*mut root::nsINode>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsINode__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsINode__bindgen_ty_1>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsINode__bindgen_ty_1>() , 8usize);
    }
    impl Clone for nsINode__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsINode() {
        assert_eq!(::std::mem::size_of::<nsINode>() , 96usize);
        assert_eq!(::std::mem::align_of::<nsINode>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCOMArray_base {
        pub mArray: root::nsTArray<*mut root::nsISupports>,
    }
    pub type nsCOMArray_base_nsBaseArrayEnumFunc =
        ::std::option::Option<unsafe extern "C" fn(aElement:
                                                       *mut ::std::os::raw::c_void,
                                                   aData:
                                                       *mut ::std::os::raw::c_void)
                                  -> bool>;
    pub type nsCOMArray_base_nsBaseArrayComparatorFunc =
        ::std::option::Option<unsafe extern "C" fn(aElement1:
                                                       *mut root::nsISupports,
                                                   aElement2:
                                                       *mut root::nsISupports,
                                                   aData:
                                                       *mut ::std::os::raw::c_void)
                                  -> ::std::os::raw::c_int>;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCOMArray_base_nsCOMArrayComparatorContext {
        pub mComparatorFunc: root::nsCOMArray_base_nsBaseArrayComparatorFunc,
        pub mData: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_nsCOMArray_base_nsCOMArrayComparatorContext() {
        assert_eq!(::std::mem::size_of::<nsCOMArray_base_nsCOMArrayComparatorContext>()
                   , 16usize);
        assert_eq!(::std::mem::align_of::<nsCOMArray_base_nsCOMArrayComparatorContext>()
                   , 8usize);
    }
    impl Clone for nsCOMArray_base_nsCOMArrayComparatorContext {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsCOMArray_base() {
        assert_eq!(::std::mem::size_of::<nsCOMArray_base>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsCOMArray_base>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCOMArray<T> {
        pub _base: root::nsCOMArray_base,
        pub _phantom_0: ::std::marker::PhantomData<T>,
    }
    pub type nsCOMArray_nsCOMArrayEnumFunc<T> =
        ::std::option::Option<unsafe extern "C" fn(aElement: *mut T,
                                                   aData:
                                                       *mut ::std::os::raw::c_void)
                                  -> bool>;
    pub type nsCOMArray_nsCOMArrayComparatorFunc<T> =
        ::std::option::Option<unsafe extern "C" fn(aElement1: *mut T,
                                                   aElement2: *mut T,
                                                   aData:
                                                       *mut ::std::os::raw::c_void)
                                  -> ::std::os::raw::c_int>;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAttrValue {
        pub mBits: usize,
    }
    pub type nsAttrValue_AtomArray =
        root::nsTArray<root::nsCOMPtr<root::nsIAtom>>;
    pub const nsAttrValue_ValueType_eSVGTypesBegin:
              root::nsAttrValue_ValueType =
        nsAttrValue_ValueType::eSVGAngle;
    pub const nsAttrValue_ValueType_eSVGTypesEnd: root::nsAttrValue_ValueType
              =
        nsAttrValue_ValueType::eSVGViewBox;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsAttrValue_ValueType {
        eString = 0,
        eAtom = 2,
        eInteger = 3,
        eColor = 7,
        eEnum = 11,
        ePercent = 15,
        eCSSDeclaration = 16,
        eURL = 17,
        eImage = 18,
        eAtomArray = 19,
        eDoubleValue = 20,
        eIntMarginValue = 21,
        eSVGAngle = 22,
        eSVGIntegerPair = 23,
        eSVGLength = 24,
        eSVGLengthList = 25,
        eSVGNumberList = 26,
        eSVGNumberPair = 27,
        eSVGPathData = 28,
        eSVGPointList = 29,
        eSVGPreserveAspectRatio = 30,
        eSVGStringList = 31,
        eSVGTransformList = 32,
        eSVGViewBox = 33,
    }
    /**
   * Structure for a mapping from int (enum) values to strings.  When you use
   * it you generally create an array of them.
   * Instantiate like this:
   * EnumTable myTable[] = {
   *   { "string1", 1 },
   *   { "string2", 2 },
   *   { nullptr, 0 }
   * }
   */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsAttrValue_EnumTable {
        /** The string the value maps to */
        pub tag: *const ::std::os::raw::c_char,
        /** The enum value that maps to this string */
        pub value: i16,
    }
    #[test]
    fn bindgen_test_layout_nsAttrValue_EnumTable() {
        assert_eq!(::std::mem::size_of::<nsAttrValue_EnumTable>() , 16usize);
        assert_eq!(::std::mem::align_of::<nsAttrValue_EnumTable>() , 8usize);
    }
    impl Clone for nsAttrValue_EnumTable {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsAttrValue_ValueBaseType {
        eStringBase = 0,
        eOtherBase = 1,
        eAtomBase = 2,
        eIntegerBase = 3,
    }
    extern "C" {
        #[link_name = "_ZN11nsAttrValue15sEnumTableArrayE"]
        pub static mut nsAttrValue_sEnumTableArray:
                   *mut root::nsTArray<*const root::nsAttrValue_EnumTable>;
    }
    #[test]
    fn bindgen_test_layout_nsAttrValue() {
        assert_eq!(::std::mem::size_of::<nsAttrValue>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsAttrValue>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsNodeInfoManager {
        pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
        pub mNodeInfoHash: *mut root::PLHashTable,
        pub mDocument: *mut root::nsIDocument,
        pub mNonDocumentNodeInfos: u32,
        pub mPrincipal: root::nsCOMPtr<root::nsIPrincipal>,
        pub mDefaultPrincipal: root::nsCOMPtr<root::nsIPrincipal>,
        pub mTextNodeInfo: *mut root::mozilla::dom::NodeInfo,
        pub mCommentNodeInfo: *mut root::mozilla::dom::NodeInfo,
        pub mDocumentNodeInfo: *mut root::mozilla::dom::NodeInfo,
        pub mBindingManager: root::RefPtr<root::nsBindingManager>,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsNodeInfoManager_cycleCollection {
        pub _base: root::nsCycleCollectionParticipant,
    }
    #[test]
    fn bindgen_test_layout_nsNodeInfoManager_cycleCollection() {
        assert_eq!(::std::mem::size_of::<nsNodeInfoManager_cycleCollection>()
                   , 16usize);
        assert_eq!(::std::mem::align_of::<nsNodeInfoManager_cycleCollection>()
                   , 8usize);
    }
    impl Clone for nsNodeInfoManager_cycleCollection {
        fn clone(&self) -> Self { *self }
    }
    pub type nsNodeInfoManager_HasThreadSafeRefCnt = root::mozilla::FalseType;
    extern "C" {
        #[link_name = "_ZN17nsNodeInfoManager21_cycleCollectorGlobalE"]
        pub static mut nsNodeInfoManager__cycleCollectorGlobal:
                   root::nsNodeInfoManager_cycleCollection;
    }
    #[test]
    fn bindgen_test_layout_nsNodeInfoManager() {
        assert_eq!(::std::mem::size_of::<nsNodeInfoManager>() , 80usize);
        assert_eq!(::std::mem::align_of::<nsNodeInfoManager>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsBindingManager {
        pub _address: u8,
    }
    impl Clone for nsBindingManager {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIFrame {
        pub _address: u8,
    }
    impl Clone for nsIFrame {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPropertyTable {
        pub mPropertyList: *mut root::nsPropertyTable_PropertyList,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsPropertyTable_PropertyList {
        pub _address: u8,
    }
    impl Clone for nsPropertyTable_PropertyList {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsPropertyTable() {
        assert_eq!(::std::mem::size_of::<nsPropertyTable>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsPropertyTable>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAttrAndChildArray {
        pub mImpl: *mut root::nsAttrAndChildArray_Impl,
    }
    pub type nsAttrAndChildArray_BorrowedAttrInfo = root::BorrowedAttrInfo;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAttrAndChildArray_InternalAttr {
        pub mName: root::nsAttrName,
        pub mValue: root::nsAttrValue,
    }
    #[test]
    fn bindgen_test_layout_nsAttrAndChildArray_InternalAttr() {
        assert_eq!(::std::mem::size_of::<nsAttrAndChildArray_InternalAttr>() ,
                   16usize);
        assert_eq!(::std::mem::align_of::<nsAttrAndChildArray_InternalAttr>()
                   , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsAttrAndChildArray_Impl {
        pub mAttrAndChildCount: u32,
        pub mBufferSize: u32,
        pub mMappedAttrs: *mut root::nsMappedAttributes,
        pub mBuffer: [*mut ::std::os::raw::c_void; 1usize],
    }
    #[test]
    fn bindgen_test_layout_nsAttrAndChildArray_Impl() {
        assert_eq!(::std::mem::size_of::<nsAttrAndChildArray_Impl>() ,
                   24usize);
        assert_eq!(::std::mem::align_of::<nsAttrAndChildArray_Impl>() ,
                   8usize);
    }
    impl Clone for nsAttrAndChildArray_Impl {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsAttrAndChildArray() {
        assert_eq!(::std::mem::size_of::<nsAttrAndChildArray>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsAttrAndChildArray>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsChildContentList {
        pub _address: u8,
    }
    impl Clone for nsChildContentList {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsDOMAttributeMap {
        pub _base: root::nsIDOMMozNamedAttrMap,
        pub _base_1: root::nsWrapperCache,
        pub mRefCnt: root::nsCycleCollectingAutoRefCnt,
        pub mContent: root::nsCOMPtr<root::mozilla::dom::Element>,
        /**
   * Cache of Attrs.
   */
        pub mAttributeCache: root::nsDOMAttributeMap_AttrCache,
    }
    pub type nsDOMAttributeMap_Attr = root::mozilla::dom::Attr;
    pub type nsDOMAttributeMap_Element = root::mozilla::dom::Element;
    pub type nsDOMAttributeMap_ErrorResult = [u64; 2usize];
    pub type nsDOMAttributeMap_HasThreadSafeRefCnt = root::mozilla::FalseType;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsDOMAttributeMap_cycleCollection {
        pub _base: root::nsXPCOMCycleCollectionParticipant,
    }
    #[test]
    fn bindgen_test_layout_nsDOMAttributeMap_cycleCollection() {
        assert_eq!(::std::mem::size_of::<nsDOMAttributeMap_cycleCollection>()
                   , 16usize);
        assert_eq!(::std::mem::align_of::<nsDOMAttributeMap_cycleCollection>()
                   , 8usize);
    }
    impl Clone for nsDOMAttributeMap_cycleCollection {
        fn clone(&self) -> Self { *self }
    }
    pub type nsDOMAttributeMap_AttrCache = [u64; 5usize];
    extern "C" {
        #[link_name = "_ZN17nsDOMAttributeMap21_cycleCollectorGlobalE"]
        pub static mut nsDOMAttributeMap__cycleCollectorGlobal:
                   root::nsDOMAttributeMap_cycleCollection;
    }
    #[test]
    fn bindgen_test_layout_nsDOMAttributeMap() {
        assert_eq!(::std::mem::size_of::<nsDOMAttributeMap>() , 88usize);
        assert_eq!(::std::mem::align_of::<nsDOMAttributeMap>() , 8usize);
    }
    /**
 * Presentation shell interface. Presentation shells are the
 * controlling point for managing the presentation of a document. The
 * presentation shell holds a live reference to the document, the
 * presentation context, the style manager, the style set and the root
 * frame. <p>
 *
 * When this object is Release'd, it will release the document, the
 * presentation context, the style manager, the style set and the root
 * frame.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIPresShell {
        pub _base: root::nsISupports,
        pub mDocument: root::nsCOMPtr<root::nsIDocument>,
        pub mPresContext: root::RefPtr<root::nsPresContext>,
        pub mStyleSet: root::StyleSetHandle,
        pub mFrameConstructor: *mut root::nsCSSFrameConstructor,
        pub mViewManager: *mut root::nsViewManager,
        pub mFrameArena: root::nsPresArena,
        pub mSelection: root::RefPtr<root::nsFrameSelection>,
        pub mFrameManager: *mut root::nsFrameManagerBase,
        pub mForwardingContainer: u64,
        pub mHiddenInvalidationObserverRefreshDriver: *mut root::nsRefreshDriver,
        pub mDocAccessible: *mut root::mozilla::a11y::DocAccessible,
        pub mReflowContinueTimer: root::nsCOMPtr<root::nsITimer>,
        pub mPaintCount: u64,
        pub mScrollPositionClampingScrollPortSize: root::nsSize,
        pub mWeakFrames: *mut root::nsWeakFrame,
        pub mCanvasBackgroundColor: root::nscolor,
        pub mResolution: [u64; 2usize],
        pub mSelectionFlags: i16,
        pub mRenderFlags: root::nsIPresShell_RenderFlags,
        pub _bitfield_1: u16,
        pub mPresShellId: u32,
        pub mChangedScopeStyleRoots: [u64; 3usize],
        pub mFontSizeInflationEmPerLine: u32,
        pub mFontSizeInflationMinTwips: u32,
        pub mFontSizeInflationLineThreshold: u32,
        pub mFontSizeInflationForceEnabled: bool,
        pub mFontSizeInflationDisabledInMasterProcess: bool,
        pub mFontSizeInflationEnabled: bool,
        pub mPaintingIsFrozen: bool,
        pub mFontSizeInflationEnabledIsDirty: bool,
        pub mIsNeverPainting: bool,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIPresShell_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub type nsIPresShell_LayerManager = root::mozilla::layers::LayerManager;
    pub type nsIPresShell_SourceSurface = root::mozilla::gfx::SourceSurface;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_eRenderFlag {
        STATE_IGNORING_VIEWPORT_SCROLLING = 1,
        STATE_DRAWWINDOW_NOT_FLUSHING = 2,
    }
    pub type nsIPresShell_RenderFlags = u8;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_ScrollDirection {
        eHorizontal = 0,
        eVertical = 1,
        eEither = 2,
    }
    #[repr(u32)]
    /**
   * Tell the pres shell that a frame needs to be marked dirty and needs
   * Reflow.  It's OK if this is an ancestor of the frame needing reflow as
   * long as the ancestor chain between them doesn't cross a reflow root.
   *
   * The bit to add should be NS_FRAME_IS_DIRTY, NS_FRAME_HAS_DIRTY_CHILDREN
   * or nsFrameState(0); passing 0 means that dirty bits won't be set on the
   * frame or its ancestors/descendants, but that intrinsic widths will still
   * be marked dirty.  Passing aIntrinsicDirty = eResize and aBitToAdd = 0
   * would result in no work being done, so don't do that.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_IntrinsicDirty {
        eResize = 0,
        eTreeChange = 1,
        eStyleChange = 2,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_ReflowRootHandling {
        ePositionOrSizeChange = 0,
        eNoPositionOrSizeChange = 1,
        eInferFromBitToAdd = 2,
    }
    pub const nsIPresShell_SCROLL_TOP: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_TOP;
    pub const nsIPresShell_SCROLL_BOTTOM: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_BOTTOM;
    pub const nsIPresShell_SCROLL_LEFT: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_TOP;
    pub const nsIPresShell_SCROLL_RIGHT: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_BOTTOM;
    pub const nsIPresShell_SCROLL_CENTER: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_CENTER;
    pub const nsIPresShell_SCROLL_MINIMUM: root::nsIPresShell__bindgen_ty_1 =
        nsIPresShell__bindgen_ty_1::SCROLL_MINIMUM;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell__bindgen_ty_1 {
        SCROLL_TOP = 0,
        SCROLL_BOTTOM = 100,
        SCROLL_CENTER = 50,
        SCROLL_MINIMUM = -1,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_WhenToScroll {
        SCROLL_ALWAYS = 0,
        SCROLL_IF_NOT_VISIBLE = 1,
        SCROLL_IF_NOT_FULLY_VISIBLE = 2,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIPresShell_ScrollAxis {
        pub _bindgen_opaque_blob: u32,
    }
    #[test]
    fn bindgen_test_layout_nsIPresShell_ScrollAxis() {
        assert_eq!(::std::mem::size_of::<nsIPresShell_ScrollAxis>() , 4usize);
        assert_eq!(::std::mem::align_of::<nsIPresShell_ScrollAxis>() ,
                   4usize);
    }
    impl Clone for nsIPresShell_ScrollAxis {
        fn clone(&self) -> Self { *self }
    }
    pub const nsIPresShell_SCROLL_FIRST_ANCESTOR_ONLY:
              root::nsIPresShell__bindgen_ty_2 =
        nsIPresShell__bindgen_ty_2::SCROLL_FIRST_ANCESTOR_ONLY;
    pub const nsIPresShell_SCROLL_OVERFLOW_HIDDEN:
              root::nsIPresShell__bindgen_ty_2 =
        nsIPresShell__bindgen_ty_2::SCROLL_OVERFLOW_HIDDEN;
    pub const nsIPresShell_SCROLL_NO_PARENT_FRAMES:
              root::nsIPresShell__bindgen_ty_2 =
        nsIPresShell__bindgen_ty_2::SCROLL_NO_PARENT_FRAMES;
    pub const nsIPresShell_SCROLL_SMOOTH: root::nsIPresShell__bindgen_ty_2 =
        nsIPresShell__bindgen_ty_2::SCROLL_SMOOTH;
    pub const nsIPresShell_SCROLL_SMOOTH_AUTO:
              root::nsIPresShell__bindgen_ty_2 =
        nsIPresShell__bindgen_ty_2::SCROLL_SMOOTH_AUTO;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell__bindgen_ty_2 {
        SCROLL_FIRST_ANCESTOR_ONLY = 1,
        SCROLL_OVERFLOW_HIDDEN = 2,
        SCROLL_NO_PARENT_FRAMES = 4,
        SCROLL_SMOOTH = 8,
        SCROLL_SMOOTH_AUTO = 16,
    }
    pub const nsIPresShell_RENDER_IS_UNTRUSTED:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_IS_UNTRUSTED;
    pub const nsIPresShell_RENDER_IGNORE_VIEWPORT_SCROLLING:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_IGNORE_VIEWPORT_SCROLLING;
    pub const nsIPresShell_RENDER_CARET: root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_CARET;
    pub const nsIPresShell_RENDER_USE_WIDGET_LAYERS:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_USE_WIDGET_LAYERS;
    pub const nsIPresShell_RENDER_ASYNC_DECODE_IMAGES:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_ASYNC_DECODE_IMAGES;
    pub const nsIPresShell_RENDER_DOCUMENT_RELATIVE:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_DOCUMENT_RELATIVE;
    pub const nsIPresShell_RENDER_DRAWWINDOW_NOT_FLUSHING:
              root::nsIPresShell__bindgen_ty_3 =
        nsIPresShell__bindgen_ty_3::RENDER_DRAWWINDOW_NOT_FLUSHING;
    #[repr(u32)]
    /**
   * Render the document into an arbitrary gfxContext
   * Designed for getting a picture of a document or a piece of a document
   * Note that callers will generally want to call FlushPendingNotifications
   * to get an up-to-date view of the document
   * @param aRect is the region to capture into the offscreen buffer, in the
   * root frame's coordinate system (if aIgnoreViewportScrolling is false)
   * or in the root scrolled frame's coordinate system
   * (if aIgnoreViewportScrolling is true). The coordinates are in appunits.
   * @param aFlags see below;
   *   set RENDER_IS_UNTRUSTED if the contents may be passed to malicious
   * agents. E.g. we might choose not to paint the contents of sensitive widgets
   * such as the file name in a file upload widget, and we might choose not
   * to paint themes.
   *   set RENDER_IGNORE_VIEWPORT_SCROLLING to ignore
   * clipping and scrollbar painting due to scrolling in the viewport
   *   set RENDER_CARET to draw the caret if one would be visible
   * (by default the caret is never drawn)
   *   set RENDER_USE_LAYER_MANAGER to force rendering to go through
   * the layer manager for the window. This may be unexpectedly slow
   * (if the layer manager must read back data from the GPU) or low-quality
   * (if the layer manager reads back pixel data and scales it
   * instead of rendering using the appropriate scaling). It may also
   * slow everything down if the area rendered does not correspond to the
   * normal visible area of the window.
   *   set RENDER_ASYNC_DECODE_IMAGES to avoid having images synchronously
   * decoded during rendering.
   * (by default images decode synchronously with RenderDocument)
   *   set RENDER_DOCUMENT_RELATIVE to render the document as if there has been
   * no scrolling and interpret |aRect| relative to the document instead of the
   * CSS viewport. Only considered if RENDER_IGNORE_VIEWPORT_SCROLLING is set
   * or the document is in ignore viewport scrolling mode
   * (nsIPresShell::SetIgnoreViewportScrolling/IgnoringViewportScrolling).
   * @param aBackgroundColor a background color to render onto
   * @param aRenderedContext the gfxContext to render to. We render so that
   * one CSS pixel in the source document is rendered to one unit in the current
   * transform.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell__bindgen_ty_3 {
        RENDER_IS_UNTRUSTED = 1,
        RENDER_IGNORE_VIEWPORT_SCROLLING = 2,
        RENDER_CARET = 4,
        RENDER_USE_WIDGET_LAYERS = 8,
        RENDER_ASYNC_DECODE_IMAGES = 16,
        RENDER_DOCUMENT_RELATIVE = 32,
        RENDER_DRAWWINDOW_NOT_FLUSHING = 64,
    }
    pub const nsIPresShell_RENDER_IS_IMAGE: root::nsIPresShell__bindgen_ty_4 =
        nsIPresShell__bindgen_ty_4::RENDER_IS_IMAGE;
    pub const nsIPresShell_RENDER_AUTO_SCALE: root::nsIPresShell__bindgen_ty_4
              =
        nsIPresShell__bindgen_ty_4::RENDER_AUTO_SCALE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell__bindgen_ty_4 {
        RENDER_IS_IMAGE = 256,
        RENDER_AUTO_SCALE = 128,
    }
    pub const nsIPresShell_FORCE_DRAW: root::nsIPresShell__bindgen_ty_5 =
        nsIPresShell__bindgen_ty_5::FORCE_DRAW;
    #[repr(u32)]
    /**
   * Add a solid color item to the bottom of aList with frame aFrame and bounds
   * aBounds. Checks first if this needs to be done by checking if aFrame is a
   * canvas frame (if the FORCE_DRAW flag is passed then this check is skipped).
   * aBackstopColor is composed behind the background color of the canvas, it is
   * transparent by default.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell__bindgen_ty_5 { FORCE_DRAW = 1, }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIPresShell_PointerCaptureInfo {
        pub mPendingContent: root::nsCOMPtr<root::nsIContent>,
        pub mOverrideContent: root::nsCOMPtr<root::nsIContent>,
    }
    #[test]
    fn bindgen_test_layout_nsIPresShell_PointerCaptureInfo() {
        assert_eq!(::std::mem::size_of::<nsIPresShell_PointerCaptureInfo>() ,
                   16usize);
        assert_eq!(::std::mem::align_of::<nsIPresShell_PointerCaptureInfo>() ,
                   8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIPresShell_PointerInfo {
        pub mPointerType: u16,
        pub mActiveState: bool,
        pub mPrimaryState: bool,
        pub mPreventMouseEventByContent: bool,
    }
    #[test]
    fn bindgen_test_layout_nsIPresShell_PointerInfo() {
        assert_eq!(::std::mem::size_of::<nsIPresShell_PointerInfo>() ,
                   6usize);
        assert_eq!(::std::mem::align_of::<nsIPresShell_PointerInfo>() ,
                   2usize);
    }
    impl Clone for nsIPresShell_PointerInfo {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_PaintFlags {
        PAINT_LAYERS = 1,
        PAINT_COMPOSITE = 2,
        PAINT_SYNC_DECODE_IMAGES = 4,
    }
    #[repr(u32)]
    /**
   * Ensures that the refresh driver is running, and schedules a view
   * manager flush on the next tick.
   *
   * @param aType PAINT_DELAYED_COMPRESS : Schedule a paint to be executed after a delay, and
   * put FrameLayerBuilder in 'compressed' mode that avoids short cut optimizations.
   */
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsIPresShell_PaintType {
        PAINT_DEFAULT = 0,
        PAINT_DELAYED_COMPRESS = 1,
    }
    extern "C" {
        #[link_name = "_ZN12nsIPresShell12gCaptureInfoE"]
        pub static mut nsIPresShell_gCaptureInfo: root::CapturingContentInfo;
    }
    extern "C" {
        #[link_name = "_ZN12nsIPresShell14gKeyDownTargetE"]
        pub static mut nsIPresShell_gKeyDownTarget: *mut root::nsIContent;
    }
    #[test]
    fn bindgen_test_layout_nsIPresShell() {
        assert_eq!(::std::mem::size_of::<nsIPresShell>() , 344usize);
        assert_eq!(::std::mem::align_of::<nsIPresShell>() , 8usize);
    }
    impl nsIPresShell {
        #[inline]
        pub fn mStylesHaveChanged(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                           0u32) as u8)
            }
        }
        #[inline]
        pub fn set_mStylesHaveChanged(&mut self, val: bool) {
            self._bitfield_1 &= !(1usize as u16);
            self._bitfield_1 |=
                ((val as u8 as u16) << 0u32) & (1usize as u16);
        }
        #[inline]
        pub fn mDidInitialize(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                           1u32) as u8)
            }
        }
        #[inline]
        pub fn set_mDidInitialize(&mut self, val: bool) {
            self._bitfield_1 &= !(2usize as u16);
            self._bitfield_1 |=
                ((val as u8 as u16) << 1u32) & (2usize as u16);
        }
        #[inline]
        pub fn mIsDestroying(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                           2u32) as u8)
            }
        }
        #[inline]
        pub fn set_mIsDestroying(&mut self, val: bool) {
            self._bitfield_1 &= !(4usize as u16);
            self._bitfield_1 |=
                ((val as u8 as u16) << 2u32) & (4usize as u16);
        }
        #[inline]
        pub fn mIsReflowing(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                           3u32) as u8)
            }
        }
        #[inline]
        pub fn set_mIsReflowing(&mut self, val: bool) {
            self._bitfield_1 &= !(8usize as u16);
            self._bitfield_1 |=
                ((val as u8 as u16) << 3u32) & (8usize as u16);
        }
        #[inline]
        pub fn mPaintingSuppressed(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (16usize as u16))
                                           >> 4u32) as u8)
            }
        }
        #[inline]
        pub fn set_mPaintingSuppressed(&mut self, val: bool) {
            self._bitfield_1 &= !(16usize as u16);
            self._bitfield_1 |=
                ((val as u8 as u16) << 4u32) & (16usize as u16);
        }
        #[inline]
        pub fn mIsThemeSupportDisabled(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (32usize as u16))
                                           >> 5u32) as u8)
            }
        }
        #[inline]
        pub fn set_mIsThemeSupportDisabled(&mut self, val: bool) {
            self._bitfield_1 &= !(32usize as u16);
            self._bitfield_1 |=
                ((val as u8 as u16) << 5u32) & (32usize as u16);
        }
        #[inline]
        pub fn mIsActive(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (64usize as u16))
                                           >> 6u32) as u8)
            }
        }
        #[inline]
        pub fn set_mIsActive(&mut self, val: bool) {
            self._bitfield_1 &= !(64usize as u16);
            self._bitfield_1 |=
                ((val as u8 as u16) << 6u32) & (64usize as u16);
        }
        #[inline]
        pub fn mFrozen(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (128usize as u16))
                                           >> 7u32) as u8)
            }
        }
        #[inline]
        pub fn set_mFrozen(&mut self, val: bool) {
            self._bitfield_1 &= !(128usize as u16);
            self._bitfield_1 |=
                ((val as u8 as u16) << 7u32) & (128usize as u16);
        }
        #[inline]
        pub fn mIsFirstPaint(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (256usize as u16))
                                           >> 8u32) as u8)
            }
        }
        #[inline]
        pub fn set_mIsFirstPaint(&mut self, val: bool) {
            self._bitfield_1 &= !(256usize as u16);
            self._bitfield_1 |=
                ((val as u8 as u16) << 8u32) & (256usize as u16);
        }
        #[inline]
        pub fn mObservesMutationsForPrint(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (512usize as u16))
                                           >> 9u32) as u8)
            }
        }
        #[inline]
        pub fn set_mObservesMutationsForPrint(&mut self, val: bool) {
            self._bitfield_1 &= !(512usize as u16);
            self._bitfield_1 |=
                ((val as u8 as u16) << 9u32) & (512usize as u16);
        }
        #[inline]
        pub fn mReflowScheduled(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (1024usize as u16))
                                           >> 10u32) as u8)
            }
        }
        #[inline]
        pub fn set_mReflowScheduled(&mut self, val: bool) {
            self._bitfield_1 &= !(1024usize as u16);
            self._bitfield_1 |=
                ((val as u8 as u16) << 10u32) & (1024usize as u16);
        }
        #[inline]
        pub fn mSuppressInterruptibleReflows(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (2048usize as u16))
                                           >> 11u32) as u8)
            }
        }
        #[inline]
        pub fn set_mSuppressInterruptibleReflows(&mut self, val: bool) {
            self._bitfield_1 &= !(2048usize as u16);
            self._bitfield_1 |=
                ((val as u8 as u16) << 11u32) & (2048usize as u16);
        }
        #[inline]
        pub fn mScrollPositionClampingScrollPortSizeSet(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (4096usize as u16))
                                           >> 12u32) as u8)
            }
        }
        #[inline]
        pub fn set_mScrollPositionClampingScrollPortSizeSet(&mut self,
                                                            val: bool) {
            self._bitfield_1 &= !(4096usize as u16);
            self._bitfield_1 |=
                ((val as u8 as u16) << 12u32) & (4096usize as u16);
        }
    }
    /**
 * A class that implements nsIWeakReference
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsNodeWeakReference {
        pub _base: root::nsIWeakReference,
        pub mRefCnt: root::nsAutoRefCnt,
        pub mNode: *mut root::nsINode,
    }
    pub type nsNodeWeakReference_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsNodeWeakReference() {
        assert_eq!(::std::mem::size_of::<nsNodeWeakReference>() , 24usize);
        assert_eq!(::std::mem::align_of::<nsNodeWeakReference>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsDOMMutationObserver {
        pub _address: u8,
    }
    impl Clone for nsDOMMutationObserver {
        fn clone(&self) -> Self { *self }
    }
    pub const NODE_HAS_LISTENERMANAGER: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_HAS_LISTENERMANAGER;
    pub const NODE_HAS_PROPERTIES: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_HAS_PROPERTIES;
    pub const NODE_IS_ANONYMOUS_ROOT: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_IS_ANONYMOUS_ROOT;
    pub const NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE;
    pub const NODE_IS_NATIVE_ANONYMOUS_ROOT: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_IS_NATIVE_ANONYMOUS_ROOT;
    pub const NODE_FORCE_XBL_BINDINGS: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_FORCE_XBL_BINDINGS;
    pub const NODE_MAY_BE_IN_BINDING_MNGR: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_MAY_BE_IN_BINDING_MNGR;
    pub const NODE_IS_EDITABLE: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_IS_EDITABLE;
    pub const NODE_MAY_HAVE_CLASS: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_MAY_HAVE_CLASS;
    pub const NODE_IS_IN_SHADOW_TREE: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_IS_IN_SHADOW_TREE;
    pub const NODE_HAS_EMPTY_SELECTOR: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_HAS_EMPTY_SELECTOR;
    pub const NODE_HAS_SLOW_SELECTOR: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_HAS_SLOW_SELECTOR;
    pub const NODE_HAS_EDGE_CHILD_SELECTOR: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_HAS_EDGE_CHILD_SELECTOR;
    pub const NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS;
    pub const NODE_ALL_SELECTOR_FLAGS: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_ALL_SELECTOR_FLAGS;
    pub const NODE_NEEDS_FRAME: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_NEEDS_FRAME;
    pub const NODE_DESCENDANTS_NEED_FRAMES: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_DESCENDANTS_NEED_FRAMES;
    pub const NODE_HAS_ACCESSKEY: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_HAS_ACCESSKEY;
    pub const NODE_HAS_DIRECTION_RTL: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_HAS_DIRECTION_RTL;
    pub const NODE_HAS_DIRECTION_LTR: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_HAS_DIRECTION_LTR;
    pub const NODE_ALL_DIRECTION_FLAGS: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_ALL_DIRECTION_FLAGS;
    pub const NODE_CHROME_ONLY_ACCESS: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_CHROME_ONLY_ACCESS;
    pub const NODE_IS_ROOT_OF_CHROME_ONLY_ACCESS: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_IS_ROOT_OF_CHROME_ONLY_ACCESS;
    pub const NODE_SHARED_RESTYLE_BIT_1: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_SHARED_RESTYLE_BIT_1;
    pub const NODE_SHARED_RESTYLE_BIT_2: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_SHARED_RESTYLE_BIT_2;
    pub const NODE_HAS_DIRTY_DESCENDANTS_FOR_SERVO: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_SHARED_RESTYLE_BIT_1;
    pub const NODE_TYPE_SPECIFIC_BITS_OFFSET: root::_bindgen_ty_136 =
        _bindgen_ty_136::NODE_TYPE_SPECIFIC_BITS_OFFSET;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum _bindgen_ty_136 {
        NODE_HAS_LISTENERMANAGER = 4,
        NODE_HAS_PROPERTIES = 8,
        NODE_IS_ANONYMOUS_ROOT = 16,
        NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE = 32,
        NODE_IS_NATIVE_ANONYMOUS_ROOT = 64,
        NODE_FORCE_XBL_BINDINGS = 128,
        NODE_MAY_BE_IN_BINDING_MNGR = 256,
        NODE_IS_EDITABLE = 512,
        NODE_MAY_HAVE_CLASS = 1024,
        NODE_IS_IN_SHADOW_TREE = 2048,
        NODE_HAS_EMPTY_SELECTOR = 4096,
        NODE_HAS_SLOW_SELECTOR = 8192,
        NODE_HAS_EDGE_CHILD_SELECTOR = 16384,
        NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS = 32768,
        NODE_ALL_SELECTOR_FLAGS = 61440,
        NODE_NEEDS_FRAME = 65536,
        NODE_DESCENDANTS_NEED_FRAMES = 131072,
        NODE_HAS_ACCESSKEY = 262144,
        NODE_HAS_DIRECTION_RTL = 524288,
        NODE_HAS_DIRECTION_LTR = 1048576,
        NODE_ALL_DIRECTION_FLAGS = 1572864,
        NODE_CHROME_ONLY_ACCESS = 2097152,
        NODE_IS_ROOT_OF_CHROME_ONLY_ACCESS = 4194304,
        NODE_SHARED_RESTYLE_BIT_1 = 8388608,
        NODE_SHARED_RESTYLE_BIT_2 = 16777216,
        NODE_TYPE_SPECIFIC_BITS_OFFSET = 23,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsContentList {
        pub _address: u8,
    }
    impl Clone for nsContentList {
        fn clone(&self) -> Self { *self }
    }
    /**
 * The signature of the timer callback function passed to initWithFuncCallback.
 * This is the function that will get called when the timer expires if the
 * timer is initialized via initWithFuncCallback.
 *
 * @param aTimer the timer which has expired
 * @param aClosure opaque parameter passed to initWithFuncCallback
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsITimer {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsITimer_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const nsITimer_TYPE_ONE_SHOT: root::nsITimer__bindgen_ty_1 =
        nsITimer__bindgen_ty_1::TYPE_ONE_SHOT;
    pub const nsITimer_TYPE_REPEATING_SLACK: root::nsITimer__bindgen_ty_1 =
        nsITimer__bindgen_ty_1::TYPE_REPEATING_SLACK;
    pub const nsITimer_TYPE_REPEATING_PRECISE: root::nsITimer__bindgen_ty_1 =
        nsITimer__bindgen_ty_1::TYPE_REPEATING_PRECISE;
    pub const nsITimer_TYPE_REPEATING_PRECISE_CAN_SKIP:
              root::nsITimer__bindgen_ty_1 =
        nsITimer__bindgen_ty_1::TYPE_REPEATING_PRECISE_CAN_SKIP;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsITimer__bindgen_ty_1 {
        TYPE_ONE_SHOT = 0,
        TYPE_REPEATING_SLACK = 1,
        TYPE_REPEATING_PRECISE = 2,
        TYPE_REPEATING_PRECISE_CAN_SKIP = 3,
    }
    #[test]
    fn bindgen_test_layout_nsITimer() {
        assert_eq!(::std::mem::size_of::<nsITimer>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsITimer>() , 8usize);
    }
    impl Clone for nsITimer {
        fn clone(&self) -> Self { *self }
    }
    /**
 * Data used to track the expiration state of an object. We promise that this
 * is 32 bits so that objects that includes this as a field can pad and align
 * efficiently.
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsExpirationState {
        pub _bitfield_1: u32,
    }
    pub const nsExpirationState_NOT_TRACKED:
              root::nsExpirationState__bindgen_ty_1 =
        nsExpirationState__bindgen_ty_1::NOT_TRACKED;
    pub const nsExpirationState_MAX_INDEX_IN_GENERATION:
              root::nsExpirationState__bindgen_ty_1 =
        nsExpirationState__bindgen_ty_1::MAX_INDEX_IN_GENERATION;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsExpirationState__bindgen_ty_1 {
        NOT_TRACKED = 15,
        MAX_INDEX_IN_GENERATION = 268435455,
    }
    #[test]
    fn bindgen_test_layout_nsExpirationState() {
        assert_eq!(::std::mem::size_of::<nsExpirationState>() , 4usize);
        assert_eq!(::std::mem::align_of::<nsExpirationState>() , 4usize);
    }
    impl Clone for nsExpirationState {
        fn clone(&self) -> Self { *self }
    }
    impl nsExpirationState {
        #[inline]
        pub fn mGeneration(&self) -> u32 {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (15usize as u32))
                                           >> 0u32) as u32)
            }
        }
        #[inline]
        pub fn set_mGeneration(&mut self, val: u32) {
            self._bitfield_1 &= !(15usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 0u32) & (15usize as u32);
        }
        #[inline]
        pub fn mIndexInGeneration(&self) -> u32 {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 &
                                            (4294967280usize as u32)) >> 4u32)
                                          as u32)
            }
        }
        #[inline]
        pub fn set_mIndexInGeneration(&mut self, val: u32) {
            self._bitfield_1 &= !(4294967280usize as u32);
            self._bitfield_1 |=
                ((val as u32 as u32) << 4u32) & (4294967280usize as u32);
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PRCListStr {
        pub next: *mut root::PRCList,
        pub prev: *mut root::PRCList,
    }
    #[test]
    fn bindgen_test_layout_PRCListStr() {
        assert_eq!(::std::mem::size_of::<PRCListStr>() , 16usize);
        assert_eq!(::std::mem::align_of::<PRCListStr>() , 8usize);
    }
    impl Clone for PRCListStr {
        fn clone(&self) -> Self { *self }
    }
    pub type PRCList = root::PRCListStr;
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct imgIRequest {
        pub _base: root::nsIRequest,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct imgIRequest_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const imgIRequest_STATUS_NONE: root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_NONE;
    pub const imgIRequest_STATUS_SIZE_AVAILABLE:
              root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_SIZE_AVAILABLE;
    pub const imgIRequest_STATUS_LOAD_COMPLETE:
              root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_LOAD_COMPLETE;
    pub const imgIRequest_STATUS_ERROR: root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_ERROR;
    pub const imgIRequest_STATUS_FRAME_COMPLETE:
              root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_FRAME_COMPLETE;
    pub const imgIRequest_STATUS_DECODE_COMPLETE:
              root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_DECODE_COMPLETE;
    pub const imgIRequest_STATUS_IS_ANIMATED: root::imgIRequest__bindgen_ty_1
              =
        imgIRequest__bindgen_ty_1::STATUS_IS_ANIMATED;
    pub const imgIRequest_STATUS_HAS_TRANSPARENCY:
              root::imgIRequest__bindgen_ty_1 =
        imgIRequest__bindgen_ty_1::STATUS_HAS_TRANSPARENCY;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum imgIRequest__bindgen_ty_1 {
        STATUS_NONE = 0,
        STATUS_SIZE_AVAILABLE = 1,
        STATUS_LOAD_COMPLETE = 2,
        STATUS_ERROR = 4,
        STATUS_FRAME_COMPLETE = 8,
        STATUS_DECODE_COMPLETE = 16,
        STATUS_IS_ANIMATED = 32,
        STATUS_HAS_TRANSPARENCY = 64,
    }
    pub const imgIRequest_CORS_NONE: root::imgIRequest__bindgen_ty_2 =
        imgIRequest__bindgen_ty_2::CORS_NONE;
    pub const imgIRequest_CORS_ANONYMOUS: root::imgIRequest__bindgen_ty_2 =
        imgIRequest__bindgen_ty_2::CORS_ANONYMOUS;
    pub const imgIRequest_CORS_USE_CREDENTIALS:
              root::imgIRequest__bindgen_ty_2 =
        imgIRequest__bindgen_ty_2::CORS_USE_CREDENTIALS;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum imgIRequest__bindgen_ty_2 {
        CORS_NONE = 1,
        CORS_ANONYMOUS = 2,
        CORS_USE_CREDENTIALS = 3,
    }
    #[test]
    fn bindgen_test_layout_imgIRequest() {
        assert_eq!(::std::mem::size_of::<imgIRequest>() , 8usize);
        assert_eq!(::std::mem::align_of::<imgIRequest>() , 8usize);
    }
    impl Clone for imgIRequest {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsHTMLCSSStyleSheet {
        pub _address: u8,
    }
    impl Clone for nsHTMLCSSStyleSheet {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsHTMLStyleSheet {
        pub _address: u8,
    }
    impl Clone for nsHTMLStyleSheet {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIBFCacheEntry {
        pub _address: u8,
    }
    impl Clone for nsIBFCacheEntry {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDocumentEncoder {
        pub _address: u8,
    }
    impl Clone for nsIDocumentEncoder {
        fn clone(&self) -> Self { *self }
    }
    /**
 * An internal interface
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIHTMLCollection {
        pub _base: root::nsIDOMHTMLCollection,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIHTMLCollection_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIHTMLCollection() {
        assert_eq!(::std::mem::size_of::<nsIHTMLCollection>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsIHTMLCollection>() , 8usize);
    }
    impl Clone for nsIHTMLCollection {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIObjectLoadingContent {
        pub _address: u8,
    }
    impl Clone for nsIObjectLoadingContent {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIStructuredCloneContainer {
        pub _address: u8,
    }
    impl Clone for nsIStructuredCloneContainer {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsViewManager {
        pub _address: u8,
    }
    impl Clone for nsViewManager {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsSMILAnimationController {
        pub _address: u8,
    }
    impl Clone for nsSMILAnimationController {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsAttrName {
        pub mBits: usize,
    }
    #[test]
    fn bindgen_test_layout_nsAttrName() {
        assert_eq!(::std::mem::size_of::<nsAttrName>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsAttrName>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCSSSelector {
        pub _address: u8,
    }
    impl Clone for nsCSSSelector {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsMappedAttributes {
        pub _address: u8,
    }
    impl Clone for nsMappedAttributes {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsXBLBinding {
        pub _address: u8,
    }
    impl Clone for nsXBLBinding {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsDOMTokenList {
        pub _address: u8,
    }
    impl Clone for nsDOMTokenList {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsDOMStringMap {
        pub _address: u8,
    }
    impl Clone for nsDOMStringMap {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIDOMMozNamedAttrMap {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIDOMMozNamedAttrMap_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIDOMMozNamedAttrMap() {
        assert_eq!(::std::mem::size_of::<nsIDOMMozNamedAttrMap>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsIDOMMozNamedAttrMap>() , 8usize);
    }
    impl Clone for nsIDOMMozNamedAttrMap {
        fn clone(&self) -> Self { *self }
    }
    /**
 * Interface used for handling clicks on links
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsILinkHandler {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsILinkHandler_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsILinkHandler() {
        assert_eq!(::std::mem::size_of::<nsILinkHandler>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsILinkHandler>() , 8usize);
    }
    impl Clone for nsILinkHandler {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsIAttribute {
        pub _base: root::nsINode,
        pub mAttrMap: root::RefPtr<root::nsDOMAttributeMap>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsIAttribute_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsIAttribute() {
        assert_eq!(::std::mem::size_of::<nsIAttribute>() , 104usize);
        assert_eq!(::std::mem::align_of::<nsIAttribute>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleContext {
        pub _address: u8,
    }
    impl Clone for nsStyleContext {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsFrameManagerBase {
        pub mPresShell: *mut root::nsIPresShell,
        pub mRootFrame: *mut root::nsIFrame,
        pub mPlaceholderMap: root::PLDHashTable,
        pub mUndisplayedMap: *mut root::nsFrameManagerBase_UndisplayedMap,
        pub mDisplayContentsMap: *mut root::nsFrameManagerBase_UndisplayedMap,
        pub mIsDestroyingFrames: bool,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsFrameManagerBase_UndisplayedMap {
        pub _address: u8,
    }
    impl Clone for nsFrameManagerBase_UndisplayedMap {
        fn clone(&self) -> Self { *self }
    }
    extern "C" {
        #[link_name = "_ZN18nsFrameManagerBase23sGlobalGenerationNumberE"]
        pub static mut nsFrameManagerBase_sGlobalGenerationNumber: u32;
    }
    #[test]
    fn bindgen_test_layout_nsFrameManagerBase() {
        assert_eq!(::std::mem::size_of::<nsFrameManagerBase>() , 80usize);
        assert_eq!(::std::mem::align_of::<nsFrameManagerBase>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPresArena {
        pub mFreeLists: [u64; 5usize],
        pub mPool: root::PLArenaPool,
        pub mArenaRefPtrs: [u64; 5usize],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsPresArena_FreeList {
        pub _base: root::PLDHashEntryHdr,
        pub mEntries: root::nsTArray<*mut ::std::os::raw::c_void>,
        pub mEntrySize: usize,
        pub mEntriesEverAllocated: usize,
        pub mKey: root::nsPresArena_FreeList_KeyTypePointer,
    }
    pub type nsPresArena_FreeList_KeyType = u32;
    pub type nsPresArena_FreeList_KeyTypePointer =
        *const ::std::os::raw::c_void;
    pub const nsPresArena_FreeList_ALLOW_MEMMOVE:
              root::nsPresArena_FreeList__bindgen_ty_1 =
        nsPresArena_FreeList__bindgen_ty_1::ALLOW_MEMMOVE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsPresArena_FreeList__bindgen_ty_1 { ALLOW_MEMMOVE = 0, }
    #[test]
    fn bindgen_test_layout_nsPresArena_FreeList() {
        assert_eq!(::std::mem::size_of::<nsPresArena_FreeList>() , 40usize);
        assert_eq!(::std::mem::align_of::<nsPresArena_FreeList>() , 8usize);
    }
    #[test]
    fn bindgen_test_layout_nsPresArena() {
        assert_eq!(::std::mem::size_of::<nsPresArena>() , 136usize);
        assert_eq!(::std::mem::align_of::<nsPresArena>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLArena {
        pub next: *mut root::PLArena,
        pub base: root::PRUword,
        pub limit: root::PRUword,
        pub avail: root::PRUword,
    }
    #[test]
    fn bindgen_test_layout_PLArena() {
        assert_eq!(::std::mem::size_of::<PLArena>() , 32usize);
        assert_eq!(::std::mem::align_of::<PLArena>() , 8usize);
    }
    impl Clone for PLArena {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct PLArenaPool {
        pub first: root::PLArena,
        pub current: *mut root::PLArena,
        pub arenasize: root::PRUint32,
        pub mask: root::PRUword,
    }
    #[test]
    fn bindgen_test_layout_PLArenaPool() {
        assert_eq!(::std::mem::size_of::<PLArenaPool>() , 56usize);
        assert_eq!(::std::mem::align_of::<PLArenaPool>() , 8usize);
    }
    impl Clone for PLArenaPool {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct imgINotificationObserver {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct imgINotificationObserver_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const imgINotificationObserver_SIZE_AVAILABLE:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::SIZE_AVAILABLE;
    pub const imgINotificationObserver_FRAME_UPDATE:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::FRAME_UPDATE;
    pub const imgINotificationObserver_FRAME_COMPLETE:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::FRAME_COMPLETE;
    pub const imgINotificationObserver_LOAD_COMPLETE:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::LOAD_COMPLETE;
    pub const imgINotificationObserver_DECODE_COMPLETE:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::DECODE_COMPLETE;
    pub const imgINotificationObserver_DISCARD:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::DISCARD;
    pub const imgINotificationObserver_UNLOCKED_DRAW:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::UNLOCKED_DRAW;
    pub const imgINotificationObserver_IS_ANIMATED:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::IS_ANIMATED;
    pub const imgINotificationObserver_HAS_TRANSPARENCY:
              root::imgINotificationObserver__bindgen_ty_1 =
        imgINotificationObserver__bindgen_ty_1::HAS_TRANSPARENCY;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum imgINotificationObserver__bindgen_ty_1 {
        SIZE_AVAILABLE = 1,
        FRAME_UPDATE = 2,
        FRAME_COMPLETE = 3,
        LOAD_COMPLETE = 4,
        DECODE_COMPLETE = 5,
        DISCARD = 6,
        UNLOCKED_DRAW = 7,
        IS_ANIMATED = 8,
        HAS_TRANSPARENCY = 9,
    }
    #[test]
    fn bindgen_test_layout_imgINotificationObserver() {
        assert_eq!(::std::mem::size_of::<imgINotificationObserver>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<imgINotificationObserver>() ,
                   8usize);
    }
    impl Clone for imgINotificationObserver {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsFrameSelection {
        pub _address: u8,
    }
    impl Clone for nsFrameSelection {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCSSFrameConstructor {
        pub _address: u8,
    }
    impl Clone for nsCSSFrameConstructor {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsWeakFrame {
        pub _address: u8,
    }
    impl Clone for nsWeakFrame {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct ScrollbarStyles {
        pub mHorizontal: u8,
        pub mVertical: u8,
        pub mScrollBehavior: u8,
        pub mScrollSnapTypeX: u8,
        pub mScrollSnapTypeY: u8,
        pub mScrollSnapPointsX: root::nsStyleCoord,
        pub mScrollSnapPointsY: root::nsStyleCoord,
        pub mScrollSnapDestinationX: root::nsStyleCoord_CalcValue,
        pub mScrollSnapDestinationY: root::nsStyleCoord_CalcValue,
    }
    #[test]
    fn bindgen_test_layout_ScrollbarStyles() {
        assert_eq!(::std::mem::size_of::<ScrollbarStyles>() , 64usize);
        assert_eq!(::std::mem::align_of::<ScrollbarStyles>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsRefreshDriver {
        pub _address: u8,
    }
    impl Clone for nsRefreshDriver {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct CapturingContentInfo {
        pub mAllowed: bool,
        pub mPointerLock: bool,
        pub mRetargetToElement: bool,
        pub mPreventDrag: bool,
        pub mContent: root::mozilla::StaticRefPtr<root::nsIContent>,
    }
    #[test]
    fn bindgen_test_layout_CapturingContentInfo() {
        assert_eq!(::std::mem::size_of::<CapturingContentInfo>() , 16usize);
        assert_eq!(::std::mem::align_of::<CapturingContentInfo>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct gfxFontFeature {
        pub mTag: u32,
        pub mValue: u32,
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeature() {
        assert_eq!(::std::mem::size_of::<gfxFontFeature>() , 8usize);
        assert_eq!(::std::mem::align_of::<gfxFontFeature>() , 4usize);
    }
    impl Clone for gfxFontFeature {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxAlternateValue {
        pub alternate: u32,
        pub value: ::nsstring::nsStringRepr,
    }
    #[test]
    fn bindgen_test_layout_gfxAlternateValue() {
        assert_eq!(::std::mem::size_of::<gfxAlternateValue>() , 24usize);
        assert_eq!(::std::mem::align_of::<gfxAlternateValue>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxFontFeatureValueSet {
        pub mRefCnt: root::nsAutoRefCnt,
        pub mFontFeatureValues: [u64; 5usize],
    }
    pub type gfxFontFeatureValueSet_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxFontFeatureValueSet_ValueList {
        pub name: ::nsstring::nsStringRepr,
        pub featureSelectors: root::nsTArray<::std::os::raw::c_uint>,
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeatureValueSet_ValueList() {
        assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet_ValueList>() ,
                   24usize);
        assert_eq!(::std::mem::align_of::<gfxFontFeatureValueSet_ValueList>()
                   , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxFontFeatureValueSet_FeatureValues {
        pub alternate: u32,
        pub valuelist: root::nsTArray<root::gfxFontFeatureValueSet_ValueList>,
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeatureValueSet_FeatureValues() {
        assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet_FeatureValues>()
                   , 16usize);
        assert_eq!(::std::mem::align_of::<gfxFontFeatureValueSet_FeatureValues>()
                   , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxFontFeatureValueSet_FeatureValueHashKey {
        pub mFamily: ::nsstring::nsStringRepr,
        pub mPropVal: u32,
        pub mName: ::nsstring::nsStringRepr,
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeatureValueSet_FeatureValueHashKey() {
        assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet_FeatureValueHashKey>()
                   , 40usize);
        assert_eq!(::std::mem::align_of::<gfxFontFeatureValueSet_FeatureValueHashKey>()
                   , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct gfxFontFeatureValueSet_FeatureValueHashEntry {
        pub _base: root::PLDHashEntryHdr,
        pub mKey: root::gfxFontFeatureValueSet_FeatureValueHashKey,
        pub mValues: root::nsTArray<::std::os::raw::c_uint>,
    }
    pub type gfxFontFeatureValueSet_FeatureValueHashEntry_KeyType =
        *const root::gfxFontFeatureValueSet_FeatureValueHashKey;
    pub type gfxFontFeatureValueSet_FeatureValueHashEntry_KeyTypePointer =
        *const root::gfxFontFeatureValueSet_FeatureValueHashKey;
    pub const gfxFontFeatureValueSet_FeatureValueHashEntry_ALLOW_MEMMOVE:
              root::gfxFontFeatureValueSet_FeatureValueHashEntry__bindgen_ty_1
              =
        gfxFontFeatureValueSet_FeatureValueHashEntry__bindgen_ty_1::ALLOW_MEMMOVE;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum gfxFontFeatureValueSet_FeatureValueHashEntry__bindgen_ty_1 {
        ALLOW_MEMMOVE = 1,
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeatureValueSet_FeatureValueHashEntry() {
        assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet_FeatureValueHashEntry>()
                   , 56usize);
        assert_eq!(::std::mem::align_of::<gfxFontFeatureValueSet_FeatureValueHashEntry>()
                   , 8usize);
    }
    #[test]
    fn bindgen_test_layout_gfxFontFeatureValueSet() {
        assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet>() , 48usize);
        assert_eq!(::std::mem::align_of::<gfxFontFeatureValueSet>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct gfxFontVariation {
        pub mTag: u32,
        pub mValue: f32,
    }
    #[test]
    fn bindgen_test_layout_gfxFontVariation() {
        assert_eq!(::std::mem::size_of::<gfxFontVariation>() , 8usize);
        assert_eq!(::std::mem::align_of::<gfxFontVariation>() , 4usize);
    }
    impl Clone for gfxFontVariation {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsFont {
        pub fontlist: root::mozilla::FontFamilyList,
        pub style: u8,
        pub systemFont: bool,
        pub variantCaps: u8,
        pub variantNumeric: u8,
        pub variantPosition: u8,
        pub variantWidth: u8,
        pub variantLigatures: u16,
        pub variantEastAsian: u16,
        pub variantAlternates: u16,
        pub smoothing: u8,
        pub weight: u16,
        pub stretch: i16,
        pub kerning: u8,
        pub synthesis: u8,
        pub size: root::nscoord,
        pub sizeAdjust: f32,
        pub alternateValues: root::nsTArray<root::gfxAlternateValue>,
        pub featureValueLookup: root::RefPtr<root::gfxFontFeatureValueSet>,
        pub fontFeatureSettings: root::nsTArray<root::gfxFontFeature>,
        pub fontVariationSettings: root::nsTArray<root::gfxFontVariation>,
        pub languageOverride: ::nsstring::nsStringRepr,
    }
    #[test]
    fn bindgen_test_layout_nsFont() {
        assert_eq!(::std::mem::size_of::<nsFont>() , 96usize);
        assert_eq!(::std::mem::align_of::<nsFont>() , 8usize);
    }
    pub const nsStyleUnit_eStyleUnit_MAX: root::nsStyleUnit =
        nsStyleUnit::eStyleUnit_Calc;
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleUnit {
        eStyleUnit_Null = 0,
        eStyleUnit_Normal = 1,
        eStyleUnit_Auto = 2,
        eStyleUnit_None = 3,
        eStyleUnit_Percent = 10,
        eStyleUnit_Factor = 11,
        eStyleUnit_Degree = 12,
        eStyleUnit_Grad = 13,
        eStyleUnit_Radian = 14,
        eStyleUnit_Turn = 15,
        eStyleUnit_FlexFraction = 16,
        eStyleUnit_Coord = 20,
        eStyleUnit_Integer = 30,
        eStyleUnit_Enumerated = 32,
        eStyleUnit_Calc = 40,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct _bindgen_ty_25 {
        pub mInt: root::__BindgenUnionField<i32>,
        pub mFloat: root::__BindgenUnionField<f32>,
        pub mPointer: root::__BindgenUnionField<*mut ::std::os::raw::c_void>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout__bindgen_ty_25() {
        assert_eq!(::std::mem::size_of::<_bindgen_ty_25>() , 8usize);
        assert_eq!(::std::mem::align_of::<_bindgen_ty_25>() , 8usize);
    }
    impl Clone for _bindgen_ty_25 {
        fn clone(&self) -> Self { *self }
    }
    pub type nsStyleUnion = root::_bindgen_ty_25;
    /**
 * Class that hold a single size specification used by the style
 * system.  The size specification consists of two parts -- a number
 * and a unit.  The number is an integer, a floating point value, an
 * nscoord, or undefined, and the unit is an nsStyleUnit.  Checking
 * the unit is a must before asking for the value in any particular
 * form.
 */
 /** <div rustbindgen private accessor="unsafe"></div> */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleCoord {
        mUnit: root::nsStyleUnit,
        mValue: root::nsStyleUnion,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleCoord_CalcValue {
        pub mLength: root::nscoord,
        pub mPercent: f32,
        pub mHasPercent: bool,
    }
    #[test]
    fn bindgen_test_layout_nsStyleCoord_CalcValue() {
        assert_eq!(::std::mem::size_of::<nsStyleCoord_CalcValue>() , 12usize);
        assert_eq!(::std::mem::align_of::<nsStyleCoord_CalcValue>() , 4usize);
    }
    impl Clone for nsStyleCoord_CalcValue {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleCoord_Calc {
        pub _base: root::nsStyleCoord_CalcValue,
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
    }
    pub type nsStyleCoord_Calc_HasThreadSafeRefCnt = root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsStyleCoord_Calc() {
        assert_eq!(::std::mem::size_of::<nsStyleCoord_Calc>() , 24usize);
        assert_eq!(::std::mem::align_of::<nsStyleCoord_Calc>() , 8usize);
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleCoord_CoordConstructorType { CoordConstructor = 0, }
    #[test]
    fn bindgen_test_layout_nsStyleCoord() {
        assert_eq!(::std::mem::size_of::<nsStyleCoord>() , 16usize);
        assert_eq!(::std::mem::align_of::<nsStyleCoord>() , 8usize);
    }
    impl nsStyleCoord {
        #[inline]
        pub unsafe fn get_mUnit(&self) -> &root::nsStyleUnit { &self.mUnit }
        #[inline]
        pub unsafe fn get_mUnit_mut(&mut self) -> &mut root::nsStyleUnit {
            &mut self.mUnit
        }
        #[inline]
        pub unsafe fn get_mValue(&self) -> &root::nsStyleUnion {
            &self.mValue
        }
        #[inline]
        pub unsafe fn get_mValue_mut(&mut self) -> &mut root::nsStyleUnion {
            &mut self.mValue
        }
    }
    /**
 * Class that represents a set of top/right/bottom/left nsStyleCoords.
 * This is commonly used to hold the widths of the borders, margins,
 * or paddings of a box.
 */
 /** <div rustbindgen private accessor="unsafe"></div> */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleSides {
        mUnits: [root::nsStyleUnit; 4usize],
        mValues: [root::nsStyleUnion; 4usize],
    }
    #[test]
    fn bindgen_test_layout_nsStyleSides() {
        assert_eq!(::std::mem::size_of::<nsStyleSides>() , 40usize);
        assert_eq!(::std::mem::align_of::<nsStyleSides>() , 8usize);
    }
    impl nsStyleSides {
        #[inline]
        pub unsafe fn get_mUnits(&self) -> &[root::nsStyleUnit; 4usize] {
            &self.mUnits
        }
        #[inline]
        pub unsafe fn get_mUnits_mut(&mut self)
         -> &mut [root::nsStyleUnit; 4usize] {
            &mut self.mUnits
        }
        #[inline]
        pub unsafe fn get_mValues(&self) -> &[root::nsStyleUnion; 4usize] {
            &self.mValues
        }
        #[inline]
        pub unsafe fn get_mValues_mut(&mut self)
         -> &mut [root::nsStyleUnion; 4usize] {
            &mut self.mValues
        }
    }
    /**
 * Class that represents a set of top-left/top-right/bottom-right/bottom-left
 * nsStyleCoord pairs.  This is used to hold the dimensions of the
 * corners of a box (for, e.g., border-radius and outline-radius).
 */
 /** <div rustbindgen private accessor="unsafe"></div> */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleCorners {
        mUnits: [root::nsStyleUnit; 8usize],
        mValues: [root::nsStyleUnion; 8usize],
    }
    #[test]
    fn bindgen_test_layout_nsStyleCorners() {
        assert_eq!(::std::mem::size_of::<nsStyleCorners>() , 72usize);
        assert_eq!(::std::mem::align_of::<nsStyleCorners>() , 8usize);
    }
    impl nsStyleCorners {
        #[inline]
        pub unsafe fn get_mUnits(&self) -> &[root::nsStyleUnit; 8usize] {
            &self.mUnits
        }
        #[inline]
        pub unsafe fn get_mUnits_mut(&mut self)
         -> &mut [root::nsStyleUnit; 8usize] {
            &mut self.mUnits
        }
        #[inline]
        pub unsafe fn get_mValues(&self) -> &[root::nsStyleUnion; 8usize] {
            &self.mValues
        }
        #[inline]
        pub unsafe fn get_mValues_mut(&mut self)
         -> &mut [root::nsStyleUnion; 8usize] {
            &mut self.mValues
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleDisplay {
        pub mBinding: root::RefPtr<root::mozilla::css::URLValue>,
        pub mDisplay: root::mozilla::StyleDisplay,
        pub mOriginalDisplay: root::mozilla::StyleDisplay,
        pub mContain: u8,
        pub mAppearance: u8,
        pub mPosition: u8,
        pub mFloat: root::mozilla::StyleFloat,
        pub mOriginalFloat: root::mozilla::StyleFloat,
        pub mBreakType: root::mozilla::StyleClear,
        pub mBreakInside: u8,
        pub mBreakBefore: bool,
        pub mBreakAfter: bool,
        pub mOverflowX: u8,
        pub mOverflowY: u8,
        pub mOverflowClipBox: u8,
        pub mResize: u8,
        pub mOrient: root::mozilla::StyleOrient,
        pub mIsolation: u8,
        pub mTopLayer: u8,
        pub mWillChangeBitField: u8,
        pub mWillChange: root::nsTArray<::nsstring::nsStringRepr>,
        pub mTouchAction: u8,
        pub mScrollBehavior: u8,
        pub mScrollSnapTypeX: u8,
        pub mScrollSnapTypeY: u8,
        pub mScrollSnapPointsX: root::nsStyleCoord,
        pub mScrollSnapPointsY: root::nsStyleCoord,
        pub mScrollSnapDestination: root::mozilla::Position,
        pub mScrollSnapCoordinate: root::nsTArray<root::mozilla::Position>,
        pub mBackfaceVisibility: u8,
        pub mTransformStyle: u8,
        pub mTransformBox: u8,
        pub mSpecifiedTransform: root::RefPtr<root::nsCSSValueSharedList>,
        pub mTransformOrigin: [root::nsStyleCoord; 3usize],
        pub mChildPerspective: root::nsStyleCoord,
        pub mPerspectiveOrigin: [root::nsStyleCoord; 2usize],
        pub mVerticalAlign: root::nsStyleCoord,
        pub mTransitions: root::nsStyleAutoArray<root::mozilla::StyleTransition>,
        pub mTransitionTimingFunctionCount: u32,
        pub mTransitionDurationCount: u32,
        pub mTransitionDelayCount: u32,
        pub mTransitionPropertyCount: u32,
        pub mAnimations: root::nsStyleAutoArray<root::mozilla::StyleAnimation>,
        pub mAnimationTimingFunctionCount: u32,
        pub mAnimationDurationCount: u32,
        pub mAnimationDelayCount: u32,
        pub mAnimationNameCount: u32,
        pub mAnimationDirectionCount: u32,
        pub mAnimationFillModeCount: u32,
        pub mAnimationPlayStateCount: u32,
        pub mAnimationIterationCountCount: u32,
        pub mShapeOutside: root::mozilla::StyleShapeOutside,
    }
    #[test]
    fn bindgen_test_layout_nsStyleDisplay() {
        assert_eq!(::std::mem::size_of::<nsStyleDisplay>() , 424usize);
        assert_eq!(::std::mem::align_of::<nsStyleDisplay>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsILanguageAtomService {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsILanguageAtomService_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsILanguageAtomService() {
        assert_eq!(::std::mem::size_of::<nsILanguageAtomService>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsILanguageAtomService>() , 8usize);
    }
    impl Clone for nsILanguageAtomService {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsIPrintSettings {
        pub _address: u8,
    }
    impl Clone for nsIPrintSettings {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsITheme {
        pub _address: u8,
    }
    impl Clone for nsITheme {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct gfxTextPerfMetrics {
        pub _address: u8,
    }
    impl Clone for gfxTextPerfMetrics {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTransitionManager {
        pub _address: u8,
    }
    impl Clone for nsTransitionManager {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsAnimationManager {
        pub _address: u8,
    }
    impl Clone for nsAnimationManager {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsDeviceContext {
        pub _address: u8,
    }
    impl Clone for nsDeviceContext {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct gfxMissingFontRecorder {
        pub _address: u8,
    }
    impl Clone for gfxMissingFontRecorder {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsInvalidateRequestList {
        pub mRequests: root::nsTArray<root::nsInvalidateRequestList_Request>,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsInvalidateRequestList_Request {
        pub mRect: root::nsRect,
        pub mFlags: u32,
    }
    #[test]
    fn bindgen_test_layout_nsInvalidateRequestList_Request() {
        assert_eq!(::std::mem::size_of::<nsInvalidateRequestList_Request>() ,
                   20usize);
        assert_eq!(::std::mem::align_of::<nsInvalidateRequestList_Request>() ,
                   4usize);
    }
    impl Clone for nsInvalidateRequestList_Request {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsInvalidateRequestList() {
        assert_eq!(::std::mem::size_of::<nsInvalidateRequestList>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsInvalidateRequestList>() ,
                   8usize);
    }
    #[repr(i16)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSKeyword {
        eCSSKeyword_UNKNOWN = -1,
        eCSSKeyword__moz_activehyperlinktext = 0,
        eCSSKeyword__moz_all = 1,
        eCSSKeyword__moz_alt_content = 2,
        eCSSKeyword__moz_anchor_decoration = 3,
        eCSSKeyword__moz_available = 4,
        eCSSKeyword__moz_box = 5,
        eCSSKeyword__moz_button = 6,
        eCSSKeyword__moz_buttondefault = 7,
        eCSSKeyword__moz_buttonhoverface = 8,
        eCSSKeyword__moz_buttonhovertext = 9,
        eCSSKeyword__moz_cellhighlight = 10,
        eCSSKeyword__moz_cellhighlighttext = 11,
        eCSSKeyword__moz_center = 12,
        eCSSKeyword__moz_combobox = 13,
        eCSSKeyword__moz_comboboxtext = 14,
        eCSSKeyword__moz_block_height = 15,
        eCSSKeyword__moz_deck = 16,
        eCSSKeyword__moz_default_background_color = 17,
        eCSSKeyword__moz_default_color = 18,
        eCSSKeyword__moz_desktop = 19,
        eCSSKeyword__moz_dialog = 20,
        eCSSKeyword__moz_dialogtext = 21,
        eCSSKeyword__moz_document = 22,
        eCSSKeyword__moz_dragtargetzone = 23,
        eCSSKeyword__moz_element = 24,
        eCSSKeyword__moz_eventreerow = 25,
        eCSSKeyword__moz_field = 26,
        eCSSKeyword__moz_fieldtext = 27,
        eCSSKeyword__moz_fit_content = 28,
        eCSSKeyword__moz_fixed = 29,
        eCSSKeyword__moz_grabbing = 30,
        eCSSKeyword__moz_grab = 31,
        eCSSKeyword__moz_grid_group = 32,
        eCSSKeyword__moz_grid_line = 33,
        eCSSKeyword__moz_grid = 34,
        eCSSKeyword__moz_groupbox = 35,
        eCSSKeyword__moz_gtk_info_bar = 36,
        eCSSKeyword__moz_gtk_info_bar_text = 37,
        eCSSKeyword__moz_hidden_unscrollable = 38,
        eCSSKeyword__moz_hyperlinktext = 39,
        eCSSKeyword__moz_html_cellhighlight = 40,
        eCSSKeyword__moz_html_cellhighlighttext = 41,
        eCSSKeyword__moz_image_rect = 42,
        eCSSKeyword__moz_info = 43,
        eCSSKeyword__moz_inline_box = 44,
        eCSSKeyword__moz_inline_grid = 45,
        eCSSKeyword__moz_inline_stack = 46,
        eCSSKeyword__moz_isolate = 47,
        eCSSKeyword__moz_isolate_override = 48,
        eCSSKeyword__moz_left = 49,
        eCSSKeyword__moz_list = 50,
        eCSSKeyword__moz_mac_buttonactivetext = 51,
        eCSSKeyword__moz_mac_chrome_active = 52,
        eCSSKeyword__moz_mac_chrome_inactive = 53,
        eCSSKeyword__moz_mac_defaultbuttontext = 54,
        eCSSKeyword__moz_mac_focusring = 55,
        eCSSKeyword__moz_mac_fullscreen_button = 56,
        eCSSKeyword__moz_mac_menuselect = 57,
        eCSSKeyword__moz_mac_menushadow = 58,
        eCSSKeyword__moz_mac_menutextdisable = 59,
        eCSSKeyword__moz_mac_menutextselect = 60,
        eCSSKeyword__moz_mac_disabledtoolbartext = 61,
        eCSSKeyword__moz_mac_secondaryhighlight = 62,
        eCSSKeyword__moz_max_content = 63,
        eCSSKeyword__moz_menuhover = 64,
        eCSSKeyword__moz_menuhovertext = 65,
        eCSSKeyword__moz_menubartext = 66,
        eCSSKeyword__moz_menubarhovertext = 67,
        eCSSKeyword__moz_middle_with_baseline = 68,
        eCSSKeyword__moz_min_content = 69,
        eCSSKeyword__moz_nativehyperlinktext = 70,
        eCSSKeyword__moz_none = 71,
        eCSSKeyword__moz_oddtreerow = 72,
        eCSSKeyword__moz_plaintext = 73,
        eCSSKeyword__moz_popup = 74,
        eCSSKeyword__moz_pre_space = 75,
        eCSSKeyword__moz_pull_down_menu = 76,
        eCSSKeyword__moz_right = 77,
        eCSSKeyword__moz_scrollbars_horizontal = 78,
        eCSSKeyword__moz_scrollbars_none = 79,
        eCSSKeyword__moz_scrollbars_vertical = 80,
        eCSSKeyword__moz_stack = 81,
        eCSSKeyword__moz_text = 82,
        eCSSKeyword__moz_use_system_font = 83,
        eCSSKeyword__moz_visitedhyperlinktext = 84,
        eCSSKeyword__moz_window = 85,
        eCSSKeyword__moz_workspace = 86,
        eCSSKeyword__moz_zoom_in = 87,
        eCSSKeyword__moz_zoom_out = 88,
        eCSSKeyword__webkit_box = 89,
        eCSSKeyword__webkit_flex = 90,
        eCSSKeyword__webkit_inline_box = 91,
        eCSSKeyword__webkit_inline_flex = 92,
        eCSSKeyword_absolute = 93,
        eCSSKeyword_active = 94,
        eCSSKeyword_activeborder = 95,
        eCSSKeyword_activecaption = 96,
        eCSSKeyword_add = 97,
        eCSSKeyword_additive = 98,
        eCSSKeyword_alias = 99,
        eCSSKeyword_all = 100,
        eCSSKeyword_all_petite_caps = 101,
        eCSSKeyword_all_scroll = 102,
        eCSSKeyword_all_small_caps = 103,
        eCSSKeyword_alpha = 104,
        eCSSKeyword_alternate = 105,
        eCSSKeyword_alternate_reverse = 106,
        eCSSKeyword_always = 107,
        eCSSKeyword_annotation = 108,
        eCSSKeyword_appworkspace = 109,
        eCSSKeyword_auto = 110,
        eCSSKeyword_auto_fill = 111,
        eCSSKeyword_auto_fit = 112,
        eCSSKeyword_auto_flow = 113,
        eCSSKeyword_avoid = 114,
        eCSSKeyword_background = 115,
        eCSSKeyword_backwards = 116,
        eCSSKeyword_balance = 117,
        eCSSKeyword_baseline = 118,
        eCSSKeyword_bidi_override = 119,
        eCSSKeyword_blink = 120,
        eCSSKeyword_block = 121,
        eCSSKeyword_block_axis = 122,
        eCSSKeyword_blur = 123,
        eCSSKeyword_bold = 124,
        eCSSKeyword_bold_fraktur = 125,
        eCSSKeyword_bold_italic = 126,
        eCSSKeyword_bold_sans_serif = 127,
        eCSSKeyword_bold_script = 128,
        eCSSKeyword_bolder = 129,
        eCSSKeyword_border_box = 130,
        eCSSKeyword_both = 131,
        eCSSKeyword_bottom = 132,
        eCSSKeyword_bottom_outside = 133,
        eCSSKeyword_break_all = 134,
        eCSSKeyword_break_word = 135,
        eCSSKeyword_brightness = 136,
        eCSSKeyword_browser = 137,
        eCSSKeyword_bullets = 138,
        eCSSKeyword_button = 139,
        eCSSKeyword_buttonface = 140,
        eCSSKeyword_buttonhighlight = 141,
        eCSSKeyword_buttonshadow = 142,
        eCSSKeyword_buttontext = 143,
        eCSSKeyword_capitalize = 144,
        eCSSKeyword_caption = 145,
        eCSSKeyword_captiontext = 146,
        eCSSKeyword_cell = 147,
        eCSSKeyword_center = 148,
        eCSSKeyword_ch = 149,
        eCSSKeyword_character_variant = 150,
        eCSSKeyword_circle = 151,
        eCSSKeyword_cjk_decimal = 152,
        eCSSKeyword_clip = 153,
        eCSSKeyword_clone = 154,
        eCSSKeyword_close_quote = 155,
        eCSSKeyword_closest_corner = 156,
        eCSSKeyword_closest_side = 157,
        eCSSKeyword_cm = 158,
        eCSSKeyword_col_resize = 159,
        eCSSKeyword_collapse = 160,
        eCSSKeyword_color = 161,
        eCSSKeyword_color_burn = 162,
        eCSSKeyword_color_dodge = 163,
        eCSSKeyword_common_ligatures = 164,
        eCSSKeyword_column = 165,
        eCSSKeyword_column_reverse = 166,
        eCSSKeyword_condensed = 167,
        eCSSKeyword_contain = 168,
        eCSSKeyword_content_box = 169,
        eCSSKeyword_contents = 170,
        eCSSKeyword_context_fill = 171,
        eCSSKeyword_context_fill_opacity = 172,
        eCSSKeyword_context_menu = 173,
        eCSSKeyword_context_stroke = 174,
        eCSSKeyword_context_stroke_opacity = 175,
        eCSSKeyword_context_value = 176,
        eCSSKeyword_continuous = 177,
        eCSSKeyword_contrast = 178,
        eCSSKeyword_copy = 179,
        eCSSKeyword_contextual = 180,
        eCSSKeyword_cover = 181,
        eCSSKeyword_crop = 182,
        eCSSKeyword_cross = 183,
        eCSSKeyword_crosshair = 184,
        eCSSKeyword_currentcolor = 185,
        eCSSKeyword_cursive = 186,
        eCSSKeyword_cyclic = 187,
        eCSSKeyword_darken = 188,
        eCSSKeyword_dashed = 189,
        eCSSKeyword_dense = 190,
        eCSSKeyword_decimal = 191,
        eCSSKeyword_default = 192,
        eCSSKeyword_deg = 193,
        eCSSKeyword_diagonal_fractions = 194,
        eCSSKeyword_dialog = 195,
        eCSSKeyword_difference = 196,
        eCSSKeyword_digits = 197,
        eCSSKeyword_disabled = 198,
        eCSSKeyword_disc = 199,
        eCSSKeyword_disclosure_closed = 200,
        eCSSKeyword_disclosure_open = 201,
        eCSSKeyword_discretionary_ligatures = 202,
        eCSSKeyword_dot = 203,
        eCSSKeyword_dotted = 204,
        eCSSKeyword_double = 205,
        eCSSKeyword_double_circle = 206,
        eCSSKeyword_double_struck = 207,
        eCSSKeyword_drag = 208,
        eCSSKeyword_drop_shadow = 209,
        eCSSKeyword_e_resize = 210,
        eCSSKeyword_ease = 211,
        eCSSKeyword_ease_in = 212,
        eCSSKeyword_ease_in_out = 213,
        eCSSKeyword_ease_out = 214,
        eCSSKeyword_economy = 215,
        eCSSKeyword_element = 216,
        eCSSKeyword_elements = 217,
        eCSSKeyword_ellipse = 218,
        eCSSKeyword_ellipsis = 219,
        eCSSKeyword_em = 220,
        eCSSKeyword_embed = 221,
        eCSSKeyword_enabled = 222,
        eCSSKeyword_end = 223,
        eCSSKeyword_ethiopic_numeric = 224,
        eCSSKeyword_ex = 225,
        eCSSKeyword_exact = 226,
        eCSSKeyword_exclude = 227,
        eCSSKeyword_exclusion = 228,
        eCSSKeyword_expanded = 229,
        eCSSKeyword_extends = 230,
        eCSSKeyword_extra_condensed = 231,
        eCSSKeyword_extra_expanded = 232,
        eCSSKeyword_ew_resize = 233,
        eCSSKeyword_fallback = 234,
        eCSSKeyword_fantasy = 235,
        eCSSKeyword_farthest_side = 236,
        eCSSKeyword_farthest_corner = 237,
        eCSSKeyword_fill = 238,
        eCSSKeyword_filled = 239,
        eCSSKeyword_fill_box = 240,
        eCSSKeyword_first = 241,
        eCSSKeyword_fit_content = 242,
        eCSSKeyword_fixed = 243,
        eCSSKeyword_flat = 244,
        eCSSKeyword_flex = 245,
        eCSSKeyword_flex_end = 246,
        eCSSKeyword_flex_start = 247,
        eCSSKeyword_flip = 248,
        eCSSKeyword_flow_root = 249,
        eCSSKeyword_forwards = 250,
        eCSSKeyword_fraktur = 251,
        eCSSKeyword_from_image = 252,
        eCSSKeyword_full_width = 253,
        eCSSKeyword_fullscreen = 254,
        eCSSKeyword_grab = 255,
        eCSSKeyword_grabbing = 256,
        eCSSKeyword_grad = 257,
        eCSSKeyword_grayscale = 258,
        eCSSKeyword_graytext = 259,
        eCSSKeyword_grid = 260,
        eCSSKeyword_groove = 261,
        eCSSKeyword_hard_light = 262,
        eCSSKeyword_hebrew = 263,
        eCSSKeyword_help = 264,
        eCSSKeyword_hidden = 265,
        eCSSKeyword_hide = 266,
        eCSSKeyword_highlight = 267,
        eCSSKeyword_highlighttext = 268,
        eCSSKeyword_historical_forms = 269,
        eCSSKeyword_historical_ligatures = 270,
        eCSSKeyword_horizontal = 271,
        eCSSKeyword_horizontal_tb = 272,
        eCSSKeyword_hue = 273,
        eCSSKeyword_hue_rotate = 274,
        eCSSKeyword_hz = 275,
        eCSSKeyword_icon = 276,
        eCSSKeyword_ignore = 277,
        eCSSKeyword_in = 278,
        eCSSKeyword_interlace = 279,
        eCSSKeyword_inactive = 280,
        eCSSKeyword_inactiveborder = 281,
        eCSSKeyword_inactivecaption = 282,
        eCSSKeyword_inactivecaptiontext = 283,
        eCSSKeyword_infinite = 284,
        eCSSKeyword_infobackground = 285,
        eCSSKeyword_infotext = 286,
        eCSSKeyword_inherit = 287,
        eCSSKeyword_initial = 288,
        eCSSKeyword_inline = 289,
        eCSSKeyword_inline_axis = 290,
        eCSSKeyword_inline_block = 291,
        eCSSKeyword_inline_end = 292,
        eCSSKeyword_inline_flex = 293,
        eCSSKeyword_inline_grid = 294,
        eCSSKeyword_inline_start = 295,
        eCSSKeyword_inline_table = 296,
        eCSSKeyword_inset = 297,
        eCSSKeyword_inside = 298,
        eCSSKeyword_interpolatematrix = 299,
        eCSSKeyword_accumulatematrix = 300,
        eCSSKeyword_intersect = 301,
        eCSSKeyword_isolate = 302,
        eCSSKeyword_isolate_override = 303,
        eCSSKeyword_invert = 304,
        eCSSKeyword_italic = 305,
        eCSSKeyword_japanese_formal = 306,
        eCSSKeyword_japanese_informal = 307,
        eCSSKeyword_jis78 = 308,
        eCSSKeyword_jis83 = 309,
        eCSSKeyword_jis90 = 310,
        eCSSKeyword_jis04 = 311,
        eCSSKeyword_justify = 312,
        eCSSKeyword_keep_all = 313,
        eCSSKeyword_khz = 314,
        eCSSKeyword_korean_hangul_formal = 315,
        eCSSKeyword_korean_hanja_formal = 316,
        eCSSKeyword_korean_hanja_informal = 317,
        eCSSKeyword_landscape = 318,
        eCSSKeyword_large = 319,
        eCSSKeyword_larger = 320,
        eCSSKeyword_last = 321,
        eCSSKeyword_last_baseline = 322,
        eCSSKeyword_layout = 323,
        eCSSKeyword_left = 324,
        eCSSKeyword_legacy = 325,
        eCSSKeyword_lighten = 326,
        eCSSKeyword_lighter = 327,
        eCSSKeyword_line_through = 328,
        eCSSKeyword_linear = 329,
        eCSSKeyword_lining_nums = 330,
        eCSSKeyword_list_item = 331,
        eCSSKeyword_local = 332,
        eCSSKeyword_logical = 333,
        eCSSKeyword_looped = 334,
        eCSSKeyword_lowercase = 335,
        eCSSKeyword_lr = 336,
        eCSSKeyword_lr_tb = 337,
        eCSSKeyword_ltr = 338,
        eCSSKeyword_luminance = 339,
        eCSSKeyword_luminosity = 340,
        eCSSKeyword_mandatory = 341,
        eCSSKeyword_manipulation = 342,
        eCSSKeyword_manual = 343,
        eCSSKeyword_margin_box = 344,
        eCSSKeyword_markers = 345,
        eCSSKeyword_match_parent = 346,
        eCSSKeyword_match_source = 347,
        eCSSKeyword_matrix = 348,
        eCSSKeyword_matrix3d = 349,
        eCSSKeyword_max_content = 350,
        eCSSKeyword_medium = 351,
        eCSSKeyword_menu = 352,
        eCSSKeyword_menutext = 353,
        eCSSKeyword_message_box = 354,
        eCSSKeyword_middle = 355,
        eCSSKeyword_min_content = 356,
        eCSSKeyword_minmax = 357,
        eCSSKeyword_mix = 358,
        eCSSKeyword_mixed = 359,
        eCSSKeyword_mm = 360,
        eCSSKeyword_monospace = 361,
        eCSSKeyword_move = 362,
        eCSSKeyword_ms = 363,
        eCSSKeyword_multiply = 364,
        eCSSKeyword_n_resize = 365,
        eCSSKeyword_narrower = 366,
        eCSSKeyword_ne_resize = 367,
        eCSSKeyword_nesw_resize = 368,
        eCSSKeyword_no_clip = 369,
        eCSSKeyword_no_close_quote = 370,
        eCSSKeyword_no_common_ligatures = 371,
        eCSSKeyword_no_contextual = 372,
        eCSSKeyword_no_discretionary_ligatures = 373,
        eCSSKeyword_no_drag = 374,
        eCSSKeyword_no_drop = 375,
        eCSSKeyword_no_historical_ligatures = 376,
        eCSSKeyword_no_open_quote = 377,
        eCSSKeyword_no_repeat = 378,
        eCSSKeyword_none = 379,
        eCSSKeyword_normal = 380,
        eCSSKeyword_not_allowed = 381,
        eCSSKeyword_nowrap = 382,
        eCSSKeyword_numeric = 383,
        eCSSKeyword_ns_resize = 384,
        eCSSKeyword_nw_resize = 385,
        eCSSKeyword_nwse_resize = 386,
        eCSSKeyword_oblique = 387,
        eCSSKeyword_oldstyle_nums = 388,
        eCSSKeyword_opacity = 389,
        eCSSKeyword_open = 390,
        eCSSKeyword_open_quote = 391,
        eCSSKeyword_optional = 392,
        eCSSKeyword_ordinal = 393,
        eCSSKeyword_ornaments = 394,
        eCSSKeyword_outset = 395,
        eCSSKeyword_outside = 396,
        eCSSKeyword_over = 397,
        eCSSKeyword_overlay = 398,
        eCSSKeyword_overline = 399,
        eCSSKeyword_paint = 400,
        eCSSKeyword_padding_box = 401,
        eCSSKeyword_painted = 402,
        eCSSKeyword_pan_x = 403,
        eCSSKeyword_pan_y = 404,
        eCSSKeyword_paused = 405,
        eCSSKeyword_pc = 406,
        eCSSKeyword_perspective = 407,
        eCSSKeyword_petite_caps = 408,
        eCSSKeyword_physical = 409,
        eCSSKeyword_plaintext = 410,
        eCSSKeyword_pointer = 411,
        eCSSKeyword_polygon = 412,
        eCSSKeyword_portrait = 413,
        eCSSKeyword_pre = 414,
        eCSSKeyword_pre_wrap = 415,
        eCSSKeyword_pre_line = 416,
        eCSSKeyword_preserve_3d = 417,
        eCSSKeyword_progress = 418,
        eCSSKeyword_progressive = 419,
        eCSSKeyword_proportional_nums = 420,
        eCSSKeyword_proportional_width = 421,
        eCSSKeyword_proximity = 422,
        eCSSKeyword_pt = 423,
        eCSSKeyword_px = 424,
        eCSSKeyword_rad = 425,
        eCSSKeyword_read_only = 426,
        eCSSKeyword_read_write = 427,
        eCSSKeyword_relative = 428,
        eCSSKeyword_repeat = 429,
        eCSSKeyword_repeat_x = 430,
        eCSSKeyword_repeat_y = 431,
        eCSSKeyword_reverse = 432,
        eCSSKeyword_ridge = 433,
        eCSSKeyword_right = 434,
        eCSSKeyword_rl = 435,
        eCSSKeyword_rl_tb = 436,
        eCSSKeyword_rotate = 437,
        eCSSKeyword_rotate3d = 438,
        eCSSKeyword_rotatex = 439,
        eCSSKeyword_rotatey = 440,
        eCSSKeyword_rotatez = 441,
        eCSSKeyword_round = 442,
        eCSSKeyword_row = 443,
        eCSSKeyword_row_resize = 444,
        eCSSKeyword_row_reverse = 445,
        eCSSKeyword_rtl = 446,
        eCSSKeyword_ruby = 447,
        eCSSKeyword_ruby_base = 448,
        eCSSKeyword_ruby_base_container = 449,
        eCSSKeyword_ruby_text = 450,
        eCSSKeyword_ruby_text_container = 451,
        eCSSKeyword_running = 452,
        eCSSKeyword_s = 453,
        eCSSKeyword_s_resize = 454,
        eCSSKeyword_safe = 455,
        eCSSKeyword_saturate = 456,
        eCSSKeyword_saturation = 457,
        eCSSKeyword_scale = 458,
        eCSSKeyword_scale_down = 459,
        eCSSKeyword_scale3d = 460,
        eCSSKeyword_scalex = 461,
        eCSSKeyword_scaley = 462,
        eCSSKeyword_scalez = 463,
        eCSSKeyword_screen = 464,
        eCSSKeyword_script = 465,
        eCSSKeyword_scroll = 466,
        eCSSKeyword_scrollbar = 467,
        eCSSKeyword_scrollbar_small = 468,
        eCSSKeyword_scrollbar_horizontal = 469,
        eCSSKeyword_scrollbar_vertical = 470,
        eCSSKeyword_se_resize = 471,
        eCSSKeyword_select_after = 472,
        eCSSKeyword_select_all = 473,
        eCSSKeyword_select_before = 474,
        eCSSKeyword_select_menu = 475,
        eCSSKeyword_select_same = 476,
        eCSSKeyword_self_end = 477,
        eCSSKeyword_self_start = 478,
        eCSSKeyword_semi_condensed = 479,
        eCSSKeyword_semi_expanded = 480,
        eCSSKeyword_separate = 481,
        eCSSKeyword_sepia = 482,
        eCSSKeyword_serif = 483,
        eCSSKeyword_sesame = 484,
        eCSSKeyword_show = 485,
        eCSSKeyword_sideways = 486,
        eCSSKeyword_sideways_lr = 487,
        eCSSKeyword_sideways_right = 488,
        eCSSKeyword_sideways_rl = 489,
        eCSSKeyword_simp_chinese_formal = 490,
        eCSSKeyword_simp_chinese_informal = 491,
        eCSSKeyword_simplified = 492,
        eCSSKeyword_skew = 493,
        eCSSKeyword_skewx = 494,
        eCSSKeyword_skewy = 495,
        eCSSKeyword_slashed_zero = 496,
        eCSSKeyword_slice = 497,
        eCSSKeyword_small = 498,
        eCSSKeyword_small_caps = 499,
        eCSSKeyword_small_caption = 500,
        eCSSKeyword_smaller = 501,
        eCSSKeyword_smooth = 502,
        eCSSKeyword_soft = 503,
        eCSSKeyword_soft_light = 504,
        eCSSKeyword_solid = 505,
        eCSSKeyword_space_around = 506,
        eCSSKeyword_space_between = 507,
        eCSSKeyword_space_evenly = 508,
        eCSSKeyword_span = 509,
        eCSSKeyword_spell_out = 510,
        eCSSKeyword_square = 511,
        eCSSKeyword_stacked_fractions = 512,
        eCSSKeyword_start = 513,
        eCSSKeyword_static = 514,
        eCSSKeyword_standalone = 515,
        eCSSKeyword_status_bar = 516,
        eCSSKeyword_step_end = 517,
        eCSSKeyword_step_start = 518,
        eCSSKeyword_sticky = 519,
        eCSSKeyword_stretch = 520,
        eCSSKeyword_stretch_to_fit = 521,
        eCSSKeyword_stretched = 522,
        eCSSKeyword_strict = 523,
        eCSSKeyword_stroke = 524,
        eCSSKeyword_stroke_box = 525,
        eCSSKeyword_style = 526,
        eCSSKeyword_styleset = 527,
        eCSSKeyword_stylistic = 528,
        eCSSKeyword_sub = 529,
        eCSSKeyword_subgrid = 530,
        eCSSKeyword_subtract = 531,
        eCSSKeyword_super = 532,
        eCSSKeyword_sw_resize = 533,
        eCSSKeyword_swash = 534,
        eCSSKeyword_swap = 535,
        eCSSKeyword_table = 536,
        eCSSKeyword_table_caption = 537,
        eCSSKeyword_table_cell = 538,
        eCSSKeyword_table_column = 539,
        eCSSKeyword_table_column_group = 540,
        eCSSKeyword_table_footer_group = 541,
        eCSSKeyword_table_header_group = 542,
        eCSSKeyword_table_row = 543,
        eCSSKeyword_table_row_group = 544,
        eCSSKeyword_tabular_nums = 545,
        eCSSKeyword_tailed = 546,
        eCSSKeyword_tb = 547,
        eCSSKeyword_tb_rl = 548,
        eCSSKeyword_text = 549,
        eCSSKeyword_text_bottom = 550,
        eCSSKeyword_text_top = 551,
        eCSSKeyword_thick = 552,
        eCSSKeyword_thin = 553,
        eCSSKeyword_threeddarkshadow = 554,
        eCSSKeyword_threedface = 555,
        eCSSKeyword_threedhighlight = 556,
        eCSSKeyword_threedlightshadow = 557,
        eCSSKeyword_threedshadow = 558,
        eCSSKeyword_titling_caps = 559,
        eCSSKeyword_toggle = 560,
        eCSSKeyword_top = 561,
        eCSSKeyword_top_outside = 562,
        eCSSKeyword_trad_chinese_formal = 563,
        eCSSKeyword_trad_chinese_informal = 564,
        eCSSKeyword_traditional = 565,
        eCSSKeyword_translate = 566,
        eCSSKeyword_translate3d = 567,
        eCSSKeyword_translatex = 568,
        eCSSKeyword_translatey = 569,
        eCSSKeyword_translatez = 570,
        eCSSKeyword_transparent = 571,
        eCSSKeyword_triangle = 572,
        eCSSKeyword_tri_state = 573,
        eCSSKeyword_ultra_condensed = 574,
        eCSSKeyword_ultra_expanded = 575,
        eCSSKeyword_under = 576,
        eCSSKeyword_underline = 577,
        eCSSKeyword_unicase = 578,
        eCSSKeyword_unsafe = 579,
        eCSSKeyword_unset = 580,
        eCSSKeyword_uppercase = 581,
        eCSSKeyword_upright = 582,
        eCSSKeyword_vertical = 583,
        eCSSKeyword_vertical_lr = 584,
        eCSSKeyword_vertical_rl = 585,
        eCSSKeyword_vertical_text = 586,
        eCSSKeyword_view_box = 587,
        eCSSKeyword_visible = 588,
        eCSSKeyword_visiblefill = 589,
        eCSSKeyword_visiblepainted = 590,
        eCSSKeyword_visiblestroke = 591,
        eCSSKeyword_w_resize = 592,
        eCSSKeyword_wait = 593,
        eCSSKeyword_wavy = 594,
        eCSSKeyword_weight = 595,
        eCSSKeyword_wider = 596,
        eCSSKeyword_window = 597,
        eCSSKeyword_windowframe = 598,
        eCSSKeyword_windowtext = 599,
        eCSSKeyword_words = 600,
        eCSSKeyword_wrap = 601,
        eCSSKeyword_wrap_reverse = 602,
        eCSSKeyword_write_only = 603,
        eCSSKeyword_x_large = 604,
        eCSSKeyword_x_small = 605,
        eCSSKeyword_xx_large = 606,
        eCSSKeyword_xx_small = 607,
        eCSSKeyword_zoom_in = 608,
        eCSSKeyword_zoom_out = 609,
        eCSSKeyword_radio = 610,
        eCSSKeyword_checkbox = 611,
        eCSSKeyword_button_bevel = 612,
        eCSSKeyword_toolbox = 613,
        eCSSKeyword_toolbar = 614,
        eCSSKeyword_toolbarbutton = 615,
        eCSSKeyword_toolbargripper = 616,
        eCSSKeyword_dualbutton = 617,
        eCSSKeyword_toolbarbutton_dropdown = 618,
        eCSSKeyword_button_arrow_up = 619,
        eCSSKeyword_button_arrow_down = 620,
        eCSSKeyword_button_arrow_next = 621,
        eCSSKeyword_button_arrow_previous = 622,
        eCSSKeyword_separator = 623,
        eCSSKeyword_splitter = 624,
        eCSSKeyword_statusbar = 625,
        eCSSKeyword_statusbarpanel = 626,
        eCSSKeyword_resizerpanel = 627,
        eCSSKeyword_resizer = 628,
        eCSSKeyword_listbox = 629,
        eCSSKeyword_listitem = 630,
        eCSSKeyword_numbers = 631,
        eCSSKeyword_number_input = 632,
        eCSSKeyword_treeview = 633,
        eCSSKeyword_treeitem = 634,
        eCSSKeyword_treetwisty = 635,
        eCSSKeyword_treetwistyopen = 636,
        eCSSKeyword_treeline = 637,
        eCSSKeyword_treeheader = 638,
        eCSSKeyword_treeheadercell = 639,
        eCSSKeyword_treeheadersortarrow = 640,
        eCSSKeyword_progressbar = 641,
        eCSSKeyword_progressbar_vertical = 642,
        eCSSKeyword_progresschunk = 643,
        eCSSKeyword_progresschunk_vertical = 644,
        eCSSKeyword_tab = 645,
        eCSSKeyword_tabpanels = 646,
        eCSSKeyword_tabpanel = 647,
        eCSSKeyword_tab_scroll_arrow_back = 648,
        eCSSKeyword_tab_scroll_arrow_forward = 649,
        eCSSKeyword_tooltip = 650,
        eCSSKeyword_spinner = 651,
        eCSSKeyword_spinner_upbutton = 652,
        eCSSKeyword_spinner_downbutton = 653,
        eCSSKeyword_spinner_textfield = 654,
        eCSSKeyword_scrollbarbutton_up = 655,
        eCSSKeyword_scrollbarbutton_down = 656,
        eCSSKeyword_scrollbarbutton_left = 657,
        eCSSKeyword_scrollbarbutton_right = 658,
        eCSSKeyword_scrollbartrack_horizontal = 659,
        eCSSKeyword_scrollbartrack_vertical = 660,
        eCSSKeyword_scrollbarthumb_horizontal = 661,
        eCSSKeyword_scrollbarthumb_vertical = 662,
        eCSSKeyword_sheet = 663,
        eCSSKeyword_textfield = 664,
        eCSSKeyword_textfield_multiline = 665,
        eCSSKeyword_caret = 666,
        eCSSKeyword_searchfield = 667,
        eCSSKeyword_menubar = 668,
        eCSSKeyword_menupopup = 669,
        eCSSKeyword_menuitem = 670,
        eCSSKeyword_checkmenuitem = 671,
        eCSSKeyword_radiomenuitem = 672,
        eCSSKeyword_menucheckbox = 673,
        eCSSKeyword_menuradio = 674,
        eCSSKeyword_menuseparator = 675,
        eCSSKeyword_menuarrow = 676,
        eCSSKeyword_menuimage = 677,
        eCSSKeyword_menuitemtext = 678,
        eCSSKeyword_menulist = 679,
        eCSSKeyword_menulist_button = 680,
        eCSSKeyword_menulist_text = 681,
        eCSSKeyword_menulist_textfield = 682,
        eCSSKeyword_meterbar = 683,
        eCSSKeyword_meterchunk = 684,
        eCSSKeyword_minimal_ui = 685,
        eCSSKeyword_range = 686,
        eCSSKeyword_range_thumb = 687,
        eCSSKeyword_sans_serif = 688,
        eCSSKeyword_sans_serif_bold_italic = 689,
        eCSSKeyword_sans_serif_italic = 690,
        eCSSKeyword_scale_horizontal = 691,
        eCSSKeyword_scale_vertical = 692,
        eCSSKeyword_scalethumb_horizontal = 693,
        eCSSKeyword_scalethumb_vertical = 694,
        eCSSKeyword_scalethumbstart = 695,
        eCSSKeyword_scalethumbend = 696,
        eCSSKeyword_scalethumbtick = 697,
        eCSSKeyword_groupbox = 698,
        eCSSKeyword_checkbox_container = 699,
        eCSSKeyword_radio_container = 700,
        eCSSKeyword_checkbox_label = 701,
        eCSSKeyword_radio_label = 702,
        eCSSKeyword_button_focus = 703,
        eCSSKeyword__moz_win_media_toolbox = 704,
        eCSSKeyword__moz_win_communications_toolbox = 705,
        eCSSKeyword__moz_win_browsertabbar_toolbox = 706,
        eCSSKeyword__moz_win_mediatext = 707,
        eCSSKeyword__moz_win_communicationstext = 708,
        eCSSKeyword__moz_win_glass = 709,
        eCSSKeyword__moz_win_borderless_glass = 710,
        eCSSKeyword__moz_window_titlebar = 711,
        eCSSKeyword__moz_window_titlebar_maximized = 712,
        eCSSKeyword__moz_window_frame_left = 713,
        eCSSKeyword__moz_window_frame_right = 714,
        eCSSKeyword__moz_window_frame_bottom = 715,
        eCSSKeyword__moz_window_button_close = 716,
        eCSSKeyword__moz_window_button_minimize = 717,
        eCSSKeyword__moz_window_button_maximize = 718,
        eCSSKeyword__moz_window_button_restore = 719,
        eCSSKeyword__moz_window_button_box = 720,
        eCSSKeyword__moz_window_button_box_maximized = 721,
        eCSSKeyword__moz_mac_help_button = 722,
        eCSSKeyword__moz_win_exclude_glass = 723,
        eCSSKeyword__moz_mac_vibrancy_light = 724,
        eCSSKeyword__moz_mac_vibrancy_dark = 725,
        eCSSKeyword__moz_mac_disclosure_button_closed = 726,
        eCSSKeyword__moz_mac_disclosure_button_open = 727,
        eCSSKeyword__moz_mac_source_list = 728,
        eCSSKeyword__moz_mac_source_list_selection = 729,
        eCSSKeyword__moz_mac_active_source_list_selection = 730,
        eCSSKeyword_alphabetic = 731,
        eCSSKeyword_bevel = 732,
        eCSSKeyword_butt = 733,
        eCSSKeyword_central = 734,
        eCSSKeyword_crispedges = 735,
        eCSSKeyword_evenodd = 736,
        eCSSKeyword_geometricprecision = 737,
        eCSSKeyword_hanging = 738,
        eCSSKeyword_ideographic = 739,
        eCSSKeyword_linearrgb = 740,
        eCSSKeyword_mathematical = 741,
        eCSSKeyword_miter = 742,
        eCSSKeyword_no_change = 743,
        eCSSKeyword_non_scaling_stroke = 744,
        eCSSKeyword_nonzero = 745,
        eCSSKeyword_optimizelegibility = 746,
        eCSSKeyword_optimizequality = 747,
        eCSSKeyword_optimizespeed = 748,
        eCSSKeyword_reset_size = 749,
        eCSSKeyword_srgb = 750,
        eCSSKeyword_symbolic = 751,
        eCSSKeyword_symbols = 752,
        eCSSKeyword_text_after_edge = 753,
        eCSSKeyword_text_before_edge = 754,
        eCSSKeyword_use_script = 755,
        eCSSKeyword__moz_crisp_edges = 756,
        eCSSKeyword_space = 757,
        eCSSKeyword_COUNT = 758,
    }
    pub const nsCSSPropertyID_eCSSProperty_COUNT_DUMMY: root::nsCSSPropertyID
              =
        nsCSSPropertyID::eCSSProperty_z_index;
    pub const nsCSSPropertyID_eCSSProperty_all: root::nsCSSPropertyID =
        nsCSSPropertyID::eCSSProperty_COUNT_no_shorthands;
    pub const nsCSSPropertyID_eCSSProperty_COUNT_DUMMY2: root::nsCSSPropertyID
              =
        nsCSSPropertyID::eCSSProperty_transition;
    pub const nsCSSPropertyID_eCSSPropertyAlias_WordWrap:
              root::nsCSSPropertyID =
        nsCSSPropertyID::eCSSProperty_COUNT;
    pub const nsCSSPropertyID_eCSSProperty_COUNT_DUMMY3: root::nsCSSPropertyID
              =
        nsCSSPropertyID::eCSSPropertyAlias_WebkitMaskSize;
    pub const nsCSSPropertyID_eCSSPropertyExtra_no_properties:
              root::nsCSSPropertyID =
        nsCSSPropertyID::eCSSProperty_COUNT_with_aliases;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSPropertyID {
        eCSSProperty_UNKNOWN = -1,
        eCSSProperty_align_content = 0,
        eCSSProperty_align_items = 1,
        eCSSProperty_align_self = 2,
        eCSSProperty_animation_delay = 3,
        eCSSProperty_animation_direction = 4,
        eCSSProperty_animation_duration = 5,
        eCSSProperty_animation_fill_mode = 6,
        eCSSProperty_animation_iteration_count = 7,
        eCSSProperty_animation_name = 8,
        eCSSProperty_animation_play_state = 9,
        eCSSProperty_animation_timing_function = 10,
        eCSSProperty__moz_appearance = 11,
        eCSSProperty_backface_visibility = 12,
        eCSSProperty_background_attachment = 13,
        eCSSProperty_background_blend_mode = 14,
        eCSSProperty_background_clip = 15,
        eCSSProperty_background_color = 16,
        eCSSProperty_background_image = 17,
        eCSSProperty_background_origin = 18,
        eCSSProperty_background_position_x = 19,
        eCSSProperty_background_position_y = 20,
        eCSSProperty_background_repeat = 21,
        eCSSProperty_background_size = 22,
        eCSSProperty__moz_binding = 23,
        eCSSProperty_block_size = 24,
        eCSSProperty_border_block_end_color = 25,
        eCSSProperty_border_block_end_style = 26,
        eCSSProperty_border_block_end_width = 27,
        eCSSProperty_border_block_start_color = 28,
        eCSSProperty_border_block_start_style = 29,
        eCSSProperty_border_block_start_width = 30,
        eCSSProperty_border_bottom_color = 31,
        eCSSProperty__moz_border_bottom_colors = 32,
        eCSSProperty_border_bottom_left_radius = 33,
        eCSSProperty_border_bottom_right_radius = 34,
        eCSSProperty_border_bottom_style = 35,
        eCSSProperty_border_bottom_width = 36,
        eCSSProperty_border_collapse = 37,
        eCSSProperty_border_image_outset = 38,
        eCSSProperty_border_image_repeat = 39,
        eCSSProperty_border_image_slice = 40,
        eCSSProperty_border_image_source = 41,
        eCSSProperty_border_image_width = 42,
        eCSSProperty_border_inline_end_color = 43,
        eCSSProperty_border_inline_end_style = 44,
        eCSSProperty_border_inline_end_width = 45,
        eCSSProperty_border_inline_start_color = 46,
        eCSSProperty_border_inline_start_style = 47,
        eCSSProperty_border_inline_start_width = 48,
        eCSSProperty_border_left_color = 49,
        eCSSProperty__moz_border_left_colors = 50,
        eCSSProperty_border_left_style = 51,
        eCSSProperty_border_left_width = 52,
        eCSSProperty_border_right_color = 53,
        eCSSProperty__moz_border_right_colors = 54,
        eCSSProperty_border_right_style = 55,
        eCSSProperty_border_right_width = 56,
        eCSSProperty_border_spacing = 57,
        eCSSProperty_border_top_color = 58,
        eCSSProperty__moz_border_top_colors = 59,
        eCSSProperty_border_top_left_radius = 60,
        eCSSProperty_border_top_right_radius = 61,
        eCSSProperty_border_top_style = 62,
        eCSSProperty_border_top_width = 63,
        eCSSProperty_bottom = 64,
        eCSSProperty__moz_box_align = 65,
        eCSSProperty_box_decoration_break = 66,
        eCSSProperty__moz_box_direction = 67,
        eCSSProperty__moz_box_flex = 68,
        eCSSProperty__moz_box_ordinal_group = 69,
        eCSSProperty__moz_box_orient = 70,
        eCSSProperty__moz_box_pack = 71,
        eCSSProperty_box_shadow = 72,
        eCSSProperty_box_sizing = 73,
        eCSSProperty_caption_side = 74,
        eCSSProperty_caret_color = 75,
        eCSSProperty_clear = 76,
        eCSSProperty_clip = 77,
        eCSSProperty_clip_path = 78,
        eCSSProperty_clip_rule = 79,
        eCSSProperty_color = 80,
        eCSSProperty_color_adjust = 81,
        eCSSProperty_color_interpolation = 82,
        eCSSProperty_color_interpolation_filters = 83,
        eCSSProperty_column_count = 84,
        eCSSProperty_column_fill = 85,
        eCSSProperty_column_gap = 86,
        eCSSProperty_column_rule_color = 87,
        eCSSProperty_column_rule_style = 88,
        eCSSProperty_column_rule_width = 89,
        eCSSProperty_column_width = 90,
        eCSSProperty_contain = 91,
        eCSSProperty_content = 92,
        eCSSProperty__moz_control_character_visibility = 93,
        eCSSProperty_counter_increment = 94,
        eCSSProperty_counter_reset = 95,
        eCSSProperty_cursor = 96,
        eCSSProperty_direction = 97,
        eCSSProperty_display = 98,
        eCSSProperty_dominant_baseline = 99,
        eCSSProperty_empty_cells = 100,
        eCSSProperty_fill = 101,
        eCSSProperty_fill_opacity = 102,
        eCSSProperty_fill_rule = 103,
        eCSSProperty_filter = 104,
        eCSSProperty_flex_basis = 105,
        eCSSProperty_flex_direction = 106,
        eCSSProperty_flex_grow = 107,
        eCSSProperty_flex_shrink = 108,
        eCSSProperty_flex_wrap = 109,
        eCSSProperty_float_ = 110,
        eCSSProperty__moz_float_edge = 111,
        eCSSProperty_flood_color = 112,
        eCSSProperty_flood_opacity = 113,
        eCSSProperty_font_family = 114,
        eCSSProperty_font_feature_settings = 115,
        eCSSProperty_font_kerning = 116,
        eCSSProperty_font_language_override = 117,
        eCSSProperty_font_size = 118,
        eCSSProperty_font_size_adjust = 119,
        eCSSProperty_font_stretch = 120,
        eCSSProperty_font_style = 121,
        eCSSProperty_font_synthesis = 122,
        eCSSProperty_font_variant_alternates = 123,
        eCSSProperty_font_variant_caps = 124,
        eCSSProperty_font_variant_east_asian = 125,
        eCSSProperty_font_variant_ligatures = 126,
        eCSSProperty_font_variant_numeric = 127,
        eCSSProperty_font_variant_position = 128,
        eCSSProperty_font_variation_settings = 129,
        eCSSProperty_font_weight = 130,
        eCSSProperty__moz_force_broken_image_icon = 131,
        eCSSProperty_grid_auto_columns = 132,
        eCSSProperty_grid_auto_flow = 133,
        eCSSProperty_grid_auto_rows = 134,
        eCSSProperty_grid_column_end = 135,
        eCSSProperty_grid_column_gap = 136,
        eCSSProperty_grid_column_start = 137,
        eCSSProperty_grid_row_end = 138,
        eCSSProperty_grid_row_gap = 139,
        eCSSProperty_grid_row_start = 140,
        eCSSProperty_grid_template_areas = 141,
        eCSSProperty_grid_template_columns = 142,
        eCSSProperty_grid_template_rows = 143,
        eCSSProperty_height = 144,
        eCSSProperty_hyphens = 145,
        eCSSProperty_initial_letter = 146,
        eCSSProperty_image_orientation = 147,
        eCSSProperty__moz_image_region = 148,
        eCSSProperty_image_rendering = 149,
        eCSSProperty_ime_mode = 150,
        eCSSProperty_inline_size = 151,
        eCSSProperty_isolation = 152,
        eCSSProperty_justify_content = 153,
        eCSSProperty_justify_items = 154,
        eCSSProperty_justify_self = 155,
        eCSSProperty__x_lang = 156,
        eCSSProperty_left = 157,
        eCSSProperty_letter_spacing = 158,
        eCSSProperty_lighting_color = 159,
        eCSSProperty_line_height = 160,
        eCSSProperty_list_style_image = 161,
        eCSSProperty_list_style_position = 162,
        eCSSProperty_list_style_type = 163,
        eCSSProperty_margin_block_end = 164,
        eCSSProperty_margin_block_start = 165,
        eCSSProperty_margin_bottom = 166,
        eCSSProperty_margin_inline_end = 167,
        eCSSProperty_margin_inline_start = 168,
        eCSSProperty_margin_left = 169,
        eCSSProperty_margin_right = 170,
        eCSSProperty_margin_top = 171,
        eCSSProperty_marker_end = 172,
        eCSSProperty_marker_mid = 173,
        eCSSProperty_marker_start = 174,
        eCSSProperty_mask_clip = 175,
        eCSSProperty_mask_composite = 176,
        eCSSProperty_mask_image = 177,
        eCSSProperty_mask_mode = 178,
        eCSSProperty_mask_origin = 179,
        eCSSProperty_mask_position_x = 180,
        eCSSProperty_mask_position_y = 181,
        eCSSProperty_mask_repeat = 182,
        eCSSProperty_mask_size = 183,
        eCSSProperty_mask_type = 184,
        eCSSProperty__moz_math_display = 185,
        eCSSProperty__moz_math_variant = 186,
        eCSSProperty_max_block_size = 187,
        eCSSProperty_max_height = 188,
        eCSSProperty_max_inline_size = 189,
        eCSSProperty_max_width = 190,
        eCSSProperty_min_block_size = 191,
        eCSSProperty__moz_min_font_size_ratio = 192,
        eCSSProperty_min_height = 193,
        eCSSProperty_min_inline_size = 194,
        eCSSProperty_min_width = 195,
        eCSSProperty_mix_blend_mode = 196,
        eCSSProperty_object_fit = 197,
        eCSSProperty_object_position = 198,
        eCSSProperty_offset_block_end = 199,
        eCSSProperty_offset_block_start = 200,
        eCSSProperty_offset_inline_end = 201,
        eCSSProperty_offset_inline_start = 202,
        eCSSProperty_opacity = 203,
        eCSSProperty_order = 204,
        eCSSProperty__moz_orient = 205,
        eCSSProperty__moz_osx_font_smoothing = 206,
        eCSSProperty_outline_color = 207,
        eCSSProperty_outline_offset = 208,
        eCSSProperty__moz_outline_radius_bottomleft = 209,
        eCSSProperty__moz_outline_radius_bottomright = 210,
        eCSSProperty__moz_outline_radius_topleft = 211,
        eCSSProperty__moz_outline_radius_topright = 212,
        eCSSProperty_outline_style = 213,
        eCSSProperty_outline_width = 214,
        eCSSProperty_overflow_clip_box = 215,
        eCSSProperty_overflow_x = 216,
        eCSSProperty_overflow_y = 217,
        eCSSProperty_padding_block_end = 218,
        eCSSProperty_padding_block_start = 219,
        eCSSProperty_padding_bottom = 220,
        eCSSProperty_padding_inline_end = 221,
        eCSSProperty_padding_inline_start = 222,
        eCSSProperty_padding_left = 223,
        eCSSProperty_padding_right = 224,
        eCSSProperty_padding_top = 225,
        eCSSProperty_page_break_after = 226,
        eCSSProperty_page_break_before = 227,
        eCSSProperty_page_break_inside = 228,
        eCSSProperty_paint_order = 229,
        eCSSProperty_perspective = 230,
        eCSSProperty_perspective_origin = 231,
        eCSSProperty_pointer_events = 232,
        eCSSProperty_position = 233,
        eCSSProperty_quotes = 234,
        eCSSProperty_resize = 235,
        eCSSProperty_right = 236,
        eCSSProperty_ruby_align = 237,
        eCSSProperty_ruby_position = 238,
        eCSSProperty__moz_script_level = 239,
        eCSSProperty__moz_script_min_size = 240,
        eCSSProperty__moz_script_size_multiplier = 241,
        eCSSProperty_scroll_behavior = 242,
        eCSSProperty_scroll_snap_coordinate = 243,
        eCSSProperty_scroll_snap_destination = 244,
        eCSSProperty_scroll_snap_points_x = 245,
        eCSSProperty_scroll_snap_points_y = 246,
        eCSSProperty_scroll_snap_type_x = 247,
        eCSSProperty_scroll_snap_type_y = 248,
        eCSSProperty_shape_outside = 249,
        eCSSProperty_shape_rendering = 250,
        eCSSProperty__x_span = 251,
        eCSSProperty__moz_stack_sizing = 252,
        eCSSProperty_stop_color = 253,
        eCSSProperty_stop_opacity = 254,
        eCSSProperty_stroke = 255,
        eCSSProperty_stroke_dasharray = 256,
        eCSSProperty_stroke_dashoffset = 257,
        eCSSProperty_stroke_linecap = 258,
        eCSSProperty_stroke_linejoin = 259,
        eCSSProperty_stroke_miterlimit = 260,
        eCSSProperty_stroke_opacity = 261,
        eCSSProperty_stroke_width = 262,
        eCSSProperty__x_system_font = 263,
        eCSSProperty__moz_tab_size = 264,
        eCSSProperty_table_layout = 265,
        eCSSProperty_text_align = 266,
        eCSSProperty_text_align_last = 267,
        eCSSProperty_text_anchor = 268,
        eCSSProperty_text_combine_upright = 269,
        eCSSProperty_text_decoration_color = 270,
        eCSSProperty_text_decoration_line = 271,
        eCSSProperty_text_decoration_style = 272,
        eCSSProperty_text_emphasis_color = 273,
        eCSSProperty_text_emphasis_position = 274,
        eCSSProperty_text_emphasis_style = 275,
        eCSSProperty__webkit_text_fill_color = 276,
        eCSSProperty_text_indent = 277,
        eCSSProperty_text_orientation = 278,
        eCSSProperty_text_overflow = 279,
        eCSSProperty_text_rendering = 280,
        eCSSProperty_text_shadow = 281,
        eCSSProperty__moz_text_size_adjust = 282,
        eCSSProperty__webkit_text_stroke_color = 283,
        eCSSProperty__webkit_text_stroke_width = 284,
        eCSSProperty_text_transform = 285,
        eCSSProperty__x_text_zoom = 286,
        eCSSProperty_top = 287,
        eCSSProperty__moz_top_layer = 288,
        eCSSProperty_touch_action = 289,
        eCSSProperty_transform = 290,
        eCSSProperty_transform_box = 291,
        eCSSProperty_transform_origin = 292,
        eCSSProperty_transform_style = 293,
        eCSSProperty_transition_delay = 294,
        eCSSProperty_transition_duration = 295,
        eCSSProperty_transition_property = 296,
        eCSSProperty_transition_timing_function = 297,
        eCSSProperty_unicode_bidi = 298,
        eCSSProperty__moz_user_focus = 299,
        eCSSProperty__moz_user_input = 300,
        eCSSProperty__moz_user_modify = 301,
        eCSSProperty__moz_user_select = 302,
        eCSSProperty_vector_effect = 303,
        eCSSProperty_vertical_align = 304,
        eCSSProperty_visibility = 305,
        eCSSProperty_white_space = 306,
        eCSSProperty_width = 307,
        eCSSProperty_will_change = 308,
        eCSSProperty__moz_window_dragging = 309,
        eCSSProperty__moz_window_shadow = 310,
        eCSSProperty_word_break = 311,
        eCSSProperty_word_spacing = 312,
        eCSSProperty_overflow_wrap = 313,
        eCSSProperty_writing_mode = 314,
        eCSSProperty_z_index = 315,
        eCSSProperty_COUNT_no_shorthands = 316,
        eCSSProperty_animation = 317,
        eCSSProperty_background = 318,
        eCSSProperty_background_position = 319,
        eCSSProperty_border = 320,
        eCSSProperty_border_block_end = 321,
        eCSSProperty_border_block_start = 322,
        eCSSProperty_border_bottom = 323,
        eCSSProperty_border_color = 324,
        eCSSProperty_border_image = 325,
        eCSSProperty_border_inline_end = 326,
        eCSSProperty_border_inline_start = 327,
        eCSSProperty_border_left = 328,
        eCSSProperty_border_radius = 329,
        eCSSProperty_border_right = 330,
        eCSSProperty_border_style = 331,
        eCSSProperty_border_top = 332,
        eCSSProperty_border_width = 333,
        eCSSProperty_column_rule = 334,
        eCSSProperty_columns = 335,
        eCSSProperty_flex = 336,
        eCSSProperty_flex_flow = 337,
        eCSSProperty_font = 338,
        eCSSProperty_font_variant = 339,
        eCSSProperty_grid = 340,
        eCSSProperty_grid_area = 341,
        eCSSProperty_grid_column = 342,
        eCSSProperty_grid_gap = 343,
        eCSSProperty_grid_row = 344,
        eCSSProperty_grid_template = 345,
        eCSSProperty_list_style = 346,
        eCSSProperty_margin = 347,
        eCSSProperty_marker = 348,
        eCSSProperty_mask = 349,
        eCSSProperty_mask_position = 350,
        eCSSProperty_outline = 351,
        eCSSProperty__moz_outline_radius = 352,
        eCSSProperty_overflow = 353,
        eCSSProperty_padding = 354,
        eCSSProperty_place_content = 355,
        eCSSProperty_place_items = 356,
        eCSSProperty_place_self = 357,
        eCSSProperty_scroll_snap_type = 358,
        eCSSProperty_text_decoration = 359,
        eCSSProperty_text_emphasis = 360,
        eCSSProperty__webkit_text_stroke = 361,
        eCSSProperty__moz_transform = 362,
        eCSSProperty_transition = 363,
        eCSSProperty_COUNT = 364,
        eCSSPropertyAlias_MozTransformOrigin = 365,
        eCSSPropertyAlias_MozPerspectiveOrigin = 366,
        eCSSPropertyAlias_MozPerspective = 367,
        eCSSPropertyAlias_MozTransformStyle = 368,
        eCSSPropertyAlias_MozBackfaceVisibility = 369,
        eCSSPropertyAlias_MozBorderImage = 370,
        eCSSPropertyAlias_MozTransition = 371,
        eCSSPropertyAlias_MozTransitionDelay = 372,
        eCSSPropertyAlias_MozTransitionDuration = 373,
        eCSSPropertyAlias_MozTransitionProperty = 374,
        eCSSPropertyAlias_MozTransitionTimingFunction = 375,
        eCSSPropertyAlias_MozAnimation = 376,
        eCSSPropertyAlias_MozAnimationDelay = 377,
        eCSSPropertyAlias_MozAnimationDirection = 378,
        eCSSPropertyAlias_MozAnimationDuration = 379,
        eCSSPropertyAlias_MozAnimationFillMode = 380,
        eCSSPropertyAlias_MozAnimationIterationCount = 381,
        eCSSPropertyAlias_MozAnimationName = 382,
        eCSSPropertyAlias_MozAnimationPlayState = 383,
        eCSSPropertyAlias_MozAnimationTimingFunction = 384,
        eCSSPropertyAlias_MozBoxSizing = 385,
        eCSSPropertyAlias_MozFontFeatureSettings = 386,
        eCSSPropertyAlias_MozFontLanguageOverride = 387,
        eCSSPropertyAlias_MozPaddingEnd = 388,
        eCSSPropertyAlias_MozPaddingStart = 389,
        eCSSPropertyAlias_MozMarginEnd = 390,
        eCSSPropertyAlias_MozMarginStart = 391,
        eCSSPropertyAlias_MozBorderEnd = 392,
        eCSSPropertyAlias_MozBorderEndColor = 393,
        eCSSPropertyAlias_MozBorderEndStyle = 394,
        eCSSPropertyAlias_MozBorderEndWidth = 395,
        eCSSPropertyAlias_MozBorderStart = 396,
        eCSSPropertyAlias_MozBorderStartColor = 397,
        eCSSPropertyAlias_MozBorderStartStyle = 398,
        eCSSPropertyAlias_MozBorderStartWidth = 399,
        eCSSPropertyAlias_MozHyphens = 400,
        eCSSPropertyAlias_MozColumnCount = 401,
        eCSSPropertyAlias_MozColumnFill = 402,
        eCSSPropertyAlias_MozColumnGap = 403,
        eCSSPropertyAlias_MozColumnRule = 404,
        eCSSPropertyAlias_MozColumnRuleColor = 405,
        eCSSPropertyAlias_MozColumnRuleStyle = 406,
        eCSSPropertyAlias_MozColumnRuleWidth = 407,
        eCSSPropertyAlias_MozColumnWidth = 408,
        eCSSPropertyAlias_MozColumns = 409,
        eCSSPropertyAlias_WebkitAnimation = 410,
        eCSSPropertyAlias_WebkitAnimationDelay = 411,
        eCSSPropertyAlias_WebkitAnimationDirection = 412,
        eCSSPropertyAlias_WebkitAnimationDuration = 413,
        eCSSPropertyAlias_WebkitAnimationFillMode = 414,
        eCSSPropertyAlias_WebkitAnimationIterationCount = 415,
        eCSSPropertyAlias_WebkitAnimationName = 416,
        eCSSPropertyAlias_WebkitAnimationPlayState = 417,
        eCSSPropertyAlias_WebkitAnimationTimingFunction = 418,
        eCSSPropertyAlias_WebkitFilter = 419,
        eCSSPropertyAlias_WebkitTextSizeAdjust = 420,
        eCSSPropertyAlias_WebkitTransform = 421,
        eCSSPropertyAlias_WebkitTransformOrigin = 422,
        eCSSPropertyAlias_WebkitTransformStyle = 423,
        eCSSPropertyAlias_WebkitBackfaceVisibility = 424,
        eCSSPropertyAlias_WebkitPerspective = 425,
        eCSSPropertyAlias_WebkitPerspectiveOrigin = 426,
        eCSSPropertyAlias_WebkitTransition = 427,
        eCSSPropertyAlias_WebkitTransitionDelay = 428,
        eCSSPropertyAlias_WebkitTransitionDuration = 429,
        eCSSPropertyAlias_WebkitTransitionProperty = 430,
        eCSSPropertyAlias_WebkitTransitionTimingFunction = 431,
        eCSSPropertyAlias_WebkitBorderRadius = 432,
        eCSSPropertyAlias_WebkitBorderTopLeftRadius = 433,
        eCSSPropertyAlias_WebkitBorderTopRightRadius = 434,
        eCSSPropertyAlias_WebkitBorderBottomLeftRadius = 435,
        eCSSPropertyAlias_WebkitBorderBottomRightRadius = 436,
        eCSSPropertyAlias_WebkitBackgroundClip = 437,
        eCSSPropertyAlias_WebkitBackgroundOrigin = 438,
        eCSSPropertyAlias_WebkitBackgroundSize = 439,
        eCSSPropertyAlias_WebkitBorderImage = 440,
        eCSSPropertyAlias_WebkitBoxShadow = 441,
        eCSSPropertyAlias_WebkitBoxSizing = 442,
        eCSSPropertyAlias_WebkitBoxFlex = 443,
        eCSSPropertyAlias_WebkitBoxOrdinalGroup = 444,
        eCSSPropertyAlias_WebkitBoxOrient = 445,
        eCSSPropertyAlias_WebkitBoxDirection = 446,
        eCSSPropertyAlias_WebkitBoxAlign = 447,
        eCSSPropertyAlias_WebkitBoxPack = 448,
        eCSSPropertyAlias_WebkitFlexDirection = 449,
        eCSSPropertyAlias_WebkitFlexWrap = 450,
        eCSSPropertyAlias_WebkitFlexFlow = 451,
        eCSSPropertyAlias_WebkitOrder = 452,
        eCSSPropertyAlias_WebkitFlex = 453,
        eCSSPropertyAlias_WebkitFlexGrow = 454,
        eCSSPropertyAlias_WebkitFlexShrink = 455,
        eCSSPropertyAlias_WebkitFlexBasis = 456,
        eCSSPropertyAlias_WebkitJustifyContent = 457,
        eCSSPropertyAlias_WebkitAlignItems = 458,
        eCSSPropertyAlias_WebkitAlignSelf = 459,
        eCSSPropertyAlias_WebkitAlignContent = 460,
        eCSSPropertyAlias_WebkitUserSelect = 461,
        eCSSPropertyAlias_WebkitMask = 462,
        eCSSPropertyAlias_WebkitMaskClip = 463,
        eCSSPropertyAlias_WebkitMaskComposite = 464,
        eCSSPropertyAlias_WebkitMaskImage = 465,
        eCSSPropertyAlias_WebkitMaskOrigin = 466,
        eCSSPropertyAlias_WebkitMaskPosition = 467,
        eCSSPropertyAlias_WebkitMaskPositionX = 468,
        eCSSPropertyAlias_WebkitMaskPositionY = 469,
        eCSSPropertyAlias_WebkitMaskRepeat = 470,
        eCSSPropertyAlias_WebkitMaskSize = 471,
        eCSSProperty_COUNT_with_aliases = 472,
        eCSSPropertyExtra_all_properties = 473,
        eCSSPropertyExtra_x_none_value = 474,
        eCSSPropertyExtra_x_auto_value = 475,
        eCSSPropertyExtra_variable = 476,
        eCSSProperty_DOM = 477,
    }
    /**
 * Class to safely handle main-thread-only pointers off the main thread.
 *
 * Classes like XPCWrappedJS are main-thread-only, which means that it is
 * forbidden to call methods on instances of these classes off the main thread.
 * For various reasons (see bug 771074), this restriction recently began to
 * apply to AddRef/Release as well.
 *
 * This presents a problem for consumers that wish to hold a callback alive
 * on non-main-thread code. A common example of this is the proxy callback
 * pattern, where non-main-thread code holds a strong-reference to the callback
 * object, and dispatches new Runnables (also with a strong reference) to the
 * main thread in order to execute the callback. This involves several AddRef
 * and Release calls on the other thread, which is (now) verboten.
 *
 * The basic idea of this class is to introduce a layer of indirection.
 * nsMainThreadPtrHolder is a threadsafe reference-counted class that internally
 * maintains one strong reference to the main-thread-only object. It must be
 * instantiated on the main thread (so that the AddRef of the underlying object
 * happens on the main thread), but consumers may subsequently pass references
 * to the holder anywhere they please. These references are meant to be opaque
 * when accessed off-main-thread (assertions enforce this).
 *
 * The semantics of RefPtr<nsMainThreadPtrHolder<T> > would be cumbersome, so
 * we also introduce nsMainThreadPtrHandle<T>, which is conceptually identical
 * to the above (though it includes various convenience methods). The basic
 * pattern is as follows.
 *
 * // On the main thread:
 * nsCOMPtr<nsIFooCallback> callback = ...;
 * nsMainThreadPtrHandle<nsIFooCallback> callbackHandle =
 *   new nsMainThreadPtrHolder<nsIFooCallback>(callback);
 * // Pass callbackHandle to structs/classes that might be accessed on other
 * // threads.
 *
 * All structs and classes that might be accessed on other threads should store
 * an nsMainThreadPtrHandle<T> rather than an nsCOMPtr<T>.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMainThreadPtrHolder<T> {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mRawPtr: *mut T,
        pub mStrict: bool,
    }
    pub type nsMainThreadPtrHolder_HasThreadSafeRefCnt =
        root::mozilla::TrueType;
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsMainThreadPtrHandle<T> {
        pub mPtr: root::RefPtr<T>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct imgRequestProxy {
        pub _base: root::imgIRequest,
        pub _base_1: root::mozilla::image::IProgressObserver,
        pub _base_2: root::nsISupportsPriority,
        pub _base_3: root::nsISecurityInfoProvider,
        pub _base_4: root::nsITimedChannel,
        pub mRefCnt: root::nsAutoRefCnt,
        pub mBehaviour: root::mozilla::UniquePtr<root::ProxyBehaviour,
                                                 root::mozilla::DefaultDelete<root::ProxyBehaviour>>,
        pub mURI: root::RefPtr<root::mozilla::image::ImageURL>,
        pub mListener: *mut root::imgINotificationObserver,
        pub mLoadGroup: root::nsCOMPtr<root::nsILoadGroup>,
        pub mLoadFlags: root::nsLoadFlags,
        pub mLockCount: u32,
        pub mAnimationConsumers: u32,
        pub mCanceled: bool,
        pub mIsInLoadGroup: bool,
        pub mListenerIsStrongRef: bool,
        pub mDecodeRequested: bool,
        pub mDeferNotifications: bool,
    }
    pub type imgRequestProxy_Image = root::mozilla::image::Image;
    pub type imgRequestProxy_ImageURL = root::mozilla::image::ImageURL;
    pub type imgRequestProxy_ProgressTracker =
        root::mozilla::image::ProgressTracker;
    pub type imgRequestProxy_HasThreadSafeRefCnt = root::mozilla::FalseType;
    #[repr(C)]
    #[derive(Debug)]
    pub struct imgRequestProxy_imgCancelRunnable {
        pub _base: root::mozilla::Runnable,
        pub mOwner: root::RefPtr<root::imgRequestProxy>,
        pub mStatus: root::nsresult,
    }
    #[test]
    fn bindgen_test_layout_imgRequestProxy_imgCancelRunnable() {
        assert_eq!(::std::mem::size_of::<imgRequestProxy_imgCancelRunnable>()
                   , 48usize);
        assert_eq!(::std::mem::align_of::<imgRequestProxy_imgCancelRunnable>()
                   , 8usize);
    }
    #[test]
    fn bindgen_test_layout_imgRequestProxy() {
        assert_eq!(::std::mem::size_of::<imgRequestProxy>() , 112usize);
        assert_eq!(::std::mem::align_of::<imgRequestProxy>() , 8usize);
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSUnit {
        eCSSUnit_Null = 0,
        eCSSUnit_Auto = 1,
        eCSSUnit_Inherit = 2,
        eCSSUnit_Initial = 3,
        eCSSUnit_Unset = 4,
        eCSSUnit_None = 5,
        eCSSUnit_Normal = 6,
        eCSSUnit_System_Font = 7,
        eCSSUnit_All = 8,
        eCSSUnit_Dummy = 9,
        eCSSUnit_DummyInherit = 10,
        eCSSUnit_String = 11,
        eCSSUnit_Ident = 12,
        eCSSUnit_Attr = 14,
        eCSSUnit_Local_Font = 15,
        eCSSUnit_Font_Format = 16,
        eCSSUnit_Element = 17,
        eCSSUnit_Array = 20,
        eCSSUnit_Counter = 21,
        eCSSUnit_Counters = 22,
        eCSSUnit_Cubic_Bezier = 23,
        eCSSUnit_Steps = 24,
        eCSSUnit_Symbols = 25,
        eCSSUnit_Function = 26,
        eCSSUnit_Calc = 30,
        eCSSUnit_Calc_Plus = 31,
        eCSSUnit_Calc_Minus = 32,
        eCSSUnit_Calc_Times_L = 33,
        eCSSUnit_Calc_Times_R = 34,
        eCSSUnit_Calc_Divided = 35,
        eCSSUnit_URL = 40,
        eCSSUnit_Image = 41,
        eCSSUnit_Gradient = 42,
        eCSSUnit_TokenStream = 43,
        eCSSUnit_GridTemplateAreas = 44,
        eCSSUnit_Pair = 50,
        eCSSUnit_Triplet = 51,
        eCSSUnit_Rect = 52,
        eCSSUnit_List = 53,
        eCSSUnit_ListDep = 54,
        eCSSUnit_SharedList = 55,
        eCSSUnit_PairList = 56,
        eCSSUnit_PairListDep = 57,
        eCSSUnit_FontFamilyList = 58,
        eCSSUnit_Integer = 70,
        eCSSUnit_Enumerated = 71,
        eCSSUnit_EnumColor = 80,
        eCSSUnit_RGBColor = 81,
        eCSSUnit_RGBAColor = 82,
        eCSSUnit_HexColor = 83,
        eCSSUnit_ShortHexColor = 84,
        eCSSUnit_HexColorAlpha = 85,
        eCSSUnit_ShortHexColorAlpha = 86,
        eCSSUnit_PercentageRGBColor = 87,
        eCSSUnit_PercentageRGBAColor = 88,
        eCSSUnit_HSLColor = 89,
        eCSSUnit_HSLAColor = 90,
        eCSSUnit_ComplexColor = 91,
        eCSSUnit_Percent = 100,
        eCSSUnit_Number = 101,
        eCSSUnit_PhysicalMillimeter = 200,
        eCSSUnit_ViewportWidth = 700,
        eCSSUnit_ViewportHeight = 701,
        eCSSUnit_ViewportMin = 702,
        eCSSUnit_ViewportMax = 703,
        eCSSUnit_EM = 800,
        eCSSUnit_XHeight = 801,
        eCSSUnit_Char = 802,
        eCSSUnit_RootEM = 803,
        eCSSUnit_Point = 900,
        eCSSUnit_Inch = 901,
        eCSSUnit_Millimeter = 902,
        eCSSUnit_Centimeter = 903,
        eCSSUnit_Pica = 904,
        eCSSUnit_Quarter = 905,
        eCSSUnit_Pixel = 906,
        eCSSUnit_Degree = 1000,
        eCSSUnit_Grad = 1001,
        eCSSUnit_Radian = 1002,
        eCSSUnit_Turn = 1003,
        eCSSUnit_Hertz = 2000,
        eCSSUnit_Kilohertz = 2001,
        eCSSUnit_Seconds = 3000,
        eCSSUnit_Milliseconds = 3001,
        eCSSUnit_FlexFraction = 4000,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueGradient {
        pub mIsRadial: bool,
        pub mIsRepeating: bool,
        pub mIsLegacySyntax: bool,
        pub mIsExplicitSize: bool,
        pub mBgPos: root::nsCSSValuePair,
        pub mAngle: root::nsCSSValue,
        pub mRadialValues: [root::nsCSSValue; 2usize],
        pub mStops: root::nsTArray<root::nsCSSValueGradientStop>,
        pub mRefCnt: root::nsAutoRefCnt,
    }
    pub type nsCSSValueGradient_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValueGradient() {
        assert_eq!(::std::mem::size_of::<nsCSSValueGradient>() , 104usize);
        assert_eq!(::std::mem::align_of::<nsCSSValueGradient>() , 8usize);
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum Serialization { eNormalized = 0, eAuthorSpecified = 1, }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValuePair {
        pub mXValue: root::nsCSSValue,
        pub mYValue: root::nsCSSValue,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValuePair() {
        assert_eq!(::std::mem::size_of::<nsCSSValuePair>() , 32usize);
        assert_eq!(::std::mem::align_of::<nsCSSValuePair>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValuePair_heap {
        pub _base: root::nsCSSValuePair,
        pub mRefCnt: root::nsAutoRefCnt,
    }
    pub type nsCSSValuePair_heap_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValuePair_heap() {
        assert_eq!(::std::mem::size_of::<nsCSSValuePair_heap>() , 40usize);
        assert_eq!(::std::mem::align_of::<nsCSSValuePair_heap>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueTokenStream {
        pub mRefCnt: root::nsAutoRefCnt,
        pub mPropertyID: root::nsCSSPropertyID,
        pub mShorthandPropertyID: root::nsCSSPropertyID,
        pub mTokenStream: ::nsstring::nsStringRepr,
        pub mBaseURI: root::nsCOMPtr<root::nsIURI>,
        pub mSheetURI: root::nsCOMPtr<root::nsIURI>,
        pub mSheetPrincipal: root::nsCOMPtr<root::nsIPrincipal>,
        pub mLineNumber: u32,
        pub mLineOffset: u32,
        pub mLevel: root::mozilla::SheetType,
    }
    pub type nsCSSValueTokenStream_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValueTokenStream() {
        assert_eq!(::std::mem::size_of::<nsCSSValueTokenStream>() , 72usize);
        assert_eq!(::std::mem::align_of::<nsCSSValueTokenStream>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSRect {
        pub mTop: root::nsCSSValue,
        pub mRight: root::nsCSSValue,
        pub mBottom: root::nsCSSValue,
        pub mLeft: root::nsCSSValue,
    }
    pub type nsCSSRect_side_type = *mut root::nsCSSValue;
    extern "C" {
        #[link_name = "_ZN9nsCSSRect5sidesE"]
        pub static mut nsCSSRect_sides: [root::nsCSSRect_side_type; 4usize];
    }
    #[test]
    fn bindgen_test_layout_nsCSSRect() {
        assert_eq!(::std::mem::size_of::<nsCSSRect>() , 64usize);
        assert_eq!(::std::mem::align_of::<nsCSSRect>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSRect_heap {
        pub _base: root::nsCSSRect,
        pub mRefCnt: root::nsAutoRefCnt,
    }
    pub type nsCSSRect_heap_HasThreadSafeRefCnt = root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSRect_heap() {
        assert_eq!(::std::mem::size_of::<nsCSSRect_heap>() , 72usize);
        assert_eq!(::std::mem::align_of::<nsCSSRect_heap>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueList {
        pub mValue: root::nsCSSValue,
        pub mNext: *mut root::nsCSSValueList,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValueList() {
        assert_eq!(::std::mem::size_of::<nsCSSValueList>() , 24usize);
        assert_eq!(::std::mem::align_of::<nsCSSValueList>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueList_heap {
        pub _base: root::nsCSSValueList,
        pub mRefCnt: root::nsAutoRefCnt,
    }
    pub type nsCSSValueList_heap_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValueList_heap() {
        assert_eq!(::std::mem::size_of::<nsCSSValueList_heap>() , 32usize);
        assert_eq!(::std::mem::align_of::<nsCSSValueList_heap>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueSharedList {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mHead: *mut root::nsCSSValueList,
    }
    pub type nsCSSValueSharedList_HasThreadSafeRefCnt =
        root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsCSSValueSharedList() {
        assert_eq!(::std::mem::size_of::<nsCSSValueSharedList>() , 16usize);
        assert_eq!(::std::mem::align_of::<nsCSSValueSharedList>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValuePairList {
        pub mXValue: root::nsCSSValue,
        pub mYValue: root::nsCSSValue,
        pub mNext: *mut root::nsCSSValuePairList,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValuePairList() {
        assert_eq!(::std::mem::size_of::<nsCSSValuePairList>() , 40usize);
        assert_eq!(::std::mem::align_of::<nsCSSValuePairList>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValuePairList_heap {
        pub _base: root::nsCSSValuePairList,
        pub mRefCnt: root::nsAutoRefCnt,
    }
    pub type nsCSSValuePairList_heap_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValuePairList_heap() {
        assert_eq!(::std::mem::size_of::<nsCSSValuePairList_heap>() ,
                   48usize);
        assert_eq!(::std::mem::align_of::<nsCSSValuePairList_heap>() ,
                   8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueTriplet {
        pub mXValue: root::nsCSSValue,
        pub mYValue: root::nsCSSValue,
        pub mZValue: root::nsCSSValue,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValueTriplet() {
        assert_eq!(::std::mem::size_of::<nsCSSValueTriplet>() , 48usize);
        assert_eq!(::std::mem::align_of::<nsCSSValueTriplet>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueTriplet_heap {
        pub _base: root::nsCSSValueTriplet,
        pub mRefCnt: root::nsAutoRefCnt,
    }
    pub type nsCSSValueTriplet_heap_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValueTriplet_heap() {
        assert_eq!(::std::mem::size_of::<nsCSSValueTriplet_heap>() , 56usize);
        assert_eq!(::std::mem::align_of::<nsCSSValueTriplet_heap>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueFloatColor {
        pub mRefCnt: root::nsAutoRefCnt,
        pub mComponent1: f32,
        pub mComponent2: f32,
        pub mComponent3: f32,
        pub mAlpha: f32,
    }
    pub type nsCSSValueFloatColor_HasThreadSafeRefCnt =
        root::mozilla::FalseType;
    #[test]
    fn bindgen_test_layout_nsCSSValueFloatColor() {
        assert_eq!(::std::mem::size_of::<nsCSSValueFloatColor>() , 24usize);
        assert_eq!(::std::mem::align_of::<nsCSSValueFloatColor>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValue {
        pub mUnit: root::nsCSSUnit,
        pub mValue: root::nsCSSValue__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValue_Array {
        pub mRefCnt: usize,
        pub mCount: usize,
        pub mArray: [root::nsCSSValue; 1usize],
    }
    #[test]
    fn bindgen_test_layout_nsCSSValue_Array() {
        assert_eq!(::std::mem::size_of::<nsCSSValue_Array>() , 32usize);
        assert_eq!(::std::mem::align_of::<nsCSSValue_Array>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsCSSValue__bindgen_ty_1 {
        pub mInt: root::__BindgenUnionField<i32>,
        pub mFloat: root::__BindgenUnionField<f32>,
        pub mString: root::__BindgenUnionField<*mut root::nsStringBuffer>,
        pub mColor: root::__BindgenUnionField<root::nscolor>,
        pub mArray: root::__BindgenUnionField<*mut root::nsCSSValue_Array>,
        pub mURL: root::__BindgenUnionField<*mut root::mozilla::css::URLValue>,
        pub mImage: root::__BindgenUnionField<*mut root::mozilla::css::ImageValue>,
        pub mGridTemplateAreas: root::__BindgenUnionField<*mut root::mozilla::css::GridTemplateAreasValue>,
        pub mGradient: root::__BindgenUnionField<*mut root::nsCSSValueGradient>,
        pub mTokenStream: root::__BindgenUnionField<*mut root::nsCSSValueTokenStream>,
        pub mPair: root::__BindgenUnionField<*mut root::nsCSSValuePair_heap>,
        pub mRect: root::__BindgenUnionField<*mut root::nsCSSRect_heap>,
        pub mTriplet: root::__BindgenUnionField<*mut root::nsCSSValueTriplet_heap>,
        pub mList: root::__BindgenUnionField<*mut root::nsCSSValueList_heap>,
        pub mListDependent: root::__BindgenUnionField<*mut root::nsCSSValueList>,
        pub mSharedList: root::__BindgenUnionField<*mut root::nsCSSValueSharedList>,
        pub mPairList: root::__BindgenUnionField<*mut root::nsCSSValuePairList_heap>,
        pub mPairListDependent: root::__BindgenUnionField<*mut root::nsCSSValuePairList>,
        pub mFloatColor: root::__BindgenUnionField<*mut root::nsCSSValueFloatColor>,
        pub mFontFamilyList: root::__BindgenUnionField<*mut root::mozilla::css::FontFamilyListRefCnt>,
        pub mComplexColor: root::__BindgenUnionField<*mut root::mozilla::css::ComplexColorValue>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValue__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsCSSValue__bindgen_ty_1>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<nsCSSValue__bindgen_ty_1>() ,
                   8usize);
    }
    impl Clone for nsCSSValue__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsCSSValue() {
        assert_eq!(::std::mem::size_of::<nsCSSValue>() , 16usize);
        assert_eq!(::std::mem::align_of::<nsCSSValue>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSValueGradientStop {
        pub mLocation: root::nsCSSValue,
        pub mColor: root::nsCSSValue,
        pub mIsInterpolationHint: bool,
    }
    #[test]
    fn bindgen_test_layout_nsCSSValueGradientStop() {
        assert_eq!(::std::mem::size_of::<nsCSSValueGradientStop>() , 40usize);
        assert_eq!(::std::mem::align_of::<nsCSSValueGradientStop>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct RawServoStyleSet {
        pub _address: u8,
    }
    impl Clone for RawServoStyleSet {
        fn clone(&self) -> Self { *self }
    }
    pub type RawGeckoNode = root::nsINode;
    pub type RawGeckoElement = root::mozilla::dom::Element;
    pub type RawGeckoDocument = root::nsIDocument;
    pub type RawGeckoNodeBorrowed = *const root::RawGeckoNode;
    pub type RawGeckoNodeBorrowedOrNull = *const root::RawGeckoNode;
    pub type RawGeckoElementBorrowed = *const root::RawGeckoElement;
    pub type RawGeckoElementBorrowedOrNull = *const root::RawGeckoElement;
    pub type RawGeckoDocumentBorrowed = *const root::RawGeckoDocument;
    pub type RawGeckoDocumentBorrowedOrNull = *const root::RawGeckoDocument;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsCSSTokenSerializationType {
        eCSSTokenSerialization_Nothing = 0,
        eCSSTokenSerialization_Whitespace = 1,
        eCSSTokenSerialization_AtKeyword_or_Hash = 2,
        eCSSTokenSerialization_Number = 3,
        eCSSTokenSerialization_Dimension = 4,
        eCSSTokenSerialization_Percentage = 5,
        eCSSTokenSerialization_URange = 6,
        eCSSTokenSerialization_URL_or_BadURL = 7,
        eCSSTokenSerialization_Function = 8,
        eCSSTokenSerialization_Ident = 9,
        eCSSTokenSerialization_CDC = 10,
        eCSSTokenSerialization_DashMatch = 11,
        eCSSTokenSerialization_ContainsMatch = 12,
        eCSSTokenSerialization_Symbol_Hash = 13,
        eCSSTokenSerialization_Symbol_At = 14,
        eCSSTokenSerialization_Symbol_Dot_or_Plus = 15,
        eCSSTokenSerialization_Symbol_Minus = 16,
        eCSSTokenSerialization_Symbol_OpenParen = 17,
        eCSSTokenSerialization_Symbol_Question = 18,
        eCSSTokenSerialization_Symbol_Assorted = 19,
        eCSSTokenSerialization_Symbol_Equals = 20,
        eCSSTokenSerialization_Symbol_Bar = 21,
        eCSSTokenSerialization_Symbol_Slash = 22,
        eCSSTokenSerialization_Symbol_Asterisk = 23,
        eCSSTokenSerialization_Other = 24,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct LookAndFeelInt {
        pub id: i32,
        pub value: i32,
    }
    #[test]
    fn bindgen_test_layout_LookAndFeelInt() {
        assert_eq!(::std::mem::size_of::<LookAndFeelInt>() , 8usize);
        assert_eq!(::std::mem::align_of::<LookAndFeelInt>() , 4usize);
    }
    impl Clone for LookAndFeelInt {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct imgIContainer {
        pub _address: u8,
    }
    impl Clone for imgIContainer {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsISecurityInfoProvider {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISecurityInfoProvider_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsISecurityInfoProvider() {
        assert_eq!(::std::mem::size_of::<nsISecurityInfoProvider>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsISecurityInfoProvider>() ,
                   8usize);
    }
    impl Clone for nsISecurityInfoProvider {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsISupportsPriority {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISupportsPriority_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    pub const nsISupportsPriority_PRIORITY_HIGHEST:
              root::nsISupportsPriority__bindgen_ty_1 =
        nsISupportsPriority__bindgen_ty_1::PRIORITY_HIGHEST;
    pub const nsISupportsPriority_PRIORITY_HIGH:
              root::nsISupportsPriority__bindgen_ty_1 =
        nsISupportsPriority__bindgen_ty_1::PRIORITY_HIGH;
    pub const nsISupportsPriority_PRIORITY_NORMAL:
              root::nsISupportsPriority__bindgen_ty_1 =
        nsISupportsPriority__bindgen_ty_1::PRIORITY_NORMAL;
    pub const nsISupportsPriority_PRIORITY_LOW:
              root::nsISupportsPriority__bindgen_ty_1 =
        nsISupportsPriority__bindgen_ty_1::PRIORITY_LOW;
    pub const nsISupportsPriority_PRIORITY_LOWEST:
              root::nsISupportsPriority__bindgen_ty_1 =
        nsISupportsPriority__bindgen_ty_1::PRIORITY_LOWEST;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsISupportsPriority__bindgen_ty_1 {
        PRIORITY_HIGHEST = -20,
        PRIORITY_HIGH = -10,
        PRIORITY_NORMAL = 0,
        PRIORITY_LOW = 10,
        PRIORITY_LOWEST = 20,
    }
    #[test]
    fn bindgen_test_layout_nsISupportsPriority() {
        assert_eq!(::std::mem::size_of::<nsISupportsPriority>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsISupportsPriority>() , 8usize);
    }
    impl Clone for nsISupportsPriority {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsITimedChannel {
        pub _base: root::nsISupports,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsITimedChannel_COMTypeInfo<T, U> {
        pub _address: u8,
        pub _phantom_0: ::std::marker::PhantomData<T>,
        pub _phantom_1: ::std::marker::PhantomData<U>,
    }
    #[test]
    fn bindgen_test_layout_nsITimedChannel() {
        assert_eq!(::std::mem::size_of::<nsITimedChannel>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsITimedChannel>() , 8usize);
    }
    impl Clone for nsITimedChannel {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct ProxyBehaviour {
        pub _address: u8,
    }
    impl Clone for ProxyBehaviour {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleVisibility {
        pub mImageOrientation: root::nsStyleImageOrientation,
        pub mDirection: u8,
        pub mVisible: u8,
        pub mImageRendering: u8,
        pub mWritingMode: u8,
        pub mTextOrientation: u8,
        pub mColorAdjust: u8,
    }
    #[test]
    fn bindgen_test_layout_nsStyleVisibility() {
        assert_eq!(::std::mem::size_of::<nsStyleVisibility>() , 7usize);
        assert_eq!(::std::mem::align_of::<nsStyleVisibility>() , 1usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleFont {
        pub mFont: root::nsFont,
        pub mSize: root::nscoord,
        pub mGenericID: u8,
        pub mScriptLevel: i8,
        pub mMathVariant: u8,
        pub mMathDisplay: u8,
        pub mMinFontSizeRatio: u8,
        pub mExplicitLanguage: bool,
        pub mAllowZoom: bool,
        pub mScriptUnconstrainedSize: root::nscoord,
        pub mScriptMinSize: root::nscoord,
        pub mScriptSizeMultiplier: f32,
        pub mLanguage: root::nsCOMPtr<root::nsIAtom>,
    }
    #[test]
    fn bindgen_test_layout_nsStyleFont() {
        assert_eq!(::std::mem::size_of::<nsStyleFont>() , 128usize);
        assert_eq!(::std::mem::align_of::<nsStyleFont>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleGradientStop {
        pub mLocation: root::nsStyleCoord,
        pub mColor: root::nscolor,
        pub mIsInterpolationHint: bool,
    }
    #[test]
    fn bindgen_test_layout_nsStyleGradientStop() {
        assert_eq!(::std::mem::size_of::<nsStyleGradientStop>() , 24usize);
        assert_eq!(::std::mem::align_of::<nsStyleGradientStop>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleGradient {
        pub mShape: u8,
        pub mSize: u8,
        pub mRepeating: bool,
        pub mLegacySyntax: bool,
        pub mBgPosX: root::nsStyleCoord,
        pub mBgPosY: root::nsStyleCoord,
        pub mAngle: root::nsStyleCoord,
        pub mRadiusX: root::nsStyleCoord,
        pub mRadiusY: root::nsStyleCoord,
        pub mStops: root::nsTArray<root::nsStyleGradientStop>,
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
    }
    pub type nsStyleGradient_HasThreadSafeRefCnt = root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsStyleGradient() {
        assert_eq!(::std::mem::size_of::<nsStyleGradient>() , 104usize);
        assert_eq!(::std::mem::align_of::<nsStyleGradient>() , 8usize);
    }
    /**
 * A wrapper for an imgRequestProxy that supports off-main-thread creation
 * and equality comparison.
 *
 * An nsStyleImageRequest can be created in two ways:
 *
 * 1. Using the constructor that takes an imgRequestProxy.  This must
 *    be called from the main thread.  The nsStyleImageRequest is
 *    immediately considered "resolved", and the get() method that
 *    returns the imgRequestProxy can be called.
 *
 * 2. Using the constructor that takes the URL, base URI, referrer
 *    and principal that can be used to inititiate an image load and
 *    produce an imgRequestProxy later.  This can be called from
 *    any thread.  The nsStyleImageRequest is not considered "resolved"
 *    at this point, and the Resolve() method must be called later
 *    to initiate the image load and make calls to get() valid.
 *
 * Calls to TrackImage(), UntrackImage(), LockImage(), UnlockImage() and
 * RequestDiscard() are made to the imgRequestProxy and ImageTracker as
 * appropriate, according to the mode flags passed in to the constructor.
 *
 * The main thread constructor takes a pointer to the css::ImageValue that
 * is the specified url() value, while the off-main-thread constructor
 * creates a new css::ImageValue to represent the url() information passed
 * to the constructor.  This ImageValue is held on to for the comparisons done
 * in DefinitelyEquals(), so that we don't need to call into the non-OMT-safe
 * Equals() on the nsIURI objects returned from imgRequestProxy::GetURI().
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleImageRequest {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mRequestProxy: root::RefPtr<root::imgRequestProxy>,
        pub mImageValue: root::RefPtr<root::mozilla::css::ImageValue>,
        pub mImageTracker: root::RefPtr<root::mozilla::dom::ImageTracker>,
        pub mModeFlags: root::nsStyleImageRequest_Mode,
        pub mResolved: bool,
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageRequest_Mode { Track = 1, Discard = 2, }
    pub type nsStyleImageRequest_HasThreadSafeRefCnt =
        root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsStyleImageRequest() {
        assert_eq!(::std::mem::size_of::<nsStyleImageRequest>() , 40usize);
        assert_eq!(::std::mem::align_of::<nsStyleImageRequest>() , 8usize);
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageType {
        eStyleImageType_Null = 0,
        eStyleImageType_Image = 1,
        eStyleImageType_Gradient = 2,
        eStyleImageType_Element = 3,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct CachedBorderImageData {
        pub mCachedSVGViewportSize: [u64; 2usize],
        pub mSubImages: root::nsCOMArray<root::imgIContainer>,
    }
    #[test]
    fn bindgen_test_layout_CachedBorderImageData() {
        assert_eq!(::std::mem::size_of::<CachedBorderImageData>() , 24usize);
        assert_eq!(::std::mem::align_of::<CachedBorderImageData>() , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_8() {
        assert_eq!(::std::mem::size_of::<root::mozilla::UniquePtr<root::nsStyleSides,
                                               root::mozilla::DefaultDelete<root::nsStyleSides>>>()
                   , 8usize);
        assert_eq!(::std::mem::align_of::<root::mozilla::UniquePtr<root::nsStyleSides,
                                                root::mozilla::DefaultDelete<root::nsStyleSides>>>()
                   , 8usize);
    }
    /**
 * Represents a paintable image of one of the following types.
 * (1) A real image loaded from an external source.
 * (2) A CSS linear or radial gradient.
 * (3) An element within a document, or an <img>, <video>, or <canvas> element
 *     not in a document.
 * (*) Optionally a crop rect can be set to paint a partial (rectangular)
 * region of an image. (Currently, this feature is only supported with an
 * image of type (1)).
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleImage {
        pub mCachedBIData: root::mozilla::UniquePtr<root::CachedBorderImageData,
                                                    root::mozilla::DefaultDelete<root::CachedBorderImageData>>,
        pub mType: root::nsStyleImageType,
        pub __bindgen_anon_1: root::nsStyleImage__bindgen_ty_1,
        pub mCropRect: root::mozilla::UniquePtr<root::nsStyleSides,
                                                root::mozilla::DefaultDelete<root::nsStyleSides>>,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleImage__bindgen_ty_1 {
        pub mImage: root::__BindgenUnionField<*mut root::nsStyleImageRequest>,
        pub mGradient: root::__BindgenUnionField<*mut root::nsStyleGradient>,
        pub mElementId: root::__BindgenUnionField<*mut u16>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsStyleImage__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleImage__bindgen_ty_1>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<nsStyleImage__bindgen_ty_1>() ,
                   8usize);
    }
    impl Clone for nsStyleImage__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsStyleImage() {
        assert_eq!(::std::mem::size_of::<nsStyleImage>() , 32usize);
        assert_eq!(::std::mem::align_of::<nsStyleImage>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleColor {
        pub mColor: root::nscolor,
    }
    #[test]
    fn bindgen_test_layout_nsStyleColor() {
        assert_eq!(::std::mem::size_of::<nsStyleColor>() , 4usize);
        assert_eq!(::std::mem::align_of::<nsStyleColor>() , 4usize);
    }
    /**
 * An array of objects, similar to AutoTArray<T,1> but which is memmovable. It
 * always has length >= 1.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleAutoArray<T> {
        pub mFirstElement: T,
        pub mOtherElements: root::nsTArray<T>,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleAutoArray_WithSingleInitialElement {
        WITH_SINGLE_INITIAL_ELEMENT = 0,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleImageLayers {
        pub mAttachmentCount: u32,
        pub mClipCount: u32,
        pub mOriginCount: u32,
        pub mRepeatCount: u32,
        pub mPositionXCount: u32,
        pub mPositionYCount: u32,
        pub mImageCount: u32,
        pub mSizeCount: u32,
        pub mMaskModeCount: u32,
        pub mBlendModeCount: u32,
        pub mCompositeCount: u32,
        pub mLayers: root::nsStyleAutoArray<root::nsStyleImageLayers_Layer>,
    }
    pub const nsStyleImageLayers_shorthand:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::shorthand;
    pub const nsStyleImageLayers_color: root::nsStyleImageLayers__bindgen_ty_1
              =
        nsStyleImageLayers__bindgen_ty_1::color;
    pub const nsStyleImageLayers_image: root::nsStyleImageLayers__bindgen_ty_1
              =
        nsStyleImageLayers__bindgen_ty_1::image;
    pub const nsStyleImageLayers_repeat:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::repeat;
    pub const nsStyleImageLayers_positionX:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::positionX;
    pub const nsStyleImageLayers_positionY:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::positionY;
    pub const nsStyleImageLayers_clip: root::nsStyleImageLayers__bindgen_ty_1
              =
        nsStyleImageLayers__bindgen_ty_1::clip;
    pub const nsStyleImageLayers_origin:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::origin;
    pub const nsStyleImageLayers_size: root::nsStyleImageLayers__bindgen_ty_1
              =
        nsStyleImageLayers__bindgen_ty_1::size;
    pub const nsStyleImageLayers_attachment:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::attachment;
    pub const nsStyleImageLayers_maskMode:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::maskMode;
    pub const nsStyleImageLayers_composite:
              root::nsStyleImageLayers__bindgen_ty_1 =
        nsStyleImageLayers__bindgen_ty_1::composite;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageLayers__bindgen_ty_1 {
        shorthand = 0,
        color = 1,
        image = 2,
        repeat = 3,
        positionX = 4,
        positionY = 5,
        clip = 6,
        origin = 7,
        size = 8,
        attachment = 9,
        maskMode = 10,
        composite = 11,
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageLayers_LayerType { Background = 0, Mask = 1, }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleImageLayers_Size {
        pub mWidth: root::nsStyleImageLayers_Size_Dimension,
        pub mHeight: root::nsStyleImageLayers_Size_Dimension,
        pub mWidthType: u8,
        pub mHeightType: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleImageLayers_Size_Dimension {
        pub _base: root::nsStyleCoord_CalcValue,
    }
    #[test]
    fn bindgen_test_layout_nsStyleImageLayers_Size_Dimension() {
        assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Size_Dimension>()
                   , 12usize);
        assert_eq!(::std::mem::align_of::<nsStyleImageLayers_Size_Dimension>()
                   , 4usize);
    }
    impl Clone for nsStyleImageLayers_Size_Dimension {
        fn clone(&self) -> Self { *self }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageLayers_Size_DimensionType {
        eContain = 0,
        eCover = 1,
        eAuto = 2,
        eLengthPercentage = 3,
        eDimensionType_COUNT = 4,
    }
    #[test]
    fn bindgen_test_layout_nsStyleImageLayers_Size() {
        assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Size>() ,
                   28usize);
        assert_eq!(::std::mem::align_of::<nsStyleImageLayers_Size>() ,
                   4usize);
    }
    impl Clone for nsStyleImageLayers_Size {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleImageLayers_Repeat {
        pub mXRepeat: u8,
        pub mYRepeat: u8,
    }
    #[test]
    fn bindgen_test_layout_nsStyleImageLayers_Repeat() {
        assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Repeat>() ,
                   2usize);
        assert_eq!(::std::mem::align_of::<nsStyleImageLayers_Repeat>() ,
                   1usize);
    }
    impl Clone for nsStyleImageLayers_Repeat {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleImageLayers_Layer {
        pub mImage: root::nsStyleImage,
        pub mSourceURI: root::RefPtr<root::mozilla::css::URLValueData>,
        pub mPosition: root::mozilla::Position,
        pub mSize: root::nsStyleImageLayers_Size,
        pub mClip: root::nsStyleImageLayers_Layer_StyleGeometryBox,
        pub mOrigin: root::nsStyleImageLayers_Layer_StyleGeometryBox,
        pub mAttachment: u8,
        pub mBlendMode: u8,
        pub mComposite: u8,
        pub mMaskMode: u8,
        pub mRepeat: root::nsStyleImageLayers_Repeat,
    }
    pub type nsStyleImageLayers_Layer_StyleGeometryBox =
        root::mozilla::StyleGeometryBox;
    #[test]
    fn bindgen_test_layout_nsStyleImageLayers_Layer() {
        assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Layer>() ,
                   104usize);
        assert_eq!(::std::mem::align_of::<nsStyleImageLayers_Layer>() ,
                   8usize);
    }
    extern "C" {
        #[link_name = "_ZN18nsStyleImageLayers21kBackgroundLayerTableE"]
        pub static mut nsStyleImageLayers_kBackgroundLayerTable:
                   *const root::nsCSSPropertyID;
    }
    extern "C" {
        #[link_name = "_ZN18nsStyleImageLayers15kMaskLayerTableE"]
        pub static mut nsStyleImageLayers_kMaskLayerTable:
                   *const root::nsCSSPropertyID;
    }
    #[test]
    fn bindgen_test_layout_nsStyleImageLayers() {
        assert_eq!(::std::mem::size_of::<nsStyleImageLayers>() , 160usize);
        assert_eq!(::std::mem::align_of::<nsStyleImageLayers>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleBackground {
        pub mImage: root::nsStyleImageLayers,
        pub mBackgroundColor: root::nscolor,
    }
    #[test]
    fn bindgen_test_layout_nsStyleBackground() {
        assert_eq!(::std::mem::size_of::<nsStyleBackground>() , 168usize);
        assert_eq!(::std::mem::align_of::<nsStyleBackground>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleMargin {
        pub mMargin: root::nsStyleSides,
    }
    #[test]
    fn bindgen_test_layout_nsStyleMargin() {
        assert_eq!(::std::mem::size_of::<nsStyleMargin>() , 40usize);
        assert_eq!(::std::mem::align_of::<nsStyleMargin>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStylePadding {
        pub mPadding: root::nsStyleSides,
    }
    #[test]
    fn bindgen_test_layout_nsStylePadding() {
        assert_eq!(::std::mem::size_of::<nsStylePadding>() , 40usize);
        assert_eq!(::std::mem::align_of::<nsStylePadding>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsBorderColors {
        pub mNext: *mut root::nsBorderColors,
        pub mColor: root::nscolor,
    }
    #[test]
    fn bindgen_test_layout_nsBorderColors() {
        assert_eq!(::std::mem::size_of::<nsBorderColors>() , 16usize);
        assert_eq!(::std::mem::align_of::<nsBorderColors>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSShadowItem {
        pub mXOffset: root::nscoord,
        pub mYOffset: root::nscoord,
        pub mRadius: root::nscoord,
        pub mSpread: root::nscoord,
        pub mColor: root::nscolor,
        pub mHasColor: bool,
        pub mInset: bool,
    }
    #[test]
    fn bindgen_test_layout_nsCSSShadowItem() {
        assert_eq!(::std::mem::size_of::<nsCSSShadowItem>() , 24usize);
        assert_eq!(::std::mem::align_of::<nsCSSShadowItem>() , 4usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCSSShadowArray {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mLength: u32,
        pub mArray: [root::nsCSSShadowItem; 1usize],
    }
    pub type nsCSSShadowArray_HasThreadSafeRefCnt = root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsCSSShadowArray() {
        assert_eq!(::std::mem::size_of::<nsCSSShadowArray>() , 40usize);
        assert_eq!(::std::mem::align_of::<nsCSSShadowArray>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleBorder {
        pub mBorderColors: *mut *mut root::nsBorderColors,
        pub mBorderRadius: root::nsStyleCorners,
        pub mBorderImageSource: root::nsStyleImage,
        pub mBorderImageSlice: root::nsStyleSides,
        pub mBorderImageWidth: root::nsStyleSides,
        pub mBorderImageOutset: root::nsStyleSides,
        pub mBorderImageFill: u8,
        pub mBorderImageRepeatH: u8,
        pub mBorderImageRepeatV: u8,
        pub mFloatEdge: root::mozilla::StyleFloatEdge,
        pub mBoxDecorationBreak: root::mozilla::StyleBoxDecorationBreak,
        pub mBorderStyle: [u8; 4usize],
        pub __bindgen_anon_1: root::nsStyleBorder__bindgen_ty_1,
        pub mComputedBorder: root::nsMargin,
        pub mBorder: root::nsMargin,
        pub mTwipsPerPixel: root::nscoord,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleBorder__bindgen_ty_1 {
        pub __bindgen_anon_1: root::__BindgenUnionField<root::nsStyleBorder__bindgen_ty_1__bindgen_ty_1>,
        pub mBorderColor: root::__BindgenUnionField<[root::mozilla::StyleComplexColor; 4usize]>,
        pub bindgen_union_field: [u32; 8usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleBorder__bindgen_ty_1__bindgen_ty_1 {
        pub mBorderTopColor: root::mozilla::StyleComplexColor,
        pub mBorderRightColor: root::mozilla::StyleComplexColor,
        pub mBorderBottomColor: root::mozilla::StyleComplexColor,
        pub mBorderLeftColor: root::mozilla::StyleComplexColor,
    }
    #[test]
    fn bindgen_test_layout_nsStyleBorder__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleBorder__bindgen_ty_1__bindgen_ty_1>()
                   , 32usize);
        assert_eq!(::std::mem::align_of::<nsStyleBorder__bindgen_ty_1__bindgen_ty_1>()
                   , 4usize);
    }
    impl Clone for nsStyleBorder__bindgen_ty_1__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsStyleBorder__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleBorder__bindgen_ty_1>() ,
                   32usize);
        assert_eq!(::std::mem::align_of::<nsStyleBorder__bindgen_ty_1>() ,
                   4usize);
    }
    impl Clone for nsStyleBorder__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsStyleBorder() {
        assert_eq!(::std::mem::size_of::<nsStyleBorder>() , 312usize);
        assert_eq!(::std::mem::align_of::<nsStyleBorder>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleOutline {
        pub mOutlineRadius: root::nsStyleCorners,
        pub mOutlineWidth: root::nscoord,
        pub mOutlineOffset: root::nscoord,
        pub mOutlineColor: root::mozilla::StyleComplexColor,
        pub mOutlineStyle: u8,
        pub mActualOutlineWidth: root::nscoord,
        pub mTwipsPerPixel: root::nscoord,
    }
    #[test]
    fn bindgen_test_layout_nsStyleOutline() {
        assert_eq!(::std::mem::size_of::<nsStyleOutline>() , 104usize);
        assert_eq!(::std::mem::align_of::<nsStyleOutline>() , 8usize);
    }
    /**
 * An object that allows sharing of arrays that store 'quotes' property
 * values.  This is particularly important for inheritance, where we want
 * to share the same 'quotes' value with a parent style context.
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleQuoteValues {
        pub mRefCnt: root::mozilla::ThreadSafeAutoRefCnt,
        pub mQuotePairs: root::nsStyleQuoteValues_QuotePairArray,
    }
    pub type nsStyleQuoteValues_QuotePairArray =
        root::nsTArray<root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr>>;
    pub type nsStyleQuoteValues_HasThreadSafeRefCnt = root::mozilla::TrueType;
    #[test]
    fn bindgen_test_layout_nsStyleQuoteValues() {
        assert_eq!(::std::mem::size_of::<nsStyleQuoteValues>() , 16usize);
        assert_eq!(::std::mem::align_of::<nsStyleQuoteValues>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleList {
        pub mListStylePosition: u8,
        pub mListStyleImage: root::RefPtr<root::nsStyleImageRequest>,
        pub mCounterStyle: root::RefPtr<root::mozilla::CounterStyle>,
        pub mQuotes: root::RefPtr<root::nsStyleQuoteValues>,
        pub mImageRegion: root::nsRect,
    }
    extern "C" {
        #[link_name = "_ZN11nsStyleList14sInitialQuotesE"]
        pub static mut nsStyleList_sInitialQuotes:
                   root::mozilla::StaticRefPtr<root::nsStyleQuoteValues>;
    }
    extern "C" {
        #[link_name = "_ZN11nsStyleList11sNoneQuotesE"]
        pub static mut nsStyleList_sNoneQuotes:
                   root::mozilla::StaticRefPtr<root::nsStyleQuoteValues>;
    }
    #[test]
    fn bindgen_test_layout_nsStyleList() {
        assert_eq!(::std::mem::size_of::<nsStyleList>() , 48usize);
        assert_eq!(::std::mem::align_of::<nsStyleList>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleGridLine {
        pub mHasSpan: bool,
        pub mInteger: i32,
        pub mLineName: ::nsstring::nsStringRepr,
    }
    pub const nsStyleGridLine_kMinLine: i32 = -10000;
    pub const nsStyleGridLine_kMaxLine: i32 = 10000;
    #[test]
    fn bindgen_test_layout_nsStyleGridLine() {
        assert_eq!(::std::mem::size_of::<nsStyleGridLine>() , 24usize);
        assert_eq!(::std::mem::align_of::<nsStyleGridLine>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleGridTemplate {
        pub mLineNameLists: root::nsTArray<root::nsTArray<::nsstring::nsStringRepr>>,
        pub mMinTrackSizingFunctions: root::nsTArray<root::nsStyleCoord>,
        pub mMaxTrackSizingFunctions: root::nsTArray<root::nsStyleCoord>,
        pub mRepeatAutoLineNameListBefore: root::nsTArray<::nsstring::nsStringRepr>,
        pub mRepeatAutoLineNameListAfter: root::nsTArray<::nsstring::nsStringRepr>,
        pub mRepeatAutoIndex: i16,
        pub _bitfield_1: u8,
    }
    #[test]
    fn bindgen_test_layout_nsStyleGridTemplate() {
        assert_eq!(::std::mem::size_of::<nsStyleGridTemplate>() , 48usize);
        assert_eq!(::std::mem::align_of::<nsStyleGridTemplate>() , 8usize);
    }
    impl nsStyleGridTemplate {
        #[inline]
        pub fn mIsAutoFill(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                           0u32) as u8)
            }
        }
        #[inline]
        pub fn set_mIsAutoFill(&mut self, val: bool) {
            self._bitfield_1 &= !(1usize as u8);
            self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
        }
        #[inline]
        pub fn mIsSubgrid(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                           1u32) as u8)
            }
        }
        #[inline]
        pub fn set_mIsSubgrid(&mut self, val: bool) {
            self._bitfield_1 &= !(2usize as u8);
            self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (2usize as u8);
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStylePosition {
        pub mObjectPosition: root::mozilla::Position,
        pub mOffset: root::nsStyleSides,
        pub mWidth: root::nsStyleCoord,
        pub mMinWidth: root::nsStyleCoord,
        pub mMaxWidth: root::nsStyleCoord,
        pub mHeight: root::nsStyleCoord,
        pub mMinHeight: root::nsStyleCoord,
        pub mMaxHeight: root::nsStyleCoord,
        pub mFlexBasis: root::nsStyleCoord,
        pub mGridAutoColumnsMin: root::nsStyleCoord,
        pub mGridAutoColumnsMax: root::nsStyleCoord,
        pub mGridAutoRowsMin: root::nsStyleCoord,
        pub mGridAutoRowsMax: root::nsStyleCoord,
        pub mGridAutoFlow: u8,
        pub mBoxSizing: root::mozilla::StyleBoxSizing,
        pub mAlignContent: u16,
        pub mAlignItems: u8,
        pub mAlignSelf: u8,
        pub mJustifyContent: u16,
        pub mJustifyItems: u8,
        pub mJustifySelf: u8,
        pub mFlexDirection: u8,
        pub mFlexWrap: u8,
        pub mObjectFit: u8,
        pub mOrder: i32,
        pub mFlexGrow: f32,
        pub mFlexShrink: f32,
        pub mZIndex: root::nsStyleCoord,
        pub mGridTemplateColumns: root::nsStyleGridTemplate,
        pub mGridTemplateRows: root::nsStyleGridTemplate,
        pub mGridTemplateAreas: root::RefPtr<root::mozilla::css::GridTemplateAreasValue>,
        pub mGridColumnStart: root::nsStyleGridLine,
        pub mGridColumnEnd: root::nsStyleGridLine,
        pub mGridRowStart: root::nsStyleGridLine,
        pub mGridRowEnd: root::nsStyleGridLine,
        pub mGridColumnGap: root::nsStyleCoord,
        pub mGridRowGap: root::nsStyleCoord,
    }
    #[test]
    fn bindgen_test_layout_nsStylePosition() {
        assert_eq!(::std::mem::size_of::<nsStylePosition>() , 520usize);
        assert_eq!(::std::mem::align_of::<nsStylePosition>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleTextOverflowSide {
        pub mString: ::nsstring::nsStringRepr,
        pub mType: u8,
    }
    #[test]
    fn bindgen_test_layout_nsStyleTextOverflowSide() {
        assert_eq!(::std::mem::size_of::<nsStyleTextOverflowSide>() ,
                   24usize);
        assert_eq!(::std::mem::align_of::<nsStyleTextOverflowSide>() ,
                   8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleTextOverflow {
        pub mLeft: root::nsStyleTextOverflowSide,
        pub mRight: root::nsStyleTextOverflowSide,
        pub mLogicalDirections: bool,
    }
    #[test]
    fn bindgen_test_layout_nsStyleTextOverflow() {
        assert_eq!(::std::mem::size_of::<nsStyleTextOverflow>() , 56usize);
        assert_eq!(::std::mem::align_of::<nsStyleTextOverflow>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleTextReset {
        pub mTextOverflow: root::nsStyleTextOverflow,
        pub mTextDecorationLine: u8,
        pub mTextDecorationStyle: u8,
        pub mUnicodeBidi: u8,
        pub mInitialLetterSink: root::nscoord,
        pub mInitialLetterSize: f32,
        pub mTextDecorationColor: root::mozilla::StyleComplexColor,
    }
    #[test]
    fn bindgen_test_layout_nsStyleTextReset() {
        assert_eq!(::std::mem::size_of::<nsStyleTextReset>() , 80usize);
        assert_eq!(::std::mem::align_of::<nsStyleTextReset>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleText {
        pub mTextAlign: u8,
        pub mTextAlignLast: u8,
        pub _bitfield_1: u8,
        pub mTextTransform: u8,
        pub mWhiteSpace: u8,
        pub mWordBreak: u8,
        pub mOverflowWrap: u8,
        pub mHyphens: u8,
        pub mRubyAlign: u8,
        pub mRubyPosition: u8,
        pub mTextSizeAdjust: u8,
        pub mTextCombineUpright: u8,
        pub mControlCharacterVisibility: u8,
        pub mTextEmphasisPosition: u8,
        pub mTextEmphasisStyle: u8,
        pub mTextRendering: u8,
        pub mTextEmphasisColor: root::mozilla::StyleComplexColor,
        pub mWebkitTextFillColor: root::mozilla::StyleComplexColor,
        pub mWebkitTextStrokeColor: root::mozilla::StyleComplexColor,
        pub mTabSize: root::nsStyleCoord,
        pub mWordSpacing: root::nsStyleCoord,
        pub mLetterSpacing: root::nsStyleCoord,
        pub mLineHeight: root::nsStyleCoord,
        pub mTextIndent: root::nsStyleCoord,
        pub mWebkitTextStrokeWidth: root::nscoord,
        pub mTextShadow: root::RefPtr<root::nsCSSShadowArray>,
        pub mTextEmphasisStyleString: ::nsstring::nsStringRepr,
    }
    #[test]
    fn bindgen_test_layout_nsStyleText() {
        assert_eq!(::std::mem::size_of::<nsStyleText>() , 152usize);
        assert_eq!(::std::mem::align_of::<nsStyleText>() , 8usize);
    }
    impl nsStyleText {
        #[inline]
        pub fn mTextAlignTrue(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                           0u32) as u8)
            }
        }
        #[inline]
        pub fn set_mTextAlignTrue(&mut self, val: bool) {
            self._bitfield_1 &= !(1usize as u8);
            self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
        }
        #[inline]
        pub fn mTextAlignLastTrue(&self) -> bool {
            unsafe {
                ::std::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                           1u32) as u8)
            }
        }
        #[inline]
        pub fn set_mTextAlignLastTrue(&mut self, val: bool) {
            self._bitfield_1 &= !(2usize as u8);
            self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (2usize as u8);
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleImageOrientation {
        pub mOrientation: u8,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageOrientation_Bits {
        ORIENTATION_MASK = 3,
        FLIP_MASK = 4,
        FROM_IMAGE_MASK = 8,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleImageOrientation_Angles {
        ANGLE_0 = 0,
        ANGLE_90 = 1,
        ANGLE_180 = 2,
        ANGLE_270 = 3,
    }
    #[test]
    fn bindgen_test_layout_nsStyleImageOrientation() {
        assert_eq!(::std::mem::size_of::<nsStyleImageOrientation>() , 1usize);
        assert_eq!(::std::mem::align_of::<nsStyleImageOrientation>() ,
                   1usize);
    }
    impl Clone for nsStyleImageOrientation {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTimingFunction {
        pub mType: root::nsTimingFunction_Type,
        pub __bindgen_anon_1: root::nsTimingFunction__bindgen_ty_1,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsTimingFunction_Type {
        Ease = 0,
        Linear = 1,
        EaseIn = 2,
        EaseOut = 3,
        EaseInOut = 4,
        StepStart = 5,
        StepEnd = 6,
        CubicBezier = 7,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsTimingFunction_Keyword { Implicit = 0, Explicit = 1, }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTimingFunction__bindgen_ty_1 {
        pub mFunc: root::__BindgenUnionField<root::nsTimingFunction__bindgen_ty_1__bindgen_ty_1>,
        pub __bindgen_anon_1: root::__BindgenUnionField<root::nsTimingFunction__bindgen_ty_1__bindgen_ty_2>,
        pub bindgen_union_field: [u32; 4usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTimingFunction__bindgen_ty_1__bindgen_ty_1 {
        pub mX1: f32,
        pub mY1: f32,
        pub mX2: f32,
        pub mY2: f32,
    }
    #[test]
    fn bindgen_test_layout_nsTimingFunction__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsTimingFunction__bindgen_ty_1__bindgen_ty_1>()
                   , 16usize);
        assert_eq!(::std::mem::align_of::<nsTimingFunction__bindgen_ty_1__bindgen_ty_1>()
                   , 4usize);
    }
    impl Clone for nsTimingFunction__bindgen_ty_1__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsTimingFunction__bindgen_ty_1__bindgen_ty_2 {
        pub mSteps: u32,
    }
    #[test]
    fn bindgen_test_layout_nsTimingFunction__bindgen_ty_1__bindgen_ty_2() {
        assert_eq!(::std::mem::size_of::<nsTimingFunction__bindgen_ty_1__bindgen_ty_2>()
                   , 4usize);
        assert_eq!(::std::mem::align_of::<nsTimingFunction__bindgen_ty_1__bindgen_ty_2>()
                   , 4usize);
    }
    impl Clone for nsTimingFunction__bindgen_ty_1__bindgen_ty_2 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsTimingFunction__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsTimingFunction__bindgen_ty_1>() ,
                   16usize);
        assert_eq!(::std::mem::align_of::<nsTimingFunction__bindgen_ty_1>() ,
                   4usize);
    }
    impl Clone for nsTimingFunction__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsTimingFunction() {
        assert_eq!(::std::mem::size_of::<nsTimingFunction>() , 20usize);
        assert_eq!(::std::mem::align_of::<nsTimingFunction>() , 4usize);
    }
    impl Clone for nsTimingFunction {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleTable {
        pub mLayoutStrategy: u8,
        pub mSpan: i32,
    }
    #[test]
    fn bindgen_test_layout_nsStyleTable() {
        assert_eq!(::std::mem::size_of::<nsStyleTable>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsStyleTable>() , 4usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleTableBorder {
        pub mBorderSpacingCol: root::nscoord,
        pub mBorderSpacingRow: root::nscoord,
        pub mBorderCollapse: u8,
        pub mCaptionSide: u8,
        pub mEmptyCells: u8,
    }
    #[test]
    fn bindgen_test_layout_nsStyleTableBorder() {
        assert_eq!(::std::mem::size_of::<nsStyleTableBorder>() , 12usize);
        assert_eq!(::std::mem::align_of::<nsStyleTableBorder>() , 4usize);
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleContentType {
        eStyleContentType_String = 1,
        eStyleContentType_Image = 10,
        eStyleContentType_Attr = 20,
        eStyleContentType_Counter = 30,
        eStyleContentType_Counters = 31,
        eStyleContentType_OpenQuote = 40,
        eStyleContentType_CloseQuote = 41,
        eStyleContentType_NoOpenQuote = 42,
        eStyleContentType_NoCloseQuote = 43,
        eStyleContentType_AltContent = 50,
        eStyleContentType_Uninitialized = 51,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleContentData {
        pub mType: root::nsStyleContentType,
        pub mContent: root::nsStyleContentData__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleContentData__bindgen_ty_1 {
        pub mString: root::__BindgenUnionField<*mut u16>,
        pub mImage: root::__BindgenUnionField<*mut root::imgRequestProxy>,
        pub mCounters: root::__BindgenUnionField<*mut root::nsCSSValue_Array>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsStyleContentData__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleContentData__bindgen_ty_1>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<nsStyleContentData__bindgen_ty_1>()
                   , 8usize);
    }
    impl Clone for nsStyleContentData__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsStyleContentData() {
        assert_eq!(::std::mem::size_of::<nsStyleContentData>() , 16usize);
        assert_eq!(::std::mem::align_of::<nsStyleContentData>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleCounterData {
        pub mCounter: ::nsstring::nsStringRepr,
        pub mValue: i32,
    }
    #[test]
    fn bindgen_test_layout_nsStyleCounterData() {
        assert_eq!(::std::mem::size_of::<nsStyleCounterData>() , 24usize);
        assert_eq!(::std::mem::align_of::<nsStyleCounterData>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleContent {
        pub mContents: root::nsTArray<root::nsStyleContentData>,
        pub mIncrements: root::nsTArray<root::nsStyleCounterData>,
        pub mResets: root::nsTArray<root::nsStyleCounterData>,
    }
    #[test]
    fn bindgen_test_layout_nsStyleContent() {
        assert_eq!(::std::mem::size_of::<nsStyleContent>() , 24usize);
        assert_eq!(::std::mem::align_of::<nsStyleContent>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleUIReset {
        pub mUserSelect: root::mozilla::StyleUserSelect,
        pub mForceBrokenImageIcon: u8,
        pub mIMEMode: u8,
        pub mWindowDragging: root::mozilla::StyleWindowDragging,
        pub mWindowShadow: u8,
    }
    #[test]
    fn bindgen_test_layout_nsStyleUIReset() {
        assert_eq!(::std::mem::size_of::<nsStyleUIReset>() , 5usize);
        assert_eq!(::std::mem::align_of::<nsStyleUIReset>() , 1usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsCursorImage {
        pub mHaveHotspot: bool,
        pub mHotspotX: f32,
        pub mHotspotY: f32,
        pub mImage: root::RefPtr<root::nsStyleImageRequest>,
    }
    #[test]
    fn bindgen_test_layout_nsCursorImage() {
        assert_eq!(::std::mem::size_of::<nsCursorImage>() , 24usize);
        assert_eq!(::std::mem::align_of::<nsCursorImage>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleUserInterface {
        pub mUserInput: root::mozilla::StyleUserInput,
        pub mUserModify: root::mozilla::StyleUserModify,
        pub mUserFocus: root::mozilla::StyleUserFocus,
        pub mPointerEvents: u8,
        pub mCursor: u8,
        pub mCursorImages: root::nsTArray<root::nsCursorImage>,
        pub mCaretColor: root::mozilla::StyleComplexColor,
    }
    #[test]
    fn bindgen_test_layout_nsStyleUserInterface() {
        assert_eq!(::std::mem::size_of::<nsStyleUserInterface>() , 24usize);
        assert_eq!(::std::mem::align_of::<nsStyleUserInterface>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleXUL {
        pub mBoxFlex: f32,
        pub mBoxOrdinal: u32,
        pub mBoxAlign: root::mozilla::StyleBoxAlign,
        pub mBoxDirection: root::mozilla::StyleBoxDirection,
        pub mBoxOrient: root::mozilla::StyleBoxOrient,
        pub mBoxPack: root::mozilla::StyleBoxPack,
        pub mStretchStack: bool,
    }
    #[test]
    fn bindgen_test_layout_nsStyleXUL() {
        assert_eq!(::std::mem::size_of::<nsStyleXUL>() , 16usize);
        assert_eq!(::std::mem::align_of::<nsStyleXUL>() , 4usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleColumn {
        pub mColumnCount: u32,
        pub mColumnWidth: root::nsStyleCoord,
        pub mColumnGap: root::nsStyleCoord,
        pub mColumnRuleColor: root::mozilla::StyleComplexColor,
        pub mColumnRuleStyle: u8,
        pub mColumnFill: u8,
        pub mColumnRuleWidth: root::nscoord,
        pub mTwipsPerPixel: root::nscoord,
    }
    pub const nsStyleColumn_kMaxColumnCount: u32 = 1000;
    #[test]
    fn bindgen_test_layout_nsStyleColumn() {
        assert_eq!(::std::mem::size_of::<nsStyleColumn>() , 64usize);
        assert_eq!(::std::mem::align_of::<nsStyleColumn>() , 8usize);
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleSVGPaintType {
        eStyleSVGPaintType_None = 1,
        eStyleSVGPaintType_Color = 2,
        eStyleSVGPaintType_Server = 3,
        eStyleSVGPaintType_ContextFill = 4,
        eStyleSVGPaintType_ContextStroke = 5,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleSVGPaint {
        pub mPaint: root::nsStyleSVGPaint__bindgen_ty_1,
        pub mType: root::nsStyleSVGPaintType,
        pub mFallbackColor: root::nscolor,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleSVGPaint__bindgen_ty_1 {
        pub mColor: root::__BindgenUnionField<root::nscolor>,
        pub mPaintServer: root::__BindgenUnionField<*mut root::mozilla::css::URLValue>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsStyleSVGPaint__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleSVGPaint__bindgen_ty_1>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<nsStyleSVGPaint__bindgen_ty_1>() ,
                   8usize);
    }
    impl Clone for nsStyleSVGPaint__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsStyleSVGPaint() {
        assert_eq!(::std::mem::size_of::<nsStyleSVGPaint>() , 16usize);
        assert_eq!(::std::mem::align_of::<nsStyleSVGPaint>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleSVG {
        pub mFill: root::nsStyleSVGPaint,
        pub mStroke: root::nsStyleSVGPaint,
        pub mMarkerEnd: root::RefPtr<root::mozilla::css::URLValue>,
        pub mMarkerMid: root::RefPtr<root::mozilla::css::URLValue>,
        pub mMarkerStart: root::RefPtr<root::mozilla::css::URLValue>,
        pub mStrokeDasharray: root::nsTArray<root::nsStyleCoord>,
        pub mStrokeDashoffset: root::nsStyleCoord,
        pub mStrokeWidth: root::nsStyleCoord,
        pub mFillOpacity: f32,
        pub mStrokeMiterlimit: f32,
        pub mStrokeOpacity: f32,
        pub mClipRule: root::mozilla::StyleFillRule,
        pub mColorInterpolation: u8,
        pub mColorInterpolationFilters: u8,
        pub mFillRule: root::mozilla::StyleFillRule,
        pub mPaintOrder: u8,
        pub mShapeRendering: u8,
        pub mStrokeLinecap: u8,
        pub mStrokeLinejoin: u8,
        pub mTextAnchor: u8,
        pub mContextFlags: u8,
    }
    pub const nsStyleSVG_FILL_OPACITY_SOURCE_MASK:
              root::nsStyleSVG__bindgen_ty_1 =
        nsStyleSVG__bindgen_ty_1::FILL_OPACITY_SOURCE_MASK;
    pub const nsStyleSVG_STROKE_OPACITY_SOURCE_MASK:
              root::nsStyleSVG__bindgen_ty_1 =
        nsStyleSVG__bindgen_ty_1::STROKE_OPACITY_SOURCE_MASK;
    pub const nsStyleSVG_STROKE_DASHARRAY_CONTEXT:
              root::nsStyleSVG__bindgen_ty_1 =
        nsStyleSVG__bindgen_ty_1::STROKE_DASHARRAY_CONTEXT;
    pub const nsStyleSVG_STROKE_DASHOFFSET_CONTEXT:
              root::nsStyleSVG__bindgen_ty_1 =
        nsStyleSVG__bindgen_ty_1::STROKE_DASHOFFSET_CONTEXT;
    pub const nsStyleSVG_STROKE_WIDTH_CONTEXT: root::nsStyleSVG__bindgen_ty_1
              =
        nsStyleSVG__bindgen_ty_1::STROKE_WIDTH_CONTEXT;
    pub const nsStyleSVG_FILL_OPACITY_SOURCE_SHIFT:
              root::nsStyleSVG__bindgen_ty_1 =
        nsStyleSVG__bindgen_ty_1::FILL_OPACITY_SOURCE_SHIFT;
    pub const nsStyleSVG_STROKE_OPACITY_SOURCE_SHIFT:
              root::nsStyleSVG__bindgen_ty_1 =
        nsStyleSVG__bindgen_ty_1::STROKE_OPACITY_SOURCE_SHIFT;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum nsStyleSVG__bindgen_ty_1 {
        FILL_OPACITY_SOURCE_MASK = 3,
        STROKE_OPACITY_SOURCE_MASK = 12,
        STROKE_DASHARRAY_CONTEXT = 16,
        STROKE_DASHOFFSET_CONTEXT = 32,
        STROKE_WIDTH_CONTEXT = 64,
        FILL_OPACITY_SOURCE_SHIFT = 0,
        STROKE_OPACITY_SOURCE_SHIFT = 2,
    }
    #[test]
    fn bindgen_test_layout_nsStyleSVG() {
        assert_eq!(::std::mem::size_of::<nsStyleSVG>() , 120usize);
        assert_eq!(::std::mem::align_of::<nsStyleSVG>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleFilter {
        pub mType: u32,
        pub mFilterParameter: root::nsStyleCoord,
        pub __bindgen_anon_1: root::nsStyleFilter__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsStyleFilter__bindgen_ty_1 {
        pub mURL: root::__BindgenUnionField<*mut root::mozilla::css::URLValue>,
        pub mDropShadow: root::__BindgenUnionField<*mut root::nsCSSShadowArray>,
        pub bindgen_union_field: u64,
    }
    #[test]
    fn bindgen_test_layout_nsStyleFilter__bindgen_ty_1() {
        assert_eq!(::std::mem::size_of::<nsStyleFilter__bindgen_ty_1>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<nsStyleFilter__bindgen_ty_1>() ,
                   8usize);
    }
    impl Clone for nsStyleFilter__bindgen_ty_1 {
        fn clone(&self) -> Self { *self }
    }
    #[test]
    fn bindgen_test_layout_nsStyleFilter() {
        assert_eq!(::std::mem::size_of::<nsStyleFilter>() , 32usize);
        assert_eq!(::std::mem::align_of::<nsStyleFilter>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleSVGReset {
        pub mMask: root::nsStyleImageLayers,
        pub mClipPath: root::mozilla::StyleClipPath,
        pub mStopColor: root::nscolor,
        pub mFloodColor: root::nscolor,
        pub mLightingColor: root::nscolor,
        pub mStopOpacity: f32,
        pub mFloodOpacity: f32,
        pub mDominantBaseline: u8,
        pub mVectorEffect: u8,
        pub mMaskType: u8,
    }
    #[test]
    fn bindgen_test_layout_nsStyleSVGReset() {
        assert_eq!(::std::mem::size_of::<nsStyleSVGReset>() , 200usize);
        assert_eq!(::std::mem::align_of::<nsStyleSVGReset>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleVariables {
        pub mVariables: root::mozilla::CSSVariableValues,
    }
    #[test]
    fn bindgen_test_layout_nsStyleVariables() {
        assert_eq!(::std::mem::size_of::<nsStyleVariables>() , 48usize);
        assert_eq!(::std::mem::align_of::<nsStyleVariables>() , 8usize);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsStyleEffects {
        pub mFilters: root::nsTArray<root::nsStyleFilter>,
        pub mBoxShadow: root::RefPtr<root::nsCSSShadowArray>,
        pub mClip: root::nsRect,
        pub mOpacity: f32,
        pub mClipFlags: u8,
        pub mMixBlendMode: u8,
    }
    #[test]
    fn bindgen_test_layout_nsStyleEffects() {
        assert_eq!(::std::mem::size_of::<nsStyleEffects>() , 40usize);
        assert_eq!(::std::mem::align_of::<nsStyleEffects>() , 8usize);
    }
    /**
 * These *_Simple types are used to map Gecko types to layout-equivalent but
 * simpler Rust types, to aid Rust binding generation.
 *
 * If something in this types or the assertions below needs to change, ask
 * bholley, heycam or emilio before!
 *
 * <div rustbindgen="true" replaces="nsPoint">
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsPoint {
        pub x: root::nscoord,
        pub y: root::nscoord,
    }
    #[test]
    fn bindgen_test_layout_nsPoint() {
        assert_eq!(::std::mem::size_of::<nsPoint>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsPoint>() , 4usize);
    }
    impl Clone for nsPoint {
        fn clone(&self) -> Self { *self }
    }
    /**
 * <div rustbindgen="true" replaces="nsMargin">
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsMargin {
        pub top: root::nscoord,
        pub right: root::nscoord,
        pub bottom: root::nscoord,
        pub left: root::nscoord,
    }
    #[test]
    fn bindgen_test_layout_nsMargin() {
        assert_eq!(::std::mem::size_of::<nsMargin>() , 16usize);
        assert_eq!(::std::mem::align_of::<nsMargin>() , 4usize);
    }
    impl Clone for nsMargin {
        fn clone(&self) -> Self { *self }
    }
    /**
 * <div rustbindgen="true" replaces="nsRect">
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsRect {
        pub x: root::nscoord,
        pub y: root::nscoord,
        pub width: root::nscoord,
        pub height: root::nscoord,
    }
    #[test]
    fn bindgen_test_layout_nsRect() {
        assert_eq!(::std::mem::size_of::<nsRect>() , 16usize);
        assert_eq!(::std::mem::align_of::<nsRect>() , 4usize);
    }
    impl Clone for nsRect {
        fn clone(&self) -> Self { *self }
    }
    /**
 * <div rustbindgen="true" replaces="nsSize">
 */
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct nsSize {
        pub width: root::nscoord,
        pub height: root::nscoord,
    }
    #[test]
    fn bindgen_test_layout_nsSize() {
        assert_eq!(::std::mem::size_of::<nsSize>() , 8usize);
        assert_eq!(::std::mem::align_of::<nsSize>() , 4usize);
    }
    impl Clone for nsSize {
        fn clone(&self) -> Self { *self }
    }
    /**
 * <div rustbindgen replaces="nsTArray"></div>
 */
    #[repr(C)]
    #[derive(Debug)]
    pub struct nsTArray<T> {
        pub mBuffer: *mut T,
    }
    pub type ThreadSafePrincipalHolder =
        root::nsMainThreadPtrHolder<root::nsIPrincipal>;
    pub type ThreadSafeURIHolder = root::nsMainThreadPtrHolder<root::nsIURI>;
    #[test]
    fn __bindgen_test_layout_template_9() {
        assert_eq!(::std::mem::size_of::<root::JS::TenuredHeap<*mut root::JSObject>>()
                   , 8usize);
        assert_eq!(::std::mem::align_of::<root::JS::TenuredHeap<*mut root::JSObject>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_10() {
        assert_eq!(::std::mem::size_of::<root::JS::Heap<*mut root::JSObject>>()
                   , 8usize);
        assert_eq!(::std::mem::align_of::<root::JS::Heap<*mut root::JSObject>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_11() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::nsCString>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::nsCString>>() ,
                   8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_12() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIPrincipal>>()
                   , 8usize);
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIPrincipal>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_13() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::Element>>()
                   , 8usize);
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::Element>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_14() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::Element>>>()
                   , 8usize);
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::Element>>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_15() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIObserver>>()
                   , 8usize);
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIObserver>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_16() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIWeakReference>>()
                   , 8usize);
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIWeakReference>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_17() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize);
        assert_eq!(::std::mem::align_of::<root::nsTArray<*mut root::nsIContent>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_18() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize);
        assert_eq!(::std::mem::align_of::<root::nsTArray<::nsstring::nsStringRepr>>() ,
                   8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_19() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete<root::mozilla::dom::TimeoutManager>>()
                   , 1usize);
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete<root::mozilla::dom::TimeoutManager>>()
                   , 1usize);
    }
    #[test]
    fn __bindgen_test_layout_template_20() {
        assert_eq!(::std::mem::size_of::<root::nsCOMPtr<root::nsIRunnable>>()
                   , 8usize);
        assert_eq!(::std::mem::align_of::<root::nsCOMPtr<root::nsIRunnable>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_21() {
        assert_eq!(::std::mem::size_of::<root::mozilla::OwningNonNull<root::nsINode>>()
                   , 8usize);
        assert_eq!(::std::mem::align_of::<root::mozilla::OwningNonNull<root::nsINode>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_22() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<f64>>() , 8usize);
        assert_eq!(::std::mem::align_of::<root::nsTArray<f64>>() , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_23() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>()
                   , 8usize);
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_24() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>>()
                   , 8usize);
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::RefPtr<root::mozilla::dom::DOMIntersectionObserverEntry>>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_25() {
        assert_eq!(::std::mem::size_of::<root::nsMainThreadPtrHolder<root::nsIURI>>()
                   , 24usize);
        assert_eq!(::std::mem::align_of::<root::nsMainThreadPtrHolder<root::nsIURI>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_26() {
        assert_eq!(::std::mem::size_of::<root::nsMainThreadPtrHolder<root::nsIPrincipal>>()
                   , 24usize);
        assert_eq!(::std::mem::align_of::<root::nsMainThreadPtrHolder<root::nsIPrincipal>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_27() {
        assert_eq!(::std::mem::size_of::<root::nsPtrHashKey<root::nsIFrame>>()
                   , 16usize);
        assert_eq!(::std::mem::align_of::<root::nsPtrHashKey<root::nsIFrame>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_28() {
        assert_eq!(::std::mem::size_of::<root::nsTArray<root::mozilla::DisplayItemClip_RoundedRect>>()
                   , 8usize);
        assert_eq!(::std::mem::align_of::<root::nsTArray<root::mozilla::DisplayItemClip_RoundedRect>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_29() {
        assert_eq!(::std::mem::size_of::<root::RefPtr<root::mozilla::dom::DOMRect>>()
                   , 8usize);
        assert_eq!(::std::mem::align_of::<root::RefPtr<root::mozilla::dom::DOMRect>>()
                   , 8usize);
    }
    #[test]
    fn __bindgen_test_layout_template_30() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete<root::ProxyBehaviour>>()
                   , 1usize);
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete<root::ProxyBehaviour>>()
                   , 1usize);
    }
    #[test]
    fn __bindgen_test_layout_template_31() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete<root::nsStyleSides>>()
                   , 1usize);
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete<root::nsStyleSides>>()
                   , 1usize);
    }
    #[test]
    fn __bindgen_test_layout_template_32() {
        assert_eq!(::std::mem::size_of::<root::mozilla::DefaultDelete<root::CachedBorderImageData>>()
                   , 1usize);
        assert_eq!(::std::mem::align_of::<root::mozilla::DefaultDelete<root::CachedBorderImageData>>()
                   , 1usize);
    }
    #[test]
    fn __bindgen_test_layout_template_33() {
        assert_eq!(::std::mem::size_of::<root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr>>()
                   , 32usize);
        assert_eq!(::std::mem::align_of::<root::std::pair<::nsstring::nsStringRepr, ::nsstring::nsStringRepr>>()
                   , 8usize);
    }
}
