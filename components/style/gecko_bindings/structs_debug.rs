/* automatically generated by rust-bindgen */

pub enum OpaqueStyleData {}
pub type ServoUnsafeCell<T> = ::std::cell::UnsafeCell<T>;
pub type ServoCell<T> = ::std::cell::Cell<T>;
pub type ServoNodeData = OpaqueStyleData;

#[derive(Debug)]
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
pub const NS_THEME_NONE: ::std::os::raw::c_uint = 0;
pub const NS_THEME_BUTTON: ::std::os::raw::c_uint = 1;
pub const NS_THEME_RADIO: ::std::os::raw::c_uint = 2;
pub const NS_THEME_CHECKBOX: ::std::os::raw::c_uint = 3;
pub const NS_THEME_BUTTON_BEVEL: ::std::os::raw::c_uint = 7;
pub const NS_THEME_FOCUS_OUTLINE: ::std::os::raw::c_uint = 8;
pub const NS_THEME_TOOLBOX: ::std::os::raw::c_uint = 11;
pub const NS_THEME_TOOLBAR: ::std::os::raw::c_uint = 12;
pub const NS_THEME_TOOLBARBUTTON: ::std::os::raw::c_uint = 13;
pub const NS_THEME_DUALBUTTON: ::std::os::raw::c_uint = 14;
pub const NS_THEME_TOOLBARBUTTON_DROPDOWN: ::std::os::raw::c_uint = 15;
pub const NS_THEME_BUTTON_ARROW_UP: ::std::os::raw::c_uint = 16;
pub const NS_THEME_BUTTON_ARROW_DOWN: ::std::os::raw::c_uint = 17;
pub const NS_THEME_BUTTON_ARROW_NEXT: ::std::os::raw::c_uint = 18;
pub const NS_THEME_BUTTON_ARROW_PREVIOUS: ::std::os::raw::c_uint = 19;
pub const NS_THEME_SEPARATOR: ::std::os::raw::c_uint = 20;
pub const NS_THEME_TOOLBARGRIPPER: ::std::os::raw::c_uint = 21;
pub const NS_THEME_SPLITTER: ::std::os::raw::c_uint = 22;
pub const NS_THEME_STATUSBAR: ::std::os::raw::c_uint = 23;
pub const NS_THEME_STATUSBARPANEL: ::std::os::raw::c_uint = 24;
pub const NS_THEME_RESIZERPANEL: ::std::os::raw::c_uint = 25;
pub const NS_THEME_RESIZER: ::std::os::raw::c_uint = 26;
pub const NS_THEME_LISTBOX: ::std::os::raw::c_uint = 31;
pub const NS_THEME_LISTITEM: ::std::os::raw::c_uint = 32;
pub const NS_THEME_TREEVIEW: ::std::os::raw::c_uint = 41;
pub const NS_THEME_TREEITEM: ::std::os::raw::c_uint = 42;
pub const NS_THEME_TREETWISTY: ::std::os::raw::c_uint = 43;
pub const NS_THEME_TREELINE: ::std::os::raw::c_uint = 44;
pub const NS_THEME_TREEHEADER: ::std::os::raw::c_uint = 45;
pub const NS_THEME_TREEHEADERCELL: ::std::os::raw::c_uint = 46;
pub const NS_THEME_TREEHEADERSORTARROW: ::std::os::raw::c_uint = 47;
pub const NS_THEME_TREETWISTYOPEN: ::std::os::raw::c_uint = 48;
pub const NS_THEME_PROGRESSBAR: ::std::os::raw::c_uint = 51;
pub const NS_THEME_PROGRESSCHUNK: ::std::os::raw::c_uint = 52;
pub const NS_THEME_PROGRESSBAR_VERTICAL: ::std::os::raw::c_uint = 53;
pub const NS_THEME_PROGRESSCHUNK_VERTICAL: ::std::os::raw::c_uint = 54;
pub const NS_THEME_METERBAR: ::std::os::raw::c_uint = 55;
pub const NS_THEME_METERCHUNK: ::std::os::raw::c_uint = 56;
pub const NS_THEME_TAB: ::std::os::raw::c_uint = 61;
pub const NS_THEME_TABPANEL: ::std::os::raw::c_uint = 62;
pub const NS_THEME_TABPANELS: ::std::os::raw::c_uint = 65;
pub const NS_THEME_TAB_SCROLL_ARROW_BACK: ::std::os::raw::c_uint = 66;
pub const NS_THEME_TAB_SCROLL_ARROW_FORWARD: ::std::os::raw::c_uint = 67;
pub const NS_THEME_TOOLTIP: ::std::os::raw::c_uint = 71;
pub const NS_THEME_SPINNER: ::std::os::raw::c_uint = 72;
pub const NS_THEME_SPINNER_UPBUTTON: ::std::os::raw::c_uint = 73;
pub const NS_THEME_SPINNER_DOWNBUTTON: ::std::os::raw::c_uint = 74;
pub const NS_THEME_SPINNER_TEXTFIELD: ::std::os::raw::c_uint = 75;
pub const NS_THEME_NUMBER_INPUT: ::std::os::raw::c_uint = 76;
pub const NS_THEME_SCROLLBAR: ::std::os::raw::c_uint = 80;
pub const NS_THEME_SCROLLBAR_SMALL: ::std::os::raw::c_uint = 81;
pub const NS_THEME_SCROLLBAR_HORIZONTAL: ::std::os::raw::c_uint = 82;
pub const NS_THEME_SCROLLBAR_VERTICAL: ::std::os::raw::c_uint = 83;
pub const NS_THEME_SCROLLBARBUTTON_UP: ::std::os::raw::c_uint = 84;
pub const NS_THEME_SCROLLBARBUTTON_DOWN: ::std::os::raw::c_uint = 85;
pub const NS_THEME_SCROLLBARBUTTON_LEFT: ::std::os::raw::c_uint = 86;
pub const NS_THEME_SCROLLBARBUTTON_RIGHT: ::std::os::raw::c_uint = 87;
pub const NS_THEME_SCROLLBARTRACK_HORIZONTAL: ::std::os::raw::c_uint = 88;
pub const NS_THEME_SCROLLBARTRACK_VERTICAL: ::std::os::raw::c_uint = 89;
pub const NS_THEME_SCROLLBARTHUMB_HORIZONTAL: ::std::os::raw::c_uint = 90;
pub const NS_THEME_SCROLLBARTHUMB_VERTICAL: ::std::os::raw::c_uint = 91;
pub const NS_THEME_SCROLLBAR_NON_DISAPPEARING: ::std::os::raw::c_uint = 92;
pub const NS_THEME_TEXTFIELD: ::std::os::raw::c_uint = 95;
pub const NS_THEME_CARET: ::std::os::raw::c_uint = 96;
pub const NS_THEME_TEXTFIELD_MULTILINE: ::std::os::raw::c_uint = 97;
pub const NS_THEME_SEARCHFIELD: ::std::os::raw::c_uint = 98;
pub const NS_THEME_MENULIST: ::std::os::raw::c_uint = 101;
pub const NS_THEME_MENULIST_BUTTON: ::std::os::raw::c_uint = 102;
pub const NS_THEME_MENULIST_TEXT: ::std::os::raw::c_uint = 103;
pub const NS_THEME_MENULIST_TEXTFIELD: ::std::os::raw::c_uint = 104;
pub const NS_THEME_SCALE_HORIZONTAL: ::std::os::raw::c_uint = 111;
pub const NS_THEME_SCALE_VERTICAL: ::std::os::raw::c_uint = 112;
pub const NS_THEME_SCALETHUMB_HORIZONTAL: ::std::os::raw::c_uint = 113;
pub const NS_THEME_SCALETHUMB_VERTICAL: ::std::os::raw::c_uint = 114;
pub const NS_THEME_SCALETHUMBSTART: ::std::os::raw::c_uint = 115;
pub const NS_THEME_SCALETHUMBEND: ::std::os::raw::c_uint = 116;
pub const NS_THEME_SCALETHUMBTICK: ::std::os::raw::c_uint = 117;
pub const NS_THEME_RANGE: ::std::os::raw::c_uint = 120;
pub const NS_THEME_RANGE_THUMB: ::std::os::raw::c_uint = 121;
pub const NS_THEME_GROUPBOX: ::std::os::raw::c_uint = 149;
pub const NS_THEME_CHECKBOX_CONTAINER: ::std::os::raw::c_uint = 150;
pub const NS_THEME_RADIO_CONTAINER: ::std::os::raw::c_uint = 151;
pub const NS_THEME_CHECKBOX_LABEL: ::std::os::raw::c_uint = 152;
pub const NS_THEME_RADIO_LABEL: ::std::os::raw::c_uint = 153;
pub const NS_THEME_BUTTON_FOCUS: ::std::os::raw::c_uint = 154;
pub const NS_THEME_WINDOW: ::std::os::raw::c_uint = 200;
pub const NS_THEME_DIALOG: ::std::os::raw::c_uint = 201;
pub const NS_THEME_MENUBAR: ::std::os::raw::c_uint = 210;
pub const NS_THEME_MENUPOPUP: ::std::os::raw::c_uint = 211;
pub const NS_THEME_MENUITEM: ::std::os::raw::c_uint = 212;
pub const NS_THEME_CHECKMENUITEM: ::std::os::raw::c_uint = 213;
pub const NS_THEME_RADIOMENUITEM: ::std::os::raw::c_uint = 214;
pub const NS_THEME_MENUCHECKBOX: ::std::os::raw::c_uint = 215;
pub const NS_THEME_MENURADIO: ::std::os::raw::c_uint = 216;
pub const NS_THEME_MENUSEPARATOR: ::std::os::raw::c_uint = 217;
pub const NS_THEME_MENUARROW: ::std::os::raw::c_uint = 218;
pub const NS_THEME_MENUIMAGE: ::std::os::raw::c_uint = 219;
pub const NS_THEME_MENUITEMTEXT: ::std::os::raw::c_uint = 220;
pub const NS_THEME_WIN_COMMUNICATIONS_TOOLBOX: ::std::os::raw::c_uint = 221;
pub const NS_THEME_WIN_MEDIA_TOOLBOX: ::std::os::raw::c_uint = 222;
pub const NS_THEME_WIN_BROWSERTABBAR_TOOLBOX: ::std::os::raw::c_uint = 223;
pub const NS_THEME_MAC_FULLSCREEN_BUTTON: ::std::os::raw::c_uint = 226;
pub const NS_THEME_MAC_HELP_BUTTON: ::std::os::raw::c_uint = 227;
pub const NS_THEME_WIN_BORDERLESS_GLASS: ::std::os::raw::c_uint = 229;
pub const NS_THEME_WIN_GLASS: ::std::os::raw::c_uint = 230;
pub const NS_THEME_WINDOW_TITLEBAR: ::std::os::raw::c_uint = 231;
pub const NS_THEME_WINDOW_TITLEBAR_MAXIMIZED: ::std::os::raw::c_uint = 232;
pub const NS_THEME_WINDOW_FRAME_LEFT: ::std::os::raw::c_uint = 233;
pub const NS_THEME_WINDOW_FRAME_RIGHT: ::std::os::raw::c_uint = 234;
pub const NS_THEME_WINDOW_FRAME_BOTTOM: ::std::os::raw::c_uint = 235;
pub const NS_THEME_WINDOW_BUTTON_CLOSE: ::std::os::raw::c_uint = 236;
pub const NS_THEME_WINDOW_BUTTON_MINIMIZE: ::std::os::raw::c_uint = 237;
pub const NS_THEME_WINDOW_BUTTON_MAXIMIZE: ::std::os::raw::c_uint = 238;
pub const NS_THEME_WINDOW_BUTTON_RESTORE: ::std::os::raw::c_uint = 239;
pub const NS_THEME_WINDOW_BUTTON_BOX: ::std::os::raw::c_uint = 240;
pub const NS_THEME_WINDOW_BUTTON_BOX_MAXIMIZED: ::std::os::raw::c_uint = 241;
pub const NS_THEME_WIN_EXCLUDE_GLASS: ::std::os::raw::c_uint = 242;
pub const NS_THEME_MAC_VIBRANCY_LIGHT: ::std::os::raw::c_uint = 243;
pub const NS_THEME_MAC_VIBRANCY_DARK: ::std::os::raw::c_uint = 244;
pub const NS_THEME_MAC_DISCLOSURE_BUTTON_OPEN: ::std::os::raw::c_uint = 245;
pub const NS_THEME_MAC_DISCLOSURE_BUTTON_CLOSED: ::std::os::raw::c_uint = 246;
pub const NS_THEME_GTK_INFO_BAR: ::std::os::raw::c_uint = 247;
pub const NS_THEME_MAC_SOURCE_LIST: ::std::os::raw::c_uint = 248;
pub const NS_FONT_STYLE_NORMAL: ::std::os::raw::c_uint = 0;
pub const NS_FONT_STYLE_ITALIC: ::std::os::raw::c_uint = 1;
pub const NS_FONT_STYLE_OBLIQUE: ::std::os::raw::c_uint = 2;
pub const NS_CORNER_TOP_LEFT_X: ::std::os::raw::c_uint = 0;
pub const NS_CORNER_TOP_LEFT_Y: ::std::os::raw::c_uint = 1;
pub const NS_CORNER_TOP_RIGHT_X: ::std::os::raw::c_uint = 2;
pub const NS_CORNER_TOP_RIGHT_Y: ::std::os::raw::c_uint = 3;
pub const NS_CORNER_BOTTOM_RIGHT_X: ::std::os::raw::c_uint = 4;
pub const NS_CORNER_BOTTOM_RIGHT_Y: ::std::os::raw::c_uint = 5;
pub const NS_CORNER_BOTTOM_LEFT_X: ::std::os::raw::c_uint = 6;
pub const NS_CORNER_BOTTOM_LEFT_Y: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_USER_INPUT_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_USER_INPUT_ENABLED: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_USER_INPUT_DISABLED: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_USER_INPUT_AUTO: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_USER_MODIFY_READ_ONLY: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_USER_MODIFY_READ_WRITE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_USER_MODIFY_WRITE_ONLY: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_WINDOW_DRAGGING_DEFAULT: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_WINDOW_DRAGGING_DRAG: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_WINDOW_DRAGGING_NO_DRAG: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_ORIENT_INLINE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_ORIENT_BLOCK: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_ORIENT_HORIZONTAL: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_ORIENT_VERTICAL: ::std::os::raw::c_uint = 3;
pub const NS_RADIUS_FARTHEST_SIDE: ::std::os::raw::c_uint = 0;
pub const NS_RADIUS_CLOSEST_SIDE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_STACK_SIZING_IGNORE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_STACK_SIZING_STRETCH_TO_FIT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_AZIMUTH_LEFT_SIDE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_AZIMUTH_FAR_LEFT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_AZIMUTH_LEFT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_AZIMUTH_CENTER_LEFT: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_AZIMUTH_CENTER: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_AZIMUTH_CENTER_RIGHT: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_AZIMUTH_RIGHT: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_AZIMUTH_FAR_RIGHT: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_AZIMUTH_RIGHT_SIDE: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_AZIMUTH_BEHIND: ::std::os::raw::c_uint = 128;
pub const NS_STYLE_AZIMUTH_LEFTWARDS: ::std::os::raw::c_uint = 16;
pub const NS_STYLE_AZIMUTH_RIGHTWARDS: ::std::os::raw::c_uint = 32;
pub const NS_STYLE_ELEVATION_BELOW: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_ELEVATION_LEVEL: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_ELEVATION_ABOVE: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_ELEVATION_HIGHER: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_ELEVATION_LOWER: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_PITCH_X_LOW: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_PITCH_LOW: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_PITCH_MEDIUM: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_PITCH_HIGH: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_PITCH_X_HIGH: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_SPEAK_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_SPEAK_NORMAL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_SPEAK_SPELL_OUT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_SPEAK_HEADER_ONCE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_SPEAK_HEADER_ALWAYS: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_SPEAK_NUMERAL_DIGITS: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_SPEAK_NUMERAL_CONTINUOUS: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_SPEAK_PUNCTUATION_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_SPEAK_PUNCTUATION_CODE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_SPEECH_RATE_X_SLOW: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_SPEECH_RATE_SLOW: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_SPEECH_RATE_MEDIUM: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_SPEECH_RATE_FAST: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_SPEECH_RATE_X_FAST: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_SPEECH_RATE_FASTER: ::std::os::raw::c_uint = 10;
pub const NS_STYLE_SPEECH_RATE_SLOWER: ::std::os::raw::c_uint = 11;
pub const NS_STYLE_VOLUME_SILENT: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_VOLUME_X_SOFT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_VOLUME_SOFT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_VOLUME_MEDIUM: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_VOLUME_LOUD: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_VOLUME_X_LOUD: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_COLOR_INHERIT_FROM_BODY: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_ANIMATION_ITERATION_COUNT_INFINITE: ::std::os::raw::c_uint
          =
    0;
pub const NS_STYLE_ANIMATION_PLAY_STATE_RUNNING: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_ANIMATION_PLAY_STATE_PAUSED: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_IMAGELAYER_ATTACHMENT_SCROLL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_IMAGELAYER_ATTACHMENT_FIXED: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_IMAGELAYER_ATTACHMENT_LOCAL: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_IMAGELAYER_CLIP_BORDER: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_IMAGELAYER_CLIP_PADDING: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_IMAGELAYER_CLIP_CONTENT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_IMAGELAYER_CLIP_TEXT: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_IMAGELAYER_CLIP_MOZ_ALMOST_PADDING: ::std::os::raw::c_uint
          =
    127;
pub const NS_STYLE_IMAGELAYER_ORIGIN_BORDER: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_IMAGELAYER_ORIGIN_PADDING: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_IMAGELAYER_ORIGIN_CONTENT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_IMAGELAYER_REPEAT_NO_REPEAT: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_IMAGELAYER_REPEAT_REPEAT_X: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_IMAGELAYER_REPEAT_REPEAT_Y: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_IMAGELAYER_REPEAT_REPEAT: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_IMAGELAYER_REPEAT_SPACE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_IMAGELAYER_REPEAT_ROUND: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_IMAGELAYER_SIZE_CONTAIN: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_IMAGELAYER_SIZE_COVER: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_MASK_MODE_ALPHA: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_MASK_MODE_LUMINANCE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_MASK_MODE_MATCH_SOURCE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_BG_INLINE_POLICY_EACH_BOX: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_BG_INLINE_POLICY_CONTINUOUS: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_BG_INLINE_POLICY_BOUNDING_BOX: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_BORDER_COLLAPSE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_BORDER_SEPARATE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_BORDER_WIDTH_THIN: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_BORDER_WIDTH_MEDIUM: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_BORDER_WIDTH_THICK: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_BORDER_STYLE_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_BORDER_STYLE_GROOVE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_BORDER_STYLE_RIDGE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_BORDER_STYLE_DOTTED: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_BORDER_STYLE_DASHED: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_BORDER_STYLE_SOLID: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_BORDER_STYLE_DOUBLE: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_BORDER_STYLE_INSET: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_BORDER_STYLE_OUTSET: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_BORDER_STYLE_HIDDEN: ::std::os::raw::c_uint = 9;
pub const NS_STYLE_BORDER_STYLE_AUTO: ::std::os::raw::c_uint = 10;
pub const NS_STYLE_BORDER_IMAGE_REPEAT_STRETCH: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_BORDER_IMAGE_REPEAT_REPEAT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_BORDER_IMAGE_REPEAT_ROUND: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_BORDER_IMAGE_REPEAT_SPACE: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_BORDER_IMAGE_SLICE_NOFILL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_BORDER_IMAGE_SLICE_FILL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_CONTENT_OPEN_QUOTE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_CONTENT_CLOSE_QUOTE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_CONTENT_NO_OPEN_QUOTE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_CONTENT_NO_CLOSE_QUOTE: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_CONTENT_ALT_CONTENT: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_CURSOR_AUTO: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_CURSOR_CROSSHAIR: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_CURSOR_DEFAULT: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_CURSOR_POINTER: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_CURSOR_MOVE: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_CURSOR_E_RESIZE: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_CURSOR_NE_RESIZE: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_CURSOR_NW_RESIZE: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_CURSOR_N_RESIZE: ::std::os::raw::c_uint = 9;
pub const NS_STYLE_CURSOR_SE_RESIZE: ::std::os::raw::c_uint = 10;
pub const NS_STYLE_CURSOR_SW_RESIZE: ::std::os::raw::c_uint = 11;
pub const NS_STYLE_CURSOR_S_RESIZE: ::std::os::raw::c_uint = 12;
pub const NS_STYLE_CURSOR_W_RESIZE: ::std::os::raw::c_uint = 13;
pub const NS_STYLE_CURSOR_TEXT: ::std::os::raw::c_uint = 14;
pub const NS_STYLE_CURSOR_WAIT: ::std::os::raw::c_uint = 15;
pub const NS_STYLE_CURSOR_HELP: ::std::os::raw::c_uint = 16;
pub const NS_STYLE_CURSOR_COPY: ::std::os::raw::c_uint = 17;
pub const NS_STYLE_CURSOR_ALIAS: ::std::os::raw::c_uint = 18;
pub const NS_STYLE_CURSOR_CONTEXT_MENU: ::std::os::raw::c_uint = 19;
pub const NS_STYLE_CURSOR_CELL: ::std::os::raw::c_uint = 20;
pub const NS_STYLE_CURSOR_GRAB: ::std::os::raw::c_uint = 21;
pub const NS_STYLE_CURSOR_GRABBING: ::std::os::raw::c_uint = 22;
pub const NS_STYLE_CURSOR_SPINNING: ::std::os::raw::c_uint = 23;
pub const NS_STYLE_CURSOR_ZOOM_IN: ::std::os::raw::c_uint = 24;
pub const NS_STYLE_CURSOR_ZOOM_OUT: ::std::os::raw::c_uint = 25;
pub const NS_STYLE_CURSOR_NOT_ALLOWED: ::std::os::raw::c_uint = 26;
pub const NS_STYLE_CURSOR_COL_RESIZE: ::std::os::raw::c_uint = 27;
pub const NS_STYLE_CURSOR_ROW_RESIZE: ::std::os::raw::c_uint = 28;
pub const NS_STYLE_CURSOR_NO_DROP: ::std::os::raw::c_uint = 29;
pub const NS_STYLE_CURSOR_VERTICAL_TEXT: ::std::os::raw::c_uint = 30;
pub const NS_STYLE_CURSOR_ALL_SCROLL: ::std::os::raw::c_uint = 31;
pub const NS_STYLE_CURSOR_NESW_RESIZE: ::std::os::raw::c_uint = 32;
pub const NS_STYLE_CURSOR_NWSE_RESIZE: ::std::os::raw::c_uint = 33;
pub const NS_STYLE_CURSOR_NS_RESIZE: ::std::os::raw::c_uint = 34;
pub const NS_STYLE_CURSOR_EW_RESIZE: ::std::os::raw::c_uint = 35;
pub const NS_STYLE_CURSOR_NONE: ::std::os::raw::c_uint = 36;
pub const NS_STYLE_DIRECTION_LTR: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_DIRECTION_RTL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_WRITING_MODE_HORIZONTAL_TB: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_WRITING_MODE_VERTICAL_RL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_WRITING_MODE_VERTICAL_LR: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_WRITING_MODE_SIDEWAYS_MASK: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_CONTAIN_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_CONTAIN_STRICT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_CONTAIN_LAYOUT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_CONTAIN_STYLE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_CONTAIN_PAINT: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_ALIGN_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_ALIGN_NORMAL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_ALIGN_START: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_ALIGN_END: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_ALIGN_FLEX_START: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_ALIGN_FLEX_END: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_ALIGN_CENTER: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_ALIGN_LEFT: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_ALIGN_RIGHT: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_ALIGN_BASELINE: ::std::os::raw::c_uint = 9;
pub const NS_STYLE_ALIGN_LAST_BASELINE: ::std::os::raw::c_uint = 10;
pub const NS_STYLE_ALIGN_STRETCH: ::std::os::raw::c_uint = 11;
pub const NS_STYLE_ALIGN_SELF_START: ::std::os::raw::c_uint = 12;
pub const NS_STYLE_ALIGN_SELF_END: ::std::os::raw::c_uint = 13;
pub const NS_STYLE_ALIGN_SPACE_BETWEEN: ::std::os::raw::c_uint = 14;
pub const NS_STYLE_ALIGN_SPACE_AROUND: ::std::os::raw::c_uint = 15;
pub const NS_STYLE_ALIGN_SPACE_EVENLY: ::std::os::raw::c_uint = 16;
pub const NS_STYLE_ALIGN_LEGACY: ::std::os::raw::c_uint = 32;
pub const NS_STYLE_ALIGN_SAFE: ::std::os::raw::c_uint = 64;
pub const NS_STYLE_ALIGN_UNSAFE: ::std::os::raw::c_uint = 128;
pub const NS_STYLE_ALIGN_FLAG_BITS: ::std::os::raw::c_uint = 224;
pub const NS_STYLE_ALIGN_ALL_BITS: ::std::os::raw::c_uint = 255;
pub const NS_STYLE_ALIGN_ALL_SHIFT: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_FLEX_DIRECTION_ROW: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_FLEX_DIRECTION_ROW_REVERSE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_FLEX_DIRECTION_COLUMN: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_FLEX_DIRECTION_COLUMN_REVERSE: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_FLEX_WRAP_NOWRAP: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_FLEX_WRAP_WRAP: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_FLEX_WRAP_WRAP_REVERSE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_ORDER_INITIAL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_FILTER_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_FILTER_URL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_FILTER_BLUR: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_FILTER_BRIGHTNESS: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_FILTER_CONTRAST: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_FILTER_GRAYSCALE: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_FILTER_INVERT: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_FILTER_OPACITY: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_FILTER_SATURATE: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_FILTER_SEPIA: ::std::os::raw::c_uint = 9;
pub const NS_STYLE_FILTER_HUE_ROTATE: ::std::os::raw::c_uint = 10;
pub const NS_STYLE_FILTER_DROP_SHADOW: ::std::os::raw::c_uint = 11;
pub const NS_STYLE_FONT_SIZE_XXSMALL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_FONT_SIZE_XSMALL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_FONT_SIZE_SMALL: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_FONT_SIZE_MEDIUM: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_FONT_SIZE_LARGE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_FONT_SIZE_XLARGE: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_FONT_SIZE_XXLARGE: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_FONT_SIZE_XXXLARGE: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_FONT_SIZE_LARGER: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_FONT_SIZE_SMALLER: ::std::os::raw::c_uint = 9;
pub const NS_STYLE_FONT_CAPTION: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_FONT_ICON: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_FONT_MENU: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_FONT_MESSAGE_BOX: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_FONT_SMALL_CAPTION: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_FONT_STATUS_BAR: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_FONT_WINDOW: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_FONT_DOCUMENT: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_FONT_WORKSPACE: ::std::os::raw::c_uint = 9;
pub const NS_STYLE_FONT_DESKTOP: ::std::os::raw::c_uint = 10;
pub const NS_STYLE_FONT_INFO: ::std::os::raw::c_uint = 11;
pub const NS_STYLE_FONT_DIALOG: ::std::os::raw::c_uint = 12;
pub const NS_STYLE_FONT_BUTTON: ::std::os::raw::c_uint = 13;
pub const NS_STYLE_FONT_PULL_DOWN_MENU: ::std::os::raw::c_uint = 14;
pub const NS_STYLE_FONT_LIST: ::std::os::raw::c_uint = 15;
pub const NS_STYLE_FONT_FIELD: ::std::os::raw::c_uint = 16;
pub const NS_STYLE_GRID_TEMPLATE_SUBGRID: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_GRID_TRACK_BREADTH_MAX_CONTENT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_GRID_TRACK_BREADTH_MIN_CONTENT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_GRID_REPEAT_AUTO_FILL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_GRID_REPEAT_AUTO_FIT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_WIDTH_MAX_CONTENT: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_WIDTH_MIN_CONTENT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_WIDTH_FIT_CONTENT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_WIDTH_AVAILABLE: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_POSITION_STATIC: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_POSITION_RELATIVE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_POSITION_ABSOLUTE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_POSITION_FIXED: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_POSITION_STICKY: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_CLIP_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_CLIP_RECT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_CLIP_TYPE_MASK: ::std::os::raw::c_uint = 15;
pub const NS_STYLE_CLIP_LEFT_AUTO: ::std::os::raw::c_uint = 16;
pub const NS_STYLE_CLIP_TOP_AUTO: ::std::os::raw::c_uint = 32;
pub const NS_STYLE_CLIP_RIGHT_AUTO: ::std::os::raw::c_uint = 64;
pub const NS_STYLE_CLIP_BOTTOM_AUTO: ::std::os::raw::c_uint = 128;
pub const NS_STYLE_FRAME_YES: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_FRAME_NO: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_FRAME_0: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_FRAME_1: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_FRAME_ON: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_FRAME_OFF: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_FRAME_AUTO: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_FRAME_SCROLL: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_FRAME_NOSCROLL: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_OVERFLOW_VISIBLE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_OVERFLOW_HIDDEN: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_OVERFLOW_SCROLL: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_OVERFLOW_AUTO: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_OVERFLOW_CLIP: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_OVERFLOW_SCROLLBARS_HORIZONTAL: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_OVERFLOW_SCROLLBARS_VERTICAL: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_OVERFLOW_CLIP_BOX_PADDING_BOX: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_OVERFLOW_CLIP_BOX_CONTENT_BOX: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_LIST_STYLE_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_LIST_STYLE_DISC: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_LIST_STYLE_CIRCLE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_LIST_STYLE_SQUARE: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_LIST_STYLE_DECIMAL: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_LIST_STYLE_HEBREW: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_LIST_STYLE_JAPANESE_INFORMAL: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_LIST_STYLE_JAPANESE_FORMAL: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_LIST_STYLE_KOREAN_HANGUL_FORMAL: ::std::os::raw::c_uint =
    8;
pub const NS_STYLE_LIST_STYLE_KOREAN_HANJA_INFORMAL: ::std::os::raw::c_uint =
    9;
pub const NS_STYLE_LIST_STYLE_KOREAN_HANJA_FORMAL: ::std::os::raw::c_uint =
    10;
pub const NS_STYLE_LIST_STYLE_SIMP_CHINESE_INFORMAL: ::std::os::raw::c_uint =
    11;
pub const NS_STYLE_LIST_STYLE_SIMP_CHINESE_FORMAL: ::std::os::raw::c_uint =
    12;
pub const NS_STYLE_LIST_STYLE_TRAD_CHINESE_INFORMAL: ::std::os::raw::c_uint =
    13;
pub const NS_STYLE_LIST_STYLE_TRAD_CHINESE_FORMAL: ::std::os::raw::c_uint =
    14;
pub const NS_STYLE_LIST_STYLE_ETHIOPIC_NUMERIC: ::std::os::raw::c_uint = 15;
pub const NS_STYLE_LIST_STYLE_DISCLOSURE_CLOSED: ::std::os::raw::c_uint = 16;
pub const NS_STYLE_LIST_STYLE_DISCLOSURE_OPEN: ::std::os::raw::c_uint = 17;
pub const NS_STYLE_LIST_STYLE__MAX: ::std::os::raw::c_uint = 18;
pub const NS_STYLE_LIST_STYLE_LOWER_ROMAN: ::std::os::raw::c_uint = 100;
pub const NS_STYLE_LIST_STYLE_UPPER_ROMAN: ::std::os::raw::c_uint = 101;
pub const NS_STYLE_LIST_STYLE_LOWER_ALPHA: ::std::os::raw::c_uint = 102;
pub const NS_STYLE_LIST_STYLE_UPPER_ALPHA: ::std::os::raw::c_uint = 103;
pub const NS_STYLE_LIST_STYLE_POSITION_INSIDE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_LIST_STYLE_POSITION_OUTSIDE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_MARGIN_SIZE_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_POINTER_EVENTS_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_POINTER_EVENTS_VISIBLEPAINTED: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_POINTER_EVENTS_VISIBLEFILL: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_POINTER_EVENTS_VISIBLESTROKE: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_POINTER_EVENTS_VISIBLE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_POINTER_EVENTS_PAINTED: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_POINTER_EVENTS_FILL: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_POINTER_EVENTS_STROKE: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_POINTER_EVENTS_ALL: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_POINTER_EVENTS_AUTO: ::std::os::raw::c_uint = 9;
pub const NS_STYLE_IMAGE_ORIENTATION_FLIP: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_IMAGE_ORIENTATION_FROM_IMAGE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_ISOLATION_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_ISOLATION_ISOLATE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_OBJECT_FIT_FILL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_OBJECT_FIT_CONTAIN: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_OBJECT_FIT_COVER: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_OBJECT_FIT_NONE: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_OBJECT_FIT_SCALE_DOWN: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_RESIZE_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_RESIZE_BOTH: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_RESIZE_HORIZONTAL: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_RESIZE_VERTICAL: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_TEXT_ALIGN_START: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_ALIGN_LEFT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TEXT_ALIGN_RIGHT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TEXT_ALIGN_CENTER: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_TEXT_ALIGN_JUSTIFY: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_TEXT_ALIGN_CHAR: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_TEXT_ALIGN_END: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_TEXT_ALIGN_AUTO: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_TEXT_ALIGN_MOZ_CENTER: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_TEXT_ALIGN_MOZ_RIGHT: ::std::os::raw::c_uint = 9;
pub const NS_STYLE_TEXT_ALIGN_MOZ_LEFT: ::std::os::raw::c_uint = 10;
pub const NS_STYLE_TEXT_ALIGN_MOZ_CENTER_OR_INHERIT: ::std::os::raw::c_uint =
    11;
pub const NS_STYLE_TEXT_ALIGN_UNSAFE: ::std::os::raw::c_uint = 12;
pub const NS_STYLE_TEXT_ALIGN_MATCH_PARENT: ::std::os::raw::c_uint = 13;
pub const NS_STYLE_TEXT_DECORATION_LINE_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TEXT_DECORATION_LINE_OVERLINE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH: ::std::os::raw::c_uint =
    4;
pub const NS_STYLE_TEXT_DECORATION_LINE_BLINK: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_TEXT_DECORATION_LINE_PREF_ANCHORS: ::std::os::raw::c_uint =
    16;
pub const NS_STYLE_TEXT_DECORATION_LINE_OVERRIDE_ALL: ::std::os::raw::c_uint =
    32;
pub const NS_STYLE_TEXT_DECORATION_STYLE_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_DECORATION_STYLE_DOTTED: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TEXT_DECORATION_STYLE_DASHED: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TEXT_DECORATION_STYLE_SOLID: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_TEXT_DECORATION_STYLE_DOUBLE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_TEXT_DECORATION_STYLE_WAVY: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_TEXT_OVERFLOW_CLIP: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_OVERFLOW_ELLIPSIS: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TEXT_OVERFLOW_STRING: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TEXT_TRANSFORM_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_TRANSFORM_CAPITALIZE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TEXT_TRANSFORM_LOWERCASE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TEXT_TRANSFORM_UPPERCASE: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_TEXT_TRANSFORM_FULL_WIDTH: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_TOP_LAYER_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TOP_LAYER_TOP: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TRANSFORM_BOX_BORDER_BOX: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TRANSFORM_BOX_FILL_BOX: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TRANSFORM_BOX_VIEW_BOX: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE: ::std::os::raw::c_uint =
    0;
pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_LINEAR: ::std::os::raw::c_uint =
    1;
pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN: ::std::os::raw::c_uint
          =
    2;
pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_OUT: ::std::os::raw::c_uint
          =
    3;
pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN_OUT:
          ::std::os::raw::c_uint =
    4;
pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_STEP_START:
          ::std::os::raw::c_uint =
    5;
pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_STEP_END: ::std::os::raw::c_uint
          =
    6;
pub const NS_STYLE_VERTICAL_ALIGN_BASELINE: ::std::os::raw::c_uint = 14;
pub const NS_STYLE_VERTICAL_ALIGN_SUB: ::std::os::raw::c_uint = 15;
pub const NS_STYLE_VERTICAL_ALIGN_SUPER: ::std::os::raw::c_uint = 16;
pub const NS_STYLE_VERTICAL_ALIGN_TOP: ::std::os::raw::c_uint = 17;
pub const NS_STYLE_VERTICAL_ALIGN_TEXT_TOP: ::std::os::raw::c_uint = 18;
pub const NS_STYLE_VERTICAL_ALIGN_MIDDLE: ::std::os::raw::c_uint = 19;
pub const NS_STYLE_VERTICAL_ALIGN_TEXT_BOTTOM: ::std::os::raw::c_uint = 20;
pub const NS_STYLE_VERTICAL_ALIGN_BOTTOM: ::std::os::raw::c_uint = 21;
pub const NS_STYLE_VERTICAL_ALIGN_MIDDLE_WITH_BASELINE: ::std::os::raw::c_uint
          =
    22;
pub const NS_STYLE_VISIBILITY_HIDDEN: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_VISIBILITY_VISIBLE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_VISIBILITY_COLLAPSE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TABSIZE_INITIAL: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_WHITESPACE_NORMAL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_WHITESPACE_PRE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_WHITESPACE_NOWRAP: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_WHITESPACE_PRE_WRAP: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_WHITESPACE_PRE_LINE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_WHITESPACE_PRE_SPACE: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_WORDBREAK_NORMAL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_WORDBREAK_BREAK_ALL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_WORDBREAK_KEEP_ALL: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_OVERFLOWWRAP_NORMAL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_OVERFLOWWRAP_BREAK_WORD: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_HYPHENS_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_HYPHENS_MANUAL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_HYPHENS_AUTO: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_RUBY_ALIGN_START: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_RUBY_ALIGN_CENTER: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_RUBY_ALIGN_SPACE_BETWEEN: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_RUBY_ALIGN_SPACE_AROUND: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_RUBY_POSITION_OVER: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_RUBY_POSITION_UNDER: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_RUBY_POSITION_INTER_CHARACTER: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TEXT_SIZE_ADJUST_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_SIZE_ADJUST_AUTO: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TEXT_ORIENTATION_MIXED: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_ORIENTATION_UPRIGHT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TEXT_ORIENTATION_SIDEWAYS: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_ALL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_DIGITS_2: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_DIGITS_3: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_DIGITS_4: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_LINE_HEIGHT_BLOCK_HEIGHT: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_UNICODE_BIDI_NORMAL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_UNICODE_BIDI_EMBED: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_UNICODE_BIDI_ISOLATE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_UNICODE_BIDI_BIDI_OVERRIDE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_UNICODE_BIDI_ISOLATE_OVERRIDE: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_UNICODE_BIDI_PLAINTEXT: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_TABLE_LAYOUT_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TABLE_LAYOUT_FIXED: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TABLE_EMPTY_CELLS_HIDE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TABLE_EMPTY_CELLS_SHOW: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_CAPTION_SIDE_TOP: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_CAPTION_SIDE_RIGHT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_CAPTION_SIDE_BOTTOM: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_CAPTION_SIDE_LEFT: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_CELL_SCOPE_ROW: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_CELL_SCOPE_COL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_CELL_SCOPE_ROWGROUP: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_CELL_SCOPE_COLGROUP: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_PAGE_MARKS_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_PAGE_MARKS_CROP: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_PAGE_MARKS_REGISTER: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_PAGE_SIZE_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_PAGE_SIZE_PORTRAIT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_PAGE_SIZE_LANDSCAPE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_PAGE_BREAK_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_PAGE_BREAK_ALWAYS: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_PAGE_BREAK_AVOID: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_PAGE_BREAK_LEFT: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_PAGE_BREAK_RIGHT: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_COLUMN_COUNT_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_COLUMN_FILL_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_COLUMN_FILL_BALANCE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_IME_MODE_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_IME_MODE_NORMAL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_IME_MODE_ACTIVE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_IME_MODE_DISABLED: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_IME_MODE_INACTIVE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_GRADIENT_SHAPE_LINEAR: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_GRADIENT_SHAPE_ELLIPTICAL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_GRADIENT_SHAPE_CIRCULAR: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_GRADIENT_SIZE_CLOSEST_SIDE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_GRADIENT_SIZE_CLOSEST_CORNER: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_GRADIENT_SIZE_FARTHEST_SIDE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_GRADIENT_SIZE_FARTHEST_CORNER: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_GRADIENT_SIZE_EXPLICIT_SIZE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_DOMINANT_BASELINE_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_DOMINANT_BASELINE_USE_SCRIPT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_DOMINANT_BASELINE_NO_CHANGE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_DOMINANT_BASELINE_RESET_SIZE: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_DOMINANT_BASELINE_IDEOGRAPHIC: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_DOMINANT_BASELINE_ALPHABETIC: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_DOMINANT_BASELINE_HANGING: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_DOMINANT_BASELINE_MATHEMATICAL: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_DOMINANT_BASELINE_CENTRAL: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_DOMINANT_BASELINE_MIDDLE: ::std::os::raw::c_uint = 9;
pub const NS_STYLE_DOMINANT_BASELINE_TEXT_AFTER_EDGE: ::std::os::raw::c_uint =
    10;
pub const NS_STYLE_DOMINANT_BASELINE_TEXT_BEFORE_EDGE: ::std::os::raw::c_uint
          =
    11;
pub const NS_STYLE_IMAGE_RENDERING_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_IMAGE_RENDERING_OPTIMIZESPEED: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_IMAGE_RENDERING_OPTIMIZEQUALITY: ::std::os::raw::c_uint =
    2;
pub const NS_STYLE_IMAGE_RENDERING_CRISPEDGES: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_MASK_TYPE_LUMINANCE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_MASK_TYPE_ALPHA: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_PAINT_ORDER_NORMAL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_PAINT_ORDER_FILL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_PAINT_ORDER_STROKE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_PAINT_ORDER_MARKERS: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_PAINT_ORDER_BITWIDTH: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_SHAPE_RENDERING_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_SHAPE_RENDERING_OPTIMIZESPEED: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_SHAPE_RENDERING_CRISPEDGES: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_SHAPE_RENDERING_GEOMETRICPRECISION: ::std::os::raw::c_uint
          =
    3;
pub const NS_STYLE_STROKE_LINECAP_BUTT: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_STROKE_LINECAP_ROUND: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_STROKE_LINECAP_SQUARE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_STROKE_LINEJOIN_MITER: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_STROKE_LINEJOIN_ROUND: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_STROKE_LINEJOIN_BEVEL: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_STROKE_PROP_CONTEXT_VALUE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_ANCHOR_START: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_ANCHOR_MIDDLE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TEXT_ANCHOR_END: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TEXT_EMPHASIS_STYLE_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_EMPHASIS_STYLE_SHAPE_MASK: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_TEXT_EMPHASIS_STYLE_DOT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TEXT_EMPHASIS_STYLE_CIRCLE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TEXT_EMPHASIS_STYLE_DOUBLE_CIRCLE: ::std::os::raw::c_uint =
    3;
pub const NS_STYLE_TEXT_EMPHASIS_STYLE_TRIANGLE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_TEXT_EMPHASIS_STYLE_SESAME: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_TEXT_EMPHASIS_STYLE_STRING: ::std::os::raw::c_uint = 255;
pub const NS_STYLE_TEXT_RENDERING_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_RENDERING_OPTIMIZESPEED: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TEXT_RENDERING_OPTIMIZELEGIBILITY: ::std::os::raw::c_uint =
    2;
pub const NS_STYLE_TEXT_RENDERING_GEOMETRICPRECISION: ::std::os::raw::c_uint =
    3;
pub const NS_STYLE_COLOR_ADJUST_ECONOMY: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_COLOR_ADJUST_EXACT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_COLOR_INTERPOLATION_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_COLOR_INTERPOLATION_SRGB: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_COLOR_INTERPOLATION_LINEARRGB: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_VECTOR_EFFECT_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_VECTOR_EFFECT_NON_SCALING_STROKE: ::std::os::raw::c_uint =
    1;
pub const NS_STYLE_BACKFACE_VISIBILITY_VISIBLE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_BACKFACE_VISIBILITY_HIDDEN: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TRANSFORM_STYLE_FLAT: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TRANSFORM_STYLE_PRESERVE_3D: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_CONTEXT_FILL_OPACITY: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_CONTEXT_STROKE_OPACITY: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_BLEND_NORMAL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_BLEND_MULTIPLY: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_BLEND_SCREEN: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_BLEND_OVERLAY: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_BLEND_DARKEN: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_BLEND_LIGHTEN: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_BLEND_COLOR_DODGE: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_BLEND_COLOR_BURN: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_BLEND_HARD_LIGHT: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_BLEND_SOFT_LIGHT: ::std::os::raw::c_uint = 9;
pub const NS_STYLE_BLEND_DIFFERENCE: ::std::os::raw::c_uint = 10;
pub const NS_STYLE_BLEND_EXCLUSION: ::std::os::raw::c_uint = 11;
pub const NS_STYLE_BLEND_HUE: ::std::os::raw::c_uint = 12;
pub const NS_STYLE_BLEND_SATURATION: ::std::os::raw::c_uint = 13;
pub const NS_STYLE_BLEND_COLOR: ::std::os::raw::c_uint = 14;
pub const NS_STYLE_BLEND_LUMINOSITY: ::std::os::raw::c_uint = 15;
pub const NS_STYLE_MASK_COMPOSITE_ADD: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_MASK_COMPOSITE_SUBTRACT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_MASK_COMPOSITE_INTERSECT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_MASK_COMPOSITE_EXCLUDE: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_CONTROL_CHARACTER_VISIBILITY_HIDDEN: ::std::os::raw::c_uint
          =
    0;
pub const NS_STYLE_CONTROL_CHARACTER_VISIBILITY_VISIBLE:
          ::std::os::raw::c_uint =
    1;
pub const NS_STYLE_COUNTER_SYSTEM_CYCLIC: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_COUNTER_SYSTEM_NUMERIC: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_COUNTER_SYSTEM_ALPHABETIC: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_COUNTER_SYSTEM_SYMBOLIC: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_COUNTER_SYSTEM_ADDITIVE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_COUNTER_SYSTEM_FIXED: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_COUNTER_SYSTEM_EXTENDS: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_COUNTER_RANGE_INFINITE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_COUNTER_SPEAKAS_BULLETS: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_COUNTER_SPEAKAS_NUMBERS: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_COUNTER_SPEAKAS_WORDS: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_COUNTER_SPEAKAS_SPELL_OUT: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_COUNTER_SPEAKAS_OTHER: ::std::os::raw::c_uint = 255;
pub const NS_STYLE_SCROLL_BEHAVIOR_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_SCROLL_BEHAVIOR_SMOOTH: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_SCROLL_SNAP_TYPE_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_SCROLL_SNAP_TYPE_MANDATORY: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_SCROLL_SNAP_TYPE_PROXIMITY: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_ORIENTATION_PORTRAIT: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_ORIENTATION_LANDSCAPE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_SCAN_PROGRESSIVE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_SCAN_INTERLACE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_DISPLAY_MODE_BROWSER: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_DISPLAY_MODE_MINIMAL_UI: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_DISPLAY_MODE_STANDALONE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_DISPLAY_MODE_FULLSCREEN: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_INHERIT_MASK: ::std::os::raw::c_uint = 16777215;
pub const NS_STYLE_HAS_TEXT_DECORATION_LINES: ::std::os::raw::c_uint =
    16777216;
pub const NS_STYLE_HAS_PSEUDO_ELEMENT_DATA: ::std::os::raw::c_uint = 33554432;
pub const NS_STYLE_RELEVANT_LINK_VISITED: ::std::os::raw::c_uint = 67108864;
pub const NS_STYLE_IS_STYLE_IF_VISITED: ::std::os::raw::c_uint = 134217728;
pub const NS_STYLE_CHILD_USES_GRANDANCESTOR_STYLE: ::std::os::raw::c_uint =
    268435456;
pub const NS_STYLE_IS_SHARED: ::std::os::raw::c_uint = 536870912;
pub const NS_STYLE_IS_GOING_AWAY: ::std::os::raw::c_uint = 1073741824;
pub const NS_STYLE_SUPPRESS_LINEBREAK: ::std::os::raw::c_uint = 2147483648;
pub const NS_STYLE_IN_DISPLAY_NONE_SUBTREE: ::std::os::raw::c_ulonglong =
    4294967296;
pub const NS_STYLE_INELIGIBLE_FOR_SHARING: ::std::os::raw::c_ulonglong =
    8589934592;
pub const NS_STYLE_HAS_CHILD_THAT_USES_RESET_STYLE:
          ::std::os::raw::c_ulonglong =
    17179869184;
pub const NS_STYLE_IS_TEXT_COMBINED: ::std::os::raw::c_ulonglong =
    34359738368;
pub const NS_STYLE_CONTEXT_TYPE_SHIFT: ::std::os::raw::c_uint = 36;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fallible_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_fallible_t() {
    assert_eq!(::std::mem::size_of::<fallible_t>() , 1usize);
    assert_eq!(::std::mem::align_of::<fallible_t>() , 1usize);
}
impl Clone for fallible_t {
    fn clone(&self) -> Self { *self }
}
/** Convenient aliases. */
pub type TrueType = u8;
pub type FalseType = u8;
/**
 * MozRefCountType is Mozilla's reference count type.
 *
 * We use the same type to represent the refcount of RefCounted objects
 * as well, in order to be able to use the leak detection facilities
 * that are implemented by XPCOM.
 *
 * Note that this type is not in the mozilla namespace so that it is
 * usable for both C and C++ code.
 */
pub type MozRefCountType = usize;
pub const nsresult_NS_ERROR_NO_INTERFACE: nsresult = nsresult::NS_NOINTERFACE;
pub const nsresult_NS_ERROR_INVALID_ARG: nsresult =
    nsresult::NS_ERROR_ILLEGAL_VALUE;
pub const nsresult_NS_ERROR_INVALID_POINTER: nsresult =
    nsresult::NS_ERROR_ILLEGAL_VALUE;
pub const nsresult_NS_ERROR_NULL_POINTER: nsresult =
    nsresult::NS_ERROR_ILLEGAL_VALUE;
pub const nsresult_NS_BINDING_SUCCEEDED: nsresult = nsresult::NS_OK;
pub const nsresult_NS_NET_STATUS_RESOLVING_HOST: nsresult =
    nsresult::NS_BINDING_REDIRECTED;
pub const nsresult_NS_NET_STATUS_RESOLVED_HOST: nsresult =
    nsresult::NS_ERROR_ALREADY_CONNECTED;
pub const nsresult_NS_NET_STATUS_CONNECTED_TO: nsresult =
    nsresult::NS_BINDING_RETARGETED;
pub const nsresult_NS_NET_STATUS_WAITING_FOR: nsresult =
    nsresult::NS_ERROR_MALFORMED_URI;
pub const nsresult_NS_STATE_PROPERTY_EXISTS: nsresult = nsresult::NS_OK;
pub const nsresult_NS_ERROR_HTMLPARSER_CONTINUE: nsresult = nsresult::NS_OK;
pub const nsresult_NS_RDF_ASSERTION_ACCEPTED: nsresult = nsresult::NS_OK;
pub const nsresult_NS_EXACT_LENGTH: nsresult =
    nsresult::NS_OK_UDEC_EXACTLENGTH;
pub const nsresult_NS_PARTIAL_MORE_INPUT: nsresult =
    nsresult::NS_OK_UDEC_MOREINPUT;
pub const nsresult_NS_PARTIAL_MORE_OUTPUT: nsresult =
    nsresult::NS_OK_UDEC_MOREOUTPUT;
pub const nsresult_NS_ERROR_ILLEGAL_INPUT: nsresult =
    nsresult::NS_ERROR_UDEC_ILLEGALINPUT;
pub const nsresult_NS_ERROR_XPATH_INVALID_ARG: nsresult =
    nsresult::NS_ERROR_ILLEGAL_VALUE;
pub const nsresult_NS_SUCCESS_RESTART_APP: nsresult =
    nsresult::NS_SUCCESS_DONT_FIXUP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsresult {
    NS_OK = 0,
    NS_ERROR_BASE = 3253927936,
    NS_ERROR_NOT_INITIALIZED = 3253927937,
    NS_ERROR_ALREADY_INITIALIZED = 3253927938,
    NS_ERROR_NOT_IMPLEMENTED = 2147500033,
    NS_NOINTERFACE = 2147500034,
    NS_ERROR_ABORT = 2147500036,
    NS_ERROR_FAILURE = 2147500037,
    NS_ERROR_UNEXPECTED = 2147549183,
    NS_ERROR_OUT_OF_MEMORY = 2147942414,
    NS_ERROR_ILLEGAL_VALUE = 2147942487,
    NS_ERROR_NO_AGGREGATION = 2147746064,
    NS_ERROR_NOT_AVAILABLE = 2147746065,
    NS_ERROR_FACTORY_NOT_REGISTERED = 2147746132,
    NS_ERROR_FACTORY_REGISTER_AGAIN = 2147746133,
    NS_ERROR_FACTORY_NOT_LOADED = 2147746296,
    NS_ERROR_FACTORY_NO_SIGNATURE_SUPPORT = 3253928193,
    NS_ERROR_FACTORY_EXISTS = 3253928192,
    NS_ERROR_CANNOT_CONVERT_DATA = 2152071169,
    NS_ERROR_OBJECT_IS_IMMUTABLE = 2152071170,
    NS_ERROR_LOSS_OF_SIGNIFICANT_DATA = 2152071171,
    NS_ERROR_NOT_SAME_THREAD = 2152071172,
    NS_ERROR_ILLEGAL_DURING_SHUTDOWN = 2152071198,
    NS_ERROR_SERVICE_NOT_AVAILABLE = 2152071190,
    NS_SUCCESS_LOSS_OF_INSIGNIFICANT_DATA = 4587521,
    NS_SUCCESS_INTERRUPTED_TRAVERSE = 4587522,
    NS_ERROR_SERVICE_NOT_FOUND = 4587542,
    NS_ERROR_SERVICE_IN_USE = 4587543,
    NS_BASE_STREAM_CLOSED = 2152136706,
    NS_BASE_STREAM_OSERROR = 2152136707,
    NS_BASE_STREAM_ILLEGAL_ARGS = 2152136708,
    NS_BASE_STREAM_NO_CONVERTER = 2152136709,
    NS_BASE_STREAM_BAD_CONVERSION = 2152136710,
    NS_BASE_STREAM_WOULD_BLOCK = 2152136711,
    NS_ERROR_GFX_PRINTER_NO_PRINTER_AVAILABLE = 2152202241,
    NS_ERROR_GFX_PRINTER_NAME_NOT_FOUND = 2152202242,
    NS_ERROR_GFX_PRINTER_COULD_NOT_OPEN_FILE = 2152202243,
    NS_ERROR_GFX_PRINTER_STARTDOC = 2152202244,
    NS_ERROR_GFX_PRINTER_ENDDOC = 2152202245,
    NS_ERROR_GFX_PRINTER_STARTPAGE = 2152202246,
    NS_ERROR_GFX_PRINTER_DOC_IS_BUSY = 2152202247,
    NS_ERROR_GFX_CMAP_MALFORMED = 2152202291,
    NS_SUCCESS_EVENT_CONSUMED = 4784129,
    NS_SUCCESS_EVENT_HANDLED_ASYNCHRONOUSLY = 4784130,
    NS_BINDING_FAILED = 2152398849,
    NS_BINDING_ABORTED = 2152398850,
    NS_BINDING_REDIRECTED = 2152398851,
    NS_BINDING_RETARGETED = 2152398852,
    NS_ERROR_MALFORMED_URI = 2152398858,
    NS_ERROR_IN_PROGRESS = 2152398863,
    NS_ERROR_NO_CONTENT = 2152398865,
    NS_ERROR_UNKNOWN_PROTOCOL = 2152398866,
    NS_ERROR_INVALID_CONTENT_ENCODING = 2152398875,
    NS_ERROR_CORRUPTED_CONTENT = 2152398877,
    NS_ERROR_INVALID_SIGNATURE = 2152398906,
    NS_ERROR_FIRST_HEADER_FIELD_COMPONENT_EMPTY = 2152398882,
    NS_ERROR_ALREADY_OPENED = 2152398921,
    NS_ERROR_ALREADY_CONNECTED = 2152398859,
    NS_ERROR_NOT_CONNECTED = 2152398860,
    NS_ERROR_CONNECTION_REFUSED = 2152398861,
    NS_ERROR_NET_TIMEOUT = 2152398862,
    NS_ERROR_OFFLINE = 2152398864,
    NS_ERROR_PORT_ACCESS_NOT_ALLOWED = 2152398867,
    NS_ERROR_NET_RESET = 2152398868,
    NS_ERROR_NET_INTERRUPT = 2152398919,
    NS_ERROR_PROXY_CONNECTION_REFUSED = 2152398920,
    NS_ERROR_NET_PARTIAL_TRANSFER = 2152398924,
    NS_ERROR_NET_INADEQUATE_SECURITY = 2152398930,
    NS_ERROR_NOT_RESUMABLE = 2152398873,
    NS_ERROR_REDIRECT_LOOP = 2152398879,
    NS_ERROR_ENTITY_CHANGED = 2152398880,
    NS_ERROR_UNSAFE_CONTENT_TYPE = 2152398922,
    NS_ERROR_REMOTE_XUL = 2152398923,
    NS_ERROR_LOAD_SHOWED_ERRORPAGE = 2152398925,
    NS_ERROR_FTP_LOGIN = 2152398869,
    NS_ERROR_FTP_CWD = 2152398870,
    NS_ERROR_FTP_PASV = 2152398871,
    NS_ERROR_FTP_PWD = 2152398872,
    NS_ERROR_FTP_LIST = 2152398876,
    NS_ERROR_UNKNOWN_HOST = 2152398878,
    NS_ERROR_DNS_LOOKUP_QUEUE_FULL = 2152398881,
    NS_ERROR_UNKNOWN_PROXY_HOST = 2152398890,
    NS_ERROR_UNKNOWN_SOCKET_TYPE = 2152398899,
    NS_ERROR_SOCKET_CREATE_FAILED = 2152398900,
    NS_ERROR_SOCKET_ADDRESS_NOT_SUPPORTED = 2152398901,
    NS_ERROR_SOCKET_ADDRESS_IN_USE = 2152398902,
    NS_ERROR_CACHE_KEY_NOT_FOUND = 2152398909,
    NS_ERROR_CACHE_DATA_IS_STREAM = 2152398910,
    NS_ERROR_CACHE_DATA_IS_NOT_STREAM = 2152398911,
    NS_ERROR_CACHE_WAIT_FOR_VALIDATION = 2152398912,
    NS_ERROR_CACHE_ENTRY_DOOMED = 2152398913,
    NS_ERROR_CACHE_READ_ACCESS_DENIED = 2152398914,
    NS_ERROR_CACHE_WRITE_ACCESS_DENIED = 2152398915,
    NS_ERROR_CACHE_IN_USE = 2152398916,
    NS_ERROR_DOCUMENT_NOT_CACHED = 2152398918,
    NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS = 2152398928,
    NS_ERROR_HOST_IS_IP_ADDRESS = 2152398929,
    NS_SUCCESS_ADOPTED_DATA = 4915290,
    NS_NET_STATUS_BEGIN_FTP_TRANSACTION = 4915227,
    NS_NET_STATUS_END_FTP_TRANSACTION = 4915228,
    NS_SUCCESS_AUTH_FINISHED = 4915240,
    NS_NET_STATUS_READING = 2152398856,
    NS_NET_STATUS_WRITING = 2152398857,
    NS_NET_STATUS_CONNECTING_TO = 2152398855,
    NS_NET_STATUS_SENDING_TO = 2152398853,
    NS_NET_STATUS_RECEIVING_FROM = 2152398854,
    NS_ERROR_INTERCEPTION_FAILED = 2152398948,
    NS_ERROR_PLUGINS_PLUGINSNOTCHANGED = 2152465384,
    NS_ERROR_PLUGIN_DISABLED = 2152465385,
    NS_ERROR_PLUGIN_BLOCKLISTED = 2152465386,
    NS_ERROR_PLUGIN_TIME_RANGE_NOT_SUPPORTED = 2152465387,
    NS_ERROR_PLUGIN_CLICKTOPLAY = 2152465388,
    NS_PLUGIN_INIT_PENDING = 4981741,
    NS_TABLELAYOUT_CELL_NOT_FOUND = 5046272,
    NS_POSITION_BEFORE_TABLE = 5046275,
    NS_STATE_PROPERTY_NOT_THERE = 5046277,
    NS_ERROR_HTMLPARSER_EOF = 2152596456,
    NS_ERROR_HTMLPARSER_UNKNOWN = 2152596457,
    NS_ERROR_HTMLPARSER_CANTPROPAGATE = 2152596458,
    NS_ERROR_HTMLPARSER_CONTEXTMISMATCH = 2152596459,
    NS_ERROR_HTMLPARSER_BADFILENAME = 2152596460,
    NS_ERROR_HTMLPARSER_BADURL = 2152596461,
    NS_ERROR_HTMLPARSER_INVALIDPARSERCONTEXT = 2152596462,
    NS_ERROR_HTMLPARSER_INTERRUPTED = 2152596463,
    NS_ERROR_HTMLPARSER_BLOCK = 2152596464,
    NS_ERROR_HTMLPARSER_BADTOKENIZER = 2152596465,
    NS_ERROR_HTMLPARSER_BADATTRIBUTE = 2152596466,
    NS_ERROR_HTMLPARSER_UNRESOLVEDDTD = 2152596467,
    NS_ERROR_HTMLPARSER_MISPLACEDTABLECONTENT = 2152596468,
    NS_ERROR_HTMLPARSER_BADDTD = 2152596469,
    NS_ERROR_HTMLPARSER_BADCONTEXT = 2152596470,
    NS_ERROR_HTMLPARSER_STOPPARSING = 2152596471,
    NS_ERROR_HTMLPARSER_UNTERMINATEDSTRINGLITERAL = 2152596472,
    NS_ERROR_HTMLPARSER_HIERARCHYTOODEEP = 2152596473,
    NS_ERROR_HTMLPARSER_FAKE_ENDTAG = 2152596474,
    NS_ERROR_HTMLPARSER_INVALID_COMMENT = 2152596475,
    NS_HTMLTOKENS_NOT_AN_ENTITY = 5113808,
    NS_HTMLPARSER_VALID_META_CHARSET = 5114808,
    NS_RDF_CURSOR_EMPTY = 5177345,
    NS_RDF_NO_VALUE = 5177346,
    NS_RDF_ASSERTION_REJECTED = 5177347,
    NS_RDF_STOP_VISIT = 5177348,
    NS_ERROR_UCONV_NOCONV = 2152726529,
    NS_ERROR_UDEC_ILLEGALINPUT = 2152726542,
    NS_SUCCESS_USING_FALLBACK_LOCALE = 5242882,
    NS_OK_UDEC_EXACTLENGTH = 5242891,
    NS_OK_UDEC_MOREINPUT = 5242892,
    NS_OK_UDEC_MOREOUTPUT = 5242893,
    NS_OK_UDEC_NOBOMFOUND = 5242894,
    NS_OK_UENC_EXACTLENGTH = 5242913,
    NS_OK_UENC_MOREOUTPUT = 5242914,
    NS_ERROR_UENC_NOMAPPING = 5242915,
    NS_OK_UENC_MOREINPUT = 5242916,
    NS_ERROR_FILE_UNRECOGNIZED_PATH = 2152857601,
    NS_ERROR_FILE_UNRESOLVABLE_SYMLINK = 2152857602,
    NS_ERROR_FILE_EXECUTION_FAILED = 2152857603,
    NS_ERROR_FILE_UNKNOWN_TYPE = 2152857604,
    NS_ERROR_FILE_DESTINATION_NOT_DIR = 2152857605,
    NS_ERROR_FILE_TARGET_DOES_NOT_EXIST = 2152857606,
    NS_ERROR_FILE_COPY_OR_MOVE_FAILED = 2152857607,
    NS_ERROR_FILE_ALREADY_EXISTS = 2152857608,
    NS_ERROR_FILE_INVALID_PATH = 2152857609,
    NS_ERROR_FILE_DISK_FULL = 2152857610,
    NS_ERROR_FILE_CORRUPTED = 2152857611,
    NS_ERROR_FILE_NOT_DIRECTORY = 2152857612,
    NS_ERROR_FILE_IS_DIRECTORY = 2152857613,
    NS_ERROR_FILE_IS_LOCKED = 2152857614,
    NS_ERROR_FILE_TOO_BIG = 2152857615,
    NS_ERROR_FILE_NO_DEVICE_SPACE = 2152857616,
    NS_ERROR_FILE_NAME_TOO_LONG = 2152857617,
    NS_ERROR_FILE_NOT_FOUND = 2152857618,
    NS_ERROR_FILE_READ_ONLY = 2152857619,
    NS_ERROR_FILE_DIR_NOT_EMPTY = 2152857620,
    NS_ERROR_FILE_ACCESS_DENIED = 2152857621,
    NS_SUCCESS_FILE_DIRECTORY_EMPTY = 5373953,
    NS_SUCCESS_AGGREGATE_RESULT = 5373954,
    NS_ERROR_DOM_INDEX_SIZE_ERR = 2152923137,
    NS_ERROR_DOM_HIERARCHY_REQUEST_ERR = 2152923139,
    NS_ERROR_DOM_WRONG_DOCUMENT_ERR = 2152923140,
    NS_ERROR_DOM_INVALID_CHARACTER_ERR = 2152923141,
    NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR = 2152923143,
    NS_ERROR_DOM_NOT_FOUND_ERR = 2152923144,
    NS_ERROR_DOM_NOT_SUPPORTED_ERR = 2152923145,
    NS_ERROR_DOM_INUSE_ATTRIBUTE_ERR = 2152923146,
    NS_ERROR_DOM_INVALID_STATE_ERR = 2152923147,
    NS_ERROR_DOM_SYNTAX_ERR = 2152923148,
    NS_ERROR_DOM_INVALID_MODIFICATION_ERR = 2152923149,
    NS_ERROR_DOM_NAMESPACE_ERR = 2152923150,
    NS_ERROR_DOM_INVALID_ACCESS_ERR = 2152923151,
    NS_ERROR_DOM_TYPE_MISMATCH_ERR = 2152923153,
    NS_ERROR_DOM_SECURITY_ERR = 2152923154,
    NS_ERROR_DOM_NETWORK_ERR = 2152923155,
    NS_ERROR_DOM_ABORT_ERR = 2152923156,
    NS_ERROR_DOM_URL_MISMATCH_ERR = 2152923157,
    NS_ERROR_DOM_QUOTA_EXCEEDED_ERR = 2152923158,
    NS_ERROR_DOM_TIMEOUT_ERR = 2152923159,
    NS_ERROR_DOM_INVALID_NODE_TYPE_ERR = 2152923160,
    NS_ERROR_DOM_DATA_CLONE_ERR = 2152923161,
    NS_ERROR_TYPE_ERR = 2152923162,
    NS_ERROR_RANGE_ERR = 2152923163,
    NS_ERROR_DOM_ENCODING_NOT_SUPPORTED_ERR = 2152923164,
    NS_ERROR_DOM_INVALID_POINTER_ERR = 2152923165,
    NS_ERROR_DOM_UNKNOWN_ERR = 2152923166,
    NS_ERROR_DOM_DATA_ERR = 2152923167,
    NS_ERROR_DOM_OPERATION_ERR = 2152923168,
    NS_ERROR_DOM_NOT_ALLOWED_ERR = 2152923169,
    NS_ERROR_DOM_SECMAN_ERR = 2152924137,
    NS_ERROR_DOM_WRONG_TYPE_ERR = 2152924138,
    NS_ERROR_DOM_NOT_OBJECT_ERR = 2152924139,
    NS_ERROR_DOM_NOT_XPC_OBJECT_ERR = 2152924140,
    NS_ERROR_DOM_NOT_NUMBER_ERR = 2152924141,
    NS_ERROR_DOM_NOT_BOOLEAN_ERR = 2152924142,
    NS_ERROR_DOM_NOT_FUNCTION_ERR = 2152924143,
    NS_ERROR_DOM_TOO_FEW_PARAMETERS_ERR = 2152924144,
    NS_ERROR_DOM_BAD_DOCUMENT_DOMAIN = 2152924145,
    NS_ERROR_DOM_PROP_ACCESS_DENIED = 2152924146,
    NS_ERROR_DOM_XPCONNECT_ACCESS_DENIED = 2152924147,
    NS_ERROR_DOM_BAD_URI = 2152924148,
    NS_ERROR_DOM_RETVAL_UNDEFINED = 2152924149,
    NS_ERROR_DOM_QUOTA_REACHED = 2152924150,
    NS_ERROR_DOM_JS_EXCEPTION = 2152924151,
    NS_ERROR_UNCATCHABLE_EXCEPTION = 2152924152,
    NS_ERROR_DOM_DOMEXCEPTION = 2152924153,
    NS_ERROR_DOM_EXCEPTION_ON_JSCONTEXT = 2152924154,
    NS_ERROR_DOM_MALFORMED_URI = 2152924155,
    NS_ERROR_DOM_INVALID_HEADER_NAME = 2152924156,
    NS_ERROR_DOM_INVALID_STATE_XHR_HAS_INVALID_CONTEXT = 2152924157,
    NS_ERROR_DOM_INVALID_STATE_XHR_MUST_BE_OPENED = 2152924158,
    NS_ERROR_DOM_INVALID_STATE_XHR_MUST_NOT_BE_SENDING = 2152924159,
    NS_ERROR_DOM_INVALID_STATE_XHR_MUST_NOT_BE_LOADING_OR_DONE = 2152924160,
    NS_ERROR_DOM_INVALID_STATE_XHR_HAS_WRONG_RESPONSETYPE_FOR_RESPONSEXML =
        2152924161,
    NS_ERROR_DOM_INVALID_STATE_XHR_HAS_WRONG_RESPONSETYPE_FOR_RESPONSETEXT =
        2152924162,
    NS_ERROR_DOM_INVALID_STATE_XHR_CHUNKED_RESPONSETYPES_UNSUPPORTED_FOR_SYNC
        = 2152924163,
    NS_ERROR_DOM_INVALID_ACCESS_XHR_TIMEOUT_AND_RESPONSETYPE_UNSUPPORTED_FOR_SYNC
        = 2152924164,
    NS_SUCCESS_DOM_NO_OPERATION = 5439489,
    NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW = 5439490,
    NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW_UNCATCHABLE = 5439491,
    NS_IMAGELIB_SUCCESS_LOAD_FINISHED = 5505024,
    NS_IMAGELIB_CHANGING_OWNER = 5505025,
    NS_IMAGELIB_ERROR_FAILURE = 2152988677,
    NS_IMAGELIB_ERROR_NO_DECODER = 2152988678,
    NS_IMAGELIB_ERROR_NOT_FINISHED = 2152988679,
    NS_IMAGELIB_ERROR_NO_ENCODER = 2152988681,
    NS_ERROR_EDITOR_NO_SELECTION = 2153119745,
    NS_ERROR_EDITOR_NO_TEXTNODE = 2153119746,
    NS_FOUND_TARGET = 2153119747,
    NS_EDITOR_ELEMENT_NOT_FOUND = 5636097,
    NS_ERROR_XPC_NOT_ENOUGH_ARGS = 2153185281,
    NS_ERROR_XPC_NEED_OUT_OBJECT = 2153185282,
    NS_ERROR_XPC_CANT_SET_OUT_VAL = 2153185283,
    NS_ERROR_XPC_NATIVE_RETURNED_FAILURE = 2153185284,
    NS_ERROR_XPC_CANT_GET_INTERFACE_INFO = 2153185285,
    NS_ERROR_XPC_CANT_GET_PARAM_IFACE_INFO = 2153185286,
    NS_ERROR_XPC_CANT_GET_METHOD_INFO = 2153185287,
    NS_ERROR_XPC_UNEXPECTED = 2153185288,
    NS_ERROR_XPC_BAD_CONVERT_JS = 2153185289,
    NS_ERROR_XPC_BAD_CONVERT_NATIVE = 2153185290,
    NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF = 2153185291,
    NS_ERROR_XPC_BAD_OP_ON_WN_PROTO = 2153185292,
    NS_ERROR_XPC_CANT_CONVERT_WN_TO_FUN = 2153185293,
    NS_ERROR_XPC_CANT_DEFINE_PROP_ON_WN = 2153185294,
    NS_ERROR_XPC_CANT_WATCH_WN_STATIC = 2153185295,
    NS_ERROR_XPC_CANT_EXPORT_WN_STATIC = 2153185296,
    NS_ERROR_XPC_SCRIPTABLE_CALL_FAILED = 2153185297,
    NS_ERROR_XPC_SCRIPTABLE_CTOR_FAILED = 2153185298,
    NS_ERROR_XPC_CANT_CALL_WO_SCRIPTABLE = 2153185299,
    NS_ERROR_XPC_CANT_CTOR_WO_SCRIPTABLE = 2153185300,
    NS_ERROR_XPC_CI_RETURNED_FAILURE = 2153185301,
    NS_ERROR_XPC_GS_RETURNED_FAILURE = 2153185302,
    NS_ERROR_XPC_BAD_CID = 2153185303,
    NS_ERROR_XPC_BAD_IID = 2153185304,
    NS_ERROR_XPC_CANT_CREATE_WN = 2153185305,
    NS_ERROR_XPC_JS_THREW_EXCEPTION = 2153185306,
    NS_ERROR_XPC_JS_THREW_NATIVE_OBJECT = 2153185307,
    NS_ERROR_XPC_JS_THREW_JS_OBJECT = 2153185308,
    NS_ERROR_XPC_JS_THREW_NULL = 2153185309,
    NS_ERROR_XPC_JS_THREW_STRING = 2153185310,
    NS_ERROR_XPC_JS_THREW_NUMBER = 2153185311,
    NS_ERROR_XPC_JAVASCRIPT_ERROR = 2153185312,
    NS_ERROR_XPC_JAVASCRIPT_ERROR_WITH_DETAILS = 2153185313,
    NS_ERROR_XPC_CANT_CONVERT_PRIMITIVE_TO_ARRAY = 2153185314,
    NS_ERROR_XPC_CANT_CONVERT_OBJECT_TO_ARRAY = 2153185315,
    NS_ERROR_XPC_NOT_ENOUGH_ELEMENTS_IN_ARRAY = 2153185316,
    NS_ERROR_XPC_CANT_GET_ARRAY_INFO = 2153185317,
    NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING = 2153185318,
    NS_ERROR_XPC_SECURITY_MANAGER_VETO = 2153185319,
    NS_ERROR_XPC_INTERFACE_NOT_SCRIPTABLE = 2153185320,
    NS_ERROR_XPC_INTERFACE_NOT_FROM_NSISUPPORTS = 2153185321,
    NS_ERROR_XPC_CANT_GET_JSOBJECT_OF_DOM_OBJECT = 2153185322,
    NS_ERROR_XPC_CANT_SET_READ_ONLY_CONSTANT = 2153185323,
    NS_ERROR_XPC_CANT_SET_READ_ONLY_ATTRIBUTE = 2153185324,
    NS_ERROR_XPC_CANT_SET_READ_ONLY_METHOD = 2153185325,
    NS_ERROR_XPC_CANT_ADD_PROP_TO_WRAPPED_NATIVE = 2153185326,
    NS_ERROR_XPC_CALL_TO_SCRIPTABLE_FAILED = 2153185327,
    NS_ERROR_XPC_JSOBJECT_HAS_NO_FUNCTION_NAMED = 2153185328,
    NS_ERROR_XPC_BAD_ID_STRING = 2153185329,
    NS_ERROR_XPC_BAD_INITIALIZER_NAME = 2153185330,
    NS_ERROR_XPC_HAS_BEEN_SHUTDOWN = 2153185331,
    NS_ERROR_XPC_CANT_MODIFY_PROP_ON_WN = 2153185332,
    NS_ERROR_XPC_BAD_CONVERT_JS_ZERO_ISNOT_NULL = 2153185333,
    NS_ERROR_XPC_CANT_PASS_CPOW_TO_NATIVE = 2153185334,
    NS_ERROR_LAUNCHED_CHILD_PROCESS = 2153251016,
    NS_ERROR_CSP_FORM_ACTION_VIOLATION = 2153381986,
    NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION = 2153381987,
    NS_ERROR_SRI_CORRUPT = 2153382088,
    NS_ERROR_SRI_DISABLED = 2153382089,
    NS_ERROR_SRI_NOT_ELIGIBLE = 2153382090,
    NS_ERROR_CMS_VERIFY_NOT_SIGNED = 2153382912,
    NS_ERROR_CMS_VERIFY_NO_CONTENT_INFO = 2153382913,
    NS_ERROR_CMS_VERIFY_BAD_DIGEST = 2153382914,
    NS_ERROR_CMS_VERIFY_NOCERT = 2153382916,
    NS_ERROR_CMS_VERIFY_UNTRUSTED = 2153382917,
    NS_ERROR_CMS_VERIFY_ERROR_UNVERIFIED = 2153382919,
    NS_ERROR_CMS_VERIFY_ERROR_PROCESSING = 2153382920,
    NS_ERROR_CMS_VERIFY_BAD_SIGNATURE = 2153382921,
    NS_ERROR_CMS_VERIFY_DIGEST_MISMATCH = 2153382922,
    NS_ERROR_CMS_VERIFY_UNKNOWN_ALGO = 2153382923,
    NS_ERROR_CMS_VERIFY_UNSUPPORTED_ALGO = 2153382924,
    NS_ERROR_CMS_VERIFY_MALFORMED_SIGNATURE = 2153382925,
    NS_ERROR_CMS_VERIFY_HEADER_MISMATCH = 2153382926,
    NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED = 2153382927,
    NS_ERROR_CMS_VERIFY_CERT_WITHOUT_ADDRESS = 2153382928,
    NS_ERROR_CMS_ENCRYPT_NO_BULK_ALG = 2153382944,
    NS_ERROR_CMS_ENCRYPT_INCOMPLETE = 2153382945,
    NS_ERROR_DOM_INVALID_EXPRESSION_ERR = 2153447475,
    NS_ERROR_DOM_TYPE_ERR = 2153447476,
    NS_ERROR_WONT_HANDLE_CONTENT = 2153578497,
    NS_ERROR_MALWARE_URI = 2153578526,
    NS_ERROR_PHISHING_URI = 2153578527,
    NS_ERROR_TRACKING_URI = 2153578530,
    NS_ERROR_UNWANTED_URI = 2153578531,
    NS_ERROR_BLOCKED_URI = 2153578533,
    NS_ERROR_SAVE_LINK_AS_TIMEOUT = 2153578528,
    NS_ERROR_PARSED_DATA_CACHED = 2153578529,
    NS_REFRESHURI_HEADER_FOUND = 6094850,
    NS_ERROR_IMAGE_SRC_CHANGED = 2153644036,
    NS_ERROR_IMAGE_BLOCKED = 2153644037,
    NS_ERROR_CONTENT_BLOCKED = 2153644038,
    NS_ERROR_CONTENT_BLOCKED_SHOW_ALT = 2153644039,
    NS_PROPTABLE_PROP_NOT_THERE = 2153644042,
    NS_ERROR_XBL_BLOCKED = 2153644047,
    NS_ERROR_CONTENT_CRASHED = 2153644048,
    NS_HTML_STYLE_PROPERTY_NOT_THERE = 6160386,
    NS_CONTENT_BLOCKED = 6160392,
    NS_CONTENT_BLOCKED_SHOW_ALT = 6160393,
    NS_PROPTABLE_PROP_OVERWRITTEN = 6160395,
    NS_FINDBROADCASTER_NOT_FOUND = 6160396,
    NS_FINDBROADCASTER_FOUND = 6160397,
    NS_FINDBROADCASTER_AWAIT_OVERLAYS = 6160398,
    NS_ERROR_XSLT_PARSE_FAILURE = 2153775105,
    NS_ERROR_XPATH_PARSE_FAILURE = 2153775106,
    NS_ERROR_XSLT_ALREADY_SET = 2153775107,
    NS_ERROR_XSLT_EXECUTION_FAILURE = 2153775108,
    NS_ERROR_XPATH_UNKNOWN_FUNCTION = 2153775109,
    NS_ERROR_XSLT_BAD_RECURSION = 2153775110,
    NS_ERROR_XSLT_BAD_VALUE = 2153775111,
    NS_ERROR_XSLT_NODESET_EXPECTED = 2153775112,
    NS_ERROR_XSLT_ABORTED = 2153775113,
    NS_ERROR_XSLT_NETWORK_ERROR = 2153775114,
    NS_ERROR_XSLT_WRONG_MIME_TYPE = 2153775115,
    NS_ERROR_XSLT_LOAD_RECURSION = 2153775116,
    NS_ERROR_XPATH_BAD_ARGUMENT_COUNT = 2153775117,
    NS_ERROR_XPATH_BAD_EXTENSION_FUNCTION = 2153775118,
    NS_ERROR_XPATH_PAREN_EXPECTED = 2153775119,
    NS_ERROR_XPATH_INVALID_AXIS = 2153775120,
    NS_ERROR_XPATH_NO_NODE_TYPE_TEST = 2153775121,
    NS_ERROR_XPATH_BRACKET_EXPECTED = 2153775122,
    NS_ERROR_XPATH_INVALID_VAR_NAME = 2153775123,
    NS_ERROR_XPATH_UNEXPECTED_END = 2153775124,
    NS_ERROR_XPATH_OPERATOR_EXPECTED = 2153775125,
    NS_ERROR_XPATH_UNCLOSED_LITERAL = 2153775126,
    NS_ERROR_XPATH_BAD_COLON = 2153775127,
    NS_ERROR_XPATH_BAD_BANG = 2153775128,
    NS_ERROR_XPATH_ILLEGAL_CHAR = 2153775129,
    NS_ERROR_XPATH_BINARY_EXPECTED = 2153775130,
    NS_ERROR_XSLT_LOAD_BLOCKED_ERROR = 2153775131,
    NS_ERROR_XPATH_INVALID_EXPRESSION_EVALUATED = 2153775132,
    NS_ERROR_XPATH_UNBALANCED_CURLY_BRACE = 2153775133,
    NS_ERROR_XSLT_BAD_NODE_NAME = 2153775134,
    NS_ERROR_XSLT_VAR_ALREADY_SET = 2153775135,
    NS_ERROR_XSLT_CALL_TO_KEY_NOT_ALLOWED = 2153775136,
    NS_XSLT_GET_NEW_HANDLER = 6291457,
    NS_ERROR_TRANSPORT_INIT = 2153840641,
    NS_ERROR_DUPLICATE_HANDLE = 2153840642,
    NS_ERROR_BRIDGE_OPEN_PARENT = 2153840643,
    NS_ERROR_BRIDGE_OPEN_CHILD = 2153840644,
    NS_ERROR_DOM_SVG_WRONG_TYPE_ERR = 2153906176,
    NS_ERROR_DOM_SVG_MATRIX_NOT_INVERTABLE = 2153906178,
    NS_ERROR_STORAGE_BUSY = 2153971713,
    NS_ERROR_STORAGE_IOERR = 2153971714,
    NS_ERROR_STORAGE_CONSTRAINT = 2153971715,
    NS_ERROR_DOM_FILE_NOT_FOUND_ERR = 2154102784,
    NS_ERROR_DOM_FILE_NOT_READABLE_ERR = 2154102785,
    NS_ERROR_DOM_FILE_ABORT_ERR = 2154102786,
    NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR = 2154168321,
    NS_ERROR_DOM_INDEXEDDB_NOT_FOUND_ERR = 2154168323,
    NS_ERROR_DOM_INDEXEDDB_CONSTRAINT_ERR = 2154168324,
    NS_ERROR_DOM_INDEXEDDB_DATA_ERR = 2154168325,
    NS_ERROR_DOM_INDEXEDDB_NOT_ALLOWED_ERR = 2154168326,
    NS_ERROR_DOM_INDEXEDDB_TRANSACTION_INACTIVE_ERR = 2154168327,
    NS_ERROR_DOM_INDEXEDDB_ABORT_ERR = 2154168328,
    NS_ERROR_DOM_INDEXEDDB_READ_ONLY_ERR = 2154168329,
    NS_ERROR_DOM_INDEXEDDB_TIMEOUT_ERR = 2154168330,
    NS_ERROR_DOM_INDEXEDDB_QUOTA_ERR = 2154168331,
    NS_ERROR_DOM_INDEXEDDB_VERSION_ERR = 2154168332,
    NS_ERROR_DOM_INDEXEDDB_RECOVERABLE_ERR = 2154169321,
    NS_ERROR_DOM_FILEHANDLE_UNKNOWN_ERR = 2154233857,
    NS_ERROR_DOM_FILEHANDLE_NOT_ALLOWED_ERR = 2154233858,
    NS_ERROR_DOM_FILEHANDLE_INACTIVE_ERR = 2154233859,
    NS_ERROR_DOM_FILEHANDLE_ABORT_ERR = 2154233860,
    NS_ERROR_DOM_FILEHANDLE_READ_ONLY_ERR = 2154233861,
    NS_ERROR_DOM_FILEHANDLE_QUOTA_ERR = 2154233862,
    NS_ERROR_SIGNED_JAR_NOT_SIGNED = 2154299393,
    NS_ERROR_SIGNED_JAR_MODIFIED_ENTRY = 2154299394,
    NS_ERROR_SIGNED_JAR_UNSIGNED_ENTRY = 2154299395,
    NS_ERROR_SIGNED_JAR_ENTRY_MISSING = 2154299396,
    NS_ERROR_SIGNED_JAR_WRONG_SIGNATURE = 2154299397,
    NS_ERROR_SIGNED_JAR_ENTRY_TOO_LARGE = 2154299398,
    NS_ERROR_SIGNED_JAR_ENTRY_INVALID = 2154299399,
    NS_ERROR_SIGNED_JAR_MANIFEST_INVALID = 2154299400,
    NS_ERROR_DOM_FILESYSTEM_INVALID_PATH_ERR = 2154364929,
    NS_ERROR_DOM_FILESYSTEM_INVALID_MODIFICATION_ERR = 2154364930,
    NS_ERROR_DOM_FILESYSTEM_NO_MODIFICATION_ALLOWED_ERR = 2154364931,
    NS_ERROR_DOM_FILESYSTEM_PATH_EXISTS_ERR = 2154364932,
    NS_ERROR_DOM_FILESYSTEM_TYPE_MISMATCH_ERR = 2154364933,
    NS_ERROR_DOM_FILESYSTEM_UNKNOWN_ERR = 2154364934,
    NS_ERROR_DOM_BLUETOOTH_FAIL = 2154430465,
    NS_ERROR_DOM_BLUETOOTH_NOT_READY = 2154430466,
    NS_ERROR_DOM_BLUETOOTH_NOMEM = 2154430467,
    NS_ERROR_DOM_BLUETOOTH_BUSY = 2154430468,
    NS_ERROR_DOM_BLUETOOTH_DONE = 2154430469,
    NS_ERROR_DOM_BLUETOOTH_UNSUPPORTED = 2154430470,
    NS_ERROR_DOM_BLUETOOTH_PARM_INVALID = 2154430471,
    NS_ERROR_DOM_BLUETOOTH_UNHANDLED = 2154430472,
    NS_ERROR_DOM_BLUETOOTH_AUTH_FAILURE = 2154430473,
    NS_ERROR_DOM_BLUETOOTH_RMT_DEV_DOWN = 2154430474,
    NS_ERROR_DOM_BLUETOOTH_AUTH_REJECTED = 2154430475,
    NS_ERROR_SIGNED_APP_MANIFEST_INVALID = 2154496001,
    NS_ERROR_DOM_ANIM_MISSING_PROPS_ERR = 2154561537,
    NS_ERROR_DOM_PUSH_INVALID_REGISTRATION_ERR = 2154627073,
    NS_ERROR_DOM_PUSH_DENIED_ERR = 2154627074,
    NS_ERROR_DOM_PUSH_ABORT_ERR = 2154627075,
    NS_ERROR_DOM_PUSH_SERVICE_UNREACHABLE = 2154627076,
    NS_ERROR_DOM_PUSH_INVALID_KEY_ERR = 2154627077,
    NS_ERROR_DOM_PUSH_MISMATCHED_KEY_ERR = 2154627078,
    NS_ERROR_DOM_MEDIA_ABORT_ERR = 2154692609,
    NS_ERROR_DOM_MEDIA_NOT_ALLOWED_ERR = 2154692610,
    NS_ERROR_DOM_MEDIA_NOT_SUPPORTED_ERR = 2154692611,
    NS_ERROR_DOM_MEDIA_DECODE_ERR = 2154692612,
    NS_ERROR_DOM_MEDIA_FATAL_ERR = 2154692613,
    NS_ERROR_DOM_MEDIA_METADATA_ERR = 2154692614,
    NS_ERROR_DOM_MEDIA_OVERFLOW_ERR = 2154692615,
    NS_ERROR_DOM_MEDIA_END_OF_STREAM = 2154692616,
    NS_ERROR_DOM_MEDIA_WAITING_FOR_DATA = 2154692617,
    NS_ERROR_DOM_MEDIA_CANCELED = 2154692618,
    NS_ERROR_DOM_MEDIA_MEDIASINK_ERR = 2154692619,
    NS_ERROR_DOM_MEDIA_DEMUXER_ERR = 2154692620,
    NS_ERROR_DOM_MEDIA_CDM_ERR = 2154692621,
    NS_ERROR_DOM_MEDIA_CUBEB_INITIALIZATION_ERR = 2154692709,
    NS_ERROR_DOWNLOAD_COMPLETE = 2155347969,
    NS_ERROR_DOWNLOAD_NOT_PARTIAL = 2155347970,
    NS_ERROR_UNORM_MOREOUTPUT = 2155348001,
    NS_ERROR_DOCSHELL_REQUEST_REJECTED = 2155348969,
    NS_ERROR_DOCUMENT_IS_PRINTMODE = 2155349969,
    NS_SUCCESS_DONT_FIXUP = 7864321,
    NS_SUCCESS_RESTART_APP_NOT_SAME_PROFILE = 7864323,
    NS_SUCCESS_UNORM_NOTFOUND = 7864337,
    NS_ERROR_NOT_IN_TREE = 2155348006,
    NS_OK_NO_NAME_CLAUSE_HANDLED = 7864354,
}
pub type nsrefcnt = MozRefCountType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlignedStorage2<T> {
    pub u: AlignedStorage2_U<T>,
    pub _phantom_0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlignedStorage2_U<T> {
    pub mBytes: __BindgenUnionField<*mut ::std::os::raw::c_char>,
    pub mDummy: __BindgenUnionField<u64>,
    pub bindgen_union_field: u64,
    pub _phantom_0: ::std::marker::PhantomData<T>,
}
/**
 * Pair is the logical concatenation of an instance of A with an instance B.
 * Space is conserved when possible.  Neither A nor B may be a final class.
 *
 * It's typically clearer to have individual A and B member fields.  Except if
 * you want the space-conserving qualities of Pair, you're probably better off
 * not using this!
 *
 * No guarantees are provided about the memory layout of A and B, the order of
 * initialization or destruction of A and B, and so on.  (This is approximately
 * required to optimize space usage.)  The first/second names are merely
 * conceptual!
 */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pair<A, B> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<A>,
    pub _phantom_1: ::std::marker::PhantomData<B>,
}
pub type Pair_Base = [u8; 0usize];
/**
 * A default deletion policy using plain old operator delete.
 *
 * Note that this type can be specialized, but authors should beware of the risk
 * that the specialization may at some point cease to match (either because it
 * gets moved to a different compilation unit or the signature changes). If the
 * non-specialized (|delete|-based) version compiles for that type but does the
 * wrong thing, bad things could happen.
 *
 * This is a non-issue for types which are always incomplete (i.e. opaque handle
 * types), since |delete|-ing such a type will always trigger a compilation
 * error.
 */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DefaultDelete<T> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSContext {
    pub _address: u8,
}
impl Clone for JSContext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSObject {
    pub _address: u8,
}
impl Clone for JSObject {
    fn clone(&self) -> Self { *self }
}
/**
 * JS::Value is the interface for a single JavaScript Engine value.  A few
 * general notes on JS::Value:
 *
 * - JS::Value has setX() and isX() members for X in
 *
 *     { Int32, Double, String, Symbol, Boolean, Undefined, Null, Object, Magic }
 *
 *   JS::Value also contains toX() for each of the non-singleton types.
 *
 * - Magic is a singleton type whose payload contains either a JSWhyMagic "reason" for
 *   the magic value or a uint32_t value. By providing JSWhyMagic values when
 *   creating and checking for magic values, it is possible to assert, at
 *   runtime, that only magic values with the expected reason flow through a
 *   particular value. For example, if cx->exception has a magic value, the
 *   reason must be JS_GENERATOR_CLOSING.
 *
 * - The JS::Value operations are preferred.  The JSVAL_* operations remain for
 *   compatibility; they may be removed at some point.  These operations mostly
 *   provide similar functionality.  But there are a few key differences.  One
 *   is that JS::Value gives null a separate type.
 *   Also, to help prevent mistakenly boxing a nullable JSObject* as an object,
 *   Value::setObject takes a JSObject&. (Conversely, Value::toObject returns a
 *   JSObject&.)  A convenience member Value::setObjectOrNull is provided.
 *
 * - JSVAL_VOID is the same as the singleton value of the Undefined type.
 *
 * - Note that JS::Value is 8 bytes on 32 and 64-bit architectures. Thus, on
 *   32-bit user code should avoid copying jsval/JS::Value as much as possible,
 *   preferring to pass by const Value&.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Value {
    pub data: jsval_layout,
}
#[test]
fn bindgen_test_layout_Value() {
    assert_eq!(::std::mem::size_of::<Value>() , 8usize);
    assert_eq!(::std::mem::align_of::<Value>() , 8usize);
}
impl Clone for Value {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSCompartment {
    pub _address: u8,
}
impl Clone for JSCompartment {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atomic<_Tp> {
    pub _base: (),
    pub _phantom_0: ::std::marker::PhantomData<_Tp>,
}
pub type atomic___base = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FreePolicy {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_FreePolicy() {
    assert_eq!(::std::mem::size_of::<FreePolicy>() , 1usize);
    assert_eq!(::std::mem::align_of::<FreePolicy>() , 1usize);
}
impl Clone for FreePolicy {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum JSValueTag {
    JSVAL_TAG_MAX_DOUBLE = 131056,
    JSVAL_TAG_INT32 = 131057,
    JSVAL_TAG_UNDEFINED = 131058,
    JSVAL_TAG_STRING = 131061,
    JSVAL_TAG_SYMBOL = 131062,
    JSVAL_TAG_BOOLEAN = 131059,
    JSVAL_TAG_MAGIC = 131060,
    JSVAL_TAG_NULL = 131064,
    JSVAL_TAG_OBJECT = 131068,
    JSVAL_TAG_PRIVATE_GCTHING = 131063,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum JSWhyMagic {
    JS_ELEMENTS_HOLE = 0,
    JS_NO_ITER_VALUE = 1,
    JS_GENERATOR_CLOSING = 2,
    JS_NO_CONSTANT = 3,
    JS_THIS_POISON = 4,
    JS_ARG_POISON = 5,
    JS_SERIALIZE_NO_NODE = 6,
    JS_LAZY_ARGUMENTS = 7,
    JS_OPTIMIZED_ARGUMENTS = 8,
    JS_IS_CONSTRUCTING = 9,
    JS_BLOCK_NEEDS_CLONE = 10,
    JS_HASH_KEY_EMPTY = 11,
    JS_ION_ERROR = 12,
    JS_ION_BAILOUT = 13,
    JS_OPTIMIZED_OUT = 14,
    JS_UNINITIALIZED_LEXICAL = 15,
    JS_GENERIC_MAGIC = 16,
    JS_WHY_MAGIC_COUNT = 17,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct jsval_layout {
    pub asBits: __BindgenUnionField<u64>,
    pub debugView: __BindgenUnionField<jsval_layout__bindgen_ty_bindgen_id_61833>,
    pub s: __BindgenUnionField<jsval_layout__bindgen_ty_bindgen_id_61840>,
    pub asDouble: __BindgenUnionField<f64>,
    pub asPtr: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub asWord: __BindgenUnionField<usize>,
    pub asUIntPtr: __BindgenUnionField<usize>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct jsval_layout__bindgen_ty_bindgen_id_61833 {
    pub _bitfield_1: u64,
}
#[test]
fn bindgen_test_layout_jsval_layout__bindgen_ty_bindgen_id_61833() {
    assert_eq!(::std::mem::size_of::<jsval_layout__bindgen_ty_bindgen_id_61833>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<jsval_layout__bindgen_ty_bindgen_id_61833>()
               , 8usize);
}
impl Clone for jsval_layout__bindgen_ty_bindgen_id_61833 {
    fn clone(&self) -> Self { *self }
}
impl jsval_layout__bindgen_ty_bindgen_id_61833 {
    #[inline]
    pub fn payload47(&self) -> u64 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (140737488355327usize as u64)) >>
                                       0u32) as u64)
        }
    }
    #[inline]
    pub fn set_payload47(&mut self, val: u64) {
        self._bitfield_1 &= !(140737488355327usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 0u32) & (140737488355327usize as u64);
    }
    #[inline]
    pub fn tag(&self) -> JSValueTag {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (18446603336221196288usize as u64)) >>
                                       47u32) as u32)
        }
    }
    #[inline]
    pub fn set_tag(&mut self, val: JSValueTag) {
        self._bitfield_1 &= !(18446603336221196288usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 47u32) &
                (18446603336221196288usize as u64);
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct jsval_layout__bindgen_ty_bindgen_id_61840 {
    pub payload: jsval_layout__bindgen_ty_bindgen_id_61840__bindgen_ty_bindgen_id_61841,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct jsval_layout__bindgen_ty_bindgen_id_61840__bindgen_ty_bindgen_id_61841 {
    pub i32: __BindgenUnionField<i32>,
    pub u32: __BindgenUnionField<u32>,
    pub why: __BindgenUnionField<JSWhyMagic>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_jsval_layout__bindgen_ty_bindgen_id_61840__bindgen_ty_bindgen_id_61841() {
    assert_eq!(::std::mem::size_of::<jsval_layout__bindgen_ty_bindgen_id_61840__bindgen_ty_bindgen_id_61841>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<jsval_layout__bindgen_ty_bindgen_id_61840__bindgen_ty_bindgen_id_61841>()
               , 4usize);
}
impl Clone for
 jsval_layout__bindgen_ty_bindgen_id_61840__bindgen_ty_bindgen_id_61841 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_jsval_layout__bindgen_ty_bindgen_id_61840() {
    assert_eq!(::std::mem::size_of::<jsval_layout__bindgen_ty_bindgen_id_61840>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<jsval_layout__bindgen_ty_bindgen_id_61840>()
               , 4usize);
}
impl Clone for jsval_layout__bindgen_ty_bindgen_id_61840 {
    fn clone(&self) -> Self { *self }
}
impl Clone for jsval_layout {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct nsAString_internal {
    pub mData: *mut nsAString_internal_char_type,
    pub mLength: nsAString_internal_size_type,
    pub mFlags: u32,
}
pub type nsAString_internal_fallible_t = fallible_t;
pub type nsAString_internal_char_type = u16;
pub type nsAString_internal_char_traits = u8;
pub type nsAString_internal_incompatible_char_type = u8;
pub type nsAString_internal_self_type = nsAString_internal;
pub type nsAString_internal_abstract_string_type =
    nsAString_internal_self_type;
pub type nsAString_internal_base_string_type = nsAString_internal_self_type;
pub type nsAString_internal_substring_type = nsAString_internal_self_type;
pub type nsAString_internal_substring_tuple_type = nsSubstringTuple;
pub type nsAString_internal_string_type = nsString;
pub type nsAString_internal_const_iterator = nsReadingIterator<u16>;
pub type nsAString_internal_iterator = nsWritingIterator<u16>;
pub type nsAString_internal_comparator_type = nsStringComparator;
pub type nsAString_internal_char_iterator = *mut nsAString_internal_char_type;
pub type nsAString_internal_const_char_iterator =
    *const nsAString_internal_char_type;
pub type nsAString_internal_size_type = u32;
pub type nsAString_internal_index_type = u32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsAString_internal__bindgen_ty_bindgen_id_63710 {
    F_NONE = 0,
    F_TERMINATED = 1,
    F_VOIDED = 2,
    F_SHARED = 4,
    F_OWNED = 8,
    F_FIXED = 16,
    F_LITERAL = 32,
    F_CLASS_FIXED = 65536,
}
#[test]
fn bindgen_test_layout_nsAString_internal() {
    assert_eq!(::std::mem::size_of::<nsAString_internal>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsAString_internal>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsSubstringTuple {
    pub mHead: *const nsSubstringTuple_self_type,
    pub mFragA: *const nsSubstringTuple_base_string_type,
    pub mFragB: *const nsSubstringTuple_base_string_type,
}
pub type nsSubstringTuple_char_type = u16;
pub type nsSubstringTuple_char_traits = nsCharTraits<u16>;
pub type nsSubstringTuple_self_type = nsSubstringTuple;
pub type nsSubstringTuple_substring_type = nsAString_internal;
pub type nsSubstringTuple_base_string_type = nsAString_internal;
pub type nsSubstringTuple_size_type = u32;
#[test]
fn bindgen_test_layout_nsSubstringTuple() {
    assert_eq!(::std::mem::size_of::<nsSubstringTuple>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsSubstringTuple>() , 8usize);
}
impl Clone for nsSubstringTuple {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct nsString {
    pub _base: nsAString_internal,
}
pub type nsString_self_type = nsString;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsString_Segment {
    pub mBegin: u32,
    pub mLength: u32,
}
#[test]
fn bindgen_test_layout_nsString_Segment() {
    assert_eq!(::std::mem::size_of::<nsString_Segment>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsString_Segment>() , 4usize);
}
impl Clone for nsString_Segment {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsString() {
    assert_eq!(::std::mem::size_of::<nsString>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsString>() , 8usize);
}
#[repr(C)]
pub struct bindgen_vtable__bindgen_id_64320 {
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStringComparator {
    pub vtable_: *const bindgen_vtable__bindgen_id_64320,
}
pub type nsStringComparator_char_type = u16;
#[test]
fn bindgen_test_layout_nsStringComparator() {
    assert_eq!(::std::mem::size_of::<nsStringComparator>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsStringComparator>() , 8usize);
}
impl Clone for nsStringComparator {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct nsACString_internal {
    pub mData: *mut nsACString_internal_char_type,
    pub mLength: nsACString_internal_size_type,
    pub mFlags: u32,
}
pub type nsACString_internal_fallible_t = fallible_t;
pub type nsACString_internal_char_type = ::std::os::raw::c_char;
pub type nsACString_internal_char_traits = u8;
pub type nsACString_internal_incompatible_char_type = u16;
pub type nsACString_internal_self_type = nsACString_internal;
pub type nsACString_internal_abstract_string_type =
    nsACString_internal_self_type;
pub type nsACString_internal_base_string_type = nsACString_internal_self_type;
pub type nsACString_internal_substring_type = nsACString_internal_self_type;
pub type nsACString_internal_substring_tuple_type = nsCSubstringTuple;
pub type nsACString_internal_string_type = nsCString;
pub type nsACString_internal_const_iterator =
    nsReadingIterator<::std::os::raw::c_char>;
pub type nsACString_internal_iterator =
    nsWritingIterator<::std::os::raw::c_char>;
pub type nsACString_internal_comparator_type = nsCStringComparator;
pub type nsACString_internal_char_iterator =
    *mut nsACString_internal_char_type;
pub type nsACString_internal_const_char_iterator =
    *const nsACString_internal_char_type;
pub type nsACString_internal_size_type = u32;
pub type nsACString_internal_index_type = u32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsACString_internal__bindgen_ty_bindgen_id_65550 {
    F_NONE = 0,
    F_TERMINATED = 1,
    F_VOIDED = 2,
    F_SHARED = 4,
    F_OWNED = 8,
    F_FIXED = 16,
    F_LITERAL = 32,
    F_CLASS_FIXED = 65536,
}
#[test]
fn bindgen_test_layout_nsACString_internal() {
    assert_eq!(::std::mem::size_of::<nsACString_internal>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsACString_internal>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsCSubstringTuple {
    pub mHead: *const nsCSubstringTuple_self_type,
    pub mFragA: *const nsCSubstringTuple_base_string_type,
    pub mFragB: *const nsCSubstringTuple_base_string_type,
}
pub type nsCSubstringTuple_char_type = ::std::os::raw::c_char;
pub type nsCSubstringTuple_char_traits = nsCharTraits<::std::os::raw::c_char>;
pub type nsCSubstringTuple_self_type = nsCSubstringTuple;
pub type nsCSubstringTuple_substring_type = nsACString_internal;
pub type nsCSubstringTuple_base_string_type = nsACString_internal;
pub type nsCSubstringTuple_size_type = u32;
#[test]
fn bindgen_test_layout_nsCSubstringTuple() {
    assert_eq!(::std::mem::size_of::<nsCSubstringTuple>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsCSubstringTuple>() , 8usize);
}
impl Clone for nsCSubstringTuple {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCString {
    pub _base: nsACString_internal,
}
pub type nsCString_self_type = nsCString;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsCString_Segment {
    pub mBegin: u32,
    pub mLength: u32,
}
#[test]
fn bindgen_test_layout_nsCString_Segment() {
    assert_eq!(::std::mem::size_of::<nsCString_Segment>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsCString_Segment>() , 4usize);
}
impl Clone for nsCString_Segment {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsCString() {
    assert_eq!(::std::mem::size_of::<nsCString>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsCString>() , 8usize);
}
#[repr(C)]
pub struct bindgen_vtable__bindgen_id_66102 {
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsCStringComparator {
    pub vtable_: *const bindgen_vtable__bindgen_id_66102,
}
pub type nsCStringComparator_char_type = ::std::os::raw::c_char;
#[test]
fn bindgen_test_layout_nsCStringComparator() {
    assert_eq!(::std::mem::size_of::<nsCStringComparator>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsCStringComparator>() , 8usize);
}
impl Clone for nsCStringComparator {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct bindgen_vtable__bindgen_id_66146 {
}
/**
 * Basic component object model interface. Objects which implement
 * this interface support runtime interface discovery (QueryInterface)
 * and a reference counted memory model (AddRef/Release). This is
 * modelled after the win32 IUnknown API.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsISupports {
    pub vtable_: *const bindgen_vtable__bindgen_id_66146,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsISupports_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsISupports() {
    assert_eq!(::std::mem::size_of::<nsISupports>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsISupports>() , 8usize);
}
impl Clone for nsISupports {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct bindgen_vtable__bindgen_id_66429 {
}
/**
 * Participant implementation classes
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsCycleCollectionParticipant {
    pub vtable_: *const bindgen_vtable__bindgen_id_66429,
    pub mMightSkip: bool,
}
#[test]
fn bindgen_test_layout_nsCycleCollectionParticipant() {
    assert_eq!(::std::mem::size_of::<nsCycleCollectionParticipant>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<nsCycleCollectionParticipant>() ,
               8usize);
}
impl Clone for nsCycleCollectionParticipant {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsCycleCollectingAutoRefCnt {
    pub mRefCntAndFlags: usize,
}
#[test]
fn bindgen_test_layout_nsCycleCollectingAutoRefCnt() {
    assert_eq!(::std::mem::size_of::<nsCycleCollectingAutoRefCnt>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsCycleCollectingAutoRefCnt>() ,
               8usize);
}
impl Clone for nsCycleCollectingAutoRefCnt {
    fn clone(&self) -> Self { *self }
}
pub type PRUint32 = ::std::os::raw::c_uint;
pub type PRUintn = ::std::os::raw::c_uint;
/************************************************************************
** TYPES:       PRSize
** DESCRIPTION:
**  A type for representing the size of objects.
************************************************************************/
pub type PRSize = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsCharTraits<CharT> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<CharT>,
}
/**
 * @see nsTAString
 */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsReadingIterator<CharT> {
    pub mStart: *mut CharT,
    pub mEnd: *mut CharT,
    pub mPosition: *mut CharT,
}
pub type nsReadingIterator_self_type<CharT> = nsReadingIterator<CharT>;
pub type nsReadingIterator_difference_type = isize;
pub type nsReadingIterator_size_type = usize;
pub type nsReadingIterator_value_type<CharT> = CharT;
pub type nsReadingIterator_pointer<CharT> = *mut CharT;
pub type nsReadingIterator_reference = [u8; 0usize];
/**
 * @see nsTAString
 */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsWritingIterator<CharT> {
    pub mStart: *mut CharT,
    pub mEnd: *mut CharT,
    pub mPosition: *mut CharT,
}
pub type nsWritingIterator_self_type<CharT> = nsWritingIterator<CharT>;
pub type nsWritingIterator_difference_type = isize;
pub type nsWritingIterator_size_type = usize;
pub type nsWritingIterator_value_type<CharT> = CharT;
pub type nsWritingIterator_pointer<CharT> = *mut CharT;
pub type nsWritingIterator_reference = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PLHashEntry {
    pub next: *mut PLHashEntry,
    pub keyHash: PLHashNumber,
    pub key: *const ::std::os::raw::c_void,
    pub value: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_PLHashEntry() {
    assert_eq!(::std::mem::size_of::<PLHashEntry>() , 32usize);
    assert_eq!(::std::mem::align_of::<PLHashEntry>() , 8usize);
}
impl Clone for PLHashEntry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PLHashTable {
    pub buckets: *mut *mut PLHashEntry,
    pub nentries: PRUint32,
    pub shift: PRUint32,
    pub keyHash: PLHashFunction,
    pub keyCompare: PLHashComparator,
    pub valueCompare: PLHashComparator,
    pub allocOps: *const PLHashAllocOps,
    pub allocPriv: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_PLHashTable() {
    assert_eq!(::std::mem::size_of::<PLHashTable>() , 56usize);
    assert_eq!(::std::mem::align_of::<PLHashTable>() , 8usize);
}
impl Clone for PLHashTable {
    fn clone(&self) -> Self { *self }
}
pub type PLHashNumber = PRUint32;
pub type PLHashFunction =
    ::std::option::Option<unsafe extern "C" fn(key:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_uint>;
pub type PLHashComparator =
    ::std::option::Option<unsafe extern "C" fn(v1:
                                                   *const ::std::os::raw::c_void,
                                               v2:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PLHashAllocOps {
    pub allocTable: ::std::option::Option<unsafe extern "C" fn(pool:
                                                                   *mut ::std::os::raw::c_void,
                                                               size: PRSize)
                                              -> *mut ::std::os::raw::c_void>,
    pub freeTable: ::std::option::Option<unsafe extern "C" fn(pool:
                                                                  *mut ::std::os::raw::c_void,
                                                              item:
                                                                  *mut ::std::os::raw::c_void)>,
    pub allocEntry: ::std::option::Option<unsafe extern "C" fn(pool:
                                                                   *mut ::std::os::raw::c_void,
                                                               key:
                                                                   *const ::std::os::raw::c_void)
                                              -> *mut PLHashEntry>,
    pub freeEntry: ::std::option::Option<unsafe extern "C" fn(pool:
                                                                  *mut ::std::os::raw::c_void,
                                                              he:
                                                                  *mut PLHashEntry,
                                                              flag: PRUintn)>,
}
#[test]
fn bindgen_test_layout_PLHashAllocOps() {
    assert_eq!(::std::mem::size_of::<PLHashAllocOps>() , 32usize);
    assert_eq!(::std::mem::align_of::<PLHashAllocOps>() , 8usize);
}
impl Clone for PLHashAllocOps {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct OwningNonNull<T> {
    pub mPtr: RefPtr<T>,
    pub mInited: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StaticRefPtr<T> {
    pub mRawPtr: *mut T,
}
#[repr(C)]
#[derive(Debug)]
pub struct RefPtr<T> {
    pub mRawPtr: *mut T,
}
pub type RefPtr_element_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RefPtr_Proxy<T, R, Args> {
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<R>,
    pub _phantom_2: ::std::marker::PhantomData<Args>,
}
pub type RefPtr_Proxy_member_function = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RefPtr_ConstRemovingRefPtrTraits<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsAutoOwningThread {
    pub mThread: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_nsAutoOwningThread() {
    assert_eq!(::std::mem::size_of::<nsAutoOwningThread>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsAutoOwningThread>() , 8usize);
}
impl Clone for nsAutoOwningThread {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsAutoRefCnt {
    pub mValue: nsrefcnt,
}
extern "C" {
    #[link_name = "_ZN12nsAutoRefCnt12isThreadSafeE"]
    pub static nsAutoRefCnt_isThreadSafe: bool;
}
#[test]
fn bindgen_test_layout_nsAutoRefCnt() {
    assert_eq!(::std::mem::size_of::<nsAutoRefCnt>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsAutoRefCnt>() , 8usize);
}
impl Clone for nsAutoRefCnt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ThreadSafeAutoRefCnt {
    pub mValue: u64,
}
extern "C" {
    #[link_name = "_ZN7mozilla20ThreadSafeAutoRefCnt12isThreadSafeE"]
    pub static ThreadSafeAutoRefCnt_isThreadSafe: bool;
}
#[test]
fn bindgen_test_layout_ThreadSafeAutoRefCnt() {
    assert_eq!(::std::mem::size_of::<ThreadSafeAutoRefCnt>() , 8usize);
    assert_eq!(::std::mem::align_of::<ThreadSafeAutoRefCnt>() , 8usize);
}
impl Clone for ThreadSafeAutoRefCnt {
    fn clone(&self) -> Self { *self }
}
pub type nscoord = i32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsTArrayHeader {
    pub mLength: u32,
    pub _bitfield_1: u32,
}
extern "C" {
    #[link_name = "_ZN14nsTArrayHeader9sEmptyHdrE"]
    pub static mut nsTArrayHeader_sEmptyHdr: nsTArrayHeader;
}
#[test]
fn bindgen_test_layout_nsTArrayHeader() {
    assert_eq!(::std::mem::size_of::<nsTArrayHeader>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsTArrayHeader>() , 4usize);
}
impl Clone for nsTArrayHeader {
    fn clone(&self) -> Self { *self }
}
impl nsTArrayHeader {
    #[inline]
    pub fn mCapacity(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (2147483647usize as u32)) >> 0u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_mCapacity(&mut self, val: u32) {
        self._bitfield_1 &= !(2147483647usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 0u32) & (2147483647usize as u32);
    }
    #[inline]
    pub fn mIsAutoArray(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (2147483648usize as u32)) >> 31u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_mIsAutoArray(&mut self, val: u32) {
        self._bitfield_1 &= !(2147483648usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 31u32) & (2147483648usize as u32);
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCOMPtr<T> {
    pub mRawPtr: *mut T,
}
pub type nsCOMPtr_element_type<T> = T;
#[repr(C)]
#[derive(Debug)]
pub struct ErrorResult {
    pub _base: TErrorResult<AssertAndSuppressCleanupPolicy>,
}
pub type ErrorResult_BaseErrorResult =
    TErrorResult<AssertAndSuppressCleanupPolicy>;
#[test]
fn bindgen_test_layout_ErrorResult() {
    assert_eq!(::std::mem::size_of::<ErrorResult>() , 32usize);
    assert_eq!(::std::mem::align_of::<ErrorResult>() , 8usize);
}
/**
 * Templated implementation class for various ErrorResult-like things.  The
 * instantiations differ only in terms of their cleanup policies (used in the
 * destructor), which they can specify via the template argument.  Note that
 * this means it's safe to reinterpret_cast between the instantiations unless
 * you plan to invoke the destructor through such a cast pointer.
 *
 * A cleanup policy consists of two booleans: whether to assert that we've been
 * reported or suppressed, and whether to then go ahead and suppress the
 * exception.
 */
#[repr(C)]
#[derive(Debug)]
pub struct TErrorResult<CleanupPolicy> {
    pub mResult: nsresult,
    pub __bindgen_anon_1: TErrorResult__bindgen_ty_bindgen_id_73928<CleanupPolicy>,
    pub mMightHaveUnreportedJSException: bool,
    pub mUnionState: TErrorResult_UnionState,
    pub _mOwningThread: nsAutoOwningThread,
    pub _phantom_0: ::std::marker::PhantomData<CleanupPolicy>,
}
pub const TErrorResult_UnionState_HasDOMExceptionInfo: TErrorResult_UnionState
          =
    TErrorResult_UnionState::HasMessage;
pub const TErrorResult_UnionState_HasJSException: TErrorResult_UnionState =
    TErrorResult_UnionState::HasMessage;
pub const TErrorResult_UnionState_HasNothing: TErrorResult_UnionState =
    TErrorResult_UnionState::HasMessage;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum TErrorResult_UnionState { HasMessage = 0, }
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TErrorResult_Message<CleanupPolicy> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<CleanupPolicy>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TErrorResult_DOMExceptionInfo<CleanupPolicy> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<CleanupPolicy>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TErrorResult__bindgen_ty_bindgen_id_73928<CleanupPolicy> {
    pub mMessage: __BindgenUnionField<*mut TErrorResult_Message<CleanupPolicy>>,
    pub mJSException: __BindgenUnionField<Value>,
    pub mDOMExceptionInfo: __BindgenUnionField<*mut TErrorResult_DOMExceptionInfo<CleanupPolicy>>,
    pub bindgen_union_field: u64,
    pub _phantom_0: ::std::marker::PhantomData<CleanupPolicy>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AssertAndSuppressCleanupPolicy {
    pub _address: u8,
}
extern "C" {
    #[link_name =
          "_ZN7mozilla14binding_danger30AssertAndSuppressCleanupPolicy13assertHandledE"]
    pub static AssertAndSuppressCleanupPolicy_assertHandled: bool;
}
extern "C" {
    #[link_name =
          "_ZN7mozilla14binding_danger30AssertAndSuppressCleanupPolicy8suppressE"]
    pub static AssertAndSuppressCleanupPolicy_suppress: bool;
}
#[test]
fn bindgen_test_layout_AssertAndSuppressCleanupPolicy() {
    assert_eq!(::std::mem::size_of::<AssertAndSuppressCleanupPolicy>() ,
               1usize);
    assert_eq!(::std::mem::align_of::<AssertAndSuppressCleanupPolicy>() ,
               1usize);
}
impl Clone for AssertAndSuppressCleanupPolicy {
    fn clone(&self) -> Self { *self }
}
/**
 * Factors implementation for all template versions of nsCOMPtr.
 *
 * Here's the way people normally do things like this:
 *
 *   template<class T> class Foo { ... };
 *   template<> class Foo<void*> { ... };
 *   template<class T> class Foo<T*> : private Foo<void*> { ... };
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsCOMPtr_base {
    pub mRawPtr: *mut nsISupports,
}
#[repr(C)]
#[derive(Debug)]
pub struct nsAutoPtr<T> {
    pub mRawPtr: *mut T,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsAutoPtr_Ptr<T> {
    pub mPtr: *mut T,
}
pub type nsAutoPtr_element_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsAutoPtr_Proxy<T, R, Args> {
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<R>,
    pub _phantom_2: ::std::marker::PhantomData<Args>,
}
pub type nsAutoPtr_Proxy_member_function = [u8; 0usize];
/**
 * This structure precedes the string buffers "we" allocate.  It may be the
 * case that nsTAString::mData does not point to one of these special
 * buffers.  The mFlags member variable distinguishes the buffer type.
 *
 * When this header is in use, it enables reference counting, and capacity
 * tracking.  NOTE: A string buffer can be modified only if its reference
 * count is 1.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStringBuffer {
    pub mRefCount: u32,
    pub mStorageSize: u32,
}
#[test]
fn bindgen_test_layout_nsStringBuffer() {
    assert_eq!(::std::mem::size_of::<nsStringBuffer>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsStringBuffer>() , 4usize);
}
impl Clone for nsStringBuffer {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIAtom {
    pub _base: nsISupports,
    pub _bitfield_1: u32,
    pub mHash: u32,
    /**
   * WARNING! There is an invisible constraint on |mString|: the chars it
   * points to must belong to an nsStringBuffer. This is so that the
   * nsStringBuffer::FromData() calls above are valid.
   */
    pub mString: *mut u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsIAtom_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsIAtom() {
    assert_eq!(::std::mem::size_of::<nsIAtom>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsIAtom>() , 8usize);
}
impl Clone for nsIAtom {
    fn clone(&self) -> Self { *self }
}
impl nsIAtom {
    #[inline]
    pub fn mLength(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (2147483647usize as u32)) >> 0u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_mLength(&mut self, val: u32) {
        self._bitfield_1 &= !(2147483647usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 0u32) & (2147483647usize as u32);
    }
    #[inline]
    pub fn mIsStatic(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (2147483648usize as u32)) >> 31u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_mIsStatic(&mut self, val: u32) {
        self._bitfield_1 &= !(2147483648usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 31u32) & (2147483648usize as u32);
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIPrincipal {
    pub _base: nsISerializable,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsIPrincipal_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIPrincipal__bindgen_ty_bindgen_id_75167 {
    APP_STATUS_NOT_INSTALLED = 0,
    APP_STATUS_INSTALLED = 1,
    APP_STATUS_PRIVILEGED = 2,
    APP_STATUS_CERTIFIED = 3,
}
#[test]
fn bindgen_test_layout_nsIPrincipal() {
    assert_eq!(::std::mem::size_of::<nsIPrincipal>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsIPrincipal>() , 8usize);
}
impl Clone for nsIPrincipal {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsISerializable {
    pub _base: nsISupports,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsISerializable_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsISerializable() {
    assert_eq!(::std::mem::size_of::<nsISerializable>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsISerializable>() , 8usize);
}
impl Clone for nsISerializable {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct bindgen_vtable__bindgen_id_75335 {
}
/**
 * Class to store the wrapper for an object. This can only be used with objects
 * that only have one non-security wrapper at a time (for an XPCWrappedNative
 * this is usually ensured by setting an explicit parent in the PreCreate hook
 * for the class).
 *
 * An instance of nsWrapperCache can be gotten from an object that implements
 * a wrapper cache by calling QueryInterface on it. Note that this breaks XPCOM
 * rules a bit (this object doesn't derive from nsISupports).
 *
 * The cache can store objects other than wrappers. We allow wrappers to use a
 * separate JSObject to store their state (mostly expandos). If the wrapper is
 * collected and we want to preserve this state we actually store the state
 * object in the cache.
 *
 * The cache can store 2 types of objects:
 *
 *  If WRAPPER_IS_NOT_DOM_BINDING is set (IsDOMBinding() returns false):
 *    - the JSObject of an XPCWrappedNative wrapper
 *
 *  If WRAPPER_IS_NOT_DOM_BINDING is not set (IsDOMBinding() returns true):
 *    - a DOM binding object (regular JS object or proxy)
 *
 * The finalizer for the wrapper clears the cache.
 *
 * A compacting GC can move the wrapper object. Pointers to moved objects are
 * usually found and updated by tracing the heap, however non-preserved wrappers
 * are weak references and are not traced, so another approach is
 * necessary. Instead a class hook (objectMovedOp) is provided that is called
 * when an object is moved and is responsible for ensuring pointers are
 * updated. It does this by calling UpdateWrapper() on the wrapper
 * cache. SetWrapper() asserts that the hook is implemented for any wrapper set.
 *
 * A number of the methods are implemented in nsWrapperCacheInlines.h because we
 * have to include some JS headers that don't play nicely with the rest of the
 * codebase. Include nsWrapperCacheInlines.h if you need to call those methods.
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsWrapperCache {
    pub vtable_: *const bindgen_vtable__bindgen_id_75335,
    pub mWrapper: *mut JSObject,
    pub mFlags: nsWrapperCache_FlagsType,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsWrapperCache_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
pub type nsWrapperCache_FlagsType = u32;
#[repr(u32)]
/**
   * If this bit is set then we're preserving the wrapper, which in effect ties
   * the lifetime of the JS object stored in the cache to the lifetime of the
   * native object. We rely on the cycle collector to break the cycle that this
   * causes between the native object and the JS object, so it is important that
   * any native object that supports preserving of its wrapper
   * traces/traverses/unlinks the cached JS object (see
   * NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER,
   * NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS and
   * NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER).
   */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsWrapperCache__bindgen_ty_bindgen_id_75542 {
    WRAPPER_BIT_PRESERVED = 1,
}
#[repr(u32)]
/**
   * If this bit is set then the wrapper for the native object is not a DOM
   * binding.
   */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsWrapperCache__bindgen_ty_bindgen_id_75545 {
    WRAPPER_IS_NOT_DOM_BINDING = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsWrapperCache__bindgen_ty_bindgen_id_75548 {
    kWrapperFlagsMask = 3,
}
#[test]
fn bindgen_test_layout_nsWrapperCache() {
    assert_eq!(::std::mem::size_of::<nsWrapperCache>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsWrapperCache>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AllOwningUnionBase {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_AllOwningUnionBase() {
    assert_eq!(::std::mem::size_of::<AllOwningUnionBase>() , 1usize);
    assert_eq!(::std::mem::align_of::<AllOwningUnionBase>() , 1usize);
}
impl Clone for AllOwningUnionBase {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct GlobalObject {
    pub mGlobalJSObject: [u64; 3usize],
    pub mCx: *mut JSContext,
    pub mGlobalObject: *mut nsISupports,
}
#[test]
fn bindgen_test_layout_GlobalObject() {
    assert_eq!(::std::mem::size_of::<GlobalObject>() , 40usize);
    assert_eq!(::std::mem::align_of::<GlobalObject>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsScriptObjectTracer {
    pub _base: nsCycleCollectionParticipant,
}
#[test]
fn bindgen_test_layout_nsScriptObjectTracer() {
    assert_eq!(::std::mem::size_of::<nsScriptObjectTracer>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsScriptObjectTracer>() , 8usize);
}
impl Clone for nsScriptObjectTracer {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsXPCOMCycleCollectionParticipant {
    pub _base: nsScriptObjectTracer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsXPCOMCycleCollectionParticipant_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsXPCOMCycleCollectionParticipant() {
    assert_eq!(::std::mem::size_of::<nsXPCOMCycleCollectionParticipant>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<nsXPCOMCycleCollectionParticipant>() ,
               8usize);
}
impl Clone for nsXPCOMCycleCollectionParticipant {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pair<_T1, _T2> {
    pub first: _T1,
    pub second: _T2,
}
pub type pair_first_type<_T1> = _T1;
pub type pair_second_type<_T2> = _T2;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct input_iterator_tag {
    pub _address: u8,
}
impl Clone for input_iterator_tag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct forward_iterator_tag {
    pub _address: u8,
}
impl Clone for forward_iterator_tag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bidirectional_iterator_tag {
    pub _address: u8,
}
impl Clone for bidirectional_iterator_tag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct random_access_iterator_tag {
    pub _address: u8,
}
impl Clone for random_access_iterator_tag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct bindgen_vtable__bindgen_id_95272 {
}
/**
 * A class of objects that return source code on demand.
 *
 * When code is compiled with setSourceIsLazy(true), SpiderMonkey doesn't
 * retain the source code (and doesn't do lazy bytecode generation). If we ever
 * need the source code, say, in response to a call to Function.prototype.
 * toSource or Debugger.Source.prototype.text, then we call the 'load' member
 * function of the instance of this class that has hopefully been registered
 * with the runtime, passing the code's URL, and hope that it will be able to
 * find the source.
 */
#[repr(C)]
#[derive(Debug)]
pub struct SourceHook {
    pub vtable_: *const bindgen_vtable__bindgen_id_95272,
}
#[test]
fn bindgen_test_layout_SourceHook() {
    assert_eq!(::std::mem::size_of::<SourceHook>() , 8usize);
    assert_eq!(::std::mem::align_of::<SourceHook>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsIGlobalObject {
    pub _base: nsISupports,
    pub mHostObjectURIs: nsTArray<nsCString>,
    pub mIsDying: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsIGlobalObject_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsIGlobalObject() {
    assert_eq!(::std::mem::size_of::<nsIGlobalObject>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsIGlobalObject>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIURI {
    pub _base: nsISupports,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsIURI_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsIURI() {
    assert_eq!(::std::mem::size_of::<nsIURI>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsIURI>() , 8usize);
}
impl Clone for nsIURI {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct nsPIDOMWindowInner {
    pub _base: [u64; 28usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsPIDOMWindowInner_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsPIDOMWindowInner() {
    assert_eq!(::std::mem::size_of::<nsPIDOMWindowInner>() , 224usize);
    assert_eq!(::std::mem::align_of::<nsPIDOMWindowInner>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsIDocument {
    pub _base: nsINode,
    pub mDeprecationWarnedAbout: u64,
    pub mDocWarningWarnedAbout: u64,
    pub mSelectorCache: [u64; 16usize],
    pub mReferrer: nsCString,
    pub mLastModified: nsString,
    pub mDocumentURI: nsCOMPtr<nsIURI>,
    pub mOriginalURI: nsCOMPtr<nsIURI>,
    pub mChromeXHRDocURI: nsCOMPtr<nsIURI>,
    pub mDocumentBaseURI: nsCOMPtr<nsIURI>,
    pub mChromeXHRDocBaseURI: nsCOMPtr<nsIURI>,
    pub mDocumentLoadGroup: nsWeakPtr,
    pub mReferrerPolicySet: bool,
    pub mReferrerPolicy: nsIDocument_ReferrerPolicyEnum,
    pub mBlockAllMixedContent: bool,
    pub mBlockAllMixedContentPreloads: bool,
    pub mUpgradeInsecureRequests: bool,
    pub mUpgradeInsecurePreloads: bool,
    pub mHSTSPrimingURIList: [u64; 6usize],
    pub mDocumentContainer: u64,
    pub mCharacterSet: nsCString,
    pub mCharacterSetSource: i32,
    pub mParentDocument: *mut nsIDocument,
    pub mCachedRootElement: *mut Element,
    pub mNodeInfoManager: *mut nsNodeInfoManager,
    pub mCSSLoader: RefPtr<Loader>,
    pub mStyleImageLoader: RefPtr<ImageLoader>,
    pub mAttrStyleSheet: RefPtr<nsHTMLStyleSheet>,
    pub mStyleAttrStyleSheet: RefPtr<nsHTMLCSSStyleSheet>,
    pub mSVGAttrAnimationRuleProcessor: RefPtr<SVGAttrAnimationRuleProcessor>,
    pub mActivityObservers: nsAutoPtr<()>,
    pub mLinksToUpdate: [u64; 6usize],
    pub mAnimationController: RefPtr<nsSMILAnimationController>,
    pub mPropertyTable: nsPropertyTable,
    pub mExtraPropertyTables: nsTArray<nsAutoPtr<nsPropertyTable>>,
    pub mChildrenCollection: nsCOMPtr<nsIHTMLCollection>,
    pub mFontFaceSet: RefPtr<FontFaceSet>,
    pub mCompatMode: nsCompatibility,
    pub mReadyState: nsIDocument_ReadyState,
    pub mVisibilityState: VisibilityState,
    pub mStyleBackendType: StyleBackendType,
    pub _bitfield_1: u64,
    pub mType: nsIDocument_Type,
    pub mDefaultElementType: u8,
    pub mAllowXULXBL: nsIDocument_Tri,
    /**
   * This is true while FlushPendingLinkUpdates executes.  Calls to
   * [Un]RegisterPendingLinkUpdate will assert when this is true.
   */
    pub mIsLinkUpdateRegistrationsForbidden: bool,
    pub mScriptGlobalObject: nsCOMPtr<nsIScriptGlobalObject>,
    pub mOriginalDocument: nsCOMPtr<nsIDocument>,
    pub mBidiOptions: u32,
    pub mSandboxFlags: u32,
    pub mContentLanguage: nsCString,
    pub mChannel: nsCOMPtr<nsIChannel>,
    pub mContentType: nsCString,
    pub mId: nsString,
    pub mSecurityInfo: nsCOMPtr<nsISupports>,
    pub mFailedChannel: nsCOMPtr<nsIChannel>,
    pub mPartID: u32,
    pub mMarkedCCGeneration: u32,
    pub mPresShell: *mut nsIPresShell,
    pub mSubtreeModifiedTargets: nsCOMArray<nsINode>,
    pub mSubtreeModifiedDepth: u32,
    pub mDisplayDocument: nsCOMPtr<nsIDocument>,
    pub mEventsSuppressed: u32,
    pub mAnimationsPaused: u32,
    /**
   * The number number of external scripts (ones with the src attribute) that
   * have this document as their owner and that are being evaluated right now.
   */
    pub mExternalScriptsBeingEvaluated: u32,
    /**
   * The current frame request callback handle
   */
    pub mFrameRequestCallbackCounter: i32,
    pub mStaticCloneCount: u32,
    pub mBlockedTrackingNodes: nsTArray<nsCOMPtr<nsIWeakReference>>,
    pub mWindow: *mut nsPIDOMWindowInner,
    pub mCachedEncoder: nsCOMPtr<nsIDocumentEncoder>,
    pub mFrameRequestCallbacks: nsTArray<nsIDocument_FrameRequest>,
    pub mBFCacheEntry: *mut nsIBFCacheEntry,
    pub mBaseTarget: nsString,
    pub mStateObjectContainer: nsCOMPtr<nsIStructuredCloneContainer>,
    pub mStateObjectCached: nsCOMPtr<nsIVariant>,
    pub mInSyncOperationCount: u32,
    pub mXPathEvaluator: RefPtr<XPathEvaluator>,
    pub mAnonymousContents: nsTArray<RefPtr<AnonymousContent>>,
    pub mBlockDOMContentLoaded: u32,
    pub _bitfield_2: u8,
    pub mDOMMediaQueryLists: PRCList,
    pub mUseCounters: [u64; 2usize],
    pub mChildDocumentUseCounters: [u64; 2usize],
    pub mNotifiedPageForUseCounter: [u64; 2usize],
    pub mUserHasInteracted: bool,
}
pub type nsIDocument_GlobalObject = GlobalObject;
pub type nsIDocument_ReferrerPolicyEnum = ReferrerPolicy;
pub type nsIDocument_Element = Element;
pub type nsIDocument_FullscreenRequest = FullscreenRequest;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsIDocument_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
/**
   * This gets fired when the element that an id refers to changes.
   * This fires at difficult times. It is generally not safe to do anything
   * which could modify the DOM in any way. Use
   * nsContentUtils::AddScriptRunner.
   * @return true to keep the callback in the callback set, false
   * to remove it.
   */
pub type nsIDocument_IDTargetObserver =
    ::std::option::Option<unsafe extern "C" fn(aOldElement:
                                                   *mut nsIDocument_Element,
                                               aNewelement:
                                                   *mut nsIDocument_Element,
                                               aData:
                                                   *mut ::std::os::raw::c_void)
                              -> bool>;
#[repr(C)]
#[derive(Debug)]
pub struct nsIDocument_SelectorCacheKey {
    pub mKey: nsString,
    pub mState: nsExpirationState,
}
#[test]
fn bindgen_test_layout_nsIDocument_SelectorCacheKey() {
    assert_eq!(::std::mem::size_of::<nsIDocument_SelectorCacheKey>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<nsIDocument_SelectorCacheKey>() ,
               8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIDocument_SelectorCacheKeyDeleter {
    pub _address: u8,
}
impl Clone for nsIDocument_SelectorCacheKeyDeleter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct nsIDocument_SelectorCache {
    pub _bindgen_opaque_blob: [u64; 16usize],
}
#[test]
fn bindgen_test_layout_nsIDocument_SelectorCache() {
    assert_eq!(::std::mem::size_of::<nsIDocument_SelectorCache>() , 128usize);
    assert_eq!(::std::mem::align_of::<nsIDocument_SelectorCache>() , 8usize);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIDocument_additionalSheetType {
    eAgentSheet = 0,
    eUserSheet = 1,
    eAuthorSheet = 2,
    AdditionalSheetTypeCount = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIDocument_ReadyState {
    READYSTATE_UNINITIALIZED = 0,
    READYSTATE_LOADING = 1,
    READYSTATE_INTERACTIVE = 3,
    READYSTATE_COMPLETE = 4,
}
/**
   * Enumerate all subdocuments.
   * The enumerator callback should return true to continue enumerating, or
   * false to stop.  This will never get passed a null aDocument.
   */
pub type nsIDocument_nsSubDocEnumFunc =
    ::std::option::Option<unsafe extern "C" fn(aDocument: *mut nsIDocument,
                                               aData:
                                                   *mut ::std::os::raw::c_void)
                              -> bool>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIDocument_ElementsFromPointFlags {
    IGNORE_ROOT_SCROLL_FRAME = 1,
    FLUSH_LAYOUT = 2,
    IS_ELEMENT_FROM_POINT = 4,
}
/**
   * A class that represents an external resource load that has begun but
   * doesn't have a document yet.  Observers can be registered on this object,
   * and will be notified after the document is created.  Observers registered
   * after the document has been created will NOT be notified.  When observers
   * are notified, the subject will be the newly-created document, the topic
   * will be "external-resource-document-created", and the data will be null.
   * If document creation fails for some reason, observers will still be
   * notified, with a null document pointer.
   */
#[repr(C)]
#[derive(Debug)]
pub struct nsIDocument_ExternalResourceLoad {
    pub _base: nsISupports,
    pub mObservers: [u64; 10usize],
}
#[test]
fn bindgen_test_layout_nsIDocument_ExternalResourceLoad() {
    assert_eq!(::std::mem::size_of::<nsIDocument_ExternalResourceLoad>() ,
               88usize);
    assert_eq!(::std::mem::align_of::<nsIDocument_ExternalResourceLoad>() ,
               8usize);
}
pub type nsIDocument_ActivityObserverEnumerator =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut nsISupports,
                                               arg2:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIDocument_SuppressionType { eAnimationsOnly = 1, eEvents = 3, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIDocument_DocumentTheme {
    Doc_Theme_Uninitialized = 0,
    Doc_Theme_None = 1,
    Doc_Theme_Neutral = 2,
    Doc_Theme_Dark = 3,
    Doc_Theme_Bright = 4,
}
pub type nsIDocument_FrameRequestCallbackList =
    nsTArray<RefPtr<FrameRequestCallback>>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIDocument__bindgen_ty_bindgen_id_108839 { REQUEST_DISCARD = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIDocument_DeprecatedOperations {
    eGetAttributeNode = 0,
    eSetAttributeNode = 1,
    eGetAttributeNodeNS = 2,
    eSetAttributeNodeNS = 3,
    eRemoveAttributeNode = 4,
    eCreateAttribute = 5,
    eCreateAttributeNS = 6,
    eNodeValue = 7,
    eTextContent = 8,
    eEnablePrivilege = 9,
    eDOMExceptionCode = 10,
    eNoExposedProps = 11,
    eMutationEvent = 12,
    eComponents = 13,
    ePrefixedVisibilityAPI = 14,
    eNodeIteratorDetach = 15,
    eLenientThis = 16,
    eGetPreventDefault = 17,
    eGetSetUserData = 18,
    eMozGetAsFile = 19,
    eUseOfCaptureEvents = 20,
    eUseOfReleaseEvents = 21,
    eUseOfDOM3LoadMethod = 22,
    eChromeUseOfDOM3LoadMethod = 23,
    eShowModalDialog = 24,
    eWindow_Content = 25,
    eSyncXMLHttpRequest = 26,
    eDataContainerEvent = 27,
    eWindow_Controllers = 28,
    eImportXULIntoContent = 29,
    ePannerNodeDoppler = 30,
    eNavigatorGetUserMedia = 31,
    eWebrtcDeprecatedPrefix = 32,
    eRTCPeerConnectionGetStreams = 33,
    eAppCache = 34,
    ePrefixedImageSmoothingEnabled = 35,
    ePrefixedFullscreenAPI = 36,
    eLenientSetter = 37,
    eFileLastModifiedDate = 38,
    eDeprecatedOperationCount = 39,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIDocument_DocumentWarnings {
    eIgnoringWillChangeOverBudget = 0,
    ePreventDefaultFromPassiveListener = 1,
    eDocumentWarningCount = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIDocument_ElementCallbackType {
    eCreated = 0,
    eAttached = 1,
    eDetached = 2,
    eAttributeChanged = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIDocument_Type {
    eUnknown = 0,
    eHTML = 1,
    eXHTML = 2,
    eGenericXML = 3,
    eSVG = 4,
    eXUL = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIDocument_Tri { eTriUnset = 0, eTriFalse = 1, eTriTrue = 2, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIDocument_FrameRequest {
    pub _address: u8,
}
impl Clone for nsIDocument_FrameRequest {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsIDocument() {
    assert_eq!(::std::mem::size_of::<nsIDocument>() , 960usize);
    assert_eq!(::std::mem::align_of::<nsIDocument>() , 8usize);
}
impl nsIDocument {
    #[inline]
    pub fn mBidiEnabled(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u64)) >>
                                       0u32) as u8)
        }
    }
    #[inline]
    pub fn set_mBidiEnabled(&mut self, val: bool) {
        self._bitfield_1 &= !(1usize as u64);
        self._bitfield_1 |= ((val as u8 as u64) << 0u32) & (1usize as u64);
    }
    #[inline]
    pub fn mMathMLEnabled(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u64)) >>
                                       1u32) as u8)
        }
    }
    #[inline]
    pub fn set_mMathMLEnabled(&mut self, val: bool) {
        self._bitfield_1 &= !(2usize as u64);
        self._bitfield_1 |= ((val as u8 as u64) << 1u32) & (2usize as u64);
    }
    #[inline]
    pub fn mIsInitialDocumentInWindow(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u64)) >>
                                       2u32) as u8)
        }
    }
    #[inline]
    pub fn set_mIsInitialDocumentInWindow(&mut self, val: bool) {
        self._bitfield_1 &= !(4usize as u64);
        self._bitfield_1 |= ((val as u8 as u64) << 2u32) & (4usize as u64);
    }
    #[inline]
    pub fn mLoadedAsData(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u64)) >>
                                       3u32) as u8)
        }
    }
    #[inline]
    pub fn set_mLoadedAsData(&mut self, val: bool) {
        self._bitfield_1 &= !(8usize as u64);
        self._bitfield_1 |= ((val as u8 as u64) << 3u32) & (8usize as u64);
    }
    #[inline]
    pub fn mLoadedAsInteractiveData(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u64)) >>
                                       4u32) as u8)
        }
    }
    #[inline]
    pub fn set_mLoadedAsInteractiveData(&mut self, val: bool) {
        self._bitfield_1 &= !(16usize as u64);
        self._bitfield_1 |= ((val as u8 as u64) << 4u32) & (16usize as u64);
    }
    #[inline]
    pub fn mMayStartLayout(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u64)) >>
                                       5u32) as u8)
        }
    }
    #[inline]
    pub fn set_mMayStartLayout(&mut self, val: bool) {
        self._bitfield_1 &= !(32usize as u64);
        self._bitfield_1 |= ((val as u8 as u64) << 5u32) & (32usize as u64);
    }
    #[inline]
    pub fn mHaveFiredTitleChange(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u64)) >>
                                       6u32) as u8)
        }
    }
    #[inline]
    pub fn set_mHaveFiredTitleChange(&mut self, val: bool) {
        self._bitfield_1 &= !(64usize as u64);
        self._bitfield_1 |= ((val as u8 as u64) << 6u32) & (64usize as u64);
    }
    #[inline]
    pub fn mIsShowing(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u64)) >>
                                       7u32) as u8)
        }
    }
    #[inline]
    pub fn set_mIsShowing(&mut self, val: bool) {
        self._bitfield_1 &= !(128usize as u64);
        self._bitfield_1 |= ((val as u8 as u64) << 7u32) & (128usize as u64);
    }
    #[inline]
    pub fn mVisible(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (256usize as u64)) >>
                                       8u32) as u8)
        }
    }
    #[inline]
    pub fn set_mVisible(&mut self, val: bool) {
        self._bitfield_1 &= !(256usize as u64);
        self._bitfield_1 |= ((val as u8 as u64) << 8u32) & (256usize as u64);
    }
    #[inline]
    pub fn mRemovedFromDocShell(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (512usize as u64)) >>
                                       9u32) as u8)
        }
    }
    #[inline]
    pub fn set_mRemovedFromDocShell(&mut self, val: bool) {
        self._bitfield_1 &= !(512usize as u64);
        self._bitfield_1 |= ((val as u8 as u64) << 9u32) & (512usize as u64);
    }
    #[inline]
    pub fn mAllowDNSPrefetch(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1024usize as u64)) >>
                                       10u32) as u8)
        }
    }
    #[inline]
    pub fn set_mAllowDNSPrefetch(&mut self, val: bool) {
        self._bitfield_1 &= !(1024usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 10u32) & (1024usize as u64);
    }
    #[inline]
    pub fn mIsStaticDocument(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2048usize as u64)) >>
                                       11u32) as u8)
        }
    }
    #[inline]
    pub fn set_mIsStaticDocument(&mut self, val: bool) {
        self._bitfield_1 &= !(2048usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 11u32) & (2048usize as u64);
    }
    #[inline]
    pub fn mCreatingStaticClone(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4096usize as u64)) >>
                                       12u32) as u8)
        }
    }
    #[inline]
    pub fn set_mCreatingStaticClone(&mut self, val: bool) {
        self._bitfield_1 &= !(4096usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 12u32) & (4096usize as u64);
    }
    #[inline]
    pub fn mInUnlinkOrDeletion(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8192usize as u64)) >>
                                       13u32) as u8)
        }
    }
    #[inline]
    pub fn set_mInUnlinkOrDeletion(&mut self, val: bool) {
        self._bitfield_1 &= !(8192usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 13u32) & (8192usize as u64);
    }
    #[inline]
    pub fn mHasHadScriptHandlingObject(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16384usize as u64)) >>
                                       14u32) as u8)
        }
    }
    #[inline]
    pub fn set_mHasHadScriptHandlingObject(&mut self, val: bool) {
        self._bitfield_1 &= !(16384usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 14u32) & (16384usize as u64);
    }
    #[inline]
    pub fn mIsBeingUsedAsImage(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32768usize as u64)) >>
                                       15u32) as u8)
        }
    }
    #[inline]
    pub fn set_mIsBeingUsedAsImage(&mut self, val: bool) {
        self._bitfield_1 &= !(32768usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 15u32) & (32768usize as u64);
    }
    #[inline]
    pub fn mIsSyntheticDocument(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (65536usize as u64)) >>
                                       16u32) as u8)
        }
    }
    #[inline]
    pub fn set_mIsSyntheticDocument(&mut self, val: bool) {
        self._bitfield_1 &= !(65536usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 16u32) & (65536usize as u64);
    }
    #[inline]
    pub fn mHasLinksToUpdate(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (131072usize as u64))
                                       >> 17u32) as u8)
        }
    }
    #[inline]
    pub fn set_mHasLinksToUpdate(&mut self, val: bool) {
        self._bitfield_1 &= !(131072usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 17u32) & (131072usize as u64);
    }
    #[inline]
    pub fn mNeedLayoutFlush(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (262144usize as u64))
                                       >> 18u32) as u8)
        }
    }
    #[inline]
    pub fn set_mNeedLayoutFlush(&mut self, val: bool) {
        self._bitfield_1 &= !(262144usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 18u32) & (262144usize as u64);
    }
    #[inline]
    pub fn mNeedStyleFlush(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (524288usize as u64))
                                       >> 19u32) as u8)
        }
    }
    #[inline]
    pub fn set_mNeedStyleFlush(&mut self, val: bool) {
        self._bitfield_1 &= !(524288usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 19u32) & (524288usize as u64);
    }
    #[inline]
    pub fn mMayHaveDOMMutationObservers(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1048576usize as u64))
                                       >> 20u32) as u8)
        }
    }
    #[inline]
    pub fn set_mMayHaveDOMMutationObservers(&mut self, val: bool) {
        self._bitfield_1 &= !(1048576usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 20u32) & (1048576usize as u64);
    }
    #[inline]
    pub fn mMayHaveAnimationObservers(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2097152usize as u64))
                                       >> 21u32) as u8)
        }
    }
    #[inline]
    pub fn set_mMayHaveAnimationObservers(&mut self, val: bool) {
        self._bitfield_1 &= !(2097152usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 21u32) & (2097152usize as u64);
    }
    #[inline]
    pub fn mHasMixedActiveContentLoaded(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4194304usize as u64))
                                       >> 22u32) as u8)
        }
    }
    #[inline]
    pub fn set_mHasMixedActiveContentLoaded(&mut self, val: bool) {
        self._bitfield_1 &= !(4194304usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 22u32) & (4194304usize as u64);
    }
    #[inline]
    pub fn mHasMixedActiveContentBlocked(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8388608usize as u64))
                                       >> 23u32) as u8)
        }
    }
    #[inline]
    pub fn set_mHasMixedActiveContentBlocked(&mut self, val: bool) {
        self._bitfield_1 &= !(8388608usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 23u32) & (8388608usize as u64);
    }
    #[inline]
    pub fn mHasMixedDisplayContentLoaded(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16777216usize as u64))
                                       >> 24u32) as u8)
        }
    }
    #[inline]
    pub fn set_mHasMixedDisplayContentLoaded(&mut self, val: bool) {
        self._bitfield_1 &= !(16777216usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 24u32) & (16777216usize as u64);
    }
    #[inline]
    pub fn mHasMixedDisplayContentBlocked(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (33554432usize as u64))
                                       >> 25u32) as u8)
        }
    }
    #[inline]
    pub fn set_mHasMixedDisplayContentBlocked(&mut self, val: bool) {
        self._bitfield_1 &= !(33554432usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 25u32) & (33554432usize as u64);
    }
    #[inline]
    pub fn mHasMixedContentObjectSubrequest(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (67108864usize as u64))
                                       >> 26u32) as u8)
        }
    }
    #[inline]
    pub fn set_mHasMixedContentObjectSubrequest(&mut self, val: bool) {
        self._bitfield_1 &= !(67108864usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 26u32) & (67108864usize as u64);
    }
    #[inline]
    pub fn mHasCSP(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (134217728usize as u64)) >> 27u32) as
                                      u8)
        }
    }
    #[inline]
    pub fn set_mHasCSP(&mut self, val: bool) {
        self._bitfield_1 &= !(134217728usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 27u32) & (134217728usize as u64);
    }
    #[inline]
    pub fn mHasUnsafeEvalCSP(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (268435456usize as u64)) >> 28u32) as
                                      u8)
        }
    }
    #[inline]
    pub fn set_mHasUnsafeEvalCSP(&mut self, val: bool) {
        self._bitfield_1 &= !(268435456usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 28u32) & (268435456usize as u64);
    }
    #[inline]
    pub fn mHasUnsafeInlineCSP(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (536870912usize as u64)) >> 29u32) as
                                      u8)
        }
    }
    #[inline]
    pub fn set_mHasUnsafeInlineCSP(&mut self, val: bool) {
        self._bitfield_1 &= !(536870912usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 29u32) & (536870912usize as u64);
    }
    #[inline]
    pub fn mHasTrackingContentBlocked(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (1073741824usize as u64)) >> 30u32) as
                                      u8)
        }
    }
    #[inline]
    pub fn set_mHasTrackingContentBlocked(&mut self, val: bool) {
        self._bitfield_1 &= !(1073741824usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 30u32) & (1073741824usize as u64);
    }
    #[inline]
    pub fn mHasTrackingContentLoaded(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (2147483648usize as u64)) >> 31u32) as
                                      u8)
        }
    }
    #[inline]
    pub fn set_mHasTrackingContentLoaded(&mut self, val: bool) {
        self._bitfield_1 &= !(2147483648usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 31u32) & (2147483648usize as u64);
    }
    #[inline]
    pub fn mBFCacheDisallowed(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (4294967296usize as u64)) >> 32u32) as
                                      u8)
        }
    }
    #[inline]
    pub fn set_mBFCacheDisallowed(&mut self, val: bool) {
        self._bitfield_1 &= !(4294967296usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 32u32) & (4294967296usize as u64);
    }
    #[inline]
    pub fn mHasHadDefaultView(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (8589934592usize as u64)) >> 33u32) as
                                      u8)
        }
    }
    #[inline]
    pub fn set_mHasHadDefaultView(&mut self, val: bool) {
        self._bitfield_1 &= !(8589934592usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 33u32) & (8589934592usize as u64);
    }
    #[inline]
    pub fn mStyleSheetChangeEventsEnabled(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (17179869184usize as u64)) >> 34u32)
                                      as u8)
        }
    }
    #[inline]
    pub fn set_mStyleSheetChangeEventsEnabled(&mut self, val: bool) {
        self._bitfield_1 &= !(17179869184usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 34u32) & (17179869184usize as u64);
    }
    #[inline]
    pub fn mIsSrcdocDocument(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (34359738368usize as u64)) >> 35u32)
                                      as u8)
        }
    }
    #[inline]
    pub fn set_mIsSrcdocDocument(&mut self, val: bool) {
        self._bitfield_1 &= !(34359738368usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 35u32) & (34359738368usize as u64);
    }
    #[inline]
    pub fn mDidDocumentOpen(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (68719476736usize as u64)) >> 36u32)
                                      as u8)
        }
    }
    #[inline]
    pub fn set_mDidDocumentOpen(&mut self, val: bool) {
        self._bitfield_1 &= !(68719476736usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 36u32) & (68719476736usize as u64);
    }
    #[inline]
    pub fn mHasDisplayDocument(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (137438953472usize as u64)) >> 37u32)
                                      as u8)
        }
    }
    #[inline]
    pub fn set_mHasDisplayDocument(&mut self, val: bool) {
        self._bitfield_1 &= !(137438953472usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 37u32) & (137438953472usize as u64);
    }
    #[inline]
    pub fn mFontFaceSetDirty(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (274877906944usize as u64)) >> 38u32)
                                      as u8)
        }
    }
    #[inline]
    pub fn set_mFontFaceSetDirty(&mut self, val: bool) {
        self._bitfield_1 &= !(274877906944usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 38u32) & (274877906944usize as u64);
    }
    #[inline]
    pub fn mGetUserFontSetCalled(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (549755813888usize as u64)) >> 39u32)
                                      as u8)
        }
    }
    #[inline]
    pub fn set_mGetUserFontSetCalled(&mut self, val: bool) {
        self._bitfield_1 &= !(549755813888usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 39u32) & (549755813888usize as u64);
    }
    #[inline]
    pub fn mPostedFlushUserFontSet(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (1099511627776usize as u64)) >> 40u32)
                                      as u8)
        }
    }
    #[inline]
    pub fn set_mPostedFlushUserFontSet(&mut self, val: bool) {
        self._bitfield_1 &= !(1099511627776usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 40u32) & (1099511627776usize as u64);
    }
    #[inline]
    pub fn mEverInForeground(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (2199023255552usize as u64)) >> 41u32)
                                      as u8)
        }
    }
    #[inline]
    pub fn set_mEverInForeground(&mut self, val: bool) {
        self._bitfield_1 &= !(2199023255552usize as u64);
        self._bitfield_1 |=
            ((val as u8 as u64) << 41u32) & (2199023255552usize as u64);
    }
    #[inline]
    pub fn mDidFireDOMContentLoaded(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_2 & (1usize as u8)) >>
                                       0u32) as u8)
        }
    }
    #[inline]
    pub fn set_mDidFireDOMContentLoaded(&mut self, val: bool) {
        self._bitfield_2 &= !(1usize as u8);
        self._bitfield_2 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn mHasScrollLinkedEffect(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_2 & (2usize as u8)) >>
                                       1u32) as u8)
        }
    }
    #[inline]
    pub fn set_mHasScrollLinkedEffect(&mut self, val: bool) {
        self._bitfield_2 &= !(2usize as u8);
        self._bitfield_2 |= ((val as u8 as u8) << 1u32) & (2usize as u8);
    }
}
/**
 * An internal interface that abstracts some DOMNode-related parts that both
 * nsIContent and nsIDocument share.  An instance of this interface has a list
 * of nsIContent children and provides access to them.
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsINode {
    pub _base: EventTarget,
    pub mNodeInfo: RefPtr<NodeInfo>,
    pub mParent: *mut nsINode,
    pub mBoolFlags: u32,
    pub mNextSibling: *mut nsIContent,
    pub mPreviousSibling: *mut nsIContent,
    pub mFirstChild: *mut nsIContent,
    pub __bindgen_anon_1: nsINode__bindgen_ty_bindgen_id_105742,
    pub mSlots: *mut nsINode_nsSlots,
    pub mServoData: ServoCell<*mut ServoNodeData>,
}
pub type nsINode_BoxQuadOptions = BoxQuadOptions;
pub type nsINode_ConvertCoordinateOptions = ConvertCoordinateOptions;
pub type nsINode_DOMPoint = DOMPoint;
pub type nsINode_DOMPointInit = DOMPointInit;
pub type nsINode_DOMQuad = DOMQuad;
pub type nsINode_DOMRectReadOnly = DOMRectReadOnly;
pub type nsINode_OwningNodeOrString = OwningNodeOrString;
pub type nsINode_TextOrElementOrDocument = TextOrElementOrDocument;
pub type nsINode_ErrorResult = ErrorResult;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsINode_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[repr(u32)]
/**
   * Bit-flags to pass (or'ed together) to IsNodeOfType()
   */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsINode__bindgen_ty_bindgen_id_101867 {
    eCONTENT = 1,
    eDOCUMENT = 2,
    eATTRIBUTE = 4,
    eTEXT = 8,
    ePROCESSING_INSTRUCTION = 16,
    eCOMMENT = 32,
    eHTML_FORM_CONTROL = 64,
    eDOCUMENT_FRAGMENT = 128,
    eDATA_NODE = 256,
    eMEDIA = 512,
    eANIMATION = 1024,
    eFILTER = 2048,
}
#[repr(C)]
pub struct bindgen_vtable__bindgen_id_102636 {
}
#[repr(C)]
#[derive(Debug)]
pub struct nsINode_nsSlots {
    pub vtable_: *const bindgen_vtable__bindgen_id_102636,
    /**
     * A list of mutation observers
     */
    pub mMutationObservers: [u64; 2usize],
    /**
     * An object implementing nsIDOMNodeList for this content (childNodes)
     * @see nsIDOMNodeList
     * @see nsGenericHTMLElement::GetChildNodes
     */
    pub mChildNodes: RefPtr<nsChildContentList>,
    /**
     * Weak reference to this node.  This is cleared by the destructor of
     * nsNodeWeakReference.
     */
    pub mWeakReference: *mut nsNodeWeakReference,
    /**
     * Number of descendant nodes in the uncomposed document that have been
     * explicitly set as editable.
     */
    pub mEditableDescendantCount: u32,
}
#[test]
fn bindgen_test_layout_nsINode_nsSlots() {
    assert_eq!(::std::mem::size_of::<nsINode_nsSlots>() , 48usize);
    assert_eq!(::std::mem::align_of::<nsINode_nsSlots>() , 8usize);
}
#[repr(u32)]
/**
   * Boolean flags
   */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsINode_BooleanFlag {
    NodeHasRenderingObservers = 0,
    IsInDocument = 1,
    ParentIsContent = 2,
    NodeIsElement = 3,
    ElementHasID = 4,
    ElementMayHaveStyle = 5,
    ElementHasName = 6,
    ElementMayHaveContentEditableAttr = 7,
    NodeIsCommonAncestorForRangeInSelection = 8,
    NodeIsDescendantOfCommonAncestorForRangeInSelection = 9,
    NodeIsCCMarkedRoot = 10,
    NodeIsCCBlackTree = 11,
    NodeIsPurpleRoot = 12,
    NodeHasExplicitBaseURI = 13,
    ElementHasLockedStyleStates = 14,
    ElementHasPointerLock = 15,
    NodeMayHaveDOMMutationObserver = 16,
    NodeIsContent = 17,
    ElementHasAnimations = 18,
    NodeHasValidDirAttribute = 19,
    NodeHasFixedDir = 20,
    NodeHasDirAutoSet = 21,
    NodeHasTextNodeDirectionalityMap = 22,
    NodeHasDirAuto = 23,
    NodeAncestorHasDirAuto = 24,
    ElementIsInStyleScope = 25,
    ElementIsScopedStyleRoot = 26,
    NodeHandlingClick = 27,
    NodeHasRelevantHoverRules = 28,
    ElementHasWeirdParserInsertionMode = 29,
    ParserHasNotified = 30,
    MayBeApzAware = 31,
    BooleanFlagCount = 32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsINode__bindgen_ty_bindgen_id_105742 {
    pub mPrimaryFrame: __BindgenUnionField<*mut nsIFrame>,
    pub mSubtreeRoot: __BindgenUnionField<*mut nsINode>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_nsINode__bindgen_ty_bindgen_id_105742() {
    assert_eq!(::std::mem::size_of::<nsINode__bindgen_ty_bindgen_id_105742>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<nsINode__bindgen_ty_bindgen_id_105742>()
               , 8usize);
}
impl Clone for nsINode__bindgen_ty_bindgen_id_105742 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsINode() {
    assert_eq!(::std::mem::size_of::<nsINode>() , 104usize);
    assert_eq!(::std::mem::align_of::<nsINode>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct EventTarget {
    pub _base: nsIDOMEventTarget,
    pub _base_1: nsWrapperCache,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EventTarget_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_EventTarget() {
    assert_eq!(::std::mem::size_of::<EventTarget>() , 32usize);
    assert_eq!(::std::mem::align_of::<EventTarget>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIDOMEventTarget {
    pub _base: nsISupports,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsIDOMEventTarget_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsIDOMEventTarget() {
    assert_eq!(::std::mem::size_of::<nsIDOMEventTarget>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsIDOMEventTarget>() , 8usize);
}
impl Clone for nsIDOMEventTarget {
    fn clone(&self) -> Self { *self }
}
/**
 * Smart pointer class that can hold a pointer to either an nsStyleSet
 * or a ServoStyleSet.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct StyleSetHandle {
    pub mPtr: StyleSetHandle_Ptr,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct StyleSetHandle_Ptr {
    pub mValue: usize,
}
#[test]
fn bindgen_test_layout_StyleSetHandle_Ptr() {
    assert_eq!(::std::mem::size_of::<StyleSetHandle_Ptr>() , 8usize);
    assert_eq!(::std::mem::align_of::<StyleSetHandle_Ptr>() , 8usize);
}
impl Clone for StyleSetHandle_Ptr {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_StyleSetHandle() {
    assert_eq!(::std::mem::size_of::<StyleSetHandle>() , 8usize);
    assert_eq!(::std::mem::align_of::<StyleSetHandle>() , 8usize);
}
impl Clone for StyleSetHandle {
    fn clone(&self) -> Self { *self }
}
#[repr(i32)]
/**
 * Enumeration that represents one of the two supported style system backends.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum StyleBackendType { Gecko = 1, Servo = 2, }
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SheetType {
    Agent = 0,
    User = 1,
    PresHint = 2,
    SVGAttrAnimation = 3,
    Doc = 4,
    ScopedDoc = 5,
    StyleAttr = 6,
    Override = 7,
    Animation = 8,
    Transition = 9,
    Count = 10,
    Unknown = 255,
}
/**
 * EventStates is the class used to represent the event states of nsIContent
 * instances. These states are calculated by IntrinsicState() and
 * ContentStatesChanged() has to be called when one of them changes thus
 * informing the layout/style engine of the change.
 * Event states are associated with pseudo-classes.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct EventStates {
    pub mStates: EventStates_InternalType,
}
pub type EventStates_InternalType = u64;
pub type EventStates_ServoType = u8;
#[test]
fn bindgen_test_layout_EventStates() {
    assert_eq!(::std::mem::size_of::<EventStates>() , 8usize);
    assert_eq!(::std::mem::align_of::<EventStates>() , 8usize);
}
impl Clone for EventStates {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 * |nsRestyleHint| is a bitfield for the result of
 * |HasStateDependentStyle| and |HasAttributeDependentStyle|.  When no
 * restyling is necessary, use |nsRestyleHint(0)|.
 *
 * Without eRestyle_Force or eRestyle_ForceDescendants, the restyling process
 * can stop processing at a frame when it detects no style changes and it is
 * known that the styles of the subtree beneath it will not change, leaving
 * the old style context on the frame.  eRestyle_Force can be used to skip this
 * optimization on a frame, and to force its new style context to be used.
 *
 * Similarly, eRestyle_ForceDescendants will cause the frame and all of its
 * descendants to be traversed and for the new style contexts that are created
 * to be set on the frames.
 *
 * NOTE: When adding new restyle hints, please also add them to
 * RestyleManager::RestyleHintToString.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsRestyleHint {
    eRestyle_Self = 1,
    eRestyle_SomeDescendants = 2,
    eRestyle_Subtree = 4,
    eRestyle_LaterSiblings = 8,
    eRestyle_CSSTransitions = 16,
    eRestyle_CSSAnimations = 32,
    eRestyle_SVGAttrAnimations = 64,
    eRestyle_StyleAttribute = 128,
    eRestyle_StyleAttribute_Animations = 256,
    eRestyle_Force = 512,
    eRestyle_ForceDescendants = 1024,
    eRestyle_AllHintsWithAnimations = 368,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIObserver {
    pub _base: nsISupports,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsIObserver_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsIObserver() {
    assert_eq!(::std::mem::size_of::<nsIObserver>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsIObserver>() , 8usize);
}
impl Clone for nsIObserver {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsCompatibility {
    eCompatibility_FullStandards = 1,
    eCompatibility_AlmostStandards = 2,
    eCompatibility_NavQuirks = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VisibilityState {
    Hidden = 0,
    Visible = 1,
    Prerender = 2,
    EndGuard_ = 3,
}
/**
 * The global object which keeps a script context for each supported script
 * language. This often used to store per-window global state.
 * This is a heavyweight interface implemented only by DOM globals, and
 * it might go away some time in the future.
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsIScriptGlobalObject {
    pub _base: nsIGlobalObject,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsIScriptGlobalObject_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsIScriptGlobalObject() {
    assert_eq!(::std::mem::size_of::<nsIScriptGlobalObject>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsIScriptGlobalObject>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ShortcutKeyCandidate {
    pub _address: u8,
}
impl Clone for ShortcutKeyCandidate {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIVariant {
    pub _base: nsISupports,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsIVariant_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsIVariant() {
    assert_eq!(::std::mem::size_of::<nsIVariant>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsIVariant>() , 8usize);
}
impl Clone for nsIVariant {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIRunnable {
    pub _base: nsISupports,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsIRunnable_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsIRunnable() {
    assert_eq!(::std::mem::size_of::<nsIRunnable>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsIRunnable>() , 8usize);
}
impl Clone for nsIRunnable {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct Runnable {
    pub _base: nsIRunnable,
    pub mRefCnt: ThreadSafeAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
}
pub type Runnable_HasThreadSafeRefCnt = TrueType;
#[test]
fn bindgen_test_layout_Runnable() {
    assert_eq!(::std::mem::size_of::<Runnable>() , 24usize);
    assert_eq!(::std::mem::align_of::<Runnable>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIDOMAttr {
    pub _base: nsIDOMNode,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsIDOMAttr_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsIDOMAttr() {
    assert_eq!(::std::mem::size_of::<nsIDOMAttr>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsIDOMAttr>() , 8usize);
}
impl Clone for nsIDOMAttr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIDOMNode {
    pub _base: nsISupports,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsIDOMNode_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIDOMNode__bindgen_ty_bindgen_id_113677 {
    ELEMENT_NODE = 1,
    ATTRIBUTE_NODE = 2,
    TEXT_NODE = 3,
    CDATA_SECTION_NODE = 4,
    ENTITY_REFERENCE_NODE = 5,
    ENTITY_NODE = 6,
    PROCESSING_INSTRUCTION_NODE = 7,
    COMMENT_NODE = 8,
    DOCUMENT_NODE = 9,
    DOCUMENT_TYPE_NODE = 10,
    DOCUMENT_FRAGMENT_NODE = 11,
    NOTATION_NODE = 12,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIDOMNode__bindgen_ty_bindgen_id_113896 {
    DOCUMENT_POSITION_DISCONNECTED = 1,
    DOCUMENT_POSITION_PRECEDING = 2,
    DOCUMENT_POSITION_FOLLOWING = 4,
    DOCUMENT_POSITION_CONTAINS = 8,
    DOCUMENT_POSITION_CONTAINED_BY = 16,
    DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32,
}
#[test]
fn bindgen_test_layout_nsIDOMNode() {
    assert_eq!(::std::mem::size_of::<nsIDOMNode>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsIDOMNode>() , 8usize);
}
impl Clone for nsIDOMNode {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIDOMHTMLCollection {
    pub _base: nsISupports,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsIDOMHTMLCollection_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsIDOMHTMLCollection() {
    assert_eq!(::std::mem::size_of::<nsIDOMHTMLCollection>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsIDOMHTMLCollection>() , 8usize);
}
impl Clone for nsIDOMHTMLCollection {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIControllers {
    pub _address: u8,
}
impl Clone for nsIControllers {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct nsPresContext {
    pub _base: nsIObserver,
    pub mRefCnt: nsCycleCollectingAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    pub mType: nsPresContext_nsPresContextType,
    pub mShell: *mut nsIPresShell,
    pub mDocument: nsCOMPtr<nsIDocument>,
    pub mDeviceContext: RefPtr<nsDeviceContext>,
    pub mEventManager: RefPtr<EventStateManager>,
    pub mRefreshDriver: RefPtr<nsRefreshDriver>,
    pub mEffectCompositor: RefPtr<EffectCompositor>,
    pub mTransitionManager: RefPtr<nsTransitionManager>,
    pub mAnimationManager: RefPtr<nsAnimationManager>,
    pub mRestyleManager: RestyleManagerHandle_RefPtr,
    pub mCounterStyleManager: RefPtr<CounterStyleManager>,
    pub mMedium: *mut nsIAtom,
    pub mMediaEmulated: nsCOMPtr<nsIAtom>,
    pub mLinkHandler: *mut nsILinkHandler,
    pub mLanguage: nsCOMPtr<nsIAtom>,
    pub mInflationDisabledForShrinkWrap: bool,
    pub mContainer: u64,
    pub mBaseMinFontSize: i32,
    pub mTextZoom: f32,
    pub mFullZoom: f32,
    pub mOverrideDPPX: f32,
    pub mLastFontInflationScreenSize: [u64; 2usize],
    pub mCurAppUnitsPerDevPixel: i32,
    pub mAutoQualityMinFontSizePixelsPref: i32,
    pub mTheme: nsCOMPtr<nsITheme>,
    pub mLangService: nsCOMPtr<nsILanguageAtomService>,
    pub mPrintSettings: nsCOMPtr<nsIPrintSettings>,
    pub mPrefChangedTimer: nsCOMPtr<nsITimer>,
    pub mPropertyTable: nsPresContext_FramePropertyTable,
    pub mInvalidateRequestsSinceLastPaint: nsInvalidateRequestList,
    pub mUndeliveredInvalidateRequestsBeforeLastPaint: nsInvalidateRequestList,
    pub mTextPerf: nsAutoPtr<gfxTextPerfMetrics>,
    pub mMissingFonts: nsAutoPtr<gfxMissingFontRecorder>,
    pub mVisibleArea: nsRect,
    pub mPageSize: nsSize,
    pub mPageScale: f32,
    pub mPPScale: f32,
    pub mDefaultColor: nscolor,
    pub mBackgroundColor: nscolor,
    pub mLinkColor: nscolor,
    pub mActiveLinkColor: nscolor,
    pub mVisitedLinkColor: nscolor,
    pub mFocusBackgroundColor: nscolor,
    pub mFocusTextColor: nscolor,
    pub mBodyTextColor: nscolor,
    pub mViewportStyleScrollbar: nsPresContext_ScrollbarStyles,
    pub mFocusRingWidth: u8,
    pub mExistThrottledUpdates: bool,
    pub mImageAnimationMode: u16,
    pub mImageAnimationModePref: u16,
    pub mLangGroupFontPrefs: nsPresContext_LangGroupFontPrefs,
    pub mBorderWidthTable: [nscoord; 3usize],
    pub mInterruptChecksToSkip: u32,
    pub mElementsRestyled: u64,
    pub mFramesConstructed: u64,
    pub mFramesReflowed: u64,
    pub mReflowStartTime: TimeStamp,
    pub mLastStyleUpdateForAllAnimations: TimeStamp,
    pub _bitfield_1: u64,
    pub mRestyleLoggingEnabled: bool,
    pub mInitialized: bool,
    pub mLayoutPhaseCount: [u32; 3usize],
}
pub type nsPresContext_FramePropertyTable = FramePropertyTable;
pub type nsPresContext_LangGroupFontPrefs = LangGroupFontPrefs;
pub type nsPresContext_ScrollbarStyles = ScrollbarStyles;
pub type nsPresContext_StaticPresData = StaticPresData;
pub type nsPresContext_HasThreadSafeRefCnt = FalseType;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsPresContext_cycleCollection {
    pub _base: nsXPCOMCycleCollectionParticipant,
}
#[test]
fn bindgen_test_layout_nsPresContext_cycleCollection() {
    assert_eq!(::std::mem::size_of::<nsPresContext_cycleCollection>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<nsPresContext_cycleCollection>() ,
               8usize);
}
impl Clone for nsPresContext_cycleCollection {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsPresContext_nsPresContextType {
    eContext_Galley = 0,
    eContext_PrintPreview = 1,
    eContext_Print = 2,
    eContext_PageLayout = 3,
}
/**
   * A class that can be used to temporarily disable reflow interruption.
   */
#[repr(C)]
#[derive(Debug)]
pub struct nsPresContext_InterruptPreventer {
    pub mCtx: *mut nsPresContext,
    pub mInterruptsEnabled: bool,
    pub mHasPendingInterrupt: bool,
}
#[test]
fn bindgen_test_layout_nsPresContext_InterruptPreventer() {
    assert_eq!(::std::mem::size_of::<nsPresContext_InterruptPreventer>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<nsPresContext_InterruptPreventer>() ,
               8usize);
}
extern "C" {
    #[link_name = "_ZN13nsPresContext21_cycleCollectorGlobalE"]
    pub static mut nsPresContext__cycleCollectorGlobal:
               nsPresContext_cycleCollection;
}
#[test]
fn bindgen_test_layout_nsPresContext() {
    assert_eq!(::std::mem::size_of::<nsPresContext>() , 1184usize);
    assert_eq!(::std::mem::align_of::<nsPresContext>() , 8usize);
}
impl nsPresContext {
    #[inline]
    pub fn mHasPendingInterrupt(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u64)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_mHasPendingInterrupt(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1usize as u64);
        self._bitfield_1 |= ((val as u32 as u64) << 0u32) & (1usize as u64);
    }
    #[inline]
    pub fn mPendingInterruptFromTest(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u64)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_mPendingInterruptFromTest(&mut self,
                                         val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2usize as u64);
        self._bitfield_1 |= ((val as u32 as u64) << 1u32) & (2usize as u64);
    }
    #[inline]
    pub fn mInterruptsEnabled(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u64)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_mInterruptsEnabled(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4usize as u64);
        self._bitfield_1 |= ((val as u32 as u64) << 2u32) & (4usize as u64);
    }
    #[inline]
    pub fn mUseDocumentFonts(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u64)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_mUseDocumentFonts(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(8usize as u64);
        self._bitfield_1 |= ((val as u32 as u64) << 3u32) & (8usize as u64);
    }
    #[inline]
    pub fn mUseDocumentColors(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u64)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_mUseDocumentColors(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16usize as u64);
        self._bitfield_1 |= ((val as u32 as u64) << 4u32) & (16usize as u64);
    }
    #[inline]
    pub fn mUnderlineLinks(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u64)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_mUnderlineLinks(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(32usize as u64);
        self._bitfield_1 |= ((val as u32 as u64) << 5u32) & (32usize as u64);
    }
    #[inline]
    pub fn mSendAfterPaintToContent(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u64)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_mSendAfterPaintToContent(&mut self,
                                        val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(64usize as u64);
        self._bitfield_1 |= ((val as u32 as u64) << 6u32) & (64usize as u64);
    }
    #[inline]
    pub fn mUseFocusColors(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u64)) >>
                                       7u32) as u32)
        }
    }
    #[inline]
    pub fn set_mUseFocusColors(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(128usize as u64);
        self._bitfield_1 |= ((val as u32 as u64) << 7u32) & (128usize as u64);
    }
    #[inline]
    pub fn mFocusRingOnAnything(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (256usize as u64)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_mFocusRingOnAnything(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(256usize as u64);
        self._bitfield_1 |= ((val as u32 as u64) << 8u32) & (256usize as u64);
    }
    #[inline]
    pub fn mFocusRingStyle(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (512usize as u64)) >>
                                       9u32) as u32)
        }
    }
    #[inline]
    pub fn set_mFocusRingStyle(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(512usize as u64);
        self._bitfield_1 |= ((val as u32 as u64) << 9u32) & (512usize as u64);
    }
    #[inline]
    pub fn mDrawImageBackground(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1024usize as u64)) >>
                                       10u32) as u32)
        }
    }
    #[inline]
    pub fn set_mDrawImageBackground(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1024usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 10u32) & (1024usize as u64);
    }
    #[inline]
    pub fn mDrawColorBackground(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2048usize as u64)) >>
                                       11u32) as u32)
        }
    }
    #[inline]
    pub fn set_mDrawColorBackground(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2048usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 11u32) & (2048usize as u64);
    }
    #[inline]
    pub fn mNeverAnimate(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4096usize as u64)) >>
                                       12u32) as u32)
        }
    }
    #[inline]
    pub fn set_mNeverAnimate(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4096usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 12u32) & (4096usize as u64);
    }
    #[inline]
    pub fn mIsRenderingOnlySelection(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8192usize as u64)) >>
                                       13u32) as u32)
        }
    }
    #[inline]
    pub fn set_mIsRenderingOnlySelection(&mut self,
                                         val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(8192usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 13u32) & (8192usize as u64);
    }
    #[inline]
    pub fn mPaginated(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16384usize as u64)) >>
                                       14u32) as u32)
        }
    }
    #[inline]
    pub fn set_mPaginated(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16384usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 14u32) & (16384usize as u64);
    }
    #[inline]
    pub fn mCanPaginatedScroll(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32768usize as u64)) >>
                                       15u32) as u32)
        }
    }
    #[inline]
    pub fn set_mCanPaginatedScroll(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(32768usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 15u32) & (32768usize as u64);
    }
    #[inline]
    pub fn mDoScaledTwips(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (65536usize as u64)) >>
                                       16u32) as u32)
        }
    }
    #[inline]
    pub fn set_mDoScaledTwips(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(65536usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 16u32) & (65536usize as u64);
    }
    #[inline]
    pub fn mIsRootPaginatedDocument(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (131072usize as u64))
                                       >> 17u32) as u32)
        }
    }
    #[inline]
    pub fn set_mIsRootPaginatedDocument(&mut self,
                                        val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(131072usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 17u32) & (131072usize as u64);
    }
    #[inline]
    pub fn mPrefBidiDirection(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (262144usize as u64))
                                       >> 18u32) as u32)
        }
    }
    #[inline]
    pub fn set_mPrefBidiDirection(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(262144usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 18u32) & (262144usize as u64);
    }
    #[inline]
    pub fn mPrefScrollbarSide(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1572864usize as u64))
                                       >> 19u32) as u32)
        }
    }
    #[inline]
    pub fn set_mPrefScrollbarSide(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1572864usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 19u32) & (1572864usize as u64);
    }
    #[inline]
    pub fn mPendingSysColorChanged(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2097152usize as u64))
                                       >> 21u32) as u32)
        }
    }
    #[inline]
    pub fn set_mPendingSysColorChanged(&mut self,
                                       val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2097152usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 21u32) & (2097152usize as u64);
    }
    #[inline]
    pub fn mPendingThemeChanged(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4194304usize as u64))
                                       >> 22u32) as u32)
        }
    }
    #[inline]
    pub fn set_mPendingThemeChanged(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4194304usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 22u32) & (4194304usize as u64);
    }
    #[inline]
    pub fn mPendingUIResolutionChanged(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8388608usize as u64))
                                       >> 23u32) as u32)
        }
    }
    #[inline]
    pub fn set_mPendingUIResolutionChanged(&mut self,
                                           val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(8388608usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 23u32) & (8388608usize as u64);
    }
    #[inline]
    pub fn mPendingMediaFeatureValuesChanged(&self)
     -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16777216usize as u64))
                                       >> 24u32) as u32)
        }
    }
    #[inline]
    pub fn set_mPendingMediaFeatureValuesChanged(&mut self,
                                                 val:
                                                     ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16777216usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 24u32) & (16777216usize as u64);
    }
    #[inline]
    pub fn mPrefChangePendingNeedsReflow(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (33554432usize as u64))
                                       >> 25u32) as u32)
        }
    }
    #[inline]
    pub fn set_mPrefChangePendingNeedsReflow(&mut self,
                                             val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(33554432usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 25u32) & (33554432usize as u64);
    }
    #[inline]
    pub fn mIsEmulatingMedia(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (67108864usize as u64))
                                       >> 26u32) as u32)
        }
    }
    #[inline]
    pub fn set_mIsEmulatingMedia(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(67108864usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 26u32) & (67108864usize as u64);
    }
    #[inline]
    pub fn mAllInvalidated(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (134217728usize as u64)) >> 27u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_mAllInvalidated(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(134217728usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 27u32) & (134217728usize as u64);
    }
    #[inline]
    pub fn mIsGlyph(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (268435456usize as u64)) >> 28u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_mIsGlyph(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(268435456usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 28u32) & (268435456usize as u64);
    }
    #[inline]
    pub fn mUsesRootEMUnits(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (536870912usize as u64)) >> 29u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_mUsesRootEMUnits(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(536870912usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 29u32) & (536870912usize as u64);
    }
    #[inline]
    pub fn mUsesExChUnits(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (1073741824usize as u64)) >> 30u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_mUsesExChUnits(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1073741824usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 30u32) & (1073741824usize as u64);
    }
    #[inline]
    pub fn mUsesViewportUnits(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (2147483648usize as u64)) >> 31u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_mUsesViewportUnits(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2147483648usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 31u32) & (2147483648usize as u64);
    }
    #[inline]
    pub fn mPendingViewportChange(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (4294967296usize as u64)) >> 32u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_mPendingViewportChange(&mut self,
                                      val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4294967296usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 32u32) & (4294967296usize as u64);
    }
    #[inline]
    pub fn mCounterStylesDirty(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (8589934592usize as u64)) >> 33u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_mCounterStylesDirty(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(8589934592usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 33u32) & (8589934592usize as u64);
    }
    #[inline]
    pub fn mPostedFlushCounterStyles(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (17179869184usize as u64)) >> 34u32)
                                      as u32)
        }
    }
    #[inline]
    pub fn set_mPostedFlushCounterStyles(&mut self,
                                         val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(17179869184usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 34u32) & (17179869184usize as u64);
    }
    #[inline]
    pub fn mSuppressResizeReflow(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (34359738368usize as u64)) >> 35u32)
                                      as u32)
        }
    }
    #[inline]
    pub fn set_mSuppressResizeReflow(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(34359738368usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 35u32) & (34359738368usize as u64);
    }
    #[inline]
    pub fn mIsVisual(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (68719476736usize as u64)) >> 36u32)
                                      as u32)
        }
    }
    #[inline]
    pub fn set_mIsVisual(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(68719476736usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 36u32) & (68719476736usize as u64);
    }
    #[inline]
    pub fn mFireAfterPaintEvents(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (137438953472usize as u64)) >> 37u32)
                                      as u32)
        }
    }
    #[inline]
    pub fn set_mFireAfterPaintEvents(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(137438953472usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 37u32) & (137438953472usize as u64);
    }
    #[inline]
    pub fn mIsChrome(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (274877906944usize as u64)) >> 38u32)
                                      as u32)
        }
    }
    #[inline]
    pub fn set_mIsChrome(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(274877906944usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 38u32) & (274877906944usize as u64);
    }
    #[inline]
    pub fn mIsChromeOriginImage(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (549755813888usize as u64)) >> 39u32)
                                      as u32)
        }
    }
    #[inline]
    pub fn set_mIsChromeOriginImage(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(549755813888usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 39u32) & (549755813888usize as u64);
    }
    #[inline]
    pub fn mPaintFlashing(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (1099511627776usize as u64)) >> 40u32)
                                      as u32)
        }
    }
    #[inline]
    pub fn set_mPaintFlashing(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1099511627776usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 40u32) & (1099511627776usize as u64);
    }
    #[inline]
    pub fn mPaintFlashingInitialized(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (2199023255552usize as u64)) >> 41u32)
                                      as u32)
        }
    }
    #[inline]
    pub fn set_mPaintFlashingInitialized(&mut self,
                                         val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2199023255552usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 41u32) & (2199023255552usize as u64);
    }
    #[inline]
    pub fn mHasWarnedAboutPositionedTableParts(&self)
     -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (4398046511104usize as u64)) >> 42u32)
                                      as u32)
        }
    }
    #[inline]
    pub fn set_mHasWarnedAboutPositionedTableParts(&mut self,
                                                   val:
                                                       ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4398046511104usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 42u32) & (4398046511104usize as u64);
    }
    #[inline]
    pub fn mHasWarnedAboutTooLargeDashedOrDottedRadius(&self)
     -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (8796093022208usize as u64)) >> 43u32)
                                      as u32)
        }
    }
    #[inline]
    pub fn set_mHasWarnedAboutTooLargeDashedOrDottedRadius(&mut self,
                                                           val:
                                                               ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(8796093022208usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 43u32) & (8796093022208usize as u64);
    }
    #[inline]
    pub fn mQuirkSheetAdded(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (17592186044416usize as u64)) >>
                                       44u32) as u32)
        }
    }
    #[inline]
    pub fn set_mQuirkSheetAdded(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(17592186044416usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 44u32) & (17592186044416usize as u64);
    }
    #[inline]
    pub fn mNeedsPrefUpdate(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (35184372088832usize as u64)) >>
                                       45u32) as u32)
        }
    }
    #[inline]
    pub fn set_mNeedsPrefUpdate(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(35184372088832usize as u64);
        self._bitfield_1 |=
            ((val as u32 as u64) << 45u32) & (35184372088832usize as u64);
    }
}
/**
 * Smart pointer class that can hold a pointer to either a RestyleManager
 * or a ServoRestyleManager.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RestyleManagerHandle {
    pub mPtr: RestyleManagerHandle_Ptr,
}
pub type RestyleManagerHandle_RefPtr = HandleRefPtr<RestyleManagerHandle>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RestyleManagerHandle_Ptr {
    pub mValue: usize,
}
#[test]
fn bindgen_test_layout_RestyleManagerHandle_Ptr() {
    assert_eq!(::std::mem::size_of::<RestyleManagerHandle_Ptr>() , 8usize);
    assert_eq!(::std::mem::align_of::<RestyleManagerHandle_Ptr>() , 8usize);
}
impl Clone for RestyleManagerHandle_Ptr {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_RestyleManagerHandle() {
    assert_eq!(::std::mem::size_of::<RestyleManagerHandle>() , 8usize);
    assert_eq!(::std::mem::align_of::<RestyleManagerHandle>() , 8usize);
}
impl Clone for RestyleManagerHandle {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsChangeHint {
    nsChangeHint_RepaintFrame = 1,
    nsChangeHint_NeedReflow = 2,
    nsChangeHint_ClearAncestorIntrinsics = 4,
    nsChangeHint_ClearDescendantIntrinsics = 8,
    nsChangeHint_NeedDirtyReflow = 16,
    nsChangeHint_SyncFrameView = 32,
    nsChangeHint_UpdateCursor = 64,
    nsChangeHint_UpdateEffects = 128,
    nsChangeHint_UpdateOpacityLayer = 256,
    nsChangeHint_UpdateTransformLayer = 512,
    nsChangeHint_ReconstructFrame = 1024,
    nsChangeHint_UpdateOverflow = 2048,
    nsChangeHint_UpdateSubtreeOverflow = 4096,
    nsChangeHint_UpdatePostTransformOverflow = 8192,
    nsChangeHint_UpdateParentOverflow = 16384,
    nsChangeHint_ChildrenOnlyTransform = 32768,
    nsChangeHint_RecomputePosition = 65536,
    nsChangeHint_UpdateContainingBlock = 131072,
    nsChangeHint_BorderStyleNoneChange = 262144,
    nsChangeHint_UpdateTextPath = 524288,
    nsChangeHint_SchedulePaint = 1048576,
    nsChangeHint_NeutralChange = 2097152,
    nsChangeHint_InvalidateRenderingObservers = 4194304,
    nsChangeHint_ReflowChangesSizeOrPosition = 8388608,
    nsChangeHint_UpdateComputedBSize = 16777216,
    nsChangeHint_UpdateUsesOpacity = 33554432,
    nsChangeHint_UpdateBackgroundPosition = 67108864,
    nsChangeHint_AddOrRemoveTransform = 134217728,
    nsChangeHint_AllHints = 268435455,
}
pub type nscolor = u32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Side {
    eSideTop = 0,
    eSideRight = 1,
    eSideBottom = 2,
    eSideLeft = 3,
}
#[repr(C)]
#[derive(Debug)]
pub struct CallbackFunction {
    pub _base: CallbackObject,
}
#[test]
fn bindgen_test_layout_CallbackFunction() {
    assert_eq!(::std::mem::size_of::<CallbackFunction>() , 56usize);
    assert_eq!(::std::mem::align_of::<CallbackFunction>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct CallbackObject {
    pub _base: nsISupports,
    pub mRefCnt: nsCycleCollectingAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    pub mCallback: u64,
    pub mCreationStack: u64,
    pub mIncumbentGlobal: nsCOMPtr<nsIGlobalObject>,
    pub mIncumbentJSGlobal: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CallbackObject_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
pub type CallbackObject_HasThreadSafeRefCnt = FalseType;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CallbackObject_cycleCollection {
    pub _base: nsXPCOMCycleCollectionParticipant,
}
#[test]
fn bindgen_test_layout_CallbackObject_cycleCollection() {
    assert_eq!(::std::mem::size_of::<CallbackObject_cycleCollection>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<CallbackObject_cycleCollection>() ,
               8usize);
}
impl Clone for CallbackObject_cycleCollection {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CallbackObject_ExceptionHandling {
    eReportExceptions = 0,
    eRethrowContentExceptions = 1,
    eRethrowExceptions = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CallbackObject_FastCallbackConstructor {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_CallbackObject_FastCallbackConstructor() {
    assert_eq!(::std::mem::size_of::<CallbackObject_FastCallbackConstructor>()
               , 1usize);
    assert_eq!(::std::mem::align_of::<CallbackObject_FastCallbackConstructor>()
               , 1usize);
}
impl Clone for CallbackObject_FastCallbackConstructor {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct CallbackObject_CallSetup {
    pub mCx: *mut JSContext,
    pub mCompartment: *mut JSCompartment,
    pub mAutoEntryScript: [u64; 21usize],
    pub mAutoIncumbentScript: [u64; 6usize],
    pub mRootedCallable: [u64; 4usize],
    pub mAsyncStack: [u64; 4usize],
    pub mAsyncStackSetter: [u64; 7usize],
    pub mAc: [u64; 4usize],
    pub mErrorResult: *mut ErrorResult,
    pub mExceptionHandling: CallbackObject_ExceptionHandling,
    pub mIsMainThread: bool,
}
#[test]
fn bindgen_test_layout_CallbackObject_CallSetup() {
    assert_eq!(::std::mem::size_of::<CallbackObject_CallSetup>() , 400usize);
    assert_eq!(::std::mem::align_of::<CallbackObject_CallSetup>() , 8usize);
}
extern "C" {
    #[link_name = "_ZN7mozilla3dom14CallbackObject21_cycleCollectorGlobalE"]
    pub static mut CallbackObject__cycleCollectorGlobal:
               CallbackObject_cycleCollection;
}
#[test]
fn bindgen_test_layout_CallbackObject() {
    assert_eq!(::std::mem::size_of::<CallbackObject>() , 56usize);
    assert_eq!(::std::mem::align_of::<CallbackObject>() , 8usize);
}
pub type PLDHashNumber = u32;
#[repr(C)]
#[derive(Debug)]
pub struct PLDHashTable {
    pub mOps: *const PLDHashTableOps,
    pub mHashShift: i16,
    pub mEntrySize: u32,
    pub mEntryCount: u32,
    pub mRemovedCount: u32,
    pub mEntryStore: PLDHashTable_EntryStore,
    pub mChecker: Checker,
}
#[repr(C)]
#[derive(Debug)]
pub struct PLDHashTable_EntryStore {
    pub mEntryStore: *mut ::std::os::raw::c_char,
    pub mGeneration: u32,
}
#[test]
fn bindgen_test_layout_PLDHashTable_EntryStore() {
    assert_eq!(::std::mem::size_of::<PLDHashTable_EntryStore>() , 16usize);
    assert_eq!(::std::mem::align_of::<PLDHashTable_EntryStore>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct PLDHashTable_Iterator {
    pub mTable: *mut PLDHashTable,
    pub mStart: *mut ::std::os::raw::c_char,
    pub mLimit: *mut ::std::os::raw::c_char,
    pub mCurrent: *mut ::std::os::raw::c_char,
    pub mNexts: u32,
    pub mNextsLimit: u32,
    pub mHaveRemoved: bool,
}
#[test]
fn bindgen_test_layout_PLDHashTable_Iterator() {
    assert_eq!(::std::mem::size_of::<PLDHashTable_Iterator>() , 48usize);
    assert_eq!(::std::mem::align_of::<PLDHashTable_Iterator>() , 8usize);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum PLDHashTable_SearchReason { ForSearchOrRemove = 0, ForAdd = 1, }
extern "C" {
    #[link_name = "_ZN12PLDHashTable12kMaxCapacityE"]
    pub static PLDHashTable_kMaxCapacity: u32;
}
extern "C" {
    #[link_name = "_ZN12PLDHashTable12kMinCapacityE"]
    pub static PLDHashTable_kMinCapacity: u32;
}
extern "C" {
    #[link_name = "_ZN12PLDHashTable17kMaxInitialLengthE"]
    pub static PLDHashTable_kMaxInitialLength: u32;
}
extern "C" {
    #[link_name = "_ZN12PLDHashTable21kDefaultInitialLengthE"]
    pub static PLDHashTable_kDefaultInitialLength: u32;
}
extern "C" {
    #[link_name = "_ZN12PLDHashTable9kHashBitsE"]
    pub static PLDHashTable_kHashBits: u32;
}
extern "C" {
    #[link_name = "_ZN12PLDHashTable12kGoldenRatioE"]
    pub static PLDHashTable_kGoldenRatio: u32;
}
extern "C" {
    #[link_name = "_ZN12PLDHashTable14kCollisionFlagE"]
    pub static PLDHashTable_kCollisionFlag: PLDHashNumber;
}
#[test]
fn bindgen_test_layout_PLDHashTable() {
    assert_eq!(::std::mem::size_of::<PLDHashTable>() , 48usize);
    assert_eq!(::std::mem::align_of::<PLDHashTable>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PLDHashTableOps {
    pub hashKey: PLDHashHashKey,
    pub matchEntry: PLDHashMatchEntry,
    pub moveEntry: PLDHashMoveEntry,
    pub clearEntry: PLDHashClearEntry,
    pub initEntry: PLDHashInitEntry,
}
#[test]
fn bindgen_test_layout_PLDHashTableOps() {
    assert_eq!(::std::mem::size_of::<PLDHashTableOps>() , 40usize);
    assert_eq!(::std::mem::align_of::<PLDHashTableOps>() , 8usize);
}
impl Clone for PLDHashTableOps {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PLDHashEntryHdr {
    pub mKeyHash: PLDHashNumber,
}
#[test]
fn bindgen_test_layout_PLDHashEntryHdr() {
    assert_eq!(::std::mem::size_of::<PLDHashEntryHdr>() , 4usize);
    assert_eq!(::std::mem::align_of::<PLDHashEntryHdr>() , 4usize);
}
impl Clone for PLDHashEntryHdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Checker {
    pub mState: u32,
    pub mIsWritable: u32,
}
extern "C" {
    #[link_name = "_ZN7Checker5kIdleE"]
    pub static Checker_kIdle: u32;
}
extern "C" {
    #[link_name = "_ZN7Checker6kRead1E"]
    pub static Checker_kRead1: u32;
}
extern "C" {
    #[link_name = "_ZN7Checker8kReadMaxE"]
    pub static Checker_kReadMax: u32;
}
extern "C" {
    #[link_name = "_ZN7Checker6kWriteE"]
    pub static Checker_kWrite: u32;
}
#[test]
fn bindgen_test_layout_Checker() {
    assert_eq!(::std::mem::size_of::<Checker>() , 8usize);
    assert_eq!(::std::mem::align_of::<Checker>() , 4usize);
}
impl Clone for Checker {
    fn clone(&self) -> Self { *self }
}
pub type PLDHashHashKey =
    ::std::option::Option<unsafe extern "C" fn(aKey:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_uint>;
pub type PLDHashMatchEntry =
    ::std::option::Option<unsafe extern "C" fn(aEntry: *const PLDHashEntryHdr,
                                               aKey:
                                                   *const ::std::os::raw::c_void)
                              -> bool>;
pub type PLDHashMoveEntry =
    ::std::option::Option<unsafe extern "C" fn(aTable: *mut PLDHashTable,
                                               aFrom: *const PLDHashEntryHdr,
                                               aTo: *mut PLDHashEntryHdr)>;
pub type PLDHashClearEntry =
    ::std::option::Option<unsafe extern "C" fn(aTable: *mut PLDHashTable,
                                               aEntry: *mut PLDHashEntryHdr)>;
pub type PLDHashInitEntry =
    ::std::option::Option<unsafe extern "C" fn(aEntry: *mut PLDHashEntryHdr,
                                               aKey:
                                                   *const ::std::os::raw::c_void)>;
/**
 * hashkey wrapper using T* KeyType
 *
 * @see nsTHashtable::EntryType for specification
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsPtrHashKey<T> {
    pub _base: PLDHashEntryHdr,
    pub mKey: *mut T,
}
pub type nsPtrHashKey_KeyType<T> = *mut T;
pub type nsPtrHashKey_KeyTypePointer<T> = *mut T;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsPtrHashKey__bindgen_ty_bindgen_id_118426 { ALLOW_MEMMOVE = 0, }
/**
 * A node of content in a document's content model. This interface
 * is supported by all content objects.
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsIContent {
    pub _base: nsINode,
}
pub type nsIContent_IMEState = IMEState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsIContent_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIContent__bindgen_ty_bindgen_id_119766 {
    eAllChildren = 0,
    eAllButXBL = 1,
    eSkipPlaceholderContent = 2,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIContent__bindgen_ty_bindgen_id_120002 {
    ATTR_MISSING = -1,
    ATTR_VALUE_NO_MATCH = -2,
}
/**
   * Check whether this content node's given attribute has one of a given
   * list of values. If there is a match, we return the index in the list
   * of the first matching value. If there was no attribute at all, then
   * we return ATTR_MISSING. If there was an attribute but it didn't
   * match, we return ATTR_VALUE_NO_MATCH. A non-negative result always
   * indicates a match.
   *
   * @param aNameSpaceID The namespace ID of the attribute.  Must not
   *                     be kNameSpaceID_Unknown.
   * @param aName The name atom of the attribute.  Must not be null.
   * @param aValues a nullptr-terminated array of pointers to atom values to test
   *                against.
   * @param aCaseSensitive Whether to do a case-sensitive compare on the values.
   * @return ATTR_MISSING, ATTR_VALUE_NO_MATCH or the non-negative index
   * indicating the first value of aValues that matched
   */
pub type nsIContent_AttrValuesArray = *const *mut nsIAtom;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIContent_ETabFocusType {
    eTabFocus_formElementsMask = 2,
    eTabFocus_linksMask = 4,
    eTabFocus_any = 7,
}
extern "C" {
    #[link_name = "_ZN10nsIContent14sTabFocusModelE"]
    pub static mut nsIContent_sTabFocusModel: i32;
}
extern "C" {
    #[link_name = "_ZN10nsIContent26sTabFocusModelAppliesToXULE"]
    pub static mut nsIContent_sTabFocusModelAppliesToXUL: bool;
}
#[test]
fn bindgen_test_layout_nsIContent() {
    assert_eq!(::std::mem::size_of::<nsIContent>() , 104usize);
    assert_eq!(::std::mem::align_of::<nsIContent>() , 8usize);
}
/**
 * Struct that stores info on an attribute. The name and value must either both
 * be null or both be non-null.
 *
 * Note that, just as the pointers returned by GetAttrNameAt, the pointers that
 * this struct hold are only valid until the element or its attributes are
 * mutated (directly or via script).
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BorrowedAttrInfo {
    pub mName: *const nsAttrName,
    pub mValue: *const nsAttrValue,
}
#[test]
fn bindgen_test_layout_BorrowedAttrInfo() {
    assert_eq!(::std::mem::size_of::<BorrowedAttrInfo>() , 16usize);
    assert_eq!(::std::mem::align_of::<BorrowedAttrInfo>() , 8usize);
}
impl Clone for BorrowedAttrInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsICSSDeclaration {
    pub _address: u8,
}
impl Clone for nsICSSDeclaration {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AudioContext {
    pub _address: u8,
}
impl Clone for AudioContext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct Element {
    pub _base: FragmentOrElement,
    pub mState: EventStates,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Element_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Element_MappedAttributeEntry {
    pub attribute: *mut *mut nsIAtom,
}
#[test]
fn bindgen_test_layout_Element_MappedAttributeEntry() {
    assert_eq!(::std::mem::size_of::<Element_MappedAttributeEntry>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<Element_MappedAttributeEntry>() ,
               8usize);
}
impl Clone for Element_MappedAttributeEntry {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "_ZN7mozilla3dom7Element18kFireMutationEventE"]
    pub static Element_kFireMutationEvent: bool;
}
extern "C" {
    #[link_name = "_ZN7mozilla3dom7Element22kDontFireMutationEventE"]
    pub static Element_kDontFireMutationEvent: bool;
}
extern "C" {
    #[link_name = "_ZN7mozilla3dom7Element24kNotifyDocumentObserversE"]
    pub static Element_kNotifyDocumentObservers: bool;
}
extern "C" {
    #[link_name = "_ZN7mozilla3dom7Element28kDontNotifyDocumentObserversE"]
    pub static Element_kDontNotifyDocumentObservers: bool;
}
extern "C" {
    #[link_name = "_ZN7mozilla3dom7Element17kCallAfterSetAttrE"]
    pub static Element_kCallAfterSetAttr: bool;
}
extern "C" {
    #[link_name = "_ZN7mozilla3dom7Element21kDontCallAfterSetAttrE"]
    pub static Element_kDontCallAfterSetAttr: bool;
}
#[test]
fn bindgen_test_layout_Element() {
    assert_eq!(::std::mem::size_of::<Element>() , 136usize);
    assert_eq!(::std::mem::align_of::<Element>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct FragmentOrElement {
    pub _base: nsIContent,
    pub mRefCnt: nsCycleCollectingAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    /**
   * Array containing all attributes and children for this element
   */
    pub mAttrsAndChildren: nsAttrAndChildArray,
}
pub type FragmentOrElement_HasThreadSafeRefCnt = FalseType;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FragmentOrElement_cycleCollection {
    pub _base: nsXPCOMCycleCollectionParticipant,
}
#[test]
fn bindgen_test_layout_FragmentOrElement_cycleCollection() {
    assert_eq!(::std::mem::size_of::<FragmentOrElement_cycleCollection>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<FragmentOrElement_cycleCollection>() ,
               8usize);
}
impl Clone for FragmentOrElement_cycleCollection {
    fn clone(&self) -> Self { *self }
}
/**
   * There are a set of DOM- and scripting-specific instance variables
   * that may only be instantiated when a content object is accessed
   * through the DOM. Rather than burn actual slots in the content
   * objects for each of these instance variables, we put them off
   * in a side structure that's only allocated when the content is
   * accessed through the DOM.
   */
#[repr(C)]
#[derive(Debug)]
pub struct FragmentOrElement_nsDOMSlots {
    pub _base: nsINode_nsSlots,
    /**
     * The .style attribute (an interface that forwards to the actual
     * style rules)
     * @see nsGenericHTMLElement::GetStyle
     */
    pub mStyle: nsCOMPtr<nsICSSDeclaration>,
    /**
     * The .dataset attribute.
     * @see nsGenericHTMLElement::GetDataset
     */
    pub mDataset: *mut nsDOMStringMap,
    /**
     * The .undoManager property.
     * @see nsGenericHTMLElement::GetUndoManager
     */
    pub mUndoManager: RefPtr<UndoManager>,
    /**
     * SMIL Overridde style rules (for SMIL animation of CSS properties)
     * @see nsIContent::GetSMILOverrideStyle
     */
    pub mSMILOverrideStyle: nsCOMPtr<nsICSSDeclaration>,
    /**
     * Holds any SMIL override style declaration for this element.
     */
    pub mSMILOverrideStyleDeclaration: RefPtr<Declaration>,
    /**
     * An object implementing nsIDOMMozNamedAttrMap for this content (attributes)
     * @see FragmentOrElement::GetAttributes
     */
    pub mAttributeMap: RefPtr<nsDOMAttributeMap>,
    pub __bindgen_anon_1: FragmentOrElement_nsDOMSlots__bindgen_ty_bindgen_id_121135,
    /**
     * An object implementing the .children property for this element.
     */
    pub mChildrenList: RefPtr<nsContentList>,
    /**
     * An object implementing the .classList property for this element.
     */
    pub mClassList: RefPtr<nsDOMTokenList>,
    /**
     * ShadowRoot bound to the element.
     */
    pub mShadowRoot: RefPtr<ShadowRoot>,
    /**
     * The root ShadowRoot of this element if it is in a shadow tree.
     */
    pub mContainingShadow: RefPtr<ShadowRoot>,
    /**
     * An array of web component insertion points to which this element
     * is distributed.
     */
    pub mDestInsertionPoints: nsTArray<*mut nsIContent>,
    /**
     * XBL binding installed on the element.
     */
    pub mXBLBinding: RefPtr<nsXBLBinding>,
    /**
     * XBL binding installed on the lement.
     */
    pub mXBLInsertionParent: nsCOMPtr<nsIContent>,
    /**
     * Web components custom element data.
     */
    pub mCustomElementData: RefPtr<CustomElementData>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FragmentOrElement_nsDOMSlots__bindgen_ty_bindgen_id_121135 {
    /**
      * The nearest enclosing content node with a binding that created us.
      * @see FragmentOrElement::GetBindingParent
      */
    pub mBindingParent: __BindgenUnionField<*mut nsIContent>,
    /**
      * The controllers of the XUL Element.
      */
    pub mControllers: __BindgenUnionField<*mut nsIControllers>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_FragmentOrElement_nsDOMSlots__bindgen_ty_bindgen_id_121135() {
    assert_eq!(::std::mem::size_of::<FragmentOrElement_nsDOMSlots__bindgen_ty_bindgen_id_121135>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<FragmentOrElement_nsDOMSlots__bindgen_ty_bindgen_id_121135>()
               , 8usize);
}
impl Clone for FragmentOrElement_nsDOMSlots__bindgen_ty_bindgen_id_121135 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_FragmentOrElement_nsDOMSlots() {
    assert_eq!(::std::mem::size_of::<FragmentOrElement_nsDOMSlots>() ,
               168usize);
    assert_eq!(::std::mem::align_of::<FragmentOrElement_nsDOMSlots>() ,
               8usize);
}
extern "C" {
    #[link_name =
          "_ZN7mozilla3dom17FragmentOrElement21_cycleCollectorGlobalE"]
    pub static mut FragmentOrElement__cycleCollectorGlobal:
               FragmentOrElement_cycleCollection;
}
#[test]
fn bindgen_test_layout_FragmentOrElement() {
    assert_eq!(::std::mem::size_of::<FragmentOrElement>() , 128usize);
    assert_eq!(::std::mem::align_of::<FragmentOrElement>() , 8usize);
}
pub const ReferrerPolicy_RP_Default: ReferrerPolicy =
    ReferrerPolicy::RP_No_Referrer_When_Downgrade;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ReferrerPolicy {
    RP_No_Referrer = 1,
    RP_Origin = 2,
    RP_No_Referrer_When_Downgrade = 0,
    RP_Origin_When_Crossorigin = 3,
    RP_Unsafe_URL = 4,
    RP_Same_Origin = 5,
    RP_Strict_Origin = 6,
    RP_Strict_Origin_When_Cross_Origin = 7,
    RP_Unset = 4294967295,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIWeakReference {
    pub _base: nsISupports,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsIWeakReference_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsIWeakReference() {
    assert_eq!(::std::mem::size_of::<nsIWeakReference>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsIWeakReference>() , 8usize);
}
impl Clone for nsIWeakReference {
    fn clone(&self) -> Self { *self }
}
pub type nsWeakPtr = nsCOMPtr<nsIWeakReference>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PrefSetting {
    pub _address: u8,
}
impl Clone for PrefSetting {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __bit_const_reference<_Cp> {
    pub __seg_: __bit_const_reference___storage_pointer<_Cp>,
    pub __mask_: __bit_const_reference___storage_type<_Cp>,
}
pub type __bit_const_reference___storage_type<_Cp> = _Cp;
pub type __bit_const_reference___storage_pointer<_Cp> = _Cp;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIChannel {
    pub _base: nsIRequest,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsIChannel_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIChannel__bindgen_ty_bindgen_id_138644 {
    LOAD_DOCUMENT_URI = 65536,
    LOAD_RETARGETED_DOCUMENT_URI = 131072,
    LOAD_REPLACE = 262144,
    LOAD_INITIAL_DOCUMENT_URI = 524288,
    LOAD_TARGETED = 1048576,
    LOAD_CALL_CONTENT_SNIFFERS = 2097152,
    LOAD_CLASSIFY_URI = 4194304,
    LOAD_MEDIA_SNIFFER_OVERRIDES_CONTENT_TYPE = 8388608,
    LOAD_EXPLICIT_CREDENTIALS = 16777216,
    LOAD_BYPASS_SERVICE_WORKER = 33554432,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIChannel__bindgen_ty_bindgen_id_138664 {
    DISPOSITION_INLINE = 0,
    DISPOSITION_ATTACHMENT = 1,
}
#[test]
fn bindgen_test_layout_nsIChannel() {
    assert_eq!(::std::mem::size_of::<nsIChannel>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsIChannel>() , 8usize);
}
impl Clone for nsIChannel {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIRequest {
    pub _base: nsISupports,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsIRequest_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIRequest__bindgen_ty_bindgen_id_138482 {
    LOAD_REQUESTMASK = 65535,
    LOAD_NORMAL = 0,
    LOAD_BACKGROUND = 1,
    INHIBIT_PIPELINE = 64,
    INHIBIT_CACHING = 128,
    INHIBIT_PERSISTENT_CACHING = 256,
    LOAD_BYPASS_CACHE = 512,
    LOAD_FROM_CACHE = 1024,
    VALIDATE_ALWAYS = 2048,
    VALIDATE_NEVER = 4096,
    VALIDATE_ONCE_PER_SESSION = 8192,
    LOAD_ANONYMOUS = 16384,
    LOAD_FRESH_CONNECTION = 32768,
}
#[test]
fn bindgen_test_layout_nsIRequest() {
    assert_eq!(::std::mem::size_of::<nsIRequest>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsIRequest>() , 8usize);
}
impl Clone for nsIRequest {
    fn clone(&self) -> Self { *self }
}
pub type nsLoadFlags = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsILoadGroup {
    pub _base: nsIRequest,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsILoadGroup_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsILoadGroup() {
    assert_eq!(::std::mem::size_of::<nsILoadGroup>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsILoadGroup>() , 8usize);
}
impl Clone for nsILoadGroup {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCOMArray_base {
    pub mArray: nsTArray<*mut nsISupports>,
}
pub type nsCOMArray_base_nsBaseArrayEnumFunc =
    ::std::option::Option<unsafe extern "C" fn(aElement:
                                                   *mut ::std::os::raw::c_void,
                                               aData:
                                                   *mut ::std::os::raw::c_void)
                              -> bool>;
pub type nsCOMArray_base_nsBaseArrayComparatorFunc =
    ::std::option::Option<unsafe extern "C" fn(aElement1: *mut nsISupports,
                                               aElement2: *mut nsISupports,
                                               aData:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsCOMArray_base_nsCOMArrayComparatorContext {
    pub mComparatorFunc: nsCOMArray_base_nsBaseArrayComparatorFunc,
    pub mData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_nsCOMArray_base_nsCOMArrayComparatorContext() {
    assert_eq!(::std::mem::size_of::<nsCOMArray_base_nsCOMArrayComparatorContext>()
               , 16usize);
    assert_eq!(::std::mem::align_of::<nsCOMArray_base_nsCOMArrayComparatorContext>()
               , 8usize);
}
impl Clone for nsCOMArray_base_nsCOMArrayComparatorContext {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsCOMArray_base() {
    assert_eq!(::std::mem::size_of::<nsCOMArray_base>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsCOMArray_base>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCOMArray<T> {
    pub _base: nsCOMArray_base,
    pub _phantom_0: ::std::marker::PhantomData<T>,
}
pub type nsCOMArray_nsCOMArrayEnumFunc<T> =
    ::std::option::Option<unsafe extern "C" fn(aElement: *mut T,
                                               aData:
                                                   *mut ::std::os::raw::c_void)
                              -> bool>;
pub type nsCOMArray_nsCOMArrayComparatorFunc<T> =
    ::std::option::Option<unsafe extern "C" fn(aElement1: *mut T,
                                               aElement2: *mut T,
                                               aData:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
#[repr(u32)]
/**
 * Enum defining the mode in which a sheet is to be parsed.  This is
 * usually, but not always, the same as the cascade level at which the
 * sheet will apply (see nsStyleSet.h).  Most of the Loader APIs only
 * support loading of author sheets.
 *
 * Author sheets are the normal case: styles embedded in or linked
 * from HTML pages.  They are also the most restricted.
 *
 * User sheets can do anything author sheets can do, and also get
 * access to a few CSS extensions that are not yet suitable for
 * exposure on the public Web, but are very useful for expressing
 * user style overrides, such as @-moz-document rules.
 *
 * Agent sheets have access to all author- and user-sheet features
 * plus more extensions that are necessary for internal use but,
 * again, not yet suitable for exposure on the public Web.  Some of
 * these are outright unsafe to expose; in particular, incorrect
 * styling of anonymous box pseudo-elements can violate layout
 * invariants.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SheetParsingMode {
    eAuthorSheetFeatures = 0,
    eUserSheetFeatures = 1,
    eAgentSheetFeatures = 2,
}
/**
 * Superclass for data common to CSSStyleSheet and ServoStyleSheet.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct StyleSheet {
    pub mDocument: *mut nsIDocument,
    pub mOwningNode: *mut nsINode,
    pub mParsingMode: SheetParsingMode,
    pub mType: StyleBackendType,
    pub mDisabled: bool,
}
#[test]
fn bindgen_test_layout_StyleSheet() {
    assert_eq!(::std::mem::size_of::<StyleSheet>() , 32usize);
    assert_eq!(::std::mem::align_of::<StyleSheet>() , 8usize);
}
impl Clone for StyleSheet {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct nsAttrValue {
    pub mBits: usize,
}
pub type nsAttrValue_AtomArray = nsTArray<nsCOMPtr<nsIAtom>>;
pub const nsAttrValue_ValueType_eSVGTypesBegin: nsAttrValue_ValueType =
    nsAttrValue_ValueType::eSVGAngle;
pub const nsAttrValue_ValueType_eSVGTypesEnd: nsAttrValue_ValueType =
    nsAttrValue_ValueType::eSVGViewBox;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsAttrValue_ValueType {
    eString = 0,
    eAtom = 2,
    eInteger = 3,
    eColor = 7,
    eEnum = 11,
    ePercent = 15,
    eGeckoCSSDeclaration = 16,
    eServoCSSDeclaration = 17,
    eURL = 18,
    eImage = 19,
    eAtomArray = 20,
    eDoubleValue = 21,
    eIntMarginValue = 22,
    eSVGAngle = 23,
    eSVGIntegerPair = 24,
    eSVGLength = 25,
    eSVGLengthList = 26,
    eSVGNumberList = 27,
    eSVGNumberPair = 28,
    eSVGPathData = 29,
    eSVGPointList = 30,
    eSVGPreserveAspectRatio = 31,
    eSVGStringList = 32,
    eSVGTransformList = 33,
    eSVGViewBox = 34,
}
/**
   * Structure for a mapping from int (enum) values to strings.  When you use
   * it you generally create an array of them.
   * Instantiate like this:
   * EnumTable myTable[] = {
   *   { "string1", 1 },
   *   { "string2", 2 },
   *   { nullptr, 0 }
   * }
   */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsAttrValue_EnumTable {
    /** The string the value maps to */
    pub tag: *const ::std::os::raw::c_char,
    /** The enum value that maps to this string */
    pub value: i16,
}
#[test]
fn bindgen_test_layout_nsAttrValue_EnumTable() {
    assert_eq!(::std::mem::size_of::<nsAttrValue_EnumTable>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsAttrValue_EnumTable>() , 8usize);
}
impl Clone for nsAttrValue_EnumTable {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsAttrValue_ValueBaseType {
    eStringBase = 0,
    eOtherBase = 1,
    eAtomBase = 2,
    eIntegerBase = 3,
}
extern "C" {
    #[link_name = "_ZN11nsAttrValue15sEnumTableArrayE"]
    pub static mut nsAttrValue_sEnumTableArray:
               *mut nsTArray<*const nsAttrValue_EnumTable>;
}
#[test]
fn bindgen_test_layout_nsAttrValue() {
    assert_eq!(::std::mem::size_of::<nsAttrValue>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsAttrValue>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsNodeInfoManager {
    pub mRefCnt: nsCycleCollectingAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    pub mNodeInfoHash: *mut PLHashTable,
    pub mDocument: *mut nsIDocument,
    pub mNonDocumentNodeInfos: u32,
    pub mPrincipal: nsCOMPtr<nsIPrincipal>,
    pub mDefaultPrincipal: nsCOMPtr<nsIPrincipal>,
    pub mTextNodeInfo: *mut NodeInfo,
    pub mCommentNodeInfo: *mut NodeInfo,
    pub mDocumentNodeInfo: *mut NodeInfo,
    pub mBindingManager: RefPtr<nsBindingManager>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsNodeInfoManager_cycleCollection {
    pub _base: nsCycleCollectionParticipant,
}
#[test]
fn bindgen_test_layout_nsNodeInfoManager_cycleCollection() {
    assert_eq!(::std::mem::size_of::<nsNodeInfoManager_cycleCollection>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<nsNodeInfoManager_cycleCollection>() ,
               8usize);
}
impl Clone for nsNodeInfoManager_cycleCollection {
    fn clone(&self) -> Self { *self }
}
pub type nsNodeInfoManager_HasThreadSafeRefCnt = FalseType;
extern "C" {
    #[link_name = "_ZN17nsNodeInfoManager21_cycleCollectorGlobalE"]
    pub static mut nsNodeInfoManager__cycleCollectorGlobal:
               nsNodeInfoManager_cycleCollection;
}
#[test]
fn bindgen_test_layout_nsNodeInfoManager() {
    assert_eq!(::std::mem::size_of::<nsNodeInfoManager>() , 88usize);
    assert_eq!(::std::mem::align_of::<nsNodeInfoManager>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct NodeInfo {
    pub mRefCnt: nsCycleCollectingAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    pub mDocument: *mut nsIDocument,
    pub mInner: NodeInfo_NodeInfoInner,
    pub mOwnerManager: RefPtr<nsNodeInfoManager>,
    pub mQualifiedName: nsString,
    pub mNodeName: nsString,
    pub mLocalName: nsString,
}
pub type NodeInfo_HasThreadSafeRefCnt = FalseType;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct NodeInfo_cycleCollection {
    pub _base: nsCycleCollectionParticipant,
}
#[test]
fn bindgen_test_layout_NodeInfo_cycleCollection() {
    assert_eq!(::std::mem::size_of::<NodeInfo_cycleCollection>() , 16usize);
    assert_eq!(::std::mem::align_of::<NodeInfo_cycleCollection>() , 8usize);
}
impl Clone for NodeInfo_cycleCollection {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct NodeInfo_NodeInfoInner {
    pub mName: nsCOMPtr<nsIAtom>,
    pub mPrefix: nsCOMPtr<nsIAtom>,
    pub mNamespaceID: i32,
    pub mNodeType: u16,
    pub mNameString: *const nsAString_internal,
    pub mExtraName: nsCOMPtr<nsIAtom>,
}
#[test]
fn bindgen_test_layout_NodeInfo_NodeInfoInner() {
    assert_eq!(::std::mem::size_of::<NodeInfo_NodeInfoInner>() , 40usize);
    assert_eq!(::std::mem::align_of::<NodeInfo_NodeInfoInner>() , 8usize);
}
extern "C" {
    #[link_name = "_ZN7mozilla3dom8NodeInfo21_cycleCollectorGlobalE"]
    pub static mut NodeInfo__cycleCollectorGlobal: NodeInfo_cycleCollection;
}
#[test]
fn bindgen_test_layout_NodeInfo() {
    assert_eq!(::std::mem::size_of::<NodeInfo>() , 120usize);
    assert_eq!(::std::mem::align_of::<NodeInfo>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsBindingManager {
    pub _address: u8,
}
impl Clone for nsBindingManager {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIFrame {
    pub _address: u8,
}
impl Clone for nsIFrame {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct nsPropertyTable {
    pub mPropertyList: *mut nsPropertyTable_PropertyList,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsPropertyTable_PropertyList {
    pub _address: u8,
}
impl Clone for nsPropertyTable_PropertyList {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsPropertyTable() {
    assert_eq!(::std::mem::size_of::<nsPropertyTable>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsPropertyTable>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsAttrAndChildArray {
    pub mImpl: *mut nsAttrAndChildArray_Impl,
}
pub type nsAttrAndChildArray_BorrowedAttrInfo = BorrowedAttrInfo;
#[repr(C)]
#[derive(Debug)]
pub struct nsAttrAndChildArray_InternalAttr {
    pub mName: nsAttrName,
    pub mValue: nsAttrValue,
}
#[test]
fn bindgen_test_layout_nsAttrAndChildArray_InternalAttr() {
    assert_eq!(::std::mem::size_of::<nsAttrAndChildArray_InternalAttr>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<nsAttrAndChildArray_InternalAttr>() ,
               8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsAttrAndChildArray_Impl {
    pub mAttrAndChildCount: u32,
    pub mBufferSize: u32,
    pub mMappedAttrs: *mut nsMappedAttributes,
    pub mBuffer: [*mut ::std::os::raw::c_void; 1usize],
}
#[test]
fn bindgen_test_layout_nsAttrAndChildArray_Impl() {
    assert_eq!(::std::mem::size_of::<nsAttrAndChildArray_Impl>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsAttrAndChildArray_Impl>() , 8usize);
}
impl Clone for nsAttrAndChildArray_Impl {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsAttrAndChildArray() {
    assert_eq!(::std::mem::size_of::<nsAttrAndChildArray>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsAttrAndChildArray>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsChildContentList {
    pub _address: u8,
}
impl Clone for nsChildContentList {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct nsDOMAttributeMap {
    pub _base: nsIDOMMozNamedAttrMap,
    pub _base_1: nsWrapperCache,
    pub mRefCnt: nsCycleCollectingAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    pub mContent: nsCOMPtr<Element>,
    /**
   * Cache of Attrs.
   */
    pub mAttributeCache: nsDOMAttributeMap_AttrCache,
}
pub type nsDOMAttributeMap_Attr = Attr;
pub type nsDOMAttributeMap_Element = Element;
pub type nsDOMAttributeMap_ErrorResult = ErrorResult;
pub type nsDOMAttributeMap_HasThreadSafeRefCnt = FalseType;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsDOMAttributeMap_cycleCollection {
    pub _base: nsXPCOMCycleCollectionParticipant,
}
#[test]
fn bindgen_test_layout_nsDOMAttributeMap_cycleCollection() {
    assert_eq!(::std::mem::size_of::<nsDOMAttributeMap_cycleCollection>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<nsDOMAttributeMap_cycleCollection>() ,
               8usize);
}
impl Clone for nsDOMAttributeMap_cycleCollection {
    fn clone(&self) -> Self { *self }
}
pub type nsDOMAttributeMap_AttrCache = [u64; 6usize];
extern "C" {
    #[link_name = "_ZN17nsDOMAttributeMap21_cycleCollectorGlobalE"]
    pub static mut nsDOMAttributeMap__cycleCollectorGlobal:
               nsDOMAttributeMap_cycleCollection;
}
#[test]
fn bindgen_test_layout_nsDOMAttributeMap() {
    assert_eq!(::std::mem::size_of::<nsDOMAttributeMap>() , 104usize);
    assert_eq!(::std::mem::align_of::<nsDOMAttributeMap>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIDOMMozNamedAttrMap {
    pub _base: nsISupports,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsIDOMMozNamedAttrMap_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsIDOMMozNamedAttrMap() {
    assert_eq!(::std::mem::size_of::<nsIDOMMozNamedAttrMap>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsIDOMMozNamedAttrMap>() , 8usize);
}
impl Clone for nsIDOMMozNamedAttrMap {
    fn clone(&self) -> Self { *self }
}
/**
 * Presentation shell interface. Presentation shells are the
 * controlling point for managing the presentation of a document. The
 * presentation shell holds a live reference to the document, the
 * presentation context, the style manager, the style set and the root
 * frame. <p>
 *
 * When this object is Release'd, it will release the document, the
 * presentation context, the style manager, the style set and the root
 * frame.
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsIPresShell {
    pub _base: nsISupports,
    pub mDocument: nsCOMPtr<nsIDocument>,
    pub mPresContext: RefPtr<nsPresContext>,
    pub mStyleSet: StyleSetHandle,
    pub mFrameConstructor: *mut nsCSSFrameConstructor,
    pub mViewManager: *mut nsViewManager,
    pub mFrameArena: nsPresArena,
    pub mSelection: RefPtr<nsFrameSelection>,
    pub mFrameManager: *mut nsFrameManagerBase,
    pub mForwardingContainer: u64,
    pub mHiddenInvalidationObserverRefreshDriver: *mut nsRefreshDriver,
    pub mDocAccessible: *mut DocAccessible,
    pub mReflowContinueTimer: nsCOMPtr<nsITimer>,
    pub mDrawEventTargetFrame: *mut nsIFrame,
    pub mAllocatedPointers: [u64; 6usize],
    pub mPaintCount: u64,
    pub mScrollPositionClampingScrollPortSize: nsSize,
    pub mWeakFrames: *mut nsWeakFrame,
    pub mCanvasBackgroundColor: nscolor,
    pub mResolution: [u64; 2usize],
    pub mSelectionFlags: i16,
    pub mRenderFlags: nsIPresShell_RenderFlags,
    pub _bitfield_1: u16,
    pub mPresShellId: u32,
    pub mChangedScopeStyleRoots: [u64; 3usize],
    pub mFontSizeInflationEmPerLine: u32,
    pub mFontSizeInflationMinTwips: u32,
    pub mFontSizeInflationLineThreshold: u32,
    pub mFontSizeInflationForceEnabled: bool,
    pub mFontSizeInflationDisabledInMasterProcess: bool,
    pub mFontSizeInflationEnabled: bool,
    pub mPaintingIsFrozen: bool,
    pub mFontSizeInflationEnabledIsDirty: bool,
    pub mIsNeverPainting: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsIPresShell_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
pub type nsIPresShell_LayerManager = LayerManager;
pub type nsIPresShell_SourceSurface = SourceSurface;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIPresShell_eRenderFlag {
    STATE_IGNORING_VIEWPORT_SCROLLING = 1,
    STATE_DRAWWINDOW_NOT_FLUSHING = 2,
}
pub type nsIPresShell_RenderFlags = u8;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIPresShell_ScrollDirection {
    eHorizontal = 0,
    eVertical = 1,
    eEither = 2,
}
#[repr(u32)]
/**
   * Tell the pres shell that a frame needs to be marked dirty and needs
   * Reflow.  It's OK if this is an ancestor of the frame needing reflow as
   * long as the ancestor chain between them doesn't cross a reflow root.
   *
   * The bit to add should be NS_FRAME_IS_DIRTY, NS_FRAME_HAS_DIRTY_CHILDREN
   * or nsFrameState(0); passing 0 means that dirty bits won't be set on the
   * frame or its ancestors/descendants, but that intrinsic widths will still
   * be marked dirty.  Passing aIntrinsicDirty = eResize and aBitToAdd = 0
   * would result in no work being done, so don't do that.
   */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIPresShell_IntrinsicDirty {
    eResize = 0,
    eTreeChange = 1,
    eStyleChange = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIPresShell_ReflowRootHandling {
    ePositionOrSizeChange = 0,
    eNoPositionOrSizeChange = 1,
    eInferFromBitToAdd = 2,
}
pub const SCROLL_LEFT: nsIPresShell__bindgen_ty_bindgen_id_156907 =
    nsIPresShell__bindgen_ty_bindgen_id_156907::SCROLL_TOP;
pub const SCROLL_RIGHT: nsIPresShell__bindgen_ty_bindgen_id_156907 =
    nsIPresShell__bindgen_ty_bindgen_id_156907::SCROLL_BOTTOM;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIPresShell__bindgen_ty_bindgen_id_156907 {
    SCROLL_TOP = 0,
    SCROLL_BOTTOM = 100,
    SCROLL_CENTER = 50,
    SCROLL_MINIMUM = -1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIPresShell_WhenToScroll {
    SCROLL_ALWAYS = 0,
    SCROLL_IF_NOT_VISIBLE = 1,
    SCROLL_IF_NOT_FULLY_VISIBLE = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIPresShell_ScrollAxis {
    pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout_nsIPresShell_ScrollAxis() {
    assert_eq!(::std::mem::size_of::<nsIPresShell_ScrollAxis>() , 4usize);
    assert_eq!(::std::mem::align_of::<nsIPresShell_ScrollAxis>() , 4usize);
}
impl Clone for nsIPresShell_ScrollAxis {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIPresShell__bindgen_ty_bindgen_id_156938 {
    SCROLL_FIRST_ANCESTOR_ONLY = 1,
    SCROLL_OVERFLOW_HIDDEN = 2,
    SCROLL_NO_PARENT_FRAMES = 4,
    SCROLL_SMOOTH = 8,
    SCROLL_SMOOTH_AUTO = 16,
}
#[repr(u32)]
/**
   * Render the document into an arbitrary gfxContext
   * Designed for getting a picture of a document or a piece of a document
   * Note that callers will generally want to call FlushPendingNotifications
   * to get an up-to-date view of the document
   * @param aRect is the region to capture into the offscreen buffer, in the
   * root frame's coordinate system (if aIgnoreViewportScrolling is false)
   * or in the root scrolled frame's coordinate system
   * (if aIgnoreViewportScrolling is true). The coordinates are in appunits.
   * @param aFlags see below;
   *   set RENDER_IS_UNTRUSTED if the contents may be passed to malicious
   * agents. E.g. we might choose not to paint the contents of sensitive widgets
   * such as the file name in a file upload widget, and we might choose not
   * to paint themes.
   *   set RENDER_IGNORE_VIEWPORT_SCROLLING to ignore
   * clipping and scrollbar painting due to scrolling in the viewport
   *   set RENDER_CARET to draw the caret if one would be visible
   * (by default the caret is never drawn)
   *   set RENDER_USE_LAYER_MANAGER to force rendering to go through
   * the layer manager for the window. This may be unexpectedly slow
   * (if the layer manager must read back data from the GPU) or low-quality
   * (if the layer manager reads back pixel data and scales it
   * instead of rendering using the appropriate scaling). It may also
   * slow everything down if the area rendered does not correspond to the
   * normal visible area of the window.
   *   set RENDER_ASYNC_DECODE_IMAGES to avoid having images synchronously
   * decoded during rendering.
   * (by default images decode synchronously with RenderDocument)
   *   set RENDER_DOCUMENT_RELATIVE to render the document as if there has been
   * no scrolling and interpret |aRect| relative to the document instead of the
   * CSS viewport. Only considered if RENDER_IGNORE_VIEWPORT_SCROLLING is set
   * or the document is in ignore viewport scrolling mode
   * (nsIPresShell::SetIgnoreViewportScrolling/IgnoringViewportScrolling).
   * @param aBackgroundColor a background color to render onto
   * @param aRenderedContext the gfxContext to render to. We render so that
   * one CSS pixel in the source document is rendered to one unit in the current
   * transform.
   */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIPresShell__bindgen_ty_bindgen_id_157393 {
    RENDER_IS_UNTRUSTED = 1,
    RENDER_IGNORE_VIEWPORT_SCROLLING = 2,
    RENDER_CARET = 4,
    RENDER_USE_WIDGET_LAYERS = 8,
    RENDER_ASYNC_DECODE_IMAGES = 16,
    RENDER_DOCUMENT_RELATIVE = 32,
    RENDER_DRAWWINDOW_NOT_FLUSHING = 64,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIPresShell__bindgen_ty_bindgen_id_157411 {
    RENDER_IS_IMAGE = 256,
    RENDER_AUTO_SCALE = 128,
}
#[repr(u32)]
/**
   * Add a solid color item to the bottom of aList with frame aFrame and bounds
   * aBounds. Checks first if this needs to be done by checking if aFrame is a
   * canvas frame (if the FORCE_DRAW flag is passed then this check is skipped).
   * aBackstopColor is composed behind the background color of the canvas, it is
   * transparent by default.
   */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIPresShell__bindgen_ty_bindgen_id_157534 { FORCE_DRAW = 1, }
#[repr(C)]
#[derive(Debug)]
pub struct nsIPresShell_PointerCaptureInfo {
    pub mPendingContent: nsCOMPtr<nsIContent>,
    pub mOverrideContent: nsCOMPtr<nsIContent>,
    pub mPrimaryState: bool,
}
#[test]
fn bindgen_test_layout_nsIPresShell_PointerCaptureInfo() {
    assert_eq!(::std::mem::size_of::<nsIPresShell_PointerCaptureInfo>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<nsIPresShell_PointerCaptureInfo>() ,
               8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIPresShell_PointerInfo {
    pub mActiveState: bool,
    pub mPointerType: u16,
    pub mPrimaryState: bool,
}
#[test]
fn bindgen_test_layout_nsIPresShell_PointerInfo() {
    assert_eq!(::std::mem::size_of::<nsIPresShell_PointerInfo>() , 6usize);
    assert_eq!(::std::mem::align_of::<nsIPresShell_PointerInfo>() , 2usize);
}
impl Clone for nsIPresShell_PointerInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIPresShell_PaintFlags {
    PAINT_LAYERS = 1,
    PAINT_COMPOSITE = 2,
    PAINT_SYNC_DECODE_IMAGES = 4,
}
#[repr(u32)]
/**
   * Ensures that the refresh driver is running, and schedules a view
   * manager flush on the next tick.
   *
   * @param aType PAINT_DELAYED_COMPRESS : Schedule a paint to be executed after a delay, and
   * put FrameLayerBuilder in 'compressed' mode that avoids short cut optimizations.
   */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsIPresShell_PaintType {
    PAINT_DEFAULT = 0,
    PAINT_DELAYED_COMPRESS = 1,
}
extern "C" {
    #[link_name = "_ZN12nsIPresShell12gCaptureInfoE"]
    pub static mut nsIPresShell_gCaptureInfo: CapturingContentInfo;
}
extern "C" {
    #[link_name = "_ZN12nsIPresShell19gPointerCaptureListE"]
    pub static mut nsIPresShell_gPointerCaptureList: *mut [u64; 6usize];
}
extern "C" {
    #[link_name = "_ZN12nsIPresShell18gActivePointersIdsE"]
    pub static mut nsIPresShell_gActivePointersIds: *mut ();
}
extern "C" {
    #[link_name = "_ZN12nsIPresShell14gKeyDownTargetE"]
    pub static mut nsIPresShell_gKeyDownTarget: *mut nsIContent;
}
#[test]
fn bindgen_test_layout_nsIPresShell() {
    assert_eq!(::std::mem::size_of::<nsIPresShell>() , 416usize);
    assert_eq!(::std::mem::align_of::<nsIPresShell>() , 8usize);
}
impl nsIPresShell {
    #[inline]
    pub fn mStylesHaveChanged(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                       0u32) as u8)
        }
    }
    #[inline]
    pub fn set_mStylesHaveChanged(&mut self, val: bool) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u8 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn mDidInitialize(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                       1u32) as u8)
        }
    }
    #[inline]
    pub fn set_mDidInitialize(&mut self, val: bool) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u8 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn mIsDestroying(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                       2u32) as u8)
        }
    }
    #[inline]
    pub fn set_mIsDestroying(&mut self, val: bool) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u8 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn mIsZombie(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                       3u32) as u8)
        }
    }
    #[inline]
    pub fn set_mIsZombie(&mut self, val: bool) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u8 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn mIsReflowing(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                       4u32) as u8)
        }
    }
    #[inline]
    pub fn set_mIsReflowing(&mut self, val: bool) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u8 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn mPaintingSuppressed(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                       5u32) as u8)
        }
    }
    #[inline]
    pub fn set_mPaintingSuppressed(&mut self, val: bool) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u8 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn mIsThemeSupportDisabled(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u16)) >>
                                       6u32) as u8)
        }
    }
    #[inline]
    pub fn set_mIsThemeSupportDisabled(&mut self, val: bool) {
        self._bitfield_1 &= !(64usize as u16);
        self._bitfield_1 |= ((val as u8 as u16) << 6u32) & (64usize as u16);
    }
    #[inline]
    pub fn mIsActive(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u16)) >>
                                       7u32) as u8)
        }
    }
    #[inline]
    pub fn set_mIsActive(&mut self, val: bool) {
        self._bitfield_1 &= !(128usize as u16);
        self._bitfield_1 |= ((val as u8 as u16) << 7u32) & (128usize as u16);
    }
    #[inline]
    pub fn mFrozen(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (256usize as u16)) >>
                                       8u32) as u8)
        }
    }
    #[inline]
    pub fn set_mFrozen(&mut self, val: bool) {
        self._bitfield_1 &= !(256usize as u16);
        self._bitfield_1 |= ((val as u8 as u16) << 8u32) & (256usize as u16);
    }
    #[inline]
    pub fn mIsFirstPaint(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (512usize as u16)) >>
                                       9u32) as u8)
        }
    }
    #[inline]
    pub fn set_mIsFirstPaint(&mut self, val: bool) {
        self._bitfield_1 &= !(512usize as u16);
        self._bitfield_1 |= ((val as u8 as u16) << 9u32) & (512usize as u16);
    }
    #[inline]
    pub fn mObservesMutationsForPrint(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1024usize as u16)) >>
                                       10u32) as u8)
        }
    }
    #[inline]
    pub fn set_mObservesMutationsForPrint(&mut self, val: bool) {
        self._bitfield_1 &= !(1024usize as u16);
        self._bitfield_1 |=
            ((val as u8 as u16) << 10u32) & (1024usize as u16);
    }
    #[inline]
    pub fn mReflowScheduled(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2048usize as u16)) >>
                                       11u32) as u8)
        }
    }
    #[inline]
    pub fn set_mReflowScheduled(&mut self, val: bool) {
        self._bitfield_1 &= !(2048usize as u16);
        self._bitfield_1 |=
            ((val as u8 as u16) << 11u32) & (2048usize as u16);
    }
    #[inline]
    pub fn mSuppressInterruptibleReflows(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4096usize as u16)) >>
                                       12u32) as u8)
        }
    }
    #[inline]
    pub fn set_mSuppressInterruptibleReflows(&mut self, val: bool) {
        self._bitfield_1 &= !(4096usize as u16);
        self._bitfield_1 |=
            ((val as u8 as u16) << 12u32) & (4096usize as u16);
    }
    #[inline]
    pub fn mScrollPositionClampingScrollPortSizeSet(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8192usize as u16)) >>
                                       13u32) as u8)
        }
    }
    #[inline]
    pub fn set_mScrollPositionClampingScrollPortSizeSet(&mut self,
                                                        val: bool) {
        self._bitfield_1 &= !(8192usize as u16);
        self._bitfield_1 |=
            ((val as u8 as u16) << 13u32) & (8192usize as u16);
    }
}
/**
 * A class that implements nsIWeakReference
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsNodeWeakReference {
    pub _base: nsIWeakReference,
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    pub mNode: *mut nsINode,
}
pub type nsNodeWeakReference_HasThreadSafeRefCnt = FalseType;
#[test]
fn bindgen_test_layout_nsNodeWeakReference() {
    assert_eq!(::std::mem::size_of::<nsNodeWeakReference>() , 32usize);
    assert_eq!(::std::mem::align_of::<nsNodeWeakReference>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsDOMMutationObserver {
    pub _address: u8,
}
impl Clone for nsDOMMutationObserver {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BoxQuadOptions {
    pub _address: u8,
}
impl Clone for BoxQuadOptions {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ConvertCoordinateOptions {
    pub _address: u8,
}
impl Clone for ConvertCoordinateOptions {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DOMPoint {
    pub _address: u8,
}
impl Clone for DOMPoint {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DOMQuad {
    pub _address: u8,
}
impl Clone for DOMQuad {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct DOMRectReadOnly {
    pub _base: nsISupports,
    pub _base_1: nsWrapperCache,
    pub mRefCnt: nsCycleCollectingAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    pub mParent: nsCOMPtr<nsISupports>,
}
pub type DOMRectReadOnly_HasThreadSafeRefCnt = FalseType;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DOMRectReadOnly_cycleCollection {
    pub _base: nsXPCOMCycleCollectionParticipant,
}
#[test]
fn bindgen_test_layout_DOMRectReadOnly_cycleCollection() {
    assert_eq!(::std::mem::size_of::<DOMRectReadOnly_cycleCollection>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<DOMRectReadOnly_cycleCollection>() ,
               8usize);
}
impl Clone for DOMRectReadOnly_cycleCollection {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "_ZN7mozilla3dom15DOMRectReadOnly21_cycleCollectorGlobalE"]
    pub static mut DOMRectReadOnly__cycleCollectorGlobal:
               DOMRectReadOnly_cycleCollection;
}
#[test]
fn bindgen_test_layout_DOMRectReadOnly() {
    assert_eq!(::std::mem::size_of::<DOMRectReadOnly>() , 56usize);
    assert_eq!(::std::mem::align_of::<DOMRectReadOnly>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct OwningNodeOrString {
    pub mType: OwningNodeOrString_Type,
    pub mValue: OwningNodeOrString_Value,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OwningNodeOrString_Type {
    eUninitialized = 0,
    eNode = 1,
    eString = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OwningNodeOrString_Value {
    pub mNode: __BindgenUnionField<UnionMember<OwningNonNull<nsINode>>>,
    pub mString: __BindgenUnionField<UnionMember<nsString>>,
    pub bindgen_union_field: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_OwningNodeOrString_Value() {
    assert_eq!(::std::mem::size_of::<OwningNodeOrString_Value>() , 16usize);
    assert_eq!(::std::mem::align_of::<OwningNodeOrString_Value>() , 8usize);
}
impl Clone for OwningNodeOrString_Value {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_OwningNodeOrString() {
    assert_eq!(::std::mem::size_of::<OwningNodeOrString>() , 24usize);
    assert_eq!(::std::mem::align_of::<OwningNodeOrString>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TextOrElementOrDocument {
    pub _address: u8,
}
impl Clone for TextOrElementOrDocument {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DOMPointInit {
    pub _address: u8,
}
impl Clone for DOMPointInit {
    fn clone(&self) -> Self { *self }
}
pub const NODE_HAS_LISTENERMANAGER: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_HAS_LISTENERMANAGER;
pub const NODE_HAS_PROPERTIES: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_HAS_PROPERTIES;
pub const NODE_IS_ANONYMOUS_ROOT: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_IS_ANONYMOUS_ROOT;
pub const NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE;
pub const NODE_IS_NATIVE_ANONYMOUS_ROOT: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_IS_NATIVE_ANONYMOUS_ROOT;
pub const NODE_FORCE_XBL_BINDINGS: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_FORCE_XBL_BINDINGS;
pub const NODE_MAY_BE_IN_BINDING_MNGR: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_MAY_BE_IN_BINDING_MNGR;
pub const NODE_IS_EDITABLE: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_IS_EDITABLE;
pub const NODE_MAY_HAVE_CLASS: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_MAY_HAVE_CLASS;
pub const NODE_IS_IN_SHADOW_TREE: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_IS_IN_SHADOW_TREE;
pub const NODE_HAS_EMPTY_SELECTOR: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_HAS_EMPTY_SELECTOR;
pub const NODE_HAS_SLOW_SELECTOR: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_HAS_SLOW_SELECTOR;
pub const NODE_HAS_EDGE_CHILD_SELECTOR: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_HAS_EDGE_CHILD_SELECTOR;
pub const NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS: _bindgen_ty_bindgen_id_158955
          =
    _bindgen_ty_bindgen_id_158955::NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS;
pub const NODE_ALL_SELECTOR_FLAGS: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_ALL_SELECTOR_FLAGS;
pub const NODE_NEEDS_FRAME: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_NEEDS_FRAME;
pub const NODE_DESCENDANTS_NEED_FRAMES: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_DESCENDANTS_NEED_FRAMES;
pub const NODE_HAS_ACCESSKEY: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_HAS_ACCESSKEY;
pub const NODE_HAS_DIRECTION_RTL: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_HAS_DIRECTION_RTL;
pub const NODE_HAS_DIRECTION_LTR: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_HAS_DIRECTION_LTR;
pub const NODE_ALL_DIRECTION_FLAGS: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_ALL_DIRECTION_FLAGS;
pub const NODE_CHROME_ONLY_ACCESS: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_CHROME_ONLY_ACCESS;
pub const NODE_IS_ROOT_OF_CHROME_ONLY_ACCESS: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_IS_ROOT_OF_CHROME_ONLY_ACCESS;
pub const NODE_SHARED_RESTYLE_BIT_1: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_SHARED_RESTYLE_BIT_1;
pub const NODE_SHARED_RESTYLE_BIT_2: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_SHARED_RESTYLE_BIT_2;
pub const NODE_IS_DIRTY_FOR_SERVO: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_SHARED_RESTYLE_BIT_1;
pub const NODE_HAS_DIRTY_DESCENDANTS_FOR_SERVO: _bindgen_ty_bindgen_id_158955
          =
    _bindgen_ty_bindgen_id_158955::NODE_SHARED_RESTYLE_BIT_2;
pub const NODE_TYPE_SPECIFIC_BITS_OFFSET: _bindgen_ty_bindgen_id_158955 =
    _bindgen_ty_bindgen_id_158955::NODE_TYPE_SPECIFIC_BITS_OFFSET;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_bindgen_id_158955 {
    NODE_HAS_LISTENERMANAGER = 4,
    NODE_HAS_PROPERTIES = 8,
    NODE_IS_ANONYMOUS_ROOT = 16,
    NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE = 32,
    NODE_IS_NATIVE_ANONYMOUS_ROOT = 64,
    NODE_FORCE_XBL_BINDINGS = 128,
    NODE_MAY_BE_IN_BINDING_MNGR = 256,
    NODE_IS_EDITABLE = 512,
    NODE_MAY_HAVE_CLASS = 1024,
    NODE_IS_IN_SHADOW_TREE = 2048,
    NODE_HAS_EMPTY_SELECTOR = 4096,
    NODE_HAS_SLOW_SELECTOR = 8192,
    NODE_HAS_EDGE_CHILD_SELECTOR = 16384,
    NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS = 32768,
    NODE_ALL_SELECTOR_FLAGS = 61440,
    NODE_NEEDS_FRAME = 65536,
    NODE_DESCENDANTS_NEED_FRAMES = 131072,
    NODE_HAS_ACCESSKEY = 262144,
    NODE_HAS_DIRECTION_RTL = 524288,
    NODE_HAS_DIRECTION_LTR = 1048576,
    NODE_ALL_DIRECTION_FLAGS = 1572864,
    NODE_CHROME_ONLY_ACCESS = 2097152,
    NODE_IS_ROOT_OF_CHROME_ONLY_ACCESS = 4194304,
    NODE_SHARED_RESTYLE_BIT_1 = 8388608,
    NODE_SHARED_RESTYLE_BIT_2 = 16777216,
    NODE_TYPE_SPECIFIC_BITS_OFFSET = 23,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsContentList {
    pub _address: u8,
}
impl Clone for nsContentList {
    fn clone(&self) -> Self { *self }
}
/**
 * The signature of the timer callback function passed to initWithFuncCallback.
 * This is the function that will get called when the timer expires if the
 * timer is initialized via initWithFuncCallback.
 *
 * @param aTimer the timer which has expired
 * @param aClosure opaque parameter passed to initWithFuncCallback
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsITimer {
    pub _base: nsISupports,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsITimer_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsITimer__bindgen_ty_bindgen_id_175571 {
    TYPE_ONE_SHOT = 0,
    TYPE_REPEATING_SLACK = 1,
    TYPE_REPEATING_PRECISE = 2,
    TYPE_REPEATING_PRECISE_CAN_SKIP = 3,
}
#[test]
fn bindgen_test_layout_nsITimer() {
    assert_eq!(::std::mem::size_of::<nsITimer>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsITimer>() , 8usize);
}
impl Clone for nsITimer {
    fn clone(&self) -> Self { *self }
}
/**
 * Data used to track the expiration state of an object. We promise that this
 * is 32 bits so that objects that includes this as a field can pad and align
 * efficiently.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsExpirationState {
    pub _bitfield_1: u32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsExpirationState__bindgen_ty_bindgen_id_176047 {
    NOT_TRACKED = 15,
    MAX_INDEX_IN_GENERATION = 268435455,
}
#[test]
fn bindgen_test_layout_nsExpirationState() {
    assert_eq!(::std::mem::size_of::<nsExpirationState>() , 4usize);
    assert_eq!(::std::mem::align_of::<nsExpirationState>() , 4usize);
}
impl Clone for nsExpirationState {
    fn clone(&self) -> Self { *self }
}
impl nsExpirationState {
    #[inline]
    pub fn mGeneration(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (15usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_mGeneration(&mut self, val: u32) {
        self._bitfield_1 &= !(15usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (15usize as u32);
    }
    #[inline]
    pub fn mIndexInGeneration(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (4294967280usize as u32)) >> 4u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_mIndexInGeneration(&mut self, val: u32) {
        self._bitfield_1 &= !(4294967280usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 4u32) & (4294967280usize as u32);
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PRCListStr {
    pub next: *mut PRCList,
    pub prev: *mut PRCList,
}
#[test]
fn bindgen_test_layout_PRCListStr() {
    assert_eq!(::std::mem::size_of::<PRCListStr>() , 16usize);
    assert_eq!(::std::mem::align_of::<PRCListStr>() , 8usize);
}
impl Clone for PRCListStr {
    fn clone(&self) -> Self { *self }
}
pub type PRCList = PRCListStr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UnionMember<T> {
    pub mStorage: AlignedStorage2<T>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct imgIRequest {
    pub _base: nsIRequest,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imgIRequest_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum imgIRequest__bindgen_ty_bindgen_id_176631 {
    STATUS_NONE = 0,
    STATUS_SIZE_AVAILABLE = 1,
    STATUS_LOAD_COMPLETE = 2,
    STATUS_ERROR = 4,
    STATUS_FRAME_COMPLETE = 8,
    STATUS_DECODE_COMPLETE = 16,
    STATUS_IS_ANIMATED = 32,
    STATUS_HAS_TRANSPARENCY = 64,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum imgIRequest__bindgen_ty_bindgen_id_176711 {
    CORS_NONE = 1,
    CORS_ANONYMOUS = 2,
    CORS_USE_CREDENTIALS = 3,
}
#[test]
fn bindgen_test_layout_imgIRequest() {
    assert_eq!(::std::mem::size_of::<imgIRequest>() , 8usize);
    assert_eq!(::std::mem::align_of::<imgIRequest>() , 8usize);
}
impl Clone for imgIRequest {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsHTMLCSSStyleSheet {
    pub _address: u8,
}
impl Clone for nsHTMLCSSStyleSheet {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsHTMLStyleSheet {
    pub _address: u8,
}
impl Clone for nsHTMLStyleSheet {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIBFCacheEntry {
    pub _address: u8,
}
impl Clone for nsIBFCacheEntry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIDocumentEncoder {
    pub _address: u8,
}
impl Clone for nsIDocumentEncoder {
    fn clone(&self) -> Self { *self }
}
/**
 * An internal interface
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIHTMLCollection {
    pub _base: nsIDOMHTMLCollection,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsIHTMLCollection_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsIHTMLCollection() {
    assert_eq!(::std::mem::size_of::<nsIHTMLCollection>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsIHTMLCollection>() , 8usize);
}
impl Clone for nsIHTMLCollection {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIObjectLoadingContent {
    pub _address: u8,
}
impl Clone for nsIObjectLoadingContent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIStructuredCloneContainer {
    pub _address: u8,
}
impl Clone for nsIStructuredCloneContainer {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsViewManager {
    pub _address: u8,
}
impl Clone for nsViewManager {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsSMILAnimationController {
    pub _address: u8,
}
impl Clone for nsSMILAnimationController {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SVGAttrAnimationRuleProcessor {
    pub _address: u8,
}
impl Clone for SVGAttrAnimationRuleProcessor {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Loader {
    pub _address: u8,
}
impl Clone for Loader {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ImageLoader {
    pub _address: u8,
}
impl Clone for ImageLoader {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Animation {
    pub _address: u8,
}
impl Clone for Animation {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AnonymousContent {
    pub _address: u8,
}
impl Clone for AnonymousContent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct Attr {
    pub _base: nsIAttribute,
    pub _base_1: nsIDOMAttr,
    pub mRefCnt: nsCycleCollectingAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    pub mValue: nsString,
}
pub type Attr_HasThreadSafeRefCnt = FalseType;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Attr_cycleCollection {
    pub _base: nsXPCOMCycleCollectionParticipant,
}
#[test]
fn bindgen_test_layout_Attr_cycleCollection() {
    assert_eq!(::std::mem::size_of::<Attr_cycleCollection>() , 16usize);
    assert_eq!(::std::mem::align_of::<Attr_cycleCollection>() , 8usize);
}
impl Clone for Attr_cycleCollection {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "_ZN7mozilla3dom4Attr21_cycleCollectorGlobalE"]
    pub static mut Attr__cycleCollectorGlobal: Attr_cycleCollection;
}
extern "C" {
    #[link_name = "_ZN7mozilla3dom4Attr12sInitializedE"]
    pub static mut Attr_sInitialized: bool;
}
#[test]
fn bindgen_test_layout_Attr() {
    assert_eq!(::std::mem::size_of::<Attr>() , 152usize);
    assert_eq!(::std::mem::align_of::<Attr>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsIAttribute {
    pub _base: nsINode,
    pub mAttrMap: RefPtr<nsDOMAttributeMap>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsIAttribute_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsIAttribute() {
    assert_eq!(::std::mem::size_of::<nsIAttribute>() , 112usize);
    assert_eq!(::std::mem::align_of::<nsIAttribute>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FontFaceSet {
    pub _address: u8,
}
impl Clone for FontFaceSet {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct FrameRequestCallback {
    pub _base: CallbackFunction,
}
#[test]
fn bindgen_test_layout_FrameRequestCallback() {
    assert_eq!(::std::mem::size_of::<FrameRequestCallback>() , 56usize);
    assert_eq!(::std::mem::align_of::<FrameRequestCallback>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FullscreenRequest {
    pub _address: u8,
}
impl Clone for FullscreenRequest {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct UndoManager {
    pub _address: u8,
}
impl Clone for UndoManager {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct XPathEvaluator {
    pub _address: u8,
}
impl Clone for XPathEvaluator {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FillMode {
    None = 0,
    Forwards = 1,
    Backwards = 2,
    Both = 3,
    Auto = 4,
    EndGuard_ = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum PlaybackDirection {
    Normal = 0,
    Reverse = 1,
    Alternate = 2,
    Alternate_reverse = 3,
    EndGuard_ = 4,
}
#[repr(C)]
#[derive(Debug)]
pub struct nsAttrName {
    pub mBits: usize,
}
#[test]
fn bindgen_test_layout_nsAttrName() {
    assert_eq!(::std::mem::size_of::<nsAttrName>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsAttrName>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Declaration {
    pub _address: u8,
}
impl Clone for Declaration {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct URLValue {
    pub _base: URLValueData,
    pub mRefCnt: ThreadSafeAutoRefCnt,
}
pub type URLValue_HasThreadSafeRefCnt = TrueType;
#[test]
fn bindgen_test_layout_URLValue() {
    assert_eq!(::std::mem::size_of::<URLValue>() , 56usize);
    assert_eq!(::std::mem::align_of::<URLValue>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct URLValueData {
    pub mURI: nsMainThreadPtrHandle<nsIURI>,
    pub mBaseURI: nsMainThreadPtrHandle<nsIURI>,
    pub mString: RefPtr<nsStringBuffer>,
    pub mReferrer: nsMainThreadPtrHandle<nsIURI>,
    pub mOriginPrincipal: nsMainThreadPtrHandle<nsIPrincipal>,
    pub mURIResolved: bool,
    pub mLocalURLFlag: bool,
}
#[test]
fn bindgen_test_layout_URLValueData() {
    assert_eq!(::std::mem::size_of::<URLValueData>() , 48usize);
    assert_eq!(::std::mem::align_of::<URLValueData>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct ImageValue {
    pub _base: URLValueData,
    pub mRequests: [u64; 6usize],
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
}
pub type ImageValue_HasThreadSafeRefCnt = FalseType;
#[test]
fn bindgen_test_layout_ImageValue() {
    assert_eq!(::std::mem::size_of::<ImageValue>() , 112usize);
    assert_eq!(::std::mem::align_of::<ImageValue>() , 8usize);
}
/**
 * A structure representing a single attribute name and value.
 *
 * This is pretty similar to the private nsAttrAndChildArray::InternalAttr.
 */
#[repr(C)]
#[derive(Debug)]
pub struct ServoAttrSnapshot {
    pub mName: nsAttrName,
    pub mValue: nsAttrValue,
}
#[test]
fn bindgen_test_layout_ServoAttrSnapshot() {
    assert_eq!(::std::mem::size_of::<ServoAttrSnapshot>() , 16usize);
    assert_eq!(::std::mem::align_of::<ServoAttrSnapshot>() , 8usize);
}
#[repr(u8)]
/**
 * A bitflags enum class used to determine what data does a ServoElementSnapshot
 * contains.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ServoElementSnapshotFlags { State = 1, Attributes = 2, All = 3, }
/**
 * This class holds all non-tree-structural state of an element that might be
 * used for selector matching eventually.
 *
 * This means the attributes, and the element state, such as :hover, :active,
 * etc...
 */
#[repr(C)]
#[derive(Debug)]
pub struct ServoElementSnapshot {
    pub mContains: ServoElementSnapshot_Flags,
    pub mAttrs: nsTArray<ServoAttrSnapshot>,
    pub mState: ServoElementSnapshot_ServoStateType,
    pub mExplicitRestyleHint: nsRestyleHint,
    pub mExplicitChangeHint: nsChangeHint,
    pub mIsHTMLElementInHTMLDocument: bool,
    pub mIsInChromeDocument: bool,
}
pub type ServoElementSnapshot_BorrowedAttrInfo = BorrowedAttrInfo;
pub type ServoElementSnapshot_Element = Element;
pub type ServoElementSnapshot_ServoStateType = EventStates_ServoType;
pub type ServoElementSnapshot_Flags = ServoElementSnapshotFlags;
#[test]
fn bindgen_test_layout_ServoElementSnapshot() {
    assert_eq!(::std::mem::size_of::<ServoElementSnapshot>() , 32usize);
    assert_eq!(::std::mem::align_of::<ServoElementSnapshot>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsMappedAttributes {
    pub _address: u8,
}
impl Clone for nsMappedAttributes {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsXBLBinding {
    pub _address: u8,
}
impl Clone for nsXBLBinding {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ShadowRoot {
    pub _address: u8,
}
impl Clone for ShadowRoot {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CustomElementData {
    pub _address: u8,
}
impl Clone for CustomElementData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct IMEState {
    pub _address: u8,
}
impl Clone for IMEState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsDOMTokenList {
    pub _address: u8,
}
impl Clone for nsDOMTokenList {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsDOMStringMap {
    pub _address: u8,
}
impl Clone for nsDOMStringMap {
    fn clone(&self) -> Self { *self }
}
/**
 * Interface used for handling clicks on links
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsILinkHandler {
    pub _base: nsISupports,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsILinkHandler_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsILinkHandler() {
    assert_eq!(::std::mem::size_of::<nsILinkHandler>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsILinkHandler>() , 8usize);
}
impl Clone for nsILinkHandler {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleContext {
    pub _address: u8,
}
impl Clone for nsStyleContext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct nsFrameManagerBase {
    pub mPresShell: *mut nsIPresShell,
    pub mRootFrame: *mut nsIFrame,
    pub mPlaceholderMap: PLDHashTable,
    pub mUndisplayedMap: *mut nsFrameManagerBase_UndisplayedMap,
    pub mDisplayContentsMap: *mut nsFrameManagerBase_UndisplayedMap,
    pub mIsDestroyingFrames: bool,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsFrameManagerBase_UndisplayedMap {
    pub _address: u8,
}
impl Clone for nsFrameManagerBase_UndisplayedMap {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "_ZN18nsFrameManagerBase23sGlobalGenerationNumberE"]
    pub static mut nsFrameManagerBase_sGlobalGenerationNumber: u32;
}
#[test]
fn bindgen_test_layout_nsFrameManagerBase() {
    assert_eq!(::std::mem::size_of::<nsFrameManagerBase>() , 88usize);
    assert_eq!(::std::mem::align_of::<nsFrameManagerBase>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsPresArena {
    pub mFreeLists: [u64; 6usize],
    pub mPool: [u64; 7usize],
    pub mArenaRefPtrs: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct nsPresArena_FreeList {
    pub _base: PLDHashEntryHdr,
    pub mEntries: nsTArray<*mut ::std::os::raw::c_void>,
    pub mEntrySize: usize,
    pub mEntriesEverAllocated: usize,
    pub mKey: nsPresArena_FreeList_KeyTypePointer,
}
pub type nsPresArena_FreeList_KeyType = u32;
pub type nsPresArena_FreeList_KeyTypePointer = *const ::std::os::raw::c_void;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsPresArena_FreeList__bindgen_ty_bindgen_id_197183 {
    ALLOW_MEMMOVE = 0,
}
#[test]
fn bindgen_test_layout_nsPresArena_FreeList() {
    assert_eq!(::std::mem::size_of::<nsPresArena_FreeList>() , 40usize);
    assert_eq!(::std::mem::align_of::<nsPresArena_FreeList>() , 8usize);
}
#[test]
fn bindgen_test_layout_nsPresArena() {
    assert_eq!(::std::mem::size_of::<nsPresArena>() , 152usize);
    assert_eq!(::std::mem::align_of::<nsPresArena>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct imgINotificationObserver {
    pub _base: nsISupports,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imgINotificationObserver_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum imgINotificationObserver__bindgen_ty_bindgen_id_197330 {
    SIZE_AVAILABLE = 1,
    FRAME_UPDATE = 2,
    FRAME_COMPLETE = 3,
    LOAD_COMPLETE = 4,
    DECODE_COMPLETE = 5,
    DISCARD = 6,
    UNLOCKED_DRAW = 7,
    IS_ANIMATED = 8,
    HAS_TRANSPARENCY = 9,
}
#[test]
fn bindgen_test_layout_imgINotificationObserver() {
    assert_eq!(::std::mem::size_of::<imgINotificationObserver>() , 8usize);
    assert_eq!(::std::mem::align_of::<imgINotificationObserver>() , 8usize);
}
impl Clone for imgINotificationObserver {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsFrameSelection {
    pub _address: u8,
}
impl Clone for nsFrameSelection {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsCSSFrameConstructor {
    pub _address: u8,
}
impl Clone for nsCSSFrameConstructor {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsWeakFrame {
    pub _address: u8,
}
impl Clone for nsWeakFrame {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct ScrollbarStyles {
    pub mHorizontal: u8,
    pub mVertical: u8,
    pub mScrollBehavior: u8,
    pub mScrollSnapTypeX: u8,
    pub mScrollSnapTypeY: u8,
    pub mScrollSnapPointsX: nsStyleCoord,
    pub mScrollSnapPointsY: nsStyleCoord,
    pub mScrollSnapDestinationX: nsStyleCoord_CalcValue,
    pub mScrollSnapDestinationY: nsStyleCoord_CalcValue,
}
#[test]
fn bindgen_test_layout_ScrollbarStyles() {
    assert_eq!(::std::mem::size_of::<ScrollbarStyles>() , 64usize);
    assert_eq!(::std::mem::align_of::<ScrollbarStyles>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsRefreshDriver {
    pub _address: u8,
}
impl Clone for nsRefreshDriver {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DocAccessible {
    pub _address: u8,
}
impl Clone for DocAccessible {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LayerManager {
    pub _address: u8,
}
impl Clone for LayerManager {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SourceSurface {
    pub _address: u8,
}
impl Clone for SourceSurface {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct CapturingContentInfo {
    pub mAllowed: bool,
    pub mPointerLock: bool,
    pub mRetargetToElement: bool,
    pub mPreventDrag: bool,
    pub mContent: StaticRefPtr<nsIContent>,
}
#[test]
fn bindgen_test_layout_CapturingContentInfo() {
    assert_eq!(::std::mem::size_of::<CapturingContentInfo>() , 16usize);
    assert_eq!(::std::mem::align_of::<CapturingContentInfo>() , 8usize);
}
pub const FontFamilyType_eFamily_generic_first: FontFamilyType =
    FontFamilyType::eFamily_serif;
pub const FontFamilyType_eFamily_generic_last: FontFamilyType =
    FontFamilyType::eFamily_fantasy;
pub const FontFamilyType_eFamily_generic_count: FontFamilyType =
    FontFamilyType::eFamily_monospace;
#[repr(u32)]
/**
 * type of font family name, either a name (e.g. Helvetica) or a
 * generic (e.g. serif, sans-serif), with the ability to distinguish
 * between unquoted and quoted names for serializaiton
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FontFamilyType {
    eFamily_none = 0,
    eFamily_named = 1,
    eFamily_named_quoted = 2,
    eFamily_serif = 3,
    eFamily_sans_serif = 4,
    eFamily_monospace = 5,
    eFamily_cursive = 6,
    eFamily_fantasy = 7,
    eFamily_moz_variable = 8,
    eFamily_moz_fixed = 9,
}
/**
 * font family name, a string for the name if not a generic and
 * a font type indicated named family or which generic family
 */
#[repr(C)]
#[derive(Debug)]
pub struct FontFamilyName {
    pub mType: FontFamilyType,
    pub mName: nsString,
}
#[test]
fn bindgen_test_layout_FontFamilyName() {
    assert_eq!(::std::mem::size_of::<FontFamilyName>() , 24usize);
    assert_eq!(::std::mem::align_of::<FontFamilyName>() , 8usize);
}
/**
 * font family list, array of font families and a default font type.
 * font family names are either named strings or generics. the default
 * font type is used to preserve the variable font fallback behavior
 */
#[repr(C)]
#[derive(Debug)]
pub struct FontFamilyList {
    pub mFontlist: nsTArray<FontFamilyName>,
    pub mDefaultFontType: FontFamilyType,
}
#[test]
fn bindgen_test_layout_FontFamilyList() {
    assert_eq!(::std::mem::size_of::<FontFamilyList>() , 16usize);
    assert_eq!(::std::mem::align_of::<FontFamilyList>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct gfxFontFeature {
    pub mTag: u32,
    pub mValue: u32,
}
#[test]
fn bindgen_test_layout_gfxFontFeature() {
    assert_eq!(::std::mem::size_of::<gfxFontFeature>() , 8usize);
    assert_eq!(::std::mem::align_of::<gfxFontFeature>() , 4usize);
}
impl Clone for gfxFontFeature {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct gfxAlternateValue {
    pub alternate: u32,
    pub value: nsString,
}
#[test]
fn bindgen_test_layout_gfxAlternateValue() {
    assert_eq!(::std::mem::size_of::<gfxAlternateValue>() , 24usize);
    assert_eq!(::std::mem::align_of::<gfxAlternateValue>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct gfxFontFeatureValueSet {
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    pub mFontFeatureValues: [u64; 6usize],
}
pub type gfxFontFeatureValueSet_HasThreadSafeRefCnt = FalseType;
#[repr(C)]
#[derive(Debug)]
pub struct gfxFontFeatureValueSet_ValueList {
    pub name: nsString,
    pub featureSelectors: nsTArray<::std::os::raw::c_uint>,
}
#[test]
fn bindgen_test_layout_gfxFontFeatureValueSet_ValueList() {
    assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet_ValueList>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<gfxFontFeatureValueSet_ValueList>() ,
               8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct gfxFontFeatureValueSet_FeatureValues {
    pub alternate: u32,
    pub valuelist: nsTArray<gfxFontFeatureValueSet_ValueList>,
}
#[test]
fn bindgen_test_layout_gfxFontFeatureValueSet_FeatureValues() {
    assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet_FeatureValues>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<gfxFontFeatureValueSet_FeatureValues>()
               , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct gfxFontFeatureValueSet_FeatureValueHashKey {
    pub mFamily: nsString,
    pub mPropVal: u32,
    pub mName: nsString,
}
#[test]
fn bindgen_test_layout_gfxFontFeatureValueSet_FeatureValueHashKey() {
    assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet_FeatureValueHashKey>()
               , 40usize);
    assert_eq!(::std::mem::align_of::<gfxFontFeatureValueSet_FeatureValueHashKey>()
               , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct gfxFontFeatureValueSet_FeatureValueHashEntry {
    pub _base: PLDHashEntryHdr,
    pub mKey: gfxFontFeatureValueSet_FeatureValueHashKey,
    pub mValues: nsTArray<::std::os::raw::c_uint>,
}
pub type gfxFontFeatureValueSet_FeatureValueHashEntry_KeyType =
    *const gfxFontFeatureValueSet_FeatureValueHashKey;
pub type gfxFontFeatureValueSet_FeatureValueHashEntry_KeyTypePointer =
    *const gfxFontFeatureValueSet_FeatureValueHashKey;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum gfxFontFeatureValueSet_FeatureValueHashEntry__bindgen_ty_bindgen_id_198584
         {
    ALLOW_MEMMOVE = 1,
}
#[test]
fn bindgen_test_layout_gfxFontFeatureValueSet_FeatureValueHashEntry() {
    assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet_FeatureValueHashEntry>()
               , 56usize);
    assert_eq!(::std::mem::align_of::<gfxFontFeatureValueSet_FeatureValueHashEntry>()
               , 8usize);
}
#[test]
fn bindgen_test_layout_gfxFontFeatureValueSet() {
    assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet>() , 64usize);
    assert_eq!(::std::mem::align_of::<gfxFontFeatureValueSet>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsFont {
    pub fontlist: FontFamilyList,
    pub style: u8,
    pub systemFont: bool,
    pub variantCaps: u8,
    pub variantNumeric: u8,
    pub variantPosition: u8,
    pub variantWidth: u8,
    pub variantLigatures: u16,
    pub variantEastAsian: u16,
    pub variantAlternates: u16,
    pub smoothing: u8,
    pub weight: u16,
    pub stretch: i16,
    pub kerning: u8,
    pub synthesis: u8,
    pub size: nscoord,
    pub sizeAdjust: f32,
    pub alternateValues: nsTArray<gfxAlternateValue>,
    pub featureValueLookup: RefPtr<gfxFontFeatureValueSet>,
    pub fontFeatureSettings: nsTArray<gfxFontFeature>,
    pub languageOverride: nsString,
}
#[test]
fn bindgen_test_layout_nsFont() {
    assert_eq!(::std::mem::size_of::<nsFont>() , 88usize);
    assert_eq!(::std::mem::align_of::<nsFont>() , 8usize);
}
pub type TimeStampValue = u64;
/**
 * Instances of this class represent moments in time, or a special
 * "null" moment. We do not use the non-monotonic system clock or
 * local time, since they can be reset, causing apparent backward
 * travel in time, which can confuse algorithms. Instead we measure
 * elapsed time according to the system.  This time can never go
 * backwards (i.e. it never wraps around, at least not in less than
 * five million years of system elapsed time). It might not advance
 * while the system is sleeping. If TimeStamp::SetNow() is not called
 * at all for hours or days, we might not notice the passage of some
 * of that time.
 *
 * We deliberately do not expose a way to convert TimeStamps to some
 * particular unit. All you can do is compute a difference between two
 * TimeStamps to get a TimeDuration. You can also add a TimeDuration
 * to a TimeStamp to get a new TimeStamp. You can't do something
 * meaningless like add two TimeStamps.
 *
 * Internally this is implemented as either a wrapper around
 *   - high-resolution, monotonic, system clocks if they exist on this
 *     platform
 *   - PRIntervalTime otherwise.  We detect wraparounds of
 *     PRIntervalTime and work around them.
 *
 * This class is similar to C++11's time_point, however it is
 * explicitly nullable and provides an IsNull() method. time_point
 * is initialized to the clock's epoch and provides a
 * time_since_epoch() method that functions similiarly. i.e.
 * t.IsNull() is equivalent to t.time_since_epoch() == decltype(t)::duration::zero();
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TimeStamp {
    /**
   * When built with PRIntervalTime, a value of 0 means this instance
   * is "null". Otherwise, the low 32 bits represent a PRIntervalTime,
   * and the high 32 bits represent a counter of the number of
   * rollovers of PRIntervalTime that we've seen. This counter starts
   * at 1 to avoid a real time colliding with the "null" value.
   *
   * PR_INTERVAL_MAX is set at 100,000 ticks per second. So the minimum
   * time to wrap around is about 2^64/100000 seconds, i.e. about
   * 5,849,424 years.
   *
   * When using a system clock, a value is system dependent.
   */
    pub mValue: TimeStampValue,
}
#[test]
fn bindgen_test_layout_TimeStamp() {
    assert_eq!(::std::mem::size_of::<TimeStamp>() , 8usize);
    assert_eq!(::std::mem::align_of::<TimeStamp>() , 8usize);
}
impl Clone for TimeStamp {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FramePropertyDescriptorUntyped {
    pub mDestructor: FramePropertyDescriptorUntyped_UntypedDestructor,
    pub mDestructorWithFrame: FramePropertyDescriptorUntyped_UntypedDestructorWithFrame,
}
/**
   * mDestructor will be called if it's non-null.
   */
pub type FramePropertyDescriptorUntyped_UntypedDestructor =
    ::std::option::Option<unsafe extern "C" fn(aPropertyValue:
                                                   *mut ::std::os::raw::c_void)>;
/**
   * mDestructorWithFrame will be called if it's non-null and mDestructor
   * is null. WARNING: The frame passed to mDestructorWithFrame may
   * be a dangling frame pointer, if this is being called during
   * presshell teardown. Do not use it except to compare against
   * other frame pointers. No frame will have been allocated with
   * the same address yet.
   */
pub type FramePropertyDescriptorUntyped_UntypedDestructorWithFrame =
    ::std::option::Option<unsafe extern "C" fn(aFrame: *const nsIFrame,
                                               aPropertyValue:
                                                   *mut ::std::os::raw::c_void)>;
#[test]
fn bindgen_test_layout_FramePropertyDescriptorUntyped() {
    assert_eq!(::std::mem::size_of::<FramePropertyDescriptorUntyped>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<FramePropertyDescriptorUntyped>() ,
               8usize);
}
impl Clone for FramePropertyDescriptorUntyped {
    fn clone(&self) -> Self { *self }
}
/**
 * The FramePropertyTable is optimized for storing 0 or 1 properties on
 * a given frame. Storing very large numbers of properties on a single
 * frame will not be efficient.
 * 
 * Property values are passed as void* but do not actually have to be
 * valid pointers. You can use NS_INT32_TO_PTR/NS_PTR_TO_INT32 to
 * store int32_t values. Null/zero values can be stored and retrieved.
 * Of course, the destructor function (if any) must handle such values
 * correctly.
 */
#[repr(C)]
#[derive(Debug)]
pub struct FramePropertyTable {
    pub mEntries: [u64; 6usize],
    pub mLastFrame: *const nsIFrame,
    pub mLastEntry: *mut FramePropertyTable_Entry,
}
pub type FramePropertyTable_UntypedDescriptor =
    *const FramePropertyDescriptorUntyped;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FramePropertyTable_ReinterpretHelper<T> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
}
/**
   * Stores a property descriptor/value pair. It can also be used to
   * store an nsTArray of PropertyValues.
   */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FramePropertyTable_PropertyValue {
    pub mProperty: FramePropertyTable_UntypedDescriptor,
    pub mValue: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FramePropertyTable_PropertyValue() {
    assert_eq!(::std::mem::size_of::<FramePropertyTable_PropertyValue>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<FramePropertyTable_PropertyValue>() ,
               8usize);
}
impl Clone for FramePropertyTable_PropertyValue {
    fn clone(&self) -> Self { *self }
}
/**
   * Used with an array of PropertyValues to allow lookups that compare
   * only on the FramePropertyDescriptor.
   */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FramePropertyTable_PropertyComparator {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_FramePropertyTable_PropertyComparator() {
    assert_eq!(::std::mem::size_of::<FramePropertyTable_PropertyComparator>()
               , 1usize);
    assert_eq!(::std::mem::align_of::<FramePropertyTable_PropertyComparator>()
               , 1usize);
}
impl Clone for FramePropertyTable_PropertyComparator {
    fn clone(&self) -> Self { *self }
}
/**
   * Our hashtable entry. The key is an nsIFrame*, the value is a
   * PropertyValue representing one or more property/value pairs.
   */
#[repr(C)]
#[derive(Debug)]
pub struct FramePropertyTable_Entry {
    pub _base: nsPtrHashKey<nsIFrame>,
    pub mProp: FramePropertyTable_PropertyValue,
}
#[test]
fn bindgen_test_layout_FramePropertyTable_Entry() {
    assert_eq!(::std::mem::size_of::<FramePropertyTable_Entry>() , 32usize);
    assert_eq!(::std::mem::align_of::<FramePropertyTable_Entry>() , 8usize);
}
#[test]
fn bindgen_test_layout_FramePropertyTable() {
    assert_eq!(::std::mem::size_of::<FramePropertyTable>() , 64usize);
    assert_eq!(::std::mem::align_of::<FramePropertyTable>() , 8usize);
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum StyleBasicShapeType {
    Polygon = 0,
    Circle = 1,
    Ellipse = 2,
    Inset = 3,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum StyleBoxAlign {
    Stretch = 0,
    Start = 1,
    Center = 2,
    Baseline = 3,
    End = 4,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum StyleBoxDecorationBreak { Slice = 0, Clone = 1, }
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum StyleBoxDirection { Normal = 0, Reverse = 1, }
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum StyleBoxOrient { Horizontal = 0, Vertical = 1, }
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum StyleBoxPack { Start = 0, Center = 1, End = 2, Justify = 3, }
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum StyleBoxSizing { Content = 0, Border = 1, }
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum StyleClear {
    None = 0,
    Left = 1,
    Right = 2,
    InlineStart = 3,
    InlineEnd = 4,
    Both = 5,
    Line = 8,
    Max = 13,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum StyleClipPathGeometryBox {
    NoBox = 0,
    Content = 1,
    Padding = 2,
    Border = 3,
    Margin = 4,
    Fill = 5,
    Stroke = 6,
    View = 7,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum StyleFillRule { Nonzero = 0, Evenodd = 1, }
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum StyleFloat {
    None = 0,
    Left = 1,
    Right = 2,
    InlineStart = 3,
    InlineEnd = 4,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum StyleFloatEdge { ContentBox = 0, MarginBox = 1, }
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum StyleShapeOutsideShapeBox {
    NoBox = 0,
    Content = 1,
    Padding = 2,
    Border = 3,
    Margin = 4,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum StyleShapeSourceType { None = 0, URL = 1, Shape = 2, Box = 3, }
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum StyleUserFocus {
    None = 0,
    Ignore = 1,
    Normal = 2,
    SelectAll = 3,
    SelectBefore = 4,
    SelectAfter = 5,
    SelectSame = 6,
    SelectMenu = 7,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum StyleUserSelect {
    None = 0,
    Text = 1,
    Element = 2,
    Elements = 3,
    All = 4,
    Toggle = 5,
    TriState = 6,
    Auto = 7,
    MozAll = 8,
    MozText = 9,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum StyleDisplay {
    None = 0,
    Block = 1,
    Inline = 2,
    InlineBlock = 3,
    ListItem = 4,
    Table = 5,
    InlineTable = 6,
    TableRowGroup = 7,
    TableColumn = 8,
    TableColumnGroup = 9,
    TableHeaderGroup = 10,
    TableFooterGroup = 11,
    TableRow = 12,
    TableCell = 13,
    TableCaption = 14,
    Flex = 15,
    InlineFlex = 16,
    Grid = 17,
    InlineGrid = 18,
    Ruby = 19,
    RubyBase = 20,
    RubyBaseContainer = 21,
    RubyText = 22,
    RubyTextContainer = 23,
    Contents = 24,
    WebkitBox = 25,
    WebkitInlineBox = 26,
    Box = 27,
    InlineBox = 28,
    XulGrid = 29,
    InlineXulGrid = 30,
    XulGridGroup = 31,
    XulGridLine = 32,
    Stack = 33,
    InlineStack = 34,
    Deck = 35,
    Groupbox = 36,
    Popup = 37,
}
pub const nsStyleUnit_eStyleUnit_MAX: nsStyleUnit =
    nsStyleUnit::eStyleUnit_Calc;
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsStyleUnit {
    eStyleUnit_Null = 0,
    eStyleUnit_Normal = 1,
    eStyleUnit_Auto = 2,
    eStyleUnit_None = 3,
    eStyleUnit_Percent = 10,
    eStyleUnit_Factor = 11,
    eStyleUnit_Degree = 12,
    eStyleUnit_Grad = 13,
    eStyleUnit_Radian = 14,
    eStyleUnit_Turn = 15,
    eStyleUnit_FlexFraction = 16,
    eStyleUnit_Coord = 20,
    eStyleUnit_Integer = 30,
    eStyleUnit_Enumerated = 32,
    eStyleUnit_Calc = 40,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_bindgen_id_199331 {
    pub mInt: __BindgenUnionField<i32>,
    pub mFloat: __BindgenUnionField<f32>,
    pub mPointer: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_bindgen_id_199331() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_bindgen_id_199331>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_bindgen_id_199331>() ,
               8usize);
}
impl Clone for _bindgen_ty_bindgen_id_199331 {
    fn clone(&self) -> Self { *self }
}
pub type nsStyleUnion = _bindgen_ty_bindgen_id_199331;
/**
 * Class that hold a single size specification used by the style
 * system.  The size specification consists of two parts -- a number
 * and a unit.  The number is an integer, a floating point value, an
 * nscoord, or undefined, and the unit is an nsStyleUnit.  Checking
 * the unit is a must before asking for the value in any particular
 * form.
 */
 /** <div rustbindgen private accessor="unsafe"></div> */
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleCoord {
    mUnit: nsStyleUnit,
    mValue: nsStyleUnion,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleCoord_CalcValue {
    pub mLength: nscoord,
    pub mPercent: f32,
    pub mHasPercent: bool,
}
#[test]
fn bindgen_test_layout_nsStyleCoord_CalcValue() {
    assert_eq!(::std::mem::size_of::<nsStyleCoord_CalcValue>() , 12usize);
    assert_eq!(::std::mem::align_of::<nsStyleCoord_CalcValue>() , 4usize);
}
impl Clone for nsStyleCoord_CalcValue {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleCoord_Calc {
    pub _base: nsStyleCoord_CalcValue,
    pub mRefCnt: ThreadSafeAutoRefCnt,
}
pub type nsStyleCoord_Calc_HasThreadSafeRefCnt = TrueType;
#[test]
fn bindgen_test_layout_nsStyleCoord_Calc() {
    assert_eq!(::std::mem::size_of::<nsStyleCoord_Calc>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsStyleCoord_Calc>() , 8usize);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsStyleCoord_CoordConstructorType { CoordConstructor = 0, }
#[test]
fn bindgen_test_layout_nsStyleCoord() {
    assert_eq!(::std::mem::size_of::<nsStyleCoord>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsStyleCoord>() , 8usize);
}
impl nsStyleCoord {
    #[inline]
    pub unsafe fn get_mUnit(&self) -> &nsStyleUnit { &self.mUnit }
    #[inline]
    pub unsafe fn get_mUnit_mut(&mut self) -> &mut nsStyleUnit {
        &mut self.mUnit
    }
    #[inline]
    pub unsafe fn get_mValue(&self) -> &nsStyleUnion { &self.mValue }
    #[inline]
    pub unsafe fn get_mValue_mut(&mut self) -> &mut nsStyleUnion {
        &mut self.mValue
    }
}
/**
 * Class that represents a set of top/right/bottom/left nsStyleCoords.
 * This is commonly used to hold the widths of the borders, margins,
 * or paddings of a box.
 */
 /** <div rustbindgen private accessor="unsafe"></div> */
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleSides {
    mUnits: [nsStyleUnit; 4usize],
    mValues: [nsStyleUnion; 4usize],
}
#[test]
fn bindgen_test_layout_nsStyleSides() {
    assert_eq!(::std::mem::size_of::<nsStyleSides>() , 40usize);
    assert_eq!(::std::mem::align_of::<nsStyleSides>() , 8usize);
}
impl nsStyleSides {
    #[inline]
    pub unsafe fn get_mUnits(&self) -> &[nsStyleUnit; 4usize] { &self.mUnits }
    #[inline]
    pub unsafe fn get_mUnits_mut(&mut self) -> &mut [nsStyleUnit; 4usize] {
        &mut self.mUnits
    }
    #[inline]
    pub unsafe fn get_mValues(&self) -> &[nsStyleUnion; 4usize] {
        &self.mValues
    }
    #[inline]
    pub unsafe fn get_mValues_mut(&mut self) -> &mut [nsStyleUnion; 4usize] {
        &mut self.mValues
    }
}
/**
 * Class that represents a set of top-left/top-right/bottom-right/bottom-left
 * nsStyleCoord pairs.  This is used to hold the dimensions of the
 * corners of a box (for, e.g., border-radius and outline-radius).
 */
 /** <div rustbindgen private accessor="unsafe"></div> */
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleCorners {
    mUnits: [nsStyleUnit; 8usize],
    mValues: [nsStyleUnion; 8usize],
}
#[test]
fn bindgen_test_layout_nsStyleCorners() {
    assert_eq!(::std::mem::size_of::<nsStyleCorners>() , 72usize);
    assert_eq!(::std::mem::align_of::<nsStyleCorners>() , 8usize);
}
impl nsStyleCorners {
    #[inline]
    pub unsafe fn get_mUnits(&self) -> &[nsStyleUnit; 8usize] { &self.mUnits }
    #[inline]
    pub unsafe fn get_mUnits_mut(&mut self) -> &mut [nsStyleUnit; 8usize] {
        &mut self.mUnits
    }
    #[inline]
    pub unsafe fn get_mValues(&self) -> &[nsStyleUnion; 8usize] {
        &self.mValues
    }
    #[inline]
    pub unsafe fn get_mValues_mut(&mut self) -> &mut [nsStyleUnion; 8usize] {
        &mut self.mValues
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleDisplay {
    pub mBinding: RefPtr<URLValue>,
    pub mDisplay: StyleDisplay,
    pub mOriginalDisplay: StyleDisplay,
    pub mContain: u8,
    pub mAppearance: u8,
    pub mPosition: u8,
    pub mFloat: StyleFloat,
    pub mOriginalFloat: StyleFloat,
    pub mBreakType: StyleClear,
    pub mBreakInside: u8,
    pub mBreakBefore: bool,
    pub mBreakAfter: bool,
    pub mOverflowX: u8,
    pub mOverflowY: u8,
    pub mOverflowClipBox: u8,
    pub mResize: u8,
    pub mOrient: u8,
    pub mIsolation: u8,
    pub mTopLayer: u8,
    pub mWillChangeBitField: u8,
    pub mWillChange: nsTArray<nsString>,
    pub mTouchAction: u8,
    pub mScrollBehavior: u8,
    pub mScrollSnapTypeX: u8,
    pub mScrollSnapTypeY: u8,
    pub mScrollSnapPointsX: nsStyleCoord,
    pub mScrollSnapPointsY: nsStyleCoord,
    pub mScrollSnapDestination: Position,
    pub mScrollSnapCoordinate: nsTArray<Position>,
    pub mBackfaceVisibility: u8,
    pub mTransformStyle: u8,
    pub mTransformBox: u8,
    pub mSpecifiedTransform: RefPtr<nsCSSValueSharedList>,
    pub mTransformOrigin: [nsStyleCoord; 3usize],
    pub mChildPerspective: nsStyleCoord,
    pub mPerspectiveOrigin: [nsStyleCoord; 2usize],
    pub mVerticalAlign: nsStyleCoord,
    pub mTransitions: nsStyleAutoArray<StyleTransition>,
    pub mTransitionTimingFunctionCount: u32,
    pub mTransitionDurationCount: u32,
    pub mTransitionDelayCount: u32,
    pub mTransitionPropertyCount: u32,
    pub mAnimations: nsStyleAutoArray<StyleAnimation>,
    pub mAnimationTimingFunctionCount: u32,
    pub mAnimationDurationCount: u32,
    pub mAnimationDelayCount: u32,
    pub mAnimationNameCount: u32,
    pub mAnimationDirectionCount: u32,
    pub mAnimationFillModeCount: u32,
    pub mAnimationPlayStateCount: u32,
    pub mAnimationIterationCountCount: u32,
    pub mShapeOutside: StyleShapeOutside,
}
#[test]
fn bindgen_test_layout_nsStyleDisplay() {
    assert_eq!(::std::mem::size_of::<nsStyleDisplay>() , 424usize);
    assert_eq!(::std::mem::align_of::<nsStyleDisplay>() , 8usize);
}
/**
 * A class for holding strong references to handle-managed objects.
 *
 * This is intended for use with objects like RestyleManagerHandle,
 * where the handle type is not a pointer but which can still have
 * ->AddRef() and ->Release() called on it.
 */
#[repr(C)]
#[derive(Debug)]
pub struct HandleRefPtr<T> {
    pub mHandle: T,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsILanguageAtomService {
    pub _base: nsISupports,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsILanguageAtomService_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsILanguageAtomService() {
    assert_eq!(::std::mem::size_of::<nsILanguageAtomService>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsILanguageAtomService>() , 8usize);
}
impl Clone for nsILanguageAtomService {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct LangGroupFontPrefs {
    pub mLangGroup: nsCOMPtr<nsIAtom>,
    pub mMinimumFontSize: nscoord,
    pub mDefaultVariableFont: nsFont,
    pub mDefaultFixedFont: nsFont,
    pub mDefaultSerifFont: nsFont,
    pub mDefaultSansSerifFont: nsFont,
    pub mDefaultMonospaceFont: nsFont,
    pub mDefaultCursiveFont: nsFont,
    pub mDefaultFantasyFont: nsFont,
    pub mNext: nsAutoPtr<LangGroupFontPrefs>,
}
#[test]
fn bindgen_test_layout_LangGroupFontPrefs() {
    assert_eq!(::std::mem::size_of::<LangGroupFontPrefs>() , 640usize);
    assert_eq!(::std::mem::align_of::<LangGroupFontPrefs>() , 8usize);
}
/**
 * Some functionality that has historically lived on nsPresContext does not
 * actually need to be per-document. This singleton class serves as a host
 * for that functionality. We delegate to it from nsPresContext where
 * appropriate, and use it standalone in some cases as well.
 */
#[repr(C)]
#[derive(Debug)]
pub struct StaticPresData {
    pub mLangService: nsCOMPtr<nsILanguageAtomService>,
    pub mBorderWidthTable: [nscoord; 3usize],
    pub mStaticLangGroupFontPrefs: LangGroupFontPrefs,
}
#[test]
fn bindgen_test_layout_StaticPresData() {
    assert_eq!(::std::mem::size_of::<StaticPresData>() , 664usize);
    assert_eq!(::std::mem::align_of::<StaticPresData>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIPrintSettings {
    pub _address: u8,
}
impl Clone for nsIPrintSettings {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsITheme {
    pub _address: u8,
}
impl Clone for nsITheme {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct gfxTextPerfMetrics {
    pub _address: u8,
}
impl Clone for gfxTextPerfMetrics {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsTransitionManager {
    pub _address: u8,
}
impl Clone for nsTransitionManager {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsAnimationManager {
    pub _address: u8,
}
impl Clone for nsAnimationManager {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsDeviceContext {
    pub _address: u8,
}
impl Clone for nsDeviceContext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct gfxMissingFontRecorder {
    pub _address: u8,
}
impl Clone for gfxMissingFontRecorder {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct EffectCompositor {
    pub _address: u8,
}
impl Clone for EffectCompositor {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct EventStateManager {
    pub _address: u8,
}
impl Clone for EventStateManager {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct CounterStyleManager {
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    pub mPresContext: *mut nsPresContext,
    pub mCacheTable: [u64; 6usize],
}
pub type CounterStyleManager_HasThreadSafeRefCnt = FalseType;
#[test]
fn bindgen_test_layout_CounterStyleManager() {
    assert_eq!(::std::mem::size_of::<CounterStyleManager>() , 72usize);
    assert_eq!(::std::mem::align_of::<CounterStyleManager>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsInvalidateRequestList {
    pub mRequests: nsTArray<nsInvalidateRequestList_Request>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsInvalidateRequestList_Request {
    pub mRect: nsRect,
    pub mFlags: u32,
}
#[test]
fn bindgen_test_layout_nsInvalidateRequestList_Request() {
    assert_eq!(::std::mem::size_of::<nsInvalidateRequestList_Request>() ,
               20usize);
    assert_eq!(::std::mem::align_of::<nsInvalidateRequestList_Request>() ,
               4usize);
}
impl Clone for nsInvalidateRequestList_Request {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsInvalidateRequestList() {
    assert_eq!(::std::mem::size_of::<nsInvalidateRequestList>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsInvalidateRequestList>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DisplayItemClip_RoundedRect {
    pub mRect: nsRect,
    pub mRadii: [nscoord; 8usize],
}
#[test]
fn bindgen_test_layout_DisplayItemClip_RoundedRect() {
    assert_eq!(::std::mem::size_of::<DisplayItemClip_RoundedRect>() ,
               48usize);
    assert_eq!(::std::mem::align_of::<DisplayItemClip_RoundedRect>() ,
               4usize);
}
impl Clone for DisplayItemClip_RoundedRect {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Grid {
    pub _address: u8,
}
impl Clone for Grid {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsCSSTokenSerializationType {
    eCSSTokenSerialization_Nothing = 0,
    eCSSTokenSerialization_Whitespace = 1,
    eCSSTokenSerialization_AtKeyword_or_Hash = 2,
    eCSSTokenSerialization_Number = 3,
    eCSSTokenSerialization_Dimension = 4,
    eCSSTokenSerialization_Percentage = 5,
    eCSSTokenSerialization_URange = 6,
    eCSSTokenSerialization_URL_or_BadURL = 7,
    eCSSTokenSerialization_Function = 8,
    eCSSTokenSerialization_Ident = 9,
    eCSSTokenSerialization_CDC = 10,
    eCSSTokenSerialization_DashMatch = 11,
    eCSSTokenSerialization_ContainsMatch = 12,
    eCSSTokenSerialization_Symbol_Hash = 13,
    eCSSTokenSerialization_Symbol_At = 14,
    eCSSTokenSerialization_Symbol_Dot_or_Plus = 15,
    eCSSTokenSerialization_Symbol_Minus = 16,
    eCSSTokenSerialization_Symbol_OpenParen = 17,
    eCSSTokenSerialization_Symbol_Question = 18,
    eCSSTokenSerialization_Symbol_Assorted = 19,
    eCSSTokenSerialization_Symbol_Equals = 20,
    eCSSTokenSerialization_Symbol_Bar = 21,
    eCSSTokenSerialization_Symbol_Slash = 22,
    eCSSTokenSerialization_Symbol_Asterisk = 23,
    eCSSTokenSerialization_Other = 24,
}
#[repr(C)]
#[derive(Debug)]
pub struct CSSVariableValues {
    /**
   * Map of variable names to IDs.  Variable IDs are indexes into
   * mVariables.
   */
    pub mVariableIDs: [u64; 6usize],
    /**
   * Array of variables, indexed by variable ID.
   */
    pub mVariables: nsTArray<CSSVariableValues_Variable>,
}
#[repr(C)]
#[derive(Debug)]
pub struct CSSVariableValues_Variable {
    pub mVariableName: nsString,
    pub mValue: nsString,
    pub mFirstToken: nsCSSTokenSerializationType,
    pub mLastToken: nsCSSTokenSerializationType,
}
#[test]
fn bindgen_test_layout_CSSVariableValues_Variable() {
    assert_eq!(::std::mem::size_of::<CSSVariableValues_Variable>() , 40usize);
    assert_eq!(::std::mem::align_of::<CSSVariableValues_Variable>() , 8usize);
}
#[test]
fn bindgen_test_layout_CSSVariableValues() {
    assert_eq!(::std::mem::size_of::<CSSVariableValues>() , 56usize);
    assert_eq!(::std::mem::align_of::<CSSVariableValues>() , 8usize);
}
/**
 * This struct represents a combined color from a numeric color and
 * the current foreground color (currentcolor keyword).
 * Conceptually, the formula is "color * (1 - p) + currentcolor * p"
 * where p is mForegroundRatio. See mozilla::LinearBlendColors for
 * the actual algorithm.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct StyleComplexColor {
    pub mColor: nscolor,
    pub mForegroundRatio: u8,
}
#[test]
fn bindgen_test_layout_StyleComplexColor() {
    assert_eq!(::std::mem::size_of::<StyleComplexColor>() , 8usize);
    assert_eq!(::std::mem::align_of::<StyleComplexColor>() , 4usize);
}
impl Clone for StyleComplexColor {
    fn clone(&self) -> Self { *self }
}
pub const nsCSSPropertyID_eCSSProperty_COUNT_DUMMY: nsCSSPropertyID =
    nsCSSPropertyID::eCSSProperty_z_index;
pub const nsCSSPropertyID_eCSSProperty_all: nsCSSPropertyID =
    nsCSSPropertyID::eCSSProperty_COUNT_no_shorthands;
pub const nsCSSPropertyID_eCSSProperty_COUNT_DUMMY2: nsCSSPropertyID =
    nsCSSPropertyID::eCSSProperty_transition;
pub const nsCSSPropertyID_eCSSPropertyAlias_WordWrap: nsCSSPropertyID =
    nsCSSPropertyID::eCSSProperty_COUNT;
pub const nsCSSPropertyID_eCSSProperty_COUNT_DUMMY3: nsCSSPropertyID =
    nsCSSPropertyID::eCSSPropertyAlias_WebkitMaskSize;
pub const nsCSSPropertyID_eCSSPropertyExtra_no_properties: nsCSSPropertyID =
    nsCSSPropertyID::eCSSProperty_COUNT_with_aliases;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsCSSPropertyID {
    eCSSProperty_UNKNOWN = -1,
    eCSSProperty_align_content = 0,
    eCSSProperty_align_items = 1,
    eCSSProperty_align_self = 2,
    eCSSProperty_animation_delay = 3,
    eCSSProperty_animation_direction = 4,
    eCSSProperty_animation_duration = 5,
    eCSSProperty_animation_fill_mode = 6,
    eCSSProperty_animation_iteration_count = 7,
    eCSSProperty_animation_name = 8,
    eCSSProperty_animation_play_state = 9,
    eCSSProperty_animation_timing_function = 10,
    eCSSProperty_appearance = 11,
    eCSSProperty_backface_visibility = 12,
    eCSSProperty_background_attachment = 13,
    eCSSProperty_background_blend_mode = 14,
    eCSSProperty_background_clip = 15,
    eCSSProperty_background_color = 16,
    eCSSProperty_background_image = 17,
    eCSSProperty_background_origin = 18,
    eCSSProperty_background_position_x = 19,
    eCSSProperty_background_position_y = 20,
    eCSSProperty_background_repeat = 21,
    eCSSProperty_background_size = 22,
    eCSSProperty_binding = 23,
    eCSSProperty_block_size = 24,
    eCSSProperty_border_block_end_color = 25,
    eCSSProperty_border_block_end_style = 26,
    eCSSProperty_border_block_end_width = 27,
    eCSSProperty_border_block_start_color = 28,
    eCSSProperty_border_block_start_style = 29,
    eCSSProperty_border_block_start_width = 30,
    eCSSProperty_border_bottom_color = 31,
    eCSSProperty_border_bottom_colors = 32,
    eCSSProperty_border_bottom_left_radius = 33,
    eCSSProperty_border_bottom_right_radius = 34,
    eCSSProperty_border_bottom_style = 35,
    eCSSProperty_border_bottom_width = 36,
    eCSSProperty_border_collapse = 37,
    eCSSProperty_border_image_outset = 38,
    eCSSProperty_border_image_repeat = 39,
    eCSSProperty_border_image_slice = 40,
    eCSSProperty_border_image_source = 41,
    eCSSProperty_border_image_width = 42,
    eCSSProperty_border_inline_end_color = 43,
    eCSSProperty_border_inline_end_style = 44,
    eCSSProperty_border_inline_end_width = 45,
    eCSSProperty_border_inline_start_color = 46,
    eCSSProperty_border_inline_start_style = 47,
    eCSSProperty_border_inline_start_width = 48,
    eCSSProperty_border_left_color = 49,
    eCSSProperty_border_left_colors = 50,
    eCSSProperty_border_left_style = 51,
    eCSSProperty_border_left_width = 52,
    eCSSProperty_border_right_color = 53,
    eCSSProperty_border_right_colors = 54,
    eCSSProperty_border_right_style = 55,
    eCSSProperty_border_right_width = 56,
    eCSSProperty_border_spacing = 57,
    eCSSProperty_border_top_color = 58,
    eCSSProperty_border_top_colors = 59,
    eCSSProperty_border_top_left_radius = 60,
    eCSSProperty_border_top_right_radius = 61,
    eCSSProperty_border_top_style = 62,
    eCSSProperty_border_top_width = 63,
    eCSSProperty_bottom = 64,
    eCSSProperty_box_align = 65,
    eCSSProperty_box_decoration_break = 66,
    eCSSProperty_box_direction = 67,
    eCSSProperty_box_flex = 68,
    eCSSProperty_box_ordinal_group = 69,
    eCSSProperty_box_orient = 70,
    eCSSProperty_box_pack = 71,
    eCSSProperty_box_shadow = 72,
    eCSSProperty_box_sizing = 73,
    eCSSProperty_caption_side = 74,
    eCSSProperty_clear = 75,
    eCSSProperty_clip = 76,
    eCSSProperty_clip_path = 77,
    eCSSProperty_clip_rule = 78,
    eCSSProperty_color = 79,
    eCSSProperty_color_adjust = 80,
    eCSSProperty_color_interpolation = 81,
    eCSSProperty_color_interpolation_filters = 82,
    eCSSProperty_column_count = 83,
    eCSSProperty_column_fill = 84,
    eCSSProperty_column_gap = 85,
    eCSSProperty_column_rule_color = 86,
    eCSSProperty_column_rule_style = 87,
    eCSSProperty_column_rule_width = 88,
    eCSSProperty_column_width = 89,
    eCSSProperty_contain = 90,
    eCSSProperty_content = 91,
    eCSSProperty__moz_control_character_visibility = 92,
    eCSSProperty_counter_increment = 93,
    eCSSProperty_counter_reset = 94,
    eCSSProperty_cursor = 95,
    eCSSProperty_direction = 96,
    eCSSProperty_display = 97,
    eCSSProperty_dominant_baseline = 98,
    eCSSProperty_empty_cells = 99,
    eCSSProperty_fill = 100,
    eCSSProperty_fill_opacity = 101,
    eCSSProperty_fill_rule = 102,
    eCSSProperty_filter = 103,
    eCSSProperty_flex_basis = 104,
    eCSSProperty_flex_direction = 105,
    eCSSProperty_flex_grow = 106,
    eCSSProperty_flex_shrink = 107,
    eCSSProperty_flex_wrap = 108,
    eCSSProperty_float = 109,
    eCSSProperty_float_edge = 110,
    eCSSProperty_flood_color = 111,
    eCSSProperty_flood_opacity = 112,
    eCSSProperty_font_family = 113,
    eCSSProperty_font_feature_settings = 114,
    eCSSProperty_font_kerning = 115,
    eCSSProperty_font_language_override = 116,
    eCSSProperty_font_size = 117,
    eCSSProperty_font_size_adjust = 118,
    eCSSProperty_font_stretch = 119,
    eCSSProperty_font_style = 120,
    eCSSProperty_font_synthesis = 121,
    eCSSProperty_font_variant_alternates = 122,
    eCSSProperty_font_variant_caps = 123,
    eCSSProperty_font_variant_east_asian = 124,
    eCSSProperty_font_variant_ligatures = 125,
    eCSSProperty_font_variant_numeric = 126,
    eCSSProperty_font_variant_position = 127,
    eCSSProperty_font_weight = 128,
    eCSSProperty_force_broken_image_icon = 129,
    eCSSProperty_grid_auto_columns = 130,
    eCSSProperty_grid_auto_flow = 131,
    eCSSProperty_grid_auto_rows = 132,
    eCSSProperty_grid_column_end = 133,
    eCSSProperty_grid_column_gap = 134,
    eCSSProperty_grid_column_start = 135,
    eCSSProperty_grid_row_end = 136,
    eCSSProperty_grid_row_gap = 137,
    eCSSProperty_grid_row_start = 138,
    eCSSProperty_grid_template_areas = 139,
    eCSSProperty_grid_template_columns = 140,
    eCSSProperty_grid_template_rows = 141,
    eCSSProperty_height = 142,
    eCSSProperty_hyphens = 143,
    eCSSProperty_initial_letter = 144,
    eCSSProperty_image_orientation = 145,
    eCSSProperty_image_region = 146,
    eCSSProperty_image_rendering = 147,
    eCSSProperty_ime_mode = 148,
    eCSSProperty_inline_size = 149,
    eCSSProperty_isolation = 150,
    eCSSProperty_justify_content = 151,
    eCSSProperty_justify_items = 152,
    eCSSProperty_justify_self = 153,
    eCSSProperty__x_lang = 154,
    eCSSProperty_left = 155,
    eCSSProperty_letter_spacing = 156,
    eCSSProperty_lighting_color = 157,
    eCSSProperty_line_height = 158,
    eCSSProperty_list_style_image = 159,
    eCSSProperty_list_style_position = 160,
    eCSSProperty_list_style_type = 161,
    eCSSProperty_margin_block_end = 162,
    eCSSProperty_margin_block_start = 163,
    eCSSProperty_margin_bottom = 164,
    eCSSProperty_margin_inline_end = 165,
    eCSSProperty_margin_inline_start = 166,
    eCSSProperty_margin_left = 167,
    eCSSProperty_margin_right = 168,
    eCSSProperty_margin_top = 169,
    eCSSProperty_marker_end = 170,
    eCSSProperty_marker_mid = 171,
    eCSSProperty_marker_offset = 172,
    eCSSProperty_marker_start = 173,
    eCSSProperty_mask_clip = 174,
    eCSSProperty_mask_composite = 175,
    eCSSProperty_mask_image = 176,
    eCSSProperty_mask_mode = 177,
    eCSSProperty_mask_origin = 178,
    eCSSProperty_mask_position_x = 179,
    eCSSProperty_mask_position_y = 180,
    eCSSProperty_mask_repeat = 181,
    eCSSProperty_mask_size = 182,
    eCSSProperty_mask_type = 183,
    eCSSProperty_math_display = 184,
    eCSSProperty_math_variant = 185,
    eCSSProperty_max_block_size = 186,
    eCSSProperty_max_height = 187,
    eCSSProperty_max_inline_size = 188,
    eCSSProperty_max_width = 189,
    eCSSProperty_min_block_size = 190,
    eCSSProperty__moz_min_font_size_ratio = 191,
    eCSSProperty_min_height = 192,
    eCSSProperty_min_inline_size = 193,
    eCSSProperty_min_width = 194,
    eCSSProperty_mix_blend_mode = 195,
    eCSSProperty_object_fit = 196,
    eCSSProperty_object_position = 197,
    eCSSProperty_offset_block_end = 198,
    eCSSProperty_offset_block_start = 199,
    eCSSProperty_offset_inline_end = 200,
    eCSSProperty_offset_inline_start = 201,
    eCSSProperty_opacity = 202,
    eCSSProperty_order = 203,
    eCSSProperty_orient = 204,
    eCSSProperty_osx_font_smoothing = 205,
    eCSSProperty_outline_color = 206,
    eCSSProperty_outline_offset = 207,
    eCSSProperty__moz_outline_radius_bottomLeft = 208,
    eCSSProperty__moz_outline_radius_bottomRight = 209,
    eCSSProperty__moz_outline_radius_topLeft = 210,
    eCSSProperty__moz_outline_radius_topRight = 211,
    eCSSProperty_outline_style = 212,
    eCSSProperty_outline_width = 213,
    eCSSProperty_overflow_clip_box = 214,
    eCSSProperty_overflow_x = 215,
    eCSSProperty_overflow_y = 216,
    eCSSProperty_padding_block_end = 217,
    eCSSProperty_padding_block_start = 218,
    eCSSProperty_padding_bottom = 219,
    eCSSProperty_padding_inline_end = 220,
    eCSSProperty_padding_inline_start = 221,
    eCSSProperty_padding_left = 222,
    eCSSProperty_padding_right = 223,
    eCSSProperty_padding_top = 224,
    eCSSProperty_page_break_after = 225,
    eCSSProperty_page_break_before = 226,
    eCSSProperty_page_break_inside = 227,
    eCSSProperty_paint_order = 228,
    eCSSProperty_perspective = 229,
    eCSSProperty_perspective_origin = 230,
    eCSSProperty_pointer_events = 231,
    eCSSProperty_position = 232,
    eCSSProperty_quotes = 233,
    eCSSProperty_resize = 234,
    eCSSProperty_right = 235,
    eCSSProperty_ruby_align = 236,
    eCSSProperty_ruby_position = 237,
    eCSSProperty_script_level = 238,
    eCSSProperty_script_min_size = 239,
    eCSSProperty_script_size_multiplier = 240,
    eCSSProperty_scroll_behavior = 241,
    eCSSProperty_scroll_snap_coordinate = 242,
    eCSSProperty_scroll_snap_destination = 243,
    eCSSProperty_scroll_snap_points_x = 244,
    eCSSProperty_scroll_snap_points_y = 245,
    eCSSProperty_scroll_snap_type_x = 246,
    eCSSProperty_scroll_snap_type_y = 247,
    eCSSProperty_shape_outside = 248,
    eCSSProperty_shape_rendering = 249,
    eCSSProperty__x_span = 250,
    eCSSProperty_stack_sizing = 251,
    eCSSProperty_stop_color = 252,
    eCSSProperty_stop_opacity = 253,
    eCSSProperty_stroke = 254,
    eCSSProperty_stroke_dasharray = 255,
    eCSSProperty_stroke_dashoffset = 256,
    eCSSProperty_stroke_linecap = 257,
    eCSSProperty_stroke_linejoin = 258,
    eCSSProperty_stroke_miterlimit = 259,
    eCSSProperty_stroke_opacity = 260,
    eCSSProperty_stroke_width = 261,
    eCSSProperty__x_system_font = 262,
    eCSSProperty__moz_tab_size = 263,
    eCSSProperty_table_layout = 264,
    eCSSProperty_text_align = 265,
    eCSSProperty_text_align_last = 266,
    eCSSProperty_text_anchor = 267,
    eCSSProperty_text_combine_upright = 268,
    eCSSProperty_text_decoration_color = 269,
    eCSSProperty_text_decoration_line = 270,
    eCSSProperty_text_decoration_style = 271,
    eCSSProperty_text_emphasis_color = 272,
    eCSSProperty_text_emphasis_position = 273,
    eCSSProperty_text_emphasis_style = 274,
    eCSSProperty__webkit_text_fill_color = 275,
    eCSSProperty_text_indent = 276,
    eCSSProperty_text_orientation = 277,
    eCSSProperty_text_overflow = 278,
    eCSSProperty_text_rendering = 279,
    eCSSProperty_text_shadow = 280,
    eCSSProperty_text_size_adjust = 281,
    eCSSProperty__webkit_text_stroke_color = 282,
    eCSSProperty__webkit_text_stroke_width = 283,
    eCSSProperty_text_transform = 284,
    eCSSProperty__x_text_zoom = 285,
    eCSSProperty_top = 286,
    eCSSProperty__moz_top_layer = 287,
    eCSSProperty_touch_action = 288,
    eCSSProperty_transform = 289,
    eCSSProperty_transform_box = 290,
    eCSSProperty_transform_origin = 291,
    eCSSProperty_transform_style = 292,
    eCSSProperty_transition_delay = 293,
    eCSSProperty_transition_duration = 294,
    eCSSProperty_transition_property = 295,
    eCSSProperty_transition_timing_function = 296,
    eCSSProperty_unicode_bidi = 297,
    eCSSProperty_user_focus = 298,
    eCSSProperty_user_input = 299,
    eCSSProperty_user_modify = 300,
    eCSSProperty_user_select = 301,
    eCSSProperty_vector_effect = 302,
    eCSSProperty_vertical_align = 303,
    eCSSProperty_visibility = 304,
    eCSSProperty_white_space = 305,
    eCSSProperty_width = 306,
    eCSSProperty_will_change = 307,
    eCSSProperty__moz_window_dragging = 308,
    eCSSProperty__moz_window_shadow = 309,
    eCSSProperty_word_break = 310,
    eCSSProperty_word_spacing = 311,
    eCSSProperty_overflow_wrap = 312,
    eCSSProperty_writing_mode = 313,
    eCSSProperty_z_index = 314,
    eCSSProperty_COUNT_no_shorthands = 315,
    eCSSProperty_animation = 316,
    eCSSProperty_background = 317,
    eCSSProperty_background_position = 318,
    eCSSProperty_border = 319,
    eCSSProperty_border_block_end = 320,
    eCSSProperty_border_block_start = 321,
    eCSSProperty_border_bottom = 322,
    eCSSProperty_border_color = 323,
    eCSSProperty_border_image = 324,
    eCSSProperty_border_inline_end = 325,
    eCSSProperty_border_inline_start = 326,
    eCSSProperty_border_left = 327,
    eCSSProperty_border_radius = 328,
    eCSSProperty_border_right = 329,
    eCSSProperty_border_style = 330,
    eCSSProperty_border_top = 331,
    eCSSProperty_border_width = 332,
    eCSSProperty_column_rule = 333,
    eCSSProperty_columns = 334,
    eCSSProperty_flex = 335,
    eCSSProperty_flex_flow = 336,
    eCSSProperty_font = 337,
    eCSSProperty_font_variant = 338,
    eCSSProperty_grid = 339,
    eCSSProperty_grid_area = 340,
    eCSSProperty_grid_column = 341,
    eCSSProperty_grid_gap = 342,
    eCSSProperty_grid_row = 343,
    eCSSProperty_grid_template = 344,
    eCSSProperty_list_style = 345,
    eCSSProperty_margin = 346,
    eCSSProperty_marker = 347,
    eCSSProperty_mask = 348,
    eCSSProperty_mask_position = 349,
    eCSSProperty_outline = 350,
    eCSSProperty__moz_outline_radius = 351,
    eCSSProperty_overflow = 352,
    eCSSProperty_padding = 353,
    eCSSProperty_scroll_snap_type = 354,
    eCSSProperty_text_decoration = 355,
    eCSSProperty_text_emphasis = 356,
    eCSSProperty__webkit_text_stroke = 357,
    eCSSProperty__moz_transform = 358,
    eCSSProperty_transition = 359,
    eCSSProperty_COUNT = 360,
    eCSSPropertyAlias_MozTransformOrigin = 361,
    eCSSPropertyAlias_MozPerspectiveOrigin = 362,
    eCSSPropertyAlias_MozPerspective = 363,
    eCSSPropertyAlias_MozTransformStyle = 364,
    eCSSPropertyAlias_MozBackfaceVisibility = 365,
    eCSSPropertyAlias_MozBorderImage = 366,
    eCSSPropertyAlias_MozTransition = 367,
    eCSSPropertyAlias_MozTransitionDelay = 368,
    eCSSPropertyAlias_MozTransitionDuration = 369,
    eCSSPropertyAlias_MozTransitionProperty = 370,
    eCSSPropertyAlias_MozTransitionTimingFunction = 371,
    eCSSPropertyAlias_MozAnimation = 372,
    eCSSPropertyAlias_MozAnimationDelay = 373,
    eCSSPropertyAlias_MozAnimationDirection = 374,
    eCSSPropertyAlias_MozAnimationDuration = 375,
    eCSSPropertyAlias_MozAnimationFillMode = 376,
    eCSSPropertyAlias_MozAnimationIterationCount = 377,
    eCSSPropertyAlias_MozAnimationName = 378,
    eCSSPropertyAlias_MozAnimationPlayState = 379,
    eCSSPropertyAlias_MozAnimationTimingFunction = 380,
    eCSSPropertyAlias_MozBoxSizing = 381,
    eCSSPropertyAlias_MozFontFeatureSettings = 382,
    eCSSPropertyAlias_MozFontLanguageOverride = 383,
    eCSSPropertyAlias_MozPaddingEnd = 384,
    eCSSPropertyAlias_MozPaddingStart = 385,
    eCSSPropertyAlias_MozMarginEnd = 386,
    eCSSPropertyAlias_MozMarginStart = 387,
    eCSSPropertyAlias_MozBorderEnd = 388,
    eCSSPropertyAlias_MozBorderEndColor = 389,
    eCSSPropertyAlias_MozBorderEndStyle = 390,
    eCSSPropertyAlias_MozBorderEndWidth = 391,
    eCSSPropertyAlias_MozBorderStart = 392,
    eCSSPropertyAlias_MozBorderStartColor = 393,
    eCSSPropertyAlias_MozBorderStartStyle = 394,
    eCSSPropertyAlias_MozBorderStartWidth = 395,
    eCSSPropertyAlias_MozHyphens = 396,
    eCSSPropertyAlias_MozTextAlignLast = 397,
    eCSSPropertyAlias_WebkitAnimation = 398,
    eCSSPropertyAlias_WebkitAnimationDelay = 399,
    eCSSPropertyAlias_WebkitAnimationDirection = 400,
    eCSSPropertyAlias_WebkitAnimationDuration = 401,
    eCSSPropertyAlias_WebkitAnimationFillMode = 402,
    eCSSPropertyAlias_WebkitAnimationIterationCount = 403,
    eCSSPropertyAlias_WebkitAnimationName = 404,
    eCSSPropertyAlias_WebkitAnimationPlayState = 405,
    eCSSPropertyAlias_WebkitAnimationTimingFunction = 406,
    eCSSPropertyAlias_WebkitFilter = 407,
    eCSSPropertyAlias_WebkitTextSizeAdjust = 408,
    eCSSPropertyAlias_WebkitTransform = 409,
    eCSSPropertyAlias_WebkitTransformOrigin = 410,
    eCSSPropertyAlias_WebkitTransformStyle = 411,
    eCSSPropertyAlias_WebkitBackfaceVisibility = 412,
    eCSSPropertyAlias_WebkitPerspective = 413,
    eCSSPropertyAlias_WebkitPerspectiveOrigin = 414,
    eCSSPropertyAlias_WebkitTransition = 415,
    eCSSPropertyAlias_WebkitTransitionDelay = 416,
    eCSSPropertyAlias_WebkitTransitionDuration = 417,
    eCSSPropertyAlias_WebkitTransitionProperty = 418,
    eCSSPropertyAlias_WebkitTransitionTimingFunction = 419,
    eCSSPropertyAlias_WebkitBorderRadius = 420,
    eCSSPropertyAlias_WebkitBorderTopLeftRadius = 421,
    eCSSPropertyAlias_WebkitBorderTopRightRadius = 422,
    eCSSPropertyAlias_WebkitBorderBottomLeftRadius = 423,
    eCSSPropertyAlias_WebkitBorderBottomRightRadius = 424,
    eCSSPropertyAlias_WebkitBackgroundClip = 425,
    eCSSPropertyAlias_WebkitBackgroundOrigin = 426,
    eCSSPropertyAlias_WebkitBackgroundSize = 427,
    eCSSPropertyAlias_WebkitBorderImage = 428,
    eCSSPropertyAlias_WebkitBoxShadow = 429,
    eCSSPropertyAlias_WebkitBoxSizing = 430,
    eCSSPropertyAlias_WebkitBoxFlex = 431,
    eCSSPropertyAlias_WebkitBoxOrdinalGroup = 432,
    eCSSPropertyAlias_WebkitBoxOrient = 433,
    eCSSPropertyAlias_WebkitBoxDirection = 434,
    eCSSPropertyAlias_WebkitBoxAlign = 435,
    eCSSPropertyAlias_WebkitBoxPack = 436,
    eCSSPropertyAlias_WebkitFlexDirection = 437,
    eCSSPropertyAlias_WebkitFlexWrap = 438,
    eCSSPropertyAlias_WebkitFlexFlow = 439,
    eCSSPropertyAlias_WebkitOrder = 440,
    eCSSPropertyAlias_WebkitFlex = 441,
    eCSSPropertyAlias_WebkitFlexGrow = 442,
    eCSSPropertyAlias_WebkitFlexShrink = 443,
    eCSSPropertyAlias_WebkitFlexBasis = 444,
    eCSSPropertyAlias_WebkitJustifyContent = 445,
    eCSSPropertyAlias_WebkitAlignItems = 446,
    eCSSPropertyAlias_WebkitAlignSelf = 447,
    eCSSPropertyAlias_WebkitAlignContent = 448,
    eCSSPropertyAlias_WebkitUserSelect = 449,
    eCSSPropertyAlias_WebkitMask = 450,
    eCSSPropertyAlias_WebkitMaskClip = 451,
    eCSSPropertyAlias_WebkitMaskComposite = 452,
    eCSSPropertyAlias_WebkitMaskImage = 453,
    eCSSPropertyAlias_WebkitMaskOrigin = 454,
    eCSSPropertyAlias_WebkitMaskPosition = 455,
    eCSSPropertyAlias_WebkitMaskPositionX = 456,
    eCSSPropertyAlias_WebkitMaskPositionY = 457,
    eCSSPropertyAlias_WebkitMaskRepeat = 458,
    eCSSPropertyAlias_WebkitMaskSize = 459,
    eCSSProperty_COUNT_with_aliases = 460,
    eCSSPropertyExtra_all_properties = 461,
    eCSSPropertyExtra_x_none_value = 462,
    eCSSPropertyExtra_x_auto_value = 463,
    eCSSPropertyExtra_variable = 464,
}
/**
 * Class to safely handle main-thread-only pointers off the main thread.
 *
 * Classes like XPCWrappedJS are main-thread-only, which means that it is
 * forbidden to call methods on instances of these classes off the main thread.
 * For various reasons (see bug 771074), this restriction recently began to
 * apply to AddRef/Release as well.
 *
 * This presents a problem for consumers that wish to hold a callback alive
 * on non-main-thread code. A common example of this is the proxy callback
 * pattern, where non-main-thread code holds a strong-reference to the callback
 * object, and dispatches new Runnables (also with a strong reference) to the
 * main thread in order to execute the callback. This involves several AddRef
 * and Release calls on the other thread, which is (now) verboten.
 *
 * The basic idea of this class is to introduce a layer of indirection.
 * nsMainThreadPtrHolder is a threadsafe reference-counted class that internally
 * maintains one strong reference to the main-thread-only object. It must be
 * instantiated on the main thread (so that the AddRef of the underlying object
 * happens on the main thread), but consumers may subsequently pass references
 * to the holder anywhere they please. These references are meant to be opaque
 * when accessed off-main-thread (assertions enforce this).
 *
 * The semantics of RefPtr<nsMainThreadPtrHolder<T> > would be cumbersome, so
 * we also introduce nsMainThreadPtrHandle<T>, which is conceptually identical
 * to the above (though it includes various convenience methods). The basic
 * pattern is as follows.
 *
 * // On the main thread:
 * nsCOMPtr<nsIFooCallback> callback = ...;
 * nsMainThreadPtrHandle<nsIFooCallback> callbackHandle =
 *   new nsMainThreadPtrHolder<nsIFooCallback>(callback);
 * // Pass callbackHandle to structs/classes that might be accessed on other
 * // threads.
 *
 * All structs and classes that might be accessed on other threads should store
 * an nsMainThreadPtrHandle<T> rather than an nsCOMPtr<T>.
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsMainThreadPtrHolder<T> {
    pub mRefCnt: ThreadSafeAutoRefCnt,
    pub mRawPtr: *mut T,
    pub mStrict: bool,
}
pub type nsMainThreadPtrHolder_HasThreadSafeRefCnt = TrueType;
#[repr(C)]
#[derive(Debug)]
pub struct nsMainThreadPtrHandle<T> {
    pub mPtr: RefPtr<T>,
}
#[repr(C)]
#[derive(Debug)]
pub struct imgRequestProxy {
    pub _base: imgIRequest,
    pub _base_1: IProgressObserver,
    pub _base_2: nsISupportsPriority,
    pub _base_3: nsISecurityInfoProvider,
    pub _base_4: nsITimedChannel,
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    pub mBehaviour: UniquePtr<ProxyBehaviour, DefaultDelete<ProxyBehaviour>>,
    pub mURI: RefPtr<ImageURL>,
    pub mListener: *mut imgINotificationObserver,
    pub mLoadGroup: nsCOMPtr<nsILoadGroup>,
    pub mLoadFlags: nsLoadFlags,
    pub mLockCount: u32,
    pub mAnimationConsumers: u32,
    pub mCanceled: bool,
    pub mIsInLoadGroup: bool,
    pub mListenerIsStrongRef: bool,
    pub mDecodeRequested: bool,
    pub mDeferNotifications: bool,
}
pub type imgRequestProxy_Image = Image;
pub type imgRequestProxy_ImageURL = ImageURL;
pub type imgRequestProxy_ProgressTracker = ProgressTracker;
pub type imgRequestProxy_HasThreadSafeRefCnt = FalseType;
#[repr(C)]
#[derive(Debug)]
pub struct imgRequestProxy_imgCancelRunnable {
    pub _base: Runnable,
    pub mOwner: RefPtr<imgRequestProxy>,
    pub mStatus: nsresult,
}
#[test]
fn bindgen_test_layout_imgRequestProxy_imgCancelRunnable() {
    assert_eq!(::std::mem::size_of::<imgRequestProxy_imgCancelRunnable>() ,
               40usize);
    assert_eq!(::std::mem::align_of::<imgRequestProxy_imgCancelRunnable>() ,
               8usize);
}
#[test]
fn bindgen_test_layout_imgRequestProxy() {
    assert_eq!(::std::mem::size_of::<imgRequestProxy>() , 120usize);
    assert_eq!(::std::mem::align_of::<imgRequestProxy>() , 8usize);
}
#[repr(C)]
pub struct bindgen_vtable__bindgen_id_208430 {
}
/**
 * An interface for observing changes to image state, as reported by
 * ProgressTracker.
 *
 * This is the ImageLib-internal version of imgINotificationObserver,
 * essentially, with implementation details that code outside of ImageLib
 * shouldn't see.
 *
 * XXX(seth): It's preferable to avoid adding anything to this interface if
 * possible.  In the long term, it would be ideal to get to a place where we can
 * just use the imgINotificationObserver interface internally as well.
 */
#[repr(C)]
#[derive(Debug)]
pub struct IProgressObserver {
    pub vtable_: *const bindgen_vtable__bindgen_id_208430,
    pub _base: u64,
}
#[test]
fn bindgen_test_layout_IProgressObserver() {
    assert_eq!(::std::mem::size_of::<IProgressObserver>() , 16usize);
    assert_eq!(::std::mem::align_of::<IProgressObserver>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsISupportsPriority {
    pub _base: nsISupports,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsISupportsPriority_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsISupportsPriority__bindgen_ty_bindgen_id_208511 {
    PRIORITY_HIGHEST = -20,
    PRIORITY_HIGH = -10,
    PRIORITY_NORMAL = 0,
    PRIORITY_LOW = 10,
    PRIORITY_LOWEST = 20,
}
#[test]
fn bindgen_test_layout_nsISupportsPriority() {
    assert_eq!(::std::mem::size_of::<nsISupportsPriority>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsISupportsPriority>() , 8usize);
}
impl Clone for nsISupportsPriority {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsISecurityInfoProvider {
    pub _base: nsISupports,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsISecurityInfoProvider_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsISecurityInfoProvider() {
    assert_eq!(::std::mem::size_of::<nsISecurityInfoProvider>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsISecurityInfoProvider>() , 8usize);
}
impl Clone for nsISecurityInfoProvider {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsITimedChannel {
    pub _base: nsISupports,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsITimedChannel_COMTypeInfo<T, U> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[test]
fn bindgen_test_layout_nsITimedChannel() {
    assert_eq!(::std::mem::size_of::<nsITimedChannel>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsITimedChannel>() , 8usize);
}
impl Clone for nsITimedChannel {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct GridNamedArea {
    pub mName: nsString,
    pub mColumnStart: u32,
    pub mColumnEnd: u32,
    pub mRowStart: u32,
    pub mRowEnd: u32,
}
#[test]
fn bindgen_test_layout_GridNamedArea() {
    assert_eq!(::std::mem::size_of::<GridNamedArea>() , 32usize);
    assert_eq!(::std::mem::align_of::<GridNamedArea>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct GridTemplateAreasValue {
    pub mNamedAreas: nsTArray<GridNamedArea>,
    pub mTemplates: nsTArray<nsString>,
    pub mNColumns: u32,
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
}
pub type GridTemplateAreasValue_HasThreadSafeRefCnt = FalseType;
#[test]
fn bindgen_test_layout_GridTemplateAreasValue() {
    assert_eq!(::std::mem::size_of::<GridTemplateAreasValue>() , 40usize);
    assert_eq!(::std::mem::align_of::<GridTemplateAreasValue>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct FontFamilyListRefCnt {
    pub _base: FontFamilyList,
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
}
pub type FontFamilyListRefCnt_HasThreadSafeRefCnt = FalseType;
#[test]
fn bindgen_test_layout_FontFamilyListRefCnt() {
    assert_eq!(::std::mem::size_of::<FontFamilyListRefCnt>() , 32usize);
    assert_eq!(::std::mem::align_of::<FontFamilyListRefCnt>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RGBAColorData {
    pub mR: f32,
    pub mG: f32,
    pub mB: f32,
    pub mA: f32,
}
#[test]
fn bindgen_test_layout_RGBAColorData() {
    assert_eq!(::std::mem::size_of::<RGBAColorData>() , 16usize);
    assert_eq!(::std::mem::align_of::<RGBAColorData>() , 4usize);
}
impl Clone for RGBAColorData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ComplexColorData {
    pub mColor: RGBAColorData,
    pub mForegroundRatio: f32,
}
#[test]
fn bindgen_test_layout_ComplexColorData() {
    assert_eq!(::std::mem::size_of::<ComplexColorData>() , 20usize);
    assert_eq!(::std::mem::align_of::<ComplexColorData>() , 4usize);
}
impl Clone for ComplexColorData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct ComplexColorValue {
    pub _base: ComplexColorData,
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
}
pub type ComplexColorValue_HasThreadSafeRefCnt = FalseType;
#[test]
fn bindgen_test_layout_ComplexColorValue() {
    assert_eq!(::std::mem::size_of::<ComplexColorValue>() , 40usize);
    assert_eq!(::std::mem::align_of::<ComplexColorValue>() , 8usize);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsCSSUnit {
    eCSSUnit_Null = 0,
    eCSSUnit_Auto = 1,
    eCSSUnit_Inherit = 2,
    eCSSUnit_Initial = 3,
    eCSSUnit_Unset = 4,
    eCSSUnit_None = 5,
    eCSSUnit_Normal = 6,
    eCSSUnit_System_Font = 7,
    eCSSUnit_All = 8,
    eCSSUnit_Dummy = 9,
    eCSSUnit_DummyInherit = 10,
    eCSSUnit_String = 11,
    eCSSUnit_Ident = 12,
    eCSSUnit_Attr = 14,
    eCSSUnit_Local_Font = 15,
    eCSSUnit_Font_Format = 16,
    eCSSUnit_Element = 17,
    eCSSUnit_Array = 20,
    eCSSUnit_Counter = 21,
    eCSSUnit_Counters = 22,
    eCSSUnit_Cubic_Bezier = 23,
    eCSSUnit_Steps = 24,
    eCSSUnit_Symbols = 25,
    eCSSUnit_Function = 26,
    eCSSUnit_Calc = 30,
    eCSSUnit_Calc_Plus = 31,
    eCSSUnit_Calc_Minus = 32,
    eCSSUnit_Calc_Times_L = 33,
    eCSSUnit_Calc_Times_R = 34,
    eCSSUnit_Calc_Divided = 35,
    eCSSUnit_URL = 40,
    eCSSUnit_Image = 41,
    eCSSUnit_Gradient = 42,
    eCSSUnit_TokenStream = 43,
    eCSSUnit_GridTemplateAreas = 44,
    eCSSUnit_Pair = 50,
    eCSSUnit_Triplet = 51,
    eCSSUnit_Rect = 52,
    eCSSUnit_List = 53,
    eCSSUnit_ListDep = 54,
    eCSSUnit_SharedList = 55,
    eCSSUnit_PairList = 56,
    eCSSUnit_PairListDep = 57,
    eCSSUnit_FontFamilyList = 58,
    eCSSUnit_Integer = 70,
    eCSSUnit_Enumerated = 71,
    eCSSUnit_EnumColor = 80,
    eCSSUnit_RGBColor = 81,
    eCSSUnit_RGBAColor = 82,
    eCSSUnit_HexColor = 83,
    eCSSUnit_ShortHexColor = 84,
    eCSSUnit_HexColorAlpha = 85,
    eCSSUnit_ShortHexColorAlpha = 86,
    eCSSUnit_PercentageRGBColor = 87,
    eCSSUnit_PercentageRGBAColor = 88,
    eCSSUnit_HSLColor = 89,
    eCSSUnit_HSLAColor = 90,
    eCSSUnit_ComplexColor = 91,
    eCSSUnit_Percent = 100,
    eCSSUnit_Number = 101,
    eCSSUnit_PhysicalMillimeter = 200,
    eCSSUnit_ViewportWidth = 700,
    eCSSUnit_ViewportHeight = 701,
    eCSSUnit_ViewportMin = 702,
    eCSSUnit_ViewportMax = 703,
    eCSSUnit_EM = 800,
    eCSSUnit_XHeight = 801,
    eCSSUnit_Char = 802,
    eCSSUnit_RootEM = 803,
    eCSSUnit_Point = 900,
    eCSSUnit_Inch = 901,
    eCSSUnit_Millimeter = 902,
    eCSSUnit_Centimeter = 903,
    eCSSUnit_Pica = 904,
    eCSSUnit_Quarter = 905,
    eCSSUnit_Pixel = 906,
    eCSSUnit_Degree = 1000,
    eCSSUnit_Grad = 1001,
    eCSSUnit_Radian = 1002,
    eCSSUnit_Turn = 1003,
    eCSSUnit_Hertz = 2000,
    eCSSUnit_Kilohertz = 2001,
    eCSSUnit_Seconds = 3000,
    eCSSUnit_Milliseconds = 3001,
    eCSSUnit_FlexFraction = 4000,
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValueGradient {
    pub mIsRadial: bool,
    pub mIsRepeating: bool,
    pub mIsLegacySyntax: bool,
    pub mIsExplicitSize: bool,
    pub mBgPos: nsCSSValuePair,
    pub mAngle: nsCSSValue,
    pub mRadialValues: [nsCSSValue; 2usize],
    pub mStops: nsTArray<nsCSSValueGradientStop>,
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
}
pub type nsCSSValueGradient_HasThreadSafeRefCnt = FalseType;
#[test]
fn bindgen_test_layout_nsCSSValueGradient() {
    assert_eq!(::std::mem::size_of::<nsCSSValueGradient>() , 112usize);
    assert_eq!(::std::mem::align_of::<nsCSSValueGradient>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValuePair {
    pub mXValue: nsCSSValue,
    pub mYValue: nsCSSValue,
}
#[test]
fn bindgen_test_layout_nsCSSValuePair() {
    assert_eq!(::std::mem::size_of::<nsCSSValuePair>() , 32usize);
    assert_eq!(::std::mem::align_of::<nsCSSValuePair>() , 8usize);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Serialization { eNormalized = 0, eAuthorSpecified = 1, }
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValuePair_heap {
    pub _base: nsCSSValuePair,
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
}
pub type nsCSSValuePair_heap_HasThreadSafeRefCnt = FalseType;
#[test]
fn bindgen_test_layout_nsCSSValuePair_heap() {
    assert_eq!(::std::mem::size_of::<nsCSSValuePair_heap>() , 48usize);
    assert_eq!(::std::mem::align_of::<nsCSSValuePair_heap>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValueTokenStream {
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    pub mPropertyID: nsCSSPropertyID,
    pub mShorthandPropertyID: nsCSSPropertyID,
    pub mTokenStream: nsString,
    pub mBaseURI: nsCOMPtr<nsIURI>,
    pub mSheetURI: nsCOMPtr<nsIURI>,
    pub mSheetPrincipal: nsCOMPtr<nsIPrincipal>,
    pub mLineNumber: u32,
    pub mLineOffset: u32,
    pub mLevel: SheetType,
}
pub type nsCSSValueTokenStream_HasThreadSafeRefCnt = FalseType;
#[test]
fn bindgen_test_layout_nsCSSValueTokenStream() {
    assert_eq!(::std::mem::size_of::<nsCSSValueTokenStream>() , 80usize);
    assert_eq!(::std::mem::align_of::<nsCSSValueTokenStream>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSRect {
    pub mTop: nsCSSValue,
    pub mRight: nsCSSValue,
    pub mBottom: nsCSSValue,
    pub mLeft: nsCSSValue,
}
pub type nsCSSRect_side_type = *mut nsCSSValue;
extern "C" {
    #[link_name = "_ZN9nsCSSRect5sidesE"]
    pub static mut nsCSSRect_sides: [nsCSSRect_side_type; 4usize];
}
#[test]
fn bindgen_test_layout_nsCSSRect() {
    assert_eq!(::std::mem::size_of::<nsCSSRect>() , 64usize);
    assert_eq!(::std::mem::align_of::<nsCSSRect>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSRect_heap {
    pub _base: nsCSSRect,
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
}
pub type nsCSSRect_heap_HasThreadSafeRefCnt = FalseType;
#[test]
fn bindgen_test_layout_nsCSSRect_heap() {
    assert_eq!(::std::mem::size_of::<nsCSSRect_heap>() , 80usize);
    assert_eq!(::std::mem::align_of::<nsCSSRect_heap>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValueList {
    pub mValue: nsCSSValue,
    pub mNext: *mut nsCSSValueList,
}
#[test]
fn bindgen_test_layout_nsCSSValueList() {
    assert_eq!(::std::mem::size_of::<nsCSSValueList>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsCSSValueList>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValueList_heap {
    pub _base: nsCSSValueList,
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
}
pub type nsCSSValueList_heap_HasThreadSafeRefCnt = FalseType;
#[test]
fn bindgen_test_layout_nsCSSValueList_heap() {
    assert_eq!(::std::mem::size_of::<nsCSSValueList_heap>() , 40usize);
    assert_eq!(::std::mem::align_of::<nsCSSValueList_heap>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValueSharedList {
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    pub mHead: *mut nsCSSValueList,
}
pub type nsCSSValueSharedList_HasThreadSafeRefCnt = FalseType;
#[test]
fn bindgen_test_layout_nsCSSValueSharedList() {
    assert_eq!(::std::mem::size_of::<nsCSSValueSharedList>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsCSSValueSharedList>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValuePairList {
    pub mXValue: nsCSSValue,
    pub mYValue: nsCSSValue,
    pub mNext: *mut nsCSSValuePairList,
}
#[test]
fn bindgen_test_layout_nsCSSValuePairList() {
    assert_eq!(::std::mem::size_of::<nsCSSValuePairList>() , 40usize);
    assert_eq!(::std::mem::align_of::<nsCSSValuePairList>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValuePairList_heap {
    pub _base: nsCSSValuePairList,
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
}
pub type nsCSSValuePairList_heap_HasThreadSafeRefCnt = FalseType;
#[test]
fn bindgen_test_layout_nsCSSValuePairList_heap() {
    assert_eq!(::std::mem::size_of::<nsCSSValuePairList_heap>() , 56usize);
    assert_eq!(::std::mem::align_of::<nsCSSValuePairList_heap>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValueTriplet {
    pub mXValue: nsCSSValue,
    pub mYValue: nsCSSValue,
    pub mZValue: nsCSSValue,
}
#[test]
fn bindgen_test_layout_nsCSSValueTriplet() {
    assert_eq!(::std::mem::size_of::<nsCSSValueTriplet>() , 48usize);
    assert_eq!(::std::mem::align_of::<nsCSSValueTriplet>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValueTriplet_heap {
    pub _base: nsCSSValueTriplet,
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
}
pub type nsCSSValueTriplet_heap_HasThreadSafeRefCnt = FalseType;
#[test]
fn bindgen_test_layout_nsCSSValueTriplet_heap() {
    assert_eq!(::std::mem::size_of::<nsCSSValueTriplet_heap>() , 64usize);
    assert_eq!(::std::mem::align_of::<nsCSSValueTriplet_heap>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValueFloatColor {
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    pub mComponent1: f32,
    pub mComponent2: f32,
    pub mComponent3: f32,
    pub mAlpha: f32,
}
pub type nsCSSValueFloatColor_HasThreadSafeRefCnt = FalseType;
#[test]
fn bindgen_test_layout_nsCSSValueFloatColor() {
    assert_eq!(::std::mem::size_of::<nsCSSValueFloatColor>() , 32usize);
    assert_eq!(::std::mem::align_of::<nsCSSValueFloatColor>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValue {
    pub mUnit: nsCSSUnit,
    pub mValue: nsCSSValue__bindgen_ty_bindgen_id_211506,
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValue_Array {
    pub mRefCnt: usize,
    pub mCount: usize,
    pub mArray: [nsCSSValue; 1usize],
}
#[test]
fn bindgen_test_layout_nsCSSValue_Array() {
    assert_eq!(::std::mem::size_of::<nsCSSValue_Array>() , 32usize);
    assert_eq!(::std::mem::align_of::<nsCSSValue_Array>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsCSSValue__bindgen_ty_bindgen_id_211506 {
    pub mInt: __BindgenUnionField<i32>,
    pub mFloat: __BindgenUnionField<f32>,
    pub mString: __BindgenUnionField<*mut nsStringBuffer>,
    pub mColor: __BindgenUnionField<nscolor>,
    pub mArray: __BindgenUnionField<*mut nsCSSValue_Array>,
    pub mURL: __BindgenUnionField<*mut URLValue>,
    pub mImage: __BindgenUnionField<*mut ImageValue>,
    pub mGridTemplateAreas: __BindgenUnionField<*mut GridTemplateAreasValue>,
    pub mGradient: __BindgenUnionField<*mut nsCSSValueGradient>,
    pub mTokenStream: __BindgenUnionField<*mut nsCSSValueTokenStream>,
    pub mPair: __BindgenUnionField<*mut nsCSSValuePair_heap>,
    pub mRect: __BindgenUnionField<*mut nsCSSRect_heap>,
    pub mTriplet: __BindgenUnionField<*mut nsCSSValueTriplet_heap>,
    pub mList: __BindgenUnionField<*mut nsCSSValueList_heap>,
    pub mListDependent: __BindgenUnionField<*mut nsCSSValueList>,
    pub mSharedList: __BindgenUnionField<*mut nsCSSValueSharedList>,
    pub mPairList: __BindgenUnionField<*mut nsCSSValuePairList_heap>,
    pub mPairListDependent: __BindgenUnionField<*mut nsCSSValuePairList>,
    pub mFloatColor: __BindgenUnionField<*mut nsCSSValueFloatColor>,
    pub mFontFamilyList: __BindgenUnionField<*mut FontFamilyListRefCnt>,
    pub mComplexColor: __BindgenUnionField<*mut ComplexColorValue>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_nsCSSValue__bindgen_ty_bindgen_id_211506() {
    assert_eq!(::std::mem::size_of::<nsCSSValue__bindgen_ty_bindgen_id_211506>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<nsCSSValue__bindgen_ty_bindgen_id_211506>()
               , 8usize);
}
impl Clone for nsCSSValue__bindgen_ty_bindgen_id_211506 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsCSSValue() {
    assert_eq!(::std::mem::size_of::<nsCSSValue>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsCSSValue>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValueGradientStop {
    pub mLocation: nsCSSValue,
    pub mColor: nsCSSValue,
    pub mIsInterpolationHint: bool,
}
#[test]
fn bindgen_test_layout_nsCSSValueGradientStop() {
    assert_eq!(::std::mem::size_of::<nsCSSValueGradientStop>() , 40usize);
    assert_eq!(::std::mem::align_of::<nsCSSValueGradientStop>() , 8usize);
}
#[repr(C)]
pub struct bindgen_vtable__bindgen_id_211714 {
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CounterStyle {
    pub vtable_: *const bindgen_vtable__bindgen_id_211714,
    pub mStyle: i32,
}
#[test]
fn bindgen_test_layout_CounterStyle() {
    assert_eq!(::std::mem::size_of::<CounterStyle>() , 16usize);
    assert_eq!(::std::mem::align_of::<CounterStyle>() , 8usize);
}
impl Clone for CounterStyle {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LookAndFeelInt {
    pub id: i32,
    pub value: i32,
}
#[test]
fn bindgen_test_layout_LookAndFeelInt() {
    assert_eq!(::std::mem::size_of::<LookAndFeelInt>() , 8usize);
    assert_eq!(::std::mem::align_of::<LookAndFeelInt>() , 4usize);
}
impl Clone for LookAndFeelInt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct imgIContainer {
    pub _address: u8,
}
impl Clone for imgIContainer {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ImageURL {
    pub _address: u8,
}
impl Clone for ImageURL {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Image {
    pub _address: u8,
}
impl Clone for Image {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ProgressTracker {
    pub _address: u8,
}
impl Clone for ProgressTracker {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ProxyBehaviour {
    pub _address: u8,
}
impl Clone for ProxyBehaviour {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleVisibility {
    pub mImageOrientation: nsStyleImageOrientation,
    pub mDirection: u8,
    pub mVisible: u8,
    pub mImageRendering: u8,
    pub mWritingMode: u8,
    pub mTextOrientation: u8,
    pub mColorAdjust: u8,
}
#[test]
fn bindgen_test_layout_nsStyleVisibility() {
    assert_eq!(::std::mem::size_of::<nsStyleVisibility>() , 7usize);
    assert_eq!(::std::mem::align_of::<nsStyleVisibility>() , 1usize);
}
pub type RawGeckoNode = nsINode;
pub type RawGeckoElement = Element;
pub type RawGeckoDocument = nsIDocument;
#[repr(C)]
#[derive(Debug)]
pub struct FragmentOrURL {
    pub mURL: nsCOMPtr<nsIURI>,
    pub mIsLocalRef: bool,
}
#[test]
fn bindgen_test_layout_FragmentOrURL() {
    assert_eq!(::std::mem::size_of::<FragmentOrURL>() , 16usize);
    assert_eq!(::std::mem::align_of::<FragmentOrURL>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Position {
    pub mXPosition: Position_Coord,
    pub mYPosition: Position_Coord,
}
pub type Position_Coord = nsStyleCoord_CalcValue;
#[test]
fn bindgen_test_layout_Position() {
    assert_eq!(::std::mem::size_of::<Position>() , 24usize);
    assert_eq!(::std::mem::align_of::<Position>() , 4usize);
}
impl Clone for Position {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleFont {
    pub mFont: nsFont,
    pub mSize: nscoord,
    pub mGenericID: u8,
    pub mScriptLevel: i8,
    pub mMathVariant: u8,
    pub mMathDisplay: u8,
    pub mMinFontSizeRatio: u8,
    pub mExplicitLanguage: bool,
    pub mAllowZoom: bool,
    pub mScriptUnconstrainedSize: nscoord,
    pub mScriptMinSize: nscoord,
    pub mScriptSizeMultiplier: f32,
    pub mLanguage: nsCOMPtr<nsIAtom>,
}
#[test]
fn bindgen_test_layout_nsStyleFont() {
    assert_eq!(::std::mem::size_of::<nsStyleFont>() , 120usize);
    assert_eq!(::std::mem::align_of::<nsStyleFont>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleGradientStop {
    pub mLocation: nsStyleCoord,
    pub mColor: nscolor,
    pub mIsInterpolationHint: bool,
}
#[test]
fn bindgen_test_layout_nsStyleGradientStop() {
    assert_eq!(::std::mem::size_of::<nsStyleGradientStop>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsStyleGradientStop>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleGradient {
    pub mShape: u8,
    pub mSize: u8,
    pub mRepeating: bool,
    pub mLegacySyntax: bool,
    pub mBgPosX: nsStyleCoord,
    pub mBgPosY: nsStyleCoord,
    pub mAngle: nsStyleCoord,
    pub mRadiusX: nsStyleCoord,
    pub mRadiusY: nsStyleCoord,
    pub mStops: nsTArray<nsStyleGradientStop>,
    pub mRefCnt: ThreadSafeAutoRefCnt,
}
pub type nsStyleGradient_HasThreadSafeRefCnt = TrueType;
#[test]
fn bindgen_test_layout_nsStyleGradient() {
    assert_eq!(::std::mem::size_of::<nsStyleGradient>() , 104usize);
    assert_eq!(::std::mem::align_of::<nsStyleGradient>() , 8usize);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsStyleImageType {
    eStyleImageType_Null = 0,
    eStyleImageType_Image = 1,
    eStyleImageType_Gradient = 2,
    eStyleImageType_Element = 3,
}
#[repr(C)]
#[derive(Debug)]
pub struct CachedBorderImageData {
    pub mCachedSVGViewportSize: [u64; 2usize],
    pub mSubImages: nsCOMArray<imgIContainer>,
}
#[test]
fn bindgen_test_layout_CachedBorderImageData() {
    assert_eq!(::std::mem::size_of::<CachedBorderImageData>() , 24usize);
    assert_eq!(::std::mem::align_of::<CachedBorderImageData>() , 8usize);
}
/**
 * Represents a paintable image of one of the following types.
 * (1) A real image loaded from an external source.
 * (2) A CSS linear or radial gradient.
 * (3) An element within a document, or an <img>, <video>, or <canvas> element
 *     not in a document.
 * (*) Optionally a crop rect can be set to paint a partial (rectangular)
 * region of an image. (Currently, this feature is only supported with an
 * image of type (1)).
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleImage {
    pub mCachedBIData: UniquePtr<CachedBorderImageData,
                                 DefaultDelete<CachedBorderImageData>>,
    pub mType: nsStyleImageType,
    pub __bindgen_anon_1: nsStyleImage__bindgen_ty_bindgen_id_213682,
    pub mCropRect: UniquePtr<nsStyleSides, DefaultDelete<nsStyleSides>>,
    pub mImageTracked: bool,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleImage__bindgen_ty_bindgen_id_213682 {
    pub mImage: __BindgenUnionField<*mut imgRequestProxy>,
    pub mGradient: __BindgenUnionField<*mut nsStyleGradient>,
    pub mElementId: __BindgenUnionField<*mut u16>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_nsStyleImage__bindgen_ty_bindgen_id_213682() {
    assert_eq!(::std::mem::size_of::<nsStyleImage__bindgen_ty_bindgen_id_213682>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<nsStyleImage__bindgen_ty_bindgen_id_213682>()
               , 8usize);
}
impl Clone for nsStyleImage__bindgen_ty_bindgen_id_213682 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsStyleImage() {
    assert_eq!(::std::mem::size_of::<nsStyleImage>() , 40usize);
    assert_eq!(::std::mem::align_of::<nsStyleImage>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleColor {
    pub mColor: nscolor,
}
#[test]
fn bindgen_test_layout_nsStyleColor() {
    assert_eq!(::std::mem::size_of::<nsStyleColor>() , 4usize);
    assert_eq!(::std::mem::align_of::<nsStyleColor>() , 4usize);
}
/**
 * An array of objects, similar to AutoTArray<T,1> but which is memmovable. It
 * always has length >= 1.
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleAutoArray<T> {
    pub mFirstElement: T,
    pub mOtherElements: nsTArray<T>,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsStyleAutoArray_WithSingleInitialElement {
    WITH_SINGLE_INITIAL_ELEMENT = 0,
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleImageLayers {
    pub mAttachmentCount: u32,
    pub mClipCount: u32,
    pub mOriginCount: u32,
    pub mRepeatCount: u32,
    pub mPositionXCount: u32,
    pub mPositionYCount: u32,
    pub mImageCount: u32,
    pub mSizeCount: u32,
    pub mMaskModeCount: u32,
    pub mBlendModeCount: u32,
    pub mCompositeCount: u32,
    pub mLayers: nsStyleAutoArray<nsStyleImageLayers_Layer>,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsStyleImageLayers__bindgen_ty_bindgen_id_213737 {
    shorthand = 0,
    color = 1,
    image = 2,
    repeat = 3,
    positionX = 4,
    positionY = 5,
    clip = 6,
    origin = 7,
    size = 8,
    attachment = 9,
    maskMode = 10,
    composite = 11,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsStyleImageLayers_LayerType { Background = 0, Mask = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleImageLayers_Size {
    pub mWidth: nsStyleImageLayers_Size_Dimension,
    pub mHeight: nsStyleImageLayers_Size_Dimension,
    pub mWidthType: u8,
    pub mHeightType: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleImageLayers_Size_Dimension {
    pub _base: nsStyleCoord_CalcValue,
}
#[test]
fn bindgen_test_layout_nsStyleImageLayers_Size_Dimension() {
    assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Size_Dimension>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<nsStyleImageLayers_Size_Dimension>() ,
               4usize);
}
impl Clone for nsStyleImageLayers_Size_Dimension {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsStyleImageLayers_Size_DimensionType {
    eContain = 0,
    eCover = 1,
    eAuto = 2,
    eLengthPercentage = 3,
    eDimensionType_COUNT = 4,
}
#[test]
fn bindgen_test_layout_nsStyleImageLayers_Size() {
    assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Size>() , 28usize);
    assert_eq!(::std::mem::align_of::<nsStyleImageLayers_Size>() , 4usize);
}
impl Clone for nsStyleImageLayers_Size {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleImageLayers_Repeat {
    pub mXRepeat: u8,
    pub mYRepeat: u8,
}
#[test]
fn bindgen_test_layout_nsStyleImageLayers_Repeat() {
    assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Repeat>() , 2usize);
    assert_eq!(::std::mem::align_of::<nsStyleImageLayers_Repeat>() , 1usize);
}
impl Clone for nsStyleImageLayers_Repeat {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleImageLayers_Layer {
    pub mImage: nsStyleImage,
    pub mSourceURI: FragmentOrURL,
    pub mPosition: Position,
    pub mSize: nsStyleImageLayers_Size,
    pub mClip: u8,
    pub mOrigin: u8,
    pub mAttachment: u8,
    pub mBlendMode: u8,
    pub mComposite: u8,
    pub mMaskMode: u8,
    pub mRepeat: nsStyleImageLayers_Repeat,
}
#[test]
fn bindgen_test_layout_nsStyleImageLayers_Layer() {
    assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Layer>() , 120usize);
    assert_eq!(::std::mem::align_of::<nsStyleImageLayers_Layer>() , 8usize);
}
extern "C" {
    #[link_name = "_ZN18nsStyleImageLayers21kBackgroundLayerTableE"]
    pub static mut nsStyleImageLayers_kBackgroundLayerTable:
               *const nsCSSPropertyID;
}
extern "C" {
    #[link_name = "_ZN18nsStyleImageLayers15kMaskLayerTableE"]
    pub static mut nsStyleImageLayers_kMaskLayerTable: *const nsCSSPropertyID;
}
#[test]
fn bindgen_test_layout_nsStyleImageLayers() {
    assert_eq!(::std::mem::size_of::<nsStyleImageLayers>() , 176usize);
    assert_eq!(::std::mem::align_of::<nsStyleImageLayers>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleBackground {
    pub mImage: nsStyleImageLayers,
    pub mBackgroundColor: nscolor,
}
#[test]
fn bindgen_test_layout_nsStyleBackground() {
    assert_eq!(::std::mem::size_of::<nsStyleBackground>() , 184usize);
    assert_eq!(::std::mem::align_of::<nsStyleBackground>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleMargin {
    pub mMargin: nsStyleSides,
}
#[test]
fn bindgen_test_layout_nsStyleMargin() {
    assert_eq!(::std::mem::size_of::<nsStyleMargin>() , 40usize);
    assert_eq!(::std::mem::align_of::<nsStyleMargin>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStylePadding {
    pub mPadding: nsStyleSides,
}
#[test]
fn bindgen_test_layout_nsStylePadding() {
    assert_eq!(::std::mem::size_of::<nsStylePadding>() , 40usize);
    assert_eq!(::std::mem::align_of::<nsStylePadding>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsBorderColors {
    pub mNext: *mut nsBorderColors,
    pub mColor: nscolor,
}
#[test]
fn bindgen_test_layout_nsBorderColors() {
    assert_eq!(::std::mem::size_of::<nsBorderColors>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsBorderColors>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSShadowItem {
    pub mXOffset: nscoord,
    pub mYOffset: nscoord,
    pub mRadius: nscoord,
    pub mSpread: nscoord,
    pub mColor: nscolor,
    pub mHasColor: bool,
    pub mInset: bool,
}
#[test]
fn bindgen_test_layout_nsCSSShadowItem() {
    assert_eq!(::std::mem::size_of::<nsCSSShadowItem>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsCSSShadowItem>() , 4usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSShadowArray {
    pub mRefCnt: ThreadSafeAutoRefCnt,
    pub mLength: u32,
    pub mArray: [nsCSSShadowItem; 1usize],
}
pub type nsCSSShadowArray_HasThreadSafeRefCnt = TrueType;
#[test]
fn bindgen_test_layout_nsCSSShadowArray() {
    assert_eq!(::std::mem::size_of::<nsCSSShadowArray>() , 40usize);
    assert_eq!(::std::mem::align_of::<nsCSSShadowArray>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleBorder {
    pub mBorderColors: *mut *mut nsBorderColors,
    pub mBorderRadius: nsStyleCorners,
    pub mBorderImageSource: nsStyleImage,
    pub mBorderImageSlice: nsStyleSides,
    pub mBorderImageWidth: nsStyleSides,
    pub mBorderImageOutset: nsStyleSides,
    pub mBorderImageFill: u8,
    pub mBorderImageRepeatH: u8,
    pub mBorderImageRepeatV: u8,
    pub mFloatEdge: StyleFloatEdge,
    pub mBoxDecorationBreak: StyleBoxDecorationBreak,
    pub mBorderStyle: [u8; 4usize],
    pub __bindgen_anon_1: nsStyleBorder__bindgen_ty_bindgen_id_214411,
    pub mComputedBorder: nsMargin,
    pub mBorder: nsMargin,
    pub mTwipsPerPixel: nscoord,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleBorder__bindgen_ty_bindgen_id_214411 {
    pub __bindgen_anon_1: __BindgenUnionField<nsStyleBorder__bindgen_ty_bindgen_id_214411__bindgen_ty_bindgen_id_214412>,
    pub mBorderColor: __BindgenUnionField<[StyleComplexColor; 4usize]>,
    pub bindgen_union_field: [u32; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleBorder__bindgen_ty_bindgen_id_214411__bindgen_ty_bindgen_id_214412 {
    pub mBorderTopColor: StyleComplexColor,
    pub mBorderRightColor: StyleComplexColor,
    pub mBorderBottomColor: StyleComplexColor,
    pub mBorderLeftColor: StyleComplexColor,
}
#[test]
fn bindgen_test_layout_nsStyleBorder__bindgen_ty_bindgen_id_214411__bindgen_ty_bindgen_id_214412() {
    assert_eq!(::std::mem::size_of::<nsStyleBorder__bindgen_ty_bindgen_id_214411__bindgen_ty_bindgen_id_214412>()
               , 32usize);
    assert_eq!(::std::mem::align_of::<nsStyleBorder__bindgen_ty_bindgen_id_214411__bindgen_ty_bindgen_id_214412>()
               , 4usize);
}
impl Clone for
 nsStyleBorder__bindgen_ty_bindgen_id_214411__bindgen_ty_bindgen_id_214412 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsStyleBorder__bindgen_ty_bindgen_id_214411() {
    assert_eq!(::std::mem::size_of::<nsStyleBorder__bindgen_ty_bindgen_id_214411>()
               , 32usize);
    assert_eq!(::std::mem::align_of::<nsStyleBorder__bindgen_ty_bindgen_id_214411>()
               , 4usize);
}
impl Clone for nsStyleBorder__bindgen_ty_bindgen_id_214411 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsStyleBorder() {
    assert_eq!(::std::mem::size_of::<nsStyleBorder>() , 320usize);
    assert_eq!(::std::mem::align_of::<nsStyleBorder>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleOutline {
    pub mOutlineRadius: nsStyleCorners,
    pub mOutlineWidth: nsStyleCoord,
    pub mOutlineOffset: nscoord,
    pub mOutlineColor: StyleComplexColor,
    pub mOutlineStyle: u8,
    pub mActualOutlineWidth: nscoord,
    pub mTwipsPerPixel: nscoord,
}
#[test]
fn bindgen_test_layout_nsStyleOutline() {
    assert_eq!(::std::mem::size_of::<nsStyleOutline>() , 112usize);
    assert_eq!(::std::mem::align_of::<nsStyleOutline>() , 8usize);
}
/**
 * An object that allows sharing of arrays that store 'quotes' property
 * values.  This is particularly important for inheritance, where we want
 * to share the same 'quotes' value with a parent style context.
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleQuoteValues {
    pub mRefCnt: ThreadSafeAutoRefCnt,
    pub mQuotePairs: nsStyleQuoteValues_QuotePairArray,
}
pub type nsStyleQuoteValues_QuotePairArray =
    nsTArray<pair<nsString, nsString>>;
pub type nsStyleQuoteValues_HasThreadSafeRefCnt = TrueType;
#[test]
fn bindgen_test_layout_nsStyleQuoteValues() {
    assert_eq!(::std::mem::size_of::<nsStyleQuoteValues>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsStyleQuoteValues>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleList {
    pub mListStylePosition: u8,
    pub mCounterStyle: RefPtr<CounterStyle>,
    pub mListStyleImage: RefPtr<imgRequestProxy>,
    pub mQuotes: RefPtr<nsStyleQuoteValues>,
    pub mImageRegion: nsRect,
}
extern "C" {
    #[link_name = "_ZN11nsStyleList14sInitialQuotesE"]
    pub static mut nsStyleList_sInitialQuotes:
               StaticRefPtr<nsStyleQuoteValues>;
}
extern "C" {
    #[link_name = "_ZN11nsStyleList11sNoneQuotesE"]
    pub static mut nsStyleList_sNoneQuotes: StaticRefPtr<nsStyleQuoteValues>;
}
#[test]
fn bindgen_test_layout_nsStyleList() {
    assert_eq!(::std::mem::size_of::<nsStyleList>() , 48usize);
    assert_eq!(::std::mem::align_of::<nsStyleList>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleGridLine {
    pub mHasSpan: bool,
    pub mInteger: i32,
    pub mLineName: nsString,
}
extern "C" {
    #[link_name = "_ZN15nsStyleGridLine8kMinLineE"]
    pub static nsStyleGridLine_kMinLine: i32;
}
extern "C" {
    #[link_name = "_ZN15nsStyleGridLine8kMaxLineE"]
    pub static nsStyleGridLine_kMaxLine: i32;
}
#[test]
fn bindgen_test_layout_nsStyleGridLine() {
    assert_eq!(::std::mem::size_of::<nsStyleGridLine>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsStyleGridLine>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleGridTemplate {
    pub mLineNameLists: nsTArray<nsTArray<nsString>>,
    pub mMinTrackSizingFunctions: nsTArray<nsStyleCoord>,
    pub mMaxTrackSizingFunctions: nsTArray<nsStyleCoord>,
    pub mRepeatAutoLineNameListBefore: nsTArray<nsString>,
    pub mRepeatAutoLineNameListAfter: nsTArray<nsString>,
    pub mRepeatAutoIndex: i16,
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout_nsStyleGridTemplate() {
    assert_eq!(::std::mem::size_of::<nsStyleGridTemplate>() , 48usize);
    assert_eq!(::std::mem::align_of::<nsStyleGridTemplate>() , 8usize);
}
impl nsStyleGridTemplate {
    #[inline]
    pub fn mIsAutoFill(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                       0u32) as u8)
        }
    }
    #[inline]
    pub fn set_mIsAutoFill(&mut self, val: bool) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn mIsSubgrid(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                       1u32) as u8)
        }
    }
    #[inline]
    pub fn set_mIsSubgrid(&mut self, val: bool) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (2usize as u8);
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStylePosition {
    pub mObjectPosition: Position,
    pub mOffset: nsStyleSides,
    pub mWidth: nsStyleCoord,
    pub mMinWidth: nsStyleCoord,
    pub mMaxWidth: nsStyleCoord,
    pub mHeight: nsStyleCoord,
    pub mMinHeight: nsStyleCoord,
    pub mMaxHeight: nsStyleCoord,
    pub mFlexBasis: nsStyleCoord,
    pub mGridAutoColumnsMin: nsStyleCoord,
    pub mGridAutoColumnsMax: nsStyleCoord,
    pub mGridAutoRowsMin: nsStyleCoord,
    pub mGridAutoRowsMax: nsStyleCoord,
    pub mGridAutoFlow: u8,
    pub mBoxSizing: StyleBoxSizing,
    pub mAlignContent: u16,
    pub mAlignItems: u8,
    pub mAlignSelf: u8,
    pub mJustifyContent: u16,
    pub mJustifyItems: u8,
    pub mJustifySelf: u8,
    pub mFlexDirection: u8,
    pub mFlexWrap: u8,
    pub mObjectFit: u8,
    pub mOrder: i32,
    pub mFlexGrow: f32,
    pub mFlexShrink: f32,
    pub mZIndex: nsStyleCoord,
    pub mGridTemplateColumns: nsStyleGridTemplate,
    pub mGridTemplateRows: nsStyleGridTemplate,
    pub mGridTemplateAreas: RefPtr<GridTemplateAreasValue>,
    pub mGridColumnStart: nsStyleGridLine,
    pub mGridColumnEnd: nsStyleGridLine,
    pub mGridRowStart: nsStyleGridLine,
    pub mGridRowEnd: nsStyleGridLine,
    pub mGridColumnGap: nsStyleCoord,
    pub mGridRowGap: nsStyleCoord,
}
#[test]
fn bindgen_test_layout_nsStylePosition() {
    assert_eq!(::std::mem::size_of::<nsStylePosition>() , 520usize);
    assert_eq!(::std::mem::align_of::<nsStylePosition>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleTextOverflowSide {
    pub mString: nsString,
    pub mType: u8,
}
#[test]
fn bindgen_test_layout_nsStyleTextOverflowSide() {
    assert_eq!(::std::mem::size_of::<nsStyleTextOverflowSide>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsStyleTextOverflowSide>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleTextOverflow {
    pub mLeft: nsStyleTextOverflowSide,
    pub mRight: nsStyleTextOverflowSide,
    pub mLogicalDirections: bool,
}
#[test]
fn bindgen_test_layout_nsStyleTextOverflow() {
    assert_eq!(::std::mem::size_of::<nsStyleTextOverflow>() , 56usize);
    assert_eq!(::std::mem::align_of::<nsStyleTextOverflow>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleTextReset {
    pub mTextOverflow: nsStyleTextOverflow,
    pub mTextDecorationLine: u8,
    pub mTextDecorationStyle: u8,
    pub mUnicodeBidi: u8,
    pub mInitialLetterSink: nscoord,
    pub mInitialLetterSize: f32,
    pub mTextDecorationColor: StyleComplexColor,
}
#[test]
fn bindgen_test_layout_nsStyleTextReset() {
    assert_eq!(::std::mem::size_of::<nsStyleTextReset>() , 80usize);
    assert_eq!(::std::mem::align_of::<nsStyleTextReset>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleText {
    pub mTextAlign: u8,
    pub mTextAlignLast: u8,
    pub _bitfield_1: u8,
    pub mTextTransform: u8,
    pub mWhiteSpace: u8,
    pub mWordBreak: u8,
    pub mOverflowWrap: u8,
    pub mHyphens: u8,
    pub mRubyAlign: u8,
    pub mRubyPosition: u8,
    pub mTextSizeAdjust: u8,
    pub mTextCombineUpright: u8,
    pub mControlCharacterVisibility: u8,
    pub mTextEmphasisPosition: u8,
    pub mTextEmphasisStyle: u8,
    pub mTextRendering: u8,
    pub mTabSize: i32,
    pub mTextEmphasisColor: StyleComplexColor,
    pub mWebkitTextFillColor: StyleComplexColor,
    pub mWebkitTextStrokeColor: StyleComplexColor,
    pub mWordSpacing: nsStyleCoord,
    pub mLetterSpacing: nsStyleCoord,
    pub mLineHeight: nsStyleCoord,
    pub mTextIndent: nsStyleCoord,
    pub mWebkitTextStrokeWidth: nsStyleCoord,
    pub mTextShadow: RefPtr<nsCSSShadowArray>,
    pub mTextEmphasisStyleString: nsString,
}
#[test]
fn bindgen_test_layout_nsStyleText() {
    assert_eq!(::std::mem::size_of::<nsStyleText>() , 152usize);
    assert_eq!(::std::mem::align_of::<nsStyleText>() , 8usize);
}
impl nsStyleText {
    #[inline]
    pub fn mTextAlignTrue(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                       0u32) as u8)
        }
    }
    #[inline]
    pub fn set_mTextAlignTrue(&mut self, val: bool) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn mTextAlignLastTrue(&self) -> bool {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                       1u32) as u8)
        }
    }
    #[inline]
    pub fn set_mTextAlignLastTrue(&mut self, val: bool) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (2usize as u8);
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleImageOrientation {
    pub mOrientation: u8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsStyleImageOrientation_Bits {
    ORIENTATION_MASK = 3,
    FLIP_MASK = 4,
    FROM_IMAGE_MASK = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsStyleImageOrientation_Angles {
    ANGLE_0 = 0,
    ANGLE_90 = 1,
    ANGLE_180 = 2,
    ANGLE_270 = 3,
}
#[test]
fn bindgen_test_layout_nsStyleImageOrientation() {
    assert_eq!(::std::mem::size_of::<nsStyleImageOrientation>() , 1usize);
    assert_eq!(::std::mem::align_of::<nsStyleImageOrientation>() , 1usize);
}
impl Clone for nsStyleImageOrientation {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsTimingFunction {
    pub mType: nsTimingFunction_Type,
    pub __bindgen_anon_1: nsTimingFunction__bindgen_ty_bindgen_id_215389,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsTimingFunction_Type {
    Ease = 0,
    Linear = 1,
    EaseIn = 2,
    EaseOut = 3,
    EaseInOut = 4,
    StepStart = 5,
    StepEnd = 6,
    CubicBezier = 7,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsTimingFunction_Keyword { Implicit = 0, Explicit = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsTimingFunction__bindgen_ty_bindgen_id_215389 {
    pub mFunc: __BindgenUnionField<nsTimingFunction__bindgen_ty_bindgen_id_215389__bindgen_ty_bindgen_id_215390>,
    pub __bindgen_anon_1: __BindgenUnionField<nsTimingFunction__bindgen_ty_bindgen_id_215389__bindgen_ty_bindgen_id_215401>,
    pub bindgen_union_field: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsTimingFunction__bindgen_ty_bindgen_id_215389__bindgen_ty_bindgen_id_215390 {
    pub mX1: f32,
    pub mY1: f32,
    pub mX2: f32,
    pub mY2: f32,
}
#[test]
fn bindgen_test_layout_nsTimingFunction__bindgen_ty_bindgen_id_215389__bindgen_ty_bindgen_id_215390() {
    assert_eq!(::std::mem::size_of::<nsTimingFunction__bindgen_ty_bindgen_id_215389__bindgen_ty_bindgen_id_215390>()
               , 16usize);
    assert_eq!(::std::mem::align_of::<nsTimingFunction__bindgen_ty_bindgen_id_215389__bindgen_ty_bindgen_id_215390>()
               , 4usize);
}
impl Clone for
 nsTimingFunction__bindgen_ty_bindgen_id_215389__bindgen_ty_bindgen_id_215390
 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsTimingFunction__bindgen_ty_bindgen_id_215389__bindgen_ty_bindgen_id_215401 {
    pub mSteps: u32,
}
#[test]
fn bindgen_test_layout_nsTimingFunction__bindgen_ty_bindgen_id_215389__bindgen_ty_bindgen_id_215401() {
    assert_eq!(::std::mem::size_of::<nsTimingFunction__bindgen_ty_bindgen_id_215389__bindgen_ty_bindgen_id_215401>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<nsTimingFunction__bindgen_ty_bindgen_id_215389__bindgen_ty_bindgen_id_215401>()
               , 4usize);
}
impl Clone for
 nsTimingFunction__bindgen_ty_bindgen_id_215389__bindgen_ty_bindgen_id_215401
 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsTimingFunction__bindgen_ty_bindgen_id_215389() {
    assert_eq!(::std::mem::size_of::<nsTimingFunction__bindgen_ty_bindgen_id_215389>()
               , 16usize);
    assert_eq!(::std::mem::align_of::<nsTimingFunction__bindgen_ty_bindgen_id_215389>()
               , 4usize);
}
impl Clone for nsTimingFunction__bindgen_ty_bindgen_id_215389 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsTimingFunction() {
    assert_eq!(::std::mem::size_of::<nsTimingFunction>() , 20usize);
    assert_eq!(::std::mem::align_of::<nsTimingFunction>() , 4usize);
}
impl Clone for nsTimingFunction {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct StyleTransition {
    pub mTimingFunction: nsTimingFunction,
    pub mDuration: f32,
    pub mDelay: f32,
    pub mProperty: nsCSSPropertyID,
    pub mUnknownProperty: nsCOMPtr<nsIAtom>,
}
#[test]
fn bindgen_test_layout_StyleTransition() {
    assert_eq!(::std::mem::size_of::<StyleTransition>() , 40usize);
    assert_eq!(::std::mem::align_of::<StyleTransition>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct StyleAnimation {
    pub mTimingFunction: nsTimingFunction,
    pub mDuration: f32,
    pub mDelay: f32,
    pub mName: nsString,
    pub mDirection: PlaybackDirection,
    pub mFillMode: FillMode,
    pub mPlayState: u8,
    pub mIterationCount: f32,
}
#[test]
fn bindgen_test_layout_StyleAnimation() {
    assert_eq!(::std::mem::size_of::<StyleAnimation>() , 64usize);
    assert_eq!(::std::mem::align_of::<StyleAnimation>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct StyleBasicShape {
    pub mRefCnt: ThreadSafeAutoRefCnt,
    pub mType: StyleBasicShapeType,
    pub mFillRule: StyleFillRule,
    pub mCoordinates: nsTArray<nsStyleCoord>,
    pub mPosition: Position,
    pub mRadius: nsStyleCorners,
}
pub type StyleBasicShape_HasThreadSafeRefCnt = TrueType;
#[test]
fn bindgen_test_layout_StyleBasicShape() {
    assert_eq!(::std::mem::size_of::<StyleBasicShape>() , 120usize);
    assert_eq!(::std::mem::align_of::<StyleBasicShape>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct StyleShapeSource<ReferenceBox> {
    pub __bindgen_anon_1: StyleShapeSource__bindgen_ty_bindgen_id_215772<ReferenceBox>,
    pub mType: StyleShapeSourceType,
    pub mReferenceBox: ReferenceBox,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StyleShapeSource__bindgen_ty_bindgen_id_215772<ReferenceBox> {
    pub mBasicShape: __BindgenUnionField<*mut StyleBasicShape>,
    pub mURL: __BindgenUnionField<*mut FragmentOrURL>,
    pub bindgen_union_field: u64,
    pub _phantom_0: ::std::marker::PhantomData<ReferenceBox>,
}
pub type StyleClipPath = StyleShapeSource<StyleClipPathGeometryBox>;
pub type StyleShapeOutside = StyleShapeSource<StyleShapeOutsideShapeBox>;
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleTable {
    pub mLayoutStrategy: u8,
    pub mSpan: i32,
}
#[test]
fn bindgen_test_layout_nsStyleTable() {
    assert_eq!(::std::mem::size_of::<nsStyleTable>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsStyleTable>() , 4usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleTableBorder {
    pub mBorderSpacingCol: nscoord,
    pub mBorderSpacingRow: nscoord,
    pub mBorderCollapse: u8,
    pub mCaptionSide: u8,
    pub mEmptyCells: u8,
}
#[test]
fn bindgen_test_layout_nsStyleTableBorder() {
    assert_eq!(::std::mem::size_of::<nsStyleTableBorder>() , 12usize);
    assert_eq!(::std::mem::align_of::<nsStyleTableBorder>() , 4usize);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsStyleContentType {
    eStyleContentType_String = 1,
    eStyleContentType_Image = 10,
    eStyleContentType_Attr = 20,
    eStyleContentType_Counter = 30,
    eStyleContentType_Counters = 31,
    eStyleContentType_OpenQuote = 40,
    eStyleContentType_CloseQuote = 41,
    eStyleContentType_NoOpenQuote = 42,
    eStyleContentType_NoCloseQuote = 43,
    eStyleContentType_AltContent = 50,
    eStyleContentType_Uninitialized = 51,
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleContentData {
    pub mType: nsStyleContentType,
    pub mContent: nsStyleContentData__bindgen_ty_bindgen_id_215856,
    pub mImageTracked: bool,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleContentData__bindgen_ty_bindgen_id_215856 {
    pub mString: __BindgenUnionField<*mut u16>,
    pub mImage: __BindgenUnionField<*mut imgRequestProxy>,
    pub mCounters: __BindgenUnionField<*mut nsCSSValue_Array>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_nsStyleContentData__bindgen_ty_bindgen_id_215856() {
    assert_eq!(::std::mem::size_of::<nsStyleContentData__bindgen_ty_bindgen_id_215856>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<nsStyleContentData__bindgen_ty_bindgen_id_215856>()
               , 8usize);
}
impl Clone for nsStyleContentData__bindgen_ty_bindgen_id_215856 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsStyleContentData() {
    assert_eq!(::std::mem::size_of::<nsStyleContentData>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsStyleContentData>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleCounterData {
    pub mCounter: nsString,
    pub mValue: i32,
}
#[test]
fn bindgen_test_layout_nsStyleCounterData() {
    assert_eq!(::std::mem::size_of::<nsStyleCounterData>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsStyleCounterData>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleContent {
    pub mMarkerOffset: nsStyleCoord,
    pub mContents: nsTArray<nsStyleContentData>,
    pub mIncrements: nsTArray<nsStyleCounterData>,
    pub mResets: nsTArray<nsStyleCounterData>,
}
#[test]
fn bindgen_test_layout_nsStyleContent() {
    assert_eq!(::std::mem::size_of::<nsStyleContent>() , 40usize);
    assert_eq!(::std::mem::align_of::<nsStyleContent>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleUIReset {
    pub mUserSelect: StyleUserSelect,
    pub mForceBrokenImageIcon: u8,
    pub mIMEMode: u8,
    pub mWindowDragging: u8,
    pub mWindowShadow: u8,
}
#[test]
fn bindgen_test_layout_nsStyleUIReset() {
    assert_eq!(::std::mem::size_of::<nsStyleUIReset>() , 5usize);
    assert_eq!(::std::mem::align_of::<nsStyleUIReset>() , 1usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCursorImage {
    pub mHaveHotspot: bool,
    pub mHotspotX: f32,
    pub mHotspotY: f32,
    pub mImage: nsCOMPtr<imgIRequest>,
}
#[test]
fn bindgen_test_layout_nsCursorImage() {
    assert_eq!(::std::mem::size_of::<nsCursorImage>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsCursorImage>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleUserInterface {
    pub mUserInput: u8,
    pub mUserModify: u8,
    pub mUserFocus: StyleUserFocus,
    pub mPointerEvents: u8,
    pub mCursor: u8,
    pub mCursorImages: nsTArray<nsCursorImage>,
}
#[test]
fn bindgen_test_layout_nsStyleUserInterface() {
    assert_eq!(::std::mem::size_of::<nsStyleUserInterface>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsStyleUserInterface>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleXUL {
    pub mBoxFlex: f32,
    pub mBoxOrdinal: u32,
    pub mBoxAlign: StyleBoxAlign,
    pub mBoxDirection: StyleBoxDirection,
    pub mBoxOrient: StyleBoxOrient,
    pub mBoxPack: StyleBoxPack,
    pub mStretchStack: bool,
}
#[test]
fn bindgen_test_layout_nsStyleXUL() {
    assert_eq!(::std::mem::size_of::<nsStyleXUL>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsStyleXUL>() , 4usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleColumn {
    pub mColumnCount: u32,
    pub mColumnWidth: nsStyleCoord,
    pub mColumnGap: nsStyleCoord,
    pub mColumnRuleColor: StyleComplexColor,
    pub mColumnRuleStyle: u8,
    pub mColumnFill: u8,
    pub mColumnRuleWidth: nscoord,
    pub mTwipsPerPixel: nscoord,
}
extern "C" {
    #[link_name = "_ZN13nsStyleColumn15kMaxColumnCountE"]
    pub static nsStyleColumn_kMaxColumnCount: u32;
}
#[test]
fn bindgen_test_layout_nsStyleColumn() {
    assert_eq!(::std::mem::size_of::<nsStyleColumn>() , 64usize);
    assert_eq!(::std::mem::align_of::<nsStyleColumn>() , 8usize);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsStyleSVGPaintType {
    eStyleSVGPaintType_None = 1,
    eStyleSVGPaintType_Color = 2,
    eStyleSVGPaintType_Server = 3,
    eStyleSVGPaintType_ContextFill = 4,
    eStyleSVGPaintType_ContextStroke = 5,
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleSVGPaint {
    pub mPaint: nsStyleSVGPaint__bindgen_ty_bindgen_id_216243,
    pub mType: nsStyleSVGPaintType,
    pub mFallbackColor: nscolor,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleSVGPaint__bindgen_ty_bindgen_id_216243 {
    pub mColor: __BindgenUnionField<nscolor>,
    pub mPaintServer: __BindgenUnionField<*mut FragmentOrURL>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_nsStyleSVGPaint__bindgen_ty_bindgen_id_216243() {
    assert_eq!(::std::mem::size_of::<nsStyleSVGPaint__bindgen_ty_bindgen_id_216243>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<nsStyleSVGPaint__bindgen_ty_bindgen_id_216243>()
               , 8usize);
}
impl Clone for nsStyleSVGPaint__bindgen_ty_bindgen_id_216243 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsStyleSVGPaint() {
    assert_eq!(::std::mem::size_of::<nsStyleSVGPaint>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsStyleSVGPaint>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleSVG {
    pub mFill: nsStyleSVGPaint,
    pub mStroke: nsStyleSVGPaint,
    pub mMarkerEnd: FragmentOrURL,
    pub mMarkerMid: FragmentOrURL,
    pub mMarkerStart: FragmentOrURL,
    pub mStrokeDasharray: nsTArray<nsStyleCoord>,
    pub mStrokeDashoffset: nsStyleCoord,
    pub mStrokeWidth: nsStyleCoord,
    pub mFillOpacity: f32,
    pub mStrokeMiterlimit: f32,
    pub mStrokeOpacity: f32,
    pub mClipRule: StyleFillRule,
    pub mColorInterpolation: u8,
    pub mColorInterpolationFilters: u8,
    pub mFillRule: StyleFillRule,
    pub mPaintOrder: u8,
    pub mShapeRendering: u8,
    pub mStrokeLinecap: u8,
    pub mStrokeLinejoin: u8,
    pub mTextAnchor: u8,
    pub mContextFlags: u8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nsStyleSVG__bindgen_ty_bindgen_id_216420 {
    FILL_OPACITY_SOURCE_MASK = 3,
    STROKE_OPACITY_SOURCE_MASK = 12,
    STROKE_DASHARRAY_CONTEXT = 16,
    STROKE_DASHOFFSET_CONTEXT = 32,
    STROKE_WIDTH_CONTEXT = 64,
    FILL_OPACITY_SOURCE_SHIFT = 0,
    STROKE_OPACITY_SOURCE_SHIFT = 2,
}
#[test]
fn bindgen_test_layout_nsStyleSVG() {
    assert_eq!(::std::mem::size_of::<nsStyleSVG>() , 144usize);
    assert_eq!(::std::mem::align_of::<nsStyleSVG>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleFilter {
    pub mType: i32,
    pub mFilterParameter: nsStyleCoord,
    pub __bindgen_anon_1: nsStyleFilter__bindgen_ty_bindgen_id_216486,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleFilter__bindgen_ty_bindgen_id_216486 {
    pub mURL: __BindgenUnionField<*mut FragmentOrURL>,
    pub mDropShadow: __BindgenUnionField<*mut nsCSSShadowArray>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_nsStyleFilter__bindgen_ty_bindgen_id_216486() {
    assert_eq!(::std::mem::size_of::<nsStyleFilter__bindgen_ty_bindgen_id_216486>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<nsStyleFilter__bindgen_ty_bindgen_id_216486>()
               , 8usize);
}
impl Clone for nsStyleFilter__bindgen_ty_bindgen_id_216486 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsStyleFilter() {
    assert_eq!(::std::mem::size_of::<nsStyleFilter>() , 32usize);
    assert_eq!(::std::mem::align_of::<nsStyleFilter>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleSVGReset {
    pub mMask: nsStyleImageLayers,
    pub mClipPath: StyleClipPath,
    pub mStopColor: nscolor,
    pub mFloodColor: nscolor,
    pub mLightingColor: nscolor,
    pub mStopOpacity: f32,
    pub mFloodOpacity: f32,
    pub mDominantBaseline: u8,
    pub mVectorEffect: u8,
    pub mMaskType: u8,
}
#[test]
fn bindgen_test_layout_nsStyleSVGReset() {
    assert_eq!(::std::mem::size_of::<nsStyleSVGReset>() , 216usize);
    assert_eq!(::std::mem::align_of::<nsStyleSVGReset>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleVariables {
    pub mVariables: CSSVariableValues,
}
#[test]
fn bindgen_test_layout_nsStyleVariables() {
    assert_eq!(::std::mem::size_of::<nsStyleVariables>() , 56usize);
    assert_eq!(::std::mem::align_of::<nsStyleVariables>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleEffects {
    pub mFilters: nsTArray<nsStyleFilter>,
    pub mBoxShadow: RefPtr<nsCSSShadowArray>,
    pub mClip: nsRect,
    pub mOpacity: f32,
    pub mClipFlags: u8,
    pub mMixBlendMode: u8,
}
#[test]
fn bindgen_test_layout_nsStyleEffects() {
    assert_eq!(::std::mem::size_of::<nsStyleEffects>() , 40usize);
    assert_eq!(::std::mem::align_of::<nsStyleEffects>() , 8usize);
}
/**
 * <div rustbindgen="true" replaces="nsMargin">
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsMargin {
    pub top: nscoord,
    pub right: nscoord,
    pub bottom: nscoord,
    pub left: nscoord,
}
#[test]
fn bindgen_test_layout_nsMargin() {
    assert_eq!(::std::mem::size_of::<nsMargin>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsMargin>() , 4usize);
}
impl Clone for nsMargin {
    fn clone(&self) -> Self { *self }
}
/**
 * <div rustbindgen="true" replaces="nsRect">
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsRect {
    pub x: nscoord,
    pub y: nscoord,
    pub width: nscoord,
    pub height: nscoord,
}
#[test]
fn bindgen_test_layout_nsRect() {
    assert_eq!(::std::mem::size_of::<nsRect>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsRect>() , 4usize);
}
impl Clone for nsRect {
    fn clone(&self) -> Self { *self }
}
/**
 * <div rustbindgen="true" replaces="nsSize">
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsSize {
    pub width: nscoord,
    pub height: nscoord,
}
#[test]
fn bindgen_test_layout_nsSize() {
    assert_eq!(::std::mem::size_of::<nsSize>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsSize>() , 4usize);
}
impl Clone for nsSize {
    fn clone(&self) -> Self { *self }
}
/**
 * <div rustbindgen="true" replaces="UniquePtr">
 *
 * TODO(Emilio): This is a workaround and we should be able to get rid of this
 * one.
 */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UniquePtr<T, Deleter> {
    pub mPtr: *mut T,
    pub _phantom_1: ::std::marker::PhantomData<Deleter>,
}
/**
 * <div rustbindgen replaces="nsTArray"></div>
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsTArray<T> {
    pub mBuffer: *mut T,
}
