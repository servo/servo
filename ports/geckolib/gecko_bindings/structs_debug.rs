/* automatically generated by rust-bindgen */

#[derive(Copy, Debug)]
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
pub const NS_THEME_NONE: ::std::os::raw::c_uint = 0;
pub const NS_THEME_BUTTON: ::std::os::raw::c_uint = 1;
pub const NS_THEME_RADIO: ::std::os::raw::c_uint = 2;
pub const NS_THEME_CHECKBOX: ::std::os::raw::c_uint = 3;
pub const NS_THEME_BUTTON_BEVEL: ::std::os::raw::c_uint = 7;
pub const NS_THEME_FOCUS_OUTLINE: ::std::os::raw::c_uint = 8;
pub const NS_THEME_TOOLBOX: ::std::os::raw::c_uint = 11;
pub const NS_THEME_TOOLBAR: ::std::os::raw::c_uint = 12;
pub const NS_THEME_TOOLBARBUTTON: ::std::os::raw::c_uint = 13;
pub const NS_THEME_DUALBUTTON: ::std::os::raw::c_uint = 14;
pub const NS_THEME_TOOLBARBUTTON_DROPDOWN: ::std::os::raw::c_uint = 15;
pub const NS_THEME_BUTTON_ARROW_UP: ::std::os::raw::c_uint = 16;
pub const NS_THEME_BUTTON_ARROW_DOWN: ::std::os::raw::c_uint = 17;
pub const NS_THEME_BUTTON_ARROW_NEXT: ::std::os::raw::c_uint = 18;
pub const NS_THEME_BUTTON_ARROW_PREVIOUS: ::std::os::raw::c_uint = 19;
pub const NS_THEME_SEPARATOR: ::std::os::raw::c_uint = 20;
pub const NS_THEME_TOOLBARGRIPPER: ::std::os::raw::c_uint = 21;
pub const NS_THEME_SPLITTER: ::std::os::raw::c_uint = 22;
pub const NS_THEME_STATUSBAR: ::std::os::raw::c_uint = 23;
pub const NS_THEME_STATUSBARPANEL: ::std::os::raw::c_uint = 24;
pub const NS_THEME_RESIZERPANEL: ::std::os::raw::c_uint = 25;
pub const NS_THEME_RESIZER: ::std::os::raw::c_uint = 26;
pub const NS_THEME_LISTBOX: ::std::os::raw::c_uint = 31;
pub const NS_THEME_LISTITEM: ::std::os::raw::c_uint = 32;
pub const NS_THEME_TREEVIEW: ::std::os::raw::c_uint = 41;
pub const NS_THEME_TREEITEM: ::std::os::raw::c_uint = 42;
pub const NS_THEME_TREETWISTY: ::std::os::raw::c_uint = 43;
pub const NS_THEME_TREELINE: ::std::os::raw::c_uint = 44;
pub const NS_THEME_TREEHEADER: ::std::os::raw::c_uint = 45;
pub const NS_THEME_TREEHEADERCELL: ::std::os::raw::c_uint = 46;
pub const NS_THEME_TREEHEADERSORTARROW: ::std::os::raw::c_uint = 47;
pub const NS_THEME_TREETWISTYOPEN: ::std::os::raw::c_uint = 48;
pub const NS_THEME_PROGRESSBAR: ::std::os::raw::c_uint = 51;
pub const NS_THEME_PROGRESSCHUNK: ::std::os::raw::c_uint = 52;
pub const NS_THEME_PROGRESSBAR_VERTICAL: ::std::os::raw::c_uint = 53;
pub const NS_THEME_PROGRESSCHUNK_VERTICAL: ::std::os::raw::c_uint = 54;
pub const NS_THEME_METERBAR: ::std::os::raw::c_uint = 55;
pub const NS_THEME_METERCHUNK: ::std::os::raw::c_uint = 56;
pub const NS_THEME_TAB: ::std::os::raw::c_uint = 61;
pub const NS_THEME_TABPANEL: ::std::os::raw::c_uint = 62;
pub const NS_THEME_TABPANELS: ::std::os::raw::c_uint = 65;
pub const NS_THEME_TAB_SCROLL_ARROW_BACK: ::std::os::raw::c_uint = 66;
pub const NS_THEME_TAB_SCROLL_ARROW_FORWARD: ::std::os::raw::c_uint = 67;
pub const NS_THEME_TOOLTIP: ::std::os::raw::c_uint = 71;
pub const NS_THEME_SPINNER: ::std::os::raw::c_uint = 72;
pub const NS_THEME_SPINNER_UPBUTTON: ::std::os::raw::c_uint = 73;
pub const NS_THEME_SPINNER_DOWNBUTTON: ::std::os::raw::c_uint = 74;
pub const NS_THEME_SPINNER_TEXTFIELD: ::std::os::raw::c_uint = 75;
pub const NS_THEME_NUMBER_INPUT: ::std::os::raw::c_uint = 76;
pub const NS_THEME_SCROLLBAR: ::std::os::raw::c_uint = 80;
pub const NS_THEME_SCROLLBAR_SMALL: ::std::os::raw::c_uint = 81;
pub const NS_THEME_SCROLLBAR_HORIZONTAL: ::std::os::raw::c_uint = 82;
pub const NS_THEME_SCROLLBAR_VERTICAL: ::std::os::raw::c_uint = 83;
pub const NS_THEME_SCROLLBARBUTTON_UP: ::std::os::raw::c_uint = 84;
pub const NS_THEME_SCROLLBARBUTTON_DOWN: ::std::os::raw::c_uint = 85;
pub const NS_THEME_SCROLLBARBUTTON_LEFT: ::std::os::raw::c_uint = 86;
pub const NS_THEME_SCROLLBARBUTTON_RIGHT: ::std::os::raw::c_uint = 87;
pub const NS_THEME_SCROLLBARTRACK_HORIZONTAL: ::std::os::raw::c_uint = 88;
pub const NS_THEME_SCROLLBARTRACK_VERTICAL: ::std::os::raw::c_uint = 89;
pub const NS_THEME_SCROLLBARTHUMB_HORIZONTAL: ::std::os::raw::c_uint = 90;
pub const NS_THEME_SCROLLBARTHUMB_VERTICAL: ::std::os::raw::c_uint = 91;
pub const NS_THEME_SCROLLBAR_NON_DISAPPEARING: ::std::os::raw::c_uint = 92;
pub const NS_THEME_TEXTFIELD: ::std::os::raw::c_uint = 95;
pub const NS_THEME_CARET: ::std::os::raw::c_uint = 96;
pub const NS_THEME_TEXTFIELD_MULTILINE: ::std::os::raw::c_uint = 97;
pub const NS_THEME_SEARCHFIELD: ::std::os::raw::c_uint = 98;
pub const NS_THEME_MENULIST: ::std::os::raw::c_uint = 101;
pub const NS_THEME_MENULIST_BUTTON: ::std::os::raw::c_uint = 102;
pub const NS_THEME_MENULIST_TEXT: ::std::os::raw::c_uint = 103;
pub const NS_THEME_MENULIST_TEXTFIELD: ::std::os::raw::c_uint = 104;
pub const NS_THEME_SCALE_HORIZONTAL: ::std::os::raw::c_uint = 111;
pub const NS_THEME_SCALE_VERTICAL: ::std::os::raw::c_uint = 112;
pub const NS_THEME_SCALETHUMB_HORIZONTAL: ::std::os::raw::c_uint = 113;
pub const NS_THEME_SCALETHUMB_VERTICAL: ::std::os::raw::c_uint = 114;
pub const NS_THEME_SCALETHUMBSTART: ::std::os::raw::c_uint = 115;
pub const NS_THEME_SCALETHUMBEND: ::std::os::raw::c_uint = 116;
pub const NS_THEME_SCALETHUMBTICK: ::std::os::raw::c_uint = 117;
pub const NS_THEME_RANGE: ::std::os::raw::c_uint = 120;
pub const NS_THEME_RANGE_THUMB: ::std::os::raw::c_uint = 121;
pub const NS_THEME_GROUPBOX: ::std::os::raw::c_uint = 149;
pub const NS_THEME_CHECKBOX_CONTAINER: ::std::os::raw::c_uint = 150;
pub const NS_THEME_RADIO_CONTAINER: ::std::os::raw::c_uint = 151;
pub const NS_THEME_CHECKBOX_LABEL: ::std::os::raw::c_uint = 152;
pub const NS_THEME_RADIO_LABEL: ::std::os::raw::c_uint = 153;
pub const NS_THEME_BUTTON_FOCUS: ::std::os::raw::c_uint = 154;
pub const NS_THEME_WINDOW: ::std::os::raw::c_uint = 200;
pub const NS_THEME_DIALOG: ::std::os::raw::c_uint = 201;
pub const NS_THEME_MENUBAR: ::std::os::raw::c_uint = 210;
pub const NS_THEME_MENUPOPUP: ::std::os::raw::c_uint = 211;
pub const NS_THEME_MENUITEM: ::std::os::raw::c_uint = 212;
pub const NS_THEME_CHECKMENUITEM: ::std::os::raw::c_uint = 213;
pub const NS_THEME_RADIOMENUITEM: ::std::os::raw::c_uint = 214;
pub const NS_THEME_MENUCHECKBOX: ::std::os::raw::c_uint = 215;
pub const NS_THEME_MENURADIO: ::std::os::raw::c_uint = 216;
pub const NS_THEME_MENUSEPARATOR: ::std::os::raw::c_uint = 217;
pub const NS_THEME_MENUARROW: ::std::os::raw::c_uint = 218;
pub const NS_THEME_MENUIMAGE: ::std::os::raw::c_uint = 219;
pub const NS_THEME_MENUITEMTEXT: ::std::os::raw::c_uint = 220;
pub const NS_THEME_WIN_COMMUNICATIONS_TOOLBOX: ::std::os::raw::c_uint = 221;
pub const NS_THEME_WIN_MEDIA_TOOLBOX: ::std::os::raw::c_uint = 222;
pub const NS_THEME_WIN_BROWSERTABBAR_TOOLBOX: ::std::os::raw::c_uint = 223;
pub const NS_THEME_MAC_FULLSCREEN_BUTTON: ::std::os::raw::c_uint = 226;
pub const NS_THEME_MAC_HELP_BUTTON: ::std::os::raw::c_uint = 227;
pub const NS_THEME_WIN_BORDERLESS_GLASS: ::std::os::raw::c_uint = 229;
pub const NS_THEME_WIN_GLASS: ::std::os::raw::c_uint = 230;
pub const NS_THEME_WINDOW_TITLEBAR: ::std::os::raw::c_uint = 231;
pub const NS_THEME_WINDOW_TITLEBAR_MAXIMIZED: ::std::os::raw::c_uint = 232;
pub const NS_THEME_WINDOW_FRAME_LEFT: ::std::os::raw::c_uint = 233;
pub const NS_THEME_WINDOW_FRAME_RIGHT: ::std::os::raw::c_uint = 234;
pub const NS_THEME_WINDOW_FRAME_BOTTOM: ::std::os::raw::c_uint = 235;
pub const NS_THEME_WINDOW_BUTTON_CLOSE: ::std::os::raw::c_uint = 236;
pub const NS_THEME_WINDOW_BUTTON_MINIMIZE: ::std::os::raw::c_uint = 237;
pub const NS_THEME_WINDOW_BUTTON_MAXIMIZE: ::std::os::raw::c_uint = 238;
pub const NS_THEME_WINDOW_BUTTON_RESTORE: ::std::os::raw::c_uint = 239;
pub const NS_THEME_WINDOW_BUTTON_BOX: ::std::os::raw::c_uint = 240;
pub const NS_THEME_WINDOW_BUTTON_BOX_MAXIMIZED: ::std::os::raw::c_uint = 241;
pub const NS_THEME_WIN_EXCLUDE_GLASS: ::std::os::raw::c_uint = 242;
pub const NS_THEME_MAC_VIBRANCY_LIGHT: ::std::os::raw::c_uint = 243;
pub const NS_THEME_MAC_VIBRANCY_DARK: ::std::os::raw::c_uint = 244;
pub const NS_THEME_MAC_DISCLOSURE_BUTTON_OPEN: ::std::os::raw::c_uint = 245;
pub const NS_THEME_MAC_DISCLOSURE_BUTTON_CLOSED: ::std::os::raw::c_uint = 246;
pub const NS_THEME_GTK_INFO_BAR: ::std::os::raw::c_uint = 247;
pub const NS_THEME_MAC_SOURCE_LIST: ::std::os::raw::c_uint = 248;
pub const NS_ERROR_MODULE_XPCOM: ::std::os::raw::c_uint = 1;
pub const NS_ERROR_MODULE_BASE: ::std::os::raw::c_uint = 2;
pub const NS_ERROR_MODULE_GFX: ::std::os::raw::c_uint = 3;
pub const NS_ERROR_MODULE_WIDGET: ::std::os::raw::c_uint = 4;
pub const NS_ERROR_MODULE_CALENDAR: ::std::os::raw::c_uint = 5;
pub const NS_ERROR_MODULE_NETWORK: ::std::os::raw::c_uint = 6;
pub const NS_ERROR_MODULE_PLUGINS: ::std::os::raw::c_uint = 7;
pub const NS_ERROR_MODULE_LAYOUT: ::std::os::raw::c_uint = 8;
pub const NS_ERROR_MODULE_HTMLPARSER: ::std::os::raw::c_uint = 9;
pub const NS_ERROR_MODULE_RDF: ::std::os::raw::c_uint = 10;
pub const NS_ERROR_MODULE_UCONV: ::std::os::raw::c_uint = 11;
pub const NS_ERROR_MODULE_REG: ::std::os::raw::c_uint = 12;
pub const NS_ERROR_MODULE_FILES: ::std::os::raw::c_uint = 13;
pub const NS_ERROR_MODULE_DOM: ::std::os::raw::c_uint = 14;
pub const NS_ERROR_MODULE_IMGLIB: ::std::os::raw::c_uint = 15;
pub const NS_ERROR_MODULE_MAILNEWS: ::std::os::raw::c_uint = 16;
pub const NS_ERROR_MODULE_EDITOR: ::std::os::raw::c_uint = 17;
pub const NS_ERROR_MODULE_XPCONNECT: ::std::os::raw::c_uint = 18;
pub const NS_ERROR_MODULE_PROFILE: ::std::os::raw::c_uint = 19;
pub const NS_ERROR_MODULE_LDAP: ::std::os::raw::c_uint = 20;
pub const NS_ERROR_MODULE_SECURITY: ::std::os::raw::c_uint = 21;
pub const NS_ERROR_MODULE_DOM_XPATH: ::std::os::raw::c_uint = 22;
pub const NS_ERROR_MODULE_URILOADER: ::std::os::raw::c_uint = 24;
pub const NS_ERROR_MODULE_CONTENT: ::std::os::raw::c_uint = 25;
pub const NS_ERROR_MODULE_PYXPCOM: ::std::os::raw::c_uint = 26;
pub const NS_ERROR_MODULE_XSLT: ::std::os::raw::c_uint = 27;
pub const NS_ERROR_MODULE_IPC: ::std::os::raw::c_uint = 28;
pub const NS_ERROR_MODULE_SVG: ::std::os::raw::c_uint = 29;
pub const NS_ERROR_MODULE_STORAGE: ::std::os::raw::c_uint = 30;
pub const NS_ERROR_MODULE_SCHEMA: ::std::os::raw::c_uint = 31;
pub const NS_ERROR_MODULE_DOM_FILE: ::std::os::raw::c_uint = 32;
pub const NS_ERROR_MODULE_DOM_INDEXEDDB: ::std::os::raw::c_uint = 33;
pub const NS_ERROR_MODULE_DOM_FILEHANDLE: ::std::os::raw::c_uint = 34;
pub const NS_ERROR_MODULE_SIGNED_JAR: ::std::os::raw::c_uint = 35;
pub const NS_ERROR_MODULE_DOM_FILESYSTEM: ::std::os::raw::c_uint = 36;
pub const NS_ERROR_MODULE_DOM_BLUETOOTH: ::std::os::raw::c_uint = 37;
pub const NS_ERROR_MODULE_SIGNED_APP: ::std::os::raw::c_uint = 38;
pub const NS_ERROR_MODULE_DOM_ANIM: ::std::os::raw::c_uint = 39;
pub const NS_ERROR_MODULE_DOM_PUSH: ::std::os::raw::c_uint = 40;
pub const NS_ERROR_MODULE_GENERAL: ::std::os::raw::c_uint = 51;
pub const NS_ERROR_SEVERITY_SUCCESS: ::std::os::raw::c_uint = 0;
pub const NS_ERROR_SEVERITY_ERROR: ::std::os::raw::c_uint = 1;
pub const NS_ERROR_MODULE_BASE_OFFSET: ::std::os::raw::c_uint = 69;
pub const MOZ_STRING_WITH_OBSOLETE_API: ::std::os::raw::c_uint = 1;
pub const NSID_LENGTH: ::std::os::raw::c_uint = 39;
pub const NS_NUMBER_OF_FLAGS_IN_REFCNT: ::std::os::raw::c_uint = 2;
pub const _STL_PAIR_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_UTILITY: ::std::os::raw::c_uint = 1;
pub const __cpp_lib_tuple_element_t: ::std::os::raw::c_uint = 201402;
pub const __cpp_lib_tuples_by_type: ::std::os::raw::c_uint = 201304;
pub const __cpp_lib_exchange_function: ::std::os::raw::c_uint = 201304;
pub const __cpp_lib_integer_sequence: ::std::os::raw::c_uint = 201304;
pub const NS_EVENT_STATE_HIGHEST_SERVO_BIT: ::std::os::raw::c_uint = 6;
pub const DOM_USER_DATA: ::std::os::raw::c_uint = 1;
pub const SMIL_MAPPED_ATTR_ANIMVAL: ::std::os::raw::c_uint = 2;
pub const TWIPS_PER_POINT_INT: ::std::os::raw::c_uint = 20;
pub const POINTS_PER_INCH_INT: ::std::os::raw::c_uint = 72;
pub const NS_ATTRNAME_NODEINFO_BIT: ::std::os::raw::c_uint = 1;
pub const NS_ATTRVALUE_MAX_STRINGLENGTH_ATOM: ::std::os::raw::c_uint = 12;
pub const NS_ATTRVALUE_INTEGERTYPE_BITS: ::std::os::raw::c_uint = 4;
pub const NS_FONT_VARIANT_NORMAL: ::std::os::raw::c_uint = 0;
pub const NS_FONT_VARIANT_SMALL_CAPS: ::std::os::raw::c_uint = 1;
pub const NS_CORNER_TOP_LEFT_X: ::std::os::raw::c_uint = 0;
pub const NS_CORNER_TOP_LEFT_Y: ::std::os::raw::c_uint = 1;
pub const NS_CORNER_TOP_RIGHT_X: ::std::os::raw::c_uint = 2;
pub const NS_CORNER_TOP_RIGHT_Y: ::std::os::raw::c_uint = 3;
pub const NS_CORNER_BOTTOM_RIGHT_X: ::std::os::raw::c_uint = 4;
pub const NS_CORNER_BOTTOM_RIGHT_Y: ::std::os::raw::c_uint = 5;
pub const NS_CORNER_BOTTOM_LEFT_X: ::std::os::raw::c_uint = 6;
pub const NS_CORNER_BOTTOM_LEFT_Y: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_CLIP_SHAPE_SIZING_NOBOX: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_CLIP_SHAPE_SIZING_CONTENT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_CLIP_SHAPE_SIZING_PADDING: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_CLIP_SHAPE_SIZING_BORDER: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_CLIP_SHAPE_SIZING_MARGIN: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_CLIP_SHAPE_SIZING_FILL: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_CLIP_SHAPE_SIZING_STROKE: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_CLIP_SHAPE_SIZING_VIEW: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_BASIC_SHAPE_POLYGON: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_BASIC_SHAPE_CIRCLE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_BASIC_SHAPE_ELLIPSE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_BASIC_SHAPE_INSET: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_BOX_SHADOW_INSET: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_FLOAT_EDGE_CONTENT_BOX: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_FLOAT_EDGE_MARGIN_BOX: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_USER_FOCUS_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_USER_FOCUS_IGNORE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_USER_FOCUS_NORMAL: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_USER_FOCUS_SELECT_ALL: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_USER_FOCUS_SELECT_BEFORE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_USER_FOCUS_SELECT_AFTER: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_USER_FOCUS_SELECT_SAME: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_USER_FOCUS_SELECT_MENU: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_USER_SELECT_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_USER_SELECT_TEXT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_USER_SELECT_ELEMENT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_USER_SELECT_ELEMENTS: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_USER_SELECT_ALL: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_USER_SELECT_TOGGLE: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_USER_SELECT_TRI_STATE: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_USER_SELECT_AUTO: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_USER_SELECT_MOZ_ALL: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_USER_SELECT_MOZ_NONE: ::std::os::raw::c_uint = 9;
pub const NS_STYLE_USER_SELECT_MOZ_TEXT: ::std::os::raw::c_uint = 10;
pub const NS_STYLE_USER_INPUT_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_USER_INPUT_ENABLED: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_USER_INPUT_DISABLED: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_USER_INPUT_AUTO: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_USER_MODIFY_READ_ONLY: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_USER_MODIFY_READ_WRITE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_USER_MODIFY_WRITE_ONLY: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_WINDOW_DRAGGING_DEFAULT: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_WINDOW_DRAGGING_DRAG: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_WINDOW_DRAGGING_NO_DRAG: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_BOX_ALIGN_STRETCH: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_BOX_ALIGN_START: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_BOX_ALIGN_CENTER: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_BOX_ALIGN_BASELINE: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_BOX_ALIGN_END: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_BOX_PACK_START: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_BOX_PACK_CENTER: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_BOX_PACK_END: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_BOX_PACK_JUSTIFY: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_BOX_DECORATION_BREAK_SLICE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_BOX_DECORATION_BREAK_CLONE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_BOX_DIRECTION_NORMAL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_BOX_DIRECTION_REVERSE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_BOX_ORIENT_HORIZONTAL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_BOX_ORIENT_VERTICAL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_ORIENT_INLINE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_ORIENT_BLOCK: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_ORIENT_HORIZONTAL: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_ORIENT_VERTICAL: ::std::os::raw::c_uint = 3;
pub const NS_RADIUS_FARTHEST_SIDE: ::std::os::raw::c_uint = 0;
pub const NS_RADIUS_CLOSEST_SIDE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_STACK_SIZING_IGNORE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_STACK_SIZING_STRETCH_TO_FIT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_AZIMUTH_LEFT_SIDE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_AZIMUTH_FAR_LEFT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_AZIMUTH_LEFT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_AZIMUTH_CENTER_LEFT: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_AZIMUTH_CENTER: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_AZIMUTH_CENTER_RIGHT: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_AZIMUTH_RIGHT: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_AZIMUTH_FAR_RIGHT: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_AZIMUTH_RIGHT_SIDE: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_AZIMUTH_BEHIND: ::std::os::raw::c_uint = 128;
pub const NS_STYLE_AZIMUTH_LEFTWARDS: ::std::os::raw::c_uint = 16;
pub const NS_STYLE_AZIMUTH_RIGHTWARDS: ::std::os::raw::c_uint = 32;
pub const NS_STYLE_ELEVATION_BELOW: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_ELEVATION_LEVEL: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_ELEVATION_ABOVE: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_ELEVATION_HIGHER: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_ELEVATION_LOWER: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_PITCH_X_LOW: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_PITCH_LOW: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_PITCH_MEDIUM: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_PITCH_HIGH: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_PITCH_X_HIGH: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_SPEAK_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_SPEAK_NORMAL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_SPEAK_SPELL_OUT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_SPEAK_HEADER_ONCE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_SPEAK_HEADER_ALWAYS: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_SPEAK_NUMERAL_DIGITS: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_SPEAK_NUMERAL_CONTINUOUS: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_SPEAK_PUNCTUATION_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_SPEAK_PUNCTUATION_CODE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_SPEECH_RATE_X_SLOW: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_SPEECH_RATE_SLOW: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_SPEECH_RATE_MEDIUM: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_SPEECH_RATE_FAST: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_SPEECH_RATE_X_FAST: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_SPEECH_RATE_FASTER: ::std::os::raw::c_uint = 10;
pub const NS_STYLE_SPEECH_RATE_SLOWER: ::std::os::raw::c_uint = 11;
pub const NS_STYLE_VOLUME_SILENT: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_VOLUME_X_SOFT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_VOLUME_SOFT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_VOLUME_MEDIUM: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_VOLUME_LOUD: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_VOLUME_X_LOUD: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_COLOR_INHERIT_FROM_BODY: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_ANIMATION_ITERATION_COUNT_INFINITE: ::std::os::raw::c_uint
          =
    0;
pub const NS_STYLE_ANIMATION_PLAY_STATE_RUNNING: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_ANIMATION_PLAY_STATE_PAUSED: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_IMAGELAYER_ATTACHMENT_SCROLL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_IMAGELAYER_ATTACHMENT_FIXED: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_IMAGELAYER_ATTACHMENT_LOCAL: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_IMAGELAYER_CLIP_BORDER: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_IMAGELAYER_CLIP_PADDING: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_IMAGELAYER_CLIP_CONTENT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_IMAGELAYER_CLIP_TEXT: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_IMAGELAYER_CLIP_MOZ_ALMOST_PADDING: ::std::os::raw::c_uint
          =
    127;
pub const NS_STYLE_IMAGELAYER_ORIGIN_BORDER: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_IMAGELAYER_ORIGIN_PADDING: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_IMAGELAYER_ORIGIN_CONTENT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_IMAGELAYER_REPEAT_NO_REPEAT: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_IMAGELAYER_REPEAT_REPEAT_X: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_IMAGELAYER_REPEAT_REPEAT_Y: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_IMAGELAYER_REPEAT_REPEAT: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_IMAGELAYER_REPEAT_SPACE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_IMAGELAYER_REPEAT_ROUND: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_IMAGELAYER_SIZE_CONTAIN: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_IMAGELAYER_SIZE_COVER: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_MASK_MODE_ALPHA: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_MASK_MODE_LUMINANCE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_MASK_MODE_MATCH_SOURCE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_BG_INLINE_POLICY_EACH_BOX: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_BG_INLINE_POLICY_CONTINUOUS: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_BG_INLINE_POLICY_BOUNDING_BOX: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_BORDER_COLLAPSE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_BORDER_SEPARATE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_BORDER_WIDTH_THIN: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_BORDER_WIDTH_MEDIUM: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_BORDER_WIDTH_THICK: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_BORDER_STYLE_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_BORDER_STYLE_GROOVE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_BORDER_STYLE_RIDGE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_BORDER_STYLE_DOTTED: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_BORDER_STYLE_DASHED: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_BORDER_STYLE_SOLID: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_BORDER_STYLE_DOUBLE: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_BORDER_STYLE_INSET: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_BORDER_STYLE_OUTSET: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_BORDER_STYLE_HIDDEN: ::std::os::raw::c_uint = 9;
pub const NS_STYLE_BORDER_STYLE_AUTO: ::std::os::raw::c_uint = 10;
pub const NS_STYLE_BORDER_IMAGE_REPEAT_STRETCH: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_BORDER_IMAGE_REPEAT_REPEAT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_BORDER_IMAGE_REPEAT_ROUND: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_BORDER_IMAGE_SLICE_NOFILL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_BORDER_IMAGE_SLICE_FILL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_CLEAR_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_CLEAR_LEFT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_CLEAR_RIGHT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_CLEAR_INLINE_START: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_CLEAR_INLINE_END: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_CLEAR_BOTH: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_CLEAR_LINE: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_CONTENT_OPEN_QUOTE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_CONTENT_CLOSE_QUOTE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_CONTENT_NO_OPEN_QUOTE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_CONTENT_NO_CLOSE_QUOTE: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_CONTENT_ALT_CONTENT: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_CURSOR_AUTO: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_CURSOR_CROSSHAIR: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_CURSOR_DEFAULT: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_CURSOR_POINTER: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_CURSOR_MOVE: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_CURSOR_E_RESIZE: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_CURSOR_NE_RESIZE: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_CURSOR_NW_RESIZE: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_CURSOR_N_RESIZE: ::std::os::raw::c_uint = 9;
pub const NS_STYLE_CURSOR_SE_RESIZE: ::std::os::raw::c_uint = 10;
pub const NS_STYLE_CURSOR_SW_RESIZE: ::std::os::raw::c_uint = 11;
pub const NS_STYLE_CURSOR_S_RESIZE: ::std::os::raw::c_uint = 12;
pub const NS_STYLE_CURSOR_W_RESIZE: ::std::os::raw::c_uint = 13;
pub const NS_STYLE_CURSOR_TEXT: ::std::os::raw::c_uint = 14;
pub const NS_STYLE_CURSOR_WAIT: ::std::os::raw::c_uint = 15;
pub const NS_STYLE_CURSOR_HELP: ::std::os::raw::c_uint = 16;
pub const NS_STYLE_CURSOR_COPY: ::std::os::raw::c_uint = 17;
pub const NS_STYLE_CURSOR_ALIAS: ::std::os::raw::c_uint = 18;
pub const NS_STYLE_CURSOR_CONTEXT_MENU: ::std::os::raw::c_uint = 19;
pub const NS_STYLE_CURSOR_CELL: ::std::os::raw::c_uint = 20;
pub const NS_STYLE_CURSOR_GRAB: ::std::os::raw::c_uint = 21;
pub const NS_STYLE_CURSOR_GRABBING: ::std::os::raw::c_uint = 22;
pub const NS_STYLE_CURSOR_SPINNING: ::std::os::raw::c_uint = 23;
pub const NS_STYLE_CURSOR_ZOOM_IN: ::std::os::raw::c_uint = 24;
pub const NS_STYLE_CURSOR_ZOOM_OUT: ::std::os::raw::c_uint = 25;
pub const NS_STYLE_CURSOR_NOT_ALLOWED: ::std::os::raw::c_uint = 26;
pub const NS_STYLE_CURSOR_COL_RESIZE: ::std::os::raw::c_uint = 27;
pub const NS_STYLE_CURSOR_ROW_RESIZE: ::std::os::raw::c_uint = 28;
pub const NS_STYLE_CURSOR_NO_DROP: ::std::os::raw::c_uint = 29;
pub const NS_STYLE_CURSOR_VERTICAL_TEXT: ::std::os::raw::c_uint = 30;
pub const NS_STYLE_CURSOR_ALL_SCROLL: ::std::os::raw::c_uint = 31;
pub const NS_STYLE_CURSOR_NESW_RESIZE: ::std::os::raw::c_uint = 32;
pub const NS_STYLE_CURSOR_NWSE_RESIZE: ::std::os::raw::c_uint = 33;
pub const NS_STYLE_CURSOR_NS_RESIZE: ::std::os::raw::c_uint = 34;
pub const NS_STYLE_CURSOR_EW_RESIZE: ::std::os::raw::c_uint = 35;
pub const NS_STYLE_CURSOR_NONE: ::std::os::raw::c_uint = 36;
pub const NS_STYLE_DIRECTION_LTR: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_DIRECTION_RTL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_WRITING_MODE_HORIZONTAL_TB: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_WRITING_MODE_VERTICAL_RL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_WRITING_MODE_VERTICAL_LR: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_WRITING_MODE_SIDEWAYS_MASK: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_DISPLAY_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_DISPLAY_BLOCK: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_DISPLAY_INLINE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_DISPLAY_INLINE_BLOCK: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_DISPLAY_LIST_ITEM: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_DISPLAY_TABLE: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_DISPLAY_INLINE_TABLE: ::std::os::raw::c_uint = 9;
pub const NS_STYLE_DISPLAY_TABLE_ROW_GROUP: ::std::os::raw::c_uint = 10;
pub const NS_STYLE_DISPLAY_TABLE_COLUMN: ::std::os::raw::c_uint = 11;
pub const NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP: ::std::os::raw::c_uint = 12;
pub const NS_STYLE_DISPLAY_TABLE_HEADER_GROUP: ::std::os::raw::c_uint = 13;
pub const NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP: ::std::os::raw::c_uint = 14;
pub const NS_STYLE_DISPLAY_TABLE_ROW: ::std::os::raw::c_uint = 15;
pub const NS_STYLE_DISPLAY_TABLE_CELL: ::std::os::raw::c_uint = 16;
pub const NS_STYLE_DISPLAY_TABLE_CAPTION: ::std::os::raw::c_uint = 17;
pub const NS_STYLE_DISPLAY_BOX: ::std::os::raw::c_uint = 18;
pub const NS_STYLE_DISPLAY_INLINE_BOX: ::std::os::raw::c_uint = 19;
pub const NS_STYLE_DISPLAY_XUL_GRID: ::std::os::raw::c_uint = 20;
pub const NS_STYLE_DISPLAY_INLINE_XUL_GRID: ::std::os::raw::c_uint = 21;
pub const NS_STYLE_DISPLAY_XUL_GRID_GROUP: ::std::os::raw::c_uint = 22;
pub const NS_STYLE_DISPLAY_XUL_GRID_LINE: ::std::os::raw::c_uint = 23;
pub const NS_STYLE_DISPLAY_STACK: ::std::os::raw::c_uint = 24;
pub const NS_STYLE_DISPLAY_INLINE_STACK: ::std::os::raw::c_uint = 25;
pub const NS_STYLE_DISPLAY_DECK: ::std::os::raw::c_uint = 26;
pub const NS_STYLE_DISPLAY_POPUP: ::std::os::raw::c_uint = 27;
pub const NS_STYLE_DISPLAY_GROUPBOX: ::std::os::raw::c_uint = 28;
pub const NS_STYLE_DISPLAY_FLEX: ::std::os::raw::c_uint = 29;
pub const NS_STYLE_DISPLAY_INLINE_FLEX: ::std::os::raw::c_uint = 30;
pub const NS_STYLE_DISPLAY_GRID: ::std::os::raw::c_uint = 31;
pub const NS_STYLE_DISPLAY_INLINE_GRID: ::std::os::raw::c_uint = 32;
pub const NS_STYLE_DISPLAY_RUBY: ::std::os::raw::c_uint = 33;
pub const NS_STYLE_DISPLAY_RUBY_BASE: ::std::os::raw::c_uint = 34;
pub const NS_STYLE_DISPLAY_RUBY_BASE_CONTAINER: ::std::os::raw::c_uint = 35;
pub const NS_STYLE_DISPLAY_RUBY_TEXT: ::std::os::raw::c_uint = 36;
pub const NS_STYLE_DISPLAY_RUBY_TEXT_CONTAINER: ::std::os::raw::c_uint = 37;
pub const NS_STYLE_DISPLAY_CONTENTS: ::std::os::raw::c_uint = 38;
pub const NS_STYLE_DISPLAY_WEBKIT_BOX: ::std::os::raw::c_uint = 39;
pub const NS_STYLE_DISPLAY_WEBKIT_INLINE_BOX: ::std::os::raw::c_uint = 40;
pub const NS_STYLE_CONTAIN_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_CONTAIN_STRICT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_CONTAIN_LAYOUT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_CONTAIN_STYLE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_CONTAIN_PAINT: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_ALIGN_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_ALIGN_NORMAL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_ALIGN_START: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_ALIGN_END: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_ALIGN_FLEX_START: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_ALIGN_FLEX_END: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_ALIGN_CENTER: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_ALIGN_LEFT: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_ALIGN_RIGHT: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_ALIGN_BASELINE: ::std::os::raw::c_uint = 9;
pub const NS_STYLE_ALIGN_LAST_BASELINE: ::std::os::raw::c_uint = 10;
pub const NS_STYLE_ALIGN_STRETCH: ::std::os::raw::c_uint = 11;
pub const NS_STYLE_ALIGN_SELF_START: ::std::os::raw::c_uint = 12;
pub const NS_STYLE_ALIGN_SELF_END: ::std::os::raw::c_uint = 13;
pub const NS_STYLE_ALIGN_SPACE_BETWEEN: ::std::os::raw::c_uint = 14;
pub const NS_STYLE_ALIGN_SPACE_AROUND: ::std::os::raw::c_uint = 15;
pub const NS_STYLE_ALIGN_SPACE_EVENLY: ::std::os::raw::c_uint = 16;
pub const NS_STYLE_ALIGN_LEGACY: ::std::os::raw::c_uint = 32;
pub const NS_STYLE_ALIGN_SAFE: ::std::os::raw::c_uint = 64;
pub const NS_STYLE_ALIGN_UNSAFE: ::std::os::raw::c_uint = 128;
pub const NS_STYLE_ALIGN_FLAG_BITS: ::std::os::raw::c_uint = 224;
pub const NS_STYLE_ALIGN_ALL_BITS: ::std::os::raw::c_uint = 255;
pub const NS_STYLE_ALIGN_ALL_SHIFT: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_FLEX_DIRECTION_ROW: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_FLEX_DIRECTION_ROW_REVERSE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_FLEX_DIRECTION_COLUMN: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_FLEX_DIRECTION_COLUMN_REVERSE: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_FLEX_WRAP_NOWRAP: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_FLEX_WRAP_WRAP: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_FLEX_WRAP_WRAP_REVERSE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_ORDER_INITIAL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_FLOAT_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_FLOAT_LEFT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_FLOAT_RIGHT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_FLOAT_INLINE_START: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_FLOAT_INLINE_END: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_CLIP_PATH_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_CLIP_PATH_URL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_CLIP_PATH_SHAPE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_CLIP_PATH_BOX: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_FILTER_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_FILTER_URL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_FILTER_BLUR: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_FILTER_BRIGHTNESS: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_FILTER_CONTRAST: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_FILTER_GRAYSCALE: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_FILTER_INVERT: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_FILTER_OPACITY: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_FILTER_SATURATE: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_FILTER_SEPIA: ::std::os::raw::c_uint = 9;
pub const NS_STYLE_FILTER_HUE_ROTATE: ::std::os::raw::c_uint = 10;
pub const NS_STYLE_FILTER_DROP_SHADOW: ::std::os::raw::c_uint = 11;
pub const NS_STYLE_FONT_SIZE_XXSMALL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_FONT_SIZE_XSMALL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_FONT_SIZE_SMALL: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_FONT_SIZE_MEDIUM: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_FONT_SIZE_LARGE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_FONT_SIZE_XLARGE: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_FONT_SIZE_XXLARGE: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_FONT_SIZE_XXXLARGE: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_FONT_SIZE_LARGER: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_FONT_SIZE_SMALLER: ::std::os::raw::c_uint = 9;
pub const NS_STYLE_FONT_CAPTION: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_FONT_ICON: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_FONT_MENU: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_FONT_MESSAGE_BOX: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_FONT_SMALL_CAPTION: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_FONT_STATUS_BAR: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_FONT_WINDOW: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_FONT_DOCUMENT: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_FONT_WORKSPACE: ::std::os::raw::c_uint = 9;
pub const NS_STYLE_FONT_DESKTOP: ::std::os::raw::c_uint = 10;
pub const NS_STYLE_FONT_INFO: ::std::os::raw::c_uint = 11;
pub const NS_STYLE_FONT_DIALOG: ::std::os::raw::c_uint = 12;
pub const NS_STYLE_FONT_BUTTON: ::std::os::raw::c_uint = 13;
pub const NS_STYLE_FONT_PULL_DOWN_MENU: ::std::os::raw::c_uint = 14;
pub const NS_STYLE_FONT_LIST: ::std::os::raw::c_uint = 15;
pub const NS_STYLE_FONT_FIELD: ::std::os::raw::c_uint = 16;
pub const NS_STYLE_GRID_TEMPLATE_SUBGRID: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_GRID_TRACK_BREADTH_MAX_CONTENT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_GRID_TRACK_BREADTH_MIN_CONTENT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_GRID_REPEAT_AUTO_FILL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_GRID_REPEAT_AUTO_FIT: ::std::os::raw::c_uint = 1;
pub const NS_MATHML_DEFAULT_SCRIPT_MIN_SIZE_PT: ::std::os::raw::c_uint = 8;
pub const NS_MATHML_MATHVARIANT_NONE: ::std::os::raw::c_uint = 0;
pub const NS_MATHML_MATHVARIANT_NORMAL: ::std::os::raw::c_uint = 1;
pub const NS_MATHML_MATHVARIANT_BOLD: ::std::os::raw::c_uint = 2;
pub const NS_MATHML_MATHVARIANT_ITALIC: ::std::os::raw::c_uint = 3;
pub const NS_MATHML_MATHVARIANT_BOLD_ITALIC: ::std::os::raw::c_uint = 4;
pub const NS_MATHML_MATHVARIANT_SCRIPT: ::std::os::raw::c_uint = 5;
pub const NS_MATHML_MATHVARIANT_BOLD_SCRIPT: ::std::os::raw::c_uint = 6;
pub const NS_MATHML_MATHVARIANT_FRAKTUR: ::std::os::raw::c_uint = 7;
pub const NS_MATHML_MATHVARIANT_DOUBLE_STRUCK: ::std::os::raw::c_uint = 8;
pub const NS_MATHML_MATHVARIANT_BOLD_FRAKTUR: ::std::os::raw::c_uint = 9;
pub const NS_MATHML_MATHVARIANT_SANS_SERIF: ::std::os::raw::c_uint = 10;
pub const NS_MATHML_MATHVARIANT_BOLD_SANS_SERIF: ::std::os::raw::c_uint = 11;
pub const NS_MATHML_MATHVARIANT_SANS_SERIF_ITALIC: ::std::os::raw::c_uint =
    12;
pub const NS_MATHML_MATHVARIANT_SANS_SERIF_BOLD_ITALIC: ::std::os::raw::c_uint
          =
    13;
pub const NS_MATHML_MATHVARIANT_MONOSPACE: ::std::os::raw::c_uint = 14;
pub const NS_MATHML_MATHVARIANT_INITIAL: ::std::os::raw::c_uint = 15;
pub const NS_MATHML_MATHVARIANT_TAILED: ::std::os::raw::c_uint = 16;
pub const NS_MATHML_MATHVARIANT_LOOPED: ::std::os::raw::c_uint = 17;
pub const NS_MATHML_MATHVARIANT_STRETCHED: ::std::os::raw::c_uint = 18;
pub const NS_MATHML_DISPLAYSTYLE_INLINE: ::std::os::raw::c_uint = 0;
pub const NS_MATHML_DISPLAYSTYLE_BLOCK: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_WIDTH_MAX_CONTENT: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_WIDTH_MIN_CONTENT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_WIDTH_FIT_CONTENT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_WIDTH_AVAILABLE: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_POSITION_STATIC: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_POSITION_RELATIVE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_POSITION_ABSOLUTE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_POSITION_FIXED: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_POSITION_STICKY: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_CLIP_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_CLIP_RECT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_CLIP_TYPE_MASK: ::std::os::raw::c_uint = 15;
pub const NS_STYLE_CLIP_LEFT_AUTO: ::std::os::raw::c_uint = 16;
pub const NS_STYLE_CLIP_TOP_AUTO: ::std::os::raw::c_uint = 32;
pub const NS_STYLE_CLIP_RIGHT_AUTO: ::std::os::raw::c_uint = 64;
pub const NS_STYLE_CLIP_BOTTOM_AUTO: ::std::os::raw::c_uint = 128;
pub const NS_STYLE_FRAME_YES: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_FRAME_NO: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_FRAME_0: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_FRAME_1: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_FRAME_ON: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_FRAME_OFF: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_FRAME_AUTO: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_FRAME_SCROLL: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_FRAME_NOSCROLL: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_OVERFLOW_VISIBLE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_OVERFLOW_HIDDEN: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_OVERFLOW_SCROLL: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_OVERFLOW_AUTO: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_OVERFLOW_CLIP: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_OVERFLOW_SCROLLBARS_HORIZONTAL: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_OVERFLOW_SCROLLBARS_VERTICAL: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_OVERFLOW_CLIP_BOX_PADDING_BOX: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_OVERFLOW_CLIP_BOX_CONTENT_BOX: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_LIST_STYLE_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_LIST_STYLE_DISC: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_LIST_STYLE_CIRCLE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_LIST_STYLE_SQUARE: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_LIST_STYLE_DECIMAL: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_LIST_STYLE_HEBREW: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_LIST_STYLE_JAPANESE_INFORMAL: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_LIST_STYLE_JAPANESE_FORMAL: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_LIST_STYLE_KOREAN_HANGUL_FORMAL: ::std::os::raw::c_uint =
    8;
pub const NS_STYLE_LIST_STYLE_KOREAN_HANJA_INFORMAL: ::std::os::raw::c_uint =
    9;
pub const NS_STYLE_LIST_STYLE_KOREAN_HANJA_FORMAL: ::std::os::raw::c_uint =
    10;
pub const NS_STYLE_LIST_STYLE_SIMP_CHINESE_INFORMAL: ::std::os::raw::c_uint =
    11;
pub const NS_STYLE_LIST_STYLE_SIMP_CHINESE_FORMAL: ::std::os::raw::c_uint =
    12;
pub const NS_STYLE_LIST_STYLE_TRAD_CHINESE_INFORMAL: ::std::os::raw::c_uint =
    13;
pub const NS_STYLE_LIST_STYLE_TRAD_CHINESE_FORMAL: ::std::os::raw::c_uint =
    14;
pub const NS_STYLE_LIST_STYLE_ETHIOPIC_NUMERIC: ::std::os::raw::c_uint = 15;
pub const NS_STYLE_LIST_STYLE_DISCLOSURE_CLOSED: ::std::os::raw::c_uint = 16;
pub const NS_STYLE_LIST_STYLE_DISCLOSURE_OPEN: ::std::os::raw::c_uint = 17;
pub const NS_STYLE_LIST_STYLE__MAX: ::std::os::raw::c_uint = 18;
pub const NS_STYLE_LIST_STYLE_LOWER_ROMAN: ::std::os::raw::c_uint = 100;
pub const NS_STYLE_LIST_STYLE_UPPER_ROMAN: ::std::os::raw::c_uint = 101;
pub const NS_STYLE_LIST_STYLE_LOWER_ALPHA: ::std::os::raw::c_uint = 102;
pub const NS_STYLE_LIST_STYLE_UPPER_ALPHA: ::std::os::raw::c_uint = 103;
pub const NS_STYLE_LIST_STYLE_POSITION_INSIDE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_LIST_STYLE_POSITION_OUTSIDE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_MARGIN_SIZE_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_POINTER_EVENTS_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_POINTER_EVENTS_VISIBLEPAINTED: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_POINTER_EVENTS_VISIBLEFILL: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_POINTER_EVENTS_VISIBLESTROKE: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_POINTER_EVENTS_VISIBLE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_POINTER_EVENTS_PAINTED: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_POINTER_EVENTS_FILL: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_POINTER_EVENTS_STROKE: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_POINTER_EVENTS_ALL: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_POINTER_EVENTS_AUTO: ::std::os::raw::c_uint = 9;
pub const NS_STYLE_IMAGE_ORIENTATION_FLIP: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_IMAGE_ORIENTATION_FROM_IMAGE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_ISOLATION_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_ISOLATION_ISOLATE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_OBJECT_FIT_FILL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_OBJECT_FIT_CONTAIN: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_OBJECT_FIT_COVER: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_OBJECT_FIT_NONE: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_OBJECT_FIT_SCALE_DOWN: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_RESIZE_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_RESIZE_BOTH: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_RESIZE_HORIZONTAL: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_RESIZE_VERTICAL: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_TEXT_ALIGN_START: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_ALIGN_LEFT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TEXT_ALIGN_RIGHT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TEXT_ALIGN_CENTER: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_TEXT_ALIGN_JUSTIFY: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_TEXT_ALIGN_CHAR: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_TEXT_ALIGN_END: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_TEXT_ALIGN_AUTO: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_TEXT_ALIGN_MOZ_CENTER: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_TEXT_ALIGN_MOZ_RIGHT: ::std::os::raw::c_uint = 9;
pub const NS_STYLE_TEXT_ALIGN_MOZ_LEFT: ::std::os::raw::c_uint = 10;
pub const NS_STYLE_TEXT_ALIGN_MOZ_CENTER_OR_INHERIT: ::std::os::raw::c_uint =
    11;
pub const NS_STYLE_TEXT_ALIGN_UNSAFE: ::std::os::raw::c_uint = 12;
pub const NS_STYLE_TEXT_ALIGN_MATCH_PARENT: ::std::os::raw::c_uint = 13;
pub const NS_STYLE_TEXT_DECORATION_LINE_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TEXT_DECORATION_LINE_OVERLINE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH: ::std::os::raw::c_uint =
    4;
pub const NS_STYLE_TEXT_DECORATION_LINE_BLINK: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_TEXT_DECORATION_LINE_PREF_ANCHORS: ::std::os::raw::c_uint =
    16;
pub const NS_STYLE_TEXT_DECORATION_LINE_OVERRIDE_ALL: ::std::os::raw::c_uint =
    32;
pub const NS_STYLE_TEXT_DECORATION_STYLE_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_DECORATION_STYLE_DOTTED: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TEXT_DECORATION_STYLE_DASHED: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TEXT_DECORATION_STYLE_SOLID: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_TEXT_DECORATION_STYLE_DOUBLE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_TEXT_DECORATION_STYLE_WAVY: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_TEXT_OVERFLOW_CLIP: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_OVERFLOW_ELLIPSIS: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TEXT_OVERFLOW_STRING: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TEXT_TRANSFORM_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_TRANSFORM_CAPITALIZE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TEXT_TRANSFORM_LOWERCASE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TEXT_TRANSFORM_UPPERCASE: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_TEXT_TRANSFORM_FULL_WIDTH: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_TOP_LAYER_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TOP_LAYER_TOP: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TRANSFORM_BOX_BORDER_BOX: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TRANSFORM_BOX_FILL_BOX: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TRANSFORM_BOX_VIEW_BOX: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE: ::std::os::raw::c_uint =
    0;
pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_LINEAR: ::std::os::raw::c_uint =
    1;
pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN: ::std::os::raw::c_uint
          =
    2;
pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_OUT: ::std::os::raw::c_uint
          =
    3;
pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN_OUT:
          ::std::os::raw::c_uint =
    4;
pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_STEP_START:
          ::std::os::raw::c_uint =
    5;
pub const NS_STYLE_TRANSITION_TIMING_FUNCTION_STEP_END: ::std::os::raw::c_uint
          =
    6;
pub const NS_STYLE_VERTICAL_ALIGN_BASELINE: ::std::os::raw::c_uint = 14;
pub const NS_STYLE_VERTICAL_ALIGN_SUB: ::std::os::raw::c_uint = 15;
pub const NS_STYLE_VERTICAL_ALIGN_SUPER: ::std::os::raw::c_uint = 16;
pub const NS_STYLE_VERTICAL_ALIGN_TOP: ::std::os::raw::c_uint = 17;
pub const NS_STYLE_VERTICAL_ALIGN_TEXT_TOP: ::std::os::raw::c_uint = 18;
pub const NS_STYLE_VERTICAL_ALIGN_MIDDLE: ::std::os::raw::c_uint = 19;
pub const NS_STYLE_VERTICAL_ALIGN_TEXT_BOTTOM: ::std::os::raw::c_uint = 20;
pub const NS_STYLE_VERTICAL_ALIGN_BOTTOM: ::std::os::raw::c_uint = 21;
pub const NS_STYLE_VERTICAL_ALIGN_MIDDLE_WITH_BASELINE: ::std::os::raw::c_uint
          =
    22;
pub const NS_STYLE_VISIBILITY_HIDDEN: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_VISIBILITY_VISIBLE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_VISIBILITY_COLLAPSE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TABSIZE_INITIAL: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_WHITESPACE_NORMAL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_WHITESPACE_PRE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_WHITESPACE_NOWRAP: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_WHITESPACE_PRE_WRAP: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_WHITESPACE_PRE_LINE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_WHITESPACE_PRE_SPACE: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_WORDBREAK_NORMAL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_WORDBREAK_BREAK_ALL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_WORDBREAK_KEEP_ALL: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_OVERFLOWWRAP_NORMAL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_OVERFLOWWRAP_BREAK_WORD: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_HYPHENS_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_HYPHENS_MANUAL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_HYPHENS_AUTO: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_RUBY_ALIGN_START: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_RUBY_ALIGN_CENTER: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_RUBY_ALIGN_SPACE_BETWEEN: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_RUBY_ALIGN_SPACE_AROUND: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_RUBY_POSITION_OVER: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_RUBY_POSITION_UNDER: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_RUBY_POSITION_INTER_CHARACTER: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TEXT_SIZE_ADJUST_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_SIZE_ADJUST_AUTO: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TEXT_ORIENTATION_MIXED: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_ORIENTATION_UPRIGHT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TEXT_ORIENTATION_SIDEWAYS: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_ALL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_DIGITS_2: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_DIGITS_3: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_TEXT_COMBINE_UPRIGHT_DIGITS_4: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_LINE_HEIGHT_BLOCK_HEIGHT: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_UNICODE_BIDI_NORMAL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_UNICODE_BIDI_EMBED: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_UNICODE_BIDI_ISOLATE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_UNICODE_BIDI_BIDI_OVERRIDE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_UNICODE_BIDI_ISOLATE_OVERRIDE: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_UNICODE_BIDI_PLAINTEXT: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_TABLE_LAYOUT_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TABLE_LAYOUT_FIXED: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TABLE_EMPTY_CELLS_HIDE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TABLE_EMPTY_CELLS_SHOW: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_CAPTION_SIDE_TOP: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_CAPTION_SIDE_RIGHT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_CAPTION_SIDE_BOTTOM: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_CAPTION_SIDE_LEFT: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_CELL_SCOPE_ROW: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_CELL_SCOPE_COL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_CELL_SCOPE_ROWGROUP: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_CELL_SCOPE_COLGROUP: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_PAGE_MARKS_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_PAGE_MARKS_CROP: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_PAGE_MARKS_REGISTER: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_PAGE_SIZE_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_PAGE_SIZE_PORTRAIT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_PAGE_SIZE_LANDSCAPE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_PAGE_BREAK_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_PAGE_BREAK_ALWAYS: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_PAGE_BREAK_AVOID: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_PAGE_BREAK_LEFT: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_PAGE_BREAK_RIGHT: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_COLUMN_COUNT_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_COLUMN_FILL_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_COLUMN_FILL_BALANCE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_IME_MODE_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_IME_MODE_NORMAL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_IME_MODE_ACTIVE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_IME_MODE_DISABLED: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_IME_MODE_INACTIVE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_GRADIENT_SHAPE_LINEAR: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_GRADIENT_SHAPE_ELLIPTICAL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_GRADIENT_SHAPE_CIRCULAR: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_GRADIENT_SIZE_CLOSEST_SIDE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_GRADIENT_SIZE_CLOSEST_CORNER: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_GRADIENT_SIZE_FARTHEST_SIDE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_GRADIENT_SIZE_FARTHEST_CORNER: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_GRADIENT_SIZE_EXPLICIT_SIZE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_DOMINANT_BASELINE_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_DOMINANT_BASELINE_USE_SCRIPT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_DOMINANT_BASELINE_NO_CHANGE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_DOMINANT_BASELINE_RESET_SIZE: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_DOMINANT_BASELINE_IDEOGRAPHIC: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_DOMINANT_BASELINE_ALPHABETIC: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_DOMINANT_BASELINE_HANGING: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_DOMINANT_BASELINE_MATHEMATICAL: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_DOMINANT_BASELINE_CENTRAL: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_DOMINANT_BASELINE_MIDDLE: ::std::os::raw::c_uint = 9;
pub const NS_STYLE_DOMINANT_BASELINE_TEXT_AFTER_EDGE: ::std::os::raw::c_uint =
    10;
pub const NS_STYLE_DOMINANT_BASELINE_TEXT_BEFORE_EDGE: ::std::os::raw::c_uint
          =
    11;
pub const NS_STYLE_FILL_RULE_NONZERO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_FILL_RULE_EVENODD: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_IMAGE_RENDERING_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_IMAGE_RENDERING_OPTIMIZESPEED: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_IMAGE_RENDERING_OPTIMIZEQUALITY: ::std::os::raw::c_uint =
    2;
pub const NS_STYLE_IMAGE_RENDERING_CRISPEDGES: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_MASK_TYPE_LUMINANCE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_MASK_TYPE_ALPHA: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_PAINT_ORDER_NORMAL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_PAINT_ORDER_FILL: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_PAINT_ORDER_STROKE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_PAINT_ORDER_MARKERS: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_PAINT_ORDER_BITWIDTH: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_SHAPE_RENDERING_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_SHAPE_RENDERING_OPTIMIZESPEED: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_SHAPE_RENDERING_CRISPEDGES: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_SHAPE_RENDERING_GEOMETRICPRECISION: ::std::os::raw::c_uint
          =
    3;
pub const NS_STYLE_STROKE_LINECAP_BUTT: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_STROKE_LINECAP_ROUND: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_STROKE_LINECAP_SQUARE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_STROKE_LINEJOIN_MITER: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_STROKE_LINEJOIN_ROUND: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_STROKE_LINEJOIN_BEVEL: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_STROKE_PROP_CONTEXT_VALUE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_ANCHOR_START: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_ANCHOR_MIDDLE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TEXT_ANCHOR_END: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TEXT_EMPHASIS_STYLE_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_EMPHASIS_STYLE_SHAPE_MASK: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_TEXT_EMPHASIS_STYLE_DOT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TEXT_EMPHASIS_STYLE_CIRCLE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_TEXT_EMPHASIS_STYLE_DOUBLE_CIRCLE: ::std::os::raw::c_uint =
    3;
pub const NS_STYLE_TEXT_EMPHASIS_STYLE_TRIANGLE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_TEXT_EMPHASIS_STYLE_SESAME: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_TEXT_EMPHASIS_STYLE_STRING: ::std::os::raw::c_uint = 255;
pub const NS_STYLE_TEXT_RENDERING_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TEXT_RENDERING_OPTIMIZESPEED: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_TEXT_RENDERING_OPTIMIZELEGIBILITY: ::std::os::raw::c_uint =
    2;
pub const NS_STYLE_TEXT_RENDERING_GEOMETRICPRECISION: ::std::os::raw::c_uint =
    3;
pub const NS_STYLE_COLOR_ADJUST_ECONOMY: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_COLOR_ADJUST_EXACT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_COLOR_INTERPOLATION_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_COLOR_INTERPOLATION_SRGB: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_COLOR_INTERPOLATION_LINEARRGB: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_VECTOR_EFFECT_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_VECTOR_EFFECT_NON_SCALING_STROKE: ::std::os::raw::c_uint =
    1;
pub const NS_STYLE_BACKFACE_VISIBILITY_VISIBLE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_BACKFACE_VISIBILITY_HIDDEN: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TRANSFORM_STYLE_FLAT: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_TRANSFORM_STYLE_PRESERVE_3D: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_CONTEXT_FILL_OPACITY: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_CONTEXT_STROKE_OPACITY: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_BLEND_NORMAL: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_BLEND_MULTIPLY: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_BLEND_SCREEN: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_BLEND_OVERLAY: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_BLEND_DARKEN: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_BLEND_LIGHTEN: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_BLEND_COLOR_DODGE: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_BLEND_COLOR_BURN: ::std::os::raw::c_uint = 7;
pub const NS_STYLE_BLEND_HARD_LIGHT: ::std::os::raw::c_uint = 8;
pub const NS_STYLE_BLEND_SOFT_LIGHT: ::std::os::raw::c_uint = 9;
pub const NS_STYLE_BLEND_DIFFERENCE: ::std::os::raw::c_uint = 10;
pub const NS_STYLE_BLEND_EXCLUSION: ::std::os::raw::c_uint = 11;
pub const NS_STYLE_BLEND_HUE: ::std::os::raw::c_uint = 12;
pub const NS_STYLE_BLEND_SATURATION: ::std::os::raw::c_uint = 13;
pub const NS_STYLE_BLEND_COLOR: ::std::os::raw::c_uint = 14;
pub const NS_STYLE_BLEND_LUMINOSITY: ::std::os::raw::c_uint = 15;
pub const NS_STYLE_MASK_COMPOSITE_ADD: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_MASK_COMPOSITE_SUBTRACT: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_MASK_COMPOSITE_INTERSECT: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_MASK_COMPOSITE_EXCLUDE: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_CONTROL_CHARACTER_VISIBILITY_HIDDEN: ::std::os::raw::c_uint
          =
    0;
pub const NS_STYLE_CONTROL_CHARACTER_VISIBILITY_VISIBLE:
          ::std::os::raw::c_uint =
    1;
pub const NS_STYLE_COUNTER_SYSTEM_CYCLIC: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_COUNTER_SYSTEM_NUMERIC: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_COUNTER_SYSTEM_ALPHABETIC: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_COUNTER_SYSTEM_SYMBOLIC: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_COUNTER_SYSTEM_ADDITIVE: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_COUNTER_SYSTEM_FIXED: ::std::os::raw::c_uint = 5;
pub const NS_STYLE_COUNTER_SYSTEM_EXTENDS: ::std::os::raw::c_uint = 6;
pub const NS_STYLE_COUNTER_RANGE_INFINITE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_COUNTER_SPEAKAS_BULLETS: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_COUNTER_SPEAKAS_NUMBERS: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_COUNTER_SPEAKAS_WORDS: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_COUNTER_SPEAKAS_SPELL_OUT: ::std::os::raw::c_uint = 3;
pub const NS_STYLE_COUNTER_SPEAKAS_OTHER: ::std::os::raw::c_uint = 255;
pub const NS_STYLE_SCROLL_BEHAVIOR_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_SCROLL_BEHAVIOR_SMOOTH: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_SCROLL_SNAP_TYPE_NONE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_SCROLL_SNAP_TYPE_MANDATORY: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_SCROLL_SNAP_TYPE_PROXIMITY: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_ORIENTATION_PORTRAIT: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_ORIENTATION_LANDSCAPE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_SCAN_PROGRESSIVE: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_SCAN_INTERLACE: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_DISPLAY_MODE_BROWSER: ::std::os::raw::c_uint = 0;
pub const NS_STYLE_DISPLAY_MODE_MINIMAL_UI: ::std::os::raw::c_uint = 1;
pub const NS_STYLE_DISPLAY_MODE_STANDALONE: ::std::os::raw::c_uint = 2;
pub const NS_STYLE_DISPLAY_MODE_FULLSCREEN: ::std::os::raw::c_uint = 3;
pub const NS_FONT_STYLE_NORMAL: ::std::os::raw::c_uint = 0;
pub const NS_FONT_STYLE_ITALIC: ::std::os::raw::c_uint = 1;
pub const NS_FONT_STYLE_OBLIQUE: ::std::os::raw::c_uint = 2;
pub const NS_FONT_WEIGHT_NORMAL: ::std::os::raw::c_uint = 400;
pub const NS_FONT_WEIGHT_BOLD: ::std::os::raw::c_uint = 700;
pub const NS_FONT_WEIGHT_THIN: ::std::os::raw::c_uint = 100;
pub const NS_FONT_STRETCH_NORMAL: ::std::os::raw::c_uint = 0;
pub const NS_FONT_STRETCH_SEMI_EXPANDED: ::std::os::raw::c_uint = 1;
pub const NS_FONT_STRETCH_EXPANDED: ::std::os::raw::c_uint = 2;
pub const NS_FONT_STRETCH_EXTRA_EXPANDED: ::std::os::raw::c_uint = 3;
pub const NS_FONT_STRETCH_ULTRA_EXPANDED: ::std::os::raw::c_uint = 4;
pub const NS_FONT_SMOOTHING_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_FONT_SMOOTHING_GRAYSCALE: ::std::os::raw::c_uint = 1;
pub const NS_FONT_KERNING_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_FONT_KERNING_NONE: ::std::os::raw::c_uint = 1;
pub const NS_FONT_KERNING_NORMAL: ::std::os::raw::c_uint = 2;
pub const NS_FONT_SYNTHESIS_WEIGHT: ::std::os::raw::c_uint = 1;
pub const NS_FONT_SYNTHESIS_STYLE: ::std::os::raw::c_uint = 2;
pub const NS_FONT_DISPLAY_AUTO: ::std::os::raw::c_uint = 0;
pub const NS_FONT_DISPLAY_BLOCK: ::std::os::raw::c_uint = 1;
pub const NS_FONT_DISPLAY_SWAP: ::std::os::raw::c_uint = 2;
pub const NS_FONT_DISPLAY_FALLBACK: ::std::os::raw::c_uint = 3;
pub const NS_FONT_DISPLAY_OPTIONAL: ::std::os::raw::c_uint = 4;
pub const NS_FONT_VARIANT_CAPS_NORMAL: ::std::os::raw::c_uint = 0;
pub const NS_FONT_VARIANT_CAPS_SMALLCAPS: ::std::os::raw::c_uint = 1;
pub const NS_FONT_VARIANT_CAPS_ALLSMALL: ::std::os::raw::c_uint = 2;
pub const NS_FONT_VARIANT_CAPS_PETITECAPS: ::std::os::raw::c_uint = 3;
pub const NS_FONT_VARIANT_CAPS_ALLPETITE: ::std::os::raw::c_uint = 4;
pub const NS_FONT_VARIANT_CAPS_TITLING: ::std::os::raw::c_uint = 5;
pub const NS_FONT_VARIANT_CAPS_UNICASE: ::std::os::raw::c_uint = 6;
pub const NS_FONT_VARIANT_POSITION_NORMAL: ::std::os::raw::c_uint = 0;
pub const NS_FONT_VARIANT_POSITION_SUPER: ::std::os::raw::c_uint = 1;
pub const NS_FONT_VARIANT_POSITION_SUB: ::std::os::raw::c_uint = 2;
pub const NS_FONT_VARIANT_WIDTH_NORMAL: ::std::os::raw::c_uint = 0;
pub const NS_FONT_VARIANT_WIDTH_FULL: ::std::os::raw::c_uint = 1;
pub const NS_FONT_VARIANT_WIDTH_HALF: ::std::os::raw::c_uint = 2;
pub const NS_FONT_VARIANT_WIDTH_THIRD: ::std::os::raw::c_uint = 3;
pub const NS_FONT_VARIANT_WIDTH_QUARTER: ::std::os::raw::c_uint = 4;
pub const NS_STYLE_INHERIT_MASK: ::std::os::raw::c_uint = 16777215;
pub const NS_STYLE_HAS_TEXT_DECORATION_LINES: ::std::os::raw::c_uint =
    16777216;
pub const NS_STYLE_HAS_PSEUDO_ELEMENT_DATA: ::std::os::raw::c_uint = 33554432;
pub const NS_STYLE_RELEVANT_LINK_VISITED: ::std::os::raw::c_uint = 67108864;
pub const NS_STYLE_IS_STYLE_IF_VISITED: ::std::os::raw::c_uint = 134217728;
pub const NS_STYLE_CHILD_USES_GRANDANCESTOR_STYLE: ::std::os::raw::c_uint =
    268435456;
pub const NS_STYLE_IS_SHARED: ::std::os::raw::c_uint = 536870912;
pub const NS_STYLE_IS_GOING_AWAY: ::std::os::raw::c_uint = 1073741824;
pub const NS_STYLE_SUPPRESS_LINEBREAK: ::std::os::raw::c_uint = 2147483648;
pub const NS_STYLE_IN_DISPLAY_NONE_SUBTREE: ::std::os::raw::c_ulonglong =
    4294967296;
pub const NS_STYLE_INELIGIBLE_FOR_SHARING: ::std::os::raw::c_ulonglong =
    8589934592;
pub const NS_STYLE_HAS_CHILD_THAT_USES_RESET_STYLE:
          ::std::os::raw::c_ulonglong =
    17179869184;
pub const NS_STYLE_IS_TEXT_COMBINED: ::std::os::raw::c_ulonglong =
    34359738368;
pub const NS_STYLE_CONTEXT_TYPE_SHIFT: ::std::os::raw::c_uint = 36;
pub const NS_RULE_NODE_IS_ANIMATION_RULE: ::std::os::raw::c_uint = 16777216;
pub const NS_RULE_NODE_USED_DIRECTLY: ::std::os::raw::c_uint = 67108864;
pub const NS_RULE_NODE_IS_IMPORTANT: ::std::os::raw::c_uint = 134217728;
pub const NS_RULE_NODE_LEVEL_MASK: ::std::os::raw::c_uint = 4026531840;
pub const NS_RULE_NODE_LEVEL_SHIFT: ::std::os::raw::c_uint = 28;
pub const NS_RULE_NODE_HAS_ANIMATION_DATA: ::std::os::raw::c_uint =
    2147483648;
pub const BORDER_COLOR_FOREGROUND: ::std::os::raw::c_uint = 32;
pub const OUTLINE_COLOR_INITIAL: ::std::os::raw::c_uint = 128;
pub const BORDER_COLOR_SPECIAL: ::std::os::raw::c_uint = 160;
pub const BORDER_STYLE_MASK: ::std::os::raw::c_uint = 31;
pub const NS_SPACING_MARGIN: ::std::os::raw::c_uint = 0;
pub const NS_SPACING_PADDING: ::std::os::raw::c_uint = 1;
pub const NS_SPACING_BORDER: ::std::os::raw::c_uint = 2;
/**
 * MozRefCountType is Mozilla's reference count type.
 *
 * We use the same type to represent the refcount of RefCounted objects
 * as well, in order to be able to use the leak detection facilities
 * that are implemented by XPCOM.
 *
 * Note that this type is not in the mozilla namespace so that it is
 * usable for both C and C++ code.
 */
pub type MozRefCountType = usize;
pub type MozExternalRefCountType = u32;
pub const NS_ERROR_NO_INTERFACE: nsresult = nsresult::NS_NOINTERFACE;
pub const NS_ERROR_INVALID_ARG: nsresult = nsresult::NS_ERROR_ILLEGAL_VALUE;
pub const NS_ERROR_INVALID_POINTER: nsresult =
    nsresult::NS_ERROR_ILLEGAL_VALUE;
pub const NS_ERROR_NULL_POINTER: nsresult = nsresult::NS_ERROR_ILLEGAL_VALUE;
pub const NS_BINDING_SUCCEEDED: nsresult = nsresult::NS_OK;
pub const NS_NET_STATUS_RESOLVING_HOST: nsresult =
    nsresult::NS_BINDING_REDIRECTED;
pub const NS_NET_STATUS_RESOLVED_HOST: nsresult =
    nsresult::NS_ERROR_ALREADY_CONNECTED;
pub const NS_NET_STATUS_CONNECTED_TO: nsresult =
    nsresult::NS_BINDING_RETARGETED;
pub const NS_NET_STATUS_WAITING_FOR: nsresult =
    nsresult::NS_ERROR_MALFORMED_URI;
pub const NS_STATE_PROPERTY_EXISTS: nsresult = nsresult::NS_OK;
pub const NS_ERROR_HTMLPARSER_CONTINUE: nsresult = nsresult::NS_OK;
pub const NS_RDF_ASSERTION_ACCEPTED: nsresult = nsresult::NS_OK;
pub const NS_EXACT_LENGTH: nsresult = nsresult::NS_OK_UDEC_EXACTLENGTH;
pub const NS_PARTIAL_MORE_INPUT: nsresult = nsresult::NS_OK_UDEC_MOREINPUT;
pub const NS_PARTIAL_MORE_OUTPUT: nsresult = nsresult::NS_OK_UDEC_MOREOUTPUT;
pub const NS_ERROR_ILLEGAL_INPUT: nsresult =
    nsresult::NS_ERROR_UDEC_ILLEGALINPUT;
pub const NS_ERROR_XPATH_INVALID_ARG: nsresult =
    nsresult::NS_ERROR_ILLEGAL_VALUE;
pub const NS_SUCCESS_RESTART_APP: nsresult = nsresult::NS_SUCCESS_DONT_FIXUP;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsresult {
    NS_OK = 0,
    NS_ERROR_BASE = -1041039360,
    NS_ERROR_NOT_INITIALIZED = -1041039359,
    NS_ERROR_ALREADY_INITIALIZED = -1041039358,
    NS_ERROR_NOT_IMPLEMENTED = -2147467263,
    NS_NOINTERFACE = -2147467262,
    NS_ERROR_ABORT = -2147467260,
    NS_ERROR_FAILURE = -2147467259,
    NS_ERROR_UNEXPECTED = -2147418113,
    NS_ERROR_OUT_OF_MEMORY = -2147024882,
    NS_ERROR_ILLEGAL_VALUE = -2147024809,
    NS_ERROR_NO_AGGREGATION = -2147221232,
    NS_ERROR_NOT_AVAILABLE = -2147221231,
    NS_ERROR_FACTORY_NOT_REGISTERED = -2147221164,
    NS_ERROR_FACTORY_REGISTER_AGAIN = -2147221163,
    NS_ERROR_FACTORY_NOT_LOADED = -2147221000,
    NS_ERROR_FACTORY_NO_SIGNATURE_SUPPORT = -1041039103,
    NS_ERROR_FACTORY_EXISTS = -1041039104,
    NS_ERROR_CANNOT_CONVERT_DATA = -2142896127,
    NS_ERROR_OBJECT_IS_IMMUTABLE = -2142896126,
    NS_ERROR_LOSS_OF_SIGNIFICANT_DATA = -2142896125,
    NS_ERROR_NOT_SAME_THREAD = -2142896124,
    NS_ERROR_ILLEGAL_DURING_SHUTDOWN = -2142896098,
    NS_ERROR_SERVICE_NOT_AVAILABLE = -2142896106,
    NS_SUCCESS_LOSS_OF_INSIGNIFICANT_DATA = 4587521,
    NS_SUCCESS_INTERRUPTED_TRAVERSE = 4587522,
    NS_ERROR_SERVICE_NOT_FOUND = 4587542,
    NS_ERROR_SERVICE_IN_USE = 4587543,
    NS_BASE_STREAM_CLOSED = -2142830590,
    NS_BASE_STREAM_OSERROR = -2142830589,
    NS_BASE_STREAM_ILLEGAL_ARGS = -2142830588,
    NS_BASE_STREAM_NO_CONVERTER = -2142830587,
    NS_BASE_STREAM_BAD_CONVERSION = -2142830586,
    NS_BASE_STREAM_WOULD_BLOCK = -2142830585,
    NS_ERROR_GFX_PRINTER_NO_PRINTER_AVAILABLE = -2142765055,
    NS_ERROR_GFX_PRINTER_NAME_NOT_FOUND = -2142765054,
    NS_ERROR_GFX_PRINTER_COULD_NOT_OPEN_FILE = -2142765053,
    NS_ERROR_GFX_PRINTER_STARTDOC = -2142765052,
    NS_ERROR_GFX_PRINTER_ENDDOC = -2142765051,
    NS_ERROR_GFX_PRINTER_STARTPAGE = -2142765050,
    NS_ERROR_GFX_PRINTER_DOC_IS_BUSY = -2142765049,
    NS_ERROR_GFX_CMAP_MALFORMED = -2142765005,
    NS_SUCCESS_EVENT_CONSUMED = 4784129,
    NS_SUCCESS_EVENT_HANDLED_ASYNCHRONOUSLY = 4784130,
    NS_BINDING_FAILED = -2142568447,
    NS_BINDING_ABORTED = -2142568446,
    NS_BINDING_REDIRECTED = -2142568445,
    NS_BINDING_RETARGETED = -2142568444,
    NS_ERROR_MALFORMED_URI = -2142568438,
    NS_ERROR_IN_PROGRESS = -2142568433,
    NS_ERROR_NO_CONTENT = -2142568431,
    NS_ERROR_UNKNOWN_PROTOCOL = -2142568430,
    NS_ERROR_INVALID_CONTENT_ENCODING = -2142568421,
    NS_ERROR_CORRUPTED_CONTENT = -2142568419,
    NS_ERROR_INVALID_SIGNATURE = -2142568390,
    NS_ERROR_FIRST_HEADER_FIELD_COMPONENT_EMPTY = -2142568414,
    NS_ERROR_ALREADY_OPENED = -2142568375,
    NS_ERROR_ALREADY_CONNECTED = -2142568437,
    NS_ERROR_NOT_CONNECTED = -2142568436,
    NS_ERROR_CONNECTION_REFUSED = -2142568435,
    NS_ERROR_NET_TIMEOUT = -2142568434,
    NS_ERROR_OFFLINE = -2142568432,
    NS_ERROR_PORT_ACCESS_NOT_ALLOWED = -2142568429,
    NS_ERROR_NET_RESET = -2142568428,
    NS_ERROR_NET_INTERRUPT = -2142568377,
    NS_ERROR_PROXY_CONNECTION_REFUSED = -2142568376,
    NS_ERROR_NET_PARTIAL_TRANSFER = -2142568372,
    NS_ERROR_NET_INADEQUATE_SECURITY = -2142568366,
    NS_ERROR_NOT_RESUMABLE = -2142568423,
    NS_ERROR_REDIRECT_LOOP = -2142568417,
    NS_ERROR_ENTITY_CHANGED = -2142568416,
    NS_ERROR_UNSAFE_CONTENT_TYPE = -2142568374,
    NS_ERROR_REMOTE_XUL = -2142568373,
    NS_ERROR_LOAD_SHOWED_ERRORPAGE = -2142568371,
    NS_ERROR_FTP_LOGIN = -2142568427,
    NS_ERROR_FTP_CWD = -2142568426,
    NS_ERROR_FTP_PASV = -2142568425,
    NS_ERROR_FTP_PWD = -2142568424,
    NS_ERROR_FTP_LIST = -2142568420,
    NS_ERROR_UNKNOWN_HOST = -2142568418,
    NS_ERROR_DNS_LOOKUP_QUEUE_FULL = -2142568415,
    NS_ERROR_UNKNOWN_PROXY_HOST = -2142568406,
    NS_ERROR_UNKNOWN_SOCKET_TYPE = -2142568397,
    NS_ERROR_SOCKET_CREATE_FAILED = -2142568396,
    NS_ERROR_SOCKET_ADDRESS_NOT_SUPPORTED = -2142568395,
    NS_ERROR_SOCKET_ADDRESS_IN_USE = -2142568394,
    NS_ERROR_CACHE_KEY_NOT_FOUND = -2142568387,
    NS_ERROR_CACHE_DATA_IS_STREAM = -2142568386,
    NS_ERROR_CACHE_DATA_IS_NOT_STREAM = -2142568385,
    NS_ERROR_CACHE_WAIT_FOR_VALIDATION = -2142568384,
    NS_ERROR_CACHE_ENTRY_DOOMED = -2142568383,
    NS_ERROR_CACHE_READ_ACCESS_DENIED = -2142568382,
    NS_ERROR_CACHE_WRITE_ACCESS_DENIED = -2142568381,
    NS_ERROR_CACHE_IN_USE = -2142568380,
    NS_ERROR_DOCUMENT_NOT_CACHED = -2142568378,
    NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS = -2142568368,
    NS_ERROR_HOST_IS_IP_ADDRESS = -2142568367,
    NS_SUCCESS_ADOPTED_DATA = 4915290,
    NS_NET_STATUS_BEGIN_FTP_TRANSACTION = 4915227,
    NS_NET_STATUS_END_FTP_TRANSACTION = 4915228,
    NS_SUCCESS_AUTH_FINISHED = 4915240,
    NS_NET_STATUS_READING = -2142568440,
    NS_NET_STATUS_WRITING = -2142568439,
    NS_NET_STATUS_CONNECTING_TO = -2142568441,
    NS_NET_STATUS_SENDING_TO = -2142568443,
    NS_NET_STATUS_RECEIVING_FROM = -2142568442,
    NS_ERROR_INTERCEPTION_FAILED = -2142568348,
    NS_ERROR_PLUGINS_PLUGINSNOTCHANGED = -2142501912,
    NS_ERROR_PLUGIN_DISABLED = -2142501911,
    NS_ERROR_PLUGIN_BLOCKLISTED = -2142501910,
    NS_ERROR_PLUGIN_TIME_RANGE_NOT_SUPPORTED = -2142501909,
    NS_ERROR_PLUGIN_CLICKTOPLAY = -2142501908,
    NS_PLUGIN_INIT_PENDING = 4981741,
    NS_TABLELAYOUT_CELL_NOT_FOUND = 5046272,
    NS_POSITION_BEFORE_TABLE = 5046275,
    NS_STATE_PROPERTY_NOT_THERE = 5046277,
    NS_ERROR_HTMLPARSER_EOF = -2142370840,
    NS_ERROR_HTMLPARSER_UNKNOWN = -2142370839,
    NS_ERROR_HTMLPARSER_CANTPROPAGATE = -2142370838,
    NS_ERROR_HTMLPARSER_CONTEXTMISMATCH = -2142370837,
    NS_ERROR_HTMLPARSER_BADFILENAME = -2142370836,
    NS_ERROR_HTMLPARSER_BADURL = -2142370835,
    NS_ERROR_HTMLPARSER_INVALIDPARSERCONTEXT = -2142370834,
    NS_ERROR_HTMLPARSER_INTERRUPTED = -2142370833,
    NS_ERROR_HTMLPARSER_BLOCK = -2142370832,
    NS_ERROR_HTMLPARSER_BADTOKENIZER = -2142370831,
    NS_ERROR_HTMLPARSER_BADATTRIBUTE = -2142370830,
    NS_ERROR_HTMLPARSER_UNRESOLVEDDTD = -2142370829,
    NS_ERROR_HTMLPARSER_MISPLACEDTABLECONTENT = -2142370828,
    NS_ERROR_HTMLPARSER_BADDTD = -2142370827,
    NS_ERROR_HTMLPARSER_BADCONTEXT = -2142370826,
    NS_ERROR_HTMLPARSER_STOPPARSING = -2142370825,
    NS_ERROR_HTMLPARSER_UNTERMINATEDSTRINGLITERAL = -2142370824,
    NS_ERROR_HTMLPARSER_HIERARCHYTOODEEP = -2142370823,
    NS_ERROR_HTMLPARSER_FAKE_ENDTAG = -2142370822,
    NS_ERROR_HTMLPARSER_INVALID_COMMENT = -2142370821,
    NS_HTMLTOKENS_NOT_AN_ENTITY = 5113808,
    NS_HTMLPARSER_VALID_META_CHARSET = 5114808,
    NS_RDF_CURSOR_EMPTY = 5177345,
    NS_RDF_NO_VALUE = 5177346,
    NS_RDF_ASSERTION_REJECTED = 5177347,
    NS_RDF_STOP_VISIT = 5177348,
    NS_ERROR_UCONV_NOCONV = -2142240767,
    NS_ERROR_UDEC_ILLEGALINPUT = -2142240754,
    NS_SUCCESS_USING_FALLBACK_LOCALE = 5242882,
    NS_OK_UDEC_EXACTLENGTH = 5242891,
    NS_OK_UDEC_MOREINPUT = 5242892,
    NS_OK_UDEC_MOREOUTPUT = 5242893,
    NS_OK_UDEC_NOBOMFOUND = 5242894,
    NS_OK_UENC_EXACTLENGTH = 5242913,
    NS_OK_UENC_MOREOUTPUT = 5242914,
    NS_ERROR_UENC_NOMAPPING = 5242915,
    NS_OK_UENC_MOREINPUT = 5242916,
    NS_ERROR_FILE_UNRECOGNIZED_PATH = -2142109695,
    NS_ERROR_FILE_UNRESOLVABLE_SYMLINK = -2142109694,
    NS_ERROR_FILE_EXECUTION_FAILED = -2142109693,
    NS_ERROR_FILE_UNKNOWN_TYPE = -2142109692,
    NS_ERROR_FILE_DESTINATION_NOT_DIR = -2142109691,
    NS_ERROR_FILE_TARGET_DOES_NOT_EXIST = -2142109690,
    NS_ERROR_FILE_COPY_OR_MOVE_FAILED = -2142109689,
    NS_ERROR_FILE_ALREADY_EXISTS = -2142109688,
    NS_ERROR_FILE_INVALID_PATH = -2142109687,
    NS_ERROR_FILE_DISK_FULL = -2142109686,
    NS_ERROR_FILE_CORRUPTED = -2142109685,
    NS_ERROR_FILE_NOT_DIRECTORY = -2142109684,
    NS_ERROR_FILE_IS_DIRECTORY = -2142109683,
    NS_ERROR_FILE_IS_LOCKED = -2142109682,
    NS_ERROR_FILE_TOO_BIG = -2142109681,
    NS_ERROR_FILE_NO_DEVICE_SPACE = -2142109680,
    NS_ERROR_FILE_NAME_TOO_LONG = -2142109679,
    NS_ERROR_FILE_NOT_FOUND = -2142109678,
    NS_ERROR_FILE_READ_ONLY = -2142109677,
    NS_ERROR_FILE_DIR_NOT_EMPTY = -2142109676,
    NS_ERROR_FILE_ACCESS_DENIED = -2142109675,
    NS_SUCCESS_FILE_DIRECTORY_EMPTY = 5373953,
    NS_SUCCESS_AGGREGATE_RESULT = 5373954,
    NS_ERROR_DOM_INDEX_SIZE_ERR = -2142044159,
    NS_ERROR_DOM_HIERARCHY_REQUEST_ERR = -2142044157,
    NS_ERROR_DOM_WRONG_DOCUMENT_ERR = -2142044156,
    NS_ERROR_DOM_INVALID_CHARACTER_ERR = -2142044155,
    NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR = -2142044153,
    NS_ERROR_DOM_NOT_FOUND_ERR = -2142044152,
    NS_ERROR_DOM_NOT_SUPPORTED_ERR = -2142044151,
    NS_ERROR_DOM_INUSE_ATTRIBUTE_ERR = -2142044150,
    NS_ERROR_DOM_INVALID_STATE_ERR = -2142044149,
    NS_ERROR_DOM_SYNTAX_ERR = -2142044148,
    NS_ERROR_DOM_INVALID_MODIFICATION_ERR = -2142044147,
    NS_ERROR_DOM_NAMESPACE_ERR = -2142044146,
    NS_ERROR_DOM_INVALID_ACCESS_ERR = -2142044145,
    NS_ERROR_DOM_TYPE_MISMATCH_ERR = -2142044143,
    NS_ERROR_DOM_SECURITY_ERR = -2142044142,
    NS_ERROR_DOM_NETWORK_ERR = -2142044141,
    NS_ERROR_DOM_ABORT_ERR = -2142044140,
    NS_ERROR_DOM_URL_MISMATCH_ERR = -2142044139,
    NS_ERROR_DOM_QUOTA_EXCEEDED_ERR = -2142044138,
    NS_ERROR_DOM_TIMEOUT_ERR = -2142044137,
    NS_ERROR_DOM_INVALID_NODE_TYPE_ERR = -2142044136,
    NS_ERROR_DOM_DATA_CLONE_ERR = -2142044135,
    NS_ERROR_TYPE_ERR = -2142044134,
    NS_ERROR_RANGE_ERR = -2142044133,
    NS_ERROR_DOM_ENCODING_NOT_SUPPORTED_ERR = -2142044132,
    NS_ERROR_DOM_INVALID_POINTER_ERR = -2142044131,
    NS_ERROR_DOM_UNKNOWN_ERR = -2142044130,
    NS_ERROR_DOM_DATA_ERR = -2142044129,
    NS_ERROR_DOM_OPERATION_ERR = -2142044128,
    NS_ERROR_DOM_SECMAN_ERR = -2142043159,
    NS_ERROR_DOM_WRONG_TYPE_ERR = -2142043158,
    NS_ERROR_DOM_NOT_OBJECT_ERR = -2142043157,
    NS_ERROR_DOM_NOT_XPC_OBJECT_ERR = -2142043156,
    NS_ERROR_DOM_NOT_NUMBER_ERR = -2142043155,
    NS_ERROR_DOM_NOT_BOOLEAN_ERR = -2142043154,
    NS_ERROR_DOM_NOT_FUNCTION_ERR = -2142043153,
    NS_ERROR_DOM_TOO_FEW_PARAMETERS_ERR = -2142043152,
    NS_ERROR_DOM_BAD_DOCUMENT_DOMAIN = -2142043151,
    NS_ERROR_DOM_PROP_ACCESS_DENIED = -2142043150,
    NS_ERROR_DOM_XPCONNECT_ACCESS_DENIED = -2142043149,
    NS_ERROR_DOM_BAD_URI = -2142043148,
    NS_ERROR_DOM_RETVAL_UNDEFINED = -2142043147,
    NS_ERROR_DOM_QUOTA_REACHED = -2142043146,
    NS_ERROR_DOM_JS_EXCEPTION = -2142043145,
    NS_ERROR_UNCATCHABLE_EXCEPTION = -2142043144,
    NS_ERROR_DOM_DOMEXCEPTION = -2142043143,
    NS_ERROR_DOM_EXCEPTION_ON_JSCONTEXT = -2142043142,
    NS_SUCCESS_DOM_NO_OPERATION = 5439489,
    NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW = 5439490,
    NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW_UNCATCHABLE = 5439491,
    NS_IMAGELIB_SUCCESS_LOAD_FINISHED = 5505024,
    NS_IMAGELIB_CHANGING_OWNER = 5505025,
    NS_IMAGELIB_ERROR_FAILURE = -2141978619,
    NS_IMAGELIB_ERROR_NO_DECODER = -2141978618,
    NS_IMAGELIB_ERROR_NOT_FINISHED = -2141978617,
    NS_IMAGELIB_ERROR_NO_ENCODER = -2141978615,
    NS_ERROR_EDITOR_NO_SELECTION = -2141847551,
    NS_ERROR_EDITOR_NO_TEXTNODE = -2141847550,
    NS_FOUND_TARGET = -2141847549,
    NS_EDITOR_ELEMENT_NOT_FOUND = 5636097,
    NS_ERROR_XPC_NOT_ENOUGH_ARGS = -2141782015,
    NS_ERROR_XPC_NEED_OUT_OBJECT = -2141782014,
    NS_ERROR_XPC_CANT_SET_OUT_VAL = -2141782013,
    NS_ERROR_XPC_NATIVE_RETURNED_FAILURE = -2141782012,
    NS_ERROR_XPC_CANT_GET_INTERFACE_INFO = -2141782011,
    NS_ERROR_XPC_CANT_GET_PARAM_IFACE_INFO = -2141782010,
    NS_ERROR_XPC_CANT_GET_METHOD_INFO = -2141782009,
    NS_ERROR_XPC_UNEXPECTED = -2141782008,
    NS_ERROR_XPC_BAD_CONVERT_JS = -2141782007,
    NS_ERROR_XPC_BAD_CONVERT_NATIVE = -2141782006,
    NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF = -2141782005,
    NS_ERROR_XPC_BAD_OP_ON_WN_PROTO = -2141782004,
    NS_ERROR_XPC_CANT_CONVERT_WN_TO_FUN = -2141782003,
    NS_ERROR_XPC_CANT_DEFINE_PROP_ON_WN = -2141782002,
    NS_ERROR_XPC_CANT_WATCH_WN_STATIC = -2141782001,
    NS_ERROR_XPC_CANT_EXPORT_WN_STATIC = -2141782000,
    NS_ERROR_XPC_SCRIPTABLE_CALL_FAILED = -2141781999,
    NS_ERROR_XPC_SCRIPTABLE_CTOR_FAILED = -2141781998,
    NS_ERROR_XPC_CANT_CALL_WO_SCRIPTABLE = -2141781997,
    NS_ERROR_XPC_CANT_CTOR_WO_SCRIPTABLE = -2141781996,
    NS_ERROR_XPC_CI_RETURNED_FAILURE = -2141781995,
    NS_ERROR_XPC_GS_RETURNED_FAILURE = -2141781994,
    NS_ERROR_XPC_BAD_CID = -2141781993,
    NS_ERROR_XPC_BAD_IID = -2141781992,
    NS_ERROR_XPC_CANT_CREATE_WN = -2141781991,
    NS_ERROR_XPC_JS_THREW_EXCEPTION = -2141781990,
    NS_ERROR_XPC_JS_THREW_NATIVE_OBJECT = -2141781989,
    NS_ERROR_XPC_JS_THREW_JS_OBJECT = -2141781988,
    NS_ERROR_XPC_JS_THREW_NULL = -2141781987,
    NS_ERROR_XPC_JS_THREW_STRING = -2141781986,
    NS_ERROR_XPC_JS_THREW_NUMBER = -2141781985,
    NS_ERROR_XPC_JAVASCRIPT_ERROR = -2141781984,
    NS_ERROR_XPC_JAVASCRIPT_ERROR_WITH_DETAILS = -2141781983,
    NS_ERROR_XPC_CANT_CONVERT_PRIMITIVE_TO_ARRAY = -2141781982,
    NS_ERROR_XPC_CANT_CONVERT_OBJECT_TO_ARRAY = -2141781981,
    NS_ERROR_XPC_NOT_ENOUGH_ELEMENTS_IN_ARRAY = -2141781980,
    NS_ERROR_XPC_CANT_GET_ARRAY_INFO = -2141781979,
    NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING = -2141781978,
    NS_ERROR_XPC_SECURITY_MANAGER_VETO = -2141781977,
    NS_ERROR_XPC_INTERFACE_NOT_SCRIPTABLE = -2141781976,
    NS_ERROR_XPC_INTERFACE_NOT_FROM_NSISUPPORTS = -2141781975,
    NS_ERROR_XPC_CANT_GET_JSOBJECT_OF_DOM_OBJECT = -2141781974,
    NS_ERROR_XPC_CANT_SET_READ_ONLY_CONSTANT = -2141781973,
    NS_ERROR_XPC_CANT_SET_READ_ONLY_ATTRIBUTE = -2141781972,
    NS_ERROR_XPC_CANT_SET_READ_ONLY_METHOD = -2141781971,
    NS_ERROR_XPC_CANT_ADD_PROP_TO_WRAPPED_NATIVE = -2141781970,
    NS_ERROR_XPC_CALL_TO_SCRIPTABLE_FAILED = -2141781969,
    NS_ERROR_XPC_JSOBJECT_HAS_NO_FUNCTION_NAMED = -2141781968,
    NS_ERROR_XPC_BAD_ID_STRING = -2141781967,
    NS_ERROR_XPC_BAD_INITIALIZER_NAME = -2141781966,
    NS_ERROR_XPC_HAS_BEEN_SHUTDOWN = -2141781965,
    NS_ERROR_XPC_CANT_MODIFY_PROP_ON_WN = -2141781964,
    NS_ERROR_XPC_BAD_CONVERT_JS_ZERO_ISNOT_NULL = -2141781963,
    NS_ERROR_XPC_CANT_PASS_CPOW_TO_NATIVE = -2141781962,
    NS_ERROR_LAUNCHED_CHILD_PROCESS = -2141716280,
    NS_ERROR_CSP_FORM_ACTION_VIOLATION = -2141585310,
    NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION = -2141585309,
    NS_ERROR_SRI_CORRUPT = -2141585208,
    NS_ERROR_SRI_DISABLED = -2141585207,
    NS_ERROR_SRI_NOT_ELIGIBLE = -2141585206,
    NS_ERROR_CMS_VERIFY_NOT_SIGNED = -2141584384,
    NS_ERROR_CMS_VERIFY_NO_CONTENT_INFO = -2141584383,
    NS_ERROR_CMS_VERIFY_BAD_DIGEST = -2141584382,
    NS_ERROR_CMS_VERIFY_NOCERT = -2141584380,
    NS_ERROR_CMS_VERIFY_UNTRUSTED = -2141584379,
    NS_ERROR_CMS_VERIFY_ERROR_UNVERIFIED = -2141584377,
    NS_ERROR_CMS_VERIFY_ERROR_PROCESSING = -2141584376,
    NS_ERROR_CMS_VERIFY_BAD_SIGNATURE = -2141584375,
    NS_ERROR_CMS_VERIFY_DIGEST_MISMATCH = -2141584374,
    NS_ERROR_CMS_VERIFY_UNKNOWN_ALGO = -2141584373,
    NS_ERROR_CMS_VERIFY_UNSUPPORTED_ALGO = -2141584372,
    NS_ERROR_CMS_VERIFY_MALFORMED_SIGNATURE = -2141584371,
    NS_ERROR_CMS_VERIFY_HEADER_MISMATCH = -2141584370,
    NS_ERROR_CMS_VERIFY_NOT_YET_ATTEMPTED = -2141584369,
    NS_ERROR_CMS_VERIFY_CERT_WITHOUT_ADDRESS = -2141584368,
    NS_ERROR_CMS_ENCRYPT_NO_BULK_ALG = -2141584352,
    NS_ERROR_CMS_ENCRYPT_INCOMPLETE = -2141584351,
    NS_ERROR_DOM_INVALID_EXPRESSION_ERR = -2141519821,
    NS_ERROR_DOM_TYPE_ERR = -2141519820,
    NS_ERROR_WONT_HANDLE_CONTENT = -2141388799,
    NS_ERROR_MALWARE_URI = -2141388770,
    NS_ERROR_PHISHING_URI = -2141388769,
    NS_ERROR_TRACKING_URI = -2141388766,
    NS_ERROR_UNWANTED_URI = -2141388765,
    NS_ERROR_BLOCKED_URI = -2141388763,
    NS_ERROR_SAVE_LINK_AS_TIMEOUT = -2141388768,
    NS_ERROR_PARSED_DATA_CACHED = -2141388767,
    NS_REFRESHURI_HEADER_FOUND = 6094850,
    NS_ERROR_IMAGE_SRC_CHANGED = -2141323260,
    NS_ERROR_IMAGE_BLOCKED = -2141323259,
    NS_ERROR_CONTENT_BLOCKED = -2141323258,
    NS_ERROR_CONTENT_BLOCKED_SHOW_ALT = -2141323257,
    NS_PROPTABLE_PROP_NOT_THERE = -2141323254,
    NS_ERROR_XBL_BLOCKED = -2141323249,
    NS_ERROR_CONTENT_CRASHED = -2141323248,
    NS_HTML_STYLE_PROPERTY_NOT_THERE = 6160386,
    NS_CONTENT_BLOCKED = 6160392,
    NS_CONTENT_BLOCKED_SHOW_ALT = 6160393,
    NS_PROPTABLE_PROP_OVERWRITTEN = 6160395,
    NS_FINDBROADCASTER_NOT_FOUND = 6160396,
    NS_FINDBROADCASTER_FOUND = 6160397,
    NS_FINDBROADCASTER_AWAIT_OVERLAYS = 6160398,
    NS_ERROR_XSLT_PARSE_FAILURE = -2141192191,
    NS_ERROR_XPATH_PARSE_FAILURE = -2141192190,
    NS_ERROR_XSLT_ALREADY_SET = -2141192189,
    NS_ERROR_XSLT_EXECUTION_FAILURE = -2141192188,
    NS_ERROR_XPATH_UNKNOWN_FUNCTION = -2141192187,
    NS_ERROR_XSLT_BAD_RECURSION = -2141192186,
    NS_ERROR_XSLT_BAD_VALUE = -2141192185,
    NS_ERROR_XSLT_NODESET_EXPECTED = -2141192184,
    NS_ERROR_XSLT_ABORTED = -2141192183,
    NS_ERROR_XSLT_NETWORK_ERROR = -2141192182,
    NS_ERROR_XSLT_WRONG_MIME_TYPE = -2141192181,
    NS_ERROR_XSLT_LOAD_RECURSION = -2141192180,
    NS_ERROR_XPATH_BAD_ARGUMENT_COUNT = -2141192179,
    NS_ERROR_XPATH_BAD_EXTENSION_FUNCTION = -2141192178,
    NS_ERROR_XPATH_PAREN_EXPECTED = -2141192177,
    NS_ERROR_XPATH_INVALID_AXIS = -2141192176,
    NS_ERROR_XPATH_NO_NODE_TYPE_TEST = -2141192175,
    NS_ERROR_XPATH_BRACKET_EXPECTED = -2141192174,
    NS_ERROR_XPATH_INVALID_VAR_NAME = -2141192173,
    NS_ERROR_XPATH_UNEXPECTED_END = -2141192172,
    NS_ERROR_XPATH_OPERATOR_EXPECTED = -2141192171,
    NS_ERROR_XPATH_UNCLOSED_LITERAL = -2141192170,
    NS_ERROR_XPATH_BAD_COLON = -2141192169,
    NS_ERROR_XPATH_BAD_BANG = -2141192168,
    NS_ERROR_XPATH_ILLEGAL_CHAR = -2141192167,
    NS_ERROR_XPATH_BINARY_EXPECTED = -2141192166,
    NS_ERROR_XSLT_LOAD_BLOCKED_ERROR = -2141192165,
    NS_ERROR_XPATH_INVALID_EXPRESSION_EVALUATED = -2141192164,
    NS_ERROR_XPATH_UNBALANCED_CURLY_BRACE = -2141192163,
    NS_ERROR_XSLT_BAD_NODE_NAME = -2141192162,
    NS_ERROR_XSLT_VAR_ALREADY_SET = -2141192161,
    NS_ERROR_XSLT_CALL_TO_KEY_NOT_ALLOWED = -2141192160,
    NS_XSLT_GET_NEW_HANDLER = 6291457,
    NS_ERROR_TRANSPORT_INIT = -2141126655,
    NS_ERROR_DUPLICATE_HANDLE = -2141126654,
    NS_ERROR_BRIDGE_OPEN_PARENT = -2141126653,
    NS_ERROR_BRIDGE_OPEN_CHILD = -2141126652,
    NS_ERROR_DOM_SVG_WRONG_TYPE_ERR = -2141061120,
    NS_ERROR_DOM_SVG_MATRIX_NOT_INVERTABLE = -2141061118,
    NS_ERROR_STORAGE_BUSY = -2140995583,
    NS_ERROR_STORAGE_IOERR = -2140995582,
    NS_ERROR_STORAGE_CONSTRAINT = -2140995581,
    NS_ERROR_DOM_FILE_NOT_FOUND_ERR = -2140864512,
    NS_ERROR_DOM_FILE_NOT_READABLE_ERR = -2140864511,
    NS_ERROR_DOM_FILE_ABORT_ERR = -2140864510,
    NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR = -2140798975,
    NS_ERROR_DOM_INDEXEDDB_NOT_FOUND_ERR = -2140798973,
    NS_ERROR_DOM_INDEXEDDB_CONSTRAINT_ERR = -2140798972,
    NS_ERROR_DOM_INDEXEDDB_DATA_ERR = -2140798971,
    NS_ERROR_DOM_INDEXEDDB_NOT_ALLOWED_ERR = -2140798970,
    NS_ERROR_DOM_INDEXEDDB_TRANSACTION_INACTIVE_ERR = -2140798969,
    NS_ERROR_DOM_INDEXEDDB_ABORT_ERR = -2140798968,
    NS_ERROR_DOM_INDEXEDDB_READ_ONLY_ERR = -2140798967,
    NS_ERROR_DOM_INDEXEDDB_TIMEOUT_ERR = -2140798966,
    NS_ERROR_DOM_INDEXEDDB_QUOTA_ERR = -2140798965,
    NS_ERROR_DOM_INDEXEDDB_VERSION_ERR = -2140798964,
    NS_ERROR_DOM_INDEXEDDB_RECOVERABLE_ERR = -2140797975,
    NS_ERROR_DOM_FILEHANDLE_UNKNOWN_ERR = -2140733439,
    NS_ERROR_DOM_FILEHANDLE_NOT_ALLOWED_ERR = -2140733438,
    NS_ERROR_DOM_FILEHANDLE_INACTIVE_ERR = -2140733437,
    NS_ERROR_DOM_FILEHANDLE_ABORT_ERR = -2140733436,
    NS_ERROR_DOM_FILEHANDLE_READ_ONLY_ERR = -2140733435,
    NS_ERROR_DOM_FILEHANDLE_QUOTA_ERR = -2140733434,
    NS_ERROR_SIGNED_JAR_NOT_SIGNED = -2140667903,
    NS_ERROR_SIGNED_JAR_MODIFIED_ENTRY = -2140667902,
    NS_ERROR_SIGNED_JAR_UNSIGNED_ENTRY = -2140667901,
    NS_ERROR_SIGNED_JAR_ENTRY_MISSING = -2140667900,
    NS_ERROR_SIGNED_JAR_WRONG_SIGNATURE = -2140667899,
    NS_ERROR_SIGNED_JAR_ENTRY_TOO_LARGE = -2140667898,
    NS_ERROR_SIGNED_JAR_ENTRY_INVALID = -2140667897,
    NS_ERROR_SIGNED_JAR_MANIFEST_INVALID = -2140667896,
    NS_ERROR_DOM_FILESYSTEM_INVALID_PATH_ERR = -2140602367,
    NS_ERROR_DOM_FILESYSTEM_INVALID_MODIFICATION_ERR = -2140602366,
    NS_ERROR_DOM_FILESYSTEM_NO_MODIFICATION_ALLOWED_ERR = -2140602365,
    NS_ERROR_DOM_FILESYSTEM_PATH_EXISTS_ERR = -2140602364,
    NS_ERROR_DOM_FILESYSTEM_TYPE_MISMATCH_ERR = -2140602363,
    NS_ERROR_DOM_FILESYSTEM_UNKNOWN_ERR = -2140602362,
    NS_ERROR_DOM_BLUETOOTH_FAIL = -2140536831,
    NS_ERROR_DOM_BLUETOOTH_NOT_READY = -2140536830,
    NS_ERROR_DOM_BLUETOOTH_NOMEM = -2140536829,
    NS_ERROR_DOM_BLUETOOTH_BUSY = -2140536828,
    NS_ERROR_DOM_BLUETOOTH_DONE = -2140536827,
    NS_ERROR_DOM_BLUETOOTH_UNSUPPORTED = -2140536826,
    NS_ERROR_DOM_BLUETOOTH_PARM_INVALID = -2140536825,
    NS_ERROR_DOM_BLUETOOTH_UNHANDLED = -2140536824,
    NS_ERROR_DOM_BLUETOOTH_AUTH_FAILURE = -2140536823,
    NS_ERROR_DOM_BLUETOOTH_RMT_DEV_DOWN = -2140536822,
    NS_ERROR_DOM_BLUETOOTH_AUTH_REJECTED = -2140536821,
    NS_ERROR_SIGNED_APP_MANIFEST_INVALID = -2140471295,
    NS_ERROR_DOM_ANIM_MISSING_PROPS_ERR = -2140405759,
    NS_ERROR_DOM_ANIM_NO_EFFECT_ERR = -2140405758,
    NS_ERROR_DOM_PUSH_INVALID_REGISTRATION_ERR = -2140340223,
    NS_ERROR_DOM_PUSH_DENIED_ERR = -2140340222,
    NS_ERROR_DOM_PUSH_ABORT_ERR = -2140340221,
    NS_ERROR_DOM_PUSH_SERVICE_UNREACHABLE = -2140340220,
    NS_ERROR_DOM_PUSH_INVALID_KEY_ERR = -2140340219,
    NS_ERROR_DOM_PUSH_MISMATCHED_KEY_ERR = -2140340218,
    NS_ERROR_DOWNLOAD_COMPLETE = -2139619327,
    NS_ERROR_DOWNLOAD_NOT_PARTIAL = -2139619326,
    NS_ERROR_UNORM_MOREOUTPUT = -2139619295,
    NS_ERROR_DOCSHELL_REQUEST_REJECTED = -2139618327,
    NS_ERROR_DOCUMENT_IS_PRINTMODE = -2139617327,
    NS_SUCCESS_DONT_FIXUP = 7864321,
    NS_SUCCESS_RESTART_APP_NOT_SAME_PROFILE = 7864323,
    NS_SUCCESS_UNORM_NOTFOUND = 7864337,
    NS_ERROR_NOT_IN_TREE = -2139619290,
    NS_OK_NO_NAME_CLAUSE_HANDLED = 7864354,
}
pub type nsrefcnt = MozRefCountType;
/**
 * typedefs for backwards compatibility
 */
pub type nsSubstring = nsAString_internal;
pub type nsCSubstring = nsACString_internal;
pub type nsAFlatString = nsString;
pub type nsASingleFragmentString = nsSubstring;
pub type nsAFlatCString = nsCString;
pub type nsASingleFragmentCString = nsCSubstring;
/**
 * @see nsTAString
 */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsReadingIterator<CharT> {
    pub mStart: *const CharT,
    pub mEnd: *const CharT,
    pub mPosition: *const CharT,
}
/**
 * @see nsTAString
 */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsWritingIterator<CharT> {
    pub mStart: *mut CharT,
    pub mEnd: *mut CharT,
    pub mPosition: *mut CharT,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStringComparator {
    pub _vftable: *const _vftable_nsStringComparator,
}
#[repr(C)]
pub struct _vftable_nsStringComparator {
    pub _bindgen_empty_ctype_warning_fix: u64,
}
impl ::std::clone::Clone for nsStringComparator {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsStringComparator() {
    assert_eq!(::std::mem::size_of::<nsStringComparator>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsStringComparator>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsDefaultStringComparator {
    pub _base: nsStringComparator,
}
#[repr(C)]
pub struct _vftable_nsDefaultStringComparator {
    pub _base: _vftable_nsStringComparator,
}
impl ::std::clone::Clone for nsDefaultStringComparator {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct nsAString_internal {
    pub mData: *mut ::std::os::raw::c_ushort,
    pub mLength: ::std::os::raw::c_uint,
    pub mFlags: u32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsAString_internal_nsTSubstring_h_unnamed_1 {
    F_NONE = 0,
    F_TERMINATED = 1,
    F_VOIDED = 2,
    F_SHARED = 4,
    F_OWNED = 8,
    F_FIXED = 16,
    F_LITERAL = 32,
    F_CLASS_FIXED = 65536,
}
#[test]
fn bindgen_test_layout_nsAString_internal() {
    assert_eq!(::std::mem::size_of::<nsAString_internal>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsAString_internal>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsCStringComparator {
    pub _vftable: *const _vftable_nsCStringComparator,
}
#[repr(C)]
pub struct _vftable_nsCStringComparator {
    pub _bindgen_empty_ctype_warning_fix: u64,
}
impl ::std::clone::Clone for nsCStringComparator {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsCStringComparator() {
    assert_eq!(::std::mem::size_of::<nsCStringComparator>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsCStringComparator>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsDefaultCStringComparator {
    pub _base: nsCStringComparator,
}
#[repr(C)]
pub struct _vftable_nsDefaultCStringComparator {
    pub _base: _vftable_nsCStringComparator,
}
impl ::std::clone::Clone for nsDefaultCStringComparator {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct nsACString_internal {
    pub mData: *mut ::std::os::raw::c_char,
    pub mLength: ::std::os::raw::c_uint,
    pub mFlags: u32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsACString_internal_nsTSubstring_h_unnamed_2 {
    F_NONE = 0,
    F_TERMINATED = 1,
    F_VOIDED = 2,
    F_SHARED = 4,
    F_OWNED = 8,
    F_FIXED = 16,
    F_LITERAL = 32,
    F_CLASS_FIXED = 65536,
}
#[test]
fn bindgen_test_layout_nsACString_internal() {
    assert_eq!(::std::mem::size_of::<nsACString_internal>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsACString_internal>() , 8usize);
}
/**
 * ASCII case-insensitive comparator.  (for Unicode case-insensitive
 * comparision, see nsUnicharUtils.h)
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsCaseInsensitiveCStringComparator {
    pub _base: nsCStringComparator,
}
#[repr(C)]
pub struct _vftable_nsCaseInsensitiveCStringComparator {
    pub _base: _vftable_nsCStringComparator,
}
impl ::std::clone::Clone for nsCaseInsensitiveCStringComparator {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsCaseInsensitiveCStringArrayComparator;
impl ::std::clone::Clone for nsCaseInsensitiveCStringArrayComparator {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsSubstringTuple {
    pub mHead: *const nsSubstringTuple,
    pub mFragA: *const nsAString_internal,
    pub mFragB: *const nsAString_internal,
}
impl ::std::clone::Clone for nsSubstringTuple {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsSubstringTuple() {
    assert_eq!(::std::mem::size_of::<nsSubstringTuple>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsSubstringTuple>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsCSubstringTuple {
    pub mHead: *const nsCSubstringTuple,
    pub mFragA: *const nsACString_internal,
    pub mFragB: *const nsACString_internal,
}
impl ::std::clone::Clone for nsCSubstringTuple {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsCSubstringTuple() {
    assert_eq!(::std::mem::size_of::<nsCSubstringTuple>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsCSubstringTuple>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsString {
    pub _base: nsAString_internal,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsString_Segment {
    pub mBegin: u32,
    pub mLength: u32,
}
impl ::std::clone::Clone for nsString_Segment {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsString_Segment() {
    assert_eq!(::std::mem::size_of::<nsString_Segment>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsString_Segment>() , 4usize);
}
#[test]
fn bindgen_test_layout_nsString() {
    assert_eq!(::std::mem::size_of::<nsString>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsString>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsFixedString {
    pub _base: nsString,
    pub mFixedCapacity: ::std::os::raw::c_uint,
    pub mFixedBuf: *mut ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_nsFixedString() {
    assert_eq!(::std::mem::size_of::<nsFixedString>() , 32usize);
    assert_eq!(::std::mem::align_of::<nsFixedString>() , 8usize);
}
#[repr(C)]
pub struct nsAutoString {
    pub _base: nsFixedString,
    pub mStorage: [::std::os::raw::c_ushort; 64usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsAutoString_nsTString_h_unnamed_3 { kDefaultStorageSize = 64, }
#[test]
fn bindgen_test_layout_nsAutoString() {
    assert_eq!(::std::mem::size_of::<nsAutoString>() , 160usize);
    assert_eq!(::std::mem::align_of::<nsAutoString>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dont_Instantiate_nsTArray_of<A> {
    pub _phantom0: ::std::marker::PhantomData<A>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Instead_Use_nsTArray_of<A> {
    pub _phantom0: ::std::marker::PhantomData<A>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsTArrayElementTraits;
impl ::std::clone::Clone for nsTArrayElementTraits {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct nsXPIDLString {
    pub _base: nsString,
}
#[test]
fn bindgen_test_layout_nsXPIDLString() {
    assert_eq!(::std::mem::size_of::<nsXPIDLString>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsXPIDLString>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsGetterCopies {
    pub mString: *mut nsAString_internal,
    pub mData: *mut ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_nsGetterCopies() {
    assert_eq!(::std::mem::size_of::<nsGetterCopies>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsGetterCopies>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsAdoptingString {
    pub _base: nsXPIDLString,
}
#[test]
fn bindgen_test_layout_nsAdoptingString() {
    assert_eq!(::std::mem::size_of::<nsAdoptingString>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsAdoptingString>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCString {
    pub _base: nsACString_internal,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsCString_Segment {
    pub mBegin: u32,
    pub mLength: u32,
}
impl ::std::clone::Clone for nsCString_Segment {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsCString_Segment() {
    assert_eq!(::std::mem::size_of::<nsCString_Segment>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsCString_Segment>() , 4usize);
}
#[test]
fn bindgen_test_layout_nsCString() {
    assert_eq!(::std::mem::size_of::<nsCString>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsCString>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsFixedCString {
    pub _base: nsCString,
    pub mFixedCapacity: ::std::os::raw::c_uint,
    pub mFixedBuf: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_nsFixedCString() {
    assert_eq!(::std::mem::size_of::<nsFixedCString>() , 32usize);
    assert_eq!(::std::mem::align_of::<nsFixedCString>() , 8usize);
}
#[repr(C)]
pub struct nsAutoCString {
    pub _base: nsFixedCString,
    pub mStorage: [::std::os::raw::c_char; 64usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsAutoCString_nsTString_h_unnamed_4 { kDefaultStorageSize = 64, }
#[test]
fn bindgen_test_layout_nsAutoCString() {
    assert_eq!(::std::mem::size_of::<nsAutoCString>() , 96usize);
    assert_eq!(::std::mem::align_of::<nsAutoCString>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsXPIDLCString {
    pub _base: nsCString,
}
#[test]
fn bindgen_test_layout_nsXPIDLCString() {
    assert_eq!(::std::mem::size_of::<nsXPIDLCString>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsXPIDLCString>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCGetterCopies {
    pub mString: *mut nsACString_internal,
    pub mData: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_nsCGetterCopies() {
    assert_eq!(::std::mem::size_of::<nsCGetterCopies>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsCGetterCopies>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsAdoptingCString {
    pub _base: nsXPIDLCString,
}
#[test]
fn bindgen_test_layout_nsAdoptingCString() {
    assert_eq!(::std::mem::size_of::<nsAdoptingCString>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsAdoptingCString>() , 8usize);
}
/**
 * A helper class that converts a UTF-16 string to ASCII in a lossy manner
 */
#[repr(C)]
pub struct NS_LossyConvertUTF16toASCII {
    pub _base: nsAutoCString,
}
#[test]
fn bindgen_test_layout_NS_LossyConvertUTF16toASCII() {
    assert_eq!(::std::mem::size_of::<NS_LossyConvertUTF16toASCII>() ,
               96usize);
    assert_eq!(::std::mem::align_of::<NS_LossyConvertUTF16toASCII>() ,
               8usize);
}
#[repr(C)]
pub struct NS_ConvertASCIItoUTF16 {
    pub _base: nsAutoString,
}
#[test]
fn bindgen_test_layout_NS_ConvertASCIItoUTF16() {
    assert_eq!(::std::mem::size_of::<NS_ConvertASCIItoUTF16>() , 160usize);
    assert_eq!(::std::mem::align_of::<NS_ConvertASCIItoUTF16>() , 8usize);
}
/**
 * A helper class that converts a UTF-16 string to UTF-8
 */
#[repr(C)]
pub struct NS_ConvertUTF16toUTF8 {
    pub _base: nsAutoCString,
}
#[test]
fn bindgen_test_layout_NS_ConvertUTF16toUTF8() {
    assert_eq!(::std::mem::size_of::<NS_ConvertUTF16toUTF8>() , 96usize);
    assert_eq!(::std::mem::align_of::<NS_ConvertUTF16toUTF8>() , 8usize);
}
#[repr(C)]
pub struct NS_ConvertUTF8toUTF16 {
    pub _base: nsAutoString,
}
#[test]
fn bindgen_test_layout_NS_ConvertUTF8toUTF16() {
    assert_eq!(::std::mem::size_of::<NS_ConvertUTF8toUTF16>() , 160usize);
    assert_eq!(::std::mem::align_of::<NS_ConvertUTF8toUTF16>() , 8usize);
}
pub type nsVoidableString = nsAutoString;
/**
 * A "unique identifier". This is modeled after OSF DCE UUIDs.
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsID {
    pub m0: u32,
    pub m1: u16,
    pub m2: u16,
    pub m3: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_nsID() {
    assert_eq!(::std::mem::size_of::<nsID>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsID>() , 4usize);
}
/**
 * A stack helper class to convert a nsID to a string.  Useful
 * for printing nsIDs.  For example:
 *   nsID aID = ...;
 *   printf("%s", nsIDToCString(aID).get());
 */
#[repr(C)]
#[derive(Copy)]
pub struct nsIDToCString {
    pub mStringBytes: [::std::os::raw::c_char; 39usize],
}
impl ::std::clone::Clone for nsIDToCString {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsIDToCString() {
    assert_eq!(::std::mem::size_of::<nsIDToCString>() , 39usize);
    assert_eq!(::std::mem::align_of::<nsIDToCString>() , 1usize);
}
pub type nsCID = nsID;
/**
 * An "interface id" which can be used to uniquely identify a given
 * interface.
 */
pub type nsIID = nsID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct COMTypeInfo<T, U> {
    pub _phantom0: ::std::marker::PhantomData<T>,
    pub _phantom1: ::std::marker::PhantomData<U>,
}
/**
 * Basic component object model interface. Objects which implement
 * this interface support runtime interface discovery (QueryInterface)
 * and a reference counted memory model (AddRef/Release). This is
 * modelled after the win32 IUnknown API.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsISupports {
    pub _vftable: *const _vftable_nsISupports,
}
#[repr(C)]
pub struct _vftable_nsISupports {
    pub _bindgen_empty_ctype_warning_fix: u64,
}
impl ::std::clone::Clone for nsISupports {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsISupports() {
    assert_eq!(::std::mem::size_of::<nsISupports>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsISupports>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsAutoOwningThread {
    pub mThread: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for nsAutoOwningThread {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsAutoOwningThread() {
    assert_eq!(::std::mem::size_of::<nsAutoOwningThread>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsAutoOwningThread>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsCycleCollectingAutoRefCnt {
    pub mRefCntAndFlags: usize,
}
impl ::std::clone::Clone for nsCycleCollectingAutoRefCnt {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsCycleCollectingAutoRefCnt() {
    assert_eq!(::std::mem::size_of::<nsCycleCollectingAutoRefCnt>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsCycleCollectingAutoRefCnt>() ,
               8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsAutoRefCnt {
    pub mValue: nsrefcnt,
}
impl ::std::clone::Clone for nsAutoRefCnt {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsAutoRefCnt() {
    assert_eq!(::std::mem::size_of::<nsAutoRefCnt>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsAutoRefCnt>() , 8usize);
}
extern "C" {
    #[link_name = "_ZN12nsAutoRefCnt12isThreadSafeE"]
    pub static nsAutoRefCnt_consts_isThreadSafe: bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct ThreadSafeAutoRefCnt {
    pub mValue: u64,
}
#[test]
fn bindgen_test_layout_ThreadSafeAutoRefCnt() {
    assert_eq!(::std::mem::size_of::<ThreadSafeAutoRefCnt>() , 8usize);
    assert_eq!(::std::mem::align_of::<ThreadSafeAutoRefCnt>() , 8usize);
}
extern "C" {
    #[link_name = "_ZN7mozilla20ThreadSafeAutoRefCnt12isThreadSafeE"]
    pub static ThreadSafeAutoRefCnt_consts_isThreadSafe: bool;
}
/**
 * There are two ways of implementing QueryInterface, and we use both:
 *
 * Table-driven QueryInterface uses a static table of IID->offset mappings
 * and a shared helper function. Using it tends to reduce codesize and improve
 * runtime performance (due to processor cache hits).
 *
 * Macro-driven QueryInterface generates a QueryInterface function directly
 * using common macros. This is necessary if special QueryInterface features
 * are being used (such as tearoffs and conditional interfaces).
 *
 * These methods can be combined into a table-driven function call followed
 * by custom code for tearoffs and conditionals.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct QITableEntry {
    pub iid: *const nsIID,
    pub offset: i32,
}
impl ::std::clone::Clone for QITableEntry {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_QITableEntry() {
    assert_eq!(::std::mem::size_of::<QITableEntry>() , 16usize);
    assert_eq!(::std::mem::align_of::<QITableEntry>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RefPtrTraits<U> {
    pub _phantom0: ::std::marker::PhantomData<U>,
}
#[repr(C)]
#[derive(Debug)]
pub struct RefPtr<T> {
    pub mRawPtr: *mut T,
}
#[repr(C)]
#[derive(Debug)]
pub struct RefPtr_Proxy<T, R, Args> {
    pub mRawPtr: *mut T,
    pub _phantom0: ::std::marker::PhantomData<R>,
    pub _phantom1: ::std::marker::PhantomData<Args>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RefPtr_ConstRemovingRefPtrTraits<T, U> {
    pub _phantom0: ::std::marker::PhantomData<T>,
    pub _phantom1: ::std::marker::PhantomData<U>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RefPtrGetterAddRefs<T> {
    pub mTargetSmartPtr: *mut RefPtr<T>,
}
pub enum TileClient { }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsTArrayFallibleResult {
    pub mResult: bool,
}
impl ::std::clone::Clone for nsTArrayFallibleResult {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsTArrayFallibleResult() {
    assert_eq!(::std::mem::size_of::<nsTArrayFallibleResult>() , 1usize);
    assert_eq!(::std::mem::align_of::<nsTArrayFallibleResult>() , 1usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsTArrayInfallibleResult;
impl ::std::clone::Clone for nsTArrayInfallibleResult {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsTArrayFallibleAllocatorBase;
impl ::std::clone::Clone for nsTArrayFallibleAllocatorBase {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsTArrayInfallibleAllocatorBase;
impl ::std::clone::Clone for nsTArrayInfallibleAllocatorBase {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsTArrayFallibleAllocator {
    pub _base: nsTArrayFallibleAllocatorBase,
}
impl ::std::clone::Clone for nsTArrayFallibleAllocator {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsTArrayInfallibleAllocator {
    pub _base: nsTArrayInfallibleAllocatorBase,
}
impl ::std::clone::Clone for nsTArrayInfallibleAllocator {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsTArrayHeader {
    pub mLength: u32,
    pub _bitfield_1: u32,
}
impl ::std::clone::Clone for nsTArrayHeader {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsTArrayHeader() {
    assert_eq!(::std::mem::size_of::<nsTArrayHeader>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsTArrayHeader>() , 4usize);
}
extern "C" {
    #[link_name = "_ZN14nsTArrayHeader9sEmptyHdrE"]
    pub static mut nsTArrayHeader_consts_sEmptyHdr: nsTArrayHeader;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsTArray_SafeElementAtHelper<E, Derived> {
    pub _phantom0: ::std::marker::PhantomData<E>,
    pub _phantom1: ::std::marker::PhantomData<Derived>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsTArray_SafeElementAtSmartPtrHelper<E, Derived> {
    pub _phantom0: ::std::marker::PhantomData<E>,
    pub _phantom1: ::std::marker::PhantomData<Derived>,
}
#[repr(C)]
#[derive(Debug)]
pub struct nsTArray_base<Alloc, Copy> {
    pub mHdr: *mut nsTArrayHeader,
    pub _phantom0: ::std::marker::PhantomData<Alloc>,
    pub _phantom1: ::std::marker::PhantomData<Copy>,
}
#[repr(C)]
#[derive(Debug)]
pub struct nsTArray_base_IsAutoArrayRestorer<Alloc, Copy> {
    pub mArray: *mut nsTArray_base<Alloc, Copy>,
    pub mElemAlign: usize,
    pub mIsAuto: bool,
    pub _phantom0: ::std::marker::PhantomData<Copy>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsDefaultComparator<A, B> {
    pub _phantom0: ::std::marker::PhantomData<A>,
    pub _phantom1: ::std::marker::PhantomData<B>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsTArray_CopyWithMemutils;
impl ::std::clone::Clone for nsTArray_CopyWithMemutils {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "_ZN25nsTArray_CopyWithMemutils12allowReallocE"]
    pub static nsTArray_CopyWithMemutils_consts_allowRealloc: bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsTArray_CopyWithConstructors<ElemType> {
    pub _phantom0: ::std::marker::PhantomData<ElemType>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsTArray_CopyChooser<E> {
    pub _phantom0: ::std::marker::PhantomData<E>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsTArray_TypedBase<E, Derived> {
    pub _base: nsTArray_SafeElementAtHelper<E, Derived>,
    pub _phantom0: ::std::marker::PhantomData<Derived>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ItemComparatorEq<Item, Comparator> {
    pub mItem: *const Item,
    pub mComp: *const Comparator,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ItemComparatorFirstElementGT<Item, Comparator> {
    pub mItem: *const Item,
    pub mComp: *const Comparator,
}
/**
 * <div rustbindgen replaces="nsTArray"></div>
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsTArray<T> {
    pub mBuffer: *mut T,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsCOMPtr_helper {
    pub _vftable: *const _vftable_nsCOMPtr_helper,
}
#[repr(C)]
pub struct _vftable_nsCOMPtr_helper {
    pub _bindgen_empty_ctype_warning_fix: u64,
}
impl ::std::clone::Clone for nsCOMPtr_helper {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsCOMPtr_helper() {
    assert_eq!(::std::mem::size_of::<nsCOMPtr_helper>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsCOMPtr_helper>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsQueryInterface {
    pub mRawPtr: *mut nsISupports,
}
impl ::std::clone::Clone for nsQueryInterface {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsQueryInterface() {
    assert_eq!(::std::mem::size_of::<nsQueryInterface>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsQueryInterface>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsQueryInterfaceWithError {
    pub mRawPtr: *mut nsISupports,
    pub mErrorPtr: *mut nsresult,
}
impl ::std::clone::Clone for nsQueryInterfaceWithError {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsQueryInterfaceWithError() {
    assert_eq!(::std::mem::size_of::<nsQueryInterfaceWithError>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsQueryInterfaceWithError>() , 8usize);
}
////////////////////////////////////////////////////////////////////////////
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsGetServiceByCID {
    pub mCID: *const nsCID,
}
impl ::std::clone::Clone for nsGetServiceByCID {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsGetServiceByCID() {
    assert_eq!(::std::mem::size_of::<nsGetServiceByCID>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsGetServiceByCID>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsGetServiceByCIDWithError {
    pub mCID: *const nsCID,
    pub mErrorPtr: *mut nsresult,
}
impl ::std::clone::Clone for nsGetServiceByCIDWithError {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsGetServiceByCIDWithError() {
    assert_eq!(::std::mem::size_of::<nsGetServiceByCIDWithError>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsGetServiceByCIDWithError>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsGetServiceByContractID {
    pub mContractID: *const ::std::os::raw::c_char,
}
impl ::std::clone::Clone for nsGetServiceByContractID {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsGetServiceByContractID() {
    assert_eq!(::std::mem::size_of::<nsGetServiceByContractID>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsGetServiceByContractID>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsGetServiceByContractIDWithError {
    pub mContractID: *const ::std::os::raw::c_char,
    pub mErrorPtr: *mut nsresult,
}
impl ::std::clone::Clone for nsGetServiceByContractIDWithError {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsGetServiceByContractIDWithError() {
    assert_eq!(::std::mem::size_of::<nsGetServiceByContractIDWithError>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<nsGetServiceByContractIDWithError>() ,
               8usize);
}
/**
 * Factors implementation for all template versions of nsCOMPtr.
 *
 * Here's the way people normally do things like this:
 *
 *   template<class T> class Foo { ... };
 *   template<> class Foo<void*> { ... };
 *   template<class T> class Foo<T*> : private Foo<void*> { ... };
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsCOMPtr_base {
    pub mRawPtr: *mut nsISupports,
}
#[test]
fn bindgen_test_layout_nsCOMPtr_base() {
    assert_eq!(::std::mem::size_of::<nsCOMPtr_base>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsCOMPtr_base>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCOMPtr<T> {
    pub mRawPtr: *mut T,
}
/**
 * This class is designed to be used for anonymous temporary objects in the
 * argument list of calls that return COM interface pointers, e.g.,
 *
 *   nsCOMPtr<IFoo> fooP;
 *   ...->QueryInterface(iid, getter_AddRefs(fooP))
 *
 * DO NOT USE THIS TYPE DIRECTLY IN YOUR CODE. Use |getter_AddRefs()| instead.
 *
 * When initialized with a |nsCOMPtr|, as in the example above, it returns
 * a |void**|, a |T**|, or an |nsISupports**| as needed, that the outer call
 * (|QueryInterface| in this case) can fill in.
 *
 * This type should be a nested class inside |nsCOMPtr<T>|.
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsGetterAddRefs<T> {
    pub mTargetSmartPtr: *mut nsCOMPtr<T>,
}
#[repr(C)]
#[derive(Debug)]
pub struct nsAutoPtr<T> {
    pub mRawPtr: *mut T,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsAutoPtr_Ptr<T> {
    pub mPtr: *mut T,
}
#[repr(C)]
#[derive(Debug)]
pub struct nsAutoPtr_Proxy<T, R, Args> {
    pub mRawPtr: *mut T,
    pub _phantom0: ::std::marker::PhantomData<R>,
    pub _phantom1: ::std::marker::PhantomData<Args>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsAutoPtrGetterTransfers<T> {
    pub mTargetSmartPtr: *mut nsAutoPtr<T>,
}
/**
 * This structure precedes the string buffers "we" allocate.  It may be the
 * case that nsTAString::mData does not point to one of these special
 * buffers.  The mFlags member variable distinguishes the buffer type.
 *
 * When this header is in use, it enables reference counting, and capacity
 * tracking.  NOTE: A string buffer can be modified only if its reference
 * count is 1.
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsStringBuffer {
    pub mRefCount: u32,
    pub mStorageSize: u32,
}
#[test]
fn bindgen_test_layout_nsStringBuffer() {
    assert_eq!(::std::mem::size_of::<nsStringBuffer>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsStringBuffer>() , 4usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIAtom {
    pub _base: nsISupports,
    pub _bitfield_1: u32,
    pub mHash: u32,
    /**
   * WARNING! There is an invisible constraint on |mString|: the chars it
   * points to must belong to an nsStringBuffer. This is so that the
   * nsStringBuffer::FromData() calls above are valid.
   */
    pub mString: *mut ::std::os::raw::c_ushort,
}
#[repr(C)]
pub struct _vftable_nsIAtom {
    pub _base: _vftable_nsISupports,
}
impl ::std::clone::Clone for nsIAtom {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsIAtom() {
    assert_eq!(::std::mem::size_of::<nsIAtom>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsIAtom>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsAtomString {
    pub _base: nsString,
}
#[test]
fn bindgen_test_layout_nsAtomString() {
    assert_eq!(::std::mem::size_of::<nsAtomString>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsAtomString>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsAtomCString {
    pub _base: nsCString,
}
#[test]
fn bindgen_test_layout_nsAtomCString() {
    assert_eq!(::std::mem::size_of::<nsAtomCString>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsAtomCString>() , 8usize);
}
#[repr(C)]
pub struct nsDependentAtomString {
    pub _base: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct piecewise_construct_t;
impl ::std::clone::Clone for piecewise_construct_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pair<_T1, _T2> {
    pub first: _T1,
    pub second: _T2,
}
pub type PLDHashNumber = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PLDHashEntryHdr {
    pub mKeyHash: PLDHashNumber,
}
impl ::std::clone::Clone for PLDHashEntryHdr {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_PLDHashEntryHdr() {
    assert_eq!(::std::mem::size_of::<PLDHashEntryHdr>() , 4usize);
    assert_eq!(::std::mem::align_of::<PLDHashEntryHdr>() , 4usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct Checker {
    pub mState: u32,
    pub mIsWritable: u32,
}
#[test]
fn bindgen_test_layout_Checker() {
    assert_eq!(::std::mem::size_of::<Checker>() , 8usize);
    assert_eq!(::std::mem::align_of::<Checker>() , 4usize);
}
extern "C" {
    #[link_name = "_ZN7Checker5kIdleE"]
    pub static Checker_consts_kIdle: ::std::os::raw::c_uint;
    #[link_name = "_ZN7Checker6kRead1E"]
    pub static Checker_consts_kRead1: ::std::os::raw::c_uint;
    #[link_name = "_ZN7Checker8kReadMaxE"]
    pub static Checker_consts_kReadMax: ::std::os::raw::c_uint;
    #[link_name = "_ZN7Checker6kWriteE"]
    pub static Checker_consts_kWrite: ::std::os::raw::c_uint;
}
#[repr(C)]
pub struct PLDHashTable {
    pub mOps: *const PLDHashTableOps,
    pub mHashShift: i16,
    pub mEntrySize: u32,
    pub mEntryCount: u32,
    pub mRemovedCount: u32,
    pub mEntryStore: [u64; 2usize],
    pub mChecker: ::std::cell::UnsafeCell<Checker>,
}
#[repr(C)]
pub struct PLDHashTable_EntryStore {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_PLDHashTable_EntryStore() {
    assert_eq!(::std::mem::size_of::<PLDHashTable_EntryStore>() , 16usize);
    assert_eq!(::std::mem::align_of::<PLDHashTable_EntryStore>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct PLDHashTable_Iterator {
    pub mTable: *mut PLDHashTable,
    pub mStart: *mut ::std::os::raw::c_char,
    pub mLimit: *mut ::std::os::raw::c_char,
    pub mCurrent: *mut ::std::os::raw::c_char,
    pub mNexts: u32,
    pub mNextsLimit: u32,
    pub mHaveRemoved: bool,
}
#[test]
fn bindgen_test_layout_PLDHashTable_Iterator() {
    assert_eq!(::std::mem::size_of::<PLDHashTable_Iterator>() , 48usize);
    assert_eq!(::std::mem::align_of::<PLDHashTable_Iterator>() , 8usize);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum PLDHashTable_SearchReason { ForSearchOrRemove = 0, ForAdd = 1, }
#[test]
fn bindgen_test_layout_PLDHashTable() {
    assert_eq!(::std::mem::size_of::<PLDHashTable>() , 48usize);
    assert_eq!(::std::mem::align_of::<PLDHashTable>() , 8usize);
}
extern "C" {
    #[link_name = "_ZN12PLDHashTable12kMaxCapacityE"]
    pub static PLDHashTable_consts_kMaxCapacity: ::std::os::raw::c_uint;
    #[link_name = "_ZN12PLDHashTable12kMinCapacityE"]
    pub static PLDHashTable_consts_kMinCapacity: ::std::os::raw::c_uint;
    #[link_name = "_ZN12PLDHashTable17kMaxInitialLengthE"]
    pub static PLDHashTable_consts_kMaxInitialLength: ::std::os::raw::c_uint;
    #[link_name = "_ZN12PLDHashTable21kDefaultInitialLengthE"]
    pub static PLDHashTable_consts_kDefaultInitialLength:
               ::std::os::raw::c_uint;
    #[link_name = "_ZN12PLDHashTable9kHashBitsE"]
    pub static PLDHashTable_consts_kHashBits: ::std::os::raw::c_uint;
    #[link_name = "_ZN12PLDHashTable12kGoldenRatioE"]
    pub static PLDHashTable_consts_kGoldenRatio: ::std::os::raw::c_uint;
    #[link_name = "_ZN12PLDHashTable14kCollisionFlagE"]
    pub static PLDHashTable_consts_kCollisionFlag: ::std::os::raw::c_uint;
}
pub type PLDHashHashKey =
    ::std::option::Option<unsafe extern "C" fn(aKey:
                                                   *const ::std::os::raw::c_void)
                              -> PLDHashNumber>;
pub type PLDHashMatchEntry =
    ::std::option::Option<unsafe extern "C" fn(aEntry: *const PLDHashEntryHdr,
                                               aKey:
                                                   *const ::std::os::raw::c_void)
                              -> bool>;
pub type PLDHashMoveEntry =
    ::std::option::Option<unsafe extern "C" fn(aTable: *mut PLDHashTable,
                                               aFrom: *const PLDHashEntryHdr,
                                               aTo: *mut PLDHashEntryHdr)>;
pub type PLDHashClearEntry =
    ::std::option::Option<unsafe extern "C" fn(aTable: *mut PLDHashTable,
                                               aEntry: *mut PLDHashEntryHdr)>;
pub type PLDHashInitEntry =
    ::std::option::Option<unsafe extern "C" fn(aEntry: *mut PLDHashEntryHdr,
                                               aKey:
                                                   *const ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PLDHashTableOps {
    pub hashKey: PLDHashHashKey,
    pub matchEntry: PLDHashMatchEntry,
    pub moveEntry: PLDHashMoveEntry,
    pub clearEntry: PLDHashClearEntry,
    pub initEntry: PLDHashInitEntry,
}
impl ::std::clone::Clone for PLDHashTableOps {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_PLDHashTableOps() {
    assert_eq!(::std::mem::size_of::<PLDHashTableOps>() , 40usize);
    assert_eq!(::std::mem::align_of::<PLDHashTableOps>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PLDHashEntryStub {
    pub _base: PLDHashEntryHdr,
    pub key: *const ::std::os::raw::c_void,
}
impl ::std::clone::Clone for PLDHashEntryStub {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_PLDHashEntryStub() {
    assert_eq!(::std::mem::size_of::<PLDHashEntryStub>() , 16usize);
    assert_eq!(::std::mem::align_of::<PLDHashEntryStub>() , 8usize);
}
/**
 * a base class for templated hashtables.
 *
 * Clients will rarely need to use this class directly. Check the derived
 * classes first, to see if they will meet your needs.
 *
 * @param EntryType  the templated entry-type class that is managed by the
 *   hashtable. <code>EntryType</code> must extend the following declaration,
 *   and <strong>must not declare any virtual functions or derive from classes
 *   with virtual functions.</strong>  Any vtable pointer would break the
 *   PLDHashTable code.
 *<pre>   class EntryType : public PLDHashEntryHdr
 *   {
 *   public: or friend nsTHashtable<EntryType>;
 *     // KeyType is what we use when Get()ing or Put()ing this entry
 *     // this should either be a simple datatype (uint32_t, nsISupports*) or
 *     // a const reference (const nsAString&)
 *     typedef something KeyType;
 *     // KeyTypePointer is the pointer-version of KeyType, because
 *     // PLDHashTable.h requires keys to cast to <code>const void*</code>
 *     typedef const something* KeyTypePointer;
 *
 *     EntryType(KeyTypePointer aKey);
 *
 *     // A copy or C++11 Move constructor must be defined, even if
 *     // AllowMemMove() == true, otherwise you will cause link errors.
 *     EntryType(const EntryType& aEnt);  // Either this...
 *     EntryType(EntryType&& aEnt);       // ...or this
 *
 *     // the destructor must be defined... or you will cause link errors!
 *     ~EntryType();
 *
 *     // KeyEquals(): does this entry match this key?
 *     bool KeyEquals(KeyTypePointer aKey) const;
 *
 *     // KeyToPointer(): Convert KeyType to KeyTypePointer
 *     static KeyTypePointer KeyToPointer(KeyType aKey);
 *
 *     // HashKey(): calculate the hash number
 *     static PLDHashNumber HashKey(KeyTypePointer aKey);
 *
 *     // ALLOW_MEMMOVE can we move this class with memmove(), or do we have
 *     // to use the copy constructor?
 *     enum { ALLOW_MEMMOVE = true/false };
 *   }</pre>
 *
 * @see nsInterfaceHashtable
 * @see nsDataHashtable
 * @see nsClassHashtable
 * @author "Benjamin Smedberg <bsmedberg@covad.net>"
 */
#[repr(C)]
pub struct nsTHashtable<EntryType> {
    pub mTable: PLDHashTable,
    pub _phantom0: ::std::marker::PhantomData<EntryType>,
}
#[repr(C)]
#[derive(Debug)]
pub struct nsTHashtable_Iterator<EntryType> {
    pub _base: PLDHashTable_Iterator,
    pub _phantom0: ::std::marker::PhantomData<EntryType>,
}
#[repr(C)]
pub struct nsDataHashtable;
pub enum nsIContentSecurityPolicy { }
pub enum nsIDOMDocument { }
#[repr(C)]
pub struct nsIPrincipal {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_nsIPrincipal() {
    assert_eq!(::std::mem::size_of::<nsIPrincipal>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsIPrincipal>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIExpandedPrincipal {
    pub _base: nsISupports,
}
#[repr(C)]
pub struct _vftable_nsIExpandedPrincipal {
    pub _base: _vftable_nsISupports,
}
impl ::std::clone::Clone for nsIExpandedPrincipal {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Make_integer_sequence<_Tp, _ISeq> {
    pub _phantom0: ::std::marker::PhantomData<_Tp>,
    pub _phantom1: ::std::marker::PhantomData<_ISeq>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIURI {
    pub _base: nsISupports,
}
#[repr(C)]
pub struct _vftable_nsIURI {
    pub _base: _vftable_nsISupports,
}
impl ::std::clone::Clone for nsIURI {
    fn clone(&self) -> Self { *self }
}
pub type nsLoadFlags = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsIRequest {
    pub _base: nsISupports,
}
#[repr(C)]
pub struct _vftable_nsIRequest {
    pub _base: _vftable_nsISupports,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsIRequest_nsIRequest_h_unnamed_7 {
    LOAD_REQUESTMASK = 65535,
    LOAD_NORMAL = 0,
    LOAD_BACKGROUND = 1,
    INHIBIT_PIPELINE = 64,
    INHIBIT_CACHING = 128,
    INHIBIT_PERSISTENT_CACHING = 256,
    LOAD_BYPASS_CACHE = 512,
    LOAD_FROM_CACHE = 1024,
    VALIDATE_ALWAYS = 2048,
    VALIDATE_NEVER = 4096,
    VALIDATE_ONCE_PER_SESSION = 8192,
    LOAD_ANONYMOUS = 16384,
    LOAD_FRESH_CONNECTION = 32768,
}
impl ::std::clone::Clone for nsIRequest {
    fn clone(&self) -> Self { *self }
}
/**
 * EventStates is the class used to represent the event states of nsIContent
 * instances. These states are calculated by IntrinsicState() and
 * ContentStatesChanged() has to be called when one of them changes thus
 * informing the layout/style engine of the change.
 * Event states are associated with pseudo-classes.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct EventStates {
    pub mStates: ::std::os::raw::c_ulong,
}
impl ::std::clone::Clone for EventStates {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_EventStates() {
    assert_eq!(::std::mem::size_of::<EventStates>() , 8usize);
    assert_eq!(::std::mem::align_of::<EventStates>() , 8usize);
}
/**
 * Enum defining the mode in which a sheet is to be parsed.  This is
 * usually, but not always, the same as the cascade level at which the
 * sheet will apply (see nsStyleSet.h).  Most of the Loader APIs only
 * support loading of author sheets.
 *
 * Author sheets are the normal case: styles embedded in or linked
 * from HTML pages.  They are also the most restricted.
 *
 * User sheets can do anything author sheets can do, and also get
 * access to a few CSS extensions that are not yet suitable for
 * exposure on the public Web, but are very useful for expressing
 * user style overrides, such as @-moz-document rules.
 *
 * Agent sheets have access to all author- and user-sheet features
 * plus more extensions that are necessary for internal use but,
 * again, not yet suitable for exposure on the public Web.  Some of
 * these are outright unsafe to expose; in particular, incorrect
 * styling of anonymous box pseudo-elements can violate layout
 * invariants.
 */
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum SheetParsingMode {
    eAuthorSheetFeatures = 0,
    eUserSheetFeatures = 1,
    eAgentSheetFeatures = 2,
}
/**
 * A class for holding strong references to handle-managed objects.
 *
 * This is intended for use with objects like StyleSheetHandle, where
 * the handle type is not a pointer but which can still have ->AddRef()
 * and ->Release() called on it.
 */
#[repr(C)]
#[derive(Debug)]
pub struct HandleRefPtr<T> {
    pub mHandle: T,
}
pub enum nsAttrAndChildArray { }
pub enum nsChildContentList { }
pub enum nsCSSSelectorList { }
pub enum nsDOMAttributeMap { }
pub enum nsIAnimationObserver { }
pub enum nsIDOMElement { }
pub enum nsIDOMNodeList { }
pub enum nsIEditor { }
pub enum nsIFrame { }
pub enum nsINodeList { }
pub enum nsNodeSupportsWeakRefTearoff { }
pub enum nsNodeWeakReference { }
pub enum nsDOMMutationObserver { }
pub enum ServoNodeData { }
pub enum EventListenerManager { }
pub enum BoxQuadOptions { }
pub enum ConvertCoordinateOptions { }
pub enum DOMPoint { }
pub enum DOMQuad { }
pub enum DOMRectReadOnly { }
pub enum Element { }
pub enum Text { }
pub enum TextOrElementOrDocument { }
pub enum DOMPointInit { }
pub const NODE_IS_DIRTY_FOR_SERVO: nsINode_h_unnamed_8 =
    nsINode_h_unnamed_8::NODE_SHARED_RESTYLE_BIT_1;
pub const NODE_HAS_DIRTY_DESCENDANTS_FOR_SERVO: nsINode_h_unnamed_8 =
    nsINode_h_unnamed_8::NODE_SHARED_RESTYLE_BIT_2;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsINode_h_unnamed_8 {
    NODE_HAS_LISTENERMANAGER = 4,
    NODE_HAS_PROPERTIES = 8,
    NODE_IS_ANONYMOUS_ROOT = 16,
    NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE = 32,
    NODE_IS_NATIVE_ANONYMOUS_ROOT = 64,
    NODE_FORCE_XBL_BINDINGS = 128,
    NODE_MAY_BE_IN_BINDING_MNGR = 256,
    NODE_IS_EDITABLE = 512,
    NODE_MAY_HAVE_CLASS = 1024,
    NODE_IS_IN_SHADOW_TREE = 2048,
    NODE_HAS_EMPTY_SELECTOR = 4096,
    NODE_HAS_SLOW_SELECTOR = 8192,
    NODE_HAS_EDGE_CHILD_SELECTOR = 16384,
    NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS = 32768,
    NODE_ALL_SELECTOR_FLAGS = 61440,
    NODE_NEEDS_FRAME = 65536,
    NODE_DESCENDANTS_NEED_FRAMES = 131072,
    NODE_HAS_ACCESSKEY = 262144,
    NODE_HAS_DIRECTION_RTL = 524288,
    NODE_HAS_DIRECTION_LTR = 1048576,
    NODE_ALL_DIRECTION_FLAGS = 1572864,
    NODE_CHROME_ONLY_ACCESS = 2097152,
    NODE_IS_ROOT_OF_CHROME_ONLY_ACCESS = 4194304,
    NODE_SHARED_RESTYLE_BIT_1 = 8388608,
    NODE_SHARED_RESTYLE_BIT_2 = 16777216,
    NODE_TYPE_SPECIFIC_BITS_OFFSET = 23,
}
/**
 * Class used to detect unexpected mutations. To use the class create an
 * nsMutationGuard on the stack before unexpected mutations could occur.
 * You can then at any time call Mutated to check if any unexpected mutations
 * have occurred.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsMutationGuard {
    pub mStartingGeneration: u64,
}
impl ::std::clone::Clone for nsMutationGuard {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsMutationGuard() {
    assert_eq!(::std::mem::size_of::<nsMutationGuard>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsMutationGuard>() , 8usize);
}
extern "C" {
    #[link_name = "_ZN15nsMutationGuard11sGenerationE"]
    pub static mut nsMutationGuard_consts_sGeneration:
               ::std::os::raw::c_ulong;
}
pub type Float = f32;
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum SurfaceType {
    DATA = 0,
    D2D1_BITMAP = 1,
    D2D1_DRAWTARGET = 2,
    CAIRO = 3,
    CAIRO_IMAGE = 4,
    COREGRAPHICS_IMAGE = 5,
    COREGRAPHICS_CGCONTEXT = 6,
    SKIA = 7,
    DUAL_DT = 8,
    D2D1_1_IMAGE = 9,
    RECORDING = 10,
    TILED = 11,
}
pub const A8R8G8B8_UINT32: SurfaceFormat = SurfaceFormat::B8G8R8A8;
pub const X8R8G8B8_UINT32: SurfaceFormat = SurfaceFormat::B8G8R8X8;
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum SurfaceFormat {
    B8G8R8A8 = 0,
    B8G8R8X8 = 1,
    R8G8B8A8 = 2,
    R8G8B8X8 = 3,
    A8R8G8B8 = 4,
    X8R8G8B8 = 5,
    R8G8B8 = 6,
    B8G8R8 = 7,
    R5G6B5_UINT16 = 8,
    A8 = 9,
    YUV = 10,
    NV12 = 11,
    YUV422 = 12,
    HSV = 13,
    Lab = 14,
    Depth = 15,
    UNKNOWN = 16,
}
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum FilterType {
    BLEND = 0,
    TRANSFORM = 1,
    MORPHOLOGY = 2,
    COLOR_MATRIX = 3,
    FLOOD = 4,
    TILE = 5,
    TABLE_TRANSFER = 6,
    DISCRETE_TRANSFER = 7,
    LINEAR_TRANSFER = 8,
    GAMMA_TRANSFER = 9,
    CONVOLVE_MATRIX = 10,
    DISPLACEMENT_MAP = 11,
    TURBULENCE = 12,
    ARITHMETIC_COMBINE = 13,
    COMPOSITE = 14,
    DIRECTIONAL_BLUR = 15,
    GAUSSIAN_BLUR = 16,
    POINT_DIFFUSE = 17,
    POINT_SPECULAR = 18,
    SPOT_DIFFUSE = 19,
    SPOT_SPECULAR = 20,
    DISTANT_DIFFUSE = 21,
    DISTANT_SPECULAR = 22,
    CROP = 23,
    PREMULTIPLY = 24,
    UNPREMULTIPLY = 25,
}
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum DrawTargetType {
    SOFTWARE_RASTER = 0,
    HARDWARE_RASTER = 1,
    VECTOR = 2,
}
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum BackendType {
    NONE = 0,
    DIRECT2D = 1,
    COREGRAPHICS = 2,
    COREGRAPHICS_ACCELERATED = 3,
    CAIRO = 4,
    SKIA = 5,
    RECORDING = 6,
    DIRECT2D1_1 = 7,
}
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum FontType {
    DWRITE = 0,
    GDI = 1,
    MAC = 2,
    SKIA = 3,
    CAIRO = 4,
    COREGRAPHICS = 5,
}
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum NativeSurfaceType {
    D3D10_TEXTURE = 0,
    CAIRO_CONTEXT = 1,
    CGCONTEXT = 2,
    CGCONTEXT_ACCELERATED = 3,
    OPENGL_TEXTURE = 4,
}
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum NativeFontType {
    DWRITE_FONT_FACE = 0,
    GDI_FONT_FACE = 1,
    MAC_FONT_FACE = 2,
    SKIA_FONT_FACE = 3,
    CAIRO_FONT_FACE = 4,
}
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum FontStyle { NORMAL = 0, ITALIC = 1, BOLD = 2, BOLD_ITALIC = 3, }
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum FontHinting { NONE = 0, LIGHT = 1, NORMAL = 2, FULL = 3, }
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum CompositionOp {
    OP_OVER = 0,
    OP_ADD = 1,
    OP_ATOP = 2,
    OP_OUT = 3,
    OP_IN = 4,
    OP_SOURCE = 5,
    OP_DEST_IN = 6,
    OP_DEST_OUT = 7,
    OP_DEST_OVER = 8,
    OP_DEST_ATOP = 9,
    OP_XOR = 10,
    OP_MULTIPLY = 11,
    OP_SCREEN = 12,
    OP_OVERLAY = 13,
    OP_DARKEN = 14,
    OP_LIGHTEN = 15,
    OP_COLOR_DODGE = 16,
    OP_COLOR_BURN = 17,
    OP_HARD_LIGHT = 18,
    OP_SOFT_LIGHT = 19,
    OP_DIFFERENCE = 20,
    OP_EXCLUSION = 21,
    OP_HUE = 22,
    OP_SATURATION = 23,
    OP_COLOR = 24,
    OP_LUMINOSITY = 25,
    OP_COUNT = 26,
}
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum Axis { X_AXIS = 0, Y_AXIS = 1, BOTH = 2, }
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum ExtendMode {
    CLAMP = 0,
    REPEAT = 1,
    REPEAT_X = 2,
    REPEAT_Y = 3,
    REFLECT = 4,
}
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum FillRule { FILL_WINDING = 0, FILL_EVEN_ODD = 1, }
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum AntialiasMode { NONE = 0, GRAY = 1, SUBPIXEL = 2, DEFAULT = 3, }
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum SamplingFilter { GOOD = 0, LINEAR = 1, POINT = 2, SENTINEL = 3, }
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum PatternType {
    COLOR = 0,
    SURFACE = 1,
    LINEAR_GRADIENT = 2,
    RADIAL_GRADIENT = 3,
}
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JoinStyle { BEVEL = 0, ROUND = 1, MITER = 2, MITER_OR_BEVEL = 3, }
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum CapStyle { BUTT = 0, ROUND = 1, SQUARE = 2, }
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum SamplingBounds { UNBOUNDED = 0, BOUNDED = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Color {
    pub r: Float,
    pub g: Float,
    pub b: Float,
    pub a: Float,
}
impl ::std::clone::Clone for Color {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Color() {
    assert_eq!(::std::mem::size_of::<Color>() , 16usize);
    assert_eq!(::std::mem::align_of::<Color>() , 4usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GradientStop {
    pub offset: Float,
    pub color: Color,
}
impl ::std::clone::Clone for GradientStop {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_GradientStop() {
    assert_eq!(::std::mem::size_of::<GradientStop>() , 20usize);
    assert_eq!(::std::mem::align_of::<GradientStop>() , 4usize);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JobStatus { Complete = 0, Wait = 1, Yield = 2, Error = 3, }
pub type gfxImageFormat = SurfaceFormat;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RectCorner;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum RectCorner_Types_h_unnamed_11 {
    TopLeft = 0,
    TopRight = 1,
    BottomRight = 2,
    BottomLeft = 3,
    Count = 4,
}
impl ::std::clone::Clone for RectCorner {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum Side {
    eSideTop = 0,
    eSideRight = 1,
    eSideBottom = 2,
    eSideLeft = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum SideBits {
    eSideBitsNone = 0,
    eSideBitsTop = 1,
    eSideBitsRight = 2,
    eSideBitsBottom = 4,
    eSideBitsLeft = 8,
    eSideBitsTopBottom = 5,
    eSideBitsLeftRight = 10,
    eSideBitsAll = 15,
}
pub type nscoord = i32;
#[repr(C)]
pub struct nsIntPoint {
    pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_nsIntPoint() {
    assert_eq!(::std::mem::size_of::<nsIntPoint>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsIntPoint>() , 4usize);
}
/**
 * These *_Simple types are used to map Gecko types to layout-equivalent but
 * simpler Rust types, to aid Rust binding generation.
 *
 * If something in this types or the assertions below needs to change, ask
 * bholley, heycam or emilio before!
 *
 * <div rustbindgen="true" replaces="nsPoint">
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsPoint {
    pub x: nscoord,
    pub y: nscoord,
}
impl ::std::clone::Clone for nsPoint {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsPoint() {
    assert_eq!(::std::mem::size_of::<nsPoint>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsPoint>() , 4usize);
}
/**
 * <div rustbindgen="true" replaces="nsMargin">
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsMargin {
    pub top: nscoord,
    pub right: nscoord,
    pub bottom: nscoord,
    pub left: nscoord,
}
impl ::std::clone::Clone for nsMargin {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsMargin() {
    assert_eq!(::std::mem::size_of::<nsMargin>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsMargin>() , 4usize);
}
#[repr(C)]
pub struct nsIntMargin {
    pub _bindgen_opaque_blob: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_nsIntMargin() {
    assert_eq!(::std::mem::size_of::<nsIntMargin>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsIntMargin>() , 4usize);
}
#[repr(C)]
pub struct nsIntRect {
    pub _bindgen_opaque_blob: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_nsIntRect() {
    assert_eq!(::std::mem::size_of::<nsIntRect>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsIntRect>() , 4usize);
}
/**
 * <div rustbindgen="true" replaces="nsRect">
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsRect {
    pub x: nscoord,
    pub y: nscoord,
    pub width: nscoord,
    pub height: nscoord,
}
impl ::std::clone::Clone for nsRect {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsRect() {
    assert_eq!(::std::mem::size_of::<nsRect>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsRect>() , 4usize);
}
pub enum AnimationEffectReadOnly { }
pub enum AnimationEffectReadOnlyAtoms { }
pub enum AnimationEffectTimingPropertiesAtoms { }
pub enum ComputedTimingPropertiesAtoms { }
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum FillMode {
    None = 0,
    Forwards = 1,
    Backwards = 2,
    Both = 3,
    Auto = 4,
    EndGuard_ = 5,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum PlaybackDirection {
    Normal = 0,
    Reverse = 1,
    Alternate = 2,
    Alternate_reverse = 3,
    EndGuard_ = 4,
}
pub type NativeType = AnimationEffectReadOnly;
#[repr(C)]
#[derive(Debug)]
pub struct nsAttrName {
    pub mBits: usize,
}
#[test]
fn bindgen_test_layout_nsAttrName() {
    assert_eq!(::std::mem::size_of::<nsAttrName>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsAttrName>() , 8usize);
}
pub type nscolor = u32;
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsHexColorType { NoAlpha = 0, AllowAlpha = 1, }
pub enum nsStyledElementNotElementCSSInlineStyle { }
pub enum MiscContainer { }
pub enum ServoDeclarationBlock { }
pub enum Declaration { }
/**
 * A class used to construct a nsString from a nsStringBuffer (we might
 * want to move this to nsString at some point).
 *
 * WARNING: Note that nsCheapString doesn't take an explicit length -- it
 * assumes the string is maximally large, given the nsStringBuffer's storage
 * size.  This means the given string buffer *must* be sized exactly correctly
 * for the string it contains (including one byte for a null terminator).  If
 * it has any unused storage space, then that will result in bogus characters
 * at the end of our nsCheapString.
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsCheapString {
    pub _base: nsString,
}
#[test]
fn bindgen_test_layout_nsCheapString() {
    assert_eq!(::std::mem::size_of::<nsCheapString>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsCheapString>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsAttrValue {
    pub mBits: usize,
}
pub const eSVGTypesBegin: nsAttrValue_ValueType =
    nsAttrValue_ValueType::eSVGAngle;
pub const eSVGTypesEnd: nsAttrValue_ValueType =
    nsAttrValue_ValueType::eSVGViewBox;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsAttrValue_ValueType {
    eString = 0,
    eAtom = 2,
    eInteger = 3,
    eColor = 7,
    eEnum = 11,
    ePercent = 15,
    eGeckoCSSDeclaration = 16,
    eServoCSSDeclaration = 17,
    eURL = 18,
    eImage = 19,
    eAtomArray = 20,
    eDoubleValue = 21,
    eIntMarginValue = 22,
    eSVGAngle = 23,
    eSVGIntegerPair = 24,
    eSVGLength = 25,
    eSVGLengthList = 26,
    eSVGNumberList = 27,
    eSVGNumberPair = 28,
    eSVGPathData = 29,
    eSVGPointList = 30,
    eSVGPreserveAspectRatio = 31,
    eSVGStringList = 32,
    eSVGTransformList = 33,
    eSVGViewBox = 34,
}
/**
   * Structure for a mapping from int (enum) values to strings.  When you use
   * it you generally create an array of them.
   * Instantiate like this:
   * EnumTable myTable[] = {
   *   { "string1", 1 },
   *   { "string2", 2 },
   *   { 0 }
   * }
   */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsAttrValue_EnumTable {
    /** The string the value maps to */
    pub tag: *const ::std::os::raw::c_char,
    /** The enum value that maps to this string */
    pub value: i16,
}
impl ::std::clone::Clone for nsAttrValue_EnumTable {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsAttrValue_EnumTable() {
    assert_eq!(::std::mem::size_of::<nsAttrValue_EnumTable>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsAttrValue_EnumTable>() , 8usize);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsAttrValue_ValueBaseType {
    eStringBase = 0,
    eOtherBase = 1,
    eAtomBase = 2,
    eIntegerBase = 3,
}
#[test]
fn bindgen_test_layout_nsAttrValue() {
    assert_eq!(::std::mem::size_of::<nsAttrValue>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsAttrValue>() , 8usize);
}
extern "C" {
    #[link_name = "_ZN11nsAttrValue15sEnumTableArrayE"]
    pub static mut nsAttrValue_consts_sEnumTableArray:
               nsTArray<*const nsAttrValue_EnumTable>;
}
pub enum nsCSSSelector { }
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsChangeHint {
    nsChangeHint_RepaintFrame = 1,
    nsChangeHint_NeedReflow = 2,
    nsChangeHint_ClearAncestorIntrinsics = 4,
    nsChangeHint_ClearDescendantIntrinsics = 8,
    nsChangeHint_NeedDirtyReflow = 16,
    nsChangeHint_SyncFrameView = 32,
    nsChangeHint_UpdateCursor = 64,
    nsChangeHint_UpdateEffects = 128,
    nsChangeHint_UpdateOpacityLayer = 256,
    nsChangeHint_UpdateTransformLayer = 512,
    nsChangeHint_ReconstructFrame = 1024,
    nsChangeHint_UpdateOverflow = 2048,
    nsChangeHint_UpdateSubtreeOverflow = 4096,
    nsChangeHint_UpdatePostTransformOverflow = 8192,
    nsChangeHint_UpdateParentOverflow = 16384,
    nsChangeHint_ChildrenOnlyTransform = 32768,
    nsChangeHint_RecomputePosition = 65536,
    nsChangeHint_UpdateContainingBlock = 131072,
    nsChangeHint_BorderStyleNoneChange = 262144,
    nsChangeHint_UpdateTextPath = 524288,
    nsChangeHint_SchedulePaint = 1048576,
    nsChangeHint_NeutralChange = 2097152,
    nsChangeHint_InvalidateRenderingObservers = 4194304,
    nsChangeHint_ReflowChangesSizeOrPosition = 8388608,
    nsChangeHint_UpdateComputedBSize = 16777216,
    nsChangeHint_UpdateUsesOpacity = 33554432,
    nsChangeHint_UpdateBackgroundPosition = 67108864,
}
pub type nsChangeHint_size_t = ::std::os::raw::c_int;
/**
 * |nsRestyleHint| is a bitfield for the result of
 * |HasStateDependentStyle| and |HasAttributeDependentStyle|.  When no
 * restyling is necessary, use |nsRestyleHint(0)|.
 *
 * Without eRestyle_Force or eRestyle_ForceDescendants, the restyling process
 * can stop processing at a frame when it detects no style changes and it is
 * known that the styles of the subtree beneath it will not change, leaving
 * the old style context on the frame.  eRestyle_Force can be used to skip this
 * optimization on a frame, and to force its new style context to be used.
 *
 * Similarly, eRestyle_ForceDescendants will cause the frame and all of its
 * descendants to be traversed and for the new style contexts that are created
 * to be set on the frames.
 *
 * NOTE: When adding new restyle hints, please also add them to
 * RestyleManager::RestyleHintToString.
 */
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsRestyleHint {
    eRestyle_Self = 1,
    eRestyle_SomeDescendants = 2,
    eRestyle_Subtree = 4,
    eRestyle_LaterSiblings = 8,
    eRestyle_CSSTransitions = 16,
    eRestyle_CSSAnimations = 32,
    eRestyle_SVGAttrAnimations = 64,
    eRestyle_StyleAttribute = 128,
    eRestyle_StyleAttribute_Animations = 256,
    eRestyle_Force = 512,
    eRestyle_ForceDescendants = 1024,
    eRestyle_AllHintsWithAnimations = 368,
}
pub type nsRestyleHint_size_t = ::std::os::raw::c_int;
/**
 * Additional data used in conjunction with an nsRestyleHint to control the
 * restyle process.
 */
#[repr(C)]
#[derive(Debug)]
pub struct RestyleHintData {
    pub mSelectorsForDescendants: nsTArray<*mut nsCSSSelector>,
}
#[test]
fn bindgen_test_layout_RestyleHintData() {
    assert_eq!(::std::mem::size_of::<RestyleHintData>() , 8usize);
    assert_eq!(::std::mem::align_of::<RestyleHintData>() , 8usize);
}
/**
 * A structure representing a single attribute name and value.
 *
 * This is pretty similar to the private nsAttrAndChildArray::InternalAttr.
 */
#[repr(C)]
#[derive(Debug)]
pub struct ServoAttrSnapshot {
    pub mName: nsAttrName,
    pub mValue: nsAttrValue,
}
#[test]
fn bindgen_test_layout_ServoAttrSnapshot() {
    assert_eq!(::std::mem::size_of::<ServoAttrSnapshot>() , 16usize);
    assert_eq!(::std::mem::align_of::<ServoAttrSnapshot>() , 8usize);
}
/**
 * A bitflags enum class used to determine what data does a ServoElementSnapshot
 * contains.
 */
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum ServoElementSnapshotFlags {
    State = 1,
    Attributes = 2,
    HTMLElementInHTMLDocument = 4,
    All = 7,
}
/**
 * This class holds all non-tree-structural state of an element that might be
 * used for selector matching eventually.
 *
 * This means the attributes, and the element state, such as :hover, :active,
 * etc...
 */
#[repr(C)]
#[derive(Debug)]
pub struct ServoElementSnapshot {
    pub mContains: ServoElementSnapshotFlags,
    pub mAttrs: nsTArray<ServoAttrSnapshot>,
    pub mState: ::std::os::raw::c_uchar,
    pub mExplicitRestyleHint: nsRestyleHint,
    pub mExplicitChangeHint: nsChangeHint,
    pub mIsHTMLElementInHTMLDocument: bool,
}
#[test]
fn bindgen_test_layout_ServoElementSnapshot() {
    assert_eq!(::std::mem::size_of::<ServoElementSnapshot>() , 32usize);
    assert_eq!(::std::mem::align_of::<ServoElementSnapshot>() , 8usize);
}
pub enum ErrorReporter { }
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsCSSTokenType {
    eCSSToken_Whitespace = 0,
    eCSSToken_Comment = 1,
    eCSSToken_Ident = 2,
    eCSSToken_Function = 3,
    eCSSToken_AtKeyword = 4,
    eCSSToken_ID = 5,
    eCSSToken_Hash = 6,
    eCSSToken_Number = 7,
    eCSSToken_Dimension = 8,
    eCSSToken_Percentage = 9,
    eCSSToken_String = 10,
    eCSSToken_Bad_String = 11,
    eCSSToken_URL = 12,
    eCSSToken_Bad_URL = 13,
    eCSSToken_Symbol = 14,
    eCSSToken_Includes = 15,
    eCSSToken_Dashmatch = 16,
    eCSSToken_Beginsmatch = 17,
    eCSSToken_Endsmatch = 18,
    eCSSToken_Containsmatch = 19,
    eCSSToken_URange = 20,
    eCSSToken_HTMLComment = 21,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsCSSTokenSerializationType {
    eCSSTokenSerialization_Nothing = 0,
    eCSSTokenSerialization_Whitespace = 1,
    eCSSTokenSerialization_AtKeyword_or_Hash = 2,
    eCSSTokenSerialization_Number = 3,
    eCSSTokenSerialization_Dimension = 4,
    eCSSTokenSerialization_Percentage = 5,
    eCSSTokenSerialization_URange = 6,
    eCSSTokenSerialization_URL_or_BadURL = 7,
    eCSSTokenSerialization_Function = 8,
    eCSSTokenSerialization_Ident = 9,
    eCSSTokenSerialization_CDC = 10,
    eCSSTokenSerialization_DashMatch = 11,
    eCSSTokenSerialization_ContainsMatch = 12,
    eCSSTokenSerialization_Symbol_Hash = 13,
    eCSSTokenSerialization_Symbol_At = 14,
    eCSSTokenSerialization_Symbol_Dot_or_Plus = 15,
    eCSSTokenSerialization_Symbol_Minus = 16,
    eCSSTokenSerialization_Symbol_OpenParen = 17,
    eCSSTokenSerialization_Symbol_Question = 18,
    eCSSTokenSerialization_Symbol_Assorted = 19,
    eCSSTokenSerialization_Symbol_Equals = 20,
    eCSSTokenSerialization_Symbol_Bar = 21,
    eCSSTokenSerialization_Symbol_Slash = 22,
    eCSSTokenSerialization_Symbol_Asterisk = 23,
    eCSSTokenSerialization_Other = 24,
}
#[repr(C)]
pub struct nsCSSToken {
    pub mIdent: nsAutoString,
    pub mNumber: f32,
    pub mInteger: i32,
    pub mInteger2: i32,
    pub mType: nsCSSTokenType,
    pub mSymbol: ::std::os::raw::c_ushort,
    pub mIntegerValid: bool,
    pub mHasSign: bool,
}
#[test]
fn bindgen_test_layout_nsCSSToken() {
    assert_eq!(::std::mem::size_of::<nsCSSToken>() , 184usize);
    assert_eq!(::std::mem::align_of::<nsCSSToken>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsCSSScannerPosition {
    pub mOffset: u32,
    pub mLineNumber: u32,
    pub mLineOffset: u32,
    pub mTokenLineNumber: u32,
    pub mTokenLineOffset: u32,
    pub mTokenOffset: u32,
    pub mInitialized: bool,
}
impl ::std::clone::Clone for nsCSSScannerPosition {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsCSSScannerPosition() {
    assert_eq!(::std::mem::size_of::<nsCSSScannerPosition>() , 28usize);
    assert_eq!(::std::mem::align_of::<nsCSSScannerPosition>() , 4usize);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsCSSScannerExclude {
    eCSSScannerExclude_None = 0,
    eCSSScannerExclude_Comments = 1,
    eCSSScannerExclude_WhitespaceAndComments = 2,
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSScanner {
    pub mBuffer: *const ::std::os::raw::c_ushort,
    pub mOffset: u32,
    pub mCount: u32,
    pub mLineNumber: u32,
    pub mLineOffset: u32,
    pub mTokenLineNumber: u32,
    pub mTokenLineOffset: u32,
    pub mTokenOffset: u32,
    pub mRecordStartOffset: u32,
    pub mEOFCharacters: nsCSSScanner_EOFCharacters,
    pub mReporter: *mut ErrorReporter,
    pub mSVGMode: bool,
    pub mRecording: bool,
    pub mSeenBadToken: bool,
    pub mSeenVariableReference: bool,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsCSSScanner_EOFCharacters {
    eEOFCharacters_None = 0,
    eEOFCharacters_DropBackslash = 1,
    eEOFCharacters_ReplacementChar = 2,
    eEOFCharacters_Asterisk = 4,
    eEOFCharacters_Slash = 8,
    eEOFCharacters_DoubleQuote = 16,
    eEOFCharacters_SingleQuote = 32,
    eEOFCharacters_CloseParen = 64,
}
#[test]
fn bindgen_test_layout_nsCSSScanner() {
    assert_eq!(::std::mem::size_of::<nsCSSScanner>() , 64usize);
    assert_eq!(::std::mem::align_of::<nsCSSScanner>() , 8usize);
}
#[repr(C)]
pub struct nsCSSGridTemplateAreaToken {
    pub mName: nsAutoString,
    pub isTrash: bool,
}
#[test]
fn bindgen_test_layout_nsCSSGridTemplateAreaToken() {
    assert_eq!(::std::mem::size_of::<nsCSSGridTemplateAreaToken>() ,
               168usize);
    assert_eq!(::std::mem::align_of::<nsCSSGridTemplateAreaToken>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsCSSGridTemplateAreaScanner {
    pub mBuffer: *const ::std::os::raw::c_ushort,
    pub mOffset: u32,
    pub mCount: u32,
}
impl ::std::clone::Clone for nsCSSGridTemplateAreaScanner {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsCSSGridTemplateAreaScanner() {
    assert_eq!(::std::mem::size_of::<nsCSSGridTemplateAreaScanner>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<nsCSSGridTemplateAreaScanner>() ,
               8usize);
}
pub enum CSSVariableResolver { }
#[repr(C)]
pub struct CSSVariableValues {
    pub mVariableIDs: [u64; 6usize],
    /**
   * Array of variables, indexed by variable ID.
   */
    pub mVariables: nsTArray<CSSVariableValues_Variable>,
}
#[repr(C)]
#[derive(Debug)]
pub struct CSSVariableValues_Variable {
    pub mVariableName: nsString,
    pub mValue: nsString,
    pub mFirstToken: nsCSSTokenSerializationType,
    pub mLastToken: nsCSSTokenSerializationType,
}
#[test]
fn bindgen_test_layout_CSSVariableValues_Variable() {
    assert_eq!(::std::mem::size_of::<CSSVariableValues_Variable>() , 40usize);
    assert_eq!(::std::mem::align_of::<CSSVariableValues_Variable>() , 8usize);
}
#[test]
fn bindgen_test_layout_CSSVariableValues() {
    assert_eq!(::std::mem::size_of::<CSSVariableValues>() , 56usize);
    assert_eq!(::std::mem::align_of::<CSSVariableValues>() , 8usize);
}
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum SheetType {
    Agent = 0,
    User = 1,
    PresHint = 2,
    SVGAttrAnimation = 3,
    Doc = 4,
    ScopedDoc = 5,
    StyleAttr = 6,
    Override = 7,
    Animation = 8,
    Transition = 9,
    Count = 10,
    Unknown = -1,
}
/**
 * StaticAutoPtr and StaticRefPtr are like nsAutoPtr and nsRefPtr, except they
 * are suitable for use as global variables.
 *
 * In particular, a global instance of Static{Auto,Ref}Ptr doesn't cause the
 * compiler to emit  a static initializer (in release builds, anyway).
 *
 * In order to accomplish this, Static{Auto,Ref}Ptr must have a trivial
 * constructor and destructor.  As a consequence, it cannot initialize its raw
 * pointer to 0 on construction, and it cannot delete/release its raw pointer
 * upon destruction.
 *
 * Since the compiler guarantees that all global variables are initialized to
 * 0, these trivial constructors are safe.  Since we rely on this, the clang
 * plugin, run as part of our "static analysis" builds, makes it a compile-time
 * error to use Static{Auto,Ref}Ptr as anything except a global variable.
 *
 * Static{Auto,Ref}Ptr have a limited interface as compared to ns{Auto,Ref}Ptr;
 * this is intentional, since their range of acceptable uses is smaller.
 */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StaticAutoPtr<T> {
    pub mRawPtr: *mut T,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StaticRefPtr<T> {
    pub mRawPtr: *mut T,
}
pub enum Zero { }
pub const eFamily_generic_first: FontFamilyType =
    FontFamilyType::eFamily_serif;
pub const eFamily_generic_last: FontFamilyType =
    FontFamilyType::eFamily_fantasy;
pub const eFamily_generic_count: FontFamilyType =
    FontFamilyType::eFamily_monospace;
/**
 * type of font family name, either a name (e.g. Helvetica) or a
 * generic (e.g. serif, sans-serif), with the ability to distinguish
 * between unquoted and quoted names for serializaiton
 */
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum FontFamilyType {
    eFamily_none = 0,
    eFamily_named = 1,
    eFamily_named_quoted = 2,
    eFamily_serif = 3,
    eFamily_sans_serif = 4,
    eFamily_monospace = 5,
    eFamily_cursive = 6,
    eFamily_fantasy = 7,
    eFamily_moz_variable = 8,
    eFamily_moz_fixed = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum QuotedName { eQuotedName = 0, eUnquotedName = 1, }
/**
 * font family name, a string for the name if not a generic and
 * a font type indicated named family or which generic family
 */
#[repr(C)]
#[derive(Debug)]
pub struct FontFamilyName {
    pub mType: FontFamilyType,
    pub mName: nsString,
}
#[test]
fn bindgen_test_layout_FontFamilyName() {
    assert_eq!(::std::mem::size_of::<FontFamilyName>() , 24usize);
    assert_eq!(::std::mem::align_of::<FontFamilyName>() , 8usize);
}
/**
 * font family list, array of font families and a default font type.
 * font family names are either named strings or generics. the default
 * font type is used to preserve the variable font fallback behavior
 */
#[repr(C)]
#[derive(Debug)]
pub struct FontFamilyList {
    pub mFontlist: nsTArray<FontFamilyName>,
    pub mDefaultFontType: FontFamilyType,
}
#[test]
fn bindgen_test_layout_FontFamilyList() {
    assert_eq!(::std::mem::size_of::<FontFamilyList>() , 16usize);
    assert_eq!(::std::mem::align_of::<FontFamilyList>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct gfxFontFeature {
    pub mTag: u32,
    pub mValue: u32,
}
impl ::std::clone::Clone for gfxFontFeature {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_gfxFontFeature() {
    assert_eq!(::std::mem::size_of::<gfxFontFeature>() , 8usize);
    assert_eq!(::std::mem::align_of::<gfxFontFeature>() , 4usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct gfxAlternateValue {
    pub alternate: u32,
    pub value: nsString,
}
#[test]
fn bindgen_test_layout_gfxAlternateValue() {
    assert_eq!(::std::mem::size_of::<gfxAlternateValue>() , 24usize);
    assert_eq!(::std::mem::align_of::<gfxAlternateValue>() , 8usize);
}
#[repr(C)]
pub struct gfxFontFeatureValueSet {
    pub _bindgen_opaque_blob: [u64; 8usize],
}
#[test]
fn bindgen_test_layout_gfxFontFeatureValueSet() {
    assert_eq!(::std::mem::size_of::<gfxFontFeatureValueSet>() , 64usize);
    assert_eq!(::std::mem::align_of::<gfxFontFeatureValueSet>() , 8usize);
}
pub enum gfxFontStyle { }
pub type nsFontFamilyEnumFunc =
    ::std::option::Option<unsafe extern "C" fn(aFamily: *const nsString,
                                               aGeneric: bool,
                                               aData:
                                                   *mut ::std::os::raw::c_void)
                              -> bool>;
#[repr(C)]
pub struct nsFont {
    pub fontlist: FontFamilyList,
    pub style: u8,
    pub systemFont: bool,
    pub variantCaps: u8,
    pub variantNumeric: u8,
    pub variantPosition: u8,
    pub variantWidth: u8,
    pub variantLigatures: u16,
    pub variantEastAsian: u16,
    pub variantAlternates: u16,
    pub smoothing: u8,
    pub weight: u16,
    pub stretch: i16,
    pub kerning: u8,
    pub synthesis: u8,
    pub size: nscoord,
    pub sizeAdjust: f32,
    pub alternateValues: nsTArray<gfxAlternateValue>,
    pub featureValueLookup: RefPtr<gfxFontFeatureValueSet>,
    pub fontFeatureSettings: nsTArray<gfxFontFeature>,
    pub languageOverride: nsString,
}
#[test]
fn bindgen_test_layout_nsFont() {
    assert_eq!(::std::mem::size_of::<nsFont>() , 88usize);
    assert_eq!(::std::mem::align_of::<nsFont>() , 8usize);
}
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum StyleBoxSizing { Content = 0, Border = 1, }
pub const eCSSProperty_COUNT_DUMMY: nsCSSProperty =
    nsCSSProperty::eCSSProperty_z_index;
pub const eCSSProperty_all: nsCSSProperty =
    nsCSSProperty::eCSSProperty_COUNT_no_shorthands;
pub const eCSSProperty_COUNT_DUMMY2: nsCSSProperty =
    nsCSSProperty::eCSSProperty_transition;
pub const eCSSPropertyAlias_WordWrap: nsCSSProperty =
    nsCSSProperty::eCSSProperty_COUNT;
pub const eCSSProperty_COUNT_DUMMY3: nsCSSProperty =
    nsCSSProperty::eCSSPropertyAlias_WebkitUserSelect;
pub const eCSSPropertyExtra_no_properties: nsCSSProperty =
    nsCSSProperty::eCSSProperty_COUNT_with_aliases;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsCSSProperty {
    eCSSProperty_UNKNOWN = -1,
    eCSSProperty_align_content = 0,
    eCSSProperty_align_items = 1,
    eCSSProperty_align_self = 2,
    eCSSProperty_animation_delay = 3,
    eCSSProperty_animation_direction = 4,
    eCSSProperty_animation_duration = 5,
    eCSSProperty_animation_fill_mode = 6,
    eCSSProperty_animation_iteration_count = 7,
    eCSSProperty_animation_name = 8,
    eCSSProperty_animation_play_state = 9,
    eCSSProperty_animation_timing_function = 10,
    eCSSProperty_appearance = 11,
    eCSSProperty_backface_visibility = 12,
    eCSSProperty_background_attachment = 13,
    eCSSProperty_background_blend_mode = 14,
    eCSSProperty_background_clip = 15,
    eCSSProperty_background_color = 16,
    eCSSProperty_background_image = 17,
    eCSSProperty_background_origin = 18,
    eCSSProperty_background_position_x = 19,
    eCSSProperty_background_position_y = 20,
    eCSSProperty_background_repeat = 21,
    eCSSProperty_background_size = 22,
    eCSSProperty_binding = 23,
    eCSSProperty_block_size = 24,
    eCSSProperty_border_block_end_color = 25,
    eCSSProperty_border_block_end_style = 26,
    eCSSProperty_border_block_end_width = 27,
    eCSSProperty_border_block_start_color = 28,
    eCSSProperty_border_block_start_style = 29,
    eCSSProperty_border_block_start_width = 30,
    eCSSProperty_border_bottom_color = 31,
    eCSSProperty_border_bottom_colors = 32,
    eCSSProperty_border_bottom_left_radius = 33,
    eCSSProperty_border_bottom_right_radius = 34,
    eCSSProperty_border_bottom_style = 35,
    eCSSProperty_border_bottom_width = 36,
    eCSSProperty_border_collapse = 37,
    eCSSProperty_border_image_outset = 38,
    eCSSProperty_border_image_repeat = 39,
    eCSSProperty_border_image_slice = 40,
    eCSSProperty_border_image_source = 41,
    eCSSProperty_border_image_width = 42,
    eCSSProperty_border_inline_end_color = 43,
    eCSSProperty_border_inline_end_style = 44,
    eCSSProperty_border_inline_end_width = 45,
    eCSSProperty_border_inline_start_color = 46,
    eCSSProperty_border_inline_start_style = 47,
    eCSSProperty_border_inline_start_width = 48,
    eCSSProperty_border_left_color = 49,
    eCSSProperty_border_left_colors = 50,
    eCSSProperty_border_left_style = 51,
    eCSSProperty_border_left_width = 52,
    eCSSProperty_border_right_color = 53,
    eCSSProperty_border_right_colors = 54,
    eCSSProperty_border_right_style = 55,
    eCSSProperty_border_right_width = 56,
    eCSSProperty_border_spacing = 57,
    eCSSProperty_border_top_color = 58,
    eCSSProperty_border_top_colors = 59,
    eCSSProperty_border_top_left_radius = 60,
    eCSSProperty_border_top_right_radius = 61,
    eCSSProperty_border_top_style = 62,
    eCSSProperty_border_top_width = 63,
    eCSSProperty_bottom = 64,
    eCSSProperty_box_align = 65,
    eCSSProperty_box_decoration_break = 66,
    eCSSProperty_box_direction = 67,
    eCSSProperty_box_flex = 68,
    eCSSProperty_box_ordinal_group = 69,
    eCSSProperty_box_orient = 70,
    eCSSProperty_box_pack = 71,
    eCSSProperty_box_shadow = 72,
    eCSSProperty_box_sizing = 73,
    eCSSProperty_caption_side = 74,
    eCSSProperty_clear = 75,
    eCSSProperty_clip = 76,
    eCSSProperty_clip_path = 77,
    eCSSProperty_clip_rule = 78,
    eCSSProperty_color = 79,
    eCSSProperty_color_adjust = 80,
    eCSSProperty_color_interpolation = 81,
    eCSSProperty_color_interpolation_filters = 82,
    eCSSProperty__moz_column_count = 83,
    eCSSProperty__moz_column_fill = 84,
    eCSSProperty__moz_column_gap = 85,
    eCSSProperty__moz_column_rule_color = 86,
    eCSSProperty__moz_column_rule_style = 87,
    eCSSProperty__moz_column_rule_width = 88,
    eCSSProperty__moz_column_width = 89,
    eCSSProperty_contain = 90,
    eCSSProperty_content = 91,
    eCSSProperty__moz_control_character_visibility = 92,
    eCSSProperty_counter_increment = 93,
    eCSSProperty_counter_reset = 94,
    eCSSProperty_cursor = 95,
    eCSSProperty_direction = 96,
    eCSSProperty_display = 97,
    eCSSProperty_dominant_baseline = 98,
    eCSSProperty_empty_cells = 99,
    eCSSProperty_fill = 100,
    eCSSProperty_fill_opacity = 101,
    eCSSProperty_fill_rule = 102,
    eCSSProperty_filter = 103,
    eCSSProperty_flex_basis = 104,
    eCSSProperty_flex_direction = 105,
    eCSSProperty_flex_grow = 106,
    eCSSProperty_flex_shrink = 107,
    eCSSProperty_flex_wrap = 108,
    eCSSProperty_float = 109,
    eCSSProperty_float_edge = 110,
    eCSSProperty_flood_color = 111,
    eCSSProperty_flood_opacity = 112,
    eCSSProperty_font_family = 113,
    eCSSProperty_font_feature_settings = 114,
    eCSSProperty_font_kerning = 115,
    eCSSProperty_font_language_override = 116,
    eCSSProperty_font_size = 117,
    eCSSProperty_font_size_adjust = 118,
    eCSSProperty_font_stretch = 119,
    eCSSProperty_font_style = 120,
    eCSSProperty_font_synthesis = 121,
    eCSSProperty_font_variant_alternates = 122,
    eCSSProperty_font_variant_caps = 123,
    eCSSProperty_font_variant_east_asian = 124,
    eCSSProperty_font_variant_ligatures = 125,
    eCSSProperty_font_variant_numeric = 126,
    eCSSProperty_font_variant_position = 127,
    eCSSProperty_font_weight = 128,
    eCSSProperty_force_broken_image_icon = 129,
    eCSSProperty_grid_auto_columns = 130,
    eCSSProperty_grid_auto_flow = 131,
    eCSSProperty_grid_auto_rows = 132,
    eCSSProperty_grid_column_end = 133,
    eCSSProperty_grid_column_gap = 134,
    eCSSProperty_grid_column_start = 135,
    eCSSProperty_grid_row_end = 136,
    eCSSProperty_grid_row_gap = 137,
    eCSSProperty_grid_row_start = 138,
    eCSSProperty_grid_template_areas = 139,
    eCSSProperty_grid_template_columns = 140,
    eCSSProperty_grid_template_rows = 141,
    eCSSProperty_height = 142,
    eCSSProperty_hyphens = 143,
    eCSSProperty_image_orientation = 144,
    eCSSProperty_image_region = 145,
    eCSSProperty_image_rendering = 146,
    eCSSProperty_ime_mode = 147,
    eCSSProperty_inline_size = 148,
    eCSSProperty_isolation = 149,
    eCSSProperty_justify_content = 150,
    eCSSProperty_justify_items = 151,
    eCSSProperty_justify_self = 152,
    eCSSProperty__x_lang = 153,
    eCSSProperty_left = 154,
    eCSSProperty_letter_spacing = 155,
    eCSSProperty_lighting_color = 156,
    eCSSProperty_line_height = 157,
    eCSSProperty_list_style_image = 158,
    eCSSProperty_list_style_position = 159,
    eCSSProperty_list_style_type = 160,
    eCSSProperty_margin_block_end = 161,
    eCSSProperty_margin_block_start = 162,
    eCSSProperty_margin_bottom = 163,
    eCSSProperty_margin_inline_end = 164,
    eCSSProperty_margin_inline_start = 165,
    eCSSProperty_margin_left = 166,
    eCSSProperty_margin_right = 167,
    eCSSProperty_margin_top = 168,
    eCSSProperty_marker_end = 169,
    eCSSProperty_marker_mid = 170,
    eCSSProperty_marker_offset = 171,
    eCSSProperty_marker_start = 172,
    eCSSProperty_mask = 173,
    eCSSProperty_mask_type = 174,
    eCSSProperty_math_display = 175,
    eCSSProperty_math_variant = 176,
    eCSSProperty_max_block_size = 177,
    eCSSProperty_max_height = 178,
    eCSSProperty_max_inline_size = 179,
    eCSSProperty_max_width = 180,
    eCSSProperty_min_block_size = 181,
    eCSSProperty__moz_min_font_size_ratio = 182,
    eCSSProperty_min_height = 183,
    eCSSProperty_min_inline_size = 184,
    eCSSProperty_min_width = 185,
    eCSSProperty_mix_blend_mode = 186,
    eCSSProperty_object_fit = 187,
    eCSSProperty_object_position = 188,
    eCSSProperty_offset_block_end = 189,
    eCSSProperty_offset_block_start = 190,
    eCSSProperty_offset_inline_end = 191,
    eCSSProperty_offset_inline_start = 192,
    eCSSProperty_opacity = 193,
    eCSSProperty_order = 194,
    eCSSProperty_orient = 195,
    eCSSProperty_osx_font_smoothing = 196,
    eCSSProperty_outline_color = 197,
    eCSSProperty_outline_offset = 198,
    eCSSProperty__moz_outline_radius_bottomLeft = 199,
    eCSSProperty__moz_outline_radius_bottomRight = 200,
    eCSSProperty__moz_outline_radius_topLeft = 201,
    eCSSProperty__moz_outline_radius_topRight = 202,
    eCSSProperty_outline_style = 203,
    eCSSProperty_outline_width = 204,
    eCSSProperty_overflow_clip_box = 205,
    eCSSProperty_overflow_x = 206,
    eCSSProperty_overflow_y = 207,
    eCSSProperty_padding_block_end = 208,
    eCSSProperty_padding_block_start = 209,
    eCSSProperty_padding_bottom = 210,
    eCSSProperty_padding_inline_end = 211,
    eCSSProperty_padding_inline_start = 212,
    eCSSProperty_padding_left = 213,
    eCSSProperty_padding_right = 214,
    eCSSProperty_padding_top = 215,
    eCSSProperty_page_break_after = 216,
    eCSSProperty_page_break_before = 217,
    eCSSProperty_page_break_inside = 218,
    eCSSProperty_paint_order = 219,
    eCSSProperty_perspective = 220,
    eCSSProperty_perspective_origin = 221,
    eCSSProperty_pointer_events = 222,
    eCSSProperty_position = 223,
    eCSSProperty_quotes = 224,
    eCSSProperty_resize = 225,
    eCSSProperty_right = 226,
    eCSSProperty_ruby_align = 227,
    eCSSProperty_ruby_position = 228,
    eCSSProperty_script_level = 229,
    eCSSProperty_script_min_size = 230,
    eCSSProperty_script_size_multiplier = 231,
    eCSSProperty_scroll_behavior = 232,
    eCSSProperty_scroll_snap_coordinate = 233,
    eCSSProperty_scroll_snap_destination = 234,
    eCSSProperty_scroll_snap_points_x = 235,
    eCSSProperty_scroll_snap_points_y = 236,
    eCSSProperty_scroll_snap_type_x = 237,
    eCSSProperty_scroll_snap_type_y = 238,
    eCSSProperty_shape_rendering = 239,
    eCSSProperty__x_span = 240,
    eCSSProperty_stack_sizing = 241,
    eCSSProperty_stop_color = 242,
    eCSSProperty_stop_opacity = 243,
    eCSSProperty_stroke = 244,
    eCSSProperty_stroke_dasharray = 245,
    eCSSProperty_stroke_dashoffset = 246,
    eCSSProperty_stroke_linecap = 247,
    eCSSProperty_stroke_linejoin = 248,
    eCSSProperty_stroke_miterlimit = 249,
    eCSSProperty_stroke_opacity = 250,
    eCSSProperty_stroke_width = 251,
    eCSSProperty__x_system_font = 252,
    eCSSProperty__moz_tab_size = 253,
    eCSSProperty_table_layout = 254,
    eCSSProperty_text_align = 255,
    eCSSProperty_text_align_last = 256,
    eCSSProperty_text_anchor = 257,
    eCSSProperty_text_combine_upright = 258,
    eCSSProperty_text_decoration_color = 259,
    eCSSProperty_text_decoration_line = 260,
    eCSSProperty_text_decoration_style = 261,
    eCSSProperty_text_emphasis_color = 262,
    eCSSProperty_text_emphasis_position = 263,
    eCSSProperty_text_emphasis_style = 264,
    eCSSProperty__webkit_text_fill_color = 265,
    eCSSProperty_text_indent = 266,
    eCSSProperty_text_orientation = 267,
    eCSSProperty_text_overflow = 268,
    eCSSProperty_text_rendering = 269,
    eCSSProperty_text_shadow = 270,
    eCSSProperty_text_size_adjust = 271,
    eCSSProperty__webkit_text_stroke_color = 272,
    eCSSProperty__webkit_text_stroke_width = 273,
    eCSSProperty_text_transform = 274,
    eCSSProperty__x_text_zoom = 275,
    eCSSProperty_top = 276,
    eCSSProperty__moz_top_layer = 277,
    eCSSProperty_touch_action = 278,
    eCSSProperty_transform = 279,
    eCSSProperty_transform_box = 280,
    eCSSProperty_transform_origin = 281,
    eCSSProperty_transform_style = 282,
    eCSSProperty_transition_delay = 283,
    eCSSProperty_transition_duration = 284,
    eCSSProperty_transition_property = 285,
    eCSSProperty_transition_timing_function = 286,
    eCSSProperty_unicode_bidi = 287,
    eCSSProperty_user_focus = 288,
    eCSSProperty_user_input = 289,
    eCSSProperty_user_modify = 290,
    eCSSProperty_user_select = 291,
    eCSSProperty_vector_effect = 292,
    eCSSProperty_vertical_align = 293,
    eCSSProperty_visibility = 294,
    eCSSProperty_white_space = 295,
    eCSSProperty_width = 296,
    eCSSProperty_will_change = 297,
    eCSSProperty__moz_window_dragging = 298,
    eCSSProperty__moz_window_shadow = 299,
    eCSSProperty_word_break = 300,
    eCSSProperty_word_spacing = 301,
    eCSSProperty_overflow_wrap = 302,
    eCSSProperty_writing_mode = 303,
    eCSSProperty_z_index = 304,
    eCSSProperty_COUNT_no_shorthands = 305,
    eCSSProperty_animation = 306,
    eCSSProperty_background = 307,
    eCSSProperty_background_position = 308,
    eCSSProperty_border = 309,
    eCSSProperty_border_block_end = 310,
    eCSSProperty_border_block_start = 311,
    eCSSProperty_border_bottom = 312,
    eCSSProperty_border_color = 313,
    eCSSProperty_border_image = 314,
    eCSSProperty_border_inline_end = 315,
    eCSSProperty_border_inline_start = 316,
    eCSSProperty_border_left = 317,
    eCSSProperty_border_radius = 318,
    eCSSProperty_border_right = 319,
    eCSSProperty_border_style = 320,
    eCSSProperty_border_top = 321,
    eCSSProperty_border_width = 322,
    eCSSProperty__moz_column_rule = 323,
    eCSSProperty__moz_columns = 324,
    eCSSProperty_flex = 325,
    eCSSProperty_flex_flow = 326,
    eCSSProperty_font = 327,
    eCSSProperty_font_variant = 328,
    eCSSProperty_grid = 329,
    eCSSProperty_grid_area = 330,
    eCSSProperty_grid_column = 331,
    eCSSProperty_grid_gap = 332,
    eCSSProperty_grid_row = 333,
    eCSSProperty_grid_template = 334,
    eCSSProperty_list_style = 335,
    eCSSProperty_margin = 336,
    eCSSProperty_marker = 337,
    eCSSProperty_outline = 338,
    eCSSProperty__moz_outline_radius = 339,
    eCSSProperty_overflow = 340,
    eCSSProperty_padding = 341,
    eCSSProperty_scroll_snap_type = 342,
    eCSSProperty_text_decoration = 343,
    eCSSProperty_text_emphasis = 344,
    eCSSProperty__webkit_text_stroke = 345,
    eCSSProperty__moz_transform = 346,
    eCSSProperty_transition = 347,
    eCSSProperty_COUNT = 348,
    eCSSPropertyAlias_MozTransformOrigin = 349,
    eCSSPropertyAlias_MozPerspectiveOrigin = 350,
    eCSSPropertyAlias_MozPerspective = 351,
    eCSSPropertyAlias_MozTransformStyle = 352,
    eCSSPropertyAlias_MozBackfaceVisibility = 353,
    eCSSPropertyAlias_MozBorderImage = 354,
    eCSSPropertyAlias_MozTransition = 355,
    eCSSPropertyAlias_MozTransitionDelay = 356,
    eCSSPropertyAlias_MozTransitionDuration = 357,
    eCSSPropertyAlias_MozTransitionProperty = 358,
    eCSSPropertyAlias_MozTransitionTimingFunction = 359,
    eCSSPropertyAlias_MozAnimation = 360,
    eCSSPropertyAlias_MozAnimationDelay = 361,
    eCSSPropertyAlias_MozAnimationDirection = 362,
    eCSSPropertyAlias_MozAnimationDuration = 363,
    eCSSPropertyAlias_MozAnimationFillMode = 364,
    eCSSPropertyAlias_MozAnimationIterationCount = 365,
    eCSSPropertyAlias_MozAnimationName = 366,
    eCSSPropertyAlias_MozAnimationPlayState = 367,
    eCSSPropertyAlias_MozAnimationTimingFunction = 368,
    eCSSPropertyAlias_MozBoxSizing = 369,
    eCSSPropertyAlias_MozFontFeatureSettings = 370,
    eCSSPropertyAlias_MozFontLanguageOverride = 371,
    eCSSPropertyAlias_MozPaddingEnd = 372,
    eCSSPropertyAlias_MozPaddingStart = 373,
    eCSSPropertyAlias_MozMarginEnd = 374,
    eCSSPropertyAlias_MozMarginStart = 375,
    eCSSPropertyAlias_MozBorderEnd = 376,
    eCSSPropertyAlias_MozBorderEndColor = 377,
    eCSSPropertyAlias_MozBorderEndStyle = 378,
    eCSSPropertyAlias_MozBorderEndWidth = 379,
    eCSSPropertyAlias_MozBorderStart = 380,
    eCSSPropertyAlias_MozBorderStartColor = 381,
    eCSSPropertyAlias_MozBorderStartStyle = 382,
    eCSSPropertyAlias_MozBorderStartWidth = 383,
    eCSSPropertyAlias_MozHyphens = 384,
    eCSSPropertyAlias_MozTextAlignLast = 385,
    eCSSPropertyAlias_WebkitAnimation = 386,
    eCSSPropertyAlias_WebkitAnimationDelay = 387,
    eCSSPropertyAlias_WebkitAnimationDirection = 388,
    eCSSPropertyAlias_WebkitAnimationDuration = 389,
    eCSSPropertyAlias_WebkitAnimationFillMode = 390,
    eCSSPropertyAlias_WebkitAnimationIterationCount = 391,
    eCSSPropertyAlias_WebkitAnimationName = 392,
    eCSSPropertyAlias_WebkitAnimationPlayState = 393,
    eCSSPropertyAlias_WebkitAnimationTimingFunction = 394,
    eCSSPropertyAlias_WebkitFilter = 395,
    eCSSPropertyAlias_WebkitTextSizeAdjust = 396,
    eCSSPropertyAlias_WebkitTransform = 397,
    eCSSPropertyAlias_WebkitTransformOrigin = 398,
    eCSSPropertyAlias_WebkitTransformStyle = 399,
    eCSSPropertyAlias_WebkitBackfaceVisibility = 400,
    eCSSPropertyAlias_WebkitPerspective = 401,
    eCSSPropertyAlias_WebkitPerspectiveOrigin = 402,
    eCSSPropertyAlias_WebkitTransition = 403,
    eCSSPropertyAlias_WebkitTransitionDelay = 404,
    eCSSPropertyAlias_WebkitTransitionDuration = 405,
    eCSSPropertyAlias_WebkitTransitionProperty = 406,
    eCSSPropertyAlias_WebkitTransitionTimingFunction = 407,
    eCSSPropertyAlias_WebkitBorderRadius = 408,
    eCSSPropertyAlias_WebkitBorderTopLeftRadius = 409,
    eCSSPropertyAlias_WebkitBorderTopRightRadius = 410,
    eCSSPropertyAlias_WebkitBorderBottomLeftRadius = 411,
    eCSSPropertyAlias_WebkitBorderBottomRightRadius = 412,
    eCSSPropertyAlias_WebkitBackgroundClip = 413,
    eCSSPropertyAlias_WebkitBackgroundOrigin = 414,
    eCSSPropertyAlias_WebkitBackgroundSize = 415,
    eCSSPropertyAlias_WebkitBorderImage = 416,
    eCSSPropertyAlias_WebkitBoxShadow = 417,
    eCSSPropertyAlias_WebkitBoxSizing = 418,
    eCSSPropertyAlias_WebkitBoxFlex = 419,
    eCSSPropertyAlias_WebkitBoxOrdinalGroup = 420,
    eCSSPropertyAlias_WebkitBoxOrient = 421,
    eCSSPropertyAlias_WebkitBoxDirection = 422,
    eCSSPropertyAlias_WebkitBoxAlign = 423,
    eCSSPropertyAlias_WebkitBoxPack = 424,
    eCSSPropertyAlias_WebkitFlexDirection = 425,
    eCSSPropertyAlias_WebkitFlexWrap = 426,
    eCSSPropertyAlias_WebkitFlexFlow = 427,
    eCSSPropertyAlias_WebkitOrder = 428,
    eCSSPropertyAlias_WebkitFlex = 429,
    eCSSPropertyAlias_WebkitFlexGrow = 430,
    eCSSPropertyAlias_WebkitFlexShrink = 431,
    eCSSPropertyAlias_WebkitFlexBasis = 432,
    eCSSPropertyAlias_WebkitJustifyContent = 433,
    eCSSPropertyAlias_WebkitAlignItems = 434,
    eCSSPropertyAlias_WebkitAlignSelf = 435,
    eCSSPropertyAlias_WebkitAlignContent = 436,
    eCSSPropertyAlias_WebkitUserSelect = 437,
    eCSSProperty_COUNT_with_aliases = 438,
    eCSSPropertyExtra_all_properties = 439,
    eCSSPropertyExtra_x_none_value = 440,
    eCSSPropertyExtra_x_auto_value = 441,
    eCSSPropertyExtra_variable = 442,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsCSSFontDesc {
    eCSSFontDesc_UNKNOWN = -1,
    eCSSFontDesc_Family = 0,
    eCSSFontDesc_Style = 1,
    eCSSFontDesc_Weight = 2,
    eCSSFontDesc_Stretch = 3,
    eCSSFontDesc_Src = 4,
    eCSSFontDesc_UnicodeRange = 5,
    eCSSFontDesc_FontFeatureSettings = 6,
    eCSSFontDesc_FontLanguageOverride = 7,
    eCSSFontDesc_Display = 8,
    eCSSFontDesc_COUNT = 9,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsCSSCounterDesc {
    eCSSCounterDesc_UNKNOWN = -1,
    eCSSCounterDesc_System = 0,
    eCSSCounterDesc_Symbols = 1,
    eCSSCounterDesc_AdditiveSymbols = 2,
    eCSSCounterDesc_Negative = 3,
    eCSSCounterDesc_Prefix = 4,
    eCSSCounterDesc_Suffix = 5,
    eCSSCounterDesc_Range = 6,
    eCSSCounterDesc_Pad = 7,
    eCSSCounterDesc_Fallback = 8,
    eCSSCounterDesc_SpeakAs = 9,
    eCSSCounterDesc_COUNT = 10,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsCSSPropertyLogicalGroup {
    eCSSPropertyLogicalGroup_UNKNOWN = -1,
    eCSSPropertyLogicalGroup_BorderColor = 0,
    eCSSPropertyLogicalGroup_BorderStyle = 1,
    eCSSPropertyLogicalGroup_BorderWidth = 2,
    eCSSPropertyLogicalGroup_Margin = 3,
    eCSSPropertyLogicalGroup_MaxSize = 4,
    eCSSPropertyLogicalGroup_Offset = 5,
    eCSSPropertyLogicalGroup_Padding = 6,
    eCSSPropertyLogicalGroup_MinSize = 7,
    eCSSPropertyLogicalGroup_Size = 8,
    eCSSPropertyLogicalGroup_COUNT = 9,
}
/**
 * Class to safely handle main-thread-only pointers off the main thread.
 *
 * Classes like XPCWrappedJS are main-thread-only, which means that it is
 * forbidden to call methods on instances of these classes off the main thread.
 * For various reasons (see bug 771074), this restriction recently began to
 * apply to AddRef/Release as well.
 *
 * This presents a problem for consumers that wish to hold a callback alive
 * on non-main-thread code. A common example of this is the proxy callback
 * pattern, where non-main-thread code holds a strong-reference to the callback
 * object, and dispatches new Runnables (also with a strong reference) to the
 * main thread in order to execute the callback. This involves several AddRef
 * and Release calls on the other thread, which is (now) verboten.
 *
 * The basic idea of this class is to introduce a layer of indirection.
 * nsMainThreadPtrHolder is a threadsafe reference-counted class that internally
 * maintains one strong reference to the main-thread-only object. It must be
 * instantiated on the main thread (so that the AddRef of the underlying object
 * happens on the main thread), but consumers may subsequently pass references
 * to the holder anywhere they please. These references are meant to be opaque
 * when accessed off-main-thread (assertions enforce this).
 *
 * The semantics of RefPtr<nsMainThreadPtrHolder<T> > would be cumbersome, so
 * we also introduce nsMainThreadPtrHandle<T>, which is conceptually identical
 * to the above (though it includes various convenience methods). The basic
 * pattern is as follows.
 *
 * // On the main thread:
 * nsCOMPtr<nsIFooCallback> callback = ...;
 * nsMainThreadPtrHandle<nsIFooCallback> callbackHandle =
 *   new nsMainThreadPtrHolder<nsIFooCallback>(callback);
 * // Pass callbackHandle to structs/classes that might be accessed on other
 * // threads.
 *
 * All structs and classes that might be accessed on other threads should store
 * an nsMainThreadPtrHandle<T> rather than an nsCOMPtr<T>.
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsMainThreadPtrHolder<T> {
    pub mRefCnt: ThreadSafeAutoRefCnt,
    pub mRawPtr: *mut T,
    pub mStrict: bool,
}
#[repr(C)]
#[derive(Debug)]
pub struct nsMainThreadPtrHandle<T> {
    pub mPtr: RefPtr<T>,
}
pub enum CSSStyleSheet { }
#[repr(C)]
pub struct URLValueData {
    pub _bindgen_opaque_blob: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_URLValueData() {
    assert_eq!(::std::mem::size_of::<URLValueData>() , 40usize);
    assert_eq!(::std::mem::align_of::<URLValueData>() , 8usize);
}
#[repr(C)]
pub struct URLValue {
    pub _bindgen_opaque_blob: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_URLValue() {
    assert_eq!(::std::mem::size_of::<URLValue>() , 48usize);
    assert_eq!(::std::mem::align_of::<URLValue>() , 8usize);
}
#[repr(C)]
pub struct ImageValue {
    pub _bindgen_opaque_blob: [u64; 13usize],
}
#[test]
fn bindgen_test_layout_ImageValue() {
    assert_eq!(::std::mem::size_of::<ImageValue>() , 104usize);
    assert_eq!(::std::mem::align_of::<ImageValue>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct GridNamedArea {
    pub mName: nsString,
    pub mColumnStart: u32,
    pub mColumnEnd: u32,
    pub mRowStart: u32,
    pub mRowEnd: u32,
}
#[test]
fn bindgen_test_layout_GridNamedArea() {
    assert_eq!(::std::mem::size_of::<GridNamedArea>() , 32usize);
    assert_eq!(::std::mem::align_of::<GridNamedArea>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct GridTemplateAreasValue {
    pub mNamedAreas: nsTArray<GridNamedArea>,
    pub mTemplates: nsTArray<nsString>,
    pub mNColumns: u32,
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
}
#[test]
fn bindgen_test_layout_GridTemplateAreasValue() {
    assert_eq!(::std::mem::size_of::<GridTemplateAreasValue>() , 40usize);
    assert_eq!(::std::mem::align_of::<GridTemplateAreasValue>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct FontFamilyListRefCnt {
    pub _base: FontFamilyList,
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
}
#[test]
fn bindgen_test_layout_FontFamilyListRefCnt() {
    assert_eq!(::std::mem::size_of::<FontFamilyListRefCnt>() , 32usize);
    assert_eq!(::std::mem::align_of::<FontFamilyListRefCnt>() , 8usize);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsCSSUnit {
    eCSSUnit_Null = 0,
    eCSSUnit_Auto = 1,
    eCSSUnit_Inherit = 2,
    eCSSUnit_Initial = 3,
    eCSSUnit_Unset = 4,
    eCSSUnit_None = 5,
    eCSSUnit_Normal = 6,
    eCSSUnit_System_Font = 7,
    eCSSUnit_All = 8,
    eCSSUnit_Dummy = 9,
    eCSSUnit_DummyInherit = 10,
    eCSSUnit_String = 11,
    eCSSUnit_Ident = 12,
    eCSSUnit_Attr = 14,
    eCSSUnit_Local_Font = 15,
    eCSSUnit_Font_Format = 16,
    eCSSUnit_Element = 17,
    eCSSUnit_Array = 20,
    eCSSUnit_Counter = 21,
    eCSSUnit_Counters = 22,
    eCSSUnit_Cubic_Bezier = 23,
    eCSSUnit_Steps = 24,
    eCSSUnit_Symbols = 25,
    eCSSUnit_Function = 26,
    eCSSUnit_Calc = 30,
    eCSSUnit_Calc_Plus = 31,
    eCSSUnit_Calc_Minus = 32,
    eCSSUnit_Calc_Times_L = 33,
    eCSSUnit_Calc_Times_R = 34,
    eCSSUnit_Calc_Divided = 35,
    eCSSUnit_URL = 40,
    eCSSUnit_Image = 41,
    eCSSUnit_Gradient = 42,
    eCSSUnit_TokenStream = 43,
    eCSSUnit_GridTemplateAreas = 44,
    eCSSUnit_Pair = 50,
    eCSSUnit_Triplet = 51,
    eCSSUnit_Rect = 52,
    eCSSUnit_List = 53,
    eCSSUnit_ListDep = 54,
    eCSSUnit_SharedList = 55,
    eCSSUnit_PairList = 56,
    eCSSUnit_PairListDep = 57,
    eCSSUnit_FontFamilyList = 58,
    eCSSUnit_Integer = 70,
    eCSSUnit_Enumerated = 71,
    eCSSUnit_EnumColor = 80,
    eCSSUnit_RGBColor = 81,
    eCSSUnit_RGBAColor = 82,
    eCSSUnit_HexColor = 83,
    eCSSUnit_ShortHexColor = 84,
    eCSSUnit_HexColorAlpha = 85,
    eCSSUnit_ShortHexColorAlpha = 86,
    eCSSUnit_PercentageRGBColor = 87,
    eCSSUnit_PercentageRGBAColor = 88,
    eCSSUnit_HSLColor = 89,
    eCSSUnit_HSLAColor = 90,
    eCSSUnit_Percent = 100,
    eCSSUnit_Number = 101,
    eCSSUnit_PhysicalMillimeter = 200,
    eCSSUnit_ViewportWidth = 700,
    eCSSUnit_ViewportHeight = 701,
    eCSSUnit_ViewportMin = 702,
    eCSSUnit_ViewportMax = 703,
    eCSSUnit_EM = 800,
    eCSSUnit_XHeight = 801,
    eCSSUnit_Char = 802,
    eCSSUnit_RootEM = 803,
    eCSSUnit_Point = 900,
    eCSSUnit_Inch = 901,
    eCSSUnit_Millimeter = 902,
    eCSSUnit_Centimeter = 903,
    eCSSUnit_Pica = 904,
    eCSSUnit_Quarter = 905,
    eCSSUnit_Pixel = 906,
    eCSSUnit_Degree = 1000,
    eCSSUnit_Grad = 1001,
    eCSSUnit_Radian = 1002,
    eCSSUnit_Turn = 1003,
    eCSSUnit_Hertz = 2000,
    eCSSUnit_Kilohertz = 2001,
    eCSSUnit_Seconds = 3000,
    eCSSUnit_Milliseconds = 3001,
    eCSSUnit_FlexFraction = 4000,
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValue {
    pub mUnit: nsCSSUnit,
    pub mValue: nsCSSValue_nsCSSValue_h_unnamed_13,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsCSSValue_Serialization { eNormalized = 0, eAuthorSpecified = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsCSSValue_nsCSSValue_h_unnamed_13 {
    pub mInt: __BindgenUnionField<i32>,
    pub mFloat: __BindgenUnionField<f32>,
    pub mString: __BindgenUnionField<*mut nsStringBuffer>,
    pub mColor: __BindgenUnionField<nscolor>,
    pub mArray: __BindgenUnionField<*mut Array>,
    pub mURL: __BindgenUnionField<*mut URLValue>,
    pub mImage: __BindgenUnionField<*mut ImageValue>,
    pub mGridTemplateAreas: __BindgenUnionField<*mut GridTemplateAreasValue>,
    pub mGradient: __BindgenUnionField<*mut nsCSSValueGradient>,
    pub mTokenStream: __BindgenUnionField<*mut nsCSSValueTokenStream>,
    pub mPair: __BindgenUnionField<*mut nsCSSValuePair_heap>,
    pub mRect: __BindgenUnionField<*mut nsCSSRect_heap>,
    pub mTriplet: __BindgenUnionField<*mut nsCSSValueTriplet_heap>,
    pub mList: __BindgenUnionField<*mut nsCSSValueList_heap>,
    pub mListDependent: __BindgenUnionField<*mut nsCSSValueList>,
    pub mSharedList: __BindgenUnionField<*mut nsCSSValueSharedList>,
    pub mPairList: __BindgenUnionField<*mut nsCSSValuePairList_heap>,
    pub mPairListDependent: __BindgenUnionField<*mut nsCSSValuePairList>,
    pub mFloatColor: __BindgenUnionField<*mut nsCSSValueFloatColor>,
    pub mFontFamilyList: __BindgenUnionField<*mut FontFamilyListRefCnt>,
    pub _bindgen_data_: u64,
}
impl nsCSSValue_nsCSSValue_h_unnamed_13 { }
impl ::std::clone::Clone for nsCSSValue_nsCSSValue_h_unnamed_13 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsCSSValue_nsCSSValue_h_unnamed_13() {
    assert_eq!(::std::mem::size_of::<nsCSSValue_nsCSSValue_h_unnamed_13>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<nsCSSValue_nsCSSValue_h_unnamed_13>() ,
               8usize);
}
#[test]
fn bindgen_test_layout_nsCSSValue() {
    assert_eq!(::std::mem::size_of::<nsCSSValue>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsCSSValue>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct Array {
    pub mRefCnt: usize,
    pub mCount: usize,
    pub mArray: [nsCSSValue; 1usize],
}
#[test]
fn bindgen_test_layout_Array() {
    assert_eq!(::std::mem::size_of::<Array>() , 32usize);
    assert_eq!(::std::mem::align_of::<Array>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValueList {
    pub mValue: nsCSSValue,
    pub mNext: *mut nsCSSValueList,
}
#[test]
fn bindgen_test_layout_nsCSSValueList() {
    assert_eq!(::std::mem::size_of::<nsCSSValueList>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsCSSValueList>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValueList_heap {
    pub _base: nsCSSValueList,
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
}
#[test]
fn bindgen_test_layout_nsCSSValueList_heap() {
    assert_eq!(::std::mem::size_of::<nsCSSValueList_heap>() , 40usize);
    assert_eq!(::std::mem::align_of::<nsCSSValueList_heap>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValueSharedList {
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    pub mHead: *mut nsCSSValueList,
}
#[test]
fn bindgen_test_layout_nsCSSValueSharedList() {
    assert_eq!(::std::mem::size_of::<nsCSSValueSharedList>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsCSSValueSharedList>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSRect {
    pub mTop: nsCSSValue,
    pub mRight: nsCSSValue,
    pub mBottom: nsCSSValue,
    pub mLeft: nsCSSValue,
}
#[test]
fn bindgen_test_layout_nsCSSRect() {
    assert_eq!(::std::mem::size_of::<nsCSSRect>() , 64usize);
    assert_eq!(::std::mem::align_of::<nsCSSRect>() , 8usize);
}
extern "C" {
    #[link_name = "_ZN9nsCSSRect5sidesE"]
    pub static mut nsCSSRect_consts_sides: [::std::os::raw::c_void; 4usize];
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSRect_heap {
    pub _base: nsCSSRect,
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
}
#[test]
fn bindgen_test_layout_nsCSSRect_heap() {
    assert_eq!(::std::mem::size_of::<nsCSSRect_heap>() , 80usize);
    assert_eq!(::std::mem::align_of::<nsCSSRect_heap>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValuePair {
    pub mXValue: nsCSSValue,
    pub mYValue: nsCSSValue,
}
#[test]
fn bindgen_test_layout_nsCSSValuePair() {
    assert_eq!(::std::mem::size_of::<nsCSSValuePair>() , 32usize);
    assert_eq!(::std::mem::align_of::<nsCSSValuePair>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValuePair_heap {
    pub _base: nsCSSValuePair,
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
}
#[test]
fn bindgen_test_layout_nsCSSValuePair_heap() {
    assert_eq!(::std::mem::size_of::<nsCSSValuePair_heap>() , 48usize);
    assert_eq!(::std::mem::align_of::<nsCSSValuePair_heap>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValueTriplet {
    pub mXValue: nsCSSValue,
    pub mYValue: nsCSSValue,
    pub mZValue: nsCSSValue,
}
#[test]
fn bindgen_test_layout_nsCSSValueTriplet() {
    assert_eq!(::std::mem::size_of::<nsCSSValueTriplet>() , 48usize);
    assert_eq!(::std::mem::align_of::<nsCSSValueTriplet>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValueTriplet_heap {
    pub _base: nsCSSValueTriplet,
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
}
#[test]
fn bindgen_test_layout_nsCSSValueTriplet_heap() {
    assert_eq!(::std::mem::size_of::<nsCSSValueTriplet_heap>() , 64usize);
    assert_eq!(::std::mem::align_of::<nsCSSValueTriplet_heap>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValuePairList {
    pub mXValue: nsCSSValue,
    pub mYValue: nsCSSValue,
    pub mNext: *mut nsCSSValuePairList,
}
#[test]
fn bindgen_test_layout_nsCSSValuePairList() {
    assert_eq!(::std::mem::size_of::<nsCSSValuePairList>() , 40usize);
    assert_eq!(::std::mem::align_of::<nsCSSValuePairList>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValuePairList_heap {
    pub _base: nsCSSValuePairList,
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
}
#[test]
fn bindgen_test_layout_nsCSSValuePairList_heap() {
    assert_eq!(::std::mem::size_of::<nsCSSValuePairList_heap>() , 56usize);
    assert_eq!(::std::mem::align_of::<nsCSSValuePairList_heap>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValueGradientStop {
    pub mLocation: nsCSSValue,
    pub mColor: nsCSSValue,
    pub mIsInterpolationHint: bool,
}
#[test]
fn bindgen_test_layout_nsCSSValueGradientStop() {
    assert_eq!(::std::mem::size_of::<nsCSSValueGradientStop>() , 40usize);
    assert_eq!(::std::mem::align_of::<nsCSSValueGradientStop>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValueGradient {
    pub mIsRadial: bool,
    pub mIsRepeating: bool,
    pub mIsLegacySyntax: bool,
    pub mIsExplicitSize: bool,
    pub mBgPos: nsCSSValuePair,
    pub mAngle: nsCSSValue,
    pub mRadialValues: [nsCSSValue; 2usize],
    pub mStops: nsTArray<nsCSSValueGradientStop>,
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
}
#[test]
fn bindgen_test_layout_nsCSSValueGradient() {
    assert_eq!(::std::mem::size_of::<nsCSSValueGradient>() , 112usize);
    assert_eq!(::std::mem::align_of::<nsCSSValueGradient>() , 8usize);
}
#[repr(C)]
pub struct nsCSSValueTokenStream {
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    pub mPropertyID: nsCSSProperty,
    pub mShorthandPropertyID: nsCSSProperty,
    pub mTokenStream: nsString,
    pub mBaseURI: nsCOMPtr<nsIURI>,
    pub mSheetURI: nsCOMPtr<nsIURI>,
    pub mSheetPrincipal: nsCOMPtr<nsIPrincipal>,
    pub mLineNumber: u32,
    pub mLineOffset: u32,
    pub mLevel: SheetType,
}
#[test]
fn bindgen_test_layout_nsCSSValueTokenStream() {
    assert_eq!(::std::mem::size_of::<nsCSSValueTokenStream>() , 80usize);
    assert_eq!(::std::mem::align_of::<nsCSSValueTokenStream>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSValueFloatColor {
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    pub mComponent1: f32,
    pub mComponent2: f32,
    pub mComponent3: f32,
    pub mAlpha: f32,
}
#[test]
fn bindgen_test_layout_nsCSSValueFloatColor() {
    assert_eq!(::std::mem::size_of::<nsCSSValueFloatColor>() , 32usize);
    assert_eq!(::std::mem::align_of::<nsCSSValueFloatColor>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSCornerSizes {
    pub mTopLeft: nsCSSValue,
    pub mTopRight: nsCSSValue,
    pub mBottomRight: nsCSSValue,
    pub mBottomLeft: nsCSSValue,
}
#[test]
fn bindgen_test_layout_nsCSSCornerSizes() {
    assert_eq!(::std::mem::size_of::<nsCSSCornerSizes>() , 64usize);
    assert_eq!(::std::mem::align_of::<nsCSSCornerSizes>() , 8usize);
}
extern "C" {
    #[link_name = "_ZN16nsCSSCornerSizes7cornersE"]
    pub static mut nsCSSCornerSizes_consts_corners:
               [::std::os::raw::c_void; 4usize];
}
pub enum WritingMode { }
pub type CounterValue = i32;
pub enum NegativeType { }
pub enum PadType { }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CounterStyle {
    pub _vftable: *const _vftable_CounterStyle,
    pub mStyle: i32,
}
#[repr(C)]
pub struct _vftable_CounterStyle {
    pub _bindgen_empty_ctype_warning_fix: u64,
}
impl ::std::clone::Clone for CounterStyle {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_CounterStyle() {
    assert_eq!(::std::mem::size_of::<CounterStyle>() , 16usize);
    assert_eq!(::std::mem::align_of::<CounterStyle>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct AnonymousCounterStyle {
    pub _base: CounterStyle,
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    pub mSingleString: bool,
    pub mSystem: u8,
    pub mSymbols: nsTArray<nsString>,
}
#[repr(C)]
pub struct _vftable_AnonymousCounterStyle {
    pub _base: _vftable_CounterStyle,
}
#[test]
fn bindgen_test_layout_AnonymousCounterStyle() {
    assert_eq!(::std::mem::size_of::<AnonymousCounterStyle>() , 48usize);
    assert_eq!(::std::mem::align_of::<AnonymousCounterStyle>() , 8usize);
}
#[repr(C)]
pub struct CounterStyleManager {
    pub _bindgen_opaque_blob: [u64; 9usize],
}
#[test]
fn bindgen_test_layout_CounterStyleManager() {
    assert_eq!(::std::mem::size_of::<CounterStyleManager>() , 72usize);
    assert_eq!(::std::mem::align_of::<CounterStyleManager>() , 8usize);
}
/**
 * A class for holding strong references to nsPresArena-allocated
 * objects.
 *
 * Since the arena's lifetime is not related to the refcounts
 * of the objects allocated within it, it is possible to have a strong
 * reference to an arena-allocated object that lives until the
 * destruction of the arena.  An ArenaRefPtr acts like a weak reference
 * in that it will clear its referent if the arena is about to go away.
 *
 * T must be a class that has these two methods:
 *
 *   static mozilla::ArenaObjectID ArenaObjectID();
 *   U* Arena();
 *
 * where U is a class that has these two methods:
 *
 *   void RegisterArenaRefPtr(ArenaRefPtr<T>*);
 *   void DeregisterArenaRefPtr(ArenaRefPtr<T>*);
 *
 * Currently, both nsPresArena and nsIPresShell can be used as U.
 *
 * The ArenaObjectID method must return the mozilla::ArenaObjectID that
 * uniquely identifies T, and the Arena method must return the nsPresArena
 * (or a proxy for it) in which the object was allocated.
 */
#[repr(C)]
#[derive(Debug)]
pub struct ArenaRefPtr<T> {
    pub mPtr: RefPtr<T>,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum gfxFontConstants_h_unnamed_14 {
    eFeatureAlternates_historical = 0,
    eFeatureAlternates_stylistic = 1,
    eFeatureAlternates_styleset = 2,
    eFeatureAlternates_character_variant = 3,
    eFeatureAlternates_swash = 4,
    eFeatureAlternates_ornaments = 5,
    eFeatureAlternates_annotation = 6,
    eFeatureAlternates_numFeatures = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum gfxFontConstants_h_unnamed_15 {
    eFeatureEastAsian_jis78 = 0,
    eFeatureEastAsian_jis83 = 1,
    eFeatureEastAsian_jis90 = 2,
    eFeatureEastAsian_jis04 = 3,
    eFeatureEastAsian_simplified = 4,
    eFeatureEastAsian_traditional = 5,
    eFeatureEastAsian_full_width = 6,
    eFeatureEastAsian_prop_width = 7,
    eFeatureEastAsian_ruby = 8,
    eFeatureEastAsian_numFeatures = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum gfxFontConstants_h_unnamed_16 {
    eFeatureLigatures_none = 0,
    eFeatureLigatures_common = 1,
    eFeatureLigatures_no_common = 2,
    eFeatureLigatures_discretionary = 3,
    eFeatureLigatures_no_discretionary = 4,
    eFeatureLigatures_historical = 5,
    eFeatureLigatures_no_historical = 6,
    eFeatureLigatures_contextual = 7,
    eFeatureLigatures_no_contextual = 8,
    eFeatureLigatures_numFeatures = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum gfxFontConstants_h_unnamed_17 {
    eFeatureNumeric_lining = 0,
    eFeatureNumeric_oldstyle = 1,
    eFeatureNumeric_proportional = 2,
    eFeatureNumeric_tabular = 3,
    eFeatureNumeric_diagonal_fractions = 4,
    eFeatureNumeric_stacked_fractions = 5,
    eFeatureNumeric_slashedzero = 6,
    eFeatureNumeric_ordinal = 7,
    eFeatureNumeric_numFeatures = 8,
}
pub const eFontPrefLang_First: eFontPrefLang =
    eFontPrefLang::eFontPrefLang_Western;
pub const eFontPrefLang_Last: eFontPrefLang =
    eFontPrefLang::eFontPrefLang_Others;
pub const eFontPrefLang_Count: eFontPrefLang =
    eFontPrefLang::eFontPrefLang_CJKSet;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum eFontPrefLang {
    eFontPrefLang_Western = 0,
    eFontPrefLang_Japanese = 1,
    eFontPrefLang_ChineseTW = 2,
    eFontPrefLang_ChineseCN = 3,
    eFontPrefLang_ChineseHK = 4,
    eFontPrefLang_Korean = 5,
    eFontPrefLang_Cyrillic = 6,
    eFontPrefLang_Greek = 7,
    eFontPrefLang_Thai = 8,
    eFontPrefLang_Hebrew = 9,
    eFontPrefLang_Arabic = 10,
    eFontPrefLang_Devanagari = 11,
    eFontPrefLang_Tamil = 12,
    eFontPrefLang_Armenian = 13,
    eFontPrefLang_Bengali = 14,
    eFontPrefLang_Canadian = 15,
    eFontPrefLang_Ethiopic = 16,
    eFontPrefLang_Georgian = 17,
    eFontPrefLang_Gujarati = 18,
    eFontPrefLang_Gurmukhi = 19,
    eFontPrefLang_Khmer = 20,
    eFontPrefLang_Malayalam = 21,
    eFontPrefLang_Mathematics = 22,
    eFontPrefLang_Oriya = 23,
    eFontPrefLang_Telugu = 24,
    eFontPrefLang_Kannada = 25,
    eFontPrefLang_Sinhala = 26,
    eFontPrefLang_Tibetan = 27,
    eFontPrefLang_Others = 28,
    eFontPrefLang_CJKSet = 29,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum LogicalAxis { eLogicalAxisBlock = 0, eLogicalAxisInline = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum LogicalEdge { eLogicalEdgeStart = 0, eLogicalEdgeEnd = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum LogicalSide {
    eLogicalSideBStart = 0,
    eLogicalSideBEnd = 1,
    eLogicalSideIStart = 2,
    eLogicalSideIEnd = 3,
}
pub const eStyleUnit_MAX: nsStyleUnit = nsStyleUnit::eStyleUnit_Calc;
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsStyleUnit {
    eStyleUnit_Null = 0,
    eStyleUnit_Normal = 1,
    eStyleUnit_Auto = 2,
    eStyleUnit_None = 3,
    eStyleUnit_Percent = 10,
    eStyleUnit_Factor = 11,
    eStyleUnit_Degree = 12,
    eStyleUnit_Grad = 13,
    eStyleUnit_Radian = 14,
    eStyleUnit_Turn = 15,
    eStyleUnit_FlexFraction = 16,
    eStyleUnit_Coord = 20,
    eStyleUnit_Integer = 30,
    eStyleUnit_Enumerated = 32,
    eStyleUnit_Calc = 40,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleCoord_h_unnamed_18 {
    pub mInt: __BindgenUnionField<i32>,
    pub mFloat: __BindgenUnionField<f32>,
    pub mPointer: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub _bindgen_data_: u64,
}
impl nsStyleCoord_h_unnamed_18 { }
impl ::std::clone::Clone for nsStyleCoord_h_unnamed_18 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsStyleCoord_h_unnamed_18() {
    assert_eq!(::std::mem::size_of::<nsStyleCoord_h_unnamed_18>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsStyleCoord_h_unnamed_18>() , 8usize);
}
pub type nsStyleUnion = nsStyleCoord_h_unnamed_18;
/**
 * Class that hold a single size specification used by the style
 * system.  The size specification consists of two parts -- a number
 * and a unit.  The number is an integer, a floating point value, an
 * nscoord, or undefined, and the unit is an nsStyleUnit.  Checking
 * the unit is a must before asking for the value in any particular
 * form.
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleCoord {
    pub mUnit: nsStyleUnit,
    pub mValue: nsStyleUnion,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleCoord_CalcValue {
    pub mLength: nscoord,
    pub mPercent: f32,
    pub mHasPercent: bool,
}
impl ::std::clone::Clone for nsStyleCoord_CalcValue {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsStyleCoord_CalcValue() {
    assert_eq!(::std::mem::size_of::<nsStyleCoord_CalcValue>() , 12usize);
    assert_eq!(::std::mem::align_of::<nsStyleCoord_CalcValue>() , 4usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleCoord_Calc {
    pub _base: nsStyleCoord_CalcValue,
    pub mRefCnt: ThreadSafeAutoRefCnt,
}
#[test]
fn bindgen_test_layout_nsStyleCoord_Calc() {
    assert_eq!(::std::mem::size_of::<nsStyleCoord_Calc>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsStyleCoord_Calc>() , 8usize);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsStyleCoord_CoordConstructorType { CoordConstructor = 0, }
#[test]
fn bindgen_test_layout_nsStyleCoord() {
    assert_eq!(::std::mem::size_of::<nsStyleCoord>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsStyleCoord>() , 8usize);
}
/**
 * Class that represents a set of top/right/bottom/left nsStyleCoords.
 * This is commonly used to hold the widths of the borders, margins,
 * or paddings of a box.
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleSides {
    pub mUnits: [nsStyleUnit; 4usize],
    pub mValues: [nsStyleUnion; 4usize],
}
#[test]
fn bindgen_test_layout_nsStyleSides() {
    assert_eq!(::std::mem::size_of::<nsStyleSides>() , 40usize);
    assert_eq!(::std::mem::align_of::<nsStyleSides>() , 8usize);
}
/**
 * Class that represents a set of top-left/top-right/bottom-left/bottom-right
 * nsStyleCoord pairs.  This is used to hold the dimensions of the
 * corners of a box (for, e.g., border-radius and outline-radius).
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleCorners {
    pub mUnits: [nsStyleUnit; 8usize],
    pub mValues: [nsStyleUnion; 8usize],
}
#[test]
fn bindgen_test_layout_nsStyleCorners() {
    assert_eq!(::std::mem::size_of::<nsStyleCorners>() , 72usize);
    assert_eq!(::std::mem::align_of::<nsStyleCorners>() , 8usize);
}
pub enum imgIContainer { }
pub enum imgINotificationObserver { }
#[repr(C)]
pub struct imgIRequest {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_imgIRequest() {
    assert_eq!(::std::mem::size_of::<imgIRequest>() , 8usize);
    assert_eq!(::std::mem::align_of::<imgIRequest>() , 8usize);
}
pub enum imgStatusNotifyRunnable { }
pub enum ProxyBehaviour { }
pub enum Image { }
pub enum ImageURL { }
pub enum ProgressTracker { }
#[repr(C)]
pub struct imgRequestProxy {
    pub _bindgen_opaque_blob: [u64; 15usize],
}
#[test]
fn bindgen_test_layout_imgRequestProxy() {
    assert_eq!(::std::mem::size_of::<imgRequestProxy>() , 120usize);
    assert_eq!(::std::mem::align_of::<imgRequestProxy>() , 8usize);
}
#[repr(C)]
pub struct imgRequestProxyStatic {
    pub _bindgen_opaque_blob: [u64; 16usize],
}
#[test]
fn bindgen_test_layout_imgRequestProxyStatic() {
    assert_eq!(::std::mem::size_of::<imgRequestProxyStatic>() , 128usize);
    assert_eq!(::std::mem::align_of::<imgRequestProxyStatic>() , 8usize);
}
pub enum nsStyleContext { }
pub enum nsTextFrame { }
#[repr(C)]
pub struct nsStyleFont {
    pub mFont: nsFont,
    pub mSize: nscoord,
    pub mGenericID: u8,
    pub mScriptLevel: i8,
    pub mMathVariant: u8,
    pub mMathDisplay: u8,
    pub mMinFontSizeRatio: u8,
    pub mExplicitLanguage: bool,
    pub mAllowZoom: bool,
    pub mScriptUnconstrainedSize: nscoord,
    pub mScriptMinSize: nscoord,
    pub mScriptSizeMultiplier: f32,
    pub mLanguage: nsCOMPtr<nsIAtom>,
}
#[test]
fn bindgen_test_layout_nsStyleFont() {
    assert_eq!(::std::mem::size_of::<nsStyleFont>() , 120usize);
    assert_eq!(::std::mem::align_of::<nsStyleFont>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleGradientStop {
    pub mLocation: nsStyleCoord,
    pub mColor: nscolor,
    pub mIsInterpolationHint: bool,
}
#[test]
fn bindgen_test_layout_nsStyleGradientStop() {
    assert_eq!(::std::mem::size_of::<nsStyleGradientStop>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsStyleGradientStop>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleGradient {
    pub mShape: u8,
    pub mSize: u8,
    pub mRepeating: bool,
    pub mLegacySyntax: bool,
    pub mBgPosX: nsStyleCoord,
    pub mBgPosY: nsStyleCoord,
    pub mAngle: nsStyleCoord,
    pub mRadiusX: nsStyleCoord,
    pub mRadiusY: nsStyleCoord,
    pub mStops: nsTArray<nsStyleGradientStop>,
    pub mRefCnt: ThreadSafeAutoRefCnt,
}
#[test]
fn bindgen_test_layout_nsStyleGradient() {
    assert_eq!(::std::mem::size_of::<nsStyleGradient>() , 104usize);
    assert_eq!(::std::mem::align_of::<nsStyleGradient>() , 8usize);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsStyleImageType {
    eStyleImageType_Null = 0,
    eStyleImageType_Image = 1,
    eStyleImageType_Gradient = 2,
    eStyleImageType_Element = 3,
}
/**
 * Represents a paintable image of one of the following types.
 * (1) A real image loaded from an external source.
 * (2) A CSS linear or radial gradient.
 * (3) An element within a document, or an <img>, <video>, or <canvas> element
 *     not in a document.
 * (*) Optionally a crop rect can be set to paint a partial (rectangular)
 * region of an image. (Currently, this feature is only supported with an
 * image of type (1)).
 */
#[repr(C)]
pub struct nsStyleImage {
    pub mSubImages: u64,
    pub mType: nsStyleImageType,
    pub nsStyleImage_nsStyleStruct_h_unnamed_21: nsStyleImage_nsStyleStruct_h_unnamed_21,
    pub mCropRect: nsAutoPtr<nsStyleSides>,
    pub mImageTracked: bool,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleImage_nsStyleStruct_h_unnamed_21 {
    pub mImage: __BindgenUnionField<*mut imgRequestProxy>,
    pub mGradient: __BindgenUnionField<*mut nsStyleGradient>,
    pub mElementId: __BindgenUnionField<*mut ::std::os::raw::c_ushort>,
    pub _bindgen_data_: u64,
}
impl nsStyleImage_nsStyleStruct_h_unnamed_21 { }
impl ::std::clone::Clone for nsStyleImage_nsStyleStruct_h_unnamed_21 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsStyleImage_nsStyleStruct_h_unnamed_21() {
    assert_eq!(::std::mem::size_of::<nsStyleImage_nsStyleStruct_h_unnamed_21>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<nsStyleImage_nsStyleStruct_h_unnamed_21>()
               , 8usize);
}
#[test]
fn bindgen_test_layout_nsStyleImage() {
    assert_eq!(::std::mem::size_of::<nsStyleImage>() , 40usize);
    assert_eq!(::std::mem::align_of::<nsStyleImage>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleColor {
    pub mColor: nscolor,
}
#[test]
fn bindgen_test_layout_nsStyleColor() {
    assert_eq!(::std::mem::size_of::<nsStyleColor>() , 4usize);
    assert_eq!(::std::mem::align_of::<nsStyleColor>() , 4usize);
}
/**
 * An array of objects, similar to AutoTArray<T,1> but which is memmovable. It
 * always has length >= 1.
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleAutoArray<T> {
    pub mFirstElement: T,
    pub mOtherElements: nsTArray<T>,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsStyleAutoArray_WithSingleInitialElement {
    WITH_SINGLE_INITIAL_ELEMENT = 0,
}
#[repr(C)]
pub struct nsStyleImageLayers {
    pub mAttachmentCount: u32,
    pub mClipCount: u32,
    pub mOriginCount: u32,
    pub mRepeatCount: u32,
    pub mPositionXCount: u32,
    pub mPositionYCount: u32,
    pub mImageCount: u32,
    pub mSizeCount: u32,
    pub mMaskModeCount: u32,
    pub mBlendModeCount: u32,
    pub mCompositeCount: u32,
    pub mLayers: nsStyleAutoArray<nsStyleImageLayers_Layer>,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsStyleImageLayers_nsStyleStruct_h_unnamed_22 {
    shorthand = 0,
    color = 1,
    image = 2,
    repeat = 3,
    positionX = 4,
    positionY = 5,
    clip = 6,
    origin = 7,
    size = 8,
    attachment = 9,
    maskMode = 10,
    composite = 11,
}
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsStyleImageLayers_LayerType { Background = 0, Mask = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleImageLayers_Position {
    pub mXPosition: nsStyleCoord_CalcValue,
    pub mYPosition: nsStyleCoord_CalcValue,
}
impl ::std::clone::Clone for nsStyleImageLayers_Position {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsStyleImageLayers_Position() {
    assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Position>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<nsStyleImageLayers_Position>() ,
               4usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleImageLayers_Size {
    pub mWidth: nsStyleImageLayers_Size_Dimension,
    pub mHeight: nsStyleImageLayers_Size_Dimension,
    pub mWidthType: u8,
    pub mHeightType: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleImageLayers_Size_Dimension {
    pub _base: nsStyleCoord_CalcValue,
}
impl ::std::clone::Clone for nsStyleImageLayers_Size_Dimension {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsStyleImageLayers_Size_Dimension() {
    assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Size_Dimension>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<nsStyleImageLayers_Size_Dimension>() ,
               4usize);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsStyleImageLayers_Size_DimensionType {
    eContain = 0,
    eCover = 1,
    eAuto = 2,
    eLengthPercentage = 3,
    eDimensionType_COUNT = 4,
}
impl ::std::clone::Clone for nsStyleImageLayers_Size {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsStyleImageLayers_Size() {
    assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Size>() , 28usize);
    assert_eq!(::std::mem::align_of::<nsStyleImageLayers_Size>() , 4usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleImageLayers_Repeat {
    pub mXRepeat: u8,
    pub mYRepeat: u8,
}
impl ::std::clone::Clone for nsStyleImageLayers_Repeat {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsStyleImageLayers_Repeat() {
    assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Repeat>() , 2usize);
    assert_eq!(::std::mem::align_of::<nsStyleImageLayers_Repeat>() , 1usize);
}
#[repr(C)]
pub struct nsStyleImageLayers_Layer {
    pub mImage: nsStyleImage,
    pub mSourceURI: nsCOMPtr<nsIURI>,
    pub mPosition: nsStyleImageLayers_Position,
    pub mSize: nsStyleImageLayers_Size,
    pub mClip: u8,
    pub mOrigin: u8,
    pub mAttachment: u8,
    pub mBlendMode: u8,
    pub mComposite: u8,
    pub mMaskMode: u8,
    pub mRepeat: nsStyleImageLayers_Repeat,
}
#[test]
fn bindgen_test_layout_nsStyleImageLayers_Layer() {
    assert_eq!(::std::mem::size_of::<nsStyleImageLayers_Layer>() , 112usize);
    assert_eq!(::std::mem::align_of::<nsStyleImageLayers_Layer>() , 8usize);
}
#[test]
fn bindgen_test_layout_nsStyleImageLayers() {
    assert_eq!(::std::mem::size_of::<nsStyleImageLayers>() , 168usize);
    assert_eq!(::std::mem::align_of::<nsStyleImageLayers>() , 8usize);
}
extern "C" {
    #[link_name = "_ZN18nsStyleImageLayers21kBackgroundLayerTableE"]
    pub static mut nsStyleImageLayers_consts_kBackgroundLayerTable:
               *const nsCSSProperty;
    #[link_name = "_ZN18nsStyleImageLayers15kMaskLayerTableE"]
    pub static mut nsStyleImageLayers_consts_kMaskLayerTable:
               *const nsCSSProperty;
}
#[repr(C)]
pub struct nsStyleBackground {
    pub mImage: nsStyleImageLayers,
    pub mBackgroundColor: nscolor,
}
#[test]
fn bindgen_test_layout_nsStyleBackground() {
    assert_eq!(::std::mem::size_of::<nsStyleBackground>() , 176usize);
    assert_eq!(::std::mem::align_of::<nsStyleBackground>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleMargin {
    pub mMargin: nsStyleSides,
}
#[test]
fn bindgen_test_layout_nsStyleMargin() {
    assert_eq!(::std::mem::size_of::<nsStyleMargin>() , 40usize);
    assert_eq!(::std::mem::align_of::<nsStyleMargin>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStylePadding {
    pub mPadding: nsStyleSides,
}
#[test]
fn bindgen_test_layout_nsStylePadding() {
    assert_eq!(::std::mem::size_of::<nsStylePadding>() , 40usize);
    assert_eq!(::std::mem::align_of::<nsStylePadding>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsBorderColors {
    pub mNext: *mut nsBorderColors,
    pub mColor: nscolor,
}
#[test]
fn bindgen_test_layout_nsBorderColors() {
    assert_eq!(::std::mem::size_of::<nsBorderColors>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsBorderColors>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSShadowItem {
    pub mXOffset: nscoord,
    pub mYOffset: nscoord,
    pub mRadius: nscoord,
    pub mSpread: nscoord,
    pub mColor: nscolor,
    pub mHasColor: bool,
    pub mInset: bool,
}
#[test]
fn bindgen_test_layout_nsCSSShadowItem() {
    assert_eq!(::std::mem::size_of::<nsCSSShadowItem>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsCSSShadowItem>() , 4usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsCSSShadowArray {
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    pub mLength: u32,
    pub mArray: [nsCSSShadowItem; 1usize],
}
#[test]
fn bindgen_test_layout_nsCSSShadowArray() {
    assert_eq!(::std::mem::size_of::<nsCSSShadowArray>() , 48usize);
    assert_eq!(::std::mem::align_of::<nsCSSShadowArray>() , 8usize);
}
#[repr(C)]
pub struct nsStyleBorder {
    pub mBorderColors: *mut *mut nsBorderColors,
    pub mBorderRadius: nsStyleCorners,
    pub mBorderImageSource: nsStyleImage,
    pub mBorderImageSlice: nsStyleSides,
    pub mBorderImageWidth: nsStyleSides,
    pub mBorderImageOutset: nsStyleSides,
    pub mBorderImageFill: u8,
    pub mBorderImageRepeatH: u8,
    pub mBorderImageRepeatV: u8,
    pub mFloatEdge: u8,
    pub mBoxDecorationBreak: u8,
    pub mComputedBorder: nsMargin,
    pub mBorder: nsMargin,
    pub mBorderStyle: [u8; 4usize],
    pub mBorderColor: [nscolor; 4usize],
    pub mTwipsPerPixel: nscoord,
}
#[test]
fn bindgen_test_layout_nsStyleBorder() {
    assert_eq!(::std::mem::size_of::<nsStyleBorder>() , 304usize);
    assert_eq!(::std::mem::align_of::<nsStyleBorder>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleOutline {
    pub mOutlineRadius: nsStyleCorners,
    pub mOutlineWidth: nsStyleCoord,
    pub mOutlineOffset: nscoord,
    pub mActualOutlineWidth: nscoord,
    pub mOutlineColor: nscolor,
    pub mOutlineStyle: u8,
    pub mTwipsPerPixel: nscoord,
}
#[test]
fn bindgen_test_layout_nsStyleOutline() {
    assert_eq!(::std::mem::size_of::<nsStyleOutline>() , 112usize);
    assert_eq!(::std::mem::align_of::<nsStyleOutline>() , 8usize);
}
/**
 * An object that allows sharing of arrays that store 'quotes' property
 * values.  This is particularly important for inheritance, where we want
 * to share the same 'quotes' value with a parent style context.
 */
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleQuoteValues {
    pub mRefCnt: ThreadSafeAutoRefCnt,
    pub mQuotePairs: nsTArray<pair<nsString, nsString>>,
}
#[test]
fn bindgen_test_layout_nsStyleQuoteValues() {
    assert_eq!(::std::mem::size_of::<nsStyleQuoteValues>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsStyleQuoteValues>() , 8usize);
}
#[repr(C)]
pub struct nsStyleList {
    pub mListStylePosition: u8,
    pub mCounterStyle: RefPtr<CounterStyle>,
    pub mListStyleImage: RefPtr<imgRequestProxy>,
    pub mQuotes: RefPtr<nsStyleQuoteValues>,
    pub mImageRegion: nsRect,
}
#[test]
fn bindgen_test_layout_nsStyleList() {
    assert_eq!(::std::mem::size_of::<nsStyleList>() , 48usize);
    assert_eq!(::std::mem::align_of::<nsStyleList>() , 8usize);
}
extern "C" {
    #[link_name = "_ZN11nsStyleList14sInitialQuotesE"]
    pub static mut nsStyleList_consts_sInitialQuotes:
               StaticRefPtr<nsStyleQuoteValues>;
    #[link_name = "_ZN11nsStyleList11sNoneQuotesE"]
    pub static mut nsStyleList_consts_sNoneQuotes:
               StaticRefPtr<nsStyleQuoteValues>;
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleGridLine {
    pub mHasSpan: bool,
    pub mInteger: i32,
    pub mLineName: nsString,
}
#[test]
fn bindgen_test_layout_nsStyleGridLine() {
    assert_eq!(::std::mem::size_of::<nsStyleGridLine>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsStyleGridLine>() , 8usize);
}
extern "C" {
    #[link_name = "_ZN15nsStyleGridLine8kMinLineE"]
    pub static nsStyleGridLine_consts_kMinLine: ::std::os::raw::c_int;
    #[link_name = "_ZN15nsStyleGridLine8kMaxLineE"]
    pub static nsStyleGridLine_consts_kMaxLine: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleGridTemplate {
    pub mLineNameLists: nsTArray<nsTArray<nsString>>,
    pub mMinTrackSizingFunctions: nsTArray<nsStyleCoord>,
    pub mMaxTrackSizingFunctions: nsTArray<nsStyleCoord>,
    pub mRepeatAutoLineNameListBefore: nsTArray<nsString>,
    pub mRepeatAutoLineNameListAfter: nsTArray<nsString>,
    pub mRepeatAutoIndex: i16,
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout_nsStyleGridTemplate() {
    assert_eq!(::std::mem::size_of::<nsStyleGridTemplate>() , 48usize);
    assert_eq!(::std::mem::align_of::<nsStyleGridTemplate>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStylePosition {
    pub mObjectPosition: nsStyleImageLayers_Position,
    pub mOffset: nsStyleSides,
    pub mWidth: nsStyleCoord,
    pub mMinWidth: nsStyleCoord,
    pub mMaxWidth: nsStyleCoord,
    pub mHeight: nsStyleCoord,
    pub mMinHeight: nsStyleCoord,
    pub mMaxHeight: nsStyleCoord,
    pub mFlexBasis: nsStyleCoord,
    pub mGridAutoColumnsMin: nsStyleCoord,
    pub mGridAutoColumnsMax: nsStyleCoord,
    pub mGridAutoRowsMin: nsStyleCoord,
    pub mGridAutoRowsMax: nsStyleCoord,
    pub mGridAutoFlow: u8,
    pub mBoxSizing: StyleBoxSizing,
    pub mAlignContent: u16,
    pub mAlignItems: u8,
    pub mAlignSelf: u8,
    pub mJustifyContent: u16,
    pub mJustifyItems: u8,
    pub mJustifySelf: u8,
    pub mFlexDirection: u8,
    pub mFlexWrap: u8,
    pub mObjectFit: u8,
    pub mOrder: i32,
    pub mFlexGrow: f32,
    pub mFlexShrink: f32,
    pub mZIndex: nsStyleCoord,
    pub mGridTemplateColumns: nsStyleGridTemplate,
    pub mGridTemplateRows: nsStyleGridTemplate,
    pub mGridTemplateAreas: RefPtr<GridTemplateAreasValue>,
    pub mGridColumnStart: nsStyleGridLine,
    pub mGridColumnEnd: nsStyleGridLine,
    pub mGridRowStart: nsStyleGridLine,
    pub mGridRowEnd: nsStyleGridLine,
    pub mGridColumnGap: nsStyleCoord,
    pub mGridRowGap: nsStyleCoord,
}
#[test]
fn bindgen_test_layout_nsStylePosition() {
    assert_eq!(::std::mem::size_of::<nsStylePosition>() , 520usize);
    assert_eq!(::std::mem::align_of::<nsStylePosition>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleTextOverflowSide {
    pub mString: nsString,
    pub mType: u8,
}
#[test]
fn bindgen_test_layout_nsStyleTextOverflowSide() {
    assert_eq!(::std::mem::size_of::<nsStyleTextOverflowSide>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsStyleTextOverflowSide>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleTextOverflow {
    pub mLeft: nsStyleTextOverflowSide,
    pub mRight: nsStyleTextOverflowSide,
    pub mLogicalDirections: bool,
}
#[test]
fn bindgen_test_layout_nsStyleTextOverflow() {
    assert_eq!(::std::mem::size_of::<nsStyleTextOverflow>() , 56usize);
    assert_eq!(::std::mem::align_of::<nsStyleTextOverflow>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleTextReset {
    pub mTextOverflow: nsStyleTextOverflow,
    pub mTextDecorationLine: u8,
    pub mUnicodeBidi: u8,
    pub mTextDecorationStyle: u8,
    pub mTextDecorationColor: nscolor,
}
#[test]
fn bindgen_test_layout_nsStyleTextReset() {
    assert_eq!(::std::mem::size_of::<nsStyleTextReset>() , 64usize);
    assert_eq!(::std::mem::align_of::<nsStyleTextReset>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleText {
    pub mTextAlign: u8,
    pub mTextAlignLast: u8,
    pub _bitfield_1: u8,
    pub mTextTransform: u8,
    pub mWhiteSpace: u8,
    pub mWordBreak: u8,
    pub mOverflowWrap: u8,
    pub mHyphens: u8,
    pub mRubyAlign: u8,
    pub mRubyPosition: u8,
    pub mTextSizeAdjust: u8,
    pub mTextCombineUpright: u8,
    pub mControlCharacterVisibility: u8,
    pub mTextEmphasisPosition: u8,
    pub mTextEmphasisStyle: u8,
    pub mTextRendering: u8,
    pub mTabSize: i32,
    pub mTextEmphasisColor: nscolor,
    pub mWebkitTextFillColor: nscolor,
    pub mWebkitTextStrokeColor: nscolor,
    pub mWordSpacing: nsStyleCoord,
    pub mLetterSpacing: nsStyleCoord,
    pub mLineHeight: nsStyleCoord,
    pub mTextIndent: nsStyleCoord,
    pub mWebkitTextStrokeWidth: nsStyleCoord,
    pub mTextShadow: RefPtr<nsCSSShadowArray>,
    pub mTextEmphasisStyleString: nsString,
}
#[test]
fn bindgen_test_layout_nsStyleText() {
    assert_eq!(::std::mem::size_of::<nsStyleText>() , 136usize);
    assert_eq!(::std::mem::align_of::<nsStyleText>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleImageOrientation {
    pub mOrientation: u8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsStyleImageOrientation_Bits {
    ORIENTATION_MASK = 3,
    FLIP_MASK = 4,
    FROM_IMAGE_MASK = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsStyleImageOrientation_Angles {
    ANGLE_0 = 0,
    ANGLE_90 = 1,
    ANGLE_180 = 2,
    ANGLE_270 = 3,
}
impl ::std::clone::Clone for nsStyleImageOrientation {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsStyleImageOrientation() {
    assert_eq!(::std::mem::size_of::<nsStyleImageOrientation>() , 1usize);
    assert_eq!(::std::mem::align_of::<nsStyleImageOrientation>() , 1usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleVisibility {
    pub mImageOrientation: nsStyleImageOrientation,
    pub mDirection: u8,
    pub mVisible: u8,
    pub mImageRendering: u8,
    pub mWritingMode: u8,
    pub mTextOrientation: u8,
    pub mColorAdjust: u8,
}
#[test]
fn bindgen_test_layout_nsStyleVisibility() {
    assert_eq!(::std::mem::size_of::<nsStyleVisibility>() , 7usize);
    assert_eq!(::std::mem::align_of::<nsStyleVisibility>() , 1usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsTimingFunction {
    pub mType: nsTimingFunction_Type,
    pub nsTimingFunction_nsStyleStruct_h_unnamed_23: nsTimingFunction_nsStyleStruct_h_unnamed_23,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsTimingFunction_Type {
    Ease = 0,
    Linear = 1,
    EaseIn = 2,
    EaseOut = 3,
    EaseInOut = 4,
    StepStart = 5,
    StepEnd = 6,
    CubicBezier = 7,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsTimingFunction_StepSyntax {
    Keyword = 0,
    FunctionalWithoutKeyword = 1,
    FunctionalWithStartKeyword = 2,
    FunctionalWithEndKeyword = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsTimingFunction_Keyword { Implicit = 0, Explicit = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsTimingFunction_nsStyleStruct_h_unnamed_23 {
    pub mFunc: __BindgenUnionField<nsTimingFunction_nsStyleStruct_h_unnamed_23_nsStyleStruct_h_unnamed_24>,
    pub nsTimingFunction_nsStyleStruct_h_unnamed_23_nsStyleStruct_h_unnamed_25: __BindgenUnionField<nsTimingFunction_nsStyleStruct_h_unnamed_23_nsStyleStruct_h_unnamed_25>,
    pub _bindgen_data_: [u32; 4usize],
}
impl nsTimingFunction_nsStyleStruct_h_unnamed_23 { }
impl ::std::clone::Clone for nsTimingFunction_nsStyleStruct_h_unnamed_23 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsTimingFunction_nsStyleStruct_h_unnamed_23() {
    assert_eq!(::std::mem::size_of::<nsTimingFunction_nsStyleStruct_h_unnamed_23>()
               , 16usize);
    assert_eq!(::std::mem::align_of::<nsTimingFunction_nsStyleStruct_h_unnamed_23>()
               , 4usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsTimingFunction_nsStyleStruct_h_unnamed_23_nsStyleStruct_h_unnamed_24 {
    pub mX1: f32,
    pub mY1: f32,
    pub mX2: f32,
    pub mY2: f32,
}
impl ::std::clone::Clone for
 nsTimingFunction_nsStyleStruct_h_unnamed_23_nsStyleStruct_h_unnamed_24 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsTimingFunction_nsStyleStruct_h_unnamed_23_nsStyleStruct_h_unnamed_24() {
    assert_eq!(::std::mem::size_of::<nsTimingFunction_nsStyleStruct_h_unnamed_23_nsStyleStruct_h_unnamed_24>()
               , 16usize);
    assert_eq!(::std::mem::align_of::<nsTimingFunction_nsStyleStruct_h_unnamed_23_nsStyleStruct_h_unnamed_24>()
               , 4usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsTimingFunction_nsStyleStruct_h_unnamed_23_nsStyleStruct_h_unnamed_25 {
    pub mStepSyntax: nsTimingFunction_StepSyntax,
    pub mSteps: u32,
}
impl ::std::clone::Clone for
 nsTimingFunction_nsStyleStruct_h_unnamed_23_nsStyleStruct_h_unnamed_25 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsTimingFunction_nsStyleStruct_h_unnamed_23_nsStyleStruct_h_unnamed_25() {
    assert_eq!(::std::mem::size_of::<nsTimingFunction_nsStyleStruct_h_unnamed_23_nsStyleStruct_h_unnamed_25>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<nsTimingFunction_nsStyleStruct_h_unnamed_23_nsStyleStruct_h_unnamed_25>()
               , 4usize);
}
impl ::std::clone::Clone for nsTimingFunction {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsTimingFunction() {
    assert_eq!(::std::mem::size_of::<nsTimingFunction>() , 20usize);
    assert_eq!(::std::mem::align_of::<nsTimingFunction>() , 4usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct StyleTransition {
    pub mTimingFunction: nsTimingFunction,
    pub mDuration: f32,
    pub mDelay: f32,
    pub mProperty: nsCSSProperty,
    pub mUnknownProperty: nsCOMPtr<nsIAtom>,
}
#[test]
fn bindgen_test_layout_StyleTransition() {
    assert_eq!(::std::mem::size_of::<StyleTransition>() , 40usize);
    assert_eq!(::std::mem::align_of::<StyleTransition>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct StyleAnimation {
    pub mTimingFunction: nsTimingFunction,
    pub mDuration: f32,
    pub mDelay: f32,
    pub mName: nsString,
    pub mDirection: PlaybackDirection,
    pub mFillMode: FillMode,
    pub mPlayState: u8,
    pub mIterationCount: f32,
}
#[test]
fn bindgen_test_layout_StyleAnimation() {
    assert_eq!(::std::mem::size_of::<StyleAnimation>() , 64usize);
    assert_eq!(::std::mem::align_of::<StyleAnimation>() , 8usize);
}
#[repr(C)]
pub struct nsStyleDisplay {
    pub mBinding: RefPtr<URLValue>,
    pub mDisplay: u8,
    pub mOriginalDisplay: u8,
    pub mContain: u8,
    pub mAppearance: u8,
    pub mPosition: u8,
    pub mFloat: u8,
    pub mOriginalFloat: u8,
    pub mBreakType: u8,
    pub mBreakInside: u8,
    pub mBreakBefore: bool,
    pub mBreakAfter: bool,
    pub mOverflowX: u8,
    pub mOverflowY: u8,
    pub mOverflowClipBox: u8,
    pub mResize: u8,
    pub mOrient: u8,
    pub mIsolation: u8,
    pub mTopLayer: u8,
    pub mWillChangeBitField: u8,
    pub mWillChange: nsTArray<nsString>,
    pub mTouchAction: u8,
    pub mScrollBehavior: u8,
    pub mScrollSnapTypeX: u8,
    pub mScrollSnapTypeY: u8,
    pub mScrollSnapPointsX: nsStyleCoord,
    pub mScrollSnapPointsY: nsStyleCoord,
    pub mScrollSnapDestination: nsStyleImageLayers_Position,
    pub mScrollSnapCoordinate: nsTArray<nsStyleImageLayers_Position>,
    pub mBackfaceVisibility: u8,
    pub mTransformStyle: u8,
    pub mTransformBox: u8,
    pub mSpecifiedTransform: RefPtr<nsCSSValueSharedList>,
    pub mTransformOrigin: [nsStyleCoord; 3usize],
    pub mChildPerspective: nsStyleCoord,
    pub mPerspectiveOrigin: [nsStyleCoord; 2usize],
    pub mVerticalAlign: nsStyleCoord,
    pub mTransitions: nsStyleAutoArray<StyleTransition>,
    pub mTransitionTimingFunctionCount: u32,
    pub mTransitionDurationCount: u32,
    pub mTransitionDelayCount: u32,
    pub mTransitionPropertyCount: u32,
    pub mAnimations: nsStyleAutoArray<StyleAnimation>,
    pub mAnimationTimingFunctionCount: u32,
    pub mAnimationDurationCount: u32,
    pub mAnimationDelayCount: u32,
    pub mAnimationNameCount: u32,
    pub mAnimationDirectionCount: u32,
    pub mAnimationFillModeCount: u32,
    pub mAnimationPlayStateCount: u32,
    pub mAnimationIterationCountCount: u32,
}
#[test]
fn bindgen_test_layout_nsStyleDisplay() {
    assert_eq!(::std::mem::size_of::<nsStyleDisplay>() , 408usize);
    assert_eq!(::std::mem::align_of::<nsStyleDisplay>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleTable {
    pub mLayoutStrategy: u8,
    pub mSpan: i32,
}
#[test]
fn bindgen_test_layout_nsStyleTable() {
    assert_eq!(::std::mem::size_of::<nsStyleTable>() , 8usize);
    assert_eq!(::std::mem::align_of::<nsStyleTable>() , 4usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleTableBorder {
    pub mBorderSpacingCol: nscoord,
    pub mBorderSpacingRow: nscoord,
    pub mBorderCollapse: u8,
    pub mCaptionSide: u8,
    pub mEmptyCells: u8,
}
#[test]
fn bindgen_test_layout_nsStyleTableBorder() {
    assert_eq!(::std::mem::size_of::<nsStyleTableBorder>() , 12usize);
    assert_eq!(::std::mem::align_of::<nsStyleTableBorder>() , 4usize);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsStyleContentType {
    eStyleContentType_String = 1,
    eStyleContentType_Image = 10,
    eStyleContentType_Attr = 20,
    eStyleContentType_Counter = 30,
    eStyleContentType_Counters = 31,
    eStyleContentType_OpenQuote = 40,
    eStyleContentType_CloseQuote = 41,
    eStyleContentType_NoOpenQuote = 42,
    eStyleContentType_NoCloseQuote = 43,
    eStyleContentType_AltContent = 50,
    eStyleContentType_Uninitialized = 51,
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleContentData {
    pub mType: nsStyleContentType,
    pub mContent: nsStyleContentData_nsStyleStruct_h_unnamed_26,
    pub mImageTracked: bool,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleContentData_nsStyleStruct_h_unnamed_26 {
    pub mString: __BindgenUnionField<*mut ::std::os::raw::c_ushort>,
    pub mImage: __BindgenUnionField<*mut imgRequestProxy>,
    pub mCounters: __BindgenUnionField<*mut Array>,
    pub _bindgen_data_: u64,
}
impl nsStyleContentData_nsStyleStruct_h_unnamed_26 { }
impl ::std::clone::Clone for nsStyleContentData_nsStyleStruct_h_unnamed_26 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsStyleContentData_nsStyleStruct_h_unnamed_26() {
    assert_eq!(::std::mem::size_of::<nsStyleContentData_nsStyleStruct_h_unnamed_26>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<nsStyleContentData_nsStyleStruct_h_unnamed_26>()
               , 8usize);
}
#[test]
fn bindgen_test_layout_nsStyleContentData() {
    assert_eq!(::std::mem::size_of::<nsStyleContentData>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsStyleContentData>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleCounterData {
    pub mCounter: nsString,
    pub mValue: i32,
}
#[test]
fn bindgen_test_layout_nsStyleCounterData() {
    assert_eq!(::std::mem::size_of::<nsStyleCounterData>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsStyleCounterData>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleContent {
    pub mMarkerOffset: nsStyleCoord,
    pub mContents: *mut nsStyleContentData,
    pub mIncrements: *mut nsStyleCounterData,
    pub mResets: *mut nsStyleCounterData,
    pub mContentCount: u32,
    pub mIncrementCount: u32,
    pub mResetCount: u32,
}
#[test]
fn bindgen_test_layout_nsStyleContent() {
    assert_eq!(::std::mem::size_of::<nsStyleContent>() , 56usize);
    assert_eq!(::std::mem::align_of::<nsStyleContent>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleUIReset {
    pub mUserSelect: u8,
    pub mForceBrokenImageIcon: u8,
    pub mIMEMode: u8,
    pub mWindowDragging: u8,
    pub mWindowShadow: u8,
}
#[test]
fn bindgen_test_layout_nsStyleUIReset() {
    assert_eq!(::std::mem::size_of::<nsStyleUIReset>() , 5usize);
    assert_eq!(::std::mem::align_of::<nsStyleUIReset>() , 1usize);
}
#[repr(C)]
pub struct nsCursorImage {
    pub mHaveHotspot: bool,
    pub mHotspotX: f32,
    pub mHotspotY: f32,
    pub mImage: nsCOMPtr<imgIRequest>,
}
#[test]
fn bindgen_test_layout_nsCursorImage() {
    assert_eq!(::std::mem::size_of::<nsCursorImage>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsCursorImage>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleUserInterface {
    pub mUserInput: u8,
    pub mUserModify: u8,
    pub mUserFocus: u8,
    pub mPointerEvents: u8,
    pub mCursor: u8,
    pub mCursorArrayLength: u32,
    pub mCursorArray: *mut nsCursorImage,
}
#[test]
fn bindgen_test_layout_nsStyleUserInterface() {
    assert_eq!(::std::mem::size_of::<nsStyleUserInterface>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsStyleUserInterface>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleXUL {
    pub mBoxFlex: f32,
    pub mBoxOrdinal: u32,
    pub mBoxAlign: u8,
    pub mBoxDirection: u8,
    pub mBoxOrient: u8,
    pub mBoxPack: u8,
    pub mStretchStack: bool,
}
#[test]
fn bindgen_test_layout_nsStyleXUL() {
    assert_eq!(::std::mem::size_of::<nsStyleXUL>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsStyleXUL>() , 4usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleColumn {
    pub mColumnCount: u32,
    pub mColumnWidth: nsStyleCoord,
    pub mColumnGap: nsStyleCoord,
    pub mColumnRuleColor: nscolor,
    pub mColumnRuleStyle: u8,
    pub mColumnFill: u8,
    pub mColumnRuleColorIsForeground: bool,
    pub mColumnRuleWidth: nscoord,
    pub mTwipsPerPixel: nscoord,
}
#[test]
fn bindgen_test_layout_nsStyleColumn() {
    assert_eq!(::std::mem::size_of::<nsStyleColumn>() , 56usize);
    assert_eq!(::std::mem::align_of::<nsStyleColumn>() , 8usize);
}
extern "C" {
    #[link_name = "_ZN13nsStyleColumn15kMaxColumnCountE"]
    pub static nsStyleColumn_consts_kMaxColumnCount: ::std::os::raw::c_uint;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsStyleSVGPaintType {
    eStyleSVGPaintType_None = 1,
    eStyleSVGPaintType_Color = 2,
    eStyleSVGPaintType_Server = 3,
    eStyleSVGPaintType_ContextFill = 4,
    eStyleSVGPaintType_ContextStroke = 5,
}
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsStyleSVGOpacitySource {
    eStyleSVGOpacitySource_Normal = 0,
    eStyleSVGOpacitySource_ContextFillOpacity = 1,
    eStyleSVGOpacitySource_ContextStrokeOpacity = 2,
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleSVGPaint {
    pub mPaint: nsStyleSVGPaint_nsStyleStruct_h_unnamed_27,
    pub mType: nsStyleSVGPaintType,
    pub mFallbackColor: nscolor,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleSVGPaint_nsStyleStruct_h_unnamed_27 {
    pub mColor: __BindgenUnionField<nscolor>,
    pub mPaintServer: __BindgenUnionField<*mut nsIURI>,
    pub _bindgen_data_: u64,
}
impl nsStyleSVGPaint_nsStyleStruct_h_unnamed_27 { }
impl ::std::clone::Clone for nsStyleSVGPaint_nsStyleStruct_h_unnamed_27 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsStyleSVGPaint_nsStyleStruct_h_unnamed_27() {
    assert_eq!(::std::mem::size_of::<nsStyleSVGPaint_nsStyleStruct_h_unnamed_27>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<nsStyleSVGPaint_nsStyleStruct_h_unnamed_27>()
               , 8usize);
}
#[test]
fn bindgen_test_layout_nsStyleSVGPaint() {
    assert_eq!(::std::mem::size_of::<nsStyleSVGPaint>() , 16usize);
    assert_eq!(::std::mem::align_of::<nsStyleSVGPaint>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleSVG {
    pub mFill: nsStyleSVGPaint,
    pub mStroke: nsStyleSVGPaint,
    pub mMarkerEnd: nsCOMPtr<nsIURI>,
    pub mMarkerMid: nsCOMPtr<nsIURI>,
    pub mMarkerStart: nsCOMPtr<nsIURI>,
    pub mStrokeDasharray: nsTArray<nsStyleCoord>,
    pub mStrokeDashoffset: nsStyleCoord,
    pub mStrokeWidth: nsStyleCoord,
    pub mFillOpacity: f32,
    pub mStrokeMiterlimit: f32,
    pub mStrokeOpacity: f32,
    pub mClipRule: u8,
    pub mColorInterpolation: u8,
    pub mColorInterpolationFilters: u8,
    pub mFillRule: u8,
    pub mPaintOrder: u8,
    pub mShapeRendering: u8,
    pub mStrokeLinecap: u8,
    pub mStrokeLinejoin: u8,
    pub mTextAnchor: u8,
    pub mContextFlags: u8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsStyleSVG_nsStyleStruct_h_unnamed_28 {
    FILL_OPACITY_SOURCE_MASK = 3,
    STROKE_OPACITY_SOURCE_MASK = 12,
    STROKE_DASHARRAY_CONTEXT = 16,
    STROKE_DASHOFFSET_CONTEXT = 32,
    STROKE_WIDTH_CONTEXT = 64,
    FILL_OPACITY_SOURCE_SHIFT = 0,
    STROKE_OPACITY_SOURCE_SHIFT = 2,
}
#[test]
fn bindgen_test_layout_nsStyleSVG() {
    assert_eq!(::std::mem::size_of::<nsStyleSVG>() , 120usize);
    assert_eq!(::std::mem::align_of::<nsStyleSVG>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleBasicShape {
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    pub mType: nsStyleBasicShape_Type,
    pub mFillRule: i32,
    pub mCoordinates: nsTArray<nsStyleCoord>,
    pub mPosition: nsStyleImageLayers_Position,
    pub mRadius: nsStyleCorners,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum nsStyleBasicShape_Type {
    eInset = 0,
    eCircle = 1,
    eEllipse = 2,
    ePolygon = 3,
}
#[test]
fn bindgen_test_layout_nsStyleBasicShape() {
    assert_eq!(::std::mem::size_of::<nsStyleBasicShape>() , 128usize);
    assert_eq!(::std::mem::align_of::<nsStyleBasicShape>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleClipPath {
    pub mType: i32,
    pub nsStyleClipPath_nsStyleStruct_h_unnamed_29: nsStyleClipPath_nsStyleStruct_h_unnamed_29,
    pub mSizingBox: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleClipPath_nsStyleStruct_h_unnamed_29 {
    pub mBasicShape: __BindgenUnionField<*mut nsStyleBasicShape>,
    pub mURL: __BindgenUnionField<*mut nsIURI>,
    pub _bindgen_data_: u64,
}
impl nsStyleClipPath_nsStyleStruct_h_unnamed_29 { }
impl ::std::clone::Clone for nsStyleClipPath_nsStyleStruct_h_unnamed_29 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsStyleClipPath_nsStyleStruct_h_unnamed_29() {
    assert_eq!(::std::mem::size_of::<nsStyleClipPath_nsStyleStruct_h_unnamed_29>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<nsStyleClipPath_nsStyleStruct_h_unnamed_29>()
               , 8usize);
}
#[test]
fn bindgen_test_layout_nsStyleClipPath() {
    assert_eq!(::std::mem::size_of::<nsStyleClipPath>() , 24usize);
    assert_eq!(::std::mem::align_of::<nsStyleClipPath>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleFilter {
    pub mType: i32,
    pub mFilterParameter: nsStyleCoord,
    pub nsStyleFilter_nsStyleStruct_h_unnamed_30: nsStyleFilter_nsStyleStruct_h_unnamed_30,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nsStyleFilter_nsStyleStruct_h_unnamed_30 {
    pub mURL: __BindgenUnionField<*mut nsIURI>,
    pub mDropShadow: __BindgenUnionField<*mut nsCSSShadowArray>,
    pub _bindgen_data_: u64,
}
impl nsStyleFilter_nsStyleStruct_h_unnamed_30 { }
impl ::std::clone::Clone for nsStyleFilter_nsStyleStruct_h_unnamed_30 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_nsStyleFilter_nsStyleStruct_h_unnamed_30() {
    assert_eq!(::std::mem::size_of::<nsStyleFilter_nsStyleStruct_h_unnamed_30>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<nsStyleFilter_nsStyleStruct_h_unnamed_30>()
               , 8usize);
}
#[test]
fn bindgen_test_layout_nsStyleFilter() {
    assert_eq!(::std::mem::size_of::<nsStyleFilter>() , 32usize);
    assert_eq!(::std::mem::align_of::<nsStyleFilter>() , 8usize);
}
#[repr(C)]
pub struct nsStyleSVGReset {
    pub mMask: nsStyleImageLayers,
    pub mClipPath: nsStyleClipPath,
    pub mStopColor: nscolor,
    pub mFloodColor: nscolor,
    pub mLightingColor: nscolor,
    pub mStopOpacity: f32,
    pub mFloodOpacity: f32,
    pub mDominantBaseline: u8,
    pub mVectorEffect: u8,
    pub mMaskType: u8,
}
#[test]
fn bindgen_test_layout_nsStyleSVGReset() {
    assert_eq!(::std::mem::size_of::<nsStyleSVGReset>() , 216usize);
    assert_eq!(::std::mem::align_of::<nsStyleSVGReset>() , 8usize);
}
#[repr(C)]
pub struct nsStyleVariables {
    pub mVariables: CSSVariableValues,
}
#[test]
fn bindgen_test_layout_nsStyleVariables() {
    assert_eq!(::std::mem::size_of::<nsStyleVariables>() , 56usize);
    assert_eq!(::std::mem::align_of::<nsStyleVariables>() , 8usize);
}
#[repr(C)]
#[derive(Debug)]
pub struct nsStyleEffects {
    pub mFilters: nsTArray<nsStyleFilter>,
    pub mBoxShadow: RefPtr<nsCSSShadowArray>,
    pub mClip: nsRect,
    pub mOpacity: f32,
    pub mClipFlags: u8,
    pub mMixBlendMode: u8,
}
#[test]
fn bindgen_test_layout_nsStyleEffects() {
    assert_eq!(::std::mem::size_of::<nsStyleEffects>() , 40usize);
    assert_eq!(::std::mem::align_of::<nsStyleEffects>() , 8usize);
}
