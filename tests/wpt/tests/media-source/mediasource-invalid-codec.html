<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>SourceBuffer handling of invalid codecs in the initialization segment</title>
    <link rel="author" title="Alicia Boya GarcÃ­a" href="mailto:aboya@igalia.com">
    <script src="/resources/testharness.js"></script>
    <script src="/resources/testharnessreport.js"></script>
    <script src="mediasource-util.js"></script>
</head>
<body>
<div id="log"></div>
<script>
    function testInvalidCodec(test, mediaElement, mediaSource, mediaType, url) {
        assert_true(MediaSource.isTypeSupported(mediaType), `Media type not supported in this browser: isTypeSupported('${mediaType}')`);

        MediaSourceUtil.loadBinaryData(test, url, (mediaData) => {
            _testInvalidCodecWithData(test, mediaElement, mediaSource, mediaType, mediaData);
        });
    }

    function _testInvalidCodecWithData(test, mediaElement, mediaSource, mediaType, mediaData) {
        const sourceBuffer = mediaSource.addSourceBuffer(mediaType);
        sourceBuffer.appendBuffer(mediaData);
        test.expectEvent(sourceBuffer, 'error', 'Append ended with error');
        test.waitForExpectedEvents(() => {
            test.done();
        })
    }

    // These test cases provide a typical media MIME type, but the actual files have been mangled to declare a different,
    // unsupported, fictitious codec (MP4 fourcc: 'zzzz', WebM codec id 'V_ZZZ'). The browser should report a parsing
    // error.

    mediasource_test((test, mediaElement, mediaSource) => {
        testInvalidCodec(test, mediaElement, mediaSource, 'video/mp4;codecs="avc1.4D4001"', 'mp4/invalid-codec.mp4');
    }, 'Test an MP4 with an invalid codec results in an error.');

    mediasource_test((test, mediaElement, mediaSource) => {
        testInvalidCodec(test, mediaElement, mediaSource, 'video/webm; codecs="vp8"', 'webm/invalid-codec.webm');
    }, 'Test a WebM with an invalid codec results in an error.');

</script>
</body>
</html>
