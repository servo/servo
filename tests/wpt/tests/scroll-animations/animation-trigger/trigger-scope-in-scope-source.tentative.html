<!DOCTYPE html>
<html>
  <head>
    <link rel="help" src="https://drafts.csswg.org/css-animations-2/#trigger-scope">
    <script src="/resources/testharness.js"></script>
    <script src="/resources/testharnessreport.js"></script>
    <script src="/web-animations/testcommon.js"></script>
    <script src="/dom/events/scrolling/scroll_support.js"></script>
    <script src="support/support.js"></script>
    <script src="support/trigger-scope-support.js"></script>
  </head>
  <body>
    <style>
      @keyframes expand {
        from { transform: scaleX(1) }
        to { transform: scaleX(2) }
      }
      #scroller {
        overflow-y: scroll;
        height: 200px;
        width: 200px;
        border: solid 1px;
        trigger-scope: all;
        display: block;
      }
      #source {
        top: 100%;
        height: 100px;
        width: 100px;
        background-color: blue;
        timeline-trigger: --trigger view() contain;
      }
      .target {
        background-color: red;
        height: 100px;
        width: 100px;
        animation: expand linear 1s both;
        animation-trigger: --trigger play-forwards play-backwards;
      }

      #in_scope_target {
        /* Let's it be in view when the trigger source comes into view */
        margin-top: 50%;
      }
      .long {
        width: 50%;
        height: 100%;
      }
    </style>
      <div id="scroller">
        <div id="in_scope_target" class="target">In-scope Target</div>
        <div id="source">SOURCE</div>
        <div class="long"></div>
        <div class="long"></div>
      </div>
      <div id="out_of_scope_target" class="target">
        Out-of-scope Target
      </div>

    <script>
      promise_test(async() => {
        const in_scope_target = document.getElementById("in_scope_target");
        // The in-scope target should be attached to the trigger and paused at
        // time 0.
        await assert_playstate_and_current_time(in_scope_target.id,
                                          in_scope_target.getAnimations()[0],
                                          "paused");

        // The out-of-scope target should be paused at time 0, waiting for its
        // trigger.
        await assert_playstate_and_current_time(out_of_scope_target.id,
                                          out_of_scope_target.getAnimations()[0],
                                          "paused");

        // Perform a scroll that triggers the animation.
        const scrollend_promise =
            waitForScrollEndFallbackToDelayWithoutScrollEvent(scroller);
        source.scrollIntoView({block: "center"});
        await scrollend_promise;
        await waitForCompositorReady();

        assert_greater_than(scroller.scrollTop, 0, "did scroll");

        // The in-scope target should now be playing as the trigger condition
        // has been met.
        await assert_playstate_and_current_time(in_scope_target.id,
                                          in_scope_target.getAnimations()[0],
                                          "running");

        // There should be no change to the out-of-scope target.
        await assert_playstate_and_current_time(out_of_scope_target.id,
                                          out_of_scope_target.getAnimations()[0],
                                          "paused");
      }, "In-scope target finds trigger of source; out-of-scope " +
         "target does not.");
    </script>
  </body>
</html>
