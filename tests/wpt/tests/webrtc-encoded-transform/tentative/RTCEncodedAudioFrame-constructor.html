<!doctype html>
<meta charset=utf-8>
<title>Timestamps in RTCEncodedFrame metadata</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/webrtc/RTCPeerConnection-helper.js"></script>
<script src="RTCEncodedFrame-timestamps-helper.js"></script>
<script>
'use strict';

function doWork() {
  onrtctransform = async e => {
    const reader = e.transformer.readable.getReader();
    const writer = e.transformer.writable.getWriter();
    for (let i = 0; i<10; i++) {
      const frameOrDone = await reader.read();
      if (frameOrDone.done) {
        self.postMessage("Unexpected end of stream");
        return;
      }
      const originalFrame = frameOrDone.value;
      const originalMetadata= originalFrame.getMetadata();
      const newFrame = new RTCEncodedAudioFrame(originalFrame, {metadata: originalMetadata});
      await writer.write(newFrame);
    }
    self.postMessage("OK");
  };
}

async function testAudioFrameConstructor(t, enableAbsCaptureTime, enableForSenderFrames) {
  const worker = new Worker(`data:text/javascript,(${doWork.toString()})()`);
  const workerPromise = new Promise((resolve, reject) => {
    worker.onmessage = t.step_func(message => {
      if (message.data == "OK") {
        resolve();
      } else {
        reject(message.data);
      }
    });
  });

  await initiateCall(
      t, /*streamOptions=*/{audio: true, video: false},
      /*enableAbsCaptureTime=*/enableAbsCaptureTime, worker, /*enableSenderTransform=*/enableForSenderFrames,
      /*enableReceiverTransform=*/!enableForSenderFrames);

  return workerPromise;
}

promise_test(async t => {
  return testAudioFrameConstructor(t, /*enableAbsCaptureTime=*/false, /*enableForSenderFrames=*/false)
}, 'Constructing a new receiver audio frame explicitly using metadata from a previous frame works');

promise_test(async t => {
  return testAudioFrameConstructor(t, /*enableAbsCaptureTime=*/false, /*enableForSenderFrames=*/true)
}, 'Constructing a new sender audio frame explicitly using metadata from a previous frame works');

promise_test(async t => {
  return testAudioFrameConstructor(t, /*enableAbsCaptureTime=*/true, /*enableForSenderFrames=*/false)
}, 'Constructing a new receiver audio frame explicitly using metadata from a previous frame works, absCaptureTime extension enabled');

promise_test(async t => {
  return testAudioFrameConstructor(t, /*enableAbsCaptureTime=*/true, /*enableForSenderFrames=*/true)
}, 'Constructing a new sender audio frame explicitly using metadata from a previous frame works, absCaptureTime extension enabled');

</script>
