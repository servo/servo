<!DOCTYPE html>
<html>
<head>
  <title>Test ScriptProcessorNode</title>
  <script src="/resources/testharness.js"></script>
  <script src="/resources/testharnessreport.js"></script>
  <script src="/webaudio/resources/audit-util.js"></script>
</head>
<body>
  <script>
    // Arbitrary sample rate
    const sampleRate = 48000;

    promise_test(async (t) => {
      // Two channels for testing.  Channel 0 is the output of the
      // scriptProcessor.  Channel 1 is the oscillator so we can compare
      // the outputs.
      const context = new OfflineAudioContext({
        numberOfChannels: 2,
        length: sampleRate,
        sampleRate: sampleRate});

      const merger = new ChannelMergerNode(
          context, {numberOfChannels: context.destination.channelCount});
      merger.connect(context.destination);

      const src = new OscillatorNode(context);

      // Arbitrary buffer size for the ScriptProcessorNode.  Don't use 0;
      // we need to know the actual size to know the latency of the node
      // (easily).
      const spnSize = 512;
      const spn = context.createScriptProcessor(spnSize, 1, 1);

      // Arrange for the ScriptProcessor to add |offset| to the input.
      const offset = 1;
      spn.onaudioprocess = (event) => {
        const input = event.inputBuffer.getChannelData(0);
        const output = event.outputBuffer.getChannelData(0);
        for (let k = 0; k < output.length; ++k) {
          output[k] = input[k] + offset;
        }
      };

      src.connect(spn).connect(merger, 0, 0);
      src.connect(merger, 0, 1);

      // Start and stop the source.  The stop time is fairly arbitrary,
      // but use a render quantum boundary for simplicity.
      const stopFrame = RENDER_QUANTUM_FRAMES;
      src.start();
      src.stop(stopFrame / context.sampleRate);

      const buffer = await context.startRendering();
      const ch0 = buffer.getChannelData(0);
      const ch1 = buffer.getChannelData(1);

      const shifted = ch1.slice(0, stopFrame).map((x) => x + offset);

      // SPN has a basic latency of 2*|spnSize| fraems, so the
      // beginning is silent.
      assert_array_equals(
          ch0.slice(0, 2 * spnSize - 1),
          new Float32Array(2 * spnSize - 1),
          `ScriptProcessor output[0:${2 * spnSize - 1}]`);

      // For the middle section (after adding latency), the output
      // should be the source shifted by |offset|.
      assert_array_equals(
          ch0.slice(2 * spnSize, 2 * spnSize + stopFrame),
          new Float32Array(shifted),
          `ScriptProcessor output[${2 * spnSize}:` +
              `${2 * spnSize + stopFrame - 1}]`);

      // Output should be constant after the source has stopped.
      // Include the latency introduced by the node.
      assert_array_equals(
        ch0.slice(2 * spnSize + stopFrame),
        new Float32Array(ch0.length - (2 * spnSize + stopFrame)).fill(offset),
        `ScriptProcessor output[${2 * spnSize + stopFrame}:]`);
    }, 'ScriptProcessor with stopped input source');
  </script>
</body>
</html>
