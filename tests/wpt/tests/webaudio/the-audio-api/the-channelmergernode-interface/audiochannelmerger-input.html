<!DOCTYPE html>
<html>
  <head>
    <title>audiochannelmerger-input.html</title>
    <script src="/resources/testharness.js"></script>
    <script src="/resources/testharnessreport.js"></script>
    <script src="/webaudio/resources/audit-util.js"></script>
    <script src="/webaudio/resources/merger-testing.js"></script>
  </head>
  <body>
    <script>
      promise_test((t) => {
        // Task: Check if an inactive input renders a silent mono channel in the
        // output.
        return testMergerInput_W3CTH({
          numberOfChannels: 6,

          // Create a mono source buffer filled with '1'.
          testBufferContent: [1],

          // Connect the output of source into the 4th input of merger.
          mergerInputIndex: 3,

          // All channels should contain 0, except channel 4 which should be 1.
          expected: [0, 0, 0, 1, 0, 0],
        });
      }, 'Silent inactive inputs produce 0 in unused merger channels');

      promise_test((t) => {
        // Task: Check if a stereo input is being down-mixed to mono channel
        // correctly based on the mixing rule.
        return testMergerInput_W3CTH({
          numberOfChannels: 6,

          // Create a stereo buffer filled with '1' and '2' for left and right
          // channels respectively.
          testBufferContent: [1, 2],

          // Connect the output of source into the 1st input of merger.
          mergerInputIndex: undefined,

          // The result of summed and down-mixed stereo audio should be 1.5.
          // (= 1 * 0.5 + 2 * 0.5)
          expected: [1.5, 0, 0, 0, 0, 0],
        });
      }, 'Stereo input should down-mix properly to mono merger input');

      promise_test((t) => {
        // Task: Check if 3-channel input gets processed by the 'discrete'
        // mixing rule.
        return testMergerInput_W3CTH({
          numberOfChannels: 6,

          // Create a 3-channel buffer filled with '1', '2', and '3'
          // respectively.
          testBufferContent: [1, 2, 3],

          // Connect the output of source into the 1st input of merger.
          mergerInputIndex: undefined,

          // The result of summed stereo audio should be 1 because 3-channel is
          // not a canonical layout, so the input channel 2 and 3 should be
          // dropped by 'discrete' mixing rule.
          expected: [1, 0, 0, 0, 0, 0],
        });
      }, '3-channel input uses discrete rule, dropping 2nd and 3rd channels');

      promise_test((t) => {
        // Task: Merging two inputs into a single stereo stream.

        // For this test, the number of channel should be 2.
        const context = new OfflineAudioContext(2, 128, 44100);
        const merger = context.createChannelMerger();
        const source1 = context.createBufferSource();
        const source2 = context.createBufferSource();

        // Create a DC offset buffer (mono) filled with 1 and assign it to BS
        // nodes.
        const positiveDCOffset = createConstantBuffer(context, 128, 1);
        const negativeDCOffset = createConstantBuffer(context, 128, -1);
        source1.buffer = positiveDCOffset;
        source2.buffer = negativeDCOffset;

        // Connect: BS#1 => merger_input#0, BS#2 => Inverter => merger_input#1
        source1.connect(merger, 0, 0);
        source2.connect(merger, 0, 1);
        merger.connect(context.destination);
        source1.start();
        source2.start();

        return context.startRendering().then((buffer) => {
          assert_array_equals(
              buffer.getChannelData(0),
              new Float32Array(128).fill(1),
              'Channel #0 should be constant value of 1');
          assert_array_equals(
              buffer.getChannelData(1),
              new Float32Array(128).fill(-1),
              'Channel #1 should be constant value of -1');
        });
      }, 'Merging two mono sources into stereo using ChannelMerger');
    </script>
  </body>
</html>
