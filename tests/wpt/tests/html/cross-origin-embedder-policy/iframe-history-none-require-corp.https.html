<meta name="timeout" content="long">
<script src=/resources/testharness.js></script>
<script src=/resources/testharnessreport.js></script>
<script src=/common/utils.js></script
<script src="/common/get-host-info.sub.js"></script>
<script>

promise_test(async test => {
  // TODO(arthursonzogni): Consider switching toward another message passing
  // API like:
  // /common/dispatcher/dispatcher.js
  const bc = new BroadcastChannel(token());
  const futureMessage = () => {
    return new Promise(resolve => {
      bc.onmessage = event => resolve(event.data);
    });
  };

  const prefix = document.URL.substr(0, document.URL.lastIndexOf('/'))
  const attribute = `?channelName=${bc.name}`;
  const url_coep_none =
    prefix + "/resources/navigate-none.sub.html" + attribute;
  const url_coep_require_corp =
    prefix + "/resources/navigate-require-corp.sub.html" + attribute;

  const w = window.open();
  test.add_cleanup(() => w.close());

  // Navigate to COEP:unsafe-none.
  w.location.href = url_coep_none;
  assert_equals(await futureMessage(), "loaded");
  assert_equals(w.location.href, url_coep_none);

  // For unknown reasons so far. Waiting in between the different navigations
  // avoids flakes.
  await new Promise(resolve => test.step_timeout(resolve, 1000));

  // Navigate to COEP:require-corp.
  w.location.href = url_coep_require_corp;
  assert_equals(await futureMessage(), "loaded");
  assert_equals(w.location.href, url_coep_require_corp);

  // For unknown reasons so far. Waiting in between the different navigations
  // avoids flakes.
  await new Promise(resolve => test.step_timeout(resolve, 1000));

  // Navigate back to COEP:unsafe-none, using the history API.
  // Note: `url_coep_none` already take the BFCache into account.
  w.history.back();
  assert_equals(await futureMessage(), "loaded");
  assert_equals(w.location.href, url_coep_none);
}, `"none" top-level: navigating a frame back from "require-corp" should succeed`);

</script>
