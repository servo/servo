<!DOCTYPE html>
<!-- DO NOT EDIT! This test has been generated by /html/canvas/tools/gentest.py. -->
<title>OffscreenCanvas test: 2d.text.measure.selection-rects.tentative</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/html/canvas/resources/canvas-tests.js"></script>

<h1>2d.text.measure.selection-rects.tentative</h1>
<p class="desc">Check that TextMetrics::getSelectionRects() matches its DOM equivalent.</p>


<script>
var t = async_test("Check that TextMetrics::getSelectionRects() matches its DOM equivalent.");
var t_pass = t.done.bind(t);
var t_fail = t.step_func(function(reason) {
    throw reason;
});
t.step(function() {

  var canvas = new OffscreenCanvas(100, 50);
  var ctx = canvas.getContext('2d');

  function placeAndSelectTextInDOM(text, from, to) {
    const el = document.createElement("div");
    el.innerHTML = text;
    el.style.font = '50px sans-serif';
    document.body.appendChild(el);

    let range = document.createRange();

    range.setStart(el.childNodes[0], 0);
    range.setEnd(el.childNodes[0], text.length);
    const parent = range.getClientRects()[0];

    range.setStart(el.childNodes[0], from);
    range.setEnd(el.childNodes[0], to);

    let sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);

    let sel_rects = sel.getRangeAt(0).getClientRects();

    document.body.removeChild(el);

    for(let i = 0 ; i < sel_rects.length ; ++i) {
      sel_rects[i].x -= parent.x;
      sel_rects[i].y -= parent.y;
    }

    return sel_rects;
  }

  function checkRectListsMatch(list_a, list_b) {
    _assertSame(list_a.length, list_b.length, "list_a.length", "list_b.length");
    for(let i = 0 ; i < list_a.length ; ++i) {
      assert_approx_equals(list_a[i].x, list_b[i].x, 1.0);
      assert_approx_equals(list_a[i].width, list_b[i].width, 1.0);
      assert_approx_equals(list_a[i].height, list_b[i].height, 1.0);
      // Y-position not tested here as getting the baseline for text in the
      // DOM is not straightforward.
    }
  }

  ctx.font = '50px sans-serif';

  const kTexts = [
    'UNAVAILABLE',
    '🏁🎶🏁',
    '）（あ）（'
  ]

  for (const text of kTexts) {
    const tm = ctx.measureText(text);
    // First character.
    checkRectListsMatch(
      tm.getSelectionRects(0, 1),
      placeAndSelectTextInDOM(text, 0, 1)
    );
    // Last character.
    checkRectListsMatch(
      tm.getSelectionRects(text.length - 1, text.length),
      placeAndSelectTextInDOM(text, text.length - 1, text.length)
    );
    // Whole string.
    checkRectListsMatch(
      tm.getSelectionRects(0, text.length),
      placeAndSelectTextInDOM(text, 0, text.length)
    );
    // Intermediate string.
    checkRectListsMatch(
      tm.getSelectionRects(1, text.length - 1),
      placeAndSelectTextInDOM(text, 1, text.length - 1)
    );
    // Invalid start > end string. Creates 0 width rectangle.
    checkRectListsMatch(
      tm.getSelectionRects(3, 2),
      placeAndSelectTextInDOM(text, 3, 2)
    );
    checkRectListsMatch(
      tm.getSelectionRects(1, 0),
      placeAndSelectTextInDOM(text, 1, 0)
    );
  }
  t.done();

});
</script>
