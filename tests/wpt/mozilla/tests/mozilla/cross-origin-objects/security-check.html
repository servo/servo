<!doctype html>
<meta charset=utf-8>
<title>Cross-origin security check</title>
<link rel="help" href="https://html.spec.whatwg.org/multipage/#integration-with-idl">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/common/get-host-info.sub.js"></script>
<div id=log></div>
<iframe id="F1"></iframe>
<iframe id="F2"></iframe>
<iframe id="F3"></iframe>
<script>

/*
 * Setup boilerplate. This gives us
 *
 *  - a same-origin window "F0"
 *  - a cross-origin window "F1",
 *  - an initially same-origin but then changing document.domain window "F2",
 *  - and a not-same-site (also cross-origin, of course) window "F3".
 */
const host_info = get_host_info();

path = location.pathname.substring(0, location.pathname.lastIndexOf('/')) + '/support/frame.html';
const F0 = {
  contentWindow: window,
  contentDocument: document,
  leakedDocument: document,
};
const F1 = document.getElementById('F1');
const F2 = document.getElementById('F2');
const F3 = document.getElementById('F3');
F1.src = host_info.HTTP_REMOTE_ORIGIN + path;
F2.src = path;
F3.src = host_info.HTTP_NOTSAMESITE_ORIGIN + path;

const waitWindowLoad = new Promise(r => window.addEventListener('load', r));
const frames = [
  [F0, '`this` is same-origin'],
  [F1, '`this` is cross-origin'],
  [F2, '`this` is same-origin + document.domain'],
  [F3, '`this` is cross-site'],
];

function define_test_for_each_case(testBuilder, desc) {
  let numApplicableFrames = 0;

  for (let [frame, frameDesc] of frames) {
    // Get the test function from `func`
    const testFunc = testBuilder(frame);
    if (testFunc) {
      promise_test(async t => {
        await waitWindowLoad;
        testFunc(t);
      }, `${frameDesc}, ${desc}`);
      numApplicableFrames++;
    }
  }

  // It must run at least in one frame
  if (numApplicableFrames === 0) {
    throw new Error();
  }
}

const interfaces = [
  ['windowProxy', windowProxy => windowProxy, ['close', 'frames'], 'open'],
  ['windowProxy.location', windowProxy => windowProxy.location, ['href', 'replace'], 'hash'],
];

promise_test(async t => {
  await waitWindowLoad;
  assert_not_equals(F0.contentDocument, null, "F0's document can be accessed")
  F0.leakedDocument = F0.contentDocument;
}, "F0's `Document` is accessible")

promise_test(async t => {
  await waitWindowLoad;
  assert_not_equals(F2.contentDocument, null, "F2's document can be accessed")
  F2.leakedDocument = F2.contentDocument;
  F2.contentDocument.domain = F2.contentDocument.domain;

  // On WebKit, the change of `domain` doesn't take effect immediately
  await new Promise(r => setTimeout(r, 500));

  assert_equals(F2.contentDocument, null, "F2's document can't be accessed anymore")
}, "Make F2 cross-origin, leaking its `Document`")

const getGetter = (obj, name) => Object.getOwnPropertyDescriptor(obj, name)
  ? Object.getOwnPropertyDescriptor(obj, name).get
  : getGetter(obj.__proto__, name);
const getSetter = (obj, name) => Object.getOwnPropertyDescriptor(obj, name)
  ? Object.getOwnPropertyDescriptor(obj, name).set
  : getSetter(obj.__proto__, name);

for (let bits = 0; bits < 16; ++bits) {
  // The current principals object subsumes that of `this`
  const thisSameOrigin = (bits & 1) !== 0;
  // `this`'s class provides a cross-origin member
  const thisClassCrossOrigin = (bits & 2) !== 0;
  // The tuple `(operation_name, operation_type)` (e.g., `("focus", "method")`)
  // is a member of `CrossOriginProperties(this)`
  const crossOriginOperation = (bits & 4) !== 0;
  // `this`'s class implements the current operation.
  const thisImplementsOperation = (bits & 8) !== 0;

  let testName = [
    // `thisSameOrigin`'s description is generated by `define_test_for_each_case`
    thisClassCrossOrigin ? "`this`'s class is cross-origin" : "`this`'s class is not cross-origin",
    crossOriginOperation
      ? "`this` provides a cross-origin callable operation of that name"
      : "`this` doesn't provide a cross-origin callable operation of that name",
    thisImplementsOperation ? "`this` implements the operation" : "`this` doesn't implement the operation",
  ].join(', ');

  // Create a list of operations that match the above criteria. Note that the
  // IDL operation functions retrieved here all belong to the current Realm.
  let operations;
  if (thisClassCrossOrigin) {
    if (crossOriginOperation) {
      if (thisImplementsOperation) {
        operations = [
          ['Window', 'Window#postMessage', o => window.postMessage.call(o, "hello", "*")],
          // `Location` doesn't have a non-sideeffectful cross-origin operation
        ];
      } else {
        operations = [
          // `Window` does have a cross-origin method named `close`
          ['Window', 'Document#close', o => document.close.call(o)],
          // `Window` does have a cross-origin getter named `length`
          ['Window', 'HTMLCollection#length', o => getGetter(HTMLCollection.prototype, 'length').call(o)],
          // `Location` does have a cross-origin setter named `href`
          ['Location', 'HTMLLinkElement#href', o => getSetter(HTMLLinkElement.prototype, 'href').call(o, 'hi')],
        ];
      }
    } else {
      if (thisImplementsOperation) {
        operations = [
          ['Window', 'Window#stop', o => window.stop.call(o)],
          ['Location', 'get Location#href', o => getGetter(location, 'href').call(o)],
        ];
      } else {
        operations = [
          // `Window` doesn't have a method named `replace`
          ['Window', 'Location#replace', o => location.replace.call(o)],
          // `Window` doesn't have a getter named `port`
          ['Window', 'Location#port', o => getGetter(location, 'port').call(o)],
          // `Location` doesn't have a cross-origin getter named `length`
          ['Location', 'HTMLCollection#length', o => getGetter(HTMLCollection.prototype, 'length').call(o)],
          // `Location` doesn't have a cross-origin getter named `href`
          ['Location', 'HTMLLinkElement#href', o => getGetter(HTMLLinkElement.prototype, 'href').call(o)],
        ];
      }
    }
  } else {
    if (crossOriginOperation) {
      // `Document` exposes no cross-origin operations
      continue;
    } else {
      if (thisImplementsOperation) {
        operations = [
          ['Document', 'Document#hasFocus', o => document.hasFocus.call(o)],
          ['Document', 'get Document#referrer', o => getGetter(document, 'referrer').call(o)],
        ];
      } else {
        operations = [
          ['Document', 'Window#open', o => window.open.call(o)],
          ['Document', 'get ImageData#height', o => getGetter(ImageData.prototype, 'height').call(o)],
        ];
      }
    }
  }

  // For each frame...
  define_test_for_each_case(frame => {
    const isFrameSameOrigin = frame === F0;

    if (thisSameOrigin !== isFrameSameOrigin) {
      // Not applicable for this frame
      return null;
    }

    // Enumerate the operations that are applicable to this frame
    const tests = operations
      .map(([targetName, operationName, operator]) => {
        let targetGetter;
        // This is not inside a test function - `frame` is not fully loaded yet at this point,
        // so don't access its objects yet
        switch (targetName) {
          case 'Window':
            targetGetter = () => frame.contentWindow;
            break;
          case 'Location':
            targetGetter = () => frame.contentWindow.location;
            break;
          case 'Document':
            targetGetter = () => frame.leakedDocument;
            if (frame !== F0 && frame !== F2) {
              // This frame doesn't leak its `Document` object
              return null;
            }
            break;
          default:
            assert_unreached();
        }

        const desc = `Calling ${operationName} on a ${targetName} object`;
        const boundOperator = () => operator(targetGetter());

        return t => {
          // This closure is called inside a test function, meaning `frame` is fully loaded.
          if (!thisSameOrigin && thisClassCrossOrigin && !crossOriginOperation) {
            // The security check should fail
            // <https://html.spec.whatwg.org/multipage/#integration-with-idl>
            assert_throws_dom('SecurityError', boundOperator, desc + ' should throw SecurityError');
          } else if (!thisImplementsOperation) {
            // The interface check in the IDL operation function should fail
            // <<https://heycam.github.io/webidl/#es-operations>>
            assert_throws_js(TypeError, boundOperator, desc + ' should throw TypeError');
          } else {
            boundOperator();
          }
        };
      })
      .filter(x => x);

    if (test.length === 0) {
      // No runnable test cases
      return null;
    }

    // There are runnable test cases for this frame
    return t => {
      for (const test of tests) {
        test(t);
      }
    };
  }, testName);
}

</script>
