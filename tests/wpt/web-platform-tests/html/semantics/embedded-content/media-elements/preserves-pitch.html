<!DOCTYPE html>
<title>Test preservesPitch.</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/resources/testdriver.js"></script>
<script src="/resources/testdriver-vendor.js"></script>
<script src="pitch-detector.js"></script>
<script>

// Remove when media-elements/historical.html's preservePitch prefix tests are are passing.
function getPreservesPitch(audio) {
    if ("preservesPitch" in HTMLAudioElement.prototype) {
        return audio.preservesPitch;
    }
    if ("mozPreservesPitch" in HTMLAudioElement.prototype) {
        return audio.mozPreservesPitch;
    }
    if ("wekbitPreservesPitch" in HTMLAudioElement.prototype) {
        return audio.wekbitPreservesPitch;
    }
    return undefined;
}

// Remove when media-elements/historical.html's preservePitch prefix tests are are passing.
function setPreservesPitch(audio, value) {
    if ("preservesPitch" in HTMLAudioElement.prototype) {
        audio.preservesPitch = value;
    } else if ("mozPreservesPitch" in HTMLAudioElement.prototype) {
        audio.mozPreservesPitch = value;
    } else if ("wekbitPreservesPitch" in HTMLAudioElement.prototype) {
        audio.wekbitPreservesPitch = value;
    }
}

test(function(t) {
    assert_true("preservesPitch" in HTMLAudioElement.prototype);
}, "Test that preservesPitch is present and unprefixed.");

test(function(t) {
    let audio = document.createElement('audio');
    assert_true(getPreservesPitch(audio));

    setPreservesPitch(audio, false);
    assert_false(getPreservesPitch(audio));
}, "Test that presevesPitch is on by default");

function testPreservesPitch(preservesPitch, playbackRate, expectedPitch, description) {
    promise_test(async t => {
        let audio = document.createElement('audio');

        var detector = getPitchDetector(audio, t);

        // This file contains 5 seconds of a 440hz sine wave.
        audio.src = "/media/sine440.mp3";

        audio.playbackRate = playbackRate;
        setPreservesPitch(audio, preservesPitch);

        function waitUntil(time) {
            return new Promise((resolve) => {
                audio.ontimeupdate = () => {
                    if (audio.currentTime >= time) {
                        resolve();
                    }
                };
            });
        }

        await test_driver.bless("Play audio element", () => audio.play() )

        // Wait until we have at least played some audio. Otherwise, the
        // detector might return a pitch of 0Hz.
        await waitUntil(0.5);

        var pitch = detector();

        // 25Hz is larger than the margin we get from 48kHz and 44.1kHz
        // audio being analyzed by a FFT of size 2048. If we get something
        // different, there is an error within the test's calculations (or
        // we might be dealing a larger sample rate).
        assert_less_than(pitch.margin, 25,
            "Test error: the margin should be reasonably small.")

        assert_approx_equals(pitch.value, expectedPitch, pitch.margin,
            "The actual pitch should be close to the expected pitch.");

    }, description);
}

var REFERENCE_PITCH = 440;

testPreservesPitch(true, 1.0, REFERENCE_PITCH,
    "The default playbackRate should not affect pitch")

testPreservesPitch(false, 1.0, REFERENCE_PITCH,
    "The default playbackRate should not affect pitch, even with preservesPitch=false")

testPreservesPitch(true, 2.0, REFERENCE_PITCH,
    "Speed-ups should not change the pitch when preservesPitch=true")

testPreservesPitch(true, 0.5, REFERENCE_PITCH,
    "Slow-downs should not change the pitch when preservesPitch=true")

testPreservesPitch(false, 2.0, REFERENCE_PITCH*2.0,
    "Speed-ups should change the pitch when preservesPitch=false")

testPreservesPitch(false, 0.5, REFERENCE_PITCH*0.5,
    "Slow-downs should change the pitch when preservesPitch=false")

</script>
