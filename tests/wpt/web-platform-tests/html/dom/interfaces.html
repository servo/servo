<!doctype html>
<meta charset=utf-8>
<!-- WARNING: These tests are preliminary and probably partly incorrect.  -->
<title>HTML IDL tests</title>
<meta name=timeout content=long>
<script src=/resources/testharness.js></script>
<script src=/resources/testharnessreport.js></script>
<script src=/resources/WebIDLParser.js></script>
<script src=/resources/idlharness.js></script>

<h1>HTML IDL tests</h1>
<div id=log></div>

<script type=text/plain class=untested>
[Constructor(DOMString type, optional EventInit eventInitDict)/*,
 Exposed=(Window,Worker)*/]
interface Event {
  readonly attribute DOMString type;
  readonly attribute EventTarget? target;
  readonly attribute EventTarget? currentTarget;

  const unsigned short NONE = 0;
  const unsigned short CAPTURING_PHASE = 1;
  const unsigned short AT_TARGET = 2;
  const unsigned short BUBBLING_PHASE = 3;
  readonly attribute unsigned short eventPhase;

  void stopPropagation();
  void stopImmediatePropagation();

  readonly attribute boolean bubbles;
  readonly attribute boolean cancelable;
  void preventDefault();
  readonly attribute boolean defaultPrevented;

  [Unforgeable] readonly attribute boolean isTrusted;
  readonly attribute DOMTimeStamp timeStamp;

  void initEvent(DOMString type, boolean bubbles, boolean cancelable);
};

dictionary EventInit {
  boolean bubbles = false;
  boolean cancelable = false;
};

[Constructor(DOMString type, optional CustomEventInit eventInitDict)/*,
 Exposed=(Window,Worker)*/]
interface CustomEvent : Event {
  readonly attribute any detail;

  void initCustomEvent(DOMString type, boolean bubbles, boolean cancelable, any detail);
};

dictionary CustomEventInit : EventInit {
  any detail = null;
};

//[Exposed=(Window,Worker)]
interface EventTarget {
  void addEventListener(DOMString type, EventListener? callback, optional boolean capture = false);
  void removeEventListener(DOMString type, EventListener? callback, optional boolean capture = false);
  boolean dispatchEvent(Event event);
};

callback interface EventListener {
  void handleEvent(Event event);
};

[NoInterfaceObject]
interface NonElementParentNode {
  Element? getElementById(DOMString elementId);
};
Document implements NonElementParentNode;
DocumentFragment implements NonElementParentNode;

[NoInterfaceObject]
interface ParentNode {
  [SameObject] readonly attribute HTMLCollection children;
  readonly attribute Element? firstElementChild;
  readonly attribute Element? lastElementChild;
  readonly attribute unsigned long childElementCount;

  [Unscopable] void prepend((Node or DOMString)... nodes);
  [Unscopable] void append((Node or DOMString)... nodes);

  Element? querySelector(DOMString selectors);
  [NewObject] NodeList querySelectorAll(DOMString selectors);
};
Document implements ParentNode;
DocumentFragment implements ParentNode;
Element implements ParentNode;

[NoInterfaceObject]
interface NonDocumentTypeChildNode {
  readonly attribute Element? previousElementSibling;
  readonly attribute Element? nextElementSibling;
};
Element implements NonDocumentTypeChildNode;
CharacterData implements NonDocumentTypeChildNode;

[NoInterfaceObject]
interface ChildNode {
  [Unscopable] void before((Node or DOMString)... nodes);
  [Unscopable] void after((Node or DOMString)... nodes);
  [Unscopable] void replaceWith((Node or DOMString)... nodes);
  [Unscopable] void remove();
};
DocumentType implements ChildNode;
Element implements ChildNode;
CharacterData implements ChildNode;

// XXX unrecognized tokens "class", "extends"
// https://www.w3.org/Bugs/Public/show_bug.cgi?id=20020
// https://www.w3.org/Bugs/Public/show_bug.cgi?id=23225
//class Elements extends Array {
//  Element? query(DOMString relativeSelectors);
//  Elements queryAll(DOMString relativeSelectors);
//};

interface NodeList {
  getter Node? item(unsigned long index);
  readonly attribute unsigned long length;
//  iterable<Node>;
};

interface HTMLCollection {
  readonly attribute unsigned long length;
  getter Element? item(unsigned long index);
  getter Element? namedItem(DOMString name);
};

[Constructor(MutationCallback callback)]
interface MutationObserver {
  void observe(Node target, MutationObserverInit options);
  void disconnect();
  sequence<MutationRecord> takeRecords();
};

callback MutationCallback = void (sequence<MutationRecord> mutations, MutationObserver observer);

dictionary MutationObserverInit {
  boolean childList = false;
  boolean attributes;
  boolean characterData;
  boolean subtree = false;
  boolean attributeOldValue;
  boolean characterDataOldValue;
  sequence<DOMString> attributeFilter;
};

interface MutationRecord {
  readonly attribute DOMString type;
  readonly attribute Node target;
  [SameObject] readonly attribute NodeList addedNodes;
  [SameObject] readonly attribute NodeList removedNodes;
  readonly attribute Node? previousSibling;
  readonly attribute Node? nextSibling;
  readonly attribute DOMString? attributeName;
  readonly attribute DOMString? attributeNamespace;
  readonly attribute DOMString? oldValue;
};

interface Node : EventTarget {
  const unsigned short ELEMENT_NODE = 1;
  const unsigned short ATTRIBUTE_NODE = 2; // historical
  const unsigned short TEXT_NODE = 3;
  const unsigned short CDATA_SECTION_NODE = 4;
  const unsigned short ENTITY_REFERENCE_NODE = 5; // historical
  const unsigned short ENTITY_NODE = 6; // historical
  const unsigned short PROCESSING_INSTRUCTION_NODE = 7;
  const unsigned short COMMENT_NODE = 8;
  const unsigned short DOCUMENT_NODE = 9;
  const unsigned short DOCUMENT_TYPE_NODE = 10;
  const unsigned short DOCUMENT_FRAGMENT_NODE = 11;
  const unsigned short NOTATION_NODE = 12; // historical
  readonly attribute unsigned short nodeType;
  readonly attribute DOMString nodeName;

  readonly attribute DOMString? baseURI;

  readonly attribute Document? ownerDocument;
  readonly attribute Node? parentNode;
  readonly attribute Element? parentElement;
  boolean hasChildNodes();
  [SameObject] readonly attribute NodeList childNodes;
  readonly attribute Node? firstChild;
  readonly attribute Node? lastChild;
  readonly attribute Node? previousSibling;
  readonly attribute Node? nextSibling;

           attribute DOMString? nodeValue;
           attribute DOMString? textContent;
  void normalize();

  [NewObject] Node cloneNode(optional boolean deep = false);
  boolean isEqualNode(Node? node);

  const unsigned short DOCUMENT_POSITION_DISCONNECTED = 0x01;
  const unsigned short DOCUMENT_POSITION_PRECEDING = 0x02;
  const unsigned short DOCUMENT_POSITION_FOLLOWING = 0x04;
  const unsigned short DOCUMENT_POSITION_CONTAINS = 0x08;
  const unsigned short DOCUMENT_POSITION_CONTAINED_BY = 0x10;
  const unsigned short DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
  unsigned short compareDocumentPosition(Node other);
  boolean contains(Node? other);

  DOMString? lookupPrefix(DOMString? namespace);
  DOMString? lookupNamespaceURI(DOMString? prefix);
  boolean isDefaultNamespace(DOMString? namespace);

  Node insertBefore(Node node, Node? child);
  Node appendChild(Node node);
  Node replaceChild(Node node, Node child);
  Node removeChild(Node child);
};

[Constructor]
interface Document : Node {
  [SameObject] readonly attribute DOMImplementation implementation;
  readonly attribute DOMString URL;
  readonly attribute DOMString documentURI;
  readonly attribute DOMString origin;
  readonly attribute DOMString compatMode;
  readonly attribute DOMString characterSet;
  readonly attribute DOMString charset; // legacy alias of .characterSet
  readonly attribute DOMString inputEncoding; // legacy alias of .characterSet
  readonly attribute DOMString contentType;

  readonly attribute DocumentType? doctype;
  readonly attribute Element? documentElement;
  HTMLCollection getElementsByTagName(DOMString localName);
  HTMLCollection getElementsByTagNameNS(DOMString? namespace, DOMString localName);
  HTMLCollection getElementsByClassName(DOMString classNames);

  [NewObject] Element createElement(DOMString localName);
  [NewObject] Element createElementNS(DOMString? namespace, DOMString qualifiedName);
  [NewObject] DocumentFragment createDocumentFragment();
  [NewObject] Text createTextNode(DOMString data);
  [NewObject] CDATASection createCDATASection(DOMString data);
  [NewObject] Comment createComment(DOMString data);
  [NewObject] ProcessingInstruction createProcessingInstruction(DOMString target, DOMString data);

  [NewObject] Node importNode(Node node, optional boolean deep = false);
  Node adoptNode(Node node);

  [NewObject] Attr createAttribute(DOMString localName);
  [NewObject] Attr createAttributeNS(DOMString? namespace, DOMString name);

  [NewObject] Event createEvent(DOMString interface);

  [NewObject] Range createRange();

  // NodeFilter.SHOW_ALL = 0xFFFFFFFF
  [NewObject] NodeIterator createNodeIterator(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);
  [NewObject] TreeWalker createTreeWalker(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);
};

interface XMLDocument : Document {};

interface DOMImplementation {
  [NewObject] DocumentType createDocumentType(DOMString qualifiedName, DOMString publicId, DOMString systemId);
  [NewObject] XMLDocument createDocument(DOMString? namespace, [TreatNullAs=EmptyString] DOMString qualifiedName, optional DocumentType? doctype = null);
  [NewObject] Document createHTMLDocument(optional DOMString title);

  boolean hasFeature(); // useless; always returns true
};

[Constructor]
interface DocumentFragment : Node {
};

interface DocumentType : Node {
  readonly attribute DOMString name;
  readonly attribute DOMString publicId;
  readonly attribute DOMString systemId;
};

interface Element : Node {
  readonly attribute DOMString? namespaceURI;
  readonly attribute DOMString? prefix;
  readonly attribute DOMString localName;
  readonly attribute DOMString tagName;

           attribute DOMString id;
           attribute DOMString className;
  [SameObject, PutForwards=value] readonly attribute DOMTokenList classList;

  boolean hasAttributes();
  [SameObject] readonly attribute NamedNodeMap attributes;
  sequence<DOMString> getAttributeNames();
  DOMString? getAttribute(DOMString name);
  DOMString? getAttributeNS(DOMString? namespace, DOMString localName);
  void setAttribute(DOMString name, DOMString value);
  void setAttributeNS(DOMString? namespace, DOMString name, DOMString value);
  void removeAttribute(DOMString name);
  void removeAttributeNS(DOMString? namespace, DOMString localName);
  boolean hasAttribute(DOMString name);
  boolean hasAttributeNS(DOMString? namespace, DOMString localName);

  Attr? getAttributeNode(DOMString name);
  Attr? getAttributeNodeNS(DOMString? namespace, DOMString localName);
  Attr? setAttributeNode(Attr attr);
  Attr? setAttributeNodeNS(Attr attr);
  Attr removeAttributeNode(Attr attr);

  Element? closest(DOMString selectors);
  boolean matches(DOMString selectors);

  HTMLCollection getElementsByTagName(DOMString localName);
  HTMLCollection getElementsByTagNameNS(DOMString? namespace, DOMString localName);
  HTMLCollection getElementsByClassName(DOMString classNames);
};

interface NamedNodeMap {
  readonly attribute unsigned long length;
  getter Attr? item(unsigned long index);
  getter Attr? getNamedItem(DOMString name);
  Attr? getNamedItemNS(DOMString? namespace, DOMString localName);
  Attr? setNamedItem(Attr attr);
  Attr? setNamedItemNS(Attr attr);
  Attr removeNamedItem(DOMString name);
  Attr removeNamedItemNS(DOMString? namespace, DOMString localName);
};

interface Attr {
  readonly attribute DOMString? namespaceURI;
  readonly attribute DOMString? prefix;
  readonly attribute DOMString localName;
  readonly attribute DOMString name;
           attribute DOMString value;
           attribute DOMString nodeValue; // legacy alias of .value
           attribute DOMString textContent; // legacy alias of .value

  readonly attribute Element? ownerElement;

  readonly attribute boolean specified; // useless; always returns true
};

interface CharacterData : Node {
  [TreatNullAs=EmptyString] attribute DOMString data;
  readonly attribute unsigned long length;
  DOMString substringData(unsigned long offset, unsigned long count);
  void appendData(DOMString data);
  void insertData(unsigned long offset, DOMString data);
  void deleteData(unsigned long offset, unsigned long count);
  void replaceData(unsigned long offset, unsigned long count, DOMString data);
};

[Constructor(optional DOMString data = "")]
interface Text : CharacterData {
  [NewObject] Text splitText(unsigned long offset);
  readonly attribute DOMString wholeText;
};

[Exposed=Window]
interface CDATASection : Text {
};

interface ProcessingInstruction : CharacterData {
  readonly attribute DOMString target;
};

[Constructor(optional DOMString data = "")]
interface Comment : CharacterData {
};

[Constructor]
interface Range {
  readonly attribute Node startContainer;
  readonly attribute unsigned long startOffset;
  readonly attribute Node endContainer;
  readonly attribute unsigned long endOffset;
  readonly attribute boolean collapsed;
  readonly attribute Node commonAncestorContainer;

  void setStart(Node node, unsigned long offset);
  void setEnd(Node node, unsigned long offset);
  void setStartBefore(Node node);
  void setStartAfter(Node node);
  void setEndBefore(Node node);
  void setEndAfter(Node node);
  void collapse(optional boolean toStart = false);
  void selectNode(Node node);
  void selectNodeContents(Node node);

  const unsigned short START_TO_START = 0;
  const unsigned short START_TO_END = 1;
  const unsigned short END_TO_END = 2;
  const unsigned short END_TO_START = 3;
  short compareBoundaryPoints(unsigned short how, Range sourceRange);

  void deleteContents();
  [NewObject] DocumentFragment extractContents();
  [NewObject] DocumentFragment cloneContents();
  void insertNode(Node node);
  void surroundContents(Node newParent);

  [NewObject] Range cloneRange();
  void detach();

  boolean isPointInRange(Node node, unsigned long offset);
  short comparePoint(Node node, unsigned long offset);

  boolean intersectsNode(Node node);

  stringifier;
};

interface NodeIterator {
  [SameObject] readonly attribute Node root;
  readonly attribute Node referenceNode;
  readonly attribute boolean pointerBeforeReferenceNode;
  readonly attribute unsigned long whatToShow;
  readonly attribute NodeFilter? filter;

  Node? nextNode();
  Node? previousNode();

  void detach();
};

interface TreeWalker {
  [SameObject] readonly attribute Node root;
  readonly attribute unsigned long whatToShow;
  readonly attribute NodeFilter? filter;
           attribute Node currentNode;

  Node? parentNode();
  Node? firstChild();
  Node? lastChild();
  Node? previousSibling();
  Node? nextSibling();
  Node? previousNode();
  Node? nextNode();
};

callback interface NodeFilter {
  // Constants for acceptNode()
  const unsigned short FILTER_ACCEPT = 1;
  const unsigned short FILTER_REJECT = 2;
  const unsigned short FILTER_SKIP = 3;

  // Constants for whatToShow
  const unsigned long SHOW_ALL = 0xFFFFFFFF;
  const unsigned long SHOW_ELEMENT = 0x1;
  const unsigned long SHOW_ATTRIBUTE = 0x2; // historical
  const unsigned long SHOW_TEXT = 0x4;
  const unsigned long SHOW_CDATA_SECTION = 0x8;
  const unsigned long SHOW_ENTITY_REFERENCE = 0x10; // historical
  const unsigned long SHOW_ENTITY = 0x20; // historical
  const unsigned long SHOW_PROCESSING_INSTRUCTION = 0x40;
  const unsigned long SHOW_COMMENT = 0x80;
  const unsigned long SHOW_DOCUMENT = 0x100;
  const unsigned long SHOW_DOCUMENT_TYPE = 0x200;
  const unsigned long SHOW_DOCUMENT_FRAGMENT = 0x400;
  const unsigned long SHOW_NOTATION = 0x800; // historical

  unsigned short acceptNode(Node node);
};

interface DOMTokenList {
  readonly attribute unsigned long length;
  getter DOMString? item(unsigned long index);
  boolean contains(DOMString token);
  [CEReactions] void add(DOMString... tokens);
  [CEReactions] void remove(DOMString... tokens);
  [CEReactions] boolean toggle(DOMString token, optional boolean force);
  [CEReactions] void replace(DOMString token, DOMString newToken);
  boolean supports(DOMString token);
  [CEReactions] stringifier attribute DOMString value;
  //  iterable<DOMString>;
};</script>
<!-- UI Events IDLs -->
<script type=text/plain class=untested>
[Constructor(DOMString type, optional UIEventInit eventInitDict)]
interface UIEvent : Event {
    readonly    attribute WindowProxy? view;
    readonly    attribute long         detail;
};

dictionary UIEventInit : EventInit {
    WindowProxy? view = null;
    long         detail = 0;
};

[Constructor(DOMString typeArg, optional MouseEventInit mouseEventInitDict)]
interface MouseEvent : UIEvent {
    readonly    attribute long           screenX;
    readonly    attribute long           screenY;
    readonly    attribute long           clientX;
    readonly    attribute long           clientY;
    readonly    attribute boolean        ctrlKey;
    readonly    attribute boolean        shiftKey;
    readonly    attribute boolean        altKey;
    readonly    attribute boolean        metaKey;
    readonly    attribute short          button;
    readonly    attribute EventTarget?   relatedTarget;
    // Introduced in DOM Level 3
    readonly    attribute unsigned short buttons;
    boolean getModifierState (DOMString keyArg);
};

dictionary MouseEventInit : EventModifierInit {
    long           screenX = 0;
    long           screenY = 0;
    long           clientX = 0;
    long           clientY = 0;
    short          button = 0;
    unsigned short buttons = 0;
    EventTarget?   relatedTarget = null;
};

dictionary EventModifierInit : UIEventInit {
    boolean ctrlKey = false;
    boolean shiftKey = false;
    boolean altKey = false;
    boolean metaKey = false;
    boolean keyModifierStateAltGraph = false;
    boolean keyModifierStateCapsLock = false;
    boolean keyModifierStateFn = false;
    boolean keyModifierStateFnLock = false;
    boolean keyModifierStateHyper = false;
    boolean keyModifierStateNumLock = false;
    boolean keyModifierStateOS = false;
    boolean keyModifierStateScrollLock = false;
    boolean keyModifierStateSuper = false;
    boolean keyModifierStateSymbol = false;
    boolean keyModifierStateSymbolLock = false;
};

partial interface MouseEvent {
    // Deprecated in DOM Level 3
    void initMouseEvent (DOMString typeArg, boolean bubblesArg, boolean cancelableArg, Window? viewArg, long detailArg, long screenXArg, long screenYArg, long clientXArg, long clientYArg, boolean ctrlKeyArg, boolean altKeyArg, boolean shiftKeyArg, boolean metaKeyArg, short buttonArg, EventTarget? relatedTargetArg);
};
</script>
<!-- Touch Events IDLs -->
<script type=text/plain class=untested>
interface Touch {
    readonly    attribute long        identifier;
    readonly    attribute EventTarget target;
    readonly    attribute long        screenX;
    readonly    attribute long        screenY;
    readonly    attribute long        clientX;
    readonly    attribute long        clientY;
    readonly    attribute long        pageX;
    readonly    attribute long        pageY;
};
</script>
<!-- CSSOM IDLs -->
<script type=text/plain class=untested>
interface MediaList {
  stringifier attribute DOMString mediaText;
  readonly attribute unsigned long length;
  getter DOMString item(unsigned long index);
  void appendMedium(DOMString medium);
  void deleteMedium(DOMString medium);
};

interface StyleSheet {
  readonly attribute DOMString type;
  readonly attribute DOMString href;
  readonly attribute Node ownerNode;
  readonly attribute StyleSheet parentStyleSheet;
  readonly attribute DOMString title;
  [PutForwards=mediaText] readonly attribute MediaList media;
           attribute boolean disabled;
};

interface CSSStyleSheet : StyleSheet {
  readonly attribute CSSRule ownerRule;
  readonly attribute CSSRuleList cssRules;
  unsigned long insertRule(DOMString rule, unsigned long index);
  void deleteRule(unsigned long index);
};

typedef sequence<StyleSheet> StyleSheetList;

partial interface Document {
  readonly attribute StyleSheetList styleSheets;
           attribute DOMString? selectedStyleSheetSet;
  readonly attribute DOMString? lastStyleSheetSet;
  readonly attribute DOMString? preferredStyleSheetSet;
  readonly attribute DOMStringList styleSheetSets;
  void enableStyleSheetsForSet(DOMString? name);
};

[NoInterfaceObject] interface LinkStyle {
  readonly attribute StyleSheet sheet;
};

ProcessingInstruction implements LinkStyle;

typedef sequence<CSSRule> CSSRuleList;

interface CSSRule {
  // Types
  const unsigned short STYLE_RULE = 1;
  const unsigned short IMPORT_RULE = 3;
  const unsigned short MEDIA_RULE = 4;
  const unsigned short FONT_FACE_RULE = 5;
  const unsigned short PAGE_RULE = 6;
  const unsigned short NAMESPACE_RULE = 10;
  readonly attribute unsigned short type;

  // Parsing and serialization
           attribute DOMString cssText;

  // Context
  readonly attribute CSSRule parentRule;
  readonly attribute CSSStyleSheet parentStyleSheet;
};

interface CSSStyleRule : CSSRule {
           attribute DOMString selectorText;
  readonly attribute CSSStyleDeclaration style;
};

interface CSSImportRule : CSSRule {
  readonly attribute DOMString href;
  [PutForwards=mediaText] readonly attribute MediaList media;
  readonly attribute CSSStyleSheet styleSheet;
};

interface CSSMediaRule : CSSRule {
  [PutForwards=mediaText] readonly attribute MediaList media;
  readonly attribute CSSRuleList cssRules;
  unsigned long insertRule(DOMString rule, unsigned long index);
  void deleteRule(unsigned long index);
};

interface CSSFontFaceRule : CSSRule {
  readonly attribute CSSStyleDeclaration style;
};

interface CSSPageRule : CSSRule {
           attribute DOMString selectorText;
  readonly attribute CSSStyleDeclaration style;
};

interface CSSNamespaceRule : CSSRule {
  readonly attribute DOMString namespaceURI;
  readonly attribute DOMString? prefix;
};

interface CSSStyleDeclaration {
           attribute DOMString cssText;

  readonly attribute unsigned long length;
  DOMString item(unsigned long index);

  DOMString getPropertyValue(DOMString property);
  DOMString getPropertyPriority(DOMString property);
  void setProperty(DOMString property, DOMString value, optional DOMString priority);
  DOMString removeProperty(DOMString property);

  readonly attribute CSSStyleDeclarationValue values;

  readonly attribute CSSRule parentRule;

  // CSS Properties
           attribute DOMString azimuth;
           attribute DOMString background;
           attribute DOMString backgroundAttachment;
           attribute DOMString backgroundColor;
           attribute DOMString backgroundImage;
           attribute DOMString backgroundPosition;
           attribute DOMString backgroundRepeat;
           attribute DOMString border;
           attribute DOMString borderCollapse;
           attribute DOMString borderColor;
           attribute DOMString borderSpacing;
           attribute DOMString borderStyle;
           attribute DOMString borderTop;
           attribute DOMString borderRight;
           attribute DOMString borderBottom;
           attribute DOMString borderLeft;
           attribute DOMString borderTopColor;
           attribute DOMString borderRightColor;
           attribute DOMString borderBottomColor;
           attribute DOMString borderLeftColor;
           attribute DOMString borderTopStyle;
           attribute DOMString borderRightStyle;
           attribute DOMString borderBottomStyle;
           attribute DOMString borderLeftStyle;
           attribute DOMString borderTopWidth;
           attribute DOMString borderRightWidth;
           attribute DOMString borderBottomWidth;
           attribute DOMString borderLeftWidth;
           attribute DOMString borderWidth;
           attribute DOMString bottom;
           attribute DOMString captionSide;
           attribute DOMString clear;
           attribute DOMString clip;
           attribute DOMString color;
           attribute DOMString content;
           attribute DOMString counterIncrement;
           attribute DOMString counterReset;
           attribute DOMString cue;
           attribute DOMString cueAfter;
           attribute DOMString cueBefore;
           attribute DOMString cursor;
           attribute DOMString direction;
           attribute DOMString display;
           attribute DOMString elevation;
           attribute DOMString emptyCells;
           attribute DOMString cssFloat;
           attribute DOMString font;
           attribute DOMString fontFamily;
           attribute DOMString fontSize;
           attribute DOMString fontSizeAdjust;
           attribute DOMString fontStretch;
           attribute DOMString fontStyle;
           attribute DOMString fontVariant;
           attribute DOMString fontWeight;
           attribute DOMString height;
           attribute DOMString left;
           attribute DOMString letterSpacing;
           attribute DOMString lineHeight;
           attribute DOMString listStyle;
           attribute DOMString listStyleImage;
           attribute DOMString listStylePosition;
           attribute DOMString listStyleType;
           attribute DOMString margin;
           attribute DOMString marginTop;
           attribute DOMString marginRight;
           attribute DOMString marginBottom;
           attribute DOMString marginLeft;
           attribute DOMString marks;
           attribute DOMString maxHeight;
           attribute DOMString maxWidth;
           attribute DOMString minHeight;
           attribute DOMString minWidth;
           attribute DOMString orphans;
           attribute DOMString outline;
           attribute DOMString outlineColor;
           attribute DOMString outlineStyle;
           attribute DOMString outlineWidth;
           attribute DOMString overflow;
           attribute DOMString padding;
           attribute DOMString paddingTop;
           attribute DOMString paddingRight;
           attribute DOMString paddingBottom;
           attribute DOMString paddingLeft;
           attribute DOMString page;
           attribute DOMString pageBreakAfter;
           attribute DOMString pageBreakBefore;
           attribute DOMString pageBreakInside;
           attribute DOMString pause;
           attribute DOMString pauseAfter;
           attribute DOMString pauseBefore;
           attribute DOMString pitch;
           attribute DOMString pitchRange;
           attribute DOMString playDuring;
           attribute DOMString position;
           attribute DOMString quotes;
           attribute DOMString richness;
           attribute DOMString right;
           attribute DOMString size;
           attribute DOMString speak;
           attribute DOMString speakHeader;
           attribute DOMString speakNumeral;
           attribute DOMString speakPunctuation;
           attribute DOMString speechRate;
           attribute DOMString stress;
           attribute DOMString tableLayout;
           attribute DOMString textAlign;
           attribute DOMString textDecoration;
           attribute DOMString textIndent;
           attribute DOMString textShadow;
           attribute DOMString textTransform;
           attribute DOMString top;
           attribute DOMString unicodeBidi;
           attribute DOMString verticalAlign;
           attribute DOMString visibility;
           attribute DOMString voiceFamily;
           attribute DOMString volume;
           attribute DOMString whiteSpace;
           attribute DOMString widows;
           attribute DOMString width;
           attribute DOMString wordSpacing;
           attribute DOMString zIndex;
};

interface CSSStyleDeclarationValue {
  // ...

  // CSS Properties

};

interface CSSPropertyValue {
           attribute DOMString cssText;
};

[NoInterfaceObject] interface CSSMapValue {
  getter CSSValue (DOMString name);
};

[NoInterfaceObject] interface CSSPropertyValueList {
  readonly attribute CSSValue[] list;
};

[NoInterfaceObject] interface CSSComponentValue {
  readonly attribute DOMString type;
           attribute any value;
};

[NoInterfaceObject] interface CSSStringComponentValue {
           attribute DOMString string;
};

[NoInterfaceObject] interface CSSKeywordComponentValue {
           attribute DOMString keyword;
};

[NoInterfaceObject] interface CSSIdentifierComponentValue {
           attribute DOMString identifier;
};

[NoInterfaceObject] interface CSSColorComponentValue {
           attribute short red;
           attribute short green;
           attribute short blue;
           attribute float alpha;
};

[NoInterfaceObject] interface CSSLengthComponentValue {
           attribute float em;
           attribute float ex;
           attribute float px;
           // figure out what to do with absolute lengths
};

[NoInterfaceObject] interface CSSPercentageComponentValue {
           attribute float percent;
};

[NoInterfaceObject] interface CSSURLComponentValue {
           attribute DOMString? url;
};

[NoInterfaceObject] interface ElementCSSInlineStyle {
  readonly attribute CSSStyleDeclaration style;
};

//partial interface Window {
//  CSSStyleDeclaration getComputedStyle(Element elt);
//  CSSStyleDeclaration getComputedStyle(Element elt, DOMString pseudoElt);
//};
</script>

<!-- HTML IDLs -->
<script type=text/plain>
typedef (Int8Array or Uint8Array or Uint8ClampedArray or
         Int16Array or Uint16Array or
         Int32Array or Uint32Array or
         Float32Array or Float64Array or
         DataView) ArrayBufferView;

[NoInterfaceObject, Exposed=Window]
interface HTMLHyperlinkElementUtils {
  stringifier attribute USVString href;
  readonly attribute USVString origin;
           attribute USVString protocol;
           attribute USVString username;
           attribute USVString password;
           attribute USVString host;
           attribute USVString hostname;
           attribute USVString port;
           attribute USVString pathname;
           attribute USVString search;
           attribute USVString hash;
};

interface HTMLAllCollection {
  readonly attribute unsigned long length;
  getter Element? item(unsigned long index);
  (HTMLCollection or Element)? item(DOMString name);
  legacycaller getter (HTMLCollection or Element)? namedItem(DOMString name);
};

interface HTMLFormControlsCollection : HTMLCollection {
  // inherits length and item()
  getter (RadioNodeList or Element)? namedItem(DOMString name); // shadows inherited namedItem()
};

interface RadioNodeList : NodeList {
          attribute DOMString value;
};

interface HTMLOptionsCollection : HTMLCollection {
  // inherits item(), namedItem()
  attribute unsigned long length; // shadows inherited length
  [CEReactions] setter void (unsigned long index, HTMLOptionElement? option);
  [CEReactions] void add((HTMLOptionElement or HTMLOptGroupElement) element, optional (HTMLElement or long)? before = null);
  [CEReactions] void remove(long index);
  attribute long selectedIndex;
};

typedef sequence<any> PropertyValueArray;

[OverrideBuiltins, Exposed=(Window,Worker)]
interface DOMStringMap {
  getter DOMString (DOMString name);
  setter creator void (DOMString name, DOMString value);
  deleter void (DOMString name);
};

typedef (ArrayBuffer or MessagePort) Transferable;

callback FileCallback = void (File file);

enum DocumentReadyState { "loading", "interactive", "complete" };
typedef (HTMLScriptElement or SVGScriptElement) HTMLOrSVGScriptElement;

[OverrideBuiltins]
partial /*sealed*/ interface Document {
  // resource metadata management
  [PutForwards=href, Unforgeable] readonly attribute Location? location;
           attribute USVString domain;
  readonly attribute USVString referrer;
           attribute USVString cookie;
  readonly attribute DOMString lastModified;
  readonly attribute DocumentReadyState readyState;

  // DOM tree accessors
  getter object (DOMString name);
  [CEReactions] attribute DOMString title;
  [CEReactions] attribute DOMString dir;
  [CEReactions] attribute HTMLElement? body;
  readonly attribute HTMLHeadElement? head;
  [SameObject] readonly attribute HTMLCollection images;
  [SameObject] readonly attribute HTMLCollection embeds;
  [SameObject] readonly attribute HTMLCollection plugins;
  [SameObject] readonly attribute HTMLCollection links;
  [SameObject] readonly attribute HTMLCollection forms;
  [SameObject] readonly attribute HTMLCollection scripts;
  NodeList getElementsByName(DOMString elementName);
  readonly attribute HTMLOrSVGScriptElement? currentScript; // classic scripts in a document tree only

  // dynamic markup insertion
  [CEReactions] Document open(optional DOMString type = "text/html", optional DOMString replace = "");
  WindowProxy open(USVString url, DOMString name, DOMString features);
  [CEReactions] void close();
  [CEReactions] void write(DOMString... text);
  [CEReactions] void writeln(DOMString... text);

  // user interaction
  readonly attribute WindowProxy? defaultView;
  readonly attribute Element? activeElement;
  boolean hasFocus();
  [CEReactions] attribute DOMString designMode;
  [CEReactions] boolean execCommand(DOMString commandId, optional boolean showUI = false, optional DOMString value = "");
  boolean queryCommandEnabled(DOMString commandId);
  boolean queryCommandIndeterm(DOMString commandId);
  boolean queryCommandState(DOMString commandId);
  boolean queryCommandSupported(DOMString commandId);
  DOMString queryCommandValue(DOMString commandId);

  // special event handler IDL attributes that only apply to Document objects
  [LenientThis] attribute EventHandler onreadystatechange;

  // also has obsolete members
};
Document implements GlobalEventHandlers;
Document implements DocumentAndElementEventHandlers;

[NoInterfaceObject]
interface ElementContentEditable {
  [CEReactions] attribute DOMString contentEditable;
  readonly attribute boolean isContentEditable;
};

interface HTMLElement : Element {
  // metadata attributes
  [CEReactions] attribute DOMString title;
  [CEReactions] attribute DOMString lang;
  [CEReactions] attribute boolean translate;
  [CEReactions] attribute DOMString dir;
  [SameObject] readonly attribute DOMStringMap dataset;

  // user interaction
  [CEReactions] attribute boolean hidden;
  void click();
  [CEReactions] attribute long tabIndex;
  void focus();
  void blur();
  [CEReactions] attribute DOMString accessKey;
  readonly attribute DOMString accessKeyLabel;
  [CEReactions] attribute boolean draggable;
  [CEReactions, SameObject, PutForwards=value] readonly attribute DOMTokenList dropzone;
  [CEReactions] attribute HTMLMenuElement? contextMenu;
  [CEReactions] attribute boolean spellcheck;
  void forceSpellCheck();

  [CEReactions, TreatNullAs=EmptyString] attribute DOMString innerText;
};
HTMLElement implements GlobalEventHandlers;
HTMLElement implements DocumentAndElementEventHandlers;
HTMLElement implements ElementContentEditable;

interface HTMLUnknownElement : HTMLElement { };

interface HTMLHtmlElement : HTMLElement {
  // also has obsolete members
};

interface HTMLHeadElement : HTMLElement {};

interface HTMLTitleElement : HTMLElement {
           attribute DOMString text;
};

interface HTMLBaseElement : HTMLElement {
           attribute DOMString href;
           attribute DOMString target;
};

interface HTMLLinkElement : HTMLElement {
           attribute DOMString href;
           attribute DOMString? crossOrigin;
           attribute DOMString rel;
  [PutForwards=value] readonly attribute DOMTokenList relList;
           attribute DOMString media;
           attribute DOMString hreflang;
           attribute DOMString type;
  [PutForwards=value] readonly attribute DOMTokenList sizes;

  // also has obsolete members
};
HTMLLinkElement implements LinkStyle;

interface HTMLMetaElement : HTMLElement {
           attribute DOMString name;
           attribute DOMString httpEquiv;
           attribute DOMString content;

  // also has obsolete members
};

interface HTMLStyleElement : HTMLElement {
  [CEReactions] attribute DOMString media;
  [CEReactions] attribute DOMString nonce;
  [CEReactions] attribute DOMString type;
};
HTMLStyleElement implements LinkStyle;

interface HTMLBodyElement : HTMLElement {

  // also has obsolete members
};
HTMLBodyElement implements WindowEventHandlers;

interface HTMLHeadingElement : HTMLElement {
  // also has obsolete members
};

interface HTMLParagraphElement : HTMLElement {
  // also has obsolete members
};

interface HTMLHRElement : HTMLElement {
  // also has obsolete members
};

interface HTMLPreElement : HTMLElement {
  // also has obsolete members
};

interface HTMLQuoteElement : HTMLElement {
           attribute DOMString cite;
};

interface HTMLOListElement : HTMLElement {
           attribute boolean reversed;
           attribute long start;
           attribute DOMString type;

  // also has obsolete members
};

interface HTMLUListElement : HTMLElement {
  // also has obsolete members
};

interface HTMLLIElement : HTMLElement {
           attribute long value;

  // also has obsolete members
};

interface HTMLDListElement : HTMLElement {
  // also has obsolete members
};

interface HTMLDivElement : HTMLElement {
  // also has obsolete members
};

interface HTMLAnchorElement : HTMLElement {
  attribute DOMString target;
  attribute DOMString download;
  [CEReactions] attribute USVString ping;
  attribute DOMString rel;
  [PutForwards=value] readonly attribute DOMTokenList relList;
  attribute DOMString hreflang;
  attribute DOMString type;

  attribute DOMString text;
};
HTMLAnchorElement implements HTMLHyperlinkElementUtils;

interface HTMLDataElement : HTMLElement {
           attribute DOMString value;
};

interface HTMLTimeElement : HTMLElement {
           attribute DOMString dateTime;
};

interface HTMLSpanElement : HTMLElement {};

interface HTMLBRElement : HTMLElement {
  // also has obsolete members
};

interface HTMLModElement : HTMLElement {
           attribute DOMString cite;
           attribute DOMString dateTime;
};

interface HTMLPictureElement : HTMLElement {};

partial interface HTMLSourceElement {
           attribute DOMString srcset;
           attribute DOMString sizes;
           attribute DOMString media;
};

[NamedConstructor=Image(optional unsigned long width, optional unsigned long height)]
interface HTMLImageElement : HTMLElement {
           attribute DOMString alt;
           attribute DOMString src;
           attribute DOMString srcset;
           attribute DOMString sizes;
           attribute DOMString? crossOrigin;
           attribute DOMString useMap;
           attribute boolean isMap;
           attribute unsigned long width;
           attribute unsigned long height;
  readonly attribute unsigned long naturalWidth;
  readonly attribute unsigned long naturalHeight;
  readonly attribute boolean complete;
  readonly attribute DOMString currentSrc;

  // also has obsolete members
};

interface HTMLIFrameElement : HTMLElement {
           attribute DOMString src;
           attribute DOMString srcdoc;
           attribute DOMString name;
  [PutForwards=value] readonly attribute DOMTokenList sandbox;
           attribute boolean allowFullscreen;
           attribute DOMString width;
           attribute DOMString height;
  readonly attribute Document? contentDocument;
  readonly attribute WindowProxy? contentWindow;

  // also has obsolete members
};

interface HTMLEmbedElement : HTMLElement {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString width;
           attribute DOMString height;
  Document getSVGDocument();

  // also has obsolete members
};

interface HTMLObjectElement : HTMLElement {
           attribute DOMString data;
           attribute DOMString type;
           attribute boolean typeMustMatch;
           attribute DOMString name;
           attribute DOMString useMap;
  readonly attribute HTMLFormElement? form;
           attribute DOMString width;
           attribute DOMString height;
  readonly attribute Document? contentDocument;
  readonly attribute WindowProxy? contentWindow;

  readonly attribute boolean willValidate;
  readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  boolean reportValidity();
  void setCustomValidity(DOMString error);

  // also has obsolete members
};

interface HTMLParamElement : HTMLElement {
           attribute DOMString name;
           attribute DOMString value;

  // also has obsolete members
};

interface HTMLVideoElement : HTMLMediaElement {
           attribute unsigned long width;
           attribute unsigned long height;
  readonly attribute unsigned long videoWidth;
  readonly attribute unsigned long videoHeight;
           attribute DOMString poster;
};

[NamedConstructor=Audio(optional DOMString src)]
interface HTMLAudioElement : HTMLMediaElement {};

interface HTMLSourceElement : HTMLElement {
           attribute DOMString src;
           attribute DOMString type;

  // also has obsolete members
};

interface HTMLTrackElement : HTMLElement {
           attribute DOMString kind;
           attribute DOMString src;
           attribute DOMString srclang;
           attribute DOMString label;
           attribute boolean default;

  const unsigned short NONE = 0;
  const unsigned short LOADING = 1;
  const unsigned short LOADED = 2;
  const unsigned short ERROR = 3;
  readonly attribute unsigned short readyState;

  readonly attribute TextTrack track;
};

enum CanPlayTypeResult { "" /* empty string */, "maybe", "probably" };
interface HTMLMediaElement : HTMLElement {

  // error state
  readonly attribute MediaError? error;

  // network state
           attribute DOMString src;
  readonly attribute DOMString currentSrc;
           attribute DOMString? crossOrigin;
  const unsigned short NETWORK_EMPTY = 0;
  const unsigned short NETWORK_IDLE = 1;
  const unsigned short NETWORK_LOADING = 2;
  const unsigned short NETWORK_NO_SOURCE = 3;
  readonly attribute unsigned short networkState;
           attribute DOMString preload;
  readonly attribute TimeRanges buffered;
  void load();
  CanPlayTypeResult canPlayType(DOMString type);

  // ready state
  const unsigned short HAVE_NOTHING = 0;
  const unsigned short HAVE_METADATA = 1;
  const unsigned short HAVE_CURRENT_DATA = 2;
  const unsigned short HAVE_FUTURE_DATA = 3;
  const unsigned short HAVE_ENOUGH_DATA = 4;
  readonly attribute unsigned short readyState;
  readonly attribute boolean seeking;

  // playback state
           attribute double currentTime;
  void fastSeek(double time);
  readonly attribute unrestricted double duration;
  Date getStartDate();
  readonly attribute boolean paused;
           attribute double defaultPlaybackRate;
           attribute double playbackRate;
  readonly attribute TimeRanges played;
  readonly attribute TimeRanges seekable;
  readonly attribute boolean ended;
           attribute boolean autoplay;
           attribute boolean loop;
  Promise<void> play();
  void pause();

  // controls
           attribute boolean controls;
           attribute double volume;
           attribute boolean muted;
           attribute boolean defaultMuted;

  // tracks
  readonly attribute AudioTrackList audioTracks;
  readonly attribute VideoTrackList videoTracks;
  readonly attribute TextTrackList textTracks;
  TextTrack addTextTrack(TextTrackKind kind, optional DOMString label = "", optional DOMString language = "");
};

interface MediaError {
  const unsigned short MEDIA_ERR_ABORTED = 1;
  const unsigned short MEDIA_ERR_NETWORK = 2;
  const unsigned short MEDIA_ERR_DECODE = 3;
  const unsigned short MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
  readonly attribute unsigned short code;
};

interface AudioTrackList : EventTarget {
  readonly attribute unsigned long length;
  getter AudioTrack (unsigned long index);
  AudioTrack? getTrackById(DOMString id);

           attribute EventHandler onchange;
           attribute EventHandler onaddtrack;
           attribute EventHandler onremovetrack;
};

interface AudioTrack {
  readonly attribute DOMString id;
  readonly attribute DOMString kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
           attribute boolean enabled;
};

interface VideoTrackList : EventTarget {
  readonly attribute unsigned long length;
  getter VideoTrack (unsigned long index);
  VideoTrack? getTrackById(DOMString id);
  readonly attribute long selectedIndex;

           attribute EventHandler onchange;
           attribute EventHandler onaddtrack;
           attribute EventHandler onremovetrack;
};

interface VideoTrack {
  readonly attribute DOMString id;
  readonly attribute DOMString kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
           attribute boolean selected;
};

interface TextTrackList : EventTarget {
  readonly attribute unsigned long length;
  getter TextTrack (unsigned long index);
  TextTrack? getTrackById(DOMString id);

           attribute EventHandler onchange;
           attribute EventHandler onaddtrack;
           attribute EventHandler onremovetrack;
};

enum TextTrackMode { "disabled",  "hidden",  "showing" };
enum TextTrackKind { "subtitles",  "captions",  "descriptions",  "chapters",  "metadata" };
interface TextTrack : EventTarget {
  readonly attribute TextTrackKind kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;

  readonly attribute DOMString id;
  readonly attribute DOMString inBandMetadataTrackDispatchType;

           attribute TextTrackMode mode;

  readonly attribute TextTrackCueList? cues;
  readonly attribute TextTrackCueList? activeCues;

  void addCue(TextTrackCue cue);
  void removeCue(TextTrackCue cue);

           attribute EventHandler oncuechange;
};

interface TextTrackCueList {
  readonly attribute unsigned long length;
  getter TextTrackCue (unsigned long index);
  TextTrackCue? getCueById(DOMString id);
};

interface TextTrackCue : EventTarget {
  readonly attribute TextTrack? track;

           attribute DOMString id;
           attribute double startTime;
           attribute double endTime;
           attribute boolean pauseOnExit;

           attribute EventHandler onenter;
           attribute EventHandler onexit;
};

interface TimeRanges {
  readonly attribute unsigned long length;
  double start(unsigned long index);
  double end(unsigned long index);
};

[Constructor(DOMString type, optional TrackEventInit eventInitDict)]
interface TrackEvent : Event {
  readonly attribute (VideoTrack or AudioTrack or TextTrack) track;
};

dictionary TrackEventInit : EventInit {
  (VideoTrack or AudioTrack or TextTrack) track;
};

interface HTMLMapElement : HTMLElement {
           attribute DOMString name;
  readonly attribute HTMLCollection areas;
};

interface HTMLAreaElement : HTMLElement {
  attribute DOMString alt;
  attribute DOMString coords;
  attribute DOMString shape;
  attribute DOMString target;
  attribute DOMString download;
  [CEReactions] attribute USVString ping;
  attribute DOMString rel;
  [PutForwards=value] readonly attribute DOMTokenList relList;
  // hreflang and type are not reflected
};
HTMLAreaElement implements HTMLHyperlinkElementUtils;

interface HTMLTableElement : HTMLElement {
           attribute HTMLTableCaptionElement? caption;
  HTMLElement createCaption();
  void deleteCaption();
           attribute HTMLTableSectionElement? tHead;
  HTMLElement createTHead();
  void deleteTHead();
           attribute HTMLTableSectionElement? tFoot;
  HTMLElement createTFoot();
  void deleteTFoot();
  readonly attribute HTMLCollection tBodies;
  HTMLElement createTBody();
  readonly attribute HTMLCollection rows;
  HTMLElement insertRow(optional long index = -1);
  void deleteRow(long index);

  // also has obsolete members
};

interface HTMLTableCaptionElement : HTMLElement {
  // also has obsolete members
};

interface HTMLTableColElement : HTMLElement {
           attribute unsigned long span;

  // also has obsolete members
};

interface HTMLTableSectionElement : HTMLElement {
  readonly attribute HTMLCollection rows;
  HTMLElement insertRow(optional long index = -1);
  void deleteRow(long index);

  // also has obsolete members
};

interface HTMLTableRowElement : HTMLElement {
  readonly attribute long rowIndex;
  readonly attribute long sectionRowIndex;
  readonly attribute HTMLCollection cells;
  HTMLElement insertCell(optional long index = -1);
  void deleteCell(long index);

  // also has obsolete members
};

interface HTMLTableCellElement : HTMLElement {
  [CEReactions] attribute unsigned long colSpan;
  [CEReactions] attribute unsigned long rowSpan;
  [CEReactions] attribute DOMString headers;
  readonly attribute long cellIndex;

  [CEReactions] attribute DOMString scope; // only conforming for th elements
  [CEReactions] attribute DOMString abbr;  // only conforming for th elements

  // also has obsolete members
};

[OverrideBuiltins]
interface HTMLFormElement : HTMLElement {
           attribute DOMString acceptCharset;
           attribute DOMString action;
           attribute DOMString autocomplete;
           attribute DOMString enctype;
           attribute DOMString encoding;
           attribute DOMString method;
           attribute DOMString name;
           attribute boolean noValidate;
           attribute DOMString target;

  readonly attribute HTMLFormControlsCollection elements;
  readonly attribute unsigned long length;
  getter Element (unsigned long index);
  getter (RadioNodeList or Element) (DOMString name);

  void submit();
  void reset();
  boolean checkValidity();
  boolean reportValidity();
};

interface HTMLLabelElement : HTMLElement {
  readonly attribute HTMLFormElement? form;
           attribute DOMString htmlFor;
  readonly attribute HTMLElement? control;
};

interface HTMLInputElement : HTMLElement {
           attribute DOMString accept;
           attribute DOMString alt;
           attribute DOMString autocomplete;
           attribute boolean autofocus;
           attribute boolean defaultChecked;
           attribute boolean checked;
           attribute DOMString dirName;
           attribute boolean disabled;
  readonly attribute HTMLFormElement? form;
  readonly attribute FileList? files;
           attribute DOMString formAction;
           attribute DOMString formEnctype;
           attribute DOMString formMethod;
           attribute boolean formNoValidate;
           attribute DOMString formTarget;
           attribute unsigned long height;
           attribute boolean indeterminate;
           attribute DOMString inputMode;
  readonly attribute HTMLElement? list;
           attribute DOMString max;
           attribute long maxLength;
           attribute DOMString min;
           attribute long minLength;
           attribute boolean multiple;
           attribute DOMString name;
           attribute DOMString pattern;
           attribute DOMString placeholder;
           attribute boolean readOnly;
           attribute boolean required;
           attribute unsigned long size;
           attribute DOMString src;
           attribute DOMString step;
           attribute DOMString type;
           attribute DOMString defaultValue;
  [TreatNullAs=EmptyString] attribute DOMString value;
           attribute Date? valueAsDate;
           attribute unrestricted double valueAsNumber;
           attribute unsigned long width;

  void stepUp(optional long n = 1);
  void stepDown(optional long n = 1);

  readonly attribute boolean willValidate;
  readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  boolean reportValidity();
  void setCustomValidity(DOMString error);

  readonly attribute NodeList labels;

  void select();
           attribute unsigned long? selectionStart;
           attribute unsigned long? selectionEnd;
           attribute DOMString? selectionDirection;
  void setRangeText(DOMString replacement);
  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional SelectionMode selectionMode = "preserve");
  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);

  // also has obsolete members
};

interface HTMLButtonElement : HTMLElement {
           attribute boolean autofocus;
           attribute boolean disabled;
  readonly attribute HTMLFormElement? form;
           attribute DOMString formAction;
           attribute DOMString formEnctype;
           attribute DOMString formMethod;
           attribute boolean formNoValidate;
           attribute DOMString formTarget;
           attribute DOMString name;
           attribute DOMString type;
           attribute DOMString value;
           attribute HTMLMenuElement? menu;

  readonly attribute boolean willValidate;
  readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  boolean reportValidity();
  void setCustomValidity(DOMString error);

  readonly attribute NodeList labels;
};

interface HTMLSelectElement : HTMLElement {
           attribute DOMString autocomplete;
           attribute boolean autofocus;
           attribute boolean disabled;
  readonly attribute HTMLFormElement? form;
           attribute boolean multiple;
           attribute DOMString name;
           attribute boolean required;
           attribute unsigned long size;

  readonly attribute DOMString type;

  readonly attribute HTMLOptionsCollection options;
           attribute unsigned long length;
  getter Element? item(unsigned long index);
  HTMLOptionElement? namedItem(DOMString name);
  void add((HTMLOptionElement or HTMLOptGroupElement) element, optional (HTMLElement or long)? before = null);
  void remove(); // ChildNode overload
  void remove(long index);
  setter creator void (unsigned long index, HTMLOptionElement? option);

  readonly attribute HTMLCollection selectedOptions;
           attribute long selectedIndex;
           attribute DOMString value;

  readonly attribute boolean willValidate;
  readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  boolean reportValidity();
  void setCustomValidity(DOMString error);

  readonly attribute NodeList labels;
};

interface HTMLDataListElement : HTMLElement {
  readonly attribute HTMLCollection options;
};

interface HTMLOptGroupElement : HTMLElement {
           attribute boolean disabled;
           attribute DOMString label;
};

[NamedConstructor=Option(optional DOMString text = "", optional DOMString value, optional boolean defaultSelected = false, optional boolean selected = false)]
interface HTMLOptionElement : HTMLElement {
           attribute boolean disabled;
  readonly attribute HTMLFormElement? form;
           attribute DOMString label;
           attribute boolean defaultSelected;
           attribute boolean selected;
           attribute DOMString value;

           attribute DOMString text;
  readonly attribute long index;
};

interface HTMLTextAreaElement : HTMLElement {
           attribute DOMString autocomplete;
           attribute boolean autofocus;
           attribute unsigned long cols;
           attribute DOMString dirName;
           attribute boolean disabled;
  readonly attribute HTMLFormElement? form;
           attribute DOMString inputMode;
           attribute long maxLength;
           attribute long minLength;
           attribute DOMString name;
           attribute DOMString placeholder;
           attribute boolean readOnly;
           attribute boolean required;
           attribute unsigned long rows;
           attribute DOMString wrap;

  readonly attribute DOMString type;
           attribute DOMString defaultValue;
  [TreatNullAs=EmptyString] attribute DOMString value;
  readonly attribute unsigned long textLength;

  readonly attribute boolean willValidate;
  readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  boolean reportValidity();
  void setCustomValidity(DOMString error);

  readonly attribute NodeList labels;

  void select();
           attribute unsigned long? selectionStart;
           attribute unsigned long? selectionEnd;
           attribute DOMString? selectionDirection;
  void setRangeText(DOMString replacement);
  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional SelectionMode selectionMode = "preserve");
  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);
};

interface HTMLKeygenElement : HTMLElement {
           attribute boolean autofocus;
           attribute DOMString challenge;
           attribute boolean disabled;
  readonly attribute HTMLFormElement? form;
           attribute DOMString keytype;
           attribute DOMString name;

  readonly attribute DOMString type;

  readonly attribute boolean willValidate;
  readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  boolean reportValidity();
  void setCustomValidity(DOMString error);

  readonly attribute NodeList labels;
};

interface HTMLOutputElement : HTMLElement {
  [PutForwards=value] readonly attribute DOMTokenList htmlFor;
  readonly attribute HTMLFormElement? form;
           attribute DOMString name;

  readonly attribute DOMString type;
           attribute DOMString defaultValue;
           attribute DOMString value;

  readonly attribute boolean willValidate;
  readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  boolean reportValidity();
  void setCustomValidity(DOMString error);

  readonly attribute NodeList labels;
};

interface HTMLProgressElement : HTMLElement {
           attribute double value;
           attribute double max;
  readonly attribute double position;
  readonly attribute NodeList labels;
};

interface HTMLMeterElement : HTMLElement {
           attribute double value;
           attribute double min;
           attribute double max;
           attribute double low;
           attribute double high;
           attribute double optimum;
  readonly attribute NodeList labels;
};

interface HTMLFieldSetElement : HTMLElement {
           attribute boolean disabled;
  readonly attribute HTMLFormElement? form;
           attribute DOMString name;

  readonly attribute DOMString type;

  readonly attribute HTMLFormControlsCollection elements;

  readonly attribute boolean willValidate;
  readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  boolean reportValidity();
  void setCustomValidity(DOMString error);
};

interface HTMLLegendElement : HTMLElement {
  readonly attribute HTMLFormElement? form;

  // also has obsolete members
};

enum SelectionMode {
  "select",
  "start",
  "end",
  "preserve"/*,*/ // default
};

interface ValidityState {
  readonly attribute boolean valueMissing;
  readonly attribute boolean typeMismatch;
  readonly attribute boolean patternMismatch;
  readonly attribute boolean tooLong;
  readonly attribute boolean tooShort;
  readonly attribute boolean rangeUnderflow;
  readonly attribute boolean rangeOverflow;
  readonly attribute boolean stepMismatch;
  readonly attribute boolean badInput;
  readonly attribute boolean customError;
  readonly attribute boolean valid;
};

interface HTMLDetailsElement : HTMLElement {
           attribute boolean open;
};

interface HTMLMenuElement : HTMLElement {
           attribute DOMString type;
           attribute DOMString label;

  // also has obsolete members
};

interface HTMLMenuItemElement : HTMLElement {
           attribute DOMString type;
           attribute DOMString label;
           attribute DOMString icon;
           attribute boolean disabled;
           attribute boolean checked;
           attribute DOMString radiogroup;
           attribute boolean default;
  readonly attribute HTMLElement? command;
};

[Constructor(DOMString type, optional RelatedEventInit eventInitDict)]
interface RelatedEvent : Event {
  readonly attribute EventTarget? relatedTarget;
};

dictionary RelatedEventInit : EventInit {
  EventTarget? relatedTarget;
};

interface HTMLDialogElement : HTMLElement {
           attribute boolean open;
           attribute DOMString returnValue;
  void show(optional (MouseEvent or Element) anchor);
  void showModal(optional (MouseEvent or Element) anchor);
  void close(optional DOMString returnValue);
};

interface HTMLScriptElement : HTMLElement {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString charset;
           attribute boolean async;
           attribute boolean defer;
           attribute DOMString? crossOrigin;
           attribute DOMString text;

  // also has obsolete members
};

interface HTMLTemplateElement : HTMLElement {
  readonly attribute DocumentFragment content;
};

interface HTMLSlotElement : HTMLElement {
  /*[CEReactions]*/ attribute DOMString name;
  sequence<Node> assignedNodes(optional AssignedNodesOptions options);
};

dictionary AssignedNodesOptions {
  boolean flatten = false;
};

typedef (CanvasRenderingContext2D or WebGLRenderingContext) RenderingContext;
callback BlobCallback = void (Blob? blob);

interface HTMLCanvasElement : HTMLElement {
           attribute unsigned long width;
           attribute unsigned long height;

  RenderingContext? getContext(DOMString contextId, any... arguments);

  DOMString toDataURL(optional DOMString type, any... arguments);
  void toBlob(BlobCallback _callback, optional DOMString type, any... arguments);
};

typedef (HTMLImageElement or
         SVGImageElement) HTMLOrSVGImageElement;

typedef (HTMLOrSVGImageElement or
         HTMLVideoElement or
         HTMLCanvasElement or
         ImageBitmap) CanvasImageSource;

enum CanvasFillRule { "nonzero", "evenodd" };

dictionary CanvasRenderingContext2DSettings {
  boolean alpha = true;
};

enum ImageSmoothingQuality { "low", "medium", "high" };

interface CanvasRenderingContext2D {
  // back-reference to the canvas
  readonly attribute HTMLCanvasElement canvas;
};
CanvasRenderingContext2D implements CanvasState;
CanvasRenderingContext2D implements CanvasTransform;
CanvasRenderingContext2D implements CanvasCompositing;
CanvasRenderingContext2D implements CanvasImageSmoothing;
CanvasRenderingContext2D implements CanvasFillStrokeStyles;
CanvasRenderingContext2D implements CanvasShadowStyles;
CanvasRenderingContext2D implements CanvasFilters;
CanvasRenderingContext2D implements CanvasRect;
CanvasRenderingContext2D implements CanvasDrawPath;
CanvasRenderingContext2D implements CanvasUserInterface;
CanvasRenderingContext2D implements CanvasText;
CanvasRenderingContext2D implements CanvasDrawImage;
CanvasRenderingContext2D implements CanvasHitRegion;
CanvasRenderingContext2D implements CanvasImageData;
CanvasRenderingContext2D implements CanvasPathDrawingStyles;
CanvasRenderingContext2D implements CanvasTextDrawingStyles;
CanvasRenderingContext2D implements CanvasPath;

[NoInterfaceObject]
interface CanvasState {
  // state
  void save(); // push state on state stack
  void restore(); // pop state stack and restore state
};

[NoInterfaceObject]
interface CanvasTransform {
  // transformations (default transform is the identity matrix)
  void scale(unrestricted double x, unrestricted double y);
  void rotate(unrestricted double angle);
  void translate(unrestricted double x, unrestricted double y);
  void transform(unrestricted double a, unrestricted double b, unrestricted double c, unrestricted double d, unrestricted double e, unrestricted double f);

  [NewObject] DOMMatrix getTransform();
  void setTransform(unrestricted double a, unrestricted double b, unrestricted double c, unrestricted double d, unrestricted double e, unrestricted double f);
  void setTransform(optional DOMMatrixInit transform);
  void resetTransform();

};

[NoInterfaceObject]
interface CanvasCompositing {
  // compositing
  attribute unrestricted double globalAlpha; // (default 1.0)
  attribute DOMString globalCompositeOperation; // (default source-over)
};

[NoInterfaceObject]
interface CanvasImageSmoothing {
  // image smoothing
  attribute boolean imageSmoothingEnabled; // (default true)
  attribute ImageSmoothingQuality imageSmoothingQuality; // (default low)

};

[NoInterfaceObject]
interface CanvasFillStrokeStyles {
  // colours and styles (see also the CanvasPathDrawingStyles and CanvasTextDrawingStyles interfaces)
  attribute (DOMString or CanvasGradient or CanvasPattern) strokeStyle; // (default black)
  attribute (DOMString or CanvasGradient or CanvasPattern) fillStyle; // (default black)
  CanvasGradient createLinearGradient(double x0, double y0, double x1, double y1);
  CanvasGradient createRadialGradient(double x0, double y0, double r0, double x1, double y1, double r1);
  CanvasPattern? createPattern(CanvasImageSource image, [TreatNullAs=EmptyString] DOMString repetition);

};

[NoInterfaceObject]
interface CanvasShadowStyles {
  // shadows
  attribute unrestricted double shadowOffsetX; // (default 0)
  attribute unrestricted double shadowOffsetY; // (default 0)
  attribute unrestricted double shadowBlur; // (default 0)
  attribute DOMString shadowColor; // (default transparent black)
};

[NoInterfaceObject]
interface CanvasFilters {
  // filters
  attribute DOMString filter; // (default "none")
};

[NoInterfaceObject]
interface CanvasRect {
  // rects
  void clearRect(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);
  void fillRect(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);
  void strokeRect(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);
};

[NoInterfaceObject]
interface CanvasDrawPath {
  // path API (see also CanvasPath)
  void beginPath();
  void fill(optional CanvasFillRule fillRule = "nonzero");
  void fill(Path2D path, optional CanvasFillRule fillRule = "nonzero");
  void stroke();
  void stroke(Path2D path);
  void clip(optional CanvasFillRule fillRule = "nonzero");
  void clip(Path2D path, optional CanvasFillRule fillRule = "nonzero");
  void resetClip();
  boolean isPointInPath(unrestricted double x, unrestricted double y, optional CanvasFillRule fillRule = "nonzero");
  boolean isPointInPath(Path2D path, unrestricted double x, unrestricted double y, optional CanvasFillRule fillRule = "nonzero");
  boolean isPointInStroke(unrestricted double x, unrestricted double y);
  boolean isPointInStroke(Path2D path, unrestricted double x, unrestricted double y);
};

[NoInterfaceObject]
interface CanvasUserInterface {
  void drawFocusIfNeeded(Element element);
  void drawFocusIfNeeded(Path2D path, Element element);
  void scrollPathIntoView();
  void scrollPathIntoView(Path2D path);
};

[NoInterfaceObject]
interface CanvasText {
  // text (see also the CanvasPathDrawingStyles and CanvasTextDrawingStyles interfaces)
  void fillText(DOMString text, unrestricted double x, unrestricted double y, optional unrestricted double maxWidth);
  void strokeText(DOMString text, unrestricted double x, unrestricted double y, optional unrestricted double maxWidth);
  TextMetrics measureText(DOMString text);
};

[NoInterfaceObject]
interface CanvasDrawImage {
  // drawing images
  void drawImage(CanvasImageSource image, unrestricted double dx, unrestricted double dy);
  void drawImage(CanvasImageSource image, unrestricted double dx, unrestricted double dy, unrestricted double dw, unrestricted double dh);
  void drawImage(CanvasImageSource image, unrestricted double sx, unrestricted double sy, unrestricted double sw, unrestricted double sh, unrestricted double dx, unrestricted double dy, unrestricted double dw, unrestricted double dh);
};

[NoInterfaceObject]
interface CanvasHitRegion {
  // hit regions
  void addHitRegion(optional HitRegionOptions options);
  void removeHitRegion(DOMString id);
  void clearHitRegions();
};

[NoInterfaceObject]
interface CanvasImageData {
  // pixel manipulation
  ImageData createImageData(double sw, double sh);
  ImageData createImageData(ImageData imagedata);
  ImageData getImageData(double sx, double sy, double sw, double sh);
  void putImageData(ImageData imagedata, double dx, double dy);
  void putImageData(ImageData imagedata, double dx, double dy, double dirtyX, double dirtyY, double dirtyWidth, double dirtyHeight);
};

enum CanvasLineCap { "butt", "round", "square" };
enum CanvasLineJoin { "round", "bevel", "miter"};
enum CanvasTextAlign { "start", "end", "left", "right", "center" };
enum CanvasTextBaseline { "top", "hanging", "middle", "alphabetic", "ideographic", "bottom" };
enum CanvasDirection { "ltr", "rtl", "inherit" };

[NoInterfaceObject]
interface CanvasPathDrawingStyles {
  // line caps/joins
  attribute unrestricted double lineWidth; // (default 1)
  attribute CanvasLineCap lineCap; // (default "butt")
  attribute CanvasLineJoin lineJoin; // (default "miter")
  attribute unrestricted double miterLimit; // (default 10)

  // dashed lines
  void setLineDash(sequence<unrestricted double> segments); // default empty
  sequence<unrestricted double> getLineDash();
  attribute unrestricted double lineDashOffset;
};

[NoInterfaceObject]
interface CanvasTextDrawingStyles {
  // text
  attribute DOMString font; // (default 10px sans-serif)
  attribute CanvasTextAlign textAlign; // (default: "start")
  attribute CanvasTextBaseline textBaseline; // (default: "alphabetic")
  attribute CanvasDirection direction; // (default: "inherit")
};

[NoInterfaceObject, Exposed=(Window,Worker)]
interface CanvasPath {
  // shared path API methods
  void closePath();
  void moveTo(unrestricted double x, unrestricted double y);
  void lineTo(unrestricted double x, unrestricted double y);
  void quadraticCurveTo(unrestricted double cpx, unrestricted double cpy, unrestricted double x, unrestricted double y);
  void bezierCurveTo(unrestricted double cp1x, unrestricted double cp1y, unrestricted double cp2x, unrestricted double cp2y, unrestricted double x, unrestricted double y);
  void arcTo(unrestricted double x1, unrestricted double y1, unrestricted double x2, unrestricted double y2, unrestricted double radius);
  void arcTo(unrestricted double x1, unrestricted double y1, unrestricted double x2, unrestricted double y2, unrestricted double radiusX, unrestricted double radiusY, unrestricted double rotation);
  void rect(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);
  void arc(unrestricted double x, unrestricted double y, unrestricted double radius, unrestricted double startAngle, unrestricted double endAngle, optional boolean anticlockwise = false);
  void ellipse(unrestricted double x, unrestricted double y, unrestricted double radiusX, unrestricted double radiusY, unrestricted double rotation, unrestricted double startAngle, unrestricted double endAngle, optional boolean anticlockwise = false);
};

interface CanvasGradient {
  // opaque object
  void addColorStop(double offset, DOMString color);
};

interface CanvasPattern {
  // opaque object
  void setTransform(optional DOMMatrixInit transform);
};

interface TextMetrics {
  // x-direction
  readonly attribute double width; // advance width
  readonly attribute double actualBoundingBoxLeft;
  readonly attribute double actualBoundingBoxRight;

  // y-direction
  readonly attribute double fontBoundingBoxAscent;
  readonly attribute double fontBoundingBoxDescent;
  readonly attribute double actualBoundingBoxAscent;
  readonly attribute double actualBoundingBoxDescent;
  readonly attribute double emHeightAscent;
  readonly attribute double emHeightDescent;
  readonly attribute double hangingBaseline;
  readonly attribute double alphabeticBaseline;
  readonly attribute double ideographicBaseline;
};

dictionary HitRegionOptions {
  Path2D? path = null;
  CanvasFillRule fillRule = "nonzero";
  DOMString id = "";
  DOMString? parentID = null;
  DOMString cursor = "inherit";
  // for control-backed regions:
  Element? control = null;
  // for unbacked regions:
  DOMString? label = null;
  DOMString? role = null;
};

[Constructor(unsigned long sw, unsigned long sh),
 Constructor(Uint8ClampedArray data, unsigned long sw, optional unsigned long sh),
 Exposed=(Window,Worker)]
interface ImageData {
  readonly attribute unsigned long width;
  readonly attribute unsigned long height;
  readonly attribute Uint8ClampedArray data;
};

[Constructor,
 Constructor(Path2D path),
 Constructor(sequence<Path2D> paths, optional CanvasFillRule fillRule = "nonzero"),
 Constructor(DOMString d), Exposed=(Window,Worker)]
interface Path2D {
  void addPath(Path2D path, optional DOMMatrixInit transform);
};
Path2D implements CanvasPath;

partial interface MouseEvent {
  readonly attribute DOMString? region;
};

// https://github.com/w3c/testharness.js/issues/84
//partial dictionary MouseEventInit {
//  DOMString? region;
//};

partial interface Touch {
  readonly attribute DOMString? region;
};

interface DataTransfer {
           attribute DOMString dropEffect;
           attribute DOMString effectAllowed;

  readonly attribute DataTransferItemList items;

  void setDragImage(Element image, long x, long y);

  /* old interface */
  readonly attribute DOMString[] types;
  DOMString getData(DOMString format);
  void setData(DOMString format, DOMString data);
  void clearData(optional DOMString format);
  readonly attribute FileList files;
};

interface DataTransferItemList {
  readonly attribute unsigned long length;
  getter DataTransferItem (unsigned long index);
  DataTransferItem? add(DOMString data, DOMString type);
  DataTransferItem? add(File data);
  void remove(unsigned long index);
  void clear();
};

interface DataTransferItem {
  readonly attribute DOMString kind;
  readonly attribute DOMString type;
  void getAsString(FunctionStringCallback? _callback);
  File? getAsFile();
};

callback FunctionStringCallback = void (DOMString data);

[Constructor(DOMString type, optional DragEventInit eventInitDict)]
interface DragEvent : MouseEvent {
  readonly attribute DataTransfer? dataTransfer;
};

dictionary DragEventInit : MouseEventInit {
  DataTransfer? dataTransfer;
};

// For purposes of this test, just treat WindowProxy as the same thing as
// Window.
typedef Window WindowProxy;

[PrimaryGlobal]
/*sealed*/ interface Window : EventTarget {
  // the current browsing context
  [Unforgeable] readonly attribute WindowProxy window;
  [Replaceable] readonly attribute WindowProxy self;
  [Unforgeable] readonly attribute Document document;
           attribute DOMString name;
  [PutForwards=href, Unforgeable] readonly attribute Location location;
  readonly attribute History history;
  [Replaceable] readonly attribute BarProp locationbar;
  [Replaceable] readonly attribute BarProp menubar;
  [Replaceable] readonly attribute BarProp personalbar;
  [Replaceable] readonly attribute BarProp scrollbars;
  [Replaceable] readonly attribute BarProp statusbar;
  [Replaceable] readonly attribute BarProp toolbar;
           attribute DOMString status;
  void close();
  readonly attribute boolean closed;
  void stop();
  void focus();
  void blur();

  // other browsing contexts
  [Replaceable] readonly attribute WindowProxy frames;
  [Replaceable] readonly attribute unsigned long length;
  [Unforgeable] readonly attribute WindowProxy top;
           attribute any opener;
  [Replaceable] readonly attribute WindowProxy parent;
  readonly attribute Element? frameElement;
  WindowProxy open(optional DOMString url = "about:blank", optional DOMString target = "_blank", [TreatNullAs=EmptyString] optional DOMString features = "", optional boolean replace = false);
  getter WindowProxy (unsigned long index);
  getter object (DOMString name);

  // the user agent
  readonly attribute Navigator navigator;
  [Replaceable] readonly attribute External external;
  readonly attribute ApplicationCache applicationCache;

  // user prompts
  void alert();
  //void alert(DOMString message);
  boolean confirm(optional DOMString message = "");
  DOMString? prompt(optional DOMString message = "", optional DOMString default = "");
  void print();
  any showModalDialog(DOMString url, optional any argument);

  void postMessage(any message, DOMString targetOrigin, optional sequence<Transferable> transfer);

  // also has obsolete members
};
Window implements GlobalEventHandlers;
Window implements WindowEventHandlers;

interface BarProp {
  readonly attribute boolean visible;
};

enum ScrollRestoration { "auto", "manual" };
interface History {

  readonly attribute long length;
  attribute ScrollRestoration scrollRestoration;
  readonly attribute any state;
  void go(optional long delta);
  void back();
  void forward();
  void pushState(any data, DOMString title, optional DOMString? url = null);
  void replaceState(any data, DOMString title, optional DOMString? url = null);
};

[Unforgeable] interface Location {
  stringifier attribute USVString href;
  readonly attribute USVString origin;
           attribute USVString protocol;
           attribute USVString host;
           attribute USVString hostname;
           attribute USVString port;
           attribute USVString pathname;
           attribute USVString search;
           attribute USVString hash;

  void assign(USVString url);
  void replace(USVString url);
  void reload();

  [SameObject] readonly attribute USVString[] ancestorOrigins;
};

[Constructor(DOMString type, optional PopStateEventInit eventInitDict), Exposed=(Window,Worker)]
interface PopStateEvent : Event {
  readonly attribute any state;
};

dictionary PopStateEventInit : EventInit {
  any state;
};

[Constructor(DOMString type, optional HashChangeEventInit eventInitDict), Exposed=(Window,Worker)]
interface HashChangeEvent : Event {
  readonly attribute DOMString oldURL;
  readonly attribute DOMString newURL;
};

dictionary HashChangeEventInit : EventInit {
  DOMString oldURL;
  DOMString newURL;
};

[Constructor(DOMString type, optional PageTransitionEventInit eventInitDict), Exposed=(Window,Worker)]
interface PageTransitionEvent : Event {
  readonly attribute boolean persisted;
};

dictionary PageTransitionEventInit : EventInit {
  boolean persisted;
};

interface BeforeUnloadEvent : Event {
           attribute DOMString returnValue;
};

[Exposed=(Window,SharedWorker)]
interface ApplicationCache : EventTarget {

  // update status
  const unsigned short UNCACHED = 0;
  const unsigned short IDLE = 1;
  const unsigned short CHECKING = 2;
  const unsigned short DOWNLOADING = 3;
  const unsigned short UPDATEREADY = 4;
  const unsigned short OBSOLETE = 5;
  readonly attribute unsigned short status;

  // updates
  void update();
  void abort();
  void swapCache();

  // events
           attribute EventHandler onchecking;
           attribute EventHandler onerror;
           attribute EventHandler onnoupdate;
           attribute EventHandler ondownloading;
           attribute EventHandler onprogress;
           attribute EventHandler onupdateready;
           attribute EventHandler oncached;
           attribute EventHandler onobsolete;
};

[NoInterfaceObject, Exposed=(Window,Worker)]
interface NavigatorOnLine {
  readonly attribute boolean onLine;
};

[Constructor(DOMString type, optional ErrorEventInit eventInitDict), Exposed=(Window,Worker)]
interface ErrorEvent : Event {
  readonly attribute DOMString message;
  readonly attribute DOMString filename;
  readonly attribute unsigned long lineno;
  readonly attribute unsigned long colno;
  readonly attribute any error;
};

dictionary ErrorEventInit : EventInit {
  DOMString message;
  DOMString filename;
  unsigned long lineno;
  unsigned long colno;
  any error;
};

[TreatNonCallableAsNull]
callback EventHandlerNonNull = any (Event event);
typedef EventHandlerNonNull? EventHandler;

[TreatNonCallableAsNull]
callback OnErrorEventHandlerNonNull = any ((Event or DOMString) event, optional DOMString source, optional unsigned long lineno, optional unsigned long column, optional any error);
typedef OnErrorEventHandlerNonNull? OnErrorEventHandler;

[TreatNonCallableAsNull]
callback OnBeforeUnloadEventHandlerNonNull = DOMString? (Event event);
typedef OnBeforeUnloadEventHandlerNonNull? OnBeforeUnloadEventHandler;

[NoInterfaceObject]
interface GlobalEventHandlers {
           attribute EventHandler onabort;
           attribute EventHandler onblur;
           attribute EventHandler oncancel;
           attribute EventHandler oncanplay;
           attribute EventHandler oncanplaythrough;
           attribute EventHandler onchange;
           attribute EventHandler onclick;
           attribute EventHandler onclose;
           attribute EventHandler oncontextmenu;
           attribute EventHandler oncuechange;
           attribute EventHandler ondblclick;
           attribute EventHandler ondrag;
           attribute EventHandler ondragend;
           attribute EventHandler ondragenter;
           attribute EventHandler ondragexit;
           attribute EventHandler ondragleave;
           attribute EventHandler ondragover;
           attribute EventHandler ondragstart;
           attribute EventHandler ondrop;
           attribute EventHandler ondurationchange;
           attribute EventHandler onemptied;
           attribute EventHandler onended;
           attribute OnErrorEventHandler onerror;
           attribute EventHandler onfocus;
           attribute EventHandler oninput;
           attribute EventHandler oninvalid;
           attribute EventHandler onkeydown;
           attribute EventHandler onkeypress;
           attribute EventHandler onkeyup;
           attribute EventHandler onload;
           attribute EventHandler onloadeddata;
           attribute EventHandler onloadedmetadata;
           attribute EventHandler onloadstart;
           attribute EventHandler onmousedown;
  [LenientThis] attribute EventHandler onmouseenter;
  [LenientThis] attribute EventHandler onmouseleave;
           attribute EventHandler onmousemove;
           attribute EventHandler onmouseout;
           attribute EventHandler onmouseover;
           attribute EventHandler onmouseup;
           attribute EventHandler onmousewheel;
           attribute EventHandler onpause;
           attribute EventHandler onplay;
           attribute EventHandler onplaying;
           attribute EventHandler onprogress;
           attribute EventHandler onratechange;
           attribute EventHandler onreset;
           attribute EventHandler onresize;
           attribute EventHandler onscroll;
           attribute EventHandler onseeked;
           attribute EventHandler onseeking;
           attribute EventHandler onselect;
           attribute EventHandler onshow;
           attribute EventHandler onstalled;
           attribute EventHandler onsubmit;
           attribute EventHandler onsuspend;
           attribute EventHandler ontimeupdate;
           attribute EventHandler ontoggle;
           attribute EventHandler onvolumechange;
           attribute EventHandler onwaiting;
};

[NoInterfaceObject]
interface DocumentAndElementEventHandlers {
           attribute EventHandler oncopy;
           attribute EventHandler oncut;
           attribute EventHandler onpaste;
};

[NoInterfaceObject]
interface WindowEventHandlers {
           attribute EventHandler onafterprint;
           attribute EventHandler onbeforeprint;
           attribute OnBeforeUnloadEventHandler onbeforeunload;
           attribute EventHandler onhashchange;
           attribute EventHandler onlanguagechange;
           attribute EventHandler onmessage;
           attribute EventHandler onoffline;
           attribute EventHandler ononline;
           attribute EventHandler onpagehide;
           attribute EventHandler onpageshow;
           attribute EventHandler onpopstate;
           attribute EventHandler onstorage;
           attribute EventHandler onunload;
};

[NoInterfaceObject, Exposed=(Window,Worker)]
interface WindowBase64 {
  DOMString btoa(DOMString btoa);
  DOMString atob(DOMString atob);
};
Window implements WindowBase64;

[NoInterfaceObject, Exposed=(Window,Worker)]
interface WindowTimers {
  long setTimeout(Function handler, optional long timeout = 0, any... arguments);
  long setTimeout(DOMString handler, optional long timeout = 0, any... arguments);
  void clearTimeout(optional long handle = 0);
  long setInterval(Function handler, optional long timeout = 0, any... arguments);
  long setInterval(DOMString handler, optional long timeout = 0, any... arguments);
  void clearInterval(optional long handle = 0);
};
Window implements WindowTimers;

[NoInterfaceObject]
interface WindowModal {
  readonly attribute any dialogArguments;
           attribute any returnValue;
};

interface Navigator {
  // objects implementing this interface also implement the interfaces given below
};
Navigator implements NavigatorID;
Navigator implements NavigatorLanguage;
Navigator implements NavigatorOnLine;
Navigator implements NavigatorContentUtils;
Navigator implements NavigatorCookies;
Navigator implements NavigatorPlugins;
Navigator implements NavigatorConcurrentHardware;

[NoInterfaceObject, Exposed=(Window,Worker)]
interface NavigatorID {
  [Exposed=Window] readonly attribute DOMString appCodeName; // constant "Mozilla"
  readonly attribute DOMString appName; // constant "Netscape"
  readonly attribute DOMString appVersion;
  readonly attribute DOMString platform;
  [Exposed=Window] readonly attribute DOMString product; // constant "Gecko"
  [Exposed=Window] readonly attribute DOMString productSub;
  readonly attribute DOMString userAgent;
  [Exposed=Window] readonly attribute DOMString vendor;
  [Exposed=Window] readonly attribute DOMString vendorSub; // constant ""
};

[NoInterfaceObject, Exposed=(Window,Worker)]
interface NavigatorLanguage {
  readonly attribute DOMString language;
  readonly attribute FrozenArray<DOMString> languages;
};

[NoInterfaceObject]
interface NavigatorContentUtils {
  // content handler registration
  void registerProtocolHandler(DOMString scheme, USVString url, DOMString title);
  void registerContentHandler(DOMString mimeType, USVString url, DOMString title);
  DOMString isProtocolHandlerRegistered(DOMString scheme, USVString url);
  DOMString isContentHandlerRegistered(DOMString mimeType, USVString url);
  void unregisterProtocolHandler(DOMString scheme, USVString url);
  void unregisterContentHandler(DOMString mimeType, USVString url);
};

[NoInterfaceObject]
interface NavigatorCookies {
  readonly attribute boolean cookieEnabled;
};

[NoInterfaceObject]
interface NavigatorPlugins {
  [SameObject] readonly attribute PluginArray plugins;
  [SameObject] readonly attribute MimeTypeArray mimeTypes;
  boolean javaEnabled();
};

interface PluginArray {
  void refresh(optional boolean reload = false);
  readonly attribute unsigned long length;
  getter Plugin? item(unsigned long index);
  getter Plugin? namedItem(DOMString name);
};

[NoInterfaceObject, Exposed=(Window,Worker)]
interface NavigatorConcurrentHardware {
  readonly attribute unsigned long long hardwareConcurrency;
};

interface MimeTypeArray {
  readonly attribute unsigned long length;
  getter MimeType? item(unsigned long index);
  getter MimeType? namedItem(DOMString name);
};

interface Plugin {
  readonly attribute DOMString name;
  readonly attribute DOMString description;
  readonly attribute DOMString filename;
  readonly attribute unsigned long length;
  getter MimeType? item(unsigned long index);
  getter MimeType? namedItem(DOMString name);
};

interface MimeType {
  readonly attribute DOMString type;
  readonly attribute DOMString description;
  readonly attribute DOMString suffixes; // comma-separated
  readonly attribute Plugin enabledPlugin;
};

interface External {
  void AddSearchProvider(DOMString engineURL);
  unsigned long IsSearchProviderInstalled(DOMString engineURL);
};

[Exposed=(Window,Worker)]
interface ImageBitmap {
  readonly attribute unsigned long width;
  readonly attribute unsigned long height;
};

typedef (HTMLImageElement or
         HTMLVideoElement or
         HTMLCanvasElement or
         Blob or
         ImageData or
         CanvasRenderingContext2D or
         ImageBitmap) ImageBitmapSource;

[NoInterfaceObject, Exposed=(Window,Worker)]
interface ImageBitmapFactories {
  Promise createImageBitmap(ImageBitmapSource image, optional long sx, long sy, long sw, long sh);
};
Window implements ImageBitmapFactories;
WorkerGlobalScope implements ImageBitmapFactories;

[Constructor(DOMString type, optional MessageEventInit eventInitDict), Exposed=(Window,Worker)]
interface MessageEvent : Event {
  readonly attribute any data;
  readonly attribute DOMString origin;
  readonly attribute DOMString lastEventId;
  readonly attribute (WindowProxy or MessagePort)? source;
  readonly attribute FrozenArray<MessagePort> ports;

  void initMessageEvent(DOMString type, boolean bubbles, boolean cancelable, any data, DOMString origin, DOMString lastEventId, (WindowProxy or MessagePort) source, sequence<MessagePort> ports);
};

dictionary MessageEventInit : EventInit {
  any data;
  DOMString origin;
  DOMString lastEventId;
  (WindowProxy or MessagePort)? source;
  sequence<MessagePort> ports;
};

[Constructor(DOMString url, optional EventSourceInit eventSourceInitDict), Exposed=(Window,Worker)]
interface EventSource : EventTarget {
  readonly attribute DOMString url;
  readonly attribute boolean withCredentials;

  // ready state
  const unsigned short CONNECTING = 0;
  const unsigned short OPEN = 1;
  const unsigned short CLOSED = 2;
  readonly attribute unsigned short readyState;

  // networking
           attribute EventHandler onopen;
           attribute EventHandler onmessage;
           attribute EventHandler onerror;
  void close();
};

dictionary EventSourceInit {
  boolean withCredentials = false;
};

enum BinaryType { "blob", "arraybuffer" };
[Constructor(DOMString url, optional (DOMString or DOMString[]) protocols), Exposed=(Window,Worker)]
interface WebSocket : EventTarget {
  readonly attribute DOMString url;

  // ready state
  const unsigned short CONNECTING = 0;
  const unsigned short OPEN = 1;
  const unsigned short CLOSING = 2;
  const unsigned short CLOSED = 3;
  readonly attribute unsigned short readyState;
  readonly attribute unsigned long bufferedAmount;

  // networking
  attribute EventHandler onopen;
  attribute EventHandler onerror;
  attribute EventHandler onclose;
  readonly attribute DOMString extensions;
  readonly attribute DOMString protocol;
  void close([Clamp] optional unsigned short code, optional USVString reason);

  // messaging
  attribute EventHandler onmessage;
  attribute BinaryType binaryType;
  void send(USVString data);
  void send(Blob data);
  void send(ArrayBuffer data);
  void send(ArrayBufferView data);
};

[Constructor(DOMString type, optional CloseEventInit eventInitDict), Exposed=(Window,Worker)]
interface CloseEvent : Event {
  readonly attribute boolean wasClean;
  readonly attribute unsigned short code;
  readonly attribute DOMString reason;
};

dictionary CloseEventInit : EventInit {
  boolean wasClean;
  unsigned short code;
  DOMString reason;
};

[Constructor, Exposed=(Window,Worker)]
interface MessageChannel {
  readonly attribute MessagePort port1;
  readonly attribute MessagePort port2;
};

[Exposed=(Window,Worker)]
interface MessagePort : EventTarget {
  void postMessage(any message, optional sequence<Transferable> transfer);
  void start();
  void close();

  // event handlers
           attribute EventHandler onmessage;
};
// MessagePort implements Transferable;

[Constructor(DOMString channel), Exposed=(Window,Worker)]
interface BroadcastChannel : EventTarget {
  readonly attribute DOMString name;
  void postMessage(any message);
  void close();
           attribute EventHandler onmessage;
};

[Exposed=Worker]
interface WorkerGlobalScope : EventTarget {
  readonly attribute WorkerGlobalScope self;
  readonly attribute WorkerLocation location;

  void close();
           attribute OnErrorEventHandler onerror;
           attribute EventHandler onlanguagechange;
           attribute EventHandler onoffline;
           attribute EventHandler ononline;

  // also has additional members in a partial interface
};

[Global=(Worker,DedicatedWorker),Exposed=DedicatedWorker]
/*sealed*/ interface DedicatedWorkerGlobalScope : WorkerGlobalScope {
  void postMessage(any message, optional sequence<Transferable> transfer);
           attribute EventHandler onmessage;
};

[Global=(Worker,SharedWorker),Exposed=SharedWorker]
/*sealed*/ interface SharedWorkerGlobalScope : WorkerGlobalScope {
  readonly attribute DOMString name;
  readonly attribute ApplicationCache applicationCache;
           attribute EventHandler onconnect;
};

[NoInterfaceObject, Exposed=(Window,Worker)]
interface AbstractWorker {
           attribute EventHandler onerror;
};

[Constructor(DOMString scriptURL), Exposed=(Window,Worker)]
interface Worker : EventTarget {
  void terminate();

  void postMessage(any message, optional sequence<Transferable> transfer);
           attribute EventHandler onmessage;
};
Worker implements AbstractWorker;

[Constructor(DOMString scriptURL, optional DOMString name), Exposed=(Window,Worker)]
interface SharedWorker : EventTarget {
  readonly attribute MessagePort port;
};
SharedWorker implements AbstractWorker;

partial interface WorkerGlobalScope { // not obsolete
  void importScripts(DOMString... urls);
  readonly attribute WorkerNavigator navigator;
};
WorkerGlobalScope implements WindowTimers;
WorkerGlobalScope implements WindowBase64;

[Exposed=Worker]
interface WorkerNavigator {};
WorkerNavigator implements NavigatorID;
WorkerNavigator implements NavigatorLanguage;
WorkerNavigator implements NavigatorOnLine;

[Exposed=Worker]
interface WorkerLocation {
  stringifier readonly attribute USVString href;
  readonly attribute USVString origin;
  readonly attribute USVString protocol;
  readonly attribute USVString host;
  readonly attribute USVString hostname;
  readonly attribute USVString port;
  readonly attribute USVString pathname;
  readonly attribute USVString search;
  readonly attribute USVString hash;
};

interface Storage {
  readonly attribute unsigned long length;
  DOMString? key(unsigned long index);
  getter DOMString? getItem(DOMString key);
  setter creator void setItem(DOMString key, DOMString value);
  deleter void removeItem(DOMString key);
  void clear();
};

[NoInterfaceObject]
interface WindowSessionStorage {
  readonly attribute Storage sessionStorage;
};
Window implements WindowSessionStorage;

[NoInterfaceObject]
interface WindowLocalStorage {
  readonly attribute Storage localStorage;
};
Window implements WindowLocalStorage;

[Constructor(DOMString type, optional StorageEventInit eventInitDict)]
interface StorageEvent : Event {
  readonly attribute DOMString? key;
  readonly attribute DOMString? oldValue;
  readonly attribute DOMString? newValue;
  readonly attribute DOMString url;
  readonly attribute Storage? storageArea;
};

dictionary StorageEventInit : EventInit {
  DOMString? key;
  DOMString? oldValue;
  DOMString? newValue;
  DOMString url;
  Storage? storageArea;
};

interface HTMLAppletElement : HTMLElement {
           attribute DOMString align;
           attribute DOMString alt;
           attribute DOMString archive;
           attribute DOMString code;
           attribute DOMString codeBase;
           attribute DOMString height;
           attribute unsigned long hspace;
           attribute DOMString name;
           attribute DOMString _object; // the underscore is not part of the identifier
           attribute unsigned long vspace;
           attribute DOMString width;
};

interface HTMLMarqueeElement : HTMLElement {
           attribute DOMString behavior;
           attribute DOMString bgColor;
           attribute DOMString direction;
           attribute DOMString height;
           attribute unsigned long hspace;
           attribute long loop;
           attribute unsigned long scrollAmount;
           attribute unsigned long scrollDelay;
           attribute boolean trueSpeed;
           attribute unsigned long vspace;
           attribute DOMString width;

           attribute EventHandler onbounce;
           attribute EventHandler onfinish;
           attribute EventHandler onstart;

  void start();
  void stop();
};

interface HTMLFrameSetElement : HTMLElement {
           attribute DOMString cols;
           attribute DOMString rows;
};
HTMLFrameSetElement implements WindowEventHandlers;

interface HTMLFrameElement : HTMLElement {
           attribute DOMString name;
           attribute DOMString scrolling;
           attribute DOMString src;
           attribute DOMString frameBorder;
           attribute DOMString longDesc;
           attribute boolean noResize;
  readonly attribute Document? contentDocument;
  readonly attribute WindowProxy? contentWindow;

  [TreatNullAs=EmptyString] attribute DOMString marginHeight;
  [TreatNullAs=EmptyString] attribute DOMString marginWidth;
};

partial interface HTMLAnchorElement {
           attribute DOMString coords;
           attribute DOMString charset;
           attribute DOMString name;
           attribute DOMString rev;
           attribute DOMString shape;
};

partial interface HTMLAreaElement {
           attribute boolean noHref;
};

partial interface HTMLBodyElement {
  [TreatNullAs=EmptyString] attribute DOMString text;
  [TreatNullAs=EmptyString] attribute DOMString link;
  [TreatNullAs=EmptyString] attribute DOMString vLink;
  [TreatNullAs=EmptyString] attribute DOMString aLink;
  [TreatNullAs=EmptyString] attribute DOMString bgColor;
                            attribute DOMString background;
};

partial interface HTMLBRElement {
           attribute DOMString clear;
};

partial interface HTMLTableCaptionElement {
           attribute DOMString align;
};

partial interface HTMLTableColElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;
           attribute DOMString width;
};

interface HTMLDirectoryElement : HTMLElement {
           attribute boolean compact;
};

partial interface HTMLDivElement {
           attribute DOMString align;
};

partial interface HTMLDListElement {
           attribute boolean compact;
};

partial interface HTMLEmbedElement {
           attribute DOMString align;
           attribute DOMString name;
};

interface HTMLFontElement : HTMLElement {
  [TreatNullAs=EmptyString] attribute DOMString color;
                            attribute DOMString face;
                            attribute DOMString size;
};

partial interface HTMLHeadingElement {
           attribute DOMString align;
};

partial interface HTMLHRElement {
           attribute DOMString align;
           attribute DOMString color;
           attribute boolean noShade;
           attribute DOMString size;
           attribute DOMString width;
};

partial interface HTMLHtmlElement {
           attribute DOMString version;
};

partial interface HTMLIFrameElement {
           attribute DOMString align;
           attribute DOMString scrolling;
           attribute DOMString frameBorder;
           attribute DOMString longDesc;

  [TreatNullAs=EmptyString] attribute DOMString marginHeight;
  [TreatNullAs=EmptyString] attribute DOMString marginWidth;
};

partial interface HTMLImageElement {
           attribute DOMString name;
           attribute DOMString lowsrc;
           attribute DOMString align;
           attribute unsigned long hspace;
           attribute unsigned long vspace;
           attribute DOMString longDesc;

  [TreatNullAs=EmptyString] attribute DOMString border;
};

partial interface HTMLInputElement {
           attribute DOMString align;
           attribute DOMString useMap;
};

partial interface HTMLLegendElement {
           attribute DOMString align;
};

partial interface HTMLLIElement {
           attribute DOMString type;
};

partial interface HTMLLinkElement {
           attribute DOMString charset;
           attribute DOMString rev;
           attribute DOMString target;
};

partial interface HTMLMenuElement {
           attribute boolean compact;
};

partial interface HTMLMetaElement {
           attribute DOMString scheme;
};

partial interface HTMLObjectElement {
           attribute DOMString align;
           attribute DOMString archive;
           attribute DOMString code;
           attribute boolean declare;
           attribute unsigned long hspace;
           attribute DOMString standby;
           attribute unsigned long vspace;
           attribute DOMString codeBase;
           attribute DOMString codeType;

  [TreatNullAs=EmptyString] attribute DOMString border;
};

partial interface HTMLOListElement {
           attribute boolean compact;
};

partial interface HTMLParagraphElement {
           attribute DOMString align;
};

partial interface HTMLParamElement {
           attribute DOMString type;
           attribute DOMString valueType;
};

partial interface HTMLPreElement {
           attribute long width;
};

partial interface HTMLScriptElement {
           attribute DOMString event;
           attribute DOMString htmlFor;
};

partial interface HTMLTableElement {
           attribute DOMString align;
           attribute DOMString border;
           attribute DOMString frame;
           attribute DOMString rules;
           attribute DOMString summary;
           attribute DOMString width;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
  [TreatNullAs=EmptyString] attribute DOMString cellPadding;
  [TreatNullAs=EmptyString] attribute DOMString cellSpacing;
};

partial interface HTMLTableSectionElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;
};

partial interface HTMLTableCellElement {
           attribute DOMString align;
           attribute DOMString axis;
           attribute DOMString height;
           attribute DOMString width;

           attribute DOMString ch;
           attribute DOMString chOff;
           attribute boolean noWrap;
           attribute DOMString vAlign;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
};

partial interface HTMLTableRowElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
};

partial interface HTMLUListElement {
           attribute boolean compact;
           attribute DOMString type;
};

partial interface Document {
  [TreatNullAs=EmptyString] attribute DOMString fgColor;
  [TreatNullAs=EmptyString] attribute DOMString linkColor;
  [TreatNullAs=EmptyString] attribute DOMString vlinkColor;
  [TreatNullAs=EmptyString] attribute DOMString alinkColor;
  [TreatNullAs=EmptyString] attribute DOMString bgColor;

  readonly attribute HTMLCollection anchors;
  readonly attribute HTMLCollection applets;

  void clear();
  void captureEvents();
  void releaseEvents();

  readonly attribute HTMLAllCollection all;
};

partial interface Window {
  void captureEvents();
  void releaseEvents();
};

</script>
<script>
"use strict";
var idlArray;
var errorVideo; // used to get a MediaError object
var iframe; // used to get a Document object (can't use `document` because some test clears the page)
setup(function() {
  idlArray = new IdlArray();
  [].forEach.call(document.querySelectorAll("script[type=text\\/plain]"), function(node) {
    if (node.className == "untested") {
      idlArray.add_untested_idls(node.textContent);
    } else {
      idlArray.add_idls(node.textContent);
    }
  });
  errorVideo = document.createElement('video');
  errorVideo.src = 'data:,';
  errorVideo.preload = 'auto';
  iframe = document.createElement('iframe');
  iframe.hidden = true;
  document.body.appendChild(iframe);
}, {explicit_done:true});

function createInput(type) {
  var input = document.createElement('input');
  input.type = type;
  return input;
}

window.onload = function() {
  idlArray.add_objects({
    NodeList: ['document.getElementsByName("name")'],
    HTMLAllCollection: ['document.all'],
    HTMLFormControlsCollection: ['document.createElement("form").elements'],
    RadioNodeList: [],
    HTMLOptionsCollection: ['document.createElement("select").options'],
    DOMStringMap: ['document.head.dataset'],
    Transferable: [],
    Document: ['iframe.contentDocument', 'new Document()'],
    XMLDocument: ['document.implementation.createDocument(null, "", null)'],
    HTMLElement: ['document.createElement("noscript")'], // more tests in html/semantics/interfaces.js
    HTMLUnknownElement: ['document.createElement("bgsound")'], // more tests in html/semantics/interfaces.js
    HTMLHtmlElement: ['document.createElement("html")'],
    HTMLHeadElement: ['document.createElement("head")'],
    HTMLTitleElement: ['document.createElement("title")'],
    HTMLBaseElement: ['document.createElement("base")'],
    HTMLLinkElement: ['document.createElement("link")'],
    HTMLMetaElement: ['document.createElement("meta")'],
    HTMLStyleElement: ['document.createElement("style")'],
    HTMLScriptElement: ['document.createElement("script")'],
    HTMLBodyElement: ['document.createElement("body")'],
    HTMLHeadingElement: ['document.createElement("h1")'],
    HTMLParagraphElement: ['document.createElement("p")'],
    HTMLHRElement: ['document.createElement("hr")'],
    HTMLPreElement: [
      'document.createElement("pre")',
      'document.createElement("listing")',
      'document.createElement("xmp")',
    ],
    HTMLQuoteElement: [
      'document.createElement("blockquote")',
      'document.createElement("q")',
    ],
    HTMLOlistElement: ['document.createElement("ol")'],
    HTMLUlistElement: ['document.createElement("ul")'],
    HTMLLIElement: ['document.createElement("li")'],
    HTMLDlistElement: ['document.createElement("dl")'],
    HTMLDivElement: ['document.createElement("div")'],
    HTMLAnchorElement: ['document.createElement("a")'],
    HTMLDataElement: ['document.createElement("data")'],
    HTMLTimeElement: ['document.createElement("time")'],
    HTMLSpanElement: ['document.createElement("span")'],
    HTMLBRElement: ['document.createElement("br")'],
    HTMLModElement: [
      'document.createElement("ins")',
      'document.createElement("del")',
    ],
    HTMLPictureElement: ['document.createElement("picture")'],
    HTMLImageElement: ['document.createElement("img")', 'new Image()'],
    HTMLIframeElement: ['document.createElement("iframe")'],
    HTMLEmbedElement: ['document.createElement("embed")'],
    HTMLObjectElement: ['document.createElement("object")'],
    HTMLParamElement: ['document.createElement("param")'],
    HTMLVideoElement: ['document.createElement("video")'],
    HTMLAudioElement: ['document.createElement("audio")', 'new Audio()'],
    HTMLSourceElement: ['document.createElement("source")'],
    HTMLTrackElement: ['document.createElement("track")'],
    HTMLMediaElement: [],
    MediaError: ['errorVideo.error'],
    AudioTrackList: [],
    AudioTrack: [],
    VideoTrackList: [],
    VideoTrack: [],
    TextTrackList: ['document.createElement("video").textTracks'],
    TextTrack: ['document.createElement("track").track'],
    TextTrackCueList: ['document.createElement("video").addTextTrack("subtitles").cues'],
    TextTrackCue: [],
    DataCue: [],
    TimeRanges: ['document.createElement("video").buffered'],
    TrackEvent: ['new TrackEvent("addtrack", {track:document.createElement("track").track})'],
    HTMLTemplateElement: ['document.createElement("template")'],
    HTMLSlotElement: ['document.createElement("slot")'],
    HTMLCanvasElement: ['document.createElement("canvas")'],
    CanvasRenderingContext2D: ['document.createElement("canvas").getContext("2d")'],
    CanvasGradient: [],
    CanvasPattern: [],
    TextMetrics: [],
    ImageData: [],
    HTMLMapElement: ['document.createElement("map")'],
    HTMLAreaElement: ['document.createElement("area")'],
    HTMLTableElement: ['document.createElement("table")'],
    HTMLTableCaptionElement: ['document.createElement("caption")'],
    HTMLTableColElement: [
      'document.createElement("colgroup")',
      'document.createElement("col")',
    ],
    HTMLTableSectionElement: [
      'document.createElement("tbody")',
      'document.createElement("thead")',
      'document.createElement("tfoot")',
    ],
    HTMLTableRowElement: ['document.createElement("tr")'],
    HTMLTableCellElement: [
      'document.createElement("td")',
      'document.createElement("th")',
    ],
    HTMLFormElement: ['document.createElement("form")'],
    HTMLFieldsetElement: ['document.createElement("fieldset")'],
    HTMLLegendElement: ['document.createElement("legend")'],
    HTMLLabelElement: ['document.createElement("label")'],
    HTMLInputElement: [
      'document.createElement("input")',
      'createInput("text")',
      'createInput("hidden")',
      'createInput("search")',
      'createInput("tel")',
      'createInput("url")',
      'createInput("email")',
      'createInput("password")',
      'createInput("date")',
      'createInput("month")',
      'createInput("week")',
      'createInput("time")',
      'createInput("datetime-local")',
      'createInput("number")',
      'createInput("range")',
      'createInput("color")',
      'createInput("checkbox")',
      'createInput("radio")',
      'createInput("file")',
      'createInput("submit")',
      'createInput("image")',
      'createInput("reset")',
      'createInput("button")'
    ],
    HTMLButtonElement: ['document.createElement("button")'],
    HTMLSelectElement: ['document.createElement("select")'],
    HTMLDataListElement: ['document.createElement("datalist")'],
    HTMLOptGroupElement: ['document.createElement("optgroup")'],
    HTMLOptionElement: ['document.createElement("option")', 'new Option()'],
    HTMLTextAreaElement: ['document.createElement("textarea")'],
    HTMLKeygenElement: ['document.createElement("keygen")'],
    HTMLOutputElement: ['document.createElement("output")'],
    HTMLProgressElement: ['document.createElement("progress")'],
    HTMLMeterElement: ['document.createElement("meter")'],
    ValidityState: ['document.createElement("input").validity'],
    HTMLDetailsElement: ['document.createElement("details")'],
    HTMLMenuElement: ['document.createElement("menu")'],
    Window: ['window'],
    BarProp: [],
    History: ['window.history'],
    Location: ['window.location'],
    PopStateEvent: ['new PopStateEvent("popstate", { data: {} })'],
    HashChangeEvent: [],
    PageTransitionEvent: [],
    BeforeUnloadEvent: [],
    ApplicationCache: ['window.applicationCache'],
    WindowModal: [],
    Navigator: ['window.navigator'],
    External: ['window.external'],
    DataTransfer: [],
    DataTransferItemList: [],
    DataTransferItem: [],
    DragEvent: [],
    NavigatorUserMediaError: [],
    MediaStream: [],
    LocalMediaStream: [],
    MediaStreamTrack: [],
    MediaStreamRecorder: [],
    PeerConnection: [],
    MediaStreamEvent: [],
    ErrorEvent: [],
    WebSocket: ['new WebSocket("ws://foo")'],
    CloseEvent: ['new CloseEvent("close")'],
    AbstractWorker: [],
    Worker: [],
    SharedWorker: [],
    MessageEvent: [],
    MessageChannel: [],
    MessagePort: [],
    HTMLAppletElement: ['document.createElement("applet")'],
    HTMLMarqueeElement: ['document.createElement("marquee")'],
    HTMLFrameSetElement: ['document.createElement("frameset")'],
    HTMLFrameElement: ['document.createElement("frame")'],
    HTMLDirectoryElement: ['document.createElement("dir")'],
    HTMLFontElement: ['document.createElement("font")'],
  });
  idlArray.prevent_multiple_testing("HTMLElement");
  idlArray.test();
  done();
};
</script>
