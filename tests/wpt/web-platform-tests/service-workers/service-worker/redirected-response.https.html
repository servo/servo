<!DOCTYPE html>
<title>Service Worker: Redirected response</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/common/get-host-info.sub.js"></script>
<script src="resources/test-helpers.sub.js"></script>
<script>
// Tests redirect behavior. It calls fetch_method(url, fetch_option) and tests
// the resulting response against the expected values. It also adds the
// response to |cache| and checks the cached response matches the expected
// values.
//
// |options|: a dictionary of parameters for the test
// |options.url|: the URL to fetch
// |options.fetch_option|: the options passed to |fetch_method|
// |options.fetch_method|: the method used to fetch. Useful for testing an
//                         iframe's fetch() vs. this page's fetch().
// |options.cache|: A Cache to add the response to
// |options.expected_redirected|: The value of response.redirected
function redirected_test(options) {
  return options.fetch_method.call(null, options.url, options.fetch_option).then(response => {
        var cloned_response = response.clone();
        assert_equals(
            response.redirected, options.expected_redirected,
            'The redirected flag of response must match. URL: ' + options.url);
        assert_equals(
            cloned_response.redirected, options.expected_redirected,
            'The redirected flag of cloned response must match. URL: ' + options.url);
        return options.cache.put(options.url, response);
      })
    .then(_ => options.cache.match(options.url))
    .then(response => {
        assert_equals(response.redirected, options.expected_redirected,
        'The redirected flag of response in CacheStorage must match. URL: ' +
        options.url);
      });
}

var host_info = get_host_info();
var REDIRECT_URL = host_info['HTTPS_ORIGIN'] +
                   '/service-workers/service-worker/resources/redirect.py?Redirect=';
var TARGET_URL = host_info['HTTPS_ORIGIN'] +
                 '/service-workers/service-worker/resources/simple.txt';
var REDIRECT_TO_TARGET_URL = REDIRECT_URL + encodeURIComponent(TARGET_URL);
var frame;
var cache;
var setup;

promise_test(t => {
    var SCOPE = 'resources/blank.html?redirected-response';
    var SCRIPT = 'resources/fetch-rewrite-worker.js';
    var CACHE_NAME = 'service-workers/service-worker/redirected-response';
    setup = service_worker_unregister_and_register(t, SCRIPT, SCOPE)
      .then(registration => {
          promise_test(function() {
              return registration.unregister();
            }, 'restore global state (service worker registration)');

          return wait_for_state(t, registration.installing, 'activated');
        })
      .then(_ => self.caches.open(CACHE_NAME))
      .then(c => {
          cache = c;

          promise_test(function() {
              return self.caches.delete(CACHE_NAME);
            }, 'restore global state (caches)');

          return with_iframe(SCOPE);
        })
      .then(f => {
          frame = f;

          add_completion_callback(function() {
              f.remove();
            });
        });
      return setup;
  }, 'initialize global state (service worker registration and caches)');

// ===============================================================
// Tests for requests that are out-of-scope of the service worker.
// ===============================================================
promise_test(t => setup
  .then(() => redirected_test({url: TARGET_URL,
                               fetch_option: {},
                               fetch_method: self.fetch,
                               cache: cache,
                               expected_redirected: false})),
  'mode: "follow", non-intercepted request, no server redirect');

promise_test(t => setup
  .then(() => redirected_test({url: REDIRECT_TO_TARGET_URL,
                               fetch_option: {},
                               fetch_method: self.fetch,
                               cache: cache,
                               expected_redirected: true})),
  'mode: "follow", non-intercepted request');

promise_test(t => setup
  .then(() => redirected_test({url: REDIRECT_TO_TARGET_URL + '&manual',
                               fetch_option: {redirect: 'manual'},
                               fetch_method: self.fetch,
                               cache: cache,
                               expected_redirected: false})),
  'mode: "manual", non-intercepted request');

promise_test(t => setup
    .then(() => promise_rejects(
                   t, new TypeError(),
                   self.fetch(REDIRECT_TO_TARGET_URL + '&error',
                              {redirect:'error'}),
                   'The redirect response from the server should be treated as' +
                   ' an error when the redirect flag of request was \'error\'.')),
  'mode: "error", non-intercepted request');

promise_test(t => setup
    .then(() => redirected_test({url:'./?url=' + encodeURIComponent(TARGET_URL),
                               fetch_option: {},
                               fetch_method: frame.contentWindow.fetch,
                               cache: cache,
                               expected_redirected: false})),
  'mode: "follow", no mode change, no server redirect');

// =======================================================
// Tests for requests that are in-scope of the service worker. The service
// worker returns a redirected response.
// =======================================================
promise_test(t => setup
    .then(() => redirected_test({url: './?url=' + encodeURIComponent(REDIRECT_TO_TARGET_URL) +
                                       '&original-redirect-mode=follow',
                                 fetch_option: {redirect: 'follow'},
                                 fetch_method: frame.contentWindow.fetch,
                                 cache: cache,
                                 expected_redirected: true})),
  'mode: "follow", no mode change');

promise_test(t => setup
    .then(() => promise_rejects(
                   t, new TypeError(),
                   frame.contentWindow.fetch(
                       './?url=' + encodeURIComponent(REDIRECT_TO_TARGET_URL) +
                       '&original-redirect-mode=error&redirect-mode=follow',
                       {redirect: 'error'}),
                   'The redirected response from the service worker should be ' +
                   'treated as an error when the redirect flag of request was ' +
                   '\'error\'.')),
  'mode: "error", mode change: "follow"');

promise_test(t => setup
    .then(() => promise_rejects(
                   t, new TypeError(),
                   frame.contentWindow.fetch(
                       './?url=' + encodeURIComponent(REDIRECT_TO_TARGET_URL) +
                       '&original-redirect-mode=manual&redirect-mode=follow',
                       {redirect: 'manual'}),
                   'The redirected response from the service worker should be ' +
                   'treated as an error when the redirect flag of request was ' +
                   '\'manual\'.')),
  'mode: "manual", mode change: "follow"');

// =======================================================
// Tests for requests that are in-scope of the service worker. The service
// worker returns an opaqueredirect response.
// =======================================================
promise_test(t => setup
    .then(() => promise_rejects(
                    t, new TypeError(),
                    frame.contentWindow.fetch(
                        './?url=' + encodeURIComponent(REDIRECT_TO_TARGET_URL) +
                        '&original-redirect-mode=follow&redirect-mode=manual',
                        {redirect: 'follow'}),
                    'The opaqueredirect response from the service worker should ' +
                    'be treated as an error when the redirect flag of request was' +
                    ' \'follow\'.')),
  'mode: "follow", mode change: "redirect"');

promise_test(t => setup
    .then(() => promise_rejects(
                    t, new TypeError(),
                    frame.contentWindow.fetch(
                        './?url=' + encodeURIComponent(REDIRECT_TO_TARGET_URL) +
                        '&original-redirect-mode=error&redirect-mode=manual',
                        {redirect: 'error'}),
                    'The opaqueredirect response from the service worker should ' +
                    'be treated as an error when the redirect flag of request was' +
                    ' \'error\'.')),
  'mode: "error", mode change: "manual"');

promise_test(t => setup
    .then(() => redirected_test({url: './?url=' + encodeURIComponent(REDIRECT_TO_TARGET_URL) +
                                        '&original-redirect-mode=manual&redirect-mode=manual',
                                 fetch_option: {redirect: 'manual'},
                                 fetch_method: frame.contentWindow.fetch,
                                 cache: cache,
                                 expected_redirected: false})),
  'mode: "manual", no mode change');
</script>
