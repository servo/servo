<!doctype html>
<title>RTCIceCandidate constructor</title>
<script src=/resources/testharness.js></script>
<script src=/resources/testharnessreport.js></script>
<script>
  'use strict';

  const candidateString = 'candidate:1905690388 1 udp 2113937151 192.168.0.1 58041 typ host generation 0 ufrag thC8 network-cost 50';
  const arbitraryString = '<arbitrary string[0] content>;';

  test(t => {
    // The argument for RTCIceCandidateInit is optional (w3c/webrtc-pc #1153 #1166),
    // but the constructor throws because both sdpMid and sdpMLineIndex are null by default.
    // Note that current browsers pass this test but may throw TypeError for
    // different reason, i.e. they don't accept empty argument.
    // Further tests below are used to differentiate the errors.
    assert_throws(new TypeError(), () => new RTCIceCandidate());
  }, 'new RTCIceCandidate()');

  test(t => {
    // All fields in RTCIceCandidateInit are optional,
    // but the constructor throws because both sdpMid and sdpMLineIndex are null by default.
    // Note that current browsers pass this test but may throw TypeError for
    // different reason, i.e. they don't allow undefined candidate string.
    // Further tests below are used to differentiate the errors.
    assert_throws(new TypeError(), () => new RTCIceCandidate({}));
  }, 'new RTCIceCandidate({})');

  test(t => {
    // Checks that manually filling the default values for RTCIceCandidateInit
    // still throws because both sdpMid and sdpMLineIndex are null
    assert_throws(new TypeError(),
      () => new RTCIceCandidate({
        candidate: '',
        sdpMid: null,
        sdpMLineIndex: null,
        ufrag: undefined
      }));
  }, 'new RTCIceCandidate({ ... }) with manually filled default values');

  test(t => {
    // Checks that explicitly setting both sdpMid and sdpMLineIndex null should throw
    assert_throws(new TypeError(),
      () => new RTCIceCandidate({
        sdpMid: null,
        sdpMLineIndex: null
      }));
  }, 'new RTCIceCandidate({ sdpMid: null, sdpMLineIndex: null })');

  test(t => {
    // Throws because both sdpMid and sdpMLineIndex are null by default
    assert_throws(new TypeError(),
      () => new RTCIceCandidate({
        candidate: ''
      }));
  }, `new RTCIceCandidate({ candidate: '' })`);

  test(t => {
    // Throws because the candidate field is not nullable
    assert_throws(new TypeError(),
      () => new RTCIceCandidate({
        candidate: null
      }));
  }, `new RTCIceCandidate({ candidate: null })`);

  test(t => {
    // Throws because both sdpMid and sdpMLineIndex are null by default
    assert_throws(new TypeError(),
      () => new RTCIceCandidate({
        candidate: candidateString
      }));
  }, 'new RTCIceCandidate({ ... }) with valid candidate string only');

  test(t => {
    const candidate = new RTCIceCandidate({ sdpMid: 'audio' });

    assert_equals(candidate.candidate, '');
    assert_equals(candidate.sdpMid, 'audio');
    assert_equals(candidate.sdpMLineIndex, null);
    assert_equals(candidate.ufrag, null);
  }, `new RTCIceCandidate({ sdpMid: 'audio' })`);

  test(t => {
    const candidate = new RTCIceCandidate({ sdpMLineIndex: 0 });

    assert_equals(candidate.candidate, '');
    assert_equals(candidate.sdpMid, null);
    assert_equals(candidate.sdpMLineIndex, 0);
    assert_equals(candidate.ufrag, null);
  }, 'new RTCIceCandidate({ sdpMLineIndex: 0 })');

  test(t => {
    const candidate = new RTCIceCandidate({
      sdpMid: 'audio',
      sdpMLineIndex: 0
    });

    assert_equals(candidate.candidate, '');
    assert_equals(candidate.sdpMid, 'audio');
    assert_equals(candidate.sdpMLineIndex, 0);
    assert_equals(candidate.ufrag, null);
  }, `new RTCIceCandidate({ sdpMid: 'audio', sdpMLineIndex: 0 })`);

  test(t => {
    const candidate = new RTCIceCandidate({
      candidate: '',
      sdpMid: 'audio'
    });

    assert_equals(candidate.candidate, '');
    assert_equals(candidate.sdpMid, 'audio');
    assert_equals(candidate.sdpMLineIndex, null);
    assert_equals(candidate.ufrag, null);
  }, `new RTCIceCandidate({ candidate: '', sdpMid: 'audio' }`);

  test(t => {
    const candidate = new RTCIceCandidate({
      candidate: '',
      sdpMLineIndex: 0
    });

    assert_equals(candidate.candidate, '');
    assert_equals(candidate.sdpMid, null);
    assert_equals(candidate.sdpMLineIndex, 0);
    assert_equals(candidate.ufrag, null);
  }, `new RTCIceCandidate({ candidate: '', sdpMLineIndex: 0 }`);

  test(t => {
    const candidate = new RTCIceCandidate({
      candidate: candidateString,
      sdpMid: 'audio'
    });

    assert_equals(candidate.candidate, candidateString);
    assert_equals(candidate.sdpMid, 'audio');
    assert_equals(candidate.sdpMLineIndex, null);
    assert_equals(candidate.ufrag, null);
  }, 'new RTCIceCandidate({ ... }) with valid candidate string and sdpMid');

  test(t =>{
    // candidate string is not validated in RTCIceCandidate
    const candidate = new RTCIceCandidate({
      candidate: arbitraryString,
      sdpMid: 'audio'
    });

    assert_equals(candidate.candidate, arbitraryString);
    assert_equals(candidate.sdpMid, 'audio');
    assert_equals(candidate.sdpMLineIndex, null);
    assert_equals(candidate.ufrag, null);
  }, 'new RTCIceCandidate({ ... }) with invalid candidate string and sdpMid');

  test(t => {
    const candidate = new RTCIceCandidate({
      candidate: candidateString,
      sdpMid: 'video',
      sdpMLineIndex: 1,
      ufrag: 'test'
    });

    assert_equals(candidate.candidate, candidateString);
    assert_equals(candidate.sdpMid, 'video');
    assert_equals(candidate.sdpMLineIndex, 1);
    assert_equals(candidate.ufrag, 'test');
  }, 'new RTCIceCandidate({ ... }) with non default value for all fields');


  test(t => {
    // sdpMid is not validated in RTCIceCandidate
    const candidate = new RTCIceCandidate({
      sdpMid: arbitraryString
    });

    assert_equals(candidate.candidate, '');
    assert_equals(candidate.sdpMid, arbitraryString);
    assert_equals(candidate.sdpMLineIndex, null);
    assert_equals(candidate.ufrag, null);
  }, 'new RTCIceCandidate({ ... }) with invalid sdpMid');


  test(t => {
    // Some arbitrary large out of bound line index that practically
    // do not reference any m= line in SDP.
    // However sdpMLineIndex is not validated in RTCIceCandidate
    // and it has no knowledge of the SDP it is associated with.
    const candidate = new RTCIceCandidate({
      sdpMLineIndex: 65535
    });

    assert_equals(candidate.candidate, '');
    assert_equals(candidate.sdpMid, null);
    assert_equals(candidate.sdpMLineIndex, 65535);
    assert_equals(candidate.ufrag, null);
  }, 'new RTCIceCandidate({ ... }) with invalid sdpMLineIndex');

</script>
