[abort.https.any.shadowrealm-in-serviceworker.html]
  expected: ERROR

[abort.any.shadowrealm-in-window.html]
  expected: ERROR

[abort.any.html]
  expected: ERROR
  [a signal argument 'null' should cause pipeTo() to reject]
    expected: FAIL

  [a signal argument 'AbortSignal' should cause pipeTo() to reject]
    expected: FAIL

  [a signal argument 'true' should cause pipeTo() to reject]
    expected: FAIL

  [a signal argument '-1' should cause pipeTo() to reject]
    expected: FAIL

  [a signal argument '[object AbortSignal\]' should cause pipeTo() to reject]
    expected: FAIL

  [an aborted signal should cause the writable stream to reject with an AbortError]
    expected: FAIL

  [(reason: 'null') all the error objects should be the same object]
    expected: FAIL

  [(reason: 'undefined') all the error objects should be the same object]
    expected: FAIL

  [(reason: 'error1: error1') all the error objects should be the same object]
    expected: FAIL

  [preventCancel should prevent canceling the readable]
    expected: FAIL

  [preventAbort should prevent aborting the readable]
    expected: FAIL

  [preventCancel and preventAbort should prevent canceling the readable and aborting the readable]
    expected: FAIL

  [(reason: 'null') abort should prevent further reads]
    expected: FAIL

  [(reason: 'undefined') abort should prevent further reads]
    expected: FAIL

  [(reason: 'error1: error1') abort should prevent further reads]
    expected: FAIL

  [(reason: 'null') all pending writes should complete on abort]
    expected: FAIL

  [(reason: 'undefined') all pending writes should complete on abort]
    expected: FAIL

  [(reason: 'error1: error1') all pending writes should complete on abort]
    expected: FAIL

  [(reason: 'null') underlyingSource.cancel() should called when abort, even with pending pull]
    expected: FAIL

  [(reason: 'undefined') underlyingSource.cancel() should called when abort, even with pending pull]
    expected: FAIL

  [(reason: 'error1: error1') underlyingSource.cancel() should called when abort, even with pending pull]
    expected: FAIL

  [a rejection from underlyingSource.cancel() should be returned by pipeTo()]
    expected: FAIL

  [a rejection from underlyingSink.abort() should be returned by pipeTo()]
    expected: FAIL

  [a rejection from underlyingSink.abort() should be preferred to one from underlyingSource.cancel()]
    expected: FAIL

  [abort signal takes priority over closed readable]
    expected: FAIL

  [abort signal takes priority over errored readable]
    expected: FAIL

  [abort signal takes priority over closed writable]
    expected: FAIL

  [abort signal takes priority over errored writable]
    expected: FAIL

  [abort should do nothing after the readable is closed]
    expected: FAIL

  [abort should do nothing after the readable is errored]
    expected: FAIL

  [abort should do nothing after the readable is errored, even with pending writes]
    expected: FAIL

  [abort should do nothing after the writable is errored]
    expected: FAIL

  [pipeTo on a teed readable byte stream should only be aborted when both branches are aborted]
    expected: FAIL


[abort.any.shadowrealm-in-dedicatedworker.html]
  expected: ERROR

[abort.any.sharedworker.html]
  expected: ERROR

[abort.any.shadowrealm-in-sharedworker.html]
  expected: ERROR

[abort.any.serviceworker.html]
  expected: ERROR

[abort.any.worker.html]
  expected: ERROR
  [a signal argument 'null' should cause pipeTo() to reject]
    expected: FAIL

  [a signal argument 'AbortSignal' should cause pipeTo() to reject]
    expected: FAIL

  [a signal argument 'true' should cause pipeTo() to reject]
    expected: FAIL

  [a signal argument '-1' should cause pipeTo() to reject]
    expected: FAIL

  [a signal argument '[object AbortSignal\]' should cause pipeTo() to reject]
    expected: FAIL

  [an aborted signal should cause the writable stream to reject with an AbortError]
    expected: FAIL

  [(reason: 'null') all the error objects should be the same object]
    expected: FAIL

  [(reason: 'undefined') all the error objects should be the same object]
    expected: FAIL

  [(reason: 'error1: error1') all the error objects should be the same object]
    expected: FAIL

  [preventCancel should prevent canceling the readable]
    expected: FAIL

  [preventAbort should prevent aborting the readable]
    expected: FAIL

  [preventCancel and preventAbort should prevent canceling the readable and aborting the readable]
    expected: FAIL

  [(reason: 'null') abort should prevent further reads]
    expected: FAIL

  [(reason: 'undefined') abort should prevent further reads]
    expected: FAIL

  [(reason: 'error1: error1') abort should prevent further reads]
    expected: FAIL

  [(reason: 'null') all pending writes should complete on abort]
    expected: FAIL

  [(reason: 'undefined') all pending writes should complete on abort]
    expected: FAIL

  [(reason: 'error1: error1') all pending writes should complete on abort]
    expected: FAIL

  [(reason: 'null') underlyingSource.cancel() should called when abort, even with pending pull]
    expected: FAIL

  [(reason: 'undefined') underlyingSource.cancel() should called when abort, even with pending pull]
    expected: FAIL

  [(reason: 'error1: error1') underlyingSource.cancel() should called when abort, even with pending pull]
    expected: FAIL

  [a rejection from underlyingSource.cancel() should be returned by pipeTo()]
    expected: FAIL

  [a rejection from underlyingSink.abort() should be returned by pipeTo()]
    expected: FAIL

  [a rejection from underlyingSink.abort() should be preferred to one from underlyingSource.cancel()]
    expected: FAIL

  [abort signal takes priority over closed readable]
    expected: FAIL

  [abort signal takes priority over errored readable]
    expected: FAIL

  [abort signal takes priority over closed writable]
    expected: FAIL

  [abort signal takes priority over errored writable]
    expected: FAIL

  [abort should do nothing after the readable is closed]
    expected: FAIL

  [abort should do nothing after the readable is errored]
    expected: FAIL

  [abort should do nothing after the readable is errored, even with pending writes]
    expected: FAIL

  [abort should do nothing after the writable is errored]
    expected: FAIL

  [pipeTo on a teed readable byte stream should only be aborted when both branches are aborted]
    expected: FAIL


[abort.https.any.shadowrealm-in-audioworklet.html]
  expected: ERROR

[abort.any.shadowrealm-in-shadowrealm.html]
  expected: ERROR
