[observable-from.any.worker.html]
  [from(): Observable.from() is a function]
    expected: FAIL

  [from(): Failed conversions]
    expected: FAIL

  [from(): Given an observable, it returns that exact observable]
    expected: FAIL

  [from(): Given an array]
    expected: FAIL

  [from(): Iterable converts to Observable]
    expected: FAIL

  [from(): [Symbol.iterator\] side-effects (one observable)]
    expected: FAIL

  [from(): [Symbol.iterator\] side-effects (many observables)]
    expected: FAIL

  [from(): [Symbol.iterator\] next() throws error]
    expected: FAIL

  [from(): Converts Promise to Observable]
    expected: FAIL

  [from(): Converts rejected Promise to Observable. No `unhandledrejection` event when error is handled by subscription]
    expected: FAIL

  [from(): Rejections not handled by subscription are reported to the global, and still not sent as an unhandledrejection event]
    expected: FAIL

  [from(): Observable that implements @@iterator protocol gets converted as an Observable, not iterator]
    expected: FAIL

  [from(): Promise that implements @@iterator protocol gets converted as an iterable, not Promise]
    expected: FAIL

  [from(): [Symbol.iterator\] not callable]
    expected: FAIL

  [from(): [Symbol.iterator\] is not cached]
    expected: FAIL

  [from(): Promise whose [Symbol.iterator\] returns null converts as Promise]
    expected: FAIL

  [from(): Rethrows the error when Converting an object whose @@iterator method *getter* throws an error]
    expected: FAIL

  [from(): Throws 'callable' error when @@iterator property is a non-callable primitive]
    expected: FAIL

  [from(): Async iterable protocol null, converts as iterator]
    expected: FAIL

  [from(): Asynchronous iterable conversion]
    expected: FAIL

  [from(): Asynchronous iterable multiple in-flight subscriptions competing]
    expected: FAIL

  [from(): Asynchronous generator conversion: can only be used once]
    expected: FAIL

  [from(): Promise-wrapping semantics of IteratorResult interface]
    expected: FAIL

  [from(): Errors thrown in Symbol.asyncIterator() are propagated synchronously]
    expected: FAIL

  [from(): Errors thrown in async iterator's next() GETTER are propagated in a microtask]
    expected: FAIL

  [from(): Errors thrown in async iterator's next() are propagated in a microtask]
    expected: FAIL

  [from(): Aborting sync iterable midway through iteration both stops iteration and invokes `IteratorRecord#return()]
    expected: FAIL

  [from(): Asynchronous iterable conversion, with synchronous iterable fallback]
    expected: FAIL

  [from(): Generator finally block runs when subscription is aborted]
    expected: FAIL

  [from(): Generator finally block run when Observable completes]
    expected: FAIL

  [from(): Generator finally block run when Observable errors]
    expected: FAIL

  [from(): Async generator finally block run when subscription is aborted]
    expected: FAIL

  [from(): Async generator finally block runs when Observable completes]
    expected: FAIL

  [from(): Async generator finally block run when Observable errors]
    expected: FAIL

  [from(): Sync iterable multiple in-flight subscriptions competing]
    expected: FAIL

  [from(): Aborting async iterable midway through iteration both stops iteration and invokes `IteratorRecord#return()]
    expected: FAIL

  [from(): Sync iterable: `Iterator#return()` must return an Object, or an error is thrown]
    expected: FAIL

  [from(): Async iterable: `Iterator#return()` must return an Object, or a Promise rejects asynchronously]
    expected: FAIL

  [from(): Sync iterable: error thrown from IteratorRecord#return() can be synchronously caught]
    expected: FAIL

  [from(): Async iterable: error thrown from IteratorRecord#return() is wrapped in rejected Promise]
    expected: FAIL

  [from(): Subscribing to an iterable Observable with an aborted signal does not call next()]
    expected: FAIL

  [from(): When iterable conversion aborts the subscription, next() is never called]
    expected: FAIL

  [from(): When async iterable conversion aborts the subscription, next() is never called]
    expected: FAIL

  [from(): Aborting an async iterable subscription stops subsequent next() calls, but old next() Promise reactions are web-observable]
    expected: FAIL

  [from(): Abort after complete does NOT call IteratorRecord#return()]
    expected: FAIL

  [from(): [Symbol.iterator\] not callable AFTER SUBSCRIBE throws]
    expected: FAIL

  [from(): [Symbol.iterator\] returns null AFTER SUBSCRIBE throws]
    expected: FAIL

  [Invalid async iterator protocol error is surfaced before Subscriber#signal is consulted]
    expected: FAIL

  [Invalid iterator protocol error is surfaced before Subscriber#signal is consulted]
    expected: FAIL

  [from(): Asynchronous iterable multiple in-flight subscriptions]
    expected: FAIL

  [from(): Sync iterable multiple in-flight subscriptions]
    expected: FAIL


[observable-from.any.html]
  [from(): Observable.from() is a function]
    expected: FAIL

  [from(): Failed conversions]
    expected: FAIL

  [from(): Given an observable, it returns that exact observable]
    expected: FAIL

  [from(): Given an array]
    expected: FAIL

  [from(): Iterable converts to Observable]
    expected: FAIL

  [from(): [Symbol.iterator\] side-effects (one observable)]
    expected: FAIL

  [from(): [Symbol.iterator\] side-effects (many observables)]
    expected: FAIL

  [from(): [Symbol.iterator\] next() throws error]
    expected: FAIL

  [from(): Converts Promise to Observable]
    expected: FAIL

  [from(): Converts rejected Promise to Observable. No `unhandledrejection` event when error is handled by subscription]
    expected: FAIL

  [from(): Rejections not handled by subscription are reported to the global, and still not sent as an unhandledrejection event]
    expected: FAIL

  [from(): Observable that implements @@iterator protocol gets converted as an Observable, not iterator]
    expected: FAIL

  [from(): Promise that implements @@iterator protocol gets converted as an iterable, not Promise]
    expected: FAIL

  [from(): [Symbol.iterator\] not callable]
    expected: FAIL

  [from(): [Symbol.iterator\] is not cached]
    expected: FAIL

  [from(): Promise whose [Symbol.iterator\] returns null converts as Promise]
    expected: FAIL

  [from(): Rethrows the error when Converting an object whose @@iterator method *getter* throws an error]
    expected: FAIL

  [from(): Throws 'callable' error when @@iterator property is a non-callable primitive]
    expected: FAIL

  [from(): Async iterable protocol null, converts as iterator]
    expected: FAIL

  [from(): Asynchronous iterable conversion]
    expected: FAIL

  [from(): Asynchronous iterable multiple in-flight subscriptions competing]
    expected: FAIL

  [from(): Asynchronous generator conversion: can only be used once]
    expected: FAIL

  [from(): Promise-wrapping semantics of IteratorResult interface]
    expected: FAIL

  [from(): Errors thrown in Symbol.asyncIterator() are propagated synchronously]
    expected: FAIL

  [from(): Errors thrown in async iterator's next() GETTER are propagated in a microtask]
    expected: FAIL

  [from(): Errors thrown in async iterator's next() are propagated in a microtask]
    expected: FAIL

  [from(): Aborting sync iterable midway through iteration both stops iteration and invokes `IteratorRecord#return()]
    expected: FAIL

  [from(): Asynchronous iterable conversion, with synchronous iterable fallback]
    expected: FAIL

  [from(): Generator finally block runs when subscription is aborted]
    expected: FAIL

  [from(): Generator finally block run when Observable completes]
    expected: FAIL

  [from(): Generator finally block run when Observable errors]
    expected: FAIL

  [from(): Async generator finally block run when subscription is aborted]
    expected: FAIL

  [from(): Async generator finally block runs when Observable completes]
    expected: FAIL

  [from(): Async generator finally block run when Observable errors]
    expected: FAIL

  [from(): Sync iterable multiple in-flight subscriptions competing]
    expected: FAIL

  [from(): Aborting async iterable midway through iteration both stops iteration and invokes `IteratorRecord#return()]
    expected: FAIL

  [from(): Sync iterable: `Iterator#return()` must return an Object, or an error is thrown]
    expected: FAIL

  [from(): Async iterable: `Iterator#return()` must return an Object, or a Promise rejects asynchronously]
    expected: FAIL

  [from(): Sync iterable: error thrown from IteratorRecord#return() can be synchronously caught]
    expected: FAIL

  [from(): Async iterable: error thrown from IteratorRecord#return() is wrapped in rejected Promise]
    expected: FAIL

  [from(): Subscribing to an iterable Observable with an aborted signal does not call next()]
    expected: FAIL

  [from(): When iterable conversion aborts the subscription, next() is never called]
    expected: FAIL

  [from(): When async iterable conversion aborts the subscription, next() is never called]
    expected: FAIL

  [from(): Aborting an async iterable subscription stops subsequent next() calls, but old next() Promise reactions are web-observable]
    expected: FAIL

  [from(): Abort after complete does NOT call IteratorRecord#return()]
    expected: FAIL

  [from(): [Symbol.iterator\] not callable AFTER SUBSCRIBE throws]
    expected: FAIL

  [from(): [Symbol.iterator\] returns null AFTER SUBSCRIBE throws]
    expected: FAIL

  [Invalid async iterator protocol error is surfaced before Subscriber#signal is consulted]
    expected: FAIL

  [Invalid iterator protocol error is surfaced before Subscriber#signal is consulted]
    expected: FAIL

  [from(): Asynchronous iterable multiple in-flight subscriptions]
    expected: FAIL

  [from(): Sync iterable multiple in-flight subscriptions]
    expected: FAIL
