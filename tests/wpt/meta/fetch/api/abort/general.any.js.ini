[general.any.sharedworker.html]
  expected: ERROR

[general.any.serviceworker.html]
  expected: ERROR

[general.any.html]
  [Aborting rejects with AbortError]
    expected: FAIL

  [Aborting rejects with AbortError - no-cors]
    expected: FAIL

  [TypeError from request constructor takes priority - RequestInit's window is not null]
    expected: FAIL

  [TypeError from request constructor takes priority - Input URL is not valid]
    expected: FAIL

  [TypeError from request constructor takes priority - Input URL has credentials]
    expected: FAIL

  [TypeError from request constructor takes priority - RequestInit's mode is navigate]
    expected: FAIL

  [TypeError from request constructor takes priority - RequestInit's referrer is invalid]
    expected: FAIL

  [TypeError from request constructor takes priority - RequestInit's method is invalid]
    expected: FAIL

  [TypeError from request constructor takes priority - RequestInit's method is forbidden]
    expected: FAIL

  [TypeError from request constructor takes priority - RequestInit's mode is no-cors and method is not simple]
    expected: FAIL

  [TypeError from request constructor takes priority - RequestInit's cache mode is only-if-cached and mode is not same-origin]
    expected: FAIL

  [TypeError from request constructor takes priority - Request with cache mode: only-if-cached and fetch mode cors]
    expected: FAIL

  [TypeError from request constructor takes priority - Request with cache mode: only-if-cached and fetch mode no-cors]
    expected: FAIL

  [TypeError from request constructor takes priority - Bad referrerPolicy init parameter value]
    expected: FAIL

  [TypeError from request constructor takes priority - Bad mode init parameter value]
    expected: FAIL

  [TypeError from request constructor takes priority - Bad credentials init parameter value]
    expected: FAIL

  [TypeError from request constructor takes priority - Bad cache init parameter value]
    expected: FAIL

  [TypeError from request constructor takes priority - Bad redirect init parameter value]
    expected: FAIL

  [Request objects have a signal property]
    expected: FAIL

  [Signal on request object]
    expected: FAIL

  [Signal on request object created from request object]
    expected: FAIL

  [Signal on request object created from request object, with signal on second request]
    expected: FAIL

  [Signal on request object created from request object, with signal on second request overriding another]
    expected: FAIL

  [Signal retained after unrelated properties are overridden by fetch]
    expected: FAIL

  [Signal removed by setting to null]
    expected: FAIL

  [Already aborted signal rejects immediately]
    expected: FAIL

  [Request is still 'used' if signal is aborted before fetching]
    expected: FAIL

  [response.arrayBuffer() rejects if already aborted]
    expected: FAIL

  [response.blob() rejects if already aborted]
    expected: FAIL

  [response.formData() rejects if already aborted]
    expected: FAIL

  [response.json() rejects if already aborted]
    expected: FAIL

  [response.text() rejects if already aborted]
    expected: FAIL

  [Call text() twice on aborted response]
    expected: FAIL

  [Already aborted signal does not make request]
    expected: FAIL

  [Already aborted signal can be used for many fetches]
    expected: FAIL

  [Signal can be used to abort other fetches, even if another fetch succeeded before aborting]
    expected: FAIL

  [Underlying connection is closed when aborting after receiving response]
    expected: FAIL

  [Underlying connection is closed when aborting after receiving response - no-cors]
    expected: FAIL

  [Fetch aborted & connection closed when aborted after calling response.arrayBuffer()]
    expected: FAIL

  [Fetch aborted & connection closed when aborted after calling response.blob()]
    expected: FAIL

  [Fetch aborted & connection closed when aborted after calling response.formData()]
    expected: FAIL

  [Fetch aborted & connection closed when aborted after calling response.json()]
    expected: FAIL

  [Fetch aborted & connection closed when aborted after calling response.text()]
    expected: FAIL

  [Stream errors once aborted. Underlying connection closed.]
    expected: FAIL

  [Stream errors once aborted, after reading. Underlying connection closed.]
    expected: FAIL

  [Stream will not error if body is empty. It's closed with an empty queue before it errors.]
    expected: FAIL

  [Readable stream synchronously cancels with AbortError if aborted before reading]
    expected: FAIL

  [Signal state is cloned]
    expected: FAIL

  [Clone aborts with original controller]
    expected: FAIL

  [Aborting rejects with abort reason]
    expected: FAIL

  [Signal on request object should also have abort reason]
    expected: FAIL

  [response.bytes() rejects if already aborted]
    expected: FAIL

  [Fetch aborted & connection closed when aborted after calling response.bytes()]
    expected: FAIL


[general.any.worker.html]
  [Aborting rejects with AbortError]
    expected: FAIL

  [Aborting rejects with AbortError - no-cors]
    expected: FAIL

  [TypeError from request constructor takes priority - RequestInit's window is not null]
    expected: FAIL

  [TypeError from request constructor takes priority - Input URL is not valid]
    expected: FAIL

  [TypeError from request constructor takes priority - Input URL has credentials]
    expected: FAIL

  [TypeError from request constructor takes priority - RequestInit's mode is navigate]
    expected: FAIL

  [TypeError from request constructor takes priority - RequestInit's referrer is invalid]
    expected: FAIL

  [TypeError from request constructor takes priority - RequestInit's method is invalid]
    expected: FAIL

  [TypeError from request constructor takes priority - RequestInit's method is forbidden]
    expected: FAIL

  [TypeError from request constructor takes priority - RequestInit's mode is no-cors and method is not simple]
    expected: FAIL

  [TypeError from request constructor takes priority - RequestInit's cache mode is only-if-cached and mode is not same-origin]
    expected: FAIL

  [TypeError from request constructor takes priority - Request with cache mode: only-if-cached and fetch mode cors]
    expected: FAIL

  [TypeError from request constructor takes priority - Request with cache mode: only-if-cached and fetch mode no-cors]
    expected: FAIL

  [TypeError from request constructor takes priority - Bad referrerPolicy init parameter value]
    expected: FAIL

  [TypeError from request constructor takes priority - Bad mode init parameter value]
    expected: FAIL

  [TypeError from request constructor takes priority - Bad credentials init parameter value]
    expected: FAIL

  [TypeError from request constructor takes priority - Bad cache init parameter value]
    expected: FAIL

  [TypeError from request constructor takes priority - Bad redirect init parameter value]
    expected: FAIL

  [Request objects have a signal property]
    expected: FAIL

  [Signal on request object]
    expected: FAIL

  [Signal on request object created from request object]
    expected: FAIL

  [Signal on request object created from request object, with signal on second request]
    expected: FAIL

  [Signal on request object created from request object, with signal on second request overriding another]
    expected: FAIL

  [Signal retained after unrelated properties are overridden by fetch]
    expected: FAIL

  [Signal removed by setting to null]
    expected: FAIL

  [Already aborted signal rejects immediately]
    expected: FAIL

  [Request is still 'used' if signal is aborted before fetching]
    expected: FAIL

  [response.arrayBuffer() rejects if already aborted]
    expected: FAIL

  [response.blob() rejects if already aborted]
    expected: FAIL

  [response.formData() rejects if already aborted]
    expected: FAIL

  [response.json() rejects if already aborted]
    expected: FAIL

  [response.text() rejects if already aborted]
    expected: FAIL

  [Call text() twice on aborted response]
    expected: FAIL

  [Already aborted signal does not make request]
    expected: FAIL

  [Already aborted signal can be used for many fetches]
    expected: FAIL

  [Signal can be used to abort other fetches, even if another fetch succeeded before aborting]
    expected: FAIL

  [Underlying connection is closed when aborting after receiving response]
    expected: FAIL

  [Underlying connection is closed when aborting after receiving response - no-cors]
    expected: FAIL

  [Fetch aborted & connection closed when aborted after calling response.arrayBuffer()]
    expected: FAIL

  [Fetch aborted & connection closed when aborted after calling response.blob()]
    expected: FAIL

  [Fetch aborted & connection closed when aborted after calling response.formData()]
    expected: FAIL

  [Fetch aborted & connection closed when aborted after calling response.json()]
    expected: FAIL

  [Fetch aborted & connection closed when aborted after calling response.text()]
    expected: FAIL

  [Stream errors once aborted. Underlying connection closed.]
    expected: FAIL

  [Stream errors once aborted, after reading. Underlying connection closed.]
    expected: FAIL

  [Stream will not error if body is empty. It's closed with an empty queue before it errors.]
    expected: FAIL

  [Readable stream synchronously cancels with AbortError if aborted before reading]
    expected: FAIL

  [Signal state is cloned]
    expected: FAIL

  [Clone aborts with original controller]
    expected: FAIL

  [Aborting rejects with abort reason]
    expected: FAIL

  [Signal on request object should also have abort reason]
    expected: FAIL

  [response.bytes() rejects if already aborted]
    expected: FAIL

  [Fetch aborted & connection closed when aborted after calling response.bytes()]
    expected: FAIL
