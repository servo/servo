#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Mar 26 20:08:25 2018

@author: Pranshu Sinha, Abhay Soni, Aayushi Agrawal
"""

"""
The below program is intended to test rendering mismatches in servo based on random web pages generated by the web page fuzzer.

Here is the breakdown of how our code works:
*   A session is started on localhost:7002
*   The randomly generated webpage's (html files) data is sent as JSON to this session
*   Using curl request, we load the html files for this session ID based on the session we just created
*   For each html file it renders, it takes the screenshot after rendering which is saved in the current working directory in the format "testing#.png"
"""
import os
import subprocess
import json
import requests
import start_servo
import time

#The below function is used to start servo on localhost:7002
start_servo.start_servo()

#Since servo takes time to load and to get the session ID for subsequent steps, we added a sleep for 60 seconds
time.sleep(60)

#The program assumes that the html files to be rendered in servo are present in the same current working directory in the format "file#.html"
cwd = os.getcwd()
url = 'http://localhost:7002/session'
payload = "{}"
headers = {'content-type': 'application/json', 'Accept-Charset': 'UTF-8'}
r = requests.post(url, data=payload, headers=headers)
json_string = r.json()
#Currently, we have generated 5 random html pages, hence the loop runs for 5 iterations
for x in range(5):
    json_data = {}
    json_data['url'] = 'file://'+cwd+'/file'+str(x)+'.html'
    json_data = json.dumps(json_data)
    url2 = 'http://localhost:7002/session/'+json_string['value']['sessionId']+'/url'
    payload2 = json_data
    headers2 = {'content-type': 'application/json', 'Accept-Charset': 'UTF-8'}
    r2 = requests.post(url2, data=payload2, headers=headers2)
    
    curl_command2 = 'curl -v http://localhost:7002/session/'+json_string['value']['sessionId']+'/screenshot | jq -r ".value" | base64 -d > testing'+str(x)+'.png'
    
    p = subprocess.Popen(curl_command2, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate()
    os.system(curl_command2)
start_servo.stop_servo()