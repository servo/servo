use std::{
    collections::BTreeMap,
    io::{BufRead, BufReader, Read, Write},
    net::TcpStream,
    str,
};

use jane_eyre::eyre;
use serde::{Deserialize, Serialize};
use serde_json::Value;

// <https://firefox-source-docs.mozilla.org/devtools/backend/protocol.html#id1>
pub trait DevtoolsWrite {
    /// <https://firefox-source-docs.mozilla.org/devtools/backend/protocol.html#json-packets>
    fn write_json_packet<T: Serialize>(&mut self, message: &T) -> eyre::Result<()>;
}

// <https://firefox-source-docs.mozilla.org/devtools/backend/protocol.html#id1>
pub trait DevtoolsRead {
    /// <https://firefox-source-docs.mozilla.org/devtools/backend/protocol.html#json-packets>
    fn read_packet(&mut self) -> eyre::Result<Message>;
}

impl DevtoolsWrite for TcpStream {
    fn write_json_packet<T: Serialize>(&mut self, message: &T) -> eyre::Result<()> {
        let result = serde_json::to_string(message)?;
        let result = format!("{}:{}", result.len(), result);
        self.write_all(result.as_bytes())?;
        Ok(())
    }
}

impl DevtoolsRead for BufReader<TcpStream> {
    fn read_packet(&mut self) -> eyre::Result<Message> {
        let mut prefix = vec![];
        self.read_until(b':', &mut prefix)?;
        let Some(prefix) = prefix.strip_suffix(b":") else {
            panic!("Unexpected EOF")
        };
        let prefix = str::from_utf8(&prefix)?;

        // TODO: implement bulk packets
        let len = prefix.parse::<usize>()?;
        let mut result = vec![0u8; len];
        self.read_exact(&mut result)?;

        Ok(serde_json::from_slice(&result)?)
    }
}

/// Message wrapped in an object with a `_to` or `_from` field, as generated by `devtools_parser.py --json`.
#[derive(Debug, Deserialize, Serialize)]
pub struct WrappedMessage {
    pub message: Message,
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
#[serde(untagged)]
pub enum Message {
    Server {
        from: String,
        r#type: Option<String>,
        #[serde(flatten)]
        rest: BTreeMap<String, Value>,
    },
    Client {
        to: String,
        r#type: Option<String>,
        #[serde(flatten)]
        rest: BTreeMap<String, Value>,
    },
}

#[derive(Debug, Deserialize, Serialize)]
pub struct ResourcesAvailableArray {
    pub from: String,
    pub r#type: String,
    pub array: Vec<(String, Vec<Value>)>,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct EmptyResponse {
    pub from: String,
}
