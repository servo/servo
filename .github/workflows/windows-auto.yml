name: Windows (auto runner)

# Keep this block and the two “with” blocks below in sync with the underlying
# platform workflow, to ensure all of its inputs are forwarded correctly.
# FIXME: no way to make this generic for workflows with other inputs, unless we
# generate the YAML programmatically.
on:
  workflow_call:
    inputs:
      profile:
        required: false
        default: "release"
        type: string
      unit-tests:
        required: false
        default: false
        type: boolean
      upload:
        required: false
        default: false
        type: boolean
      github-release-id:
        required: false
        type: string
  workflow_dispatch:
    inputs:
      profile:
        required: false
        default: "release"
        options: ["release", "debug", "production"]
        type: choice
      unit-tests:
        required: false
        default: false
        type: boolean
      upload:
        required: false
        default: false
        type: boolean

jobs:
  # Generate a unique id that distinguishes this auto-runner build from other
  # auto-runner builds in the same workflow call tree.
  unique-id:
    name: Generate unique id
    runs-on: ubuntu-latest
    outputs:
      id: ${{ steps.generate.outputs.id }}
    steps:
      - id: generate
        run: |
          random48=$(LC_ALL=C < /dev/urandom tr -dC 0-9A-Za-z_- 2> /dev/null | head -c 8)
          echo "id=${{ github.repository }}/${{ github.run_id }}/$random48" >> "$GITHUB_OUTPUT"

  timeout:
    name: Wait for self-hosted runner
    needs:
      - unique-id
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.check.outputs.status }}
    steps:
      - id: check
        run: |
          timeout_s=10
          check_self_hosted_job_status() {
            GH_TOKEN=${{ secrets.GITHUB_TOKEN }} gh api /repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/jobs \
            | jq -er --arg id ${{ needs.unique-id.outputs.id }} '.jobs[] | select(.name | contains("[" + $id + "]")) | .status'
          }
          i=0; while [ $i -lt $timeout_s ]; do
            i=$((i + 1))
            sleep 1
            status=$(check_self_hosted_job_status)
            printf 'Self-hosted job status: %s (%d seconds left)\n' "$status" $((timeout_s - i))
            if [ "$status" != queued ]; then
              break
            fi
          done
          echo "status=$status" >> "$GITHUB_OUTPUT"

  github-hosted:
    name: Run job on GitHub-hosted runner

    # If the self-hosted job is still queued after the timeout job finishes,
    # cancel it and run this job instead.
    needs:
      - unique-id
      - timeout
    if: ${{ needs.timeout.outputs.status == 'queued' }}
    concurrency:
      group: ${{ needs.unique-id.outputs.id }}
      cancel-in-progress: true

    uses: ./.github/workflows/windows.yml
    with:
      self-hosted-runner: false
      profile: ${{ inputs.profile }}
      unit-tests: ${{ inputs.unit-tests }}
      upload: ${{ inputs.upload }}
      github-release-id: ${{ inputs.github-release-id }}

  self-hosted:
    # To reliably query the status of this job run in the timeout job, we need
    # to put our unique id in the friendly name.
    name: Run job on self-hosted runner [${{ needs.unique-id.outputs.id }}]
    needs:
      - unique-id

    concurrency:
      group: ${{ needs.unique-id.outputs.id }}
      cancel-in-progress: true

    uses: ./.github/workflows/windows.yml
    with:
      self-hosted-runner: true
      profile: ${{ inputs.profile }}
      unit-tests: ${{ inputs.unit-tests }}
      upload: ${{ inputs.upload }}
      github-release-id: ${{ inputs.github-release-id }}
