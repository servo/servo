name: Main

on:
  push:
    # Run the entire pipeline for 'master' even though the merge queue already runs checks
    # for every change. This just offers an extra layer of testing and covers the case of
    # random force pushes.
    branches: ["master", "try"]
  pull_request:
    types: ['opened', 'synchronize']
    branches: ["**"]
  merge_group:
    types: [checks_requested]
  workflow_dispatch:

jobs:
  decision:
    name: Decision
    runs-on: ubuntu-20.04
    outputs:
      skipped: ${{ steps.skipDecision.outputs.result }}
      platforms: ${{ steps.platformDecision.outputs.result }}
    steps:
      - name: Skip Decision
        id: skipDecision
        uses: actions/github-script@v6
        with:
          result-encoding: string
          script: |
            // Never skip workflow runs for pull requests or merge groups, which might
            // need to actually run / retry WPT tests.
            if (context.eventName == "pull_request" || context.eventName == "merge_group") {
              return "run";
            }
            // Skip the run if an identical run already exists. This helps to avoid running
            // the workflow over and over again for the same commit hash.
            if ((await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: "main.yml",
              head_sha: context.sha,
              status: "success",
            })).data.workflow_runs.length > 0) {
              return "skip"
            } else {
              return "run"
            }
      - name: Platform Decision
        id: platformDecision
        uses: actions/github-script@v6
        with:
          result-encoding: string
          script: |
            if ("${{ steps.skipDecision.outputs.result }}" == "skip") {
              return "none";
            }
            if (context.eventName == "push" || context.eventName == "merge_group") {
              return "all";
            }
            return "linux"


  build-win:
    name: Windows
    needs: ["decision"]
    if: ${{ needs.decision.outputs.platforms == 'all' }}
    uses: ./.github/workflows/windows.yml
    with:
      unit-tests: true

  build-mac:
    name: Mac
    needs: ["decision"]
    if: ${{ needs.decision.outputs.platforms == 'all' }}
    uses: ./.github/workflows/mac.yml
    with:
      unit-tests: true

  build-linux:
    name: Linux
    needs: ["decision"]
    if: ${{ needs.decision.outputs.platforms == 'all' || needs.decision.outputs.platforms == 'linux' }}
    uses: ./.github/workflows/linux.yml
    with:
      wpt: 'test'
      layout: ${{ (github.event_name == 'push' || github.event_name == 'merge_group') && 'all' || 'none' }}
      unit-tests: ${{ github.event_name == 'push' || github.event_name == 'merge_group' }}

  build-result:
    name: Result
    runs-on: ubuntu-latest
    if: always()
    # needs all build to detect cancellation
    needs:
      - "decision"
      - "build-win"
      - "build-mac"
      - "build-linux"

    steps:
      - name: Mark skipped jobs as successful
        if: ${{ needs.decision.outputs.skipped == 'skip' }}
        run: exit 0
      - name: Mark the job as successful
        if: ${{ !contains(join(needs.*.result, ','), 'failure') && !contains(join(needs.*.result, ','), 'cancelled') }}
        run: exit 0
      - name: Mark the job as unsuccessful
        if: contains(join(needs.*.result, ','), 'failure') || contains(join(needs.*.result, ','), 'cancelled')
        run: exit 1
